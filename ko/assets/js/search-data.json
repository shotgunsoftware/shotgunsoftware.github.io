{
  "0": {
    "id": "0",
    "title": "Flow Production Tracking 툴킷 사용 시 3ds Max를 시작하면 충돌 오류가 발생하는 이유는 무엇입니까?",
    "content": "Flow Production Tracking 툴킷 사용 시 3ds Max를 시작하면 충돌 오류가 발생하는 이유는 무엇입니까?Flow Production Tracking 데스크톱이나 Flow Production Tracking 웹 사이트에서 3ds Max를 실행하면 하얀색 대화상자가 움직이지 않는 상태로 3ds Max가 멈추거나 다음 메시지가 나타날 수 있습니다.Microsoft Visual C++ Runtime Library (Not Responding)Runtime Error!Program: C: Program Files Autodesk 3ds Max 2016 3dsmax.exeR6034An Application has made an attempt to load the C runtime library incorrectly.Please contact the application's support team for more information.이는 보통 경로의 msvcr90.dll 버전이 3ds Max와 번들로 제공되는 Python 버전과 충돌하기 때문입니다. 솔루션먼저, 파이프라인 구성의 config/hooks 폴더로 이동하여 before_app_launch.py 파일을 생성합니다. 이 파일에서 다음을 붙여 넣습니다.&quot;&quot;&quot;Before App Launch HookThis hook is executed prior to application launch and is useful if you needto set environment variables or run scripts as part of the app initialization.&quot;&quot;&quot;import osimport tankclass BeforeAppLaunch(tank.get_hook_baseclass()):    &quot;&quot;&quot;    Hook to set up the system prior to app launch.    &quot;&quot;&quot;    def execute(self, **kwargs):        &quot;&quot;&quot;        The execute functon of the hook will be called to start the required application        &quot;&quot;&quot;        env_path = os.environ[&quot;PATH&quot;]        paths = env_path.split(os.path.pathsep)        # Remove folders which have msvcr90.dll from the PATH        paths = [path for path in paths if &quot;msvcr90.dll&quot; not in map(            str.lower, os.listdir(path))        ]        env_path = os.path.pathsep.join(paths)        os.environ[&quot;PATH&quot;] = env_path이제 파일을 저장합니다.그런 다음, 파이프라인 구성에서 config/env/includes/app_launchers.yml을 열고 launch_3dsmax 항목을 찾습니다. hook_before_app_launch: default를 hook_before_app_launch: '{config}/before_app_launch.py'로 바꿔야 합니다.이제 Flow Production Tracking 및 Flow Production Tracking 데스크톱에서 3ds Max가 올바로 실행될 것입니다. 그래도 문제가 발생하면 지원 사이트에서 도움을 요청하십시오.",
    "url": "/a7555f37/",
    "relUrl": "/a7555f37/"
  },
  "1": {
    "id": "1",
    "title": "About the Isolation Feature Set",
    "content": "What is the Isolation Feature SetThe isolation feature set combines our Cloud Hosted Platform with client-managed AWS resources to provide a solution that satisfies the most stringent security and privacy requirements. Clients retain control of their sensitive content without having to host Flow Production Tracking on their infrastructure.Leveraging the isolation feature set has the following advantages over the Standard offering:  Media Isolation by hosting of assets and attachments in a client-owned S3 Bucket  Media Traffic Isolation from the public internet  Media Replication allowing you to replicate media in one additional AWS Region  Access to fully managed Flow Production Tracking Cloud Services  Automatic and continuous version upgrades  Ephemeral compute + in-memory segration between clientsIn a nutshell, this means that with the isolation features, your Flow Production Tracking site and the data related to it cannot be reached by anyone outside of your studio network.The isolation feature set is a solution that requires less upkeep, as well as less IT/System Administrator knowledge and skills, than hosting Flow Production Tracking on-premise. The list of advantages compared to on-premise includes, but is not limited to:  No Flow Production Tracking specific knowledge required  No manual Flow Production Tracking updates required  Very low level of maintenance required for the AWS componentsMedia isolation featureMedia Isolation allows your studio to keep the ownership and control of the media and attachments that you upload to Flow Production Tracking. With Media Isolation, all the content that you upload to Flow Production Tracking can be store in your studio private S3 bucket. Access to the media is provided to the Flow Production Tracking service only, using AWS AssumeRole keyless Security Token Service. Your studio remains in control of the assets and the access to the assets, access that you can revoke at will.Traffic isolation featureMedia traffic isolation feature can be enabled to prevent your media traffic from being routed on the public internet, limiting it to the AWS backbone and your studio network. The traffic between Flow Production Tracking Services and your studio stays in closed network, never going outside AWS or your Studio network.With the Media Traffic Isolation feature activated, the media will only leave your studio infrastructure once to get transcoded.Media ReplicationFlow Production Tracking is compatible with the S3 Cross-Region replication feature, allowing your users located in different regions to read from the region closer to them in order to reduce latency and increase throughput. Replication to one region is currently supported.EligibilityThe Isolation feature set is available to clients with an active Flow Production Tracking subscription. See Getting Started for more details about how to active the different features. The activation of the isolation feature set is not instantaneous, and requires manual setup involving your AWS account.What the Isolation Feature Set is notThe isolation feature set is not a completely isolated solution. Both the compute services and the database services are shared amongst clients, and managed by Flow Production Tracking. From a hardware standpoint, the isolation features does not guarantee complete physical isolation. However, Flow Production Tracking services are guaranteeing isolation at the memory level. Processes are never reused to answer requests from different clients during their lifetime. Client metadata is stored in different databases. Client media is individually stored on S3.High Level ArchitectureThe Flow Production Tracking cloud service  can be decoupled at a high level in 3 parts:Compute Stack: The part of the Flow Production Tracking Service that handles client requests and serves data to the client.Data Stack: Metadata storage (databases).Media Storage: Where the client’s attachments, media, and assets are stored. Flow Production Tracking uses AWS S3 to store client content.Please read Securing Studio IP in AWS: Cloud-based VFX Project Management with Autodesk Flow Production Tracking for more details about the architecture.Ephemeral compute and memory isolationEven if clients share the same infrastructure, Flow Production Tracking guarantees a complete memory isolation, both in transit and at rest, of client data. This makes Flow Production Tracking less prone to data leaking due to architecture flaws or software vulnerabilities exploiting memory, like buffer overflow.Ephemeral transcodingEverytime media is uploaded to Flow Production Tracking, the transcoding service is invoked to create a web friendly versions of your assets. That process happens only once, after the initial upload. The media is directly uploaded from the client to S3, from where it is fetched by the Flow Production Tracking Transcoding Service. Each transcoding job is handled by a single container, which is killed after that unique job. The only place the media temporarily lives is in the container memory. The Flow Production Tracking Transcoding service doesn’t store permanently a copy of your media.",
    "url": "/84dfd5cc/",
    "relUrl": "/84dfd5cc/"
  },
  "2": {
    "id": "2",
    "title": "커스텀 액션 메뉴 항목",
    "content": "커스텀 액션 메뉴 항목API 개발자는 액션 메뉴 항목(AMI)을 통해 엔티티별로 상황에 맞는 메뉴 항목을  커스터마이즈할 수 있습니다. 예를 들어, 여러 버전을 선택하고 마우스 오른쪽 버튼을 클릭한 다음 “PDF 보고서 작성(Build a PDF Report)”을 선택할 수 있습니다.액션 메뉴 항목 필드1. 제목(Title)(title): 메뉴 항목의 표시 이름입니다.2. 엔티티 유형(Entity Type)(entity_type): 메뉴 항목을 한 가지 엔티티 유형의 페이지(예: 버전(Version))에만 나타나도록 제한합니다. 이 키를 생략(nil 값)하면 메뉴 항목이 모든 활성화된 엔티티에 허용됩니다.3. URL(url): PDF 보고서를 생성하는 스크립트의 URL입니다.4. 순서(Order)(list_order): 메뉴 항목의 순서입니다(다른 커스텀 메뉴 항목에 상대적임).5. 경량 페이로드(Light Payload)(light_payload): 커스텀 프로토콜을 사용하는 경우 스크립트가 전체 페이로드 대신 페이로드 정보를 보관하는 이벤트 로그 항목 레코드의 ID를 수신합니다.6. 구성 메뉴 옵션: 다음과 같은 몇 가지 옵션 중에서 선택할 수 있습니다.      엔티티 레코드의 마우스 오른쪽 버튼 클릭 메뉴에 포함: 레코드를 마우스 오른쪽 버튼으로 클릭하여 AMI를 포함하는 기본값입니다.         엔티티 페이지의 “엔티티 추가(Add Entity)” 드롭다운 메뉴에 포함: 엔티티 추가(Add Entity)” 드롭다운 메뉴에 이 AMI를 포함하는 옵션입니다(예: “에셋 추가(Add Asset)”, “샷 추가(Add Shot)” 등).         엔티티 페이지에서 “엔티티 추가(Add Entity)” 버튼 재정의: 이 옵션을 사용하면 “엔티티 추가(Add Entity)” 버튼을 AMI로 덮어쓸 수 있습니다.         사용자 메뉴의 내부 리소스(Internal Resources) 섹션에 포함: 내부 리소스를 사용하여 사용자 메뉴를 커스터마이즈할 수 있는 옵션이 제공됩니다. 내부 리소스를 사용하여 사용자 메뉴를 커스터마이즈하는 방법에 대한 자세한 내용은 여기를 참조하십시오.  7. 폴더(Folder)(folder): 상황에 맞는 메뉴 내 폴더에 AMI를 구성할 수 있습니다(현재로서는 단일 수준의 폴더만 지원됨). 8. 모달 오버레이에서 열기(Open in Modal Overlay): AMI가 새 탭 대신 iframe 창에서 열리도록 합니다. 참고로, Flow Production Tracking가 HTTPS를 실행 중인 경우 모든 iframe도 HTTPS여야 합니다.9. 데이터 업데이트 폴링(Poll for Data Updates)(poll_for_data_updates): 이벤트 로그 항목을 쿼리하는 폴링 루프를 시작합니다. 액션 메뉴 항목의 다른 쪽에 있는 코드가 API를 통해 Flow Production Tracking에 다시 액션 메뉴 항목을 트리거한 페이지에 표시되는 엔티티에 대한 변경 작업을 수행하는 경우에 해당합니다.10. 권한 그룹으로 제한(Restrict to Permission Groups)(permissions_groups): 지정된 권한 그룹만 AMI에 액세스하도록 제한할 수 있습니다. 비워 두면 모든 사용자가 AMI를 사용할 수 있습니다.11. 프로젝트로 제한(Restrict to Projects)(projects): AMI가 지정된 프로젝트에만 표시되도록 합니다. 비워 두면 AMI를 모든 프로젝트에서 사용할 수 있습니다.12. 비밀 토큰(Secret Token): 비밀 토큰을 설정하여 AMI를 보호합니다.13. 선택 필요(Selection Required)(selection_required): 현재 선택된 행이 없는 경우 메뉴 항목이 활성화되는지 여부를 결정합니다.액션 메뉴 항목 유형생성할 수 있는 메뉴 항목 유형은 두 가지입니다.HTTP URL 예시한 예로, “PDF 보고서 작성(Build a PDF Report)”이라는 커스텀 메뉴 항목을 생성할 수 있습니다. 이렇게 하면 사람들이 버전 페이지로 이동하여 하나 이상의 버전을 선택하고 마우스 오른쪽 버튼을 클릭한 다음 Flow Production Tracking 메뉴에서 “PDF 보고서 작성(Build a PDF Report)”을 선택할 수 있습니다. 그러면 스크립트(사용자가 생성해야 함)가 실행되면서 깔끔한 형식의 보고서가 브라우저로 다시 전송됩니다. 작동 방식은 다음과 같습니다.UI를 통해 메뉴 항목 생성설정(Settings) 메뉴에서 액션 메뉴 항목(Action Menu Items)을 선택하여 AMI 관리자(AMI Admin) 페이지를 엽니다.새 AMI를 생성하려면 를 클릭합니다.제목(Title) 및 기타 필수 필드를 입력하고, “액션 메뉴 항목 만들기(Create Action Menu Item)”를 클릭합니다.사용자가 AMI를 클릭하면 어떻게 될까요?Flow Production Tracking 소프트웨어가 새 창에서, 또는 해당 옵션을 선택한 경우 모달 대화상자에서 POST 요청을 발송하고, 현재 페이지에서 수신 URL로 데이터를 함께 전송합니다(POST 요청의 일부로 전송). 다음은 이 워크플로우의 예입니다.  사용자가 버전 페이지로 이동  사용자가 하나 이상의 버전 선택  사용자가 상황에 맞는 메뉴 호출(마우스 오른쪽 버튼 클릭 또는 도구막대에서 기어 메뉴 클릭)  사용자가 ‘PDF 보고서 작성(Build a PDF Report)’ 클릭  Flow Production Tracking 소프트웨어가 새 창에서 AMI의 URL로 POST 요청 발송(Flow Production Tracking 서버는 HTTPS에서 구동되고, 사용자 URL은 HTTP에서 구동되는 경우에는 브라우저 경고가 표시될 수 있음)  지정된 URL에 위치한 사용자 스크립트가 POST 데이터를 처리하고, PDF 문서 생성  사용자가 보거나 다운로드할 수 있는 깔끔한 형식의 PDF 보고서가 사용자에게 다시 전송됨커스텀 프로토콜 처리기 예시커스텀 AMI를 한 차원 높게 구현하는 작업에는 커스텀 프로토콜 처리기(예: Flow Production Tracking://process_version)를 설정하는 작업이 수반됩니다. 이렇게 하면 로컬 컴퓨터에서 스크립트를 통해 Flow Production Tracking 소프트웨어를 Maya, RV 또는 Cinesync 같은 응용프로그램과 연동할 수 있습니다. 비-HTTP(S) 프로토콜을 지정하면 데이터가 POST 대신 GET을 통해 사용자 URL로 전송됩니다. 이 방법을 사용하여 내부 도구를 실행하고 다양한 요청을 발송할 수도 있습니다.커스텀 프로토콜에 관한 자세한 정보는 커스텀 브라우저 프로토콜을 사용하여 응용프로그램 실행을 참조하십시오.  참고: Flow Production Tracking 통합을 통해 Maya 및 기타 소프트웨어 패키지와의 통합도 기본 제공합니다.  경량 페이로드커스텀 프로토콜 사용 시 쿼리 정보는 GET 요청으로 전송됩니다. 특정 운영 체제와 브라우저 조합에 따라 허용되는 GET 요청 크기에 다양한 제약이 있습니다. 그래서 커스텀 프로토콜 AMI에서 경량 페이로드 체크박스를 선택하는 것이 좋습니다. 경량 페이로드를 선택한 상태에서는 스크립트가 단일 이벤트 로그 항목 ID를 수신하고, 이를 불러와 레코드 meta 필드의 ami_payload 키를 읽어 풀 페이로드를 가져올 수 있습니다.예다음은 시작하는 데 도움이 될 만한 몇 가지 관련 예시 스크립트입니다.  액션 메뉴 항목 호출 처리  버전 패키저페이로드 컨텐츠사용자 데이터  user_id: 현재 로그인한 사용자의 사용자 ID(예: 34)  user_login: 현재 로그인한 사용자의 로그인 정보(예: joe)엔티티 데이터  entity_type: 현재 페이지 또는 뷰의 엔티티 유형(예: 버전)  selected_ids: 선택한 엔티티 ID를 쉼표로 분리한 목록(예: 931, 900)  ids: 현재 페이지의 쿼리에서 반환된 모든 엔티티 ID를 쉼표로 분리한 목록. 이는 페이지 매김 때문에 보이지 않는 항목을 포함한 모든 ID를 반환합니다(예: 931, 900, 904, 907). AMI에서 “선택 필수(Selection required)”를 선택한 경우 이 값은 selected_ids와 같아집니다.페이지 데이터  title: 페이지 제목(예: “모든 버전”)  page_id: 액션 메뉴 항목이 클릭된 페이지의 ID(예: 1353)  server_hostname: AMI가 트리거된 시스템의 호스트 이름. 스테이징 서버와 프로덕션 서버 등 같은 AMI를 호출하는 여러 서버가 있는 경우 유용할 수 있습니다.  referrer_path: AMI가 호출된 URL의 정규 경로.  session_uuid: 이 AMI가 호출된 창의 고유 식별자. 이 기능은 “데이터 업데이트 폴링(Poll for Data Updates)” 체크박스 및 Python API의 set_session_uuid 메서드와 함께 사용하여 AMI가 호출된 페이지로 정보를 다시 브로드캐스트할 수 있습니다. 참고: 이 기능의 업데이트 폴링은 기하급수적으로 감소하며, 폴링이 중지될 때까지 AMI가 업데이트되지 않으면 결국 중지되어 소스 페이지에서 업데이트를 볼 수 없게 될 수도 있습니다.  cols: 페이지에 표시되는 모든 열의 시스템 필드 이름을 쉼표로 분리한 목록(예: code, sg_status_list, description)  column_display_names: 페이지에 표시되는 모든 열의 표시 이름을 쉼표로 분리한 목록(예: 버전, 상태, 설명)  view: AMI가 호출되었을 때 선택했던 뷰. 페이지 디자인 모드를 통해 특정 페이지에 대한 여러 뷰를 생성할 수 있습니다.  sort_column: 정렬 기준이 된 열의 시스템 이름(예: code). 정렬 키가 여러 개인 경우 첫 번째 키만 전송합니다(sort_columns 참조).  sort_direction:(예: asc 또는 desc) 정렬 방향이 여러 개인 경우 첫 번째 방향만 전송합니다(sort_directions 참조).  sort_columns: 페이지 또는 뷰의 정렬 기준이 된 열의 시스템을 이름을 쉼표로 분리한 목록(예: code,created_at). 정렬 키가 여러 개인 경우에만 전송됩니다.  sort_directions: 페이지 또는 뷰의 정렬 기준이 된 열의 시스템을 이름을 쉼표로 분리한 목록(예: code,created_at). 정렬 키가 여러 개인 경우에만 전송됩니다.  grouping_column: 그룹 지정 기준이 된 열의 시스템 이름(예: code). 그룹 지정 열이 여러 개인 경우 첫 번째 열만 전송됩니다(grouping_columns 참조).  grouping_method: 그룹 지정이 이루어진 방식(예: 엔티티 필드의 경우 entitytype, 날짜 필드의 경우 month 방식으로 그룹 지정). 그룹 지정 메서드가 여러 개인 경우 첫 번째 메서드만 전송됩니다(grouping_columns 참조).  grouping_direction: 그룹 지정 방향(예: asc 또는 desc). 그룹 지정 방향이 여러 개인 경우 첫 번째 방향만 전송됩니다(grouping_directions 참조).  grouping_columns: 데이터의 그룹 지정 기준이 된 열의 시스템 이름을 쉼표로 분리한 목록(예: code,created_at). 그룹 지정 열이 여러 개인 경우에만 전송됩니다.  grouping_methods: 그룹 지정 방식을 쉼표로 분리한 목록(예: entity_type,month). 그룹 지정 열이 여러 개인 경우에만 전송됩니다.  grouping_directions: 그룹 지정 방향을 쉼표로 분리한 목록(예: asc,desc). 그룹 지정 열이 여러 개인 경우에만 전송됩니다.프로젝트 데이터(현재 페이지의 모든 엔티티가 같은 프로젝트를 공유하는 경우에만 전송)  project_name: 프로젝트의 이름(예: Gunslinger)  project_id: 프로젝트의 ID(예: 81)내부 리소스(Internal Resources) 메뉴사용자 메뉴에서 내부 리소스에 대해 액션 메뉴 항목을 활용하는 방법에 대한 자세한 내용은 관리자 안내서를 참조하십시오.",
    "url": "/67695b40/",
    "relUrl": "/67695b40/"
  },
  "3": {
    "id": "3",
    "title": "액션 메뉴 항목",
    "content": "액션 메뉴 항목이 섹션에는 커스텀 AMI(액션 메뉴 항목) 만들기 및 커스텀 브라우저 프로토콜을 사용한 응용프로그램 실행에 대한 정보가 포함됩니다.  커스텀 액션 메뉴 항목  커스텀 브라우저 프로토콜을 사용하여 응용프로그램 실행사용자 메뉴에서 내부 리소스에 대해 액션 메뉴 항목을 활용하는 방법에 대한 자세한 내용은 관리자 안내서를 참조하십시오.",
    "url": "/581648bb/",
    "relUrl": "/581648bb/"
  },
  "4": {
    "id": "4",
    "title": "Activation",
    "content": "ActivationOnce everything is configured and properly tested, it’s now time to migrate your production site to use the isolation features.TestNavigate to the /admin/speedtest route of your Flow Production Tracking site. Select the new S3_CONFIG_NAME that was just set up previously and start the test to confirm that all the upload/download tests work as intended.Switch to your own Isolation S3 BucketNavigate to the Advanced section of Site Preferences page and set the storage location to your own S3 bucket.",
    "url": "/47ecbf94/",
    "relUrl": "/47ecbf94/"
  },
  "5": {
    "id": "5",
    "title": "관리",
    "content": "관리툴킷 설정 관리 및 구성을 기반으로 한 빠른 답변 모음입니다.Flow Production Tracking 데스크톱:  Flow Production Tracking 데스크톱을 사용하여 툴킷 프로젝트를 다시 설정하려면 어떻게 해야 합니까?  Windows에서 Flow Production Tracking 데스크톱을 자동으로 설치하려면 어떻게 해야 합니까?  Linux에서 Flow Production Tracking 데스크톱의 데스크톱/시작 관리자 아이콘을 어떻게 설정합니까?  Flow Production Tracking 데스크톱의 브라우저 통합을 어떻게 비활성화할 수 있습니까?구성 관리:  여러 개의 저장소 루트를 사용하도록 구성을 수정하려면 어떻게 해야 합니까?  파이프라인 구성을 새 위치로 이동하려면 어떻게 해야 합니까?  내 프로젝트 디렉토리를 새 로컬 저장소 루트로 어떻게 옮깁니까?  파이프라인 구성 코어 위치를 업데이트하려면 어떻게 해야 합니까?  프로젝트 간에 에셋을 어떻게 공유합니까?  앱 또는 엔진을 어떻게 제거합니까?캐시 기반 질문:  경로 캐시가 무엇입니까? 파일 시스템 위치가 무엇입니까?  내 캐시는 어디에 있습니까?",
    "url": "/ba09d04c/",
    "relUrl": "/ba09d04c/"
  },
  "6": {
    "id": "6",
    "title": "관리",
    "content": "관리ShotGrid의 파이프라인 통합은 방대한 커스터마이제이션 옵션 세트를 제공합니다. 스튜디오에서 원하는 파이프라인을 시작하고 실행하려면 구성, 명령줄 도구 실행, Flow Production Tracking 도구가 스튜디오 환경에서 작동하도록 하는 등의 작업을 수행해야 합니다.이 섹션에서는 스튜디오의 Flow Production Tracking 툴킷 파이프라인 관리에 대한 내용을 소개합니다.",
    "url": "/a944bb05/",
    "relUrl": "/a944bb05/"
  },
  "7": {
    "id": "7",
    "title": "고급 툴킷 관리",
    "content": "고급 툴킷 관리고급 구성을 위한 툴킷을 관리하고 구성하는 방법을 소개합니다.이 항목의 내용:  소개  tank 명령 사용          디버그 모드로 실행      Tookit API를 통해 tank 명령 실행      유용한 tank 명령                  setup_project          core          configurations          updates          install_app, install_engine          app_info          folders, preview_folders          shell          dump_config 고급 tank 명령                      툴킷 Python API  파이프라인 구성 및 샌드박스          샌드박스용 tank 명령 실행      샌드박스에서 Core API 사용      샌드박스 액세스      파이프라인 구성 현지화      복제한 구성 삭제        업데이트 확인          스테이징 샌드박스 만들기        앱 시작 방법 구성  디스크에 폴더 만들기          파일 시스템 위치      툴킷 폴더 이름 바꾸기      생성 유예 및 사용자 샌드박스        템플릿 구성          템플릿 파일의 @include 구문      템플릿 파일에 외부 파일 포함      폴더 생성 및 템플릿        후크          앱 레벨 후크      코어 레벨 후크      스튜디오 레벨 후크      프로젝트 이름 후크      연결 후크        앱 및 엔진 구성          각 앱에는 위치 설정이 있음      파일 포함      템플릿 설정 구성 - 파일 경로      후크를 사용하여 앱 동작 커스터마이즈      소개Flow Production Tracking 툴킷 관리자 안내서입니다. 이 문서에서는 관리적인 관점에서 Flow Production Tracking Toolkit을 사용하여 앱을 설치 및 업데이트하고, 새 프로젝트를 설정하고, 스튜디오 구성을 관리하는 방법을 설명합니다. 툴킷은 비교적 기술적인 부분이므로 구성 및 관리 담당자가 sysadmin, 파이프라인/도구 개발자 또는 TD라고 가정합니다. 자세한 설명을 시작하기 전에 필요하면 다음 문서를 읽어 보시기 바랍니다. 많은 기본 개념을 다루고 구성 관리 및 업데이트에 대해 간략하게 소개합니다.Flow Production Tracking Toolkit의 기본 개념 소개아직 Flow Production Tracking 툴킷으로 설정하지 않은 경우 통합 사용자 안내서를 읽는 것이 좋습니다.tank 명령 사용일반적으로 Flow Production Tracking 툴킷을 관리하고 사용할 때 tank 명령을 사용하는 것이 좋습니다. tank 명령을 사용하면 관리 명령과 실제 앱을 명령 셸에서 쉽고 빠르게 실행할 수 있습니다.기본적으로 새로 만든 각 프로젝트에는 자체 독립적인 Core API와 함께 고유한 tank 명령도 있습니다. 간단히 프로젝트 구성 위치로 이동하여 tank 명령을 실행하면 해당 프로젝트에 적용 가능한 모든 명령을 볼 수 있습니다.cd /mnt/software/ShotGrid/big_buck_bunny./tanktank 명령은 다양한 방법으로 사용할 수 있습니다. 기본 개념은 먼저 tank 명령에 작동 위치와 수행할 작업을 지정하는 것입니다. 수행할 작업을 지정하지 않으면 사용 가능한 모든 명령 목록이 표시됩니다. 작동 위치를 지정하지 않으면 현재 디렉토리가 사용됩니다. tank 명령을 사용하여 Flow Production Tracking 항목을 나열할 수도 있습니다.tank 명령 사용 방법에 대한 기본 개요:# Show all tank commands for an asset named 'piano'&amp;gt; tank Asset piano# We can also list all assets containing the phrase 'pi'&amp;gt; tank Asset pi# We can execute the built-in folder creation command for# the piano&amp;gt; tank Asset piano folders# If the application launcher app is installed, we can launch maya# and set the work area to the piano&amp;gt; tank Asset piano launch_maya# Alternatively, we can specify a path on disk instead of a Flow Production Tracking entity&amp;gt; tank /mnt/projects/hero/assets/piano launch_maya# Or we can change our work directory and run tank like this&amp;gt; cd /mnt/projects/hero/assets/piano launch_maya&amp;gt; tank launch_maya디버그 모드로 실행내부적으로 수행되는 작업을 확인하는 것이 유용할 때도 있습니다. --debug 플래그를 tank 명령에 전달할 수 있으며 이를 통해 상세한 출력 및 타이밍을 가능하게 하고 쉽게 문제를 트래킹하거나 작업이 예상대로 수행되지 않는 이유를 이해할 수 있습니다.Tookit API를 통해 tank 명령 실행또한 대부분의 tank 명령은 API를 통해 실행되도록 완전히 지원됩니다. 이를 실행하여 보다 광범위한 스크립팅 워크플로우의 일부로 툴킷 관련 유지 관리 작업을 쉽게 수행할 수 있습니다. 이를 실행하는 방법에 대한 자세한 정보는 Core API 참조를 참조하십시오.유용한 tank 명령다음은 Flow Production Tracking 툴킷을 관리할 때 사용할 수 있는 유용한 tank 명령 목록입니다.setup_projectFlow Production Tracking 데스크톱에 있는 프로젝트 설정 마법사의 명령행 버전입니다. Flow Production Tracking 툴킷으로 새 프로젝트를 설정합니다. Flow Production Tracking에 프로젝트가 있고 툴킷을 사용하도록 확장하려고 할 때 이 설정으로 시작합니다. 이 명령은 프로세스를 통해 안내하며 사용할 구성 및 설정할 프로젝트와 같은 다양한 정보를 요청합니다.동일한 프로젝트에서 setup_project 다시 실행기본적으로 setup_project는 아직 설정되지 않은 프로젝트만 나열합니다. 그러나 동일한 프로젝트에서(특히 테스트하는 동안) setup_project를 다시 실행해야 하는 경우가 종종 있습니다. 이는 이전에 이미 설정한 프로젝트를 식별하는 노트와 함께 모든 프로젝트를 나열하는 –force 플래그를 전달하여 수행할 수 있습니다.&amp;gt; tank setup_project --forceWelcome to SGTK!For documentation, see https://developer.shotgridsoftware.com- Running setup_project...force mode: Projects already set up with Toolkit can be set up again.Welcome to SGTK Project Setup!Connecting to Flow Production Tracking...Connecting to the App Store...------------------------------------------------------------------Which configuration would you like to associate with this project?You can use the configuration from an existing project as a template for thisnew project. All settings, apps and folder configuration settings will becopied over to your new project. The following configurations were found:   big_buck_bunny: '/mnt/software/sgtk/big_buck_bunny'   ghosts: '/mnt/software/sgtk/ghosts'   chasing_perfection: '/mnt/software/sgtk/chasing_perfection'If you want to use any of the configs listed about for your new project, justtype in its path when prompted below.You can use the Default Configuration for your new project.  The defaultconfiguration is a good sample config, demonstrating a typical basic setup ofthe Flow Production Tracking Toolkit using the latest apps and engines. This will beused by default if you just hit enter below.If you have a configuration stored somewhere on disk, you can just enter thepath to this config it will be used for the new project.[tk-config-default]:Downloading Config tk-config-default v0.4.15 from the App Store...This is the 'Default Config' config.Below are all active projects, including ones that have been set up:--------------------------------------------------------------------[ 4] Demo Project     Fubar is an epic story of an on-going political wa...[ 5] Big Buck BunnyNote: This project has already been set up.     A killer bunny movie[ 6] The Ghosts of Pere LachaiseNote: This project has already been set up.     De Films en Aiguille and ChezEddy present this year...[ 7] Chasing PerfectionNote: This project has already been set up.     You've seen the car commercials, the car races, and...[ 8] What Happened to My Headphones?     The Ryan Mayeda storyPlease type in the id of the project to connect to or ENTER to exit:툴킷은 프로젝트 설정 프로세스의 일부로 프로젝트 이름을 제안합니다. 이름에 만족하면 Enter 키를 눌러 계속 진행하고 만족하지 않은 경우 다른 이름을 직접 입력합니다.프로젝트에 대해 특별한 스튜디오 이름 지정 규칙이 있는 경우 프로젝트 설정 프로세스에서 제안하는 기본값을 제어할 수도 있습니다. 이 작업은 고급 스튜디오 레벨 후크를 통해 수행됩니다. 자세한 정보는 이 문서 뒷부분의 스튜디오 레벨 후크 섹션을 참조하십시오.coreCore API 업데이트를 확인합니다. 이 명령은 App Store에 연결하여 최신 버전의 Core API가 있는지 확인합니다. Core API가 있는 경우 업데이트할 것인지 묻습니다.이 명령의 출력 예:&amp;gt; tank coreWelcome to Sgtk!Starting Sgtk for your current directory '/private/tmp'- Running core...WARNING: You are potentially about to update the Core API for multipleprojects.Welcome to the Sgtk update checker!This script will check if the Sgtk Core APIinstalled in /mnt/software/sgtk/studiois up to date.You are currently running version v0.13.22 of the Sgtk PlatformNo need to update the Sgtk Core API at this time!configurations프로젝트의 모든 구성에 대한 개요를 제공합니다. 이 명령은 프로젝트의 현재 액티비티를 분석하고자 할 때 유용할 수 있습니다.이 명령의 출력 예:&amp;gt; tank Project Bunny configurationsWelcome to Sgtk!Will search across all Flow Production Tracking Projects.- Found Project Big Buck Bunny- Starting Sgtk v0.13.22 using configuration/mnt/software/sgtk/big_buck_bunny.- Setting the Context to Big Buck Bunny.- Running configurations...Fetching data from Flow Production Tracking...======================================================================Available Configurations for Project 'Big Buck Bunny'======================================================================Configuration 'Primary' (Public)-------------------------------------------------------This is the Project Master Configuration. It will be used whenever thisproject is accessed from a studio level sgtk command or API constructor.Linux Location:  /mnt/software/sgtk/big_buck_bunnyWinows Location: z: mnt software sgtk big_buck_bunnyMac Location:    /mnt/software/sgtk/big_buck_bunnyThis configuration is using a shared version of the Core API.If you want it torun its own independent version of the Toolkit Core API, you can run:&amp;gt; /mnt/software/sgtk/big_buck_bunny/tank localizeIf you want to check for app or engine updates, you can run:&amp;gt; /mnt/software/sgtk/big_buck_bunny/tank updatesIf you want to change the location of this configuration, you can run:&amp;gt; /mnt/software/sgtk/big_buck_bunny/tank move_configurationThis is a public configuration. In Flow Production Tracking, the actions defined in thisconfiguration will be on all users' menus.Configuration 'Dev Area' (Private)-------------------------------------------------------Linux Location:  /Users/manne/sgtk_devWinows Location: z: Users manne sgtk_devMac Location:    /Users/manne/sgtk_devThis configuration is using a shared version of the Core API.If you want it torun its own independent version of the Toolkit Core API, you can run:&amp;gt; /Users/manne/sgtk_dev/tank localizeIf you want to check for app or engine updates, you can run:&amp;gt; /Users/manne/sgtk_dev/tank updatesIf you want to change the location of this configuration, you can run:&amp;gt; /Users/manne/sgtk_dev/tank move_configurationThis is a private configuration. In Flow Production Tracking, only Admin 3 will see the actionsdefined in this config. If you want to add additional members to thisconfiguration, navigate to the SG Pipeline Configuration Page and addthem to the Users field.updates이 명령은 프로젝트와 관련된 모든 환경에 사용 가능한 최신 버전의 앱 또는 엔진이 있는지 확인합니다. 앱과 엔진의 설치 방법에 따라 이 업데이트 프로그램이 로컬 git 리포지토리, Github 또는 Flow Production Tracking 툴킷 App Store에 대해 검사를 진행할 수 있습니다. 최신 버전이 검색되면 설정을 업데이트할지 묻습니다. 새로운 구성 매개변수가 새 버전의 앱에 도입된 경우 값을 묻는 메시지가 나타날 수 있습니다.일반 구문:&amp;gt; tank updates [environment_name] [engine_name] [app_name]특수 키워드 ALL을 사용하여 한 범주의 모든 항목을 나타낼 수 있습니다. 예:  모든 항목 검사: tank updates  샷 환경 검사: tank updates Shot  모든 환경의 모든 Maya 앱 검사: tank updates ALL tk-maya  샷 환경의 모든 Maya 앱 검사: tank updates Shot tk-maya  모든 위치에서 Loader 앱이 최신 버전인지 확인: tank updates ALL ALL tk-multi-loader  Maya에서 Loader 앱이 최신 버전인지 확인: tank updates ALL tk-maya tk-multi-loaderinstall_app, install_engine프로젝트와 관련된 환경 중 하나에 새 엔진 또는 앱을 설치합니다. 이 명령을 사용하여 툴킷 App Store 또는 git에서 설치할 수 있습니다.app_info모든 앱과 주요 구성 설정에 대한 분석 보기folders, preview_folders디스크에 항목에 대한 폴더를 만듭니다.이 명령의 출력 예Welcome to Sgtk!Will search across all Flow Production Tracking Projects.- Found Asset Squirrel (Project 'Big Buck Bunny')- Starting Sgtk v0.13.22 using configuration/mnt/software/sgtk/big_buck_bunny.- Setting the Context to Asset Squirrel.- Running folders...Creating folders, stand by...The following items were processed: - /mnt/projects/big_buck_bunny - /mnt/projects/big_buck_bunny/reference - /mnt/projects/big_buck_bunny/reference/artwork - /mnt/projects/big_buck_bunny/reference/footage - /mnt/projects/big_buck_bunny/sequences - /mnt/projects/big_buck_bunny/assets - /mnt/projects/big_buck_bunny/assets/Character - /mnt/projects/big_buck_bunny/assets/Character/Squirrel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/sgtk_overrides.yml - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/elements - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/photoshop/jpg - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/photoshop/psd - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/reference - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/reference/artwork - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/reference/footage - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/review - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/images - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/maya/workspace.mel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/maya/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/nuke/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/photoshop/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/elements - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/photoshop/jpg - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/photoshop/psd - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/reference - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/reference/artwork - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/reference/footage - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/review - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/images - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/maya/workspace.mel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/maya/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/nuke/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/photoshop/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/elements - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/photoshop/jpg - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/photoshop/psd - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/reference - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/reference/artwork - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/reference/footage - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/review - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/images - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/maya/workspace.mel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/maya/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/nuke/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/photoshop/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/elements - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/photoshop/jpg - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/photoshop/psd - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/reference - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/reference/artwork - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/reference/footage - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/review - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/images - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/maya/workspace.mel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/maya/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/nuke/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/photoshop/snapshotsIn total, 93 folders were processed.shell현재 선택된 컨텍스트에서 대화식 Python 셸을 시작합니다. 미리 초기화된 API, 컨텍스트 및 엔진 객체에 대한 유용한 참조를 설정합니다. ./tank shell을 사용하여 툴킷 및 Flow Production Tracking API 코드 예제를 테스트해 볼 수 있습니다. tank 실행 파일은 로컬 컴퓨터의 파이프라인 구성 루트에 있으며 다음과 같이 표시됩니다.&amp;gt; cd /my_tank_configs/project_foobar이 명령의 출력 예:Welcome to SGTK!For documentation, see https://developer.shotgridsoftware.comYou are running a tank command associated with Flow Production Tracking Project 'Chasing theLight'. Only items associated with this project will be considered.- Found Shot moo87 (Project 'Chasing the Light')- Starting the SG pipeline toolkit v0.15.14.- Setting the Context to Shot moo87.- Started Shell Engine version v0.3.3- Environment: /mnt/software/tank/chasing_the_light/config/env/shot.yml.- Running shell...Welcome to SG Pipeline Toolkit Python!2.7.1 (r271:86832, Jul 31 2011, 19:30:53)[GCC 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2335.15.00)]Running on darwin- A tk API handle is available via the tk variable- A Shotgun API handle is available via the Shotgun variable- Your current context is stored in the context variable- The shell engine can be accessed via the engine variable&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; tk&amp;lt;Sgtk Core vHEAD@0x105f66990 Config /mnt/software/tank/chasing_the_light&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; context&amp;lt;Sgtk Context:   Project: {'type': 'Project', 'id': 88, 'name': 'Chasing the Light'}  Entity: {'type': 'Shot', 'id': 1184, 'name': 'moo87'}  Step: None  Task: None  User: {'type': 'HumanUser', 'id': 42, 'name': 'Manne  xc3 x96hrstr xc3 xb6m'}  Additional Entities: []&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Shotgun&amp;lt;tank_vendor.Shotgun_api3.Shotgun.Shotgun object at 0x105fb2990&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; engine&amp;lt;Sgtk Engine 0x105feead0: tk-shell, env: shot&amp;gt;&amp;gt;&amp;gt;&amp;gt;위의 예제에서 ./tank는 Python 셸을 시작하고 필요한 몇 가지 변수를 설정합니다. 이 명령은 위의 변수에 다음과 같은 핸들과 컨텍스트를 제공하므로 인증과 사용자 세션 설정 및 Flow Production Tracking 사이트에 대한 커넥션 시작과 같은 몇 가지 기초 작업을 수행하지 않아도 됩니다.  tk 변수에는 툴킷 API에 액세스할 수 있는 핸들이 있습니다.  Flow Production Tracking 변수에는 이미 사이트에 연결되고 데이터베이스 및 [Flow Production Tracking 사이트의 다른 항목을 쿼리할 준비가 된 Flow Production Tracking API에 대한 핸들이 있습니다.]  컨텍스트 변수는 현재 컨텍스트(프로젝트, 샷, 에셋, 파이프라인 단계, 사용자 등)를 참조합니다. 다음은 활성 컨텍스트의 예입니다. 이 예에서 컨텍스트 인스턴스는 현재 컨텍스트를 설명하는 일련의 주요 필드를 수집하는 데 사용됩니다. 컨텍스트를 현재 작업 영역이라고도 합니다. 일반적으로 컨텍스트는 사용자가 작업 중인 현재 샷 또는 에셋입니다. 이 예에서 프로젝트는 “Chasing the Light”이고, ID는 1184이며, 샷은 “moo87”임을 알 수 있습니다. 할당된 파이프라인 단계 또는 태스크는 없지만 사용자는 Manne입니다. 툴킷 API용 스크립트를 작성할 때 이 정보가 필요할 수도 있으며 이 유용한 컨텍스트 변수에서 모든 항목을 사용할 수 있습니다.&amp;lt;Sgtk Context:   Project: {'type': 'Project', 'id': 88, 'name': 'Chasing the Light'}     Entity: {'type': 'Shot', 'id': 1184, 'name': 'moo87'}     Step: None     Task: None     User: {'type': 'HumanUser', 'id': 42, 'name': 'Manne  xc3 x96hrstr xc3 xb6m'}     Additional Entities: []&amp;gt;engine 변수는 현재 실행 중인 셸 엔진의 인스턴스를 가리킵니다.dump_configCore v0.18에서 사용 가능합니다.기존 환경 구성을 STDOUT 또는 다른 파일에 덤프합니다. 구성의 전체 또는 스파스 표현을 덤프할 수 있습니다. 전체 표현에는 모든 설정의 기본값이 포함되지만 스파스 표현에는 설정의 기본값과는 다른 값만 포함됩니다. 기본적으로 명령의 출력에는 기본값이 있는 매니페스트를 기록한 각 설정의 코멘트가 포함되며 구성에 있는 항목과 다른 경우 기본값이 포함됩니다. 이 명령은 안전을 위해 기존 파일에 환경 구성을 덤프하는 것을 허용하지 않습니다.용도:./tank dump_config env_name [--sparse | --full] [--no_debug-comments] [--file=/path/to/output/file.yml]이 명령의 출력 예:&amp;gt; ./tank dump_config shot_step --sparse --file=/tmp/shot_step.ymlWelcome to SGTK!For documentation, see https://developer.shotgridsoftware.comStarting toolkit for path '/Shotgun/configs/sparse34913'- The path is not associated with any SG object.- Falling back on default project settings.- Running as user 'Toolkit'- Using configuration 'Primary' and Core HEAD- Setting the Context to sparse34913.- Running command dump_config...----------------------------------------------------------------------Command: Dump config----------------------------------------------------------------------Dumping config...위의 명령을 실행하면 현재 프로젝트의 shot_step 환경 파일에 대한 스파스 복사본이 /tmp/shot_step.yml에 기록됩니다.추가 디버그 코멘트를 제외하려면 --no_debug_comments 플래그를 사용합니다.고급 tank 명령다음은 Flow Production Tracking 툴킷을 관리할 때 사용할 수 있는 고급 tank 명령 목록입니다.      tank share_core - 새 프로젝트가 만들어지면 각 프로젝트가 독립적으로 Core API의 복사본을 유지하는 상태로 종종 만들어집니다. 이 명령을 사용하면 이러한 프로젝트의 코어를 가져와서 디스크의 별도 위치로 이동할 수 있습니다. 이렇게 하면 여러 개의 프로젝트가 Core API의 단일 복사본을 공유하는 공유 코어를 만들 수 있습니다.        tank attach_to_core - 새 프로젝트가 만들어지면 각 프로젝트가 독립적으로 Core API의 복사본을 유지하는 상태로 종종 만들어집니다. 이 명령을 사용하면 Core API의 자체 포함 버전을 유지 관리하지 않고 기존 Core API 설치에 구성을 연결할 수 있습니다.        tank localize - 이 명령은 Core API를 특정 파이프라인 구성 위치로 다운로드합니다. 이 방법은 툴킷 스테이징 영역 내에서 새 버전의 Core API를 테스트하려는 경우에 유용합니다. 이 문서에서 이 프로세스에 대해 자세히 설명합니다.        tank clear_cache - 툴킷의 일부 캐시를 지웁니다. 이 명령은 어떤 이유로든 Flow Production Tracking 내에 메뉴 항목이 나타나지 않는 경우 유용할 수 있습니다.        tank validate - 프로젝트 구성의 유효성을 확인합니다.        tank cache_apps - 필요한 모든 앱, 엔진 및 프레임워크 버전이 디스크에 있는지 확인합니다.        tank switch_app - 개발에 유용합니다. 앱을 App Store 모드에서 로컬 또는 git 모드로 전환하거나 그 반대로 전환합니다.        tank push_configuration - 현재 파이프라인 구성에 포함된 구성을 다른 파이프라인 구성으로 밉니다.  툴킷 Python APIFlow Production Tracking 데스크톱, tank 명령 또는 Flow Production Tracking를 사용하여 응용프로그램을 시작하는 경우 툴킷은 자동으로 PYTHONPATH에 추가되고 초기화됩니다. 툴킷 API를 수동으로 소싱하고 실행하는 것이 유용한 경우가 있습니다. Toolkit Core API를 pythonpath에 추가한 다음 가져와서 수행할 수 있습니다.각 프로젝트 구성에는 project_config_root/install/core/python 안에 python 폴더가 있습니다. 해당 위치를 Python 경로에 추가하기만 하면 sgtk API를 가져올 수 있습니다.import sgtk# create a Sgtk API object for a Flow Production Tracking entitytk = sgtk.sgtk_from_entity(&quot;Shot&quot;, 123)# Create a Sgtk API object based on a file system locationtk = sgtk.sgtk_from_path(&quot;/mnt/projects/hero/assets/chair&quot;)파이프라인 구성 및 샌드박스파이프라인 구성은 스튜디오 설치와 기본 구조가 동일합니다. 가장 중요한 점은 install/core/python 내부에 tank 명령과 툴킷 API가 모두 포함되어 있다는 것입니다. API와 tank 명령이 각 구성 전반에서 중복되는 이유는 개발을 쉽게 수행하고 프로덕션 구성 외부에서 작업을 수행하기 위해서입니다.Flow Production Tracking 툴킷에 새 프로젝트가 설정되면 해당 프로젝트 설정에 따라 프로젝트에 대한 기본 파이프라인 구성이 생성됩니다. 이 구성을 ‘기본(Primary)’이라고 하며 프로젝트의 기본 구성을 나타냅니다. Flow Production Tracking 내부에서 구성은 프로젝트에 대한 파이프라인 구성 엔티티 형태로 표현됩니다. 개발을 수행하거나 구성을 변경할 때는 일반적으로 기본(Primary) 구성에서 작업하지 않습니다. 실수로 일부 구성을 변경할 경우 해당 프로젝트에서 작업하는 모든 사람에게 영향을 줍니다. 대신 Flow Production Tracking 내부의 구성을 복제할 수 있습니다. 이제 다른 사람에게 영향을 주지 않고 변경 작업을 수행할 수 있는 자체 병렬 구성을 가질 수 있습니다.샌드박스용 tank 명령 실행스튜디오 레벨의 tank 명령을 사용하여 앱을 실행하면 항상 프로젝트의 기본 구성이 사용됩니다. 따라서 tank Shot ABC123 launch_maya를 입력하면 Flow Production Tracking 툴킷은 샷 ABC123이 속한 프로젝트를 찾고 기본 파이프라인 구성을 찾은 다음 Maya를 시작할 때 해당 구성 설정을 사용합니다. 대신 dev 샌드박스에서 실험 구성을 사용하려는 경우 개발 샌드박스 내에서 특정 tank 명령을 사용하여 Maya를 시작합니다(~/sgtk_dev_sandbox/tank Shot ABC123 launch_maya). 이제 툴킷은 프로젝트의 기본 구성이 아닌 dev 샌드박스의 구성을 사용합니다.샌드박스에서 Core API 사용마찬가지로, 스튜디오 설치 위치가 아닌 파이프라인 구성 내부에서 툴킷 API를 실행하려는 경우 스튜디오 Python API가 아닌 PYTHONPATH에 dev 샌드박스를 추가할 수 있습니다.샌드박스 액세스Flow Production Tracking 내부는 훨씬 더 간단합니다. 프로젝트의 각 파이프라인 구성에는 해당 구성을 볼 수 있는 사용자의 목록이 있습니다. 필드를 공백으로 두면 모든 사용자가 구성을 볼 수 있습니다.구성을 복제하면(ShotGrid에서 마우스 오른쪽 버튼으로 클릭) 자동으로 해당 구성에 연결되어 해당 구성에 대한 독점적인 가시성이 부여됩니다. Maya에서 새로 개발한 도구를 아티스트가 테스트하도록 하려면 해당 아티스트를 파이프라인 구성 dev 샌드박스에만 추가하면 됩니다. 그러면 아티스트가 샌드박스에서 Maya를 시작한 다음 프로세스 도구에서 작업에 액세스할 수 있습니다.파이프라인 구성 현지화기본적으로 파이프라인 구성은 Flow Production Tracking 툴킷 스튜디오 설치에서 해당 코드를 선택합니다. 툴킷 스튜디오 설치에는 Flow Production Tracking 툴킷이 사용하는 모든 앱 및 엔진 코드의 캐시와 Toolkit Core API 설치가 포함됩니다. 각 파이프라인 구성은 스튜디오 위치에서 Core API와 앱 캐시를 공유합니다. 이 방법을 사용하면 Core API 업데이트를 모든 프로젝트에 동시에 적용할 수 있기 때문에 유용할 때가 있습니다. 스튜디오 위치를 업데이트하면 모든 프로젝트에 영향을 줍니다.그러나 때로는 파이프라인 구성을 잘라서 독립적으로 만들 수도 있습니다. 이러한 경우의 예는 다음과 같습니다.  업데이트를 중단하고 아무 변경 없이 프로젝트를 완료하려는 경우  Toolkit Core API의 새 버전을 테스트하려는 파이프라인 구성이 있는 경우  집에서 작업할 때 사용할 최소한의 툴킷 번들을 조립하려는 경우이 프로세스는 스튜디오 위치에서 완전히 독립적인 파이프라인 구성을 만들므로 구성을 현지화한다고 하며 기본적으로 Core API가 파이프라인 구성에 복사됩니다. tank localize 명령을 실행하여 이 작업을 수행합니다.구성을 현지화한 후에는 더 이상 스튜디오 tank 명령을 실행할 수 없습니다. 일반적으로 프로젝트가 현지화된 후에는 로컬 tank 명령과 Python API를 사용해야 합니다.복제한 구성 삭제복제한 구성 또는 dev 영역을 더 이상 사용하지 않으려면 해당 레코드를 삭제한 다음 디스크에서 해당 구성을 삭제합니다.업데이트 확인앱이나 엔진에 대한 업데이트가 있는지를 쉽게 확인할 수 있습니다. 프로젝트에 대해 tank updates 명령을 실행하기만 하면 됩니다. Flow Production Tracking 툴킷은 업데이트를 확인하고 업데이트할 것인지 묻습니다. 기본값이 없는 새 매개변수가 있으면 업데이트 스크립트에서 값을 묻는 메시지를 표시합니다. 변경된 사항의 상세 정보를 확인하려는 경우 각 업데이트의 릴리즈 정보 페이지에 대한 URL 링크를 참조하십시오. 언제든지 프로세스를 종료할 수 있습니다.Toolkit Core API를 업데이트하는 방법도 간단합니다. tank core 명령을 실행하기만 하면 됩니다.스테이징 샌드박스 만들기대부분은 기본 구성에서 tank updates를 실행하기만 해도 안전하지만 프로덕션 환경에 배포하기 전에 테스트하는 것이 좋습니다. 이 경우 기본 파이프라인 구성을 복제한 다음 업데이트 명령을 실행합니다. Core API 업그레이드의 경우 core 명령을 실행하기 전에 샌드박스를 현지화해야 합니다(현지화에 대한 자세한 정보는 윗부분 참조). 업데이트가 작동하는지 확인되면 기본 구성에서 다시 실행합니다. 이 작업을 수행하는 방법에 대한 자세한 정보는 구성 관리를 참조하십시오.앱 시작 방법 구성설치 직후 종종 구성에 필요한 툴킷 구성의 한 부분은 앱 시작 구성입니다. 당사에서는 이미 스튜디오가 커스터마이즈 및 도구를 갖추고 있는 경우가 많으므로 유연하고 구성 가능하도록 만들려고 노력해 왔습니다.Flow Production Tracking 내부에서 또는 tank 명령을 사용하여 응용프로그램(예: Maya 또는 Nuke)을 시작하면 응용프로그램 시작 및 툴킷 초기화를 담당하는 앱을 호출하게 됩니다. 이 앱을 tk-multi-launchapp이라고 합니다.툴킷 스타터 구성 중 하나를 사용하여 새 프로젝트를 설정하면 시작 앱과 함께 사용되는 응용프로그램 경로를 변경하는 방법에 대한 지침이 표시됩니다. 대신 사용할 수 있는 대체 시스템이 있는 경우 이 앱을 반드시 사용할 필요는 없습니다. 시작 관리자 응용프로그램은 일반적으로 다음 단계를 수행합니다.      사용할 컨텍스트를 파악합니다. 컨텍스트는 현재 작업 영역을 나타냅니다. 마우스 오른쪽 버튼으로 Flow Production Tracking 내부의 태스크, 에셋 또는 샷을 클릭하면 이를 기반으로 컨텍스트가 만들어집니다. tank 명령을 사용하는 경우 명령줄의 일부로 지정하는 것이거나 현재 디렉토리에서 선택됩니다.        그런 다음 앱 구성의 설정에 따라 응용프로그램을 시작합니다. 시작 앱은 응용프로그램의 경로, 전달할 명령줄 인자, 응용프로그램을 실행하는 실제 코드 및 응용프로그램 시작 전에 설정해야 하는 환경 변수 등 여러 가지 방법으로 구성할 수 있습니다.        툴킷 API가 나중에 초기화될 수 있도록 Pythonpath를 설정합니다.        응용프로그램이 시작되면 툴킷 API를 가져와서 초기화합니다.        마지막으로 엔진이 시작됩니다.  예: Flow Production Tracking 툴킷 시작 방법에 대한 추가 연습 예툴킷의 일반적인 부트스트래핑은 몇 단계로 진행됩니다.      기본 호스트 응용프로그램이 시작됩니다. 여기에는 Python 인터프리터가 있습니다. 이는 매우 간단한 형식으로 표준 셸에서 실행하는 CPython 인터프리터일 뿐입니다. Maya 또는 Nuke이거나 포함된 Python 인터프리터가 기본 제공되는 다른 항목일 수도 있습니다.        Toolkit Core API를 PYTHONPATH에 추가하고 가져옵니다. import sgtk        이제 컨텍스트를 파악해야 합니다. 디스크상의 경로 또는 Flow Production Tracking 객체일 수 있습니다. 이제 팩토리 방식을 사용하여 툴킷 API 인스턴스를 만들 수 있습니다. tk = sgtk.sgtk_from_path(&quot;/mnt/projects/hero/assets/chair01/lighting&quot;) 또는 Flow Production Tracking 엔티티를 사용할 수 있습니다. tk = sgtk.sgtk_from_entity(&quot;Shot&quot;, 123) 엔티티를 사용할 때 위의 코드가 Flow Production Tracking에 연결되고 해당 샷의 파이프라인 구성을 해결하고 디스크의 파이프라인 구성을 찾은 다음 파일 시스템 템플릿과 같은 Sgtk의 기본 설정을 로드합니다. 이 시점에서는 앱이나 엔진이 로드되지 않습니다. 경로 조회의 경우 파일 시스템을 사용하여 파이프라인 구성을 찾습니다.        이제 현재 작업 영역을 나타내는 컨텍스트 객체를 만듭니다. 엔티티 또는 경로에서 이 작업을 수행할 수도 있습니다. ctx = tk.context_from_entity(&quot;Shot&quot;, 123) 또는 ctx = tk.context_from_path(&quot;/mnt/projects/hero/assets/chair01/lighting&quot;)        마지막으로 엔진을 시작합니다. Maya 내부에서 Maya의 Python 인터프리터에 있는 이 명령을 실행하는 경우 다음을 수행합니다. sgtk.platform.start_engine('tk-maya', tk, ctx) 이렇게 하면 다음 작업이 수행됩니다.                  컨텍스트에 대한 환경 선택 후크를 실행합니다. 환경 선택 후크는 사용할 환경을 반환합니다. 환경에는 로드할 모든 앱 목록과 해당 구성이 포함되어 있습니다.                    환경 파일이 결정되면 엔진이 메모리에 로드됩니다. 그런 다음 엔진 기반 객체가 동적으로 로드되고 해당 init 방식을 실행합니다. 엔진이 로드되면 모든 앱이 동일한 방식으로 로드됩니다. 로드되는 동안 일반적으로 엔진이 응용프로그램 어딘가에 “ShotGrid” 메뉴를 등록하고 각 앱은 일련의 명령을 엔진에 등록합니다. 이러한 명령은 나중에 실행을 위한 진입점이 됩니다. 사용자가 Flow Production Tracking 메뉴에서 특정 항목을 클릭하면 앱 실행이 트리거됩니다.            전체적인 예의 모습은 다음과 같습니다.# starting up sgtk when your context is based on a pathimport sgtkpath = &quot;/mnt/projects/hero/assets/chair01/lighting&quot;# create a sgtk api handletk = sgtk.sgtk_from_path(path)# create a context objectctx = tk.context_from_path(path)# start the tank enginesgtk.platform.start_engine('tk-maya', tk, ctx)# starting up sgtk when your context is based on a Flow Production Tracking objectimport sgtkentity_type = &quot;Shot&quot;entity_id = 123# create a sgtk api handletk = sgtk.sgtk_from_entity(entity_type, entity_id)# create a context objectctx = tk.context_from_entity(entity_type, entity_id)# start the sgtk enginesgtk.platform.start_engine('tk-maya', tk, ctx)디스크에 폴더 만들기툴킷 구성의 핵심 부분은 파일 시스템 구성입니다. Flow Production Tracking 툴킷을 사용하면 일관된 방식으로 디스크에 폴더를 만들 수 있으며 생성 프로세스는 Flow Production Tracking에서 구동됩니다. 다음은 구성 내부의 핵심 폴더에 대한 개요입니다.폴더 구성을 설정하는 것은 비교적 쉽습니다. 구성은 기본적으로 사용자가 만든 템플릿 폴더 구조이며, 여기에는 폴더가 에셋 또는 샷 등을 나타내야 함을 가리키는 일부 구성 파일이 있습니다. 파일 시스템 구조를 구성할 때 언제든지 폴더 미리보기 기능을 사용하여 만들 항목의 목록을 가져올 수 있습니다. 이 명령은 Flow Production Tracking와 tank 명령에서 모두 사용할 수 있습니다.일반적인 폴더를 사용하여 스캐폴드의 윤곽을 그리면서 시작합니다. 예를 들어 에셋, 샷 또는 파이프라인 단계를 나타내는 스캐폴드에 동적 폴더 레벨이 있는 경우 우선 무시합니다. 결과에 만족하면 각 동적 폴더에 동적 기능을 단계별로 추가합니다. 이 작업을 수행하려면 폴더와 이름이 같은 yml 파일을 추가합니다.yaml 파일에서 특수 구문을 사용하여 폴더를 만드는 방법을 정의합니다. Flow Production Tracking 툴킷은 많은 동적 동작을 지원하지만 일반적으로는 Flow Production Tracking 엔티티를 나타내는 동적 노드입니다. 이 경우 구성 파일의 모양은 다음과 유사할 수 있습니다.# the type of dynamic contenttype: &quot;Shotgun_entity&quot;# the Shotgun field to use for the folder namename: &quot;{code}_{sg_prefix}&quot;# the Shotgun entity type to connect toentity_type: &quot;Asset&quot;# Shotgun filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std Shotgun API syntax)# any values starting with $ are resolved into path objectsfilters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }동적 폴더가 에셋 엔티티에 두 개의 Flow Production Tracking 필드를 사용하여 명명된 폴더를 만들어야 한다는 정보가 제공됩니다. 또한 현재 프로젝트 및 에셋 유형의 에셋만 고려하여 표준 Flow Production Tracking API 쿼리 구문을 사용하여 상위 폴더를 기반으로 제약 조건을 정의합니다.지원되는 노드 유형에 대한 자세한 정보는 참조 문서를 참조하십시오.파일 시스템 위치툴킷 폴더 생성 시스템을 통해 디스크에 폴더를 만들면 이러한 폴더도 Flow Production Tracking에 저장되고 트래킹됩니다. 폴더는 관리자 메뉴 아래에 있을 수 있는 Flow Production Tracking의 파일 시스템 위치 엔티티로 표시됩니다. 일반적으로 이 데이터는 툴킷에 의해 백그라운드에서 트래킹되며 사용자가 볼 필요는 없습니다. 이러한 파일 시스템 위치 엔티티는 툴킷에서 디스크의 폴더를 동기화하고 트래킹하는 데 사용되며 폴더 만들기가 처음 실행될 때 만들어진 방식대로 디스크의 폴더 구조를 다시 만드는 데 사용할 수 있습니다. 파일 시스템 위치 엔티티 데이터는 차례로 디스크의 특정 경로와 관련된 Flow Production Tracking 엔티티를 파악하려고 할 때 주로 사용됩니다.성능상의 이유로 파일 시스템 위치 테이블의 컨텐츠는 사용자의 로컬 시스템에 캐시됩니다. 이는 폴더/엔티티 조회 속도를 높이기 위한 것입니다. 전문가의 경우 cache_location 코어 후크를 수정하여 이 캐시의 위치를 커스터마이즈할 수 있습니다. 캐시된 로컬 폴더 표현은 응용프로그램을 시작할 때와 디스크에 폴더를 만들 때마다 동기화됩니다.툴킷 폴더 이름 바꾸기툴킷 폴더 생성을 실행하면 Flow Production Tracking의 엔티티와 디스크의 폴더 간에 연결이 설정됩니다.  툴킷은 폴더 스키마 구성을 사용하여 디스크에 일련의 폴더를 생성하고 이러한 각 폴더는 Flow Production Tracking의 Filesystem Location 엔티티로 등록됩니다. 즉, Flow Production Tracking 데이터(예: 샷 및 에셋 이름) 및 구성이 디스크 및 Flow Production Tracking의 실제 폴더에 “지정”된다고 생각할 수 있습니다.폴더가 만들어지면 더 이상 Flow Production Tracking에서 엔티티 이름을 자유롭게 변경할 수 없습니다. 엔티티의 이름을 바꾸고 툴킷을 시작하려고 하면 오류 메시지가 나타납니다. 이는 특정 엔티티와 관련된 폴더의 트래킹을 피하기 위한 것입니다.툴킷 폴더의 이름을 바꾸려면 다음을 수행합니다.  먼저 Flow Production Tracking에서 엔티티(에셋 또는 샷)의 이름을 변경합니다.  tank unregister_folders 명령을 실행하여 등록된 폴더의 등록을 취소합니다. 그러면 엔티티와 디스크 간의 관계를 트래킹하는 Flow Production Tracking의 파일 시스템 위치 엔티티가 제거됩니다. 이 명령은 디스크의 컨텐츠에는 영향을 주지 않으며 디스크의 위치를 가리키는 Flow Production Tracking의 Filesystem Location 엔티티에만 영향을 줍니다. 예를 들어, Plant라는 에셋에 대한 폴더의 등록을 취소하려면 tank Asset Plant unregister_folders 명령을 실행합니다. 폴더의 등록이 취소된다는 간략한 내용과 함께 작업 확인을 요청합니다.  폴더의 등록이 취소되면 본질적으로 에셋이 “재설정”됩니다. 현재 에셋과 관련된 폴더가 없을 때 Flow Production Tracking에서 새 이름으로 폴더 생성을 실행하면 디스크에 새 폴더가 만들어집니다.  마지막으로 디스크의 이전 위치에서 새 위치로 모든 데이터를 이동합니다. 또한 파일 간의 링크가 새 위치를 가리키도록 업데이트되는지 확인합니다.생성 유예 및 사용자 샌드박스툴킷 폴더 생성도 두 가지 단계로 실행되도록 설정할 수 있습니다. 하나의 단계는 사용자가 폴더 생성 명령을 실행할 때마다 실행되고 또 다른 단계는 응용프로그램이 시작되기 직전에 실행됩니다. 이 동작은 툴킷 응용프로그램 시작 관리자(폴더 생성을 수행하기 위한 표준 API 방식 호출)에서 기본으로 제공합니다. 폴더 생성 유예의 경우 다음과 같은 사례를 처리할 수 있습니다.  파이프라인에 다양한 컨텐츠 생성 응용프로그램이 여러 개 있고 실제로 필요할 때까지 모든 응용프로그램 각각에 대해 전체 폴더 스캐폴드를 포함하지 않으려는 경우 각각의 컨텐츠 생성 앱에 구성에서 유예된 하위 트리가 포함되도록 폴더 생성을 설정할 수 있습니다. 프로덕션 담당자 또는 관리자가 샷에 대한 폴더를 만들면 Maya, Nuke, Mari 등의 작업 영역을 만들기 직전에 중지됩니다. 그런 다음 응용프로그램이 시작되면 이러한 폴더가 응용프로그램이 시작되기 직전에 만들어집니다.  파일 시스템에 사용자 기반 샌드박스를 만들려면 작업을 수행하기 직전에 샌드박스를 만들어야 합니다. 폴더 생성 유예를 사용하면 이 프로세스를 쉽게 수행할 수 있는 특별한 사용자 노드를 추가할 수 있습니다. 그런 다음 템플릿 구성에서는 사용자 노드를 Flow Production Tracking API에서 나타내는 방식인 HumanUser로 참조합니다.생성 유예에 대한 자세한 정보는 참조 설명서를 참조하십시오.템플릿 구성파일 시스템 구조를 만들었으면 위의 폴더 구조를 기반으로 일련의 파일 시스템 위치를 구성할 차례입니다. 이러한 위치는 템플릿이라고 하며 Flow Production Tracking 툴킷의 필수적인 부분입니다. 템플릿 파일에는 각 필드의 의미를 정의하는 키 섹션, 템플릿 경로를 정의할 수 있는 경로 섹션 및 문자열 표현식을 정의할 수 있는 문자열 섹션 등 세 부분이 있습니다. 파일에서 두 가지 구문을 사용할 수 있습니다. 즉, 단일 저장소 루트가 있는 구성에 사용할 수 있는 단순 형식의 구문과 다중 루트 구성에 사용할 수 있는 고급 구문이 있습니다.예: 단일 루트 템플릿 형식# The keys section contains the definitions for all the different keys that are being# used in the Toolkit. A key is a magic token that is replaced by a value at runtime, for example# {Shot}. The section below tells the Toolkit which data types and formats to expect for each key.keys:    Sequence:        type: str    Shot:        type: str    Step:        type: str    sg_asset_type:        type: str    Asset:        type: str    name:        type: str        filter_by: alphanumeric    iteration:        type: int    version:        type: int        format_spec: '03'    version_four:       type: int       format_spec: '04'       alias: version    timestamp:        type: str    width:        type: int    height:        type: int    channel:        type: str        filter_by: alphanumeric    SEQ:        type: sequence        format_spec: '04'    eye:        type: str# The paths section contains all the the key locations where files are to be stored# by the Toolkit Apps. Each path is made up of several keys (like {version} or {shot}) and# these are defined in the keys section above.## Toolkit apps use these paths as part of their configuration to define where on disk# different files should go.paths:    ##########################################################################################    # Shot pipeline / maya    shot_root: 'sequences/{Sequence}/{Shot}/{Step}'    # define the location of a work area    shot_work_area_maya: '@shot_root/work/maya'    # define the location of a publish area    shot_publish_area_maya: '@shot_root/publish/maya'    # The location of WIP files    maya_shot_work: '@shot_root/work/maya/{name}.v{version}.ma'    # The location of backups of WIP files    maya_shot_snapshot: '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'    # The location of published maya files    maya_shot_publish: '@shot_root/publish/maya/{name}.v{version}.ma'    ##########################################################################################    # Asset pipeline / maya    asset_root: 'assets/{sg_asset_type}/{Asset}/{Step}'    # define the location of a work area    asset_work_area_maya: '@asset_root/work/maya'    # define the location of a publish area    asset_publish_area_maya: '@asset_root/publish/maya'    # The location of WIP files    maya_asset_work: '@asset_root/work/maya/{name}.v{version}.ma'    # The location of backups of WIP files    maya_asset_snapshot: '@asset_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'    # The location of published maya files    maya_asset_publish: '@asset_root/publish/maya/{name}.v{version}.ma'# The strings section is similar to the paths section - but rather than defining paths# on disk, it contains a list of strings. Strings are typically used when you want to be# able to configure the way data is written to Flow Production Tracking - it may be the name field for a# review version or the formatting of a publish.strings:    nuke_shot_version_name: '{Shot}_{name}_{channel}_v{version}.{iteration}'    nuke_asset_version_name: '{Asset}_{name}_{channel}_v{version}.{iteration}'예: 다중 루트 템플릿 형식## The keys section contains the definitions for all the different keys that are being# used in the Toolkit. A key is a magic token that is replaced by a value at runtime, for example# {Shot}. The section below tells the Toolkit which data types and formats to expect for each key.#keys:    Sequence:        type: str    Shot:        type: str    Step:        type: str    sg_asset_type:        type: str    Asset:        type: str    name:        type: str        filter_by: alphanumeric    iteration:        type: int    version:        type: int        format_spec: '03'    version_four:       type: int       format_spec: '04'       alias: version    timestamp:        type: str    width:        type: int    height:        type: int    channel:        type: str        filter_by: alphanumeric    SEQ:        type: sequence        format_spec: '04'    eye:        type: str# The paths section contains all the the key locations where files are to be stored# by the Toolkit Apps. Each path is made up of several keys (like {version} or {shot}) and# these are defined in the keys section above.# Toolkit apps use these paths as part of their configuration to define where on disk# different files should go.paths:    ##########################################################################################    # Shot pipeline / Maya    shot_root: 'sequences/{Sequence}/{Shot}/{Step}'    # define the location of a work area    shot_work_area_maya:      definition: '@shot_root/work/maya'      root_name: primary    # define the location of a publish area    shot_publish_area_maya:      definition: '@shot_root/publish/maya'      root_name: primary    # The location of WIP files    maya_shot_work:      definition: '@shot_root/work/maya/{name}.v{version}.ma'      root_name: primary    # The location of backups of WIP files    maya_shot_snapshot:      definition: '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'      root_name: primary    # The location of published maya files    maya_shot_publish:      definition: '@shot_root/publish/maya/{name}.v{version}.ma'      root_name: primary    ##########################################################################################    # Asset pipeline / Maya    asset_root: 'assets/{sg_asset_type}/{Asset}/{Step}'    # define the location of a work area    asset_work_area_maya:      definition: '@asset_root/work/maya'      root_name: secondary    # define the location of a publish area    asset_publish_area_maya:      definition: '@asset_root/publish/maya'      root_name: secondary    # The location of WIP files    maya_asset_work:      definition: '@asset_root/work/maya/{name}.v{version}.ma'      root_name: secondary    # The location of backups of WIP files    maya_asset_snapshot:      definition: '@asset_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'      root_name: secondary    # The location of published maya files    maya_asset_publish:      definition: '@asset_root/publish/maya/{name}.v{version}.ma'      root_name: secondary# The strings section is similar to the paths section - but rather than defining paths# on disk, it contains a list of strings. Strings are typically used when you want to be# able to configure the way data is written to Flow Production Tracking - it may be the name field for a# review version or the formatting of a publish.strings:    # when a review version in Flow Production Tracking is created inside of nuke, this is the    # name that is being given to it (the code field)    nuke_shot_version_name: '{Shot}_{name}_{channel}_v{version}.{iteration}'    nuke_asset_version_name: '{Asset}_{name}_{channel}_v{version}.{iteration}'템플릿 파일에 사용할 수 있는 여러 가지 구성 옵션이 있습니다. 여기에서 전체 참조를 찾을 수 있습니다.템플릿 파일의 @include 구문템플릿 파일에서 반복을 줄이기 위해 필드를 다시 사용할 수 있습니다.paths:    asset_root: 'assets/{sg_asset_type}/{Asset}/{Step}'    maya_asset_work: '@asset_root/work/maya/@maya_asset_file'strings:    maya_asset_file: '{name}.v{version}.ma'템플릿을 여러 파일로 분할하고 파일을 다른 파일에 포함할 수도 있습니다. 자세한 정보는 참조 문서를 참조하십시오.템플릿 파일에 외부 파일 포함환경 구성을 여러 파일로 분리한 다음 다른 파일에 파일을 포함할 수 있는 것과 같이 이 방법으로 템플릿 파일을 관리할 수 있습니다. 예를 들어 다중 프로젝트에서 공유되는 전역 구성을 설정하는 경우에 유용할 수 있습니다.include 구문 중 하나를 사용하여 templates.yml 파일에 추가 파일을 포함합니다.# single include using a path local to the location of the current fileinclude: './include_file.yml'# multiple incudes, processed in orderincludes: ['./include_file_1.yml', './include_file_2.yml']# you can also use absolute paths when including things:include:# files that are not recognized are skipped, so you can put paths for# windows and linux next to each other for multi platform support:includes: ['/foo/bar/hello.yml', 'z: foo bar hello.yml']# you can use environment variables inside of full paths tooincludes: ['$STUDIO_ROOT/foo/bar/hello.yml', '%STUDIO_ROOT% foo bar hello.yml']포함된 파일은 기본 templates.yml 파일과 동일한 구조를 가져야 합니다. 즉, paths, keys 및 strings 섹션을 포함해야 합니다. 툴킷 프로세스가 포함되면, 위에서 아래로, 깊은 순서대로 재귀적으로 읽으며 데이터를 paths, keys 및 paths 등 세 가지 “버킷”에 개별적으로 추가합니다. 이 프로세스 도중 버킷에 이미 값이 있으면 덮어씁니다. 모든 include가 처리되면 전체 구성의 유효성을 확인합니다.간단한 예를 살펴보겠습니다. 다음과 같이 기본 templates.yml 파일이 있습니다.include: ./global_defs.ymlkeys:    name:        type: str        filter_by: alphanumeric    version:        type: int        format_spec: &quot;03&quot;paths:    maya_shot_work: '@shot_root/work/maya/{name}.v{version}.ma'그리고 여기에 포함된 파일 global_defs.yml의 컨텐츠가 있습니다.keys:    Sequence:        type: str    Shot:        type: str    Step:        type: strpaths:    shot_root: sequences/{Sequence}/{Shot}/{Step}각 파일에 필요한 모든 항목이 포함되도록 키와 경로를 함께 유지하는 것이 좋습니다(하지만 적절하지 않은 경우도 있음). 이렇게 하면 일반적으로 유지 관리가 더 쉬워집니다.폴더 생성 및 템플릿폴더 생성 시스템에서 만든 폴더를 참조하는 템플릿을 만들 때 ‘Flow Production Tracking API’ 스타일 표기법을 사용하여 필드를 지정해야 합니다. 이는 놓치기 쉬운 감지하기 힘든 사항입니다. 위의 예는 이러한 부분에 대한 좋은 예입니다. 폴더를 만들 때 먼저 항목을 에셋 유형별로 그룹화한 다음 에셋 이름별로 그룹화하는 구성을 설정했습니다. 예를 들면 다음과 같습니다./mnt/projects/my_project/assets/character/Hero그런 다음 이 경로와 일치하는 툴킷에서 템플릿을 만들려고 합니다. Flow Production Tracking 툴킷이 템플릿을 경로 및 컨텍스트와 일치시키려면 Flow Production Tracking API를 사용하는 경우와 마찬가지로, 필드의 이름을 지정해야 합니다. 에셋 유형 폴더 레벨은 Flow Production Tracking에서 이 필드의 필드 이름인 sg_asset_type이라고 해야 하며, 에셋 레벨 폴더는 Flow Production Tracking API를 사용할 때 에셋 엔티티 유형을 참조하는 방법인 Asset(대문자 A)이라고 해야 합니다.후크후크는 툴킷 구성의 유연한 부분입니다. 일반적으로 앱, 엔진 또는 Core API를 구성할 때 매개변수 컬렉션을 지정하여 일부 동작을 정의합니다. 그러나 이것만으로는 부족한 경우가 있으며 여기에서 후크가 작동하게 됩니다. 후크는 Python 코드의 작은 부분이며 앱, 엔진 또는 실제로 코어의 모양을 커스터마이즈하는 데 사용할 수 있습니다. Shotgun은 가벼운 원자 레벨의 후크를 디자인하려고 했습니다. 툴킷에는 후크가 나타나는 3가지 레벨이 있습니다. 아래 섹션에서 각 레벨에 대한 자세한 정보를 참조하십시오.앱 레벨 후크각 툴킷 앱(및 해당 엔진)에는 설정 모음이 있으며 그중 일부가 후크일 수 있습니다. 각 앱에는 기본 후크 모음이 있으며 사용자가 특별히 재정의하지 않는 한 자동으로 사용됩니다. 후크는 일반적으로 응용프로그램과 밀접하게 관련된 항목을 커스터마이즈하는 데 사용됩니다. 예를 들어 이미지를 Maya에 로드하는 툴킷의 경우 UI 코드와 모든 상호 작용 로직은 앱 내에 있지만 실제로 이미지를 Maya에 로드하는 비즈니스 로직의 작은 부분은 후크 내부에 있습니다. 이렇게 하면 스튜디오가 동작을 커스터마이즈할 수 있습니다. 기본 후크가 Maya에서 표준 텍스처 노드를 간단히 만들 수 있지만 다른 노드 유형을 사용하려는 스튜디오는 후크를 재정의할 수 있으므로 코드를 다시 작성할 필요 없이 전체 앱의 동작을 쉽게 변경할 수 있습니다.앱 후크를 커스터마이즈할 때는 일반적으로 기본 후크를 앱의 후크 폴더에서 프로젝트의 후크 폴더에 복사합니다. 그런 다음 기본 후크가 아닌 새로운 후크를 읽도록 환경 파일 내부의 앱 설정을 업데이트해야 합니다. 커스터마이즈 후크는 앱에서 제공하는 기본 후크에서 자동으로 상속되므로 수정 및 작은 조정을 쉽게 추가할 수 있지만 비즈니스 로직의 대부분을 기본 후크에 유지할 수 있습니다. 후크 상속에 대한 자세한 정보는 환경 구성 참조를 참고하십시오.코어 레벨 후크코어 후크를 사용하면 툴킷에서 시스템 레벨의 동작을 재정의할 수 있습니다. 코어 레벨 후크는 모두 프로젝트별로 재정의되므로 재정의를 통해 각 프로젝트를 개별적으로 설정해야 합니다. 새 프로젝트를 설정할 때 동일한 구성을 계속 재사용하는 경우 일반적으로 간단합니다.코어 구성 영역에는 특별한 hooks 폴더가 있습니다. 이 폴더에서는 특정 코어 후크를 구현할 수 있습니다. 코어 후크는 앱에서 찾을 수 있는 후크와 유사하며 툴킷에서 코드 조각을 추출하여 커스터마이즈할 수 있는 방법입니다. Core API를 사용하면 파일 시스템 I/O, 폴더 생성 및 파일 시스템 구조의 유효성 확인을 포함하여 다양한 코어 동작을 재정의할 수 있습니다.기본적으로 툴킷은 API 폴더에서 필요한 코어 후크를 선택합니다. 동작을 커스터마이즈하려면 후크 파일을 가져 와서 구성의 config/core/hooks 영역에 복사합니다. 그런 다음 코드를 수정합니다.사용 가능한 코어 후크 목록은 Core API 내부의 후크 폴더를 확인합니다. 각 후크에는 무엇을 수행하고 어떻게 수정될 수 있는지에 대한 매우 많은 문서가 포함되어 있습니다.스튜디오 레벨 후크또한 스튜디오 레벨 후크라고 하는 몇 가지 특별한 후크가 있습니다. 이러한 후크는 전역적이며 모든 항목에 영향을 미치며  특정 프로젝트 외부에 있는 툴킷의 모습을 제어합니다.프로젝트 이름 후크프로젝트 설정 프로세스에서 프로젝트의 ‘디스크 이름’을 묻는 메시지가 표시되며 Flow Production Tracking의 프로젝트 이름을 기반으로 이름을 제안하지만 공백과 파일 시스템 형식이 아닌 글자는 밑줄로 바뀝니다. 디스크 이름은 프로젝트 데이터 및 구성이 저장되는 폴더의 이름입니다.디스크 이름을 지정할 때 슬래시를 사용할 수 있습니다. 이렇게 하면 아래로 여러 폴더를 갖는 프로젝트 루트 포인트가 생성되며, 스튜디오에서 예를 들어 분야(광고, vfx 등)를 기반으로 해당 프로젝트가 구성된 경우이거나 스튜디오 프로젝트의 업무량이 너무 커서 파일 시스템을 단일 레벨로 인해 관리하기 어렵게 된 경우에 유용할 수 있습니다. 항상 슬래시(‘/’)를 사용해야 합니다. 툴킷은 Windows에서 필요한 조정을 수행합니다.위에서 설명한 다중 레벨 폴더와 함께 툴킷에서 설정 프로세스의 일부로 제안하는 이름을 커스터마이즈할 수도 있습니다. 이 작업은 특별한 스튜디오 레벨의 후크에서 수행됩니다. 이 동작을 커스터마이즈하려면 config/core 폴더의 스튜디오 API 위치 안에 project_name.py라는 파일을 만듭니다. 이 폴더에는 install_location.yml, app_store.yml 및 shotgun.yml과 같은 파일이 있어야 합니다.project_name.py 후크 파일은 예를 들어 다음과 같이 표시될 수 있습니다.from tank import Hookimport osclass ProjectName(Hook):    def execute(self, sg, project_id, **kwargs):        &quot;&quot;&quot;        Gets executed when the setup_project command needs a disk name preview.        &quot;&quot;&quot;        # example: create a name based on both the sg_type field and the name field        sg_data = sg.find_one(&quot;Project&quot;, [[&quot;id&quot;, &quot;is&quot;, project_id]], [&quot;name&quot;, &quot;sg_type&quot;])        # create a name, for example vfx/project_x or commercials/project_y        name = &quot;%s/%s&quot; % ( sg_data[&quot;sg_type&quot;], sg_data[&quot;name&quot;] )        # perform basic replacements        return name.replace(&quot;_&quot;, &quot;/&quot;).replace(&quot; &quot;, &quot;/&quot;)커넥션 후크툴킷은 관련된 Flow Production Tracking 인스턴스에 연결할 수 있도록 커넥션 설정을 저장합니다. 때로는 동적 방식으로 이러한 커넥션 설정을 제어하는 것이 유용할 수 있습니다. 이 경우 config/core 폴더의 스튜디오 API 위치 내에 sg_connection.py라는 후크 파일을 만듭니다. 이 폴더에는 install_location.yml, app_store.yml 및 shotgun.yml과 같은 파일이 있어야 합니다.이 후크는 Flow Production Tracking 커넥션 설정 후 호출되며 shotgun.yml 및 app_store.yml 구성 파일에서 읽혀집니다. 절차를 통해 커넥션 설정을 쉽게 수정할 수 있습니다. 예를 들어 일부 외부 환경 변수에 따라 다른 프록시 서버를 설정할 수 있습니다.다음 3개의 매개변수가 후크에 전달됩니다.      config_data는 읽은 Flow Production Tracking 구성 파일의 설정을 포함하는 사전이며 일반적으로 host, api_script, api_key 및 http_proxy 키가 포함되어 있습니다.        user는 커넥션 정보와 관련된 사용자 프로파일로서 전문가 설정이며 거의 항상 defualt로 설정됩니다.        cfg_path는 config_data가 로드된 구성 파일의 경로입니다.  후크는 config_data와 같은 형식으로 사전을 반환해야 합니다.프록시 설정을 커스터마이즈하는 경우 반환되는 프록시 문자열은 Flow Production Tracking API 생성자에서 예상하는 것과 동일한 형식(예: 123.123.123.123, 123.123.123.123:8888 또는 username:pass@123.123.123.123:8888)이어야 합니다.다음은 시작 지점으로 사용할 수 있는 구현의 예입니다.from tank import Hookimport osclass CustomShotunConnection(Hook):    &quot;&quot;&quot;    Allows for post processing of Flow Production Tracking connection data prior to connection    &quot;&quot;&quot;    def execute(self, config_data, user, cfg_path, **kwargs):        # explicitly set the proxy server setting        config_data[&quot;http_proxy&quot;] = &quot;123.123.123.123&quot;        return config_data앱 및 엔진 구성이제 디스크상의 모든 키 위치를 정의하는 템플릿 파일을 설정했으므로 구성에 포함할 앱 및 엔진을 결정하기 시작할 수 있습니다. 소개 문서의 다른 부분에서 설명한 것처럼 앱 및 엔진 구성은 일련의 환경으로 세분화됩니다. 환경은 기본적으로 대체 구성이며 샷 작업 및 에셋 작업과 같이 다르게 구성된 다양한 앱 제품군을 제공해야 할 경우가 많기 때문에 유용합니다. 좀 더 복잡한 파이프라인의 경우, 모델링 설정이 리깅과 다르도록 부서에서 더 세분화할 수 있습니다. 이러한 작업은 모두 환경을 통해 처리됩니다.환경 파일에 다수의 가능한 엔진이 정의되며 실행 중인 응용프로그램에 따라 이 섹션 중 하나가 사용됩니다. 예를 들어 Maya를 실행 중인 경우 툴킷에서 ‘tk-maya’ 엔진이 시작되도록 합니다. Flow Production Tracking 툴킷은 먼저 현재 작업 영역을 기준으로 사용할 환경을 결정한 다음 이 환경 내에서 tk-maya 엔진을 찾습니다. 엔진을 찾으면 이 섹션에 정의된 모든 앱에 로드됩니다.각 앱에 여러 가지 설정을 구성할 수 있습니다. 앱을 설치하거나 업그레이드할 때 Flow Production Tracking 툴킷의 안내에 따라 기본값이 없는 모든 설정을 구성해야 합니다. 툴킷 앱은 재활용이 가능하도록 설계되기 때문에 설정 방법에 따라 다양한 방식으로 많은 워크플로우에서 사용할 수 있습니다. 동일한 환경에서 동일한 앱을 여러 번 정의할 수도 있습니다. 예를 들어 구성이 다르지만 동일한 게시 앱을 사용하는 두 가지 게시자(리깅 게시용 및 모델 게시용)를 Maya 메뉴에 표시할 수 있습니다.예: 환경 파일include: ./includes/app_launchers.ymlengines:  # 3dsmax engine  tk-3dsmax:    debug_logging: false    location: {name: tk-3dsmax, type: app_store, version: v0.2.6}    # all the registered apps for this engine    apps:      tk-multi-about:        location: {name: tk-multi-about, type: app_store, version: v0.1.8}      tk-multi-loader-texture:        dependency_mode: false        hook_add_file_to_scene: default        location: {name: tk-multi-loader, type: app_store, version: v0.2.6}        menu_name: Load Texture...        publish_filters: []        sg_entity_types:          Asset: []        single_select: true        tank_types: [Diffuse Texture, Specular Texture]      tk-multi-publish:        display_name: Publish        hook_copy_file: default        hook_post_publish: default        hook_primary_pre_publish: default        hook_primary_publish: default        hook_scan_scene: default        hook_secondary_pre_publish: default        hook_secondary_publish: default        hook_thumbnail: default        location: {name: tk-multi-publish, type: app_store, version: v0.2.5}        primary_description: Publish and version up the current 3ds Max scene        primary_display_name: 3ds Max Publish        primary_icon: icons/publish_3dsmax_main.png        primary_publish_template: max_shot_publish        primary_scene_item_type: work_file        primary_tank_type: 3dsmax Scene        secondary_outputs: []        template_work: max_shot_work      tk-multi-screeningroom: '@launch_screeningroom'      tk-multi-snapshot:        hook_copy_file: default        hook_scene_operation: default        hook_thumbnail: default        location: {name: tk-multi-snapshot, type: app_store, version: v0.1.15}        template_snapshot: max_shot_snapshot        template_work: max_shot_work      tk-multi-workfiles:        hook_copy_file: default        hook_scene_operation: default        location: {name: tk-multi-workfiles, type: app_store, version: v0.2.5}        sg_entity_types: [Shot, Asset]        template_publish: max_shot_publish        template_publish_area: shot_publish_area_max        template_work: max_shot_work        template_work_area: shot_work_area_max  # the maya engine  tk-maya:    debug_logging: false    location: {name: tk-maya, type: app_store, version: v0.2.7}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: File Manager...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}    - {app_instance: tk-multi-workfiles, name: Save As...}    - {app_instance: tk-multi-publish, name: Publish...}    template_project: shot_work_area_maya    # all the registered apps for this engine    apps:      tk-maya-breakdown:        hook_multi_update: default        hook_scan_scene: default        location: {name: tk-maya-breakdown, type: app_store, version: v0.2.7}      tk-multi-about:        location: {name: tk-multi-about, type: app_store, version: v0.1.8}      tk-multi-loader-1:        dependency_mode: false        hook_add_file_to_scene: default        location: {name: tk-multi-loader, type: app_store, version: v0.2.6}        menu_name: Load Assets...        publish_filters: []        sg_entity_types:          Asset: []        single_select: true        tank_types: [Maya Model, Maya Rig]      tk-multi-loader-2:        dependency_mode: false        hook_add_file_to_scene: default        location: {name: tk-multi-loader, type: app_store, version: v0.2.6}        menu_name: Load Shots...        publish_filters: []        sg_entity_types:          Shot: []        single_select: true        tank_types: [Maya Anim, Maya Lighting, Maya Scene]      tk-multi-publish:        display_name: Publish        hook_copy_file: default        hook_post_publish: default        hook_primary_pre_publish: default        hook_primary_publish: default        hook_scan_scene: default        hook_secondary_pre_publish: default        hook_secondary_publish: default        hook_thumbnail: default        location: {name: tk-multi-publish, type: app_store, version: v0.2.5}        primary_description: Publish and version up the current Maya scene        primary_display_name: Maya Publish        primary_icon: icons/publish_maya_main.png        primary_publish_template: maya_shot_publish        primary_scene_item_type: work_file        primary_tank_type: Maya Scene        secondary_outputs: []        template_work: maya_shot_work      tk-multi-screeningroom: '@launch_screeningroom'      tk-multi-setframerange:        location: {name: tk-multi-setframerange, type: app_store, version: v0.1.2}        sg_in_frame_field: sg_cut_in        sg_out_frame_field: sg_cut_out      tk-multi-snapshot:        hook_copy_file: default        hook_scene_operation: default        hook_thumbnail: default        location: {name: tk-multi-snapshot, type: app_store, version: v0.1.15}        template_snapshot: maya_shot_snapshot        template_work: maya_shot_work      tk-multi-workfiles:        hook_copy_file: default        hook_scene_operation: default        location: {name: tk-multi-workfiles, type: app_store, version: v0.2.5}        sg_entity_types: [Shot, Asset]        template_publish: maya_shot_publish        template_publish_area: shot_publish_area_maya        template_work: maya_shot_work        template_work_area: shot_work_area_maya각 앱에는 위치 설정이 있음환경 파일의 각 항목에는 특별한 location 토큰이 있습니다. 이 토큰은 툴킷에서 앱 코드를 선택하는 위치와 앱의 새 버전을 확인해야 하는 방법을 정의합니다. 예를 들어 위치 토큰은 다음과 같이 정의될 수 있습니다.location: {name: tk-multi-setframerange, type: app_store, version: v0.1.2}이 유형은 App Store에서 이 앱을 제공했으며 특정 버전이 사용되고 있음을 나타냅니다. 업데이트 확인을 실행하면 Flow Production Tracking 툴킷이 App Store에 연결되어 v0.1.2보다 최신 버전이 있는지 확인합니다. 그러한 경우 업그레이드할 것인지 묻습니다. 툴킷은 git 및 github를 포함하여 몇 가지 다른 위치 유형을 지원하므로 직접 앱을 빌드하고 git를 사용하여 앱을 트래킹하며 업그레이드 확인 시 git에서 새 태그를 만들 때 올바로 처리되는지 업데이트에서 감지합니다. 자세한 정보는 참조 문서를 참조하십시오.파일 포함외부 파일을 환경 파일에 포함할 수 있습니다. 이 방법은 설정을 중앙 집중화하거나 재정의를 관리할 때 유용합니다.      여러 환경에서 Maya를 시작하더라도 응용프로그램(Maya, Nuke)에 대한 모든 파일 경로를 한 곳에서 관리할 수 있도록 구성할 수 있습니다.        여러 환경에서 동일한 설정으로 사용되는 앱을 한 곳에서 정의할 수 있습니다.        다중 프로젝트에서 공유되는 ‘중앙’ 파이프라인 구성을 유지 관리할 수 있으며, 업데이트될 때 모든 프로젝트에 업데이트가 반영될 수 있습니다. 각 프로젝트는 특정 동작이 필요한 경우 포함되는 중앙 구성을 잠재적으로 재정의하거나 확장할 수 있습니다.        컨텍스트의 파일을 재정의로 포함할 수 있습니다. 즉 설정 매개변수를 샷 단위 또는 에셋 단위로 재구성할 수 있습니다. 이것은 기본 구성에 설명되어 있으며 여기에서 샷 또는 에셋 단위로 Maya, Nuke 등에 대한 경로 설정을 재정의할 수 있습니다.        전체 경로에서 환경 변수를 사용하면 자동으로 확장됩니다. Linux에서는 include 구문 분석기에 혼동을 줄 수 있으므로 ${ENV_VAR} 형식이 아닌 $ENV_VAR 형식이어야 합니다. 예: includes: ['$STUDIO_ROOT/foo/bar/hello.yml', '%STUDIO_ROOT% foo bar hello.yml'].  예: 앱 시작을 위한 샷별 재정의셸 엔진에 대해 다음과 같은 환경 파일이 있다고 가정합니다.include: ./includes/app_launchers.ymlengines:  tk-shell:    debug_logging: false    location: {name: tk-shell, type: app_store, version: v0.3.0}    apps:        tk-multi-launch3dsmax: '@launch_3dsmax'        tk-multi-launchmaya: '@launch_maya'        tk-multi-launchmotionbuilder: '@launch_motionbuilder'        tk-multi-launchnuke: '@launch_nuke'        tk-multi-launchphotoshop: '@launch_photoshop'이러한 각 앱은 참조 파일이며 app_launchers 포함 파일에 정의되어 있습니다. 이 파일은 각 앱의 실제 앱 구성을 포함하며 다음과 같이 표시됩니다.includes:    # first include the configuration's global settings for application paths    - ./paths.yml    # now include overrides - these will be loaded if they are found    - sequences/{Sequence}/{Shot}/sgtk_overrides.yml    - assets/{sg_asset_type}/{Asset}/sgtk_overrides.ymllaunch_3dsmax:  engine: tk-3dsmax  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: ''  linux_path: ''  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.4}  mac_args: ''  mac_path: ''  menu_name: Launch 3DSMax  windows_args: ''  windows_path: '@3dsmax_windows'launch_maya:  engine: tk-maya  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: ''  linux_path: '@maya_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.4}  mac_args: ''  mac_path: '@maya_mac'  menu_name: Launch Maya  windows_args: ''  windows_path: '@maya_windows'위의 파일에는 Maya, Nuke 등에 대한 실제 경로가 포함되어 있지 않습니다. 대신, 실제 경로는 별도의 파일 paths.yml에 정의됩니다.# mayamaya_windows: 'C: Program Files Autodesk Maya2012 bin maya.exe'maya_mac: /Applications/Autodesk/maya2012/Maya.appmaya_linux: maya# nukenuke_mac: /Applications/Nuke6.3v8/Nuke6.3v8.appnuke_windows: 'C: Program Files Nuke6.3v8 Nuke6.3.exe'nuke_linux: Nuke6.3app_launchers 파일은 우선 위의 파일을 포함하지만 sequences/{Sequence}/{Shot}/sgtk_overrides.yml도 포함합니다. 템플릿과 마찬가지로, 컨텍스트별 파일 경로이므로 현재 컨텍스트에 대한 경로를 확인하려고 시도합니다. 경로를 확인하고 나면 해당 경로를 찾아서 로드합니다. 즉, 샷 위치에 sgtk_overrides.yml을 만들고 특정 샷에 대해서만 응용프로그램 경로를 재정의할 수 있습니다.# mayamaya_windows: 'C: Program Files Autodesk Maya2012 bin special_maya.exe'여기에서는 Windows용 특별한 버전의 Maya를 사용합니다. 나머지 경로는 paths.yml 파일에 정의된 원래 경로입니다.include 작동 방법에 대한 자세한 정보는 참조 문서를 참조하십시오.템플릿 설정 구성 - 파일 경로많은 앱에서 사용하는 중요한 설정 유형은 template 설정입니다. 파일 시스템 위치를 지정해야 하는 앱은 이 설정을 사용합니다. 앱은 파일 시스템 구조 또는 명명 규칙을 사용하도록 설계되어 일반적이거나 유연성 있게 개발되었습니다. 템플릿은 기본 파일 시스템과 독립적으로 앱을 사용할 수 있도록 하는 주요 요소입니다. 자세한 정보는 개념 소개를 참조하십시오.앱을 구성하고 템플릿을 설정할 때 올바른 필드 집합이 포함된 템플릿을 지정해야 합니다. 필드는 필수적이거나 선택적일 수 있습니다. 필수 필드는 템플릿에 반드시 포함되어야 하며, 선택 필드는 템플릿의 일부가 될 수 있지만 필드가 템플릿에서 정의되지 않더라도 앱이 작동한다는 의미합니다.앱이 실행되면 구성에서 지정한 템플릿의 경로가 만들어집니다. 이 경로는 현재 컨텍스트와 앱 로직에서 제공하는 일련의 필드를 기반으로 만들어집니다. 즉, 템플릿에 컨텍스트의 일부가 아니거나 앱에 대한 선택 또는 필수 필드의 일부가 아닌 필드가 있는 경우 앱이 해당 필드에 값을 설정할 수 없으므로 작동하지 않습니다. 툴킷에서 시작할 때 구성의 유효성을 확인하여 이러한 상황을 방지할 수 있습니다.템플릿 설정의 유효성을 확인할 때 툴킷은 먼저 컨텍스트를 확인하고 컨텍스트에서 제공한 필드를 템플릿의 필드와 비교합니다. 컨텍스트를 비교하여 필드 목록이 앱에 대한 필수/선택 매개변수 정의와 일치하지 않으면 유효성 확인 오류가 발생합니다.실제 예: 스냅샷 앱다음은 작동 방식에 대한 실제 예입니다. 툴킷 앱 중 하나인 스냅 샷 앱을 살펴보겠습니다.이 앱은 여러 템플릿 설정을 사용합니다. 다음은 앱 설정 분석에 정의된 이러한 설정 중 하나입니다.  설정 이름: template_snapshot  유형: template  필수 템플릿 키: version  선택적 템플릿 키: name, timestamp, increment  설명: 스냅샷 백업을 디스크에 저장할 위치를 정의하는 템플릿에 대한 참조입니다.런타임에 컨텍스트에서 제공하는 필드 외에도 이 템플릿 설정에는 version 필드가 포함된 템플릿이 필요합니다. 선택적 name, timestamp 또는 increment 필드를 포함할 수 있지만 다른 필드는 포함할 수 없습니다. 예를 들면 다음과 같습니다.샷의 태스크에 대해 Maya를 시작한다고 가정합니다. 그러면 컨텍스트에 다음 필드가 포함됩니다.  현재 프로젝트가 설정된 필드  현재 엔티티(예: 샷)가 설정된 필드  현재 단계가 설정된 필드  현재 태스크가 설정된 필드엔진이 시작되면 구성의 유효성을 확인합니다. 다음은 위의 template_snapshot 필드에 대해 다른 설정이 적용되면 발생하게 되는 몇 가지 예입니다.      sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{version}.ma 템플릿은 스냅샷 template_snapshot 설정과 함께 사용할 수 있습니다.          Sequence, Shot 및 Step은 컨텍스트에 의해 채워집니다. 컨텍스트는 현재 샷을 인식하기 때문에 현재 시퀀스(파일 시스템의 상위 폴더임)를 자동으로 파악할 수 있습니다.      템플릿의 version 필드는 앱 설정에 필요한 필드입니다.      name 필드는 선택 필드입니다.      다른 필드는 없습니다.            (샷) 컨텍스트에서 Asset 필드를 확인하는 방법을 알 수 없기 때문에 assets/{Asset}/work/maya/{name}.v{version}.ma 템플릿은 유효하지 않습니다.        필수 version 필드가 없기 때문에 sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.ma 템플릿은 유효하지 않습니다.        extension 필드를 알 수 없고 앱에서 입력하는 방법을 알 수 없기 때문에 sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{version}.{extension} 템플릿은 유효하지 않습니다.  후크를 사용하여 앱 동작 커스터마이즈앱에서 자주 사용하는 또 다른 설정 유형은 hook 설정 유형입니다. 후크는 앱이 정상적인 실행의 일부로 실행될 코드 조각입니다. 후크를 사용하면 매우 유연한 앱 커스터마이즈가 가능하므로 앱의 일부 비즈니스 로직을 실제 앱 코드와 분리할 수 있습니다.예를 들어 다양한 참조와 파일 입력을 위해 씬을 스캔해야 하는 분석 앱이 있다고 가정합니다. Maya의 경우 Maya가 제공하는 표준 참조 노드를 처리하는 기본 동작을 제공할 수 있지만 Studio에서 커스텀 유형의 참조 노드를 사용하는 경우에는 어떻게 해야 할까요? 물론 스튜디오에서 언제나 앱을 가져와서 github에서 포크(fork)할 수 있지만 참조 노드에 대한 씬을 스캔하는 코드에 커스터마이즈 노드 유형을 추가하기만 하면 실제로 변경할 수 있으므로 그렇게까지 할 필요는 없습니다.대신, 분석을 통해 씬 스캔 코드 조각을 후크로 구현할 수 있습니다. 이는 앱 구성의 일부인 효과적인 설정이라는 것을 의미합니다. plain-vanilla Maya의 사례를 처리하는 기본값이 제공되므로 즉시 작동할 수 있지만 원하는 경우 Flow Production Tracking 툴킷을 간편하게 구성하여 이 동작을 완전히 변경할 수도 있습니다.앱이 설치되면 기본값으로 모든 후크 설정이 구성에 표시됩니다. 즉, 앱은 함께 제공되는 기본 제공 후크 구현을 사용합니다. 예를 들어 시작 관리자 앱 구성은 다음과 같습니다.launch_maya:  engine: tk-maya  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: ''  linux_path: '@maya_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.4}  mac_args: ''  mac_path: '@maya_mac'  menu_name: Launch Maya  windows_args: ''  windows_path: '@maya_windows'hook_app_launch 및 hook_before_app_launch는 기본 앱 구현을 사용하는 두 개의 후크가 있음을 알 수 있습니다. 이러한 후크는 스튜디오가 시작 프로세스를 커스터마이즈하고 환경 변수를 설정할 수 있도록 하기 위해 만들어졌습니다.이러한 후크를 커스터마이즈하려면 먼저 원래 구현을 찾아야 합니다. 각 앱에는 후크가 등록되는 후크 폴더가 있습니다. 이제 커스터마이즈하려는 후크를 가져와서 구성의 후크 폴더에 해당 후크를 복사합니다. 코드를 필요에 따라 변경합니다.환경 구성에는 default로 설정된 후크가 아직 있으며, 이 경우에는 앱과 함께 제공되는 기본 후크만 선택됩니다. 새 설정을 선택하려면 기본값을 구성 후크 폴더 안에 있는 Python 후크 파일의 이름으로 변경합니다.예: 후크를 커스터마이즈하는 방법다음은 앱 시작 관리자의 hook_before_app_launch 후크를 커스터마이즈하는 방법에 대한 간단한 요약입니다.      기본 후크 구현을 복사합니다. 앱과 함께 제공되는 기본 후크의 위치는 위의 이미지를 참조하십시오. 이제 이 파일을 구성 영역의 후크 폴더에 복사합니다. 예를 들어 파이프라인 구성이 /mnt/software/sgtk/big_buck_bunny에 있으면 이 파일을 /mnt/software/sgtk/big_buck_bunny/config/hooks/before_app_launch.py에 복사합니다.        Python 코드를 필요에 따라 변경합니다.        마지막으로 새 코드를 사용하도록 환경 구성을 업데이트합니다.  yaml launch_maya: engine: tk-maya extra: {} hook_app_launch: default hook_before_app_launch: before_app_launch # &amp;lt;-- uses custom hook! linux_args: '' linux_path: '@maya_linux' location: {name: tk-multi-launchapp, type: app_store, version: v0.2.4} mac_args: '' mac_path: '@maya_mac' menu_name: Launch Maya windows_args: '' windows_path: '@maya_windows'다음에 시작 앱을 실행하면 코드가 기본 후크 코드 대신 실행됩니다.",
    "url": "/425b1da4/",
    "relUrl": "/425b1da4/"
  },
  "8": {
    "id": "8",
    "title": "구성 설정",
    "content": "구성 시작하기이 안내서를 완료하면 구성에 프로젝트 정보를 추가하고, 구성을 프로젝트와 연결하고, 커스터마이즈할 파이프라인 구성을 준비하는 기본적인 지식을 갖출 수 있습니다.안내서 정보이 안내서에서는 Flow Production Tracking 데스크톱에서 고급 프로젝트 설정 마법사를 사용하여 디지털 컨텐츠 생성 파이프라인의 구성을 생성하는 방법에 대해 설명합니다. 구성 도구에 대해 간단히 살펴보고, 마법사를 사용하는 방법을 설명하며, 자세한 내용을 확인할 수 있는 자료도 제공합니다. 마법사를 사용하면 프로젝트에 대한 파이프라인 구성이 생성되고 파이프라인의 각 단계를 지원하기 위해 편집 및 확장할 수 있는 준비가 이루어집니다. 이 구성은 UI, Flow Production Tracking 앱 및 프로덕션 파이프라인을 지원하는 데 필요한 다양한 도구의 여러 측면을 제어합니다. 마법사를 사용하는 것은 구성을 확장하는 한 가지 방법에 불과합니다. 마법사에서는 파이프라인의 각 단계에 설정을 추가하고 소프트웨어 응용프로그램과의 통합도 추가할 수 있습니다. 이 안내서에서는 툴킷의 기본 구성을 기반으로 프로젝트의 구성을 설정할 것입니다.이 안내서를 학습하는 사용자는 다음과 같은 준비를 갖추어야 합니다.  고급 프로젝트 설정 마법사를 사용한 적이 없음  Flow Production Tracking 사용 방법에 대한 기초적인 지식을 갖추고 있음  Flow Production Tracking 툴킷을 처음 접함이 문서 사용이 안내서를 사용하고 프로젝트에 대해 커스터마이즈 가능한 구성을 생성하려면 다음과 같은 준비가 필요합니다.  유효한 Flow Production Tracking 사이트. 여기서 Flow Production Tracking에 등록하면 30일 무료 체험판을 다운로드해 직접 체험해 볼 수 있습니다.  Flow Production Tracking 데스크톱. 데스크톱이 설치되어 있지 않은 경우 이 링크를 따라 시작할 수 있습니다.  프로젝트 파일과 파이프라인 구성을 저장할 수 있는 파일 시스템. 파일 시스템에 Shotgun 폴더를 생성하고, 이 폴더 안에 projects 및 configs 폴더를 생성합니다.고급 프로젝트 설정 마법사 정보Flow Production Tracking 데스크톱의 고급 프로젝트 설정(Advanced Project Setup) 마법사는 기본 구성을 기반으로 파이프라인 구성을 생성합니다. 기본 구성을 사용하면 탄탄한 기초를 토대로 파이프라인 프로세스를 지원하는 커스터마이즈 가능한 설정, 앱 및 UI 요소를 작성할 수 있습니다. 이 마법사를 통해 생성되는 구성은 프로젝트의 파이프라인 요구사항을 충족하도록 편집 및 확장할 수 있습니다.기본 구성에는 다음이 포함됩니다.  디스크에서 파일이 저장되는 위치를 결정하는 기본 파일 시스템 스키마 및 템플릿  사용자의 소프트웨어 응용프로그램에서 바로 Flow Production Tracking 및 파이프라인 기능과 상호 작용할 수 있게 해 주는, 지원되는 모든 소프트웨어 통합커스터마이즈 수준은 상상력과 기발함, 그리고 프로그래밍 지식 또는 Flow Production Tracking 커뮤니티의 다른 사용자가 만든 것을 가져다 쓸 수 있는 능력 등에 따라 달라질 수 있습니다.구성 만들기모든 프로젝트에는 구성이 필요합니다. Flow Production Tracking 데스크톱을 통해 프로젝트에 처음 액세스하면 기초 구성이 다운로드되고 설정됩니다. 이 기초 구성에서는 사용자의 시스템에서 지원되는 컨텐츠 생성 소프트웨어를 자동으로 탐지하고 구성을 프로젝트와 연결합니다. 지원되는 소프트웨어 응용프로그램 내 통합은 파이프라인 구성의 설정에 의해 제어됩니다. Panel 앱에 Flow Production Tracking의 프로젝트 정보가 표시되므로 아티스트가 작업 세션을 떠나지 않고도 노트에 회신하고 버전을 확인할 수 있습니다. Publisher 앱에서는 자신의 작업물을 팀의 다른 작업자와 공유할 수 있으며 Loader 앱을 통해서는 팀원이 게시한 파일을 로드할 수 있습니다. 기초 구성에는 파일 시스템 관리 설정이나 파일 및 디렉토리의 디스크 내 명명 방식을 템플릿 개발 등이 포함되지 않습니다. 또한, 기본 구성이 설정될 때 추가되는 다양한 앱도 포함되지 않습니다. 기초 구성은 구성 파일을 직접 편집하지 않고도 툴킷을 바로 실행할 수 있게 해주는 단순한 구성입니다. 이 마법사는 기초 구성을 기본 구성으로 변환합니다. 또한, 사용자의 작업을 지원하기 위해 추가적인 앱과 소프트웨어 통합을 제공합니다. 기초 구성도 편집 가능하기는 하지만, 고급 설정을 통해 프로젝트를 커스터마이즈할 수 있도록 설정할 때까지는 편집할 수 없습니다.기초 구성과 기본 구성의 차이점            기능      기초 구성      기본 구성                  다운로드      프로젝트에 액세스하면 자동으로 다운로드됨      고급 설정 마법사를 통해 생성됨              접근성      시스템 위치에 저장됨      수동으로 편집 가능한 파일              업데이트      자동으로 업데이트됨      수동으로 업데이트됨              파일 시스템 지원      파일 시스템 스키마 지원 안 함      폴더 구조와 파일 명명 표준을 지원하는 도구 포함              소프트웨어 통합      3ds Max, Houdini, Maya, Nuke, Photoshop, Flame      기초 구성 + Hiero, Motionbulder, Mari              툴킷 앱      Flow Production Tracking Panel, Publisher, Loader      기초 구성 + Workfiles, Snap Shot, Scene Breakdown, Nuke Write Node, Houdini Mantra Node 등      이 안내서에서는 Flow Production Tracking 데스크톱의 마법사를 사용하여 기본 구성을 기반으로 프로젝트의 파이프라인 구성을 생성합니다. 이 구성을 생성하면 자체 프로덕션 파이프라인을 지원하는 데 필요한 커스터마이즈를 수행할 수 있게 됩니다.연습 시작기본 구성 사용 준비1단계: Flow Production Tracking에 “the_other_side”라는 프로젝트를 생성합니다.2단계: Flow Production Tracking 데스크톱 앱을 실행하고 Flow Production Tracking 사이트의 사용자 이름 및 암호를 사용하여 로그인합니다.3단계: 썸네일 이미지를 선택하여 마법사를 실행할 프로젝트로 이동합니다.                    팁: 데스크톱이 열려 있는 상태에서 새 프로젝트를 생성한 경우 새 프로젝트를 표시하려면 프로젝트(Projects) 창을 새로 고쳐야 할 수 있습니다. 데스크톱의 오른쪽 아래에 있는 프로파일 아바타를 선택하고 프로젝트 새로 고침(Refresh Projects)을 선택하십시오.    기본 구성 액세스프로젝트에 액세스할 때 기초 구성이 다운로드되고 설정되었습니다. Publish 앱 및 지원되는 소프트웨어 패키지가 탐지되어 Flow Production Tracking 데스크톱의 앱(Apps) 창에 자동으로 추가되었습니다.4단계: 프로젝트가 로드되면 화면 오른쪽 아래에 있는 프로파일 아바타를 선택합니다. 팝업 메뉴에서 고급 프로젝트 설정…(Advanced project setup…)을 선택하여 마법사를 시작합니다.네 개의 옵션이 있고 그중에 Shotgun 기본값(Flow Production Tracking Default)이 선택되어 있는 대화상자가 표시됩니다. 여기서 프로젝트의 파이프라인 구성을 기존 프로젝트의 구성, git 리포지토리의 구성, 디스크의 경로 중 무엇을 기반으로 할지 선택할 수 있습니다.이 연습에서는 Flow Production Tracking 기본값(Shotgun Default)을 선택하겠습니다. 이 옵션을 선택하면 Flow Production Tracking의 기본 구성을 기반으로 프로젝트의 파이프라인 구성이 생성됩니다.5단계: 계속(Continue)을 선택합니다.두 개의 옵션이 있고 그중에서 기본값(Default)이 선택되어 있는 대화상자가 표시됩니다. 이 대화상자에는 레거시(Legacy) 기본 구성 설정을 선택할 수 있는 옵션이 있습니다. 이 구성 설정은 이전 버전의 Flow Production Tracking를 계속 사용하는 스튜디오를 위해 제공되는 이전 버전의 설정입니다. 이 연습에서는 기본값(Default)을 사용하겠습니다.6단계: 계속(Continue)을 선택합니다.프로젝트 파일의 저장소 위치 정의Storage:라는 단어 옆에 드롭다운 메뉴가 표시되는 대화상자가 나타납니다.7단계: 이 프로젝트에 대한 프로젝트 데이터를 저장할 위치를 나타냅니다. 대화상자 맨 위에 있는 드롭다운에서 + 신규(+ New)를 선택하고 필드에 프로젝트(projects)를 입력합니다.Flow Production Tracking 툴킷은 세 개의 운영 체제인 Linux, Mac, Windows를 지원합니다.8단계: 프로젝트 데이터를 저장하는 데 사용되는 운영 체제 옆에 있는 필드를 선택합니다. 폴더 아이콘을 선택하고 이 연습을 진행하기 전에 파일 시스템에 생성한 프로젝트 폴더로 이동합니다.이 설정을 진행하면 프로덕션 데이터 저장 위치로 지정한 폴더에만 Flow Production Tracking가 액세스할 수 있게 됩니다. 이 연습의 준비 과정에서 Flow Production Tracking 루트 디렉토리에 projects/ 디렉토리를 추가했습니다. projects/ 디렉토리는 툴킷이 로컬 프로젝트 관련 정보를 저장할 위치입니다.9단계: 저장(Save)을 선택하여 프로젝트 데이터를 저장할 프로젝트 폴더를 지정합니다.프로젝트 데이터가 저장되는 경로를 나타내도록 운영 체제 경로가 자동으로 업데이트됩니다.10단계: 계속(Continue)을 선택합니다.프로젝트 폴더의 이름 지정텍스트 필드에 프로젝트 이름이 입력된 상태로 대화상자가 표시됩니다. 이 이름은 프로젝트 정보에서 가져와서 자동으로 입력되며 경로도 자동으로 업데이트됩니다.툴킷은 파이프라인 구성이 Flow Production Tracking에 업로드되고 각 사용자에 대해 로컬로 캐시되는 분산 설정이나 사용자가 디스크에서 공유된 위치에 있는 단일 구성에 액세스하는 중앙 집중식 설정에서도 작동할 수 있습니다. 이 연습에서는 중앙 집중식 설정을 사용하겠습니다. 분산 설정에 대한 자세한 내용은 여기서 확인할 수 있습니다.마지막 단계에서는 프로젝트와 관련된 구성을 생성하기 위해 적합한 폴더, 파일 및 데이터를 생성합니다.11단계: 해당하는 운영 체제에서 찾아보기…(Browse…)를 선택하고 이 연습을 준비할 때 생성한 구성 폴더 configs로 이동한 후 프로젝트 이름 the_other_side를 입력합니다. 그러면 폴더가 생성되고, 이 폴더에 프로젝트 구성이 저장됩니다. 설정 실행(Run Setup)을 선택하고 설정이 완료될 때까지 기다립니다.12단계: 완료(Done)를 선택하여 프로젝트 창에 나타나는 새 아이콘을 표시합니다.팁: Flow Production Tracking 데스크톱에 신속하게 액세스하기 위해 메뉴 막대에 앱을 고정할 수 있습니다. 이렇게 하려면 아바타를 선택하고 메뉴에 고정(Pin to Menu)을 선택하십시오.다 되었습니다. 프로젝트 설정이 완료되었습니다. 이제 기본 구성을 기반으로 지정한 위치에 프로젝트에 대한 툴킷 파이프라인 구성이 생성되었으므로 커스터마이즈 작업을 시작할 수 있습니다.configs 폴더를 살펴보면 여러 폴더와 파일을 보실 수 있을 것입니다. 어떠한 것들이 있는지 잠시 살펴보시기 바랍니다.이제 정말로 재미있는 내용으로, 구성으로 수행할 수 있는 모든 작업에 대해 살펴보겠습니다. 여기서 살펴볼 고급 항목은 다음과 같습니다.고급 항목Flow Production Tracking 툴킷에서는 구성을 간편하게 편집하고 복제하고 가져올 수 있는 방법을 다양하게 제공합니다. 기존의 구성을 확장하면 시간을 절약할 수 있으며 네트워크에 있는 다른 작업자가 만든 모든 멋진 구성을 이용할 수 있습니다. 필요한 구성을 찾기 위해 방대한 Flow Production Tracking 커뮤니티를 활용할 수 있습니다. Flow Production Tracking 커뮤니티는 정보를 공유하는 커뮤니티이므로 서로에게 친절하게 대하고, 작업에 도움이 되는 구성을 발견하면 작성자의 공로를 인정하고 감사의 인사를 전해 주시기 바랍니다. 그리고 Flow Production Tracking 사용자들에게 도움이 될 새로운 정보를 게시하는 것도 잊지 마십시오. 이런 식으로 우리는 서로를 도와가며 특별한 커뮤니티를 만들어 가고 있습니다!다음은 재미있게 구성 관련 작업을 진행할 수 있는 몇 가지 방법입니다.명령행을 사용하여 기본 구성 생성프로젝트 구성에서 tank 명령을 사용하여 터미널에서 관리자 명령을 실행할 수 있습니다. 프로젝트마다 고유한 전용 tank 명령이 있습니다. tank setup_project 명령의 기능은 고급 설정 마법사와 유사합니다. 이 명령은 기존 프로젝트의 구성이나 기본 구성을 기반으로 디스크에 프로젝트에 대한 편집 가능한 구성을 생성합니다. tank setup_project를 실행하는 방법에 대한 자세한 내용은 여기서 확인하고 tank 명령에 대한 자세한 내용은 여기서 확인하십시오.프로덕션 단계에 적용된 구성 편집현재 프로덕션 단계에 적용된 구성을 수정하고 싶지만 아티스트가 사용하는 동안에는 편집하고 싶지 않은 경우가 있습니다. Flow Production Tracking에서는 단 몇 개의 명령으로 기존 구성을 복사하여 수정된 구성을 프로덕션에 적용하기 전에 안전하게 수정 사항을 테스트해 볼 수 있습니다. 이 프로세스에서는 프로덕션 구성을 새 구성으로 교체하고 이전 구성은 자동으로 백업합니다.구성의 복사본을 작성하는 것은 대개 다음과 같은 이유 때문입니다.  구성 업데이트  라이브로 적용하기 전에 수정 사항 테스트  일부 앱 업그레이드 또는 추가  테스트 후 개발 진행 및 롤아웃구성을 복제하는 방법과 구성 관리에 대한 기타 기본 사항을 알아보려면 구성 스테이징 및 롤아웃 문서를 참조하십시오.파이프라인 구성의 클라우드 배포이 안내서에서는 공유 네트워크 위치에 있으면서 모든 사용자가 액세스하게 되는 파이프라인 구성의 단일 사본인 중앙 집중식 구성을 생성하는 과정을 살펴봅니다. 하지만 작업 인력이 여러 위치 및 네트워크에 분산되어 있는 경우 파이프라인 구성의 단일 사본을 공유하는 것이 가능하지 않을 수 있습니다. 이 시나리오의 툴킷을 사용하면 분산 구성 옵션을 통해 파이프라인 구성을 Flow Production Tracking에 업로드할 수 있으며 사용자가 프로젝트에 액세스할 때마다 구성이 다운로드되고 로컬로 캐시됩니다. Core API 개발자 문서에서 분산 구성에 대한 자세한 내용을 알아볼 수 있습니다.둘 이상의 루트 폴더 사용스튜디오에서 대개 특정한 작업에 맞게 최적화하는 것을 이상적으로 여깁니다. 둘 이상의 루트 폴더를 사용하여 한 서버에서는 데일리를 위한 비디오 재생과 같은 작업을, 다른 서버에서는 대화식 처리를 수행하는 식으로 작업을 최적화할 수 있습니다. 툴킷에서는 이와 같은 워크플로우를 용이하게 하기 위해 둘 이상의 저장소 루트를 사용할 수 있도록 허용합니다. 단일 루트에서 다중 루트 구성으로 변환하는 방법을 확인하십시오.프로젝트에 대한 파이프라인 구성을 갖추었으므로 편집을 시작해 보시기 바랍니다. 다음 안내서인 파이프라인 구성 편집으로 이동하여 방법을 알아보십시오.",
    "url": "/5d83a936/",
    "relUrl": "/5d83a936/"
  },
  "9": {
    "id": "9",
    "title": "Alias Flow Production Tracking 워크플로우",
    "content": "Alias Flow Production Tracking 워크플로우이 워크플로우에서는 자동차 설계에 Flow Production Tracking 및 Alias를 사용하는 방법을 다룹니다. 관련된 튜토리얼은 다음을 참조하십시오.  자동차 디자인의 아티스트 워크플로우  자동차 소개 튜토리얼",
    "url": "/7584b650/",
    "relUrl": "/7584b650/"
  },
  "10": {
    "id": "10",
    "title": "앱 및 엔진 구성 참조",
    "content": "앱 및 엔진 구성 참조이 문서에서는 Flow Production Tracking Toolkit의 앱, 엔진 및 프레임워크에 대한 구성을 만들 때 포함할 수 있는 다양한 모든 옵션을 개략적으로 설명합니다. 이러한 옵션은 앱의 고급 구성을 수행할 때 유용할 수 있으며, 개발 중에 매개변수를 앱 구성 매니페스트에 추가해야 할 때 중요합니다.이 문서에서는 툴킷 구성에 대한 제어 권한이 있는 경우에만 사용할 수 있는 기능에 대해 설명합니다. 자세한 내용은 Flow Production Tracking 통합 관리자 안내서를 참조하십시오.소개이 문서에서는 Sgtk에서 구성과 설정을 위해 사용하는 다양한 파일 형식에 대한 사양을 설명합니다. 이 문서는 사용 가능한 다양한 옵션과 매개변수에 대해 간략히 설명하는 참조 문서입니다. 구성을 관리하는 방법에 대한 모범 사례는 다음 문서를 참조하십시오.구성 관리 모범 사례Flow Production Tracking Toolkit 환경툴킷에는 세 가지 주요 구성요소가 있습니다.  엔진 은 호스트 응용프로그램(예: Maya 또는 Nuke)과 Sgtk 앱 간에 전환 계층 또는 어댑터를 제공합니다. 앱은 일반적으로 Python과 PySide를 사용하고 엔진은 호스트 응용프로그램을 표준화된 방식으로 표시하는 작업을 담당합니다. 예를 들어 호스트 응용프로그램 상위에 PySide가 없으면 추가합니다.  앱 은 비즈니스 로직을 제공하며 본질적으로 특정 작업을 수행하는 도구입니다. 앱은 특정 호스트 응용프로그램에서 작업하거나 둘 이상의 호스트 응용프로그램에서 실행되도록 설계할 수 있습니다.  프레임워크 는 엔진, 앱 또는 기타 프레임워크에서 사용할 수 있는 라이브러리입니다. 프레임워크를 사용하면 여러 앱 간에 공유되는 코드 또는 동작을 보다 쉽게 관리할 수 있습니다.환경 파일 에는 엔진, 앱 및 프레임워크 컬렉션에 대한 구성 설정이 있습니다. 이러한 컬렉션을 환경이라고 합니다. Sgtk는 파일이나 작업자별로 다른 환경을 시작합니다. 예를 들어 샷 프로덕션용 환경과 리깅용 환경을 구성할 수 있습니다. 각 환경은 단일 yaml 파일입니다.환경 파일은 /&amp;lt;sgtk_root&amp;gt;/software/shotgun/&amp;lt;project_name&amp;gt;/config/env에 있습니다.yaml 파일의 기본 형식은 다음과 같습니다.    engines:        tk-maya:            location            engine settings                apps:                tk-maya-publish:                    location                    app settings                    tk-maya-revolver:                    location                    app settings            tk-nuke:            location            engine settings                apps:                tk-nuke-setframerange:                    location                    app settings                    tk-nuke-nukepub:                    location                    app settings        frameworks:        tk-framework-tools:            location            framework settings각 앱과 엔진은 설정을 통해 구성할 수 있습니다. 이러한 설정은 앱/엔진이 매니페스트 파일 info.yml에 표시하는 설정 목록과 일치합니다. Sgtk Core의 v0.18.x에서는 매니페스트 파일에 지정된 기본값과 다를 경우에만 설정을 지정해야 합니다. 매니페스트 파일 외에도 일반적으로 툴킷 앱 스토어 내의 앱/엔진 페이지에서 구성 가능한 설정을 찾을 수 있습니다.각 앱, 엔진 및 프레임워크는 각 항목에 대해 정의할 수 있는 다양한 설정 외에도 코드가 있는 위치를 정의해야 합니다. 이 작업은 특수 location 매개변수를 사용하여 수행됩니다.코드 위치환경 파일에 정의된 각 앱, 엔진 또는 프레임워크에는 실행할 앱 버전과 다운로드 위치를 정의하는 location 매개변수가 있습니다. 대부분의 경우 tank updates 및 tank install 명령에 의해 자동으로 처리됩니다. 그러나 구성을 직접 편집하는 경우 툴킷을 배포하고 구조화할 수 있도록 하는 다양한 옵션을 사용할 수 있습니다.툴킷은 현재 다음 위치 디스크립터 를 사용한 앱 설치 및 관리를 지원합니다.  app_store 디스크립터는 툴킷 앱 스토어의 항목을 나타냅니다.  Flow Production Tracking 디스크립터는 Flow Production Tracking에 저장된 항목을 나타냅니다.  git 디스크립터는 git 리포지토리의 태그를 나타냅니다.  git_branch 디스크립터는 git 분기의 커밋을 나타냅니다.  path 디스크립터는 디스크상의 위치를 나타냅니다.  dev 디스크립터는 개발자 샌드박스를 나타냅니다.  manual 디스크립터는 커스텀 배포 및 롤아웃에 사용됩니다.다양한 디스크립터 사용 방법에 대한 자세한 정보는 툴킷 참조 문서를 참조하십시오.앱 및 엔진 비활성화때로는 앱이나 엔진을 일시적으로 비활성화하는 것이 유용할 수 있습니다. 이 작업을 수행할 때는 앱 또는 엔진을 로드해야 하는 위치를 지정하는 위치 사전에 disabled: true 매개변수를 추가하는 것이 좋습니다. 이 구문은 서로 다른 위치 유형 모두에서 지원됩니다. 예를 들어 다음과 같이 표시될 수 있습니다.location: {&quot;type&quot;: &quot;app_store&quot;, &quot;name&quot;: &quot;tk-nukepublish&quot;, &quot;version&quot;: &quot;v0.5.0&quot;, &quot;disabled&quot;: true}또는 특정 플랫폼에서만 앱을 실행하려면 특별한 deny_platforms 설정을 사용하여 지정할 수 있습니다.location: {&quot;type&quot;: &quot;app_store&quot;, &quot;name&quot;: &quot;tk-nukepublish&quot;, &quot;version&quot;: &quot;v0.5.0&quot;, &quot;deny_platforms&quot;: [windows, linux]}deny_platforms 매개변수의 가능한 값은 windows, linux 및 mac입니다.설정 및 매개변수각 앱, 엔진 또는 프레임워크는 구성 파일에서 재정의할 수 있는 여러 가지 설정을 명시적으로 정의합니다. 이러한 설정은 문자열, 정수, 목록 등에 명확히 입력됩니다. 자세한 내용은 툴킷 참조 문서를 참조하십시오.",
    "url": "/6d10dedf/",
    "relUrl": "/6d10dedf/"
  },
  "11": {
    "id": "11",
    "title": "내 컨텍스트에 존재하는 값이 as_template_fields()에 누락되었습니다.",
    "content": "내 컨텍스트에 존재하는 값이 as_template_fields()에 누락되었습니다.as_template_fields() 방식은 템플릿의 키에 해당하는 폴더가 아직 생성되지 않은 경우 경로 캐시를 사용하며, 그러면 필드가 반환되지 않습니다. 이 문제는 여러 이유에서 발생할 수 있습니다.  템플릿 정의 및 스키마가 동기화 상태여야 합니다. 이 템플릿 정의, 또는 파이프라인 구성의 스키마를 수정했는데 둘 모두 동기화되지 않은 경우 예상한 필드가 반환되지 않습니다.  이 특정 컨텍스트에 대해 폴더가 생성되지 않았습니다. 아직 생성되지 않았다면 경로 캐시에 일치되는 레코드가 없게 되고, 따라서 예상한 필드가 반환되지 않습니다.",
    "url": "/8d9d2658/",
    "relUrl": "/8d9d2658/"
  },
  "12": {
    "id": "12",
    "title": "ascii 코덱이 위치 10의 바이트 0x97을 디코딩할 수 없음",
    "content": "ASCII 코덱이 위치 10의 바이트 0x97을 디코딩할 수 없음: 서수가 범위에 없음관련 오류 메시지:구성을 복제하는 동안  TankError: ascii 파일 시스템 구조를 만들 수 없음! 코덱이 위치 10의 바이트 0x97을 디코딩할 수 없음: 서수가 범위(128)에 없음다른 프로젝트를 사용하여 프로젝트 구성을 설정하는 동안  “‘ascii’ 코덱이 위치 10의 바이트 0x97을 디코딩할 수 없음: 서수가 범위(128)에 없음”해결 방법:일반적으로 “config” 폴더에 유니코드/특수 문자가 있는 경우 이 오류가 표시됩니다. 특수 문자를 찾을 수 있는지 확인하는 것이 좋습니다.이 오류가 발생하는 원인의 예:이 경우 오류는 Windows에서 파일 이름 끝에 – 접미어를 추가하여 발생했습니다. 해당 파일을 모두 제거한 후 작업이 시작되었습니다.커뮤니티에서 전체 스레드를 참조하십시오.",
    "url": "/483eb2db/",
    "relUrl": "/483eb2db/"
  },
  "13": {
    "id": "13",
    "title": "AWS Knowledge",
    "content": "AWS KnowledgeBelow you can find links to additional reading material from AWS, including documentation on technologies leveraged by the Isolation feature set, as well as compliance information:  [AWS Media Blog] Securing Studio IP in AWS: Cloud-based VFX Project Management with Autodesk Shotgun  [AWS Media Blog] Designing for Studio-Grade Security  [Compliance] MPAA &amp;amp; Studio Security  [AWS Direct Connect] Overview          [AWS Direct Connect] User Guide        [AWS S3] Overview          [AWS S3] User Guide        [AWS EC2] Overview          [AWS EC2] User Guide        [AWS VPC] Overview          [AWS VPC] User Guide        [AWS PrivateLink] Overview",
    "url": "/5528234a/",
    "relUrl": "/5528234a/"
  },
  "14": {
    "id": "14",
    "title": "웹후크 배치 전달",
    "content": "배치 전달배치 전달(Batch) 활성화“배치 형식으로 전달(Deliver in Batched Format)” 옵션을 선택하면 배치 페이로드 형식으로 요청할 수 있도록 웹후크를 구성할 수 있습니다.이 옵션이 활성화된 경우 각 요청의 형식이 지정되면 해당 페이로드에 보류 중인 전달이 최대 50개까지 일괄 처리됩니다.짧은 시간 내에 많은 SG 이벤트가 발생하는 경우 이 방법은 대량의 전달 처리를 관리하는 데 도움을 줍니다. 일반적인 시스템 작업 중에 구독 이벤트가 2초에 두 번 이상 생성되는 경우에는 페이로드당 여러 건의 전달이 발생합니다.전달에 대한 응답배치(Batch) 전달을 활성화한 경우, 수신 서비스가 이벤트당 1초 이하의 빠른 응답 속도를 보장하도록 설계하는 것이 좋습니다. 그러지 않으면 배치가 큰 경우에 시간 초과 및 웹후크 오류 위험이 증가합니다.                    참고: 단일 이벤트에 응답하는 데 1초가 걸리는 수신 서비스의 경우 응답 시간은 전달 오버헤드가 아니라 주요 성능 요소입니다. 이 경우 배치 처리를 선택해도 큰 이점이 없습니다.    비배치 전달 웹후크  시간 초과 허용치는 전달당 6초입니다. 즉, 웹후크 엔드포인트는 6초 내에 각 요청에 응답해야 합니다.배치 전달 웹후크  배치에서 시간 초과 허용치의 최대값은 6초, 또는 배치 내 이벤트당 1초입니다.  스로틀링 한계로는 모든 웹후크에서 Flow Production Tracking 사이트별로 분당 1분의 웹후크 엔드포인트 응답 시간이 적용됩니다.웹후크 전달 형식 비교비배치 전달 웹후크 메시지 본문(항상 1개의 전달):{  &quot;data&quot;:{    &quot;id&quot;:&quot;119.110.0&quot;,    &quot;event_log_entry_id&quot;:479004,    &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,    &quot;operation&quot;:&quot;update&quot;,    &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},    &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1419},    &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:127},    &quot;meta&quot;:{      &quot;type&quot;:&quot;attribute_change&quot;,      &quot;attribute_name&quot;:&quot;code&quot;,      &quot;entity_type&quot;:&quot;Asset&quot;,      &quot;entity_id&quot;:1419,      &quot;field_data_type&quot;:&quot;text&quot;,      &quot;old_value&quot;:&quot;Cypress test asset for Webhooks deliveries&quot;,      &quot;new_value&quot;:&quot;Revised test asset for Webhooks deliveries&quot;    },    &quot;created_at&quot;:&quot;2021-02-22 17:40:23.202136&quot;,    &quot;attribute_name&quot;:&quot;code&quot;,    &quot;session_uuid&quot;:null,  },  &quot;timestamp&quot;:&quot;2021-02-22T17:40:27Z&quot;}배치 전달 웹후크 메시지 본문(1~50개의 전달이 포함될 수 있음)배치가 활성화된 경우 배치에 이벤트가 하나만 있어도 deliveries 키가 항상 존재합니다. 이 값은 개별 이벤트 전달 데이터의 배열이며 각 전달에 제공된 정보는 배치 해제 모드와 동일합니다.{  &quot;timestamp&quot;:&quot;2021-02-22T18:04:40.140Z&quot;,  &quot;data&quot;:{    &quot;deliveries&quot;:[      {        &quot;id&quot;:&quot;170.141.0&quot;,        &quot;event_log_entry_id&quot;:480850,        &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,        &quot;operation&quot;:&quot;update&quot;,        &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},        &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1424},        &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:132},        &quot;meta&quot;:{          &quot;type&quot;:&quot;attribute_change&quot;,          &quot;attribute_name&quot;:&quot;code&quot;,          &quot;entity_type&quot;:&quot;Asset&quot;,          &quot;entity_id&quot;:1424,          &quot;field_data_type&quot;:&quot;text&quot;,          &quot;old_value&quot;:&quot;Cypress test asset for Webhooks deliveries&quot;,          &quot;new_value&quot;:&quot;Revised test asset for Webhooks deliveries&quot;        },        &quot;created_at&quot;:&quot;2021-02-22 18:04:39.198641&quot;,        &quot;attribute_name&quot;:&quot;code&quot;,        &quot;session_uuid&quot;:null,      },      {        &quot;id&quot;:&quot;170.141.1&quot;,        &quot;event_log_entry_id&quot;:480851,        &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,        &quot;operation&quot;:&quot;update&quot;,        &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},        &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1424},        &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:132},        &quot;meta&quot;:{          &quot;type&quot;:&quot;attribute_change&quot;,          &quot;attribute_name&quot;:&quot;description&quot;,          &quot;entity_type&quot;:&quot;Asset&quot;,          &quot;entity_id&quot;:1424,          &quot;field_data_type&quot;:&quot;text&quot;,          &quot;old_value&quot;:null,          &quot;new_value&quot;:&quot;Some other *description*&quot;        },        &quot;created_at&quot;:&quot;2021-02-22 18:04:39.212032&quot;,        &quot;attribute_name&quot;:&quot;description&quot;,        &quot;session_uuid&quot;:null,      },    ]  }}",
    "url": "/e7890fc8/",
    "relUrl": "/e7890fc8/"
  },
  "15": {
    "id": "15",
    "title": "첫 번째 프로젝트 실행 이후 작업",
    "content": "첫 번째 프로젝트 실행 이후 작업이제 Flow Production Tracking 데스크톱을 사용하여 첫 번째 프로젝트를 실행한 후의 작업에 대해 설명하겠습니다. 여기서는 공통 질문 및 주제를 다루고 유용한 문서 리소스를 소개합니다.툴킷 소개툴킷 소개 이 문서를 읽고 있다면 Flow Production Tracking 데스크톱을 사용하여 첫 번째 Flow Production Tracking Toolkit 프로젝트를 성공적으로 설치했다는 것을 의미합니다.이 단계에서는 이미 프로젝트를 실행 중이고 위의 스크린샷처럼 여러 응용프로그램 시작 관리자가 있는 프로젝트 페이지가 표시되어 있어야 합니다. 이제 Maya, Nuke 또는 다른 응용프로그램을 열어 보십시오. 파일 및 에셋을 관리하기 위한 추가 기능이 있는 Flow Production Tracking 메뉴를 찾아야 합니다.다음으로 수행할 작업은 무엇일까요? 툴킷은 구성 및 작동 방식 면에서 많은 유연성을 제공합니다. 이 문서에서는 Flow Production Tracking 데스크톱을 사용하여 첫 번째 프로젝트를 실행한 후에 수행하면 좋은 일부 단계에 대해 설명합니다.기초 구성이 섹션에는 구성에 필요한 여러 가지 조정 및 유용한 정보가 포함되어 있습니다. 첫 번째 툴킷 프로젝트를 방금 설정했다면 아마도 올바른 작동을 위해 여러 가지 설정을 조금씩 조정해야 할 것입니다. 이 섹션에서는 이러한 다양한 단계를 설명합니다. 이 중 일부는 구성 파일 편집 및 내부적으로 진행되는 작업과 관련이 있습니다. 궁금한 사항이 있으시면 언제든지 지원 사이트를 방문해 도움을 주시기 바랍니다.응용프로그램 경로 설정첫 번째 프로젝트를 설정하고 시작 버튼 중 하나를 클릭하여 Maya, Motionbuilder 또는 Nuke를 시작하면 다음과 같은 오류 메시지가 표시될 수 있습니다.툴킷 프로젝트 구성에는 시작할 수 있는 다양한 실행 파일의 경로가 저장됩니다. 위의 메시지가 표시되면 해당 경로가 스튜디오 설정과 일치하지 않는 것일 수 있습니다. 또한 잘못된 버전의 응용프로그램이 시작되고 있음을 알 수 있습니다. 예를 들어 기본 구성에는 Maya 2015 경로가 있지만 스튜디오는 Maya 2014를 실행 중일 수 있습니다. 이 경우 경로를 변경해야 합니다.기본 구성에서 이러한 경로는 모두 paths.yml이라는 단일 파일에 저장됩니다. 경로를 변경하려면 디스크에서 프로젝트 구성을 찾은 다음 paths.yml 파일을 찾을 때까지 config 폴더를 탐색합니다.이 파일을 열고 경로를 원하는 대로 변경합니다. 파일을 저장한 후에는 Flow Production Tracking 데스크톱에 프로젝트를 그대로 두고 다시 클릭해야 합니다. 그러나 전체 응용프로그램을 다시 시작할 필요는 없습니다.추가 정보응용프로그램에 대한 자세한 정보는 다음 항목을 참조하십시오.  툴킷 응용프로그램 시작 관리자  명령행 인자 전달Flow Production Tracking 통합툴킷은 Flow Production Tracking와 통합되며 UI의 다양한 부분에 특별한 툴킷 액션 메뉴 항목을 추가하여 기존 인터페이스를 확장합니다.이를 통해 Flow Production Tracking에서 직접 데이터를 조작하는 툴킷 응용프로그램 또는 커스텀 도구를 시작할 수 있게 됩니다. 통합에 대한 자세한 내용은 Flow Production Tracking 사이트, 관리 안내서의 브라우저 통합 섹션을 참조하십시오.Flow Production Tracking UI에 게시 추가툴킷을 설치한 후에는 일반적으로 Flow Production Tracking UI 레이아웃을 약간 조정하는 것이 좋습니다. Flow Production Tracking Toolkit은 파일을 게시할 때 게시 엔티티 를 만들므로 에셋 및 샷과 같은 주요 에셋에 게시(Publishes) 탭 을 추가하기에 편리합니다. 이렇게 하려면 관리자(admin)로 로그인해야 합니다. 에셋 또는 샷으로 이동하고 디자인 모드 를 시작합니다.이제 탭 중 하나에서 작은 메뉴 삼각형을 클릭하고 새 탭 추가(Add New Tab) 액션을 선택합니다. 그러면 대화상자 UI가 나타납니다. 게시(Publishes) 탭을 호출하고 게시된 파일(Published File) 엔티티와 연결되어 있는지 확인합니다.이제 저장(Save) 을 클릭하여 변경 사항을 저장합니다. 설정이 끝났습니다.참고: 사용자가 새 탭을 만들 때 Flow Production Tracking는 몇 개의 기본 필드를 선택하여 가져옵니다. 게시할 필드를 몇 개 더 추가할 수 있습니다. 새 게시 탭에서 볼 수 있는 스프레드시트의 오른쪽 상단에 있는 작은 더하기 버튼을 클릭하면 됩니다. 다음 필드를 추가하는 것이 좋습니다.  설명(Description) - 이 게시에서 변경한 사항에 대한 설명 저장  만든 사람(Created by) - 게시를 만든 사용자  만든 날짜(Date Created) - 게시를 만든 날짜레이아웃을 변경하는 경우 완료 후 반드시 페이지를 저장해야 합니다.다중 운영 체제경우에 따라 설명서의 이 섹션에 대한 링크와 함께 Python을 찾을 수 없음(Python cannot be found)이라는 메시지가 표시될 수 있습니다.툴킷은 Python이라는 언어를 사용하여 스크립트와 기능을 실행합니다. Flow Production Tracking 데스크톱에는 완전한 Python 설치가 기본 제공되므로 보통은 이 메시지에 대해 신경쓸 필요가 없습니다. Flow Production Tracking 데스크톱을 사용하여 새 툴킷 프로젝트를 설정한 경우 프로젝트는 기본적으로 Flow Production Tracking 데스크톱과 함께 번들로 제공되는 Python을 사용하도록 설정됩니다. 그러나 툴킷에 Python을 사용하도록 명시적으로 알려야 할 때도 있습니다. 다음과 같은 경우를 예로 들 수 있습니다.  모든 Python 기본값을 자동으로 설정하지 않는 이전 버전의 Flow Production Tracking 데스크톱을 사용할 경우  Flow Production Tracking 데스크톱을 디스크의 표준 위치가 아닌 위치에 설치한 경우  수동 또는 복잡한 툴킷 프로젝트 설정을 실행하는 경우Python 경로는 수동으로 편집할 수 있는 구성 파일에 저장됩니다.올바른 파일을 찾으려면 먼저 프로젝트 구성으로 이동합니다. 그런 다음 interpreter_로 시작하는 트리 파일을 찾습니다. 여기에는 Linux, Windows 및 Mac(“Darwin”)용 Python 인터프리터에 대한 경로가 포함되어 있습니다. 이러한 파일에는 세 가지 운영 체제 각각에 대한 Python의 위치가 들어 있습니다. 이제 사용하려는 운영 체제에 대한 Python 위치를 수동으로 추가해야 합니다.파일이 비어 있으면 이전 버전의 Flow Production Tracking 데스크톱을 사용하고 있는 것입니다. 이 경우 빈 파일을 기본 Python 경로로 업데이트하십시오. 다음을 참조하십시오.  Macosx(Darwin): /Applications/Shotgun.app/Contents/Frameworks/Python/bin/python  Windows: C: Program Files Shotgun Python python.exe  Linux: /opt/Shotgun/Python/bin/pythonFlow Production Tracking 데스크톱을 표준 위치가 아닌 곳에 설치했거나 별도로 설정한 Python 위치를 사용하려는 경우 파일 경로가 유효한 Python 설치를 가리키는지 확인합니다. Python은 v2.6 이상이어야 합니다(단, Python 3 제외). UI 기반 응용프로그램과 도구를 실행하려면 지정한 Python에 PyQt 또는 PySide가 설치되어 있고 QT v4.6 이상에 링크되어 있는지 확인하십시오.또한 여러 운영 체제에서 툴킷을 실행하려면 프로젝트 설정 마법사를 실행할 때 원하는 모든 플랫폼에 대한 경로를 지정해야 합니다. 이 작업을 수행하지 않고 저장소 경로 또는 구성 위치에 추가 운영 체제를 추가하려는 경우 지원 사이트에서 도움을 요청하십시오.다음 단계이제 Flow Production Tracking 프로젝트(또는 테스트 프로젝트)에서 기본 Flow Production Tracking 설정을 사용할 수 있습니다. 응용프로그램이 시작되고 상황에 맞는 메뉴 액션 및 게시가 Flow Production Tracking에 표시되고 항목이 원하는 운영 체제 플랫폼에서 작동합니다.다음 섹션에서는 해당 기본 구성을 가져와 나머지 스튜디오 파이프라인처럼 작동하도록 조정하는 프로세스에 대해 설명합니다. 툴킷은 유연하고 상세한 구성이 가능하며 당사에서는 많은 문서를 제공합니다. 시작하기 전에 실제 모든 작동 방식을 확인하려면 몇 분 정도 시간을 내어 다양한 연습 동영상을 확인하는 것이 좋습니다. 이 동영상은 Flow Production Tracking Toolkit이 Maya 및 Nuke와 같은 응용프로그램 내에서 작동하는 방식을 보여 줍니다. 또한 게시, 버전 제어, 로딩 등과 같은 기본 개념도 설명합니다.툴킷 프로젝트 분석새로운 툴킷 프로젝트를 만들면 몇 가지 주요 위치에 구성됩니다.  Flow Production Tracking 데스크톱 및 해당 구성은 로컬 시스템에 설치됩니다. 원하는 경우 응용프로그램과 구성을 공유 저장소에 재배치할 수 있습니다.  툴킷 프로젝트는 텍스처, 파일, 렌더링 등을 데이터 영역에 저장합니다. 이 데이터를 다른 사용자와 공유하기 때문에 일반적으로 이 영역은 공유 저장소에 있지만 이 규칙에는 예외가 있습니다. 사용자 작업 영역은 로컬(사용자 전용) 저장소에 저장할 수 있으며 Perforce 통합과 같은 통합은 외부 시스템을 사용하여 컨텐츠를 배포하는 데 도움이 됩니다.  툴킷 구성은 코드, 앱, Core API 등을 비롯하여 완전한 자체 포함 번들입니다. 이 구성은 일반적으로 공유 저장소에 저장되므로 모든 사용자가 쉽게 액세스할 수 있습니다.디스크의 프로젝트 구성에는 몇 가지 서로 다른 항목이 있습니다.다음 섹션에서는 프로젝트 구성 폴더의 여러 부분을 살펴보겠습니다.명령줄 액세스Flow Production Tracking 데스크톱뿐만 아니라 터미널 또는 셸을 통해 툴킷에 액세스할 수도 있습니다. 디스크에 생성하는 각 프로젝트에는 API 세션 시작 및 응용프로그램 시작을 포함하여 많은 기능에 명령행 기반으로 액세스할 수 있는 특수 tank 명령이 있습니다.프로젝트 구성으로 이동하면 구성 루트에 tank 및 tank.bat 명령이 표시됩니다. 옵션 없이 이러한 명령을 실행하면 다음의 유용한 명령을 포함하여 현재 구성에서 지원되는 모든 명령 목록을 확인할 수 있습니다.  tank shell - tk api 액세스 권한으로 대화형 Python 셸 시작  tank core - 이 프로젝트에 사용할 수 있는 Core API 업데이트가 있는지 확인  tank updates - 이 구성의 앱이나 엔진에 사용 가능한 업데이트가 있는지 확인tank 명령을 사용하여 수행할 수 있는 작업에 대한 자세한 정보는 자세한 기술 문서를 참조하십시오.툴킷 관리 방법주요 구성 파일config 폴더에는 몇 가지 주요 구성 파일이 있습니다.응용프로그램을 시작할 때 필요한 모든 구조가 디스크상에 있고 사전에 준비되도록 하기 위해 디스크에 폴더를 자동으로 만드는 폴더 생성 시스템이 툴킷과 함께 제공됩니다. 이에 대한 구성은 위에 표시된 schema 폴더에서 찾을 수 있습니다.또한 툴킷 템플릿 시스템 을 함께 사용하면 게시, 작업 파일, 렌더링 등 구성할 수 있는 파일에 대한 다양한 경로를 쉽게 정의할 수 있습니다. 이 항목은 위의 templates.yml 파일에 저장됩니다.프로젝트 구성의 이 두 부분을 함께 사용하면 툴킷이 기존 파이프라인에서 이해할 수 있도록 디스크의 위치에 데이터를 기록하는 데 사용되는 다양한 앱을 조정할 수 있습니다.자세한 정보는 다음과 같은 고급 문서를 참조하십시오.  폴더 구성  파일 시스템 템플릿기본적으로 툴킷은 구성된 앱 및 엔진의 모음으로 구성됩니다. 이 구성은 env 폴더에 있습니다. 위에 설명된 파일 시스템 구성 파일이 디스크상에서의 리소스 위치 를 정의하면 해당 앱 및 엔진이 있는 환경 구성이 파이프라인이 수행해야 할 작업 을 정의합니다.Core API 플랫폼각 프로젝트 구성은 앱 및 엔진의 컬렉션을 사용합니다. 이러한 앱 및 엔진의 구성은 구성 내의 env 폴더에 저장됩니다. 툴킷은 이러한 앱 및 엔진을 실행하는 데 필요한 다양한 버전의 코드를 자동으로 다운로드하고 관리합니다. 코드는 install 폴더 안에 있습니다.구성, 앱 및 엔진은 모두 Toolkit Core 플랫폼 상단에서 실행됩니다. 새로운 프로젝트의 경우 install 폴더 내에도 저장됩니다. 기본적으로 프로젝트 구성은 완전하게 자체 포함되어 있습니다. 즉, 툴킷을 실행하는 데 필요한 모든 부분이 단일 위치에 있습니다. 또한 각 프로젝트가 독립적이며 하나의 프로젝트를 업데이트해도 다른 프로젝트가 중단되지 않는다는 것을 의미합니다.기술 참고 사항: 공유 Toolkit Core 사용(클릭하여 확장)추가 정보Flow Production Tracking Toolkit의 개략적인 개념을 살펴보고 ‘전체적인 내용’을 설명하는 좀 더 기술적인 문서도 있습니다. 툴킷이 기본적으로 제공하는 기능을 잘 이해한 다음 이러한 문서로 옮겨가서 특정 스튜디오 요구 사항에 맞게 툴킷을 조정할 수 있는 방법을 더 깊이 이해하는 것이 좋습니다.Flow Production Tracking 툴킷의 개괄적인 개념에 대한 소개툴킷 커뮤니티TD 및 파이프라인 엔지니어의 커뮤니티는 툴킷의 한 부분을 구성합니다. 우리는 강력하고 유연한 파이프라인 환경으로 툴킷을 함께 개선할 수 있는 역동적인 코드 공유 커뮤니티를 만드는 데 주력하고 있습니다.궁금한 점이 있거나 기존 게시물 및 논의를 살펴보고 싶다면 커뮤니티를 방문하십시오.",
    "url": "/c3b662a6/",
    "relUrl": "/c3b662a6/"
  },
  "16": {
    "id": "16",
    "title": "Flow Production Tracking 데스크톱/브라우저 통합을 Linux에서 실행할 수 없습니다",
    "content": "Flow Production Tracking 데스크톱/브라우저 통합을 Linux에서 실행할 수 없습니다Linux에서 Flow Production Tracking 데스크톱을 처음 실행하면 다음 오류 메시지 중 하나가 나타날 수 있습니다. 그러면 해당 오류에 대해 아래 단계를 수행하여 오류가 해결되는지 확인해 보십시오.여전히 해결되지 않으면 지원 사이트에서 도움을 요청하십시오.목차  OPENSSL_1.0.1_EC 또는 HTTPSConnection 관련 문제  libffi.so.5 관련 문제  인증서 유효성 확인 실패 관련 문제  호환되지 않는 Qt 버전OPENSSL_1.0.1_EC 또는 HTTPSConnection 관련 문제오류importing '/opt/Shotgun/Resources/Python/tk-framework-desktopstartup/python/server/resources/python/dist/linux/cryptography/_Cryptography_cffi_36a40ff0x2bad1bae.so': /opt/Shotgun/Resources/Python/tk-framework-desktopstartup/python/server/resources/python/dist/linux/cryptography/_Cryptography_cffi_36a40ff0x2bad1bae.so: symbol ECDSA_OpenSSL, version OPENSSL_1.0.1_EC not defined in file libcrypto.so.10 with link time referenceAttributeError: 'module' object has no attribute 'HTTPSConnection'솔루션OpenSSL을 설치해야 합니다. 설치하려면 다음 명령을 관리자 권한으로 실행합니다.$ yum install openssllibffi.so.5 관련 문제오류Browser Integration failed to start. It will not be available if you continue.libffi.so.5: cannot open shared object file: No such file or directory솔루션libffi를 설치해야 합니다. 설치하려면 다음 명령을 관리자 권한으로 실행합니다.yum install libffilibffi를 설치했는데도 여전히 작동하지 않으면 다음 symlink를 생성한 후 Flow Production Tracking 데스크톱을 다시 실행해 보십시오.sudo ln -s /usr/lib64/libffi.so.6.0.1 /usr/lib64/libffi.so.5위 방법으로 성공한 사용자들도 있고, 그렇지 못한 사용자들도 있습니다. 최신 버전 Flow Production Tracking 데스크톱에는 웹 소켓 서버에 대한 종속성이 일부 추가되었습니다. 현재 Shotgun 팀에서 해당 내용을 살펴보고 있습니다.인증서 유효성 확인 실패 관련 문제가능한 오류Browser Integration failed to start. It will not be available if you continue.Error: There was a problem validating if the certificate was installed.certutil: function failed: SEC_ERROR_BAD_DATABASE: security library: bad database.솔루션컴퓨터에 Google Chrome이 설치되어 있다면 이를 실행한 다음 Flow Production Tracking 데스크톱을 다시 실행합니다. 그래도 문제가 발생하면 지원 사이트에서 도움을 요청하십시오.Chrome이 없으면 터미널을 열고 다음 명령을 실행합니다.ls -al $HOME/.pki/nssdb해당 폴더가 검색되면 지원 팀에 문의하고, 다음 로그 파일의 내용을 지원 요청 티켓에 첨부해 주십시오.~/.shotgun/logs/tk-desktop.log폴더가 검색되지 않으면 다음을 입력합니다.$ mkdir --parents ~/.pki/nssdb$ certutil -N -d &quot;sql:$HOME/.pki/nssdb&quot;암호를 입력하지 마십시오.Flow Production Tracking 데스크톱을 실행하면 이제 올바로 작동할 것입니다.호환되지 않는 Qt 버전가능한 오류호환되지 않는 Qt 라이브러리(버전 0x40805)를 이 라이브러리(버전 0x40807)와 혼합할 수 없음솔루션이 오류는 대개 재정의가 발생하면서 호환되지 않는 Qt 라이브러리를 로딩하게 됨에 따라 발생합니다.이 오류가 발생하지 않도록 하려면 다음 명령으로 환경을 수정해 보십시오.unset QT_PLUGIN_PATH",
    "url": "/9207f027/",
    "relUrl": "/9207f027/"
  },
  "17": {
    "id": "17",
    "title": "Chrome에서 로컬 파일 링크를 사용할 수 없으며, 툴킷 응용프로그램도 실행할 수 없습니다",
    "content": "Chrome에서 로컬 파일 링크를 사용할 수 없으며, 툴킷 응용프로그램도 실행할 수 없습니다개요간혹 Flow Production Tracking의 액션 메뉴에 사용 가능한 툴킷 응용프로그램 목록이 표시되지 않거나, Flow Production Tracking 데스크톱이 실행 중인데도 로컬 파일 링크를 사용하면 오류가 발생할 수 있습니다. 이 문서는 Chrome에서 Flow Production Tracking 데스크톱의 브라우저 통합 문제를 해결하고, 원하는 기능들이 제대로 작동하도록 지원하는 안내서입니다. Firefox의 경우 별도의 안내서가 있습니다.  문제 진단  인증서 문제를 빠르게 해결하는 방법  모든 플랫폼에서 ERR_CERT_COMMON_NAME_INVALID 또는 ERR_SSL_SERVER_CERT_BAD_FORMAT 해결  Windows에서 ERR_CERT_AUTHORITY_INVALID 해결문제 진단Flow Production Tracking 데스크톱이 실행 중입니까?예, 알고 있습니다. 이미 확인하셨을 것이라 생각했지만 다시 한번 확인했습니다. :)Flow Production Tracking 데스크톱을 시작한 후에 Chrome을 다시 시작했습니까?Flow Production Tracking 데스크톱이 인증서를 등록(Flow Production Tracking 데스크톱을 처음 실행할 때에만 등록하면 되고, 이후부터는 문제 없음)하기 전에 Chrome을 실행했다면 Chrome이 오래된 인증서 사본을 사용하면서 Flow Production Tracking 데스크톱 연결을 거부합니다. 모든 탭을 닫는다고 해서 Chrome까지 닫히는 것은 아니므로 주소 표시줄에 chrome://restart를 입력하고 Enter 키를 누르는 것이 좋습니다. 이렇게 하면 모든 Chrome 관련 프로세스가 종료되고, Chrome이 다시 시작됩니다.방화벽 소프트웨어를 사용 중입니까?방화벽 소프트웨어가 localhost 또는 포트 9000 접속을 차단 중이지 않은지 확인하십시오.Chrome이 인증서를 거부합니까?https://localhost:9000으로 이동하여 Chrome이 인증서를 수락하는지 확인할 수 있습니다. 이 주소는 Flow Production Tracking 웹 사이트가 로컬 파일 링크를 수행하고 툴킷 응용프로그램을 실행하기 위해 액세스하는 주소입니다. 보통 다음 메시지가 나타나야 합니다.이와 달리 다음 메시지 중 하나가 표시된다면 인증서 등록 프로세스에 문제가 발생했다는 의미입니다.인증서 문제를 빠르게 해결하는 방법이 문제를 방지하는 가장 쉬운 방법은 고급(ADVANCED), localhost로 진행(Proceed to localhost)(안전하지 않음)을 클릭하는 것입니다. 이렇게 하면 Chrome에서 여러분이 인증서를 수락하려고 한다는 것을 인식하고, Flow Production Tracking 웹 사이트가 Flow Production Tracking 데스크톱과 통신하도록 허용합니다.                    참고: 웹 브라우저와 Flow Production Tracking 데스크톱 간에 연결이 이루어지도록 할 수 있는 방법은 이것뿐입니다. 신뢰 설정은 두 응용프로그램 간 트래픽 흐름을 가능하도록 할 뿐, 인터넷 상의 다른 모든 서버에 대한 신뢰를 의미하는 것은 아닙니다. 아쉽게도 이 프로세스는 문제가 있는 모든 컴퓨터마다 반복해야 합니다. 이렇게 해도 문제가 해결되지 않거나 모든 사용자들에게 알려주기에는 너무 복잡한 방법이라고 생각되는 경우 다음 단계를 살펴보시기 바랍니다.                        참고: 이 단계 해결 방법은 ERR_SSL_SERVER_CERT_BAD_FORMAT 오류에는 적용되지 않으며, 아래 설명에 따라 인증서를 다시 생성해야 합니다.    모든 플랫폼에서 NET::ERR_CERT_COMMON_NAME_INVALID 및 ERR_SSL_SERVER_CERT_BAD_FORMAT 해결Chrome은 자체 서명 인증서에 관한 보안을 정기적으로 업그레이드하며, 이 업데이트로 인해 종종 브라우저 통합이 끊어집니다. 불행히도 이런 종류의 문제는 인증서의 certificate_path를 다시 생성하는 방법으로만 해결할 수 있습니다.인증서를 다시 생성하려면 Flow Production Tracking 데스크톱의 사용자 메뉴에 있는 고급(Advanced) 섹션에서 인증서 재생성(Regenerate Certificates) 옵션을 선택해야 합니다. (이 옵션이 보이지 않으면 tk-desktop 엔진을 업데이트하여 잠금 해제합니다.)인증서 재생성을 확인하고 나면 인증서를 처음 생성했을 때처럼 일련의 대화상자가 나타납니다. Windows 및 macOS에서는 Windows 인증서 저장소 또는 macOS 키체인을 업데이트하라는 메시지가 두 번 나타납니다. 한 번은 이전 인증서를 제거하라는 메시지가 나타나고, 새 인증서를 등록하라는 메시지가 한 번 더 나타납니다. Linux에서는 등록이 자동으로 이루어집니다. 등록이 끝나면 Flow Production Tracking 데스크톱을 다시 시작합니다.Flow Production Tracking 데스크톱이 다시 시작되어 실행되면 주소 표시줄에 chrome://restart를 입력해 Chrome을 다시 시작함으로써 Chrome이 완전히 종료되고 인증서 캐시가 지워지도록 하는 것이 좋습니다.컴퓨터가 인터넷에 연결되어 있지 않아 업데이트를 다운로드할 수 없는 경우 지원 사이트에서 도움을 요청하십시오.Windows에서 NET::ERR_CERT_AUTHORITY_INVALID 해결경우에 따라 Windows가 인증서를 성공적으로 가져왔다고 보고하는데 인증서가 필요한 응용프로그램에 이를 사용할 수 없을 때가 있습니다. 이는 Windows에서 인증서 대화상자로 이동하여 확인할 수 있습니다. 대화상자에 액세스하려면 Windows 키를 누르고 인터넷 옵션을 입력합니다. 인터넷 속성 대화상자에서 내용 탭으로 이동한 다음 인증서 버튼을 클릭합니다. 마지막으로 신뢰할 수 있는 루트 인증 기관을 클릭하고 localhost를 찾습니다.해당 항목이 없으면 Windows 도메인 또는 로컬 컴퓨터에 그룹 정책 문제가 있다는 의미일 수 있습니다. 이 문제가 있으면 지원 팀에 문의하는 것이 좋습니다.이 경우, 조직의 Windows 컴퓨터 관리자에게 연락하여 Windows로 하여금 자체 서명 인증서를 신뢰하지 않도록 지시하는 그룹 정책이 설정되어 있지 않은지 문의해 보십시오.그룹 정책 문제 조사컴퓨터가 도메인에 존재한다면 관리자는 이 StackExchange 게시글에 나와 있는 단계대로 수행하면 됩니다.컴퓨터가 도메인에 존재하는 것이 아니라면 컴퓨터가 관리자에 의해 여전히 잠겨 있을 가능성이 있습니다. 다음 단계를 수행하려면 Windows 관리자 계정이 필요합니다.Windows 키를 클릭하고 mmc를 입력한 다음 Enter 키를 누릅니다. 그러면 Microsoft 관리 콘솔이 실행됩니다. 이 응용프로그램에서 파일 메뉴를 클릭하고 스냅인 추가/제거를 선택합니다. 그러면 스냅인 추가/제거 대화상자가 나타납니다. 왼쪽에서 그룹 정책 개체 편집기를 찾아 추가 &amp;gt;를 클릭합니다. 새 대화상자가 나타나면 마침을 클릭해 무시하면 됩니다. 끝으로 스냅인 추가/제거 대화상자에서 확인을 클릭합니다.마지막으로 메인 대화상자 왼쪽에서 로컬 컴퓨터 정책/컴퓨터 구성/Windows 설정/보안 설정/공개 키 정책으로 이동합니다. 가운데 패널에서 인증서 경로 유효성 검사 설정을 선택한 다음 두 번 클릭합니다.다음 대화상자에서 이 정책 설정 정의가 선택 해제되어 있는지 확인합니다. 선택되어 있으면 사용자의 신뢰할 수 있는 루트 CA를 사용하여 인증서를 확인하도록 허용(권장)이 선택되어 있는지 확인합니다. 마치면 확인을 클릭하여 설정을 저장합니다.이때 모든 Chrome 창을 닫고 Chrome을 다시 시작해야 합니다. 위에서처럼 chrome://restart를 사용하여 다시 시작하는 것이 좋습니다. 이렇게 해야 변경 사항이 제대로 적용됩니다. 이제 인증서 목록을 찾으면 localhost 인증서가 보여야 합니다.이렇게 변경한 후에도 브라우저 통합을 사용할 때 문제가 계속 발생하거나 첫 번째 단계에서 설정이 올바르게 되어 있다면 지원 팀에 문의하시기 바랍니다.다른 OS에서 문제 해결다른 OS에서 Flow Production Tracking 데스크톱 통합과 관련한 문제가 발생하면 지원 팀에 연락해 도움을 받고, 이 게시글도 업데이트하도록 해 주십시오.",
    "url": "/95518180/",
    "relUrl": "/95518180/"
  },
  "18": {
    "id": "18",
    "title": "Firefox에서 로컬 파일 링크를 사용할 수 없으며, 툴킷 응용프로그램도 실행할 수 없습니다.",
    "content": "Firefox에서 로컬 파일 링크를 사용할 수 없으며, 툴킷 응용프로그램도 실행할 수 없습니다.개요간혹 Flow Production Tracking의 액션 메뉴에 사용 가능한 툴킷 응용프로그램 목록이 표시되지 않거나, Flow Production Tracking 데스크톱이 실행 중인데도 로컬 파일 링크를 사용하면 오류가 발생할 수 있습니다. 이 문서는 Firefox에서 Flow Production Tracking 데스크톱의 브라우저 통합 문제를 해결하고, 원하는 기능들이 제대로 작동하도록 하는 데 도움을 주기 위한 안내서입니다. Chrome의 경우 별도의 안내서가 있습니다.문제 진단Flow Production Tracking 데스크톱이 실행 중입니까?예, 알고 있습니다. 이미 확인하셨을 것이라 생각했지만 다시 한번 확인했습니다. :)방화벽 소프트웨어를 사용 중입니까?방화벽 소프트웨어가 localhost 또는 포트 9000 접속을 차단 중이지 않은지 확인하십시오.Firefox가 인증서를 거부합니까?https://localhost:9000으로 이동하여 Firefox가 인증서를 수락하는지 확인할 수 있습니다. 이 주소는 Flow Production Tracking 웹 사이트가 로컬 파일 링크를 수행하고 툴킷 응용프로그램을 실행하기 위해 액세스하려고 시도하는 주소입니다. 보통 다음 메시지가 나타나야 합니다.이와 달리 다음 두 메시지 중 하나가 표시된다면 인증서 등록 프로세스에 문제가 발생했다는 의미입니다.“연결이 안전하지 않음” 문제를 해결하는 방법인증서가 수락되도록 Firefox 브라우저에 예외를 추가해야 합니다. https://localhost:9000을 막 방문한 경우라면 예외를 추가하는 가장 쉬운 방법은 고급(Advanced)을 클릭하고 예외 추가(Add Exception) 버튼을 클릭하는 것입니다. 대화상자가 나타납니다.인증서 가져오기(Get Certificate)를 클릭한 다음 보안 예외 확인(Confirm Security Exception)을 클릭합니다. 인증서를 신뢰할 수 없다는 메시지는 무시해도 됩니다. 인증서가 인증 기관이 아닌 Flow Production Tracking 데스크톱에 의해 생성된 경우에 보통 발생하는 일입니다.이제 Flow Production Tracking 사이트에서 로컬 파일 링크에 액세스하고 툴킷 응용프로그램을 실행할 수 있습니다. 예외를 추가하고도 계속 문제가 발생하면 지원 사이트에서 도움을 요청하십시오.“보안 연결 실패” 문제를 해결하는 방법메뉴 열기(Open Menu) 버튼을 클릭하고 기본 설정(Preferences)을 선택해야 합니다. 그 다음 왼쪽에서 고급(Advanced)을 선택하고, 인증서(Certificates) 그리고 끝으로 인증서 보기(View Certificates)를 선택합니다.서버(Servers) 섹션에서 아무 항목이나 클릭하고 localhost를 입력하거나 그냥 이름이 localhost:9000인 항목이 나올 때까지 스크롤합니다. 이를 삭제합니다. 그런 다음, 기관(Authorities) 탭으로 이동해 localhost를 다시 입력합니다. 역시 그 아래 localhost 항목이 있는 Autodesk 섹션이 나올 때까지 스크롤해도 됩니다. localhost 항목을 제거하면 됩니다. 다 마치면 확인(OK)을 클릭해 Firefox를 다시 시작합니다. Firefox가 다시 시작되면 https://localhost:9000으로 이동합니다. 이제 다음 메시지가 나타나야 합니다.이때 위에 설명된 단계에 따라 예외를 추가해야 합니다.이 화면이 나와 있지 않으면 지원 사이트에서 도움을 요청하십시오.",
    "url": "/d4936105/",
    "relUrl": "/d4936105/"
  },
  "19": {
    "id": "19",
    "title": "로컬 {% include product %} 사이트에서 {% include product %} 데스크톱을 사용할 때 CERTIFICATE_VERIFY_FAILED 오류 발생",
    "content": "로컬 Flow Production Tracking 사이트에서 Flow Production Tracking 데스크톱을 사용할 때 CERTIFICATE_VERIFY_FAILED 오류 발생활용 사례:ShotGrid의 로컬 설치를 사용하는 경우 다음 두 가지 시나리오에서 이 오류가 발생할 수 있습니다.  Flow Production Tracking 데스크톱 로그인 시  툴킷 AppStore에서 미디어 다운로드 시해결 방법:이 문제를 해결하려면 사용자의 CA를 포함하여 유효한 모든 CA 목록이 포함된 파일을 Flow Production Tracking API에 제공해야 합니다. 일반적으로 Python의 certifi 패키지에서 이 파일의 새 사본을 다운로드한 후 파일 끝에 자체 CA를 추가하는 것이 좋습니다. 그런 다음 모든 사용자가 액세스할 수 있는 위치에 해당 파일을 저장합니다. 마지막으로 각 컴퓨터에서 SHOTGUN_API_CACERTS 환경 변수를 해당 파일에 대한 전체 경로(예: /path/to/my/ca/file.pem)로 설정합니다.이렇게 하면 로컬 사이트에서 발생하는 CERTIFICATE_VERIFY_FAILED 오류가 모두 해결됩니다. Flow Production Tracking 사이트에 연결할 수는 있지만 툴킷 AppStore에서 업데이트를 다운로드할 수 없는 경우에는 .pem 파일에 Amazon CA가 없기 때문에 발생한 문제일 수 있습니다. 이 문제는 일반적으로 위에서 링크한 것과 같은 파일로 시작하지 않고 빈 파일로 시작한 후 커스텀 CA만 추가한 경우에 발생합니다.이 정보는 로컬 설치에만 적용됩니다. 호스트된 사이트가 있고 이 오류가 발생한다면 Windows의 경우 이 포럼 게시물을 살펴보십시오. 다른 OS에서 이 문제가 발생하는 경우 이 문서를 살펴보십시오.이 오류가 발생하는 원인의 예:이 문제는 일반적으로 로컬 사이트에서 HTTPS를 사용하도록 구성했지만 로컬 사이트의 인증서에 서명하는 데 사용한 인증 기관(여기서는 CA라고 함)이 인식되도록 툴킷을 구성하지 않은 경우에 발생합니다.커뮤니티에서 전체 스레드를 참조하십시오.",
    "url": "/413b6be4/",
    "relUrl": "/413b6be4/"
  },
  "20": {
    "id": "20",
    "title": "Flow Production Tracking in the Cloud",
    "content": "Flow Production Tracking in the CloudWhat is Flow Production Tracking in the Cloud?Flow Production Tracking Cloud is our default offering, hosted on AWS and built on top of Autodesk’s Cloud technology platform. Flow Production Tracking Cloud is the latest generation of our hosted service and is completely cloud based.Further ReadingAdministration documentation can be found here.",
    "url": "/af35baf6/",
    "relUrl": "/af35baf6/"
  },
  "21": {
    "id": "21",
    "title": "커뮤니티 공유 통합",
    "content": "커뮤니티 공유 통합다음은 툴킷 커뮤니티에 있는 사람들이 공유할 정도로 유용한 프로젝트들입니다. 이 프로젝트들은 Flow Production Tracking에서 작성하지 않았고 보증할 수도 없지만 답변 가능한 질문에 대해서는 성심껏 답변해 드리겠습니다. 목록에 추가할 프로젝트가 있는 경우 지원 사이트에서 도움을 요청하십시오.엔진            통합      엔진      정보                        tk-katana      프로젝트 URL: https://github.com/robblau/tk-katana  프로젝트 기여: Lightchaser Animation  프로젝트 유지보수:   프로젝트 설명: Foundry Katana용 Flow Production Tracking 엔진입니다.                    tk-unreal      프로젝트 URL: https://docs.unrealengine.com/4.26/ko/ProductionPipelines/UsingUnrealEnginewithAutodeskShotgun/  프로젝트 기여: Epic Games  프로젝트 유지보수:  프로젝트 설명: Unreal Engine용 Flow Production Tracking 엔진입니다.                    tk-substancepainter      프로젝트 URL: https://github.com/diegogarciahuerta/tk-substancepainter  프로젝트 기여: Factor64  프로젝트 유지보수: Diego Garcia Huerta  프로젝트 설명: Adobe Substance Painter용 Flow Production Tracking 엔진입니다.                    tk-substancedesigner      프로젝트 URL: https://github.com/diegogarciahuerta/tk-substancedesigner    프로젝트 기여: Factor64    프로젝트 유지보수: Diego Garcia Huerta    프로젝트 설명: Adobe Substance Designer용 Flow Production Tracking 엔진입니다.    자세한 정보: Flow Production Tracking 커뮤니티 포럼                    tk-modo      프로젝트 URL: https://github.com/tremolo/tk-modo    프로젝트 기여: Lutz Pälike 및 Walking The Dog    프로젝트 유지보수:    프로젝트 설명: Foundry Modo용 Flow Production Tracking 엔진입니다.                    tk-clarisse      프로젝트 URL: https://github.com/diegogarciahuerta/tk-clarisse  프로젝트 기여: Factor64  프로젝트 유지보수: Diego Garcia Huerta  프로젝트 설명: Clarisse iFX용 Flow Production Tracking 엔진으로, 의상, 모양 개발, 조명 및 렌더링을 위한 완전한 대화식 CG 툴셋입니다.                    tk-natron      프로젝트 URL: https://github.com/diegogarciahuerta/tk-natron  프로젝트 기여: Factor64  프로젝트 유지보수: Diego Garcia Huerta  프로젝트 설명: Natron용 Flow Production Tracking 엔진으로, 오픈 소스 노드 기반의 무료 소프트웨어 응용프로그램입니다.                    tk-harmony      프로젝트 URL: https://github.com/diegogarciahuerta/tk-harmony  프로젝트 기여: Factor64  프로젝트 유지보수: Diego Garcia Huerta  프로젝트 설명: Toon Boom Harmony용 Flow Production Tracking 엔진으로, 업계 최고의 제작 애니메이션 소프트웨어입니다.                    tk-cinema      프로젝트 URL: https://github.com/mikedatsik/tk-cinema  프로젝트 기여: Mykhailo Datsyk  프로젝트 유지보수: Mykhailo Datsyk  프로젝트 설명: Maxon Cinema 4D용 Flow Production Tracking 엔진으로, 모델링, 애니메이션 및 렌더링을 위한 디자이너 친화적인 툴셋입니다.  자세한 정보: Flow Production Tracking 커뮤니티 포럼                    tk-krita      프로젝트 URL: https://github.com/diegogarciahuerta/tk-krita  프로젝트 기여: Factor64  프로젝트 유지보수: Diego Garcia Huerta  프로젝트 설명: Krita용 Flow Production Tracking 엔진으로, 주로 디지털 페인팅 및 2D 애니메이션용으로 설계된 무료 오픈 소스 래스터 그래픽 편집기입니다.  자세한 정보: Flow Production Tracking 커뮤니티 포럼                    tk-blender      프로젝트 URL: https://github.com/diegogarciahuerta/tk-blender  프로젝트 기여: Factor64  프로젝트 유지보수: Diego Garcia Huerta  프로젝트 설명: Blender용 Flow Production Tracking 엔진으로, 애니메이션 영화, 시각 효과, 아트, 3D 프린트 모델, 모션 그래픽, 대화식 3D 응용프로그램, 가상 현실 및 컴퓨터 게임 제작에 사용되는 무료 오픈 소스 3D 컴퓨터 그래픽 소프트웨어 툴셋입니다.  자세한 정보: Flow Production Tracking 커뮤니티 포럼      앱            통합      엔진      정보                        tk-maya-playblast      프로젝트 URL: https://github.com/basestudio/tk-maya-playblast    프로젝트 기여: BASE Studio    프로젝트 유지보수:    프로젝트 설명: Maya에서 playblast를 게시하기 위한 앱입니다. https://goo.gl/5oJTv0을 참조하십시오.                    tk-multi-renderfarm      프로젝트 URL: https://github.com/baitstudio/tk-multi-renderfarm    프로젝트 기여: Bait Studio    프로젝트 유지보수:    프로젝트 설명: 팜에 작업을 제출하기 위한 앱입니다. https://goo.gl/ew6mkD를 참조하십시오.                    tk-shotgun-publishrenders      프로젝트 URL: https://github.com/janimation/tk-shotgun-publishrenders    프로젝트 기여:    프로젝트 유지보수: Dave Sisk    프로젝트 설명: 이 앱은 프로젝트의 디렉토리 구조를 검색하여 기존에 게시된 파일 또는 파일 시퀀스를 찾은 다음, 게시된 파일 객체가 이미 존재하지 않는 경우 이를 Flow Production Tracking에 게시된 파일로 등록합니다.                    nuke-getShotgunData      프로젝트 URL: https://github.com/RicardoMusch/nuke-getShotgunData    프로젝트 기여: Ricardo Musch    프로젝트 유지보수: Ricardo Musch    프로젝트 설명: Flow Production Tracking 데이터를 nuke 텍스트 노드로 가져오는 것은 쉽지 않은 일일 수 있습니다. 이 노드는 슬레이트, 번인 또는 다른 곳에 정보를 제공하는 데 사용될 수 있습니다.                    sb-shotgun-schema-introspection      프로젝트 URL: https://github.com/scottb08/sb-shotgun-schema-introspection    프로젝트 기여: Scott Ballard    프로젝트 유지보수: Scott Ballard    프로젝트 설명: Flow Production Tracking 및 툴킷 개발자가 Flow Production Tracking 엔티티, 필드 및 기본 스키마를 신속하게 탐색하고 검사할 수 있는 간단한 툴킷 앱입니다.                    foto-multi-namingconvention      프로젝트 URL: https://github.com/scottb08/foto-multi-namingconvention    프로젝트 기여: Griffith Observatory    프로젝트 유지보수: Scott Ballard    프로젝트 설명: Flow Production Tracking 및 툴킷 개발자가 Flow Production Tracking 엔티티, 필드 및 기본 스키마를 신속하게 탐색하고 검사할 수 있는 간단한 툴킷 앱입니다.                    tk-cpenv      프로젝트 URL: https://github.com/cpenv/tk-cpenv    프로젝트 기여: Dan Bradham    프로젝트 유지보수: Dan Bradham    프로젝트 설명: 이 앱은 모듈을 사용하여 소프트웨어 플러그인, 프로젝트 종속성 및 환경 변수를 관리하는 도구인 cpenv에 대한 지원을 추가합니다.    자세한 정보: Flow Production Tracking 커뮤니티 포럼                    rtm-tk-hiero-shotgunDropper      프로젝트 URL: https://github.com/RicardoMusch/rtm-tk-hiero-shotgunDropper  프로젝트 기여: Ricardo Musch  프로젝트 유지보수: Ricardo Musch  프로젝트 설명: 이 앱을 사용하면 Flow Production Tracking의 버전 및 재생 목록을 드래그하여 Hiero로 드롭할 수 있습니다.  자세한 정보: Flow Production Tracking 커뮤니티 포럼      ",
    "url": "/58a557ee/",
    "relUrl": "/58a557ee/"
  },
  "22": {
    "id": "22",
    "title": "구성 스테이징 및 롤아웃",
    "content": "구성 스테이징 및 롤아웃이 문서에서는 프로덕션 파이프라인의 변경 사항을 안전하게 롤아웃하는 방법에 대한 모범 사례를 설명합니다. 여기에서는 스테이징 샌드박스(즉, 프로덕션 구성 사본)를 만들고, 이 샌드박스를 업데이트하여 테스트를 진행한 다음 마지막으로 변경 사항을 프로덕션 구성으로 푸시하는 방법을 설명합니다.이 문서에서는 툴킷 구성에 대한 제어 권한을 갖고 있는 경우에만 사용할 수 있는 기능에 대해 설명합니다. 기본 설정에 대한 자세한 내용은 Flow Production Tracking 통합 관리자 안내서를 참조하십시오.소개이 문서에서는 툴킷 구성을 관리하는 방법을 간략히 설명합니다. 툴킷에는 샌드박스가 적용된 안전한 환경에서 구성을 안전하게 관리하고 업그레이드 및 변경 사항을 전체 프로덕션으로 롤아웃하기 전에 테스트하도록 하는 몇 가지 유틸리티와 도구가 포함되어 있습니다.이 문서에서는 다음과 같은 방법을 설명합니다.  Toolkit Core API를 안전하게 업그레이드하는 방법  앱 및 엔진을 업그레이드하는 방법  다중 프로젝트에서 구성을 관리하는 다양한 방법  툴킷의 복제 및 밀기(푸시) 기능을 통해 프로덕션에 영향을 주지 않고 업그레이드 및 변경 사항을 안전하게 테스트하는 방법  git 소스 제어 및 툴킷으로 작업하는 방법구성 관리의 기본 사항각 툴킷 프로젝트에는 하나 이상의 구성이 관련되어 있습니다. 구성에는 프로젝트에 필요한 모든 설정(파일 시스템 위치(템플릿), 엔진 앱 등)이 있습니다. 툴킷에서 각 프로젝트를 독립적으로 구성할 수 있습니다. 즉, 서로 다른 프로젝트가 병렬적으로 실행될 수 있으며 하나의 프로젝트를 업그레이드해도 다른 프로젝트에 영향을 미치지 않습니다.많은 프로젝트에 대한 작업을 수행하는 경우 번거로울 수 있으며 이 프로세스를 쉽고 안전하며 원활하게 실행할 수 있게 해 주는 여러 가지 방법이 제공됩니다.ShotGrid의 각 프로젝트에는 많은 파이프라인 구성이 있습니다. 프로젝트가 툴킷으로 먼저 설정되면 primary라는 파이프라인 구성이 만들어집니다. Flow Production Tracking의 파이프라인 구성 엔티티는 툴킷 구성을 찾을 수 있는 디스크상의 위치를 가리킵니다.프로젝트 과정에서 종종 구성을 변경해야 합니다. 구성을 조정할 수도 있거나 앱 또는 엔진을 추가해야 할 수 있습니다. 또한 새 앱 버전이 자주 릴리즈되므로 가능하면 최신 버전을 사용하는 것이 좋습니다.기본 프로젝트 구성을 즉시 업그레이드할 수는 있지만 위험할 수 있습니다. 이 구성은 프로젝트의 모든 사람이 사용하므로 문제가 발생할 경우 모든 사람에게 영향을 미칩니다. 그러므로 해당 그룹의 작업자가 액세스할 수 있는 격리된 버전의 구성을 만드는 것이 좋습니다. 이렇게 설정된 안전한 환경에서는 업그레이드, 구성 변경 및 개발 시에 다른 프로덕션에 영향을 주지 않습니다. 변경 사항을 테스트한 후에 안전하고 확실하게 기본 구성으로 푸시할 수 있습니다.이 프로세스를 복제 라고 하며, 해당 사용자(및 해당 사용자가 초대한 다른 사용자)만 복제본에 액세스할 수 있도록 기본 구성의 개인 복사본을 만드는 것을 의미합니다. 이 환경에서 안전하게 변경할 수 있으며, 성공적으로 변경한 후 기본 구성으로 변경 사항을 다시 푸시할 수 있습니다.구성 복제툴킷을 설정하고 프로젝트를 구성하면 설치 프로그램이 다음과 같이 표시될 것입니다.스튜디오 설치에는 모든 프로젝트의 Core API가 포함되어 있습니다. 또한 이 스튜디오 위치에는 툴킷이 활성화된 Flow Production Tracking 프로젝트에 액세스하는 데 사용할 수 있는 tank 명령과 툴킷 Python API가 포함되어 있습니다.이 외에도 각 프로젝트에 대한 구성 폴더가 있습니다. 이 폴더에는 해당 프로젝트에 대한 모든 설정이 있습니다. 또한 이 구성에서 특별히 작동하는 tank 명령(및 Python API)도 포함되어 있습니다. 이 tank 명령 또는 API 코드를 사용하는 경우 이 구성에서만 작동합니다.새 프로젝트가 설정되면 기본 구성이 만들어집니다. 이 구성은 기본적으로 툴킷이 프로젝트에 대해 사용됩니다. 기본 구성 외에도 프로젝트에 대한 추가 구성을 만들 수 있습니다. 이러한 구성은 병렬로 존재할 수 있습니다. 예를 들어 일부 수정 사항을 개인적으로 테스트하거나 일부 앱을 업그레이드하거나 전체 팀에 영향을 주지 않고 개발을 수행하려는 경우에 유용합니다. 추가 구성은 복제, 즉 구성이 새 위치로 복사되는 프로세스에 의해 만들어집니다.구성을 복제하면 설정이 다음과 같이 표시될 수 있습니다.스튜디오 레벨 tank 명령과 기본 프로젝트 구성 tank 명령 외에도 새로운 파이프라인 구성에 자체 tank 명령이 있습니다. 이 tank 명령을 실행하면 스테이징 샌드박스에 있는 구성에서만 작동합니다. 따라서 Maya에서 새로운 일부 항목을 테스트하려면 간단히 복제 샌드박스로 이동하여 ./tank Shot xyz launch_maya를 실행합니다. 그러면 Maya에 표시되는 Flow Production Tracking 메뉴에 기본 구성이 아닌 스테이징 샌드박스 내부의 구성이 반영됩니다.스튜디오 레벨 tank 명령은 항상 기본 구성을 사용하므로 복제 구성에 액세스하려면 반드시 해당 위치로 이동하여 해당 폴더에 있는 tank 명령을 사용해야 합니다. Flow Production Tracking에서는 특정 사용자 집합을 파이프라인 구성 항목에 할당할 수 있으며, 이제 구성과 관련된 모든 사용자에게 기본 구성의 항목 외에 메뉴 항목이 표시됩니다.복제 구성 만들기업그레이드를 안전하게 테스트할 수 있는 스테이징 샌드박스를 만들려면 Flow Production Tracking에서 프로젝트의 파이프라인 구성을 탐색하고 마우스 오른쪽 버튼으로 기본 구성을 클릭합니다. 구성을 복제하는 옵션이 나타납니다.이 옵션을 클릭하면 새로운 구성이 위치할 디스크의 경로를 지정하는 대화상자가 나타납니다. 다중 OS 설정을 실행하는 경우 모든 관련 플랫폼의 경로를 입력해야 합니다.확인(OK)을 누르면 툴킷이 구성을 복사하고 복제본을 설정합니다. 또한 Flow Production Tracking 사용자와 이 구성이 연결되므로 복제를 만들자마자 Flow Production Tracking 내에 새로운 메뉴 항목이 표시됩니다.스테이징 샌드박스의 변경 사항을 기본 구성으로 푸시관련 업데이트를 적용하고 필요한 테스트를 실행한 다음 tank push_configuration 명령을 실행하여 변경 사항을 프로덕션 구성으로 다시 푸시할 수 있습니다. 이렇게 하면 스테이징 샌드박스의 모든 변경 사항이 기본 구성으로 전송됩니다.push_configuration 명령을 실행하면 현재 구성이 백업 위치로 이동됩니다. 실수로 푸시하거나 푸시에 문제가 있는 경우 백업 폴더의 컨텐츠를 가져와서 구성 폴더로 복사하는 방법으로 간단히 롤백할 수 있습니다.기본적으로 이 명령은 파일 모음을 대상 파이프라인 구성의 config 폴더에 복사합니다. Unix를 사용하고 있고 더 원자적인 업데이트를 원할 경우 push_configuration 명령에 --symlink 플래그를 추가할 수 있습니다. 이렇게 하면 대상 파이프라인 구성의 config 폴더가 기호 링크로 바뀌므로 현재 실행 중인 세션에서 구성 불일치의 위험 없이 쉽게 업그레이드할 수 있습니다.이전 복제 구성 새로 고침이전 dev  또는 스테이징 샌드박스 설정이 있고 컨텐츠를 최신 프로덕션 구성과 동기화해야 하는 경우에는 기본 구성에 대해 push_configuration 명령을 실행합니다.tank push_configurationWelcome to the Flow Production Tracking Toolkit!For documentation, see https://developer.shotgridsoftware.comStarting Toolkit for your current directory '/tmp'- Using configuration 'Primary' and Core v0.14.52- Setting the Context to Empty Context.- Running command push_configuration...----------------------------------------------------------------------Command: Push configuration----------------------------------------------------------------------This command will push the configuration in the current pipeline configuration('Primary') to another pipeline configuration in the project.Your existing configuration will be backed up.The following pipeline configurations are available to push to: - [324] Staging Sandbox (/my/staging/sandbox)Please type in the id of the configuration to push to (ENTER to exit): 324Hold on, pushing config...Checking if there are any apps that need downloading...Push Complete!Your old configuration has been backed up into the following folder:/my/staging/sandbox/config.bak.20140108_093218기본 프로젝트 구성에서 스테이징 샌드박스로 푸시하는 방법을 확인하십시오. 기본 구성의 tank 명령을 실행하여 이 작업을 수행합니다. 여러 샌드박스가 설정된 경우 해당 샌드박스 간에 데이터를 푸시할 수도 있습니다.복제한 구성 삭제복제 구성을 삭제하려면 Flow Production Tracking에서 해당 항목을 삭제하고 디스크에서 폴더를 제거하기만 하면 됩니다.최신 앱 및 엔진 가져오기스테이징 샌드박스(또는 기타 다른 구성)에서 tank updates 명령을 실행하여 사용 가능한 앱 업데이트가 있는지 확인할 수 있습니다. 이 명령에는 구성의 특정 영역만 확인하려는 경우 사용할 수 있는 기초적인 필터가 있습니다.----------------------------------------------------------------------Command: Updates----------------------------------------------------------------------This command will go through your current configuration and check if there areany updates available. If there are updates, you will be asked if you want toperform an upgrade. If settings has been added to the new version that you areinstalling, you may be prompted to specified values for these.Running this command with no parameters will check all environments, enginesand app. This may take a long time. You can also run the updater on a subsetof your installed apps and engines.General syntax:&amp;gt; tank updates [environment_name] [engine_name] [app_name]The special keyword ALL can be used to denote all items in a category.Examples:Check everything:&amp;gt; tank updatesCheck the Shot environment:&amp;gt; tank updates ShotCheck all maya apps in all environments:&amp;gt; tank updates ALL tk-mayaCheck all maya apps in the Shot environment:&amp;gt; tank updates Shot tk-mayaMake sure the loader app is up to date everywhere:&amp;gt; tank updates ALL ALL tk-multi-loaderMake sure the loader app is up to date in maya:&amp;gt; tank updates ALL tk-maya tk-multi-loaderToolkit Core API 업그레이드이 섹션에서는 복제 스테이징 샌드박스 구성을 사용하여 Toolkit Core API를 안전하게 업그레이드하는 방법에 대해 설명합니다. 스테이징 샌드박스가 아직 준비되지 않았다면 이전 섹션의 지침을 따르십시오.스테이징 샌드박스가 공유 스튜디오 Core API를 사용하는 파이프라인 구성에서 복제된 경우 고유한 Core API 코드를 사용하도록 샌드박스를 업데이트합니다. 이러한 작업을 일컬어 코어를 “현지화”한다고 하며 스테이징 샌드박스로 이동한 다음 tank localize를 실행하여 수행할 수 있습니다. 이 명령은 스튜디오 설치에서 Core API를 샌드박스에 복사하며 나중에 다른 버전의 Core API를 실행하고 테스트할 수 있습니다.툴킷의 기본 동작은 기본적으로 코어를 현지화하는 것입니다. 이전에 공유 스튜디오 코어를 명시적으로 만들지 않은 경우 코어가 이미 현지화되어 있다고 가정하는 것이 안전합니다.cd /my/staging/sandbox./tank localizeWelcome to the Flow Production Tracking Toolkit!For documentation, see https://developer.shotgridsoftware.comStarting Toolkit for your current directory '/my/staging/sandbox'- Using configuration 'Staging Sandbox' and Core v0.14.52- Setting the Context to Empty Context.- Running command localize...----------------------------------------------------------------------Command: Localize----------------------------------------------------------------------This will copy the Core API in /mnt/software/shotgun/studio into the Pipelineconfiguration /my/staging/sandbox.Do you want to proceed [yn]yLocalizing Core: /mnt/software/shotgun/studio/install/core -&amp;gt; /my/staging/sandbox/install/coreCopying Core Configuration Files...Localizing Apps: /mnt/software/shotgun/studio/install/apps -&amp;gt; /my/staging/sandbox/install/appsLocalizing Engines: /mnt/software/shotgun/studio/install/engines -&amp;gt; /my/staging/sandbox/install/enginesLocalizing Frameworks: /mnt/software/shotgun/studio/install/frameworks -&amp;gt; /my/staging/sandbox/install/frameworksThe Core API was successfully localized.Localize complete! This pipeline configuration now has an independent API.If you upgrade the API for this configuration (using the 'tank core' command),no other configurations or projects will be affected.이제 더 이상 Core API를 스튜디오 위치에서 공유하지 않고 자체 독립적인 버전을 실행합니다. 그런 다음 로컬 tank 명령을 다시 사용하여 표준 Core API 업그레이드를 수행할 수 있습니다.cd /my/staging/sandbox./tank core툴킷을 통해 사용 가능한 새 버전이 있는지 확인하여 다운로드하고 설치합니다.Core API를 업데이트했으면 설치를 테스트해야 합니다. 샌드박스의 tank 명령을 사용하거나 Flow Production Tracking의 특수 메뉴 항목을 사용하여 일부 앱을 실행합니다.  파이프라인에 대한 기본적인 연습을 수행하고 필요에 따라 테스트를 수행합니다.결과에 만족한 경우 Core API의 스튜디오 버전 업데이트를 진행할 수 있습니다. 일반적인 툴킷 설정에서는 모든 프로젝트 간에 Core API가 공유되므로 스튜디오 위치 tank 명령에서의 tank core 명령을 실행하여 모든 프로젝트의 Core API를 업데이트합니다.프로젝트 수명 주기 관리각 툴킷 프로젝트에는 해당 프로젝트의 모든 설정이 있는 독립적인 구성이 포함됩니다. 많은 프로젝트를 관리한다는 것은 많은 구성을 관리해야 한다는 의미입니다. 따라서 툴킷에는 개별 프로젝트와 스튜디오 수명 주기 및 구성 개선을 위해 구성을 다룰 수 있는 다양한 도구 및 방법이 포함되어 있습니다. 이 섹션에서는 몇몇 모범 사례를 간략히 설명하고 구성을 설정하는 실제 단계를 소개합니다.스튜디오의 요구 사항에 따라 복잡성이 다양할 수 있습니다. 툴킷은 세 가지 접근 방식을 제공하며 각각에 대해 자세히 설명하겠습니다.  가장 간단한 방법은 새 프로젝트를 설정할 때 이전 프로젝트의 구성을 복사하는 것입니다. 이 방법은 소규모 스튜디오나 프로젝트가 많지 않은 경우에 유용합니다.  프로젝트 회전율이 높고 두 개 이상의 프로젝트를 병렬로 실행하는 경우 다음 통합 레벨에 git 버전 제어를 포함하는 것이 좋습니다. 툴킷은 git에 대한 기본적인 지원을 제공합니다. git 기반 워크플로우를 통해 시작하고 실행한 후에는 스튜디오에 대한 단일 구성을 가지게 되며 시간 경과에 따라 해당 구성에 대한 모든 변경 사항을 트래킹할 수 있습니다. 각 프로젝트는 필요할 때마다 구성 변경 사항을 안전하게 가져올 수 있습니다.  대규모 프로덕션에서는 단일 구성을 설정하고 스튜디오에서 현재 진행되는 모든 프로젝트에 직접 연결하는 방식을 고려해 볼 수 있습니다. 이 경우 한 번의 구성 변경으로 모든 프로젝트에 즉각적인 영향을 미칠 수 있습니다.다음 섹션에서는 다양한 접근 방식을 자세히 설명합니다.이전 프로젝트에서 구성 상속구성 관리에 대한 가장 간단한 방법입니다. 툴킷을 사용하여 프로젝트를 처음 설정하면 기본 구성이 다운로드됩니다. 그런 다음 파이프라인 설정, 파일 시스템 위치 등에 맞게 첫 번째 프로젝트를 설정합니다. 프로젝트가 실행 중일 때 tank updates와 같은 명령 등을 실행하여 실행 중인 앱 버전을 업데이트합니다.두 번째 프로젝트를 시작할 때 기초 구성으로 다시 시작하지 않으려면 프로젝트 설정 단계에서 첫 번째 프로젝트의 구성을 새 프로젝트의 시작 지점으로 지정합니다. 즉, 첫 번째 프로젝트에서 수행한 모든 변경, 조정 및 개선 사항을 두 번째 프로젝트에서도 활용할 수 있습니다. 세 번째 프로젝트의 경우 두 번째 프로젝트의 구성을 사용합니다.이 간단한 방법으로 시간이 지남에 따라 구성을 점차 개선시킬 수 있습니다. 변경과 개선 사항은 프로젝트 간에 필요에 따라 전달됩니다. setup_project 명령을 처음 실행하려면 설정 프로세스에서 사용할 구성을 묻는 메시지가 나타날 때 Enter 키를 누릅니다. 이렇게 하면 기본 구성이 다운로드되어 설치됩니다.두 번째 프로젝트의 경우 이전 프로젝트 구성에 대한 경로 목록이 제공됩니다. 이러한 경로 중 하나를 선택하여 설정 프로세스에서 구성을 묻는 메시지가 표시될 때 입력합니다. 이렇게 하면 해당 구성이 새 프로젝트에 복사됩니다.Welcome to the Flow Production Tracking Toolkit!For documentation, see https://developer.shotgridsoftware.com- Running command setup_project...----------------------------------------------------------------------Command: Setup project----------------------------------------------------------------------Welcome to the Flow Production Tracking Toolkit Project Setup!Connecting to Flow Production Tracking...Connecting to the App Store...------------------------------------------------------------------Which configuration would you like to associate with this project?You can use the configuration from an existing project as a template for thisnew project. All settings, apps and folder configuration settings will becopied over to your new project. The following configurations were found:   My very first project: '/mnt/software/shotgun/first_project/config'If you want to use any of the configs listed about for your new project, justtype in its path when prompted below.You can use the Default Configuration for your new project.  The defaultconfiguration is a good sample config, demonstrating a typical basic setup ofthe Flow Production Tracking Toolkit using the latest apps and engines. This will beused by default if you just hit enter below.If you have a configuration stored somewhere on disk, you can enter the pathto this config and it will be used for the new project.You can also enter an url pointing to a git repository. Toolkit will thenclone this repository and base the config on its content.[tk-config-default]: /mnt/software/shotgun/first_project/configgit 소스 제어의 스튜디오 구성첫 번째 접근 방식에는 프로젝트가 서로 연결되지 않는다는 제한이 있습니다. 10개의 프로젝트가 있고 중요한 버그 수정이 릴리즈되어 업데이트해야 하는 경우 각 프로젝트를 수동으로 확인하고 tank updates 명령을 실행해야 합니다.이 문제를 해결하는 한 가지 방법은 마스터 구성을 만들고 git 소스 제어에 저장하는 것입니다. 새 프로젝트를 만들 때마다 프로젝트 설정 대화상자에 이 git 리포지토리의 경로를 입력하기만 하면 툴킷에서 복제됩니다. 이제 모든 프로젝트가 동일한 “스튜디오 마스터” 구성에 연결됩니다. 프로젝트 구성을 변경한 후에는 커밋하고 스튜디오 마스터에 푸시할 수 있습니다. 그러면 다른 프로젝트에서 이 변경 사항을 쉽게 가져올 수 있습니다. 또한 git를 통해 변경한 모든 내역은 기록으로 유지됩니다.git란?기본 개념은 git 구성을 저장하는 git 리포지토리를 설정하는 것입니다. tank setup_project를 실행할 때마다 이 리포지토리에 git URL을 지정하면(예: username@someserver.com:/studio_config.git) 새 프로젝트가 기본 스튜디오 리포지토리에 연결된 리포지토리가 되도록 설치 프로세스에서 리포지토리가 복제됩니다. 연결된 후에는 변경 사항을 푸시(push)하고 풀(pull)해서 분기에서 보다 세부적으로 작업할 수 있습니다.스튜디오 구성 리포지토리 설정다른 작업을 수행하기 전에 스튜디오 구성 리포지토리를 만들어야 합니다. 이 섹션에서는 기존 툴킷 구성을 가져와서 git 리포지토리를 만드는 방법을 보여 줍니다.먼저 git 서버로 가서 리포지토리를 만들어야 합니다. 이 프로세스는 설정에 따라 달라질 수 있습니다. GitHub 등을 사용하는 경우에는 웹 브라우저를 시작하고 github.com로 이동합니다. 서버에 액세스할 수 있으면 git init --bare 등을 수행할 수 있습니다. 위의 예에서 만든 git 리포지토리를 username@someserver.com:/studio_config.git라고 가정합니다.이제 리포지토리를 시드하는 데 사용하려는 프로젝트의 config 폴더를 config.bak 위치로 이동합니다.cd /project_configs/studio_configmv config config.bak초기화된 git 리포지토리를 스튜디오 구성을 기반으로 할 프로젝트의 config 위치에 복제합니다. clone 명령을 실행하면 git 리포지토리인 빈 config folder 폴더가 생성됩니다.cd /project_configs/studio_configgit clone username@someserver.com:/studio_config.git configconfig.bak 위치의 모든 파일을 config 폴더로 다시 복사합니다. 그러면 빈 config.bak 폴더를 삭제할 수 있습니다. 구성 파일은 이제 git 리포지토리 내에 있습니다. 이 파일을 추가하고 커밋한 다음 서버로 푸시해야 합니다. 하지만 먼저 일부 툴킷 시스템 파일을 올바르게 처리하도록 정리해야 합니다. config 폴더에서 .gitignore 파일을 만들어 다음 줄을 추가합니다.install_location.ymlpipeline_configuration.yml이제 git에서 두 시스템 파일을 무시합니다. 그런 다음 나머지 파일을 구성에 추가하고 커밋하여 스튜디오 리포지토리로 푸시할 수 있습니다.git add --allgit commit -am &quot;initial commit of our studio config!&quot;git pushgit에서 새 프로젝트 만들기새 프로젝트를 만들 때 설치 프로세스에서 사용할 구성의 경로를 입력하라는 메시지가 표시되면 유효한 git URL을 지정하기만 하면 됩니다. 위의 예시에 따라 username@someserver.com:/studio_config.git를 입력합니다. 프로젝트 설정 프로세스의 일부로 툴킷이 이 리포지토리를 새 프로젝트 구성의 config 폴더에 복제합니다. 이는 나중에 이 구성 폴더로 가서 git 명령을 실행할 수 있음을 의미합니다. 복제된 파이프라인 구성도 git 리포지토리를 복제하므로 완벽하게 작동합니다.프로젝트 변경기본 구성을 변경할 때마다 간단히 config 폴더로 가서 git diff, git commit 및 git push를 실행할 수 있습니다. 이렇게 하면 프로젝트 구성을 복제한 스튜디오 구성에 변경 사항이 푸시됩니다.프로젝트를 최신 버전으로 업데이트또한 일부를 변경하여 스튜디오 레벨 구성을 업데이트하여 프로젝트로 가져오려는 경우 config 폴더에서 git pull을 실행합니다.  중요: 이 작업을 완료한 후에는 tank cache_apps를 실행하여 변경된 구성에 필요한 모든 앱 버전이 시스템에 있는지 확인하십시오.고급 git 사용: 분기새 프로젝트가 만들어질 때 툴킷의 기본 동작은 간단한 복제 작업입니다. 프로젝트는 git master 분기를 사용합니다. 고급 설정으로, 예를 들어 프로젝트의 특정 구성 변경 사항을 비공개로 유지하고 다른 프로젝트와 공유하지 않으려는 경우 프로젝트를 만든 후에 git 분기를 설정할 수 있습니다. 그런 다음 이 분기에 커밋합니다. 스튜디오 구성으로 푸시하려는 변경 사항을 프로젝트의 로컬 마스터 분기와 병합한 다음 푸시할 수 있습니다.고급 git 사용: 배치(Batch) 배포툴킷은 파이프라인 구성 엔티티를 통해 Flow Production Tracking 사이트에 대한 다른 모든 구성의 목록을 유지하므로 이 목록을 반복하고 각 항목에 대해 git pull 명령을 실행하는 방법으로 모든 프로젝트에서 배치(Batch) 업데이트를 효과적으로 실행할 수 있습니다. 이 기능은 현재 툴킷의 기본 제공 기능에 포함되어 있지 않지만 Python 및 Flow Production Tracking Python API를 사용하여 스크립팅할 수 있습니다.include를 사용한 전역 구성위의 git 기반 접근 방식은 git를 통해 연결된 독립적인 프로젝트 구성을 처리합니다. 업데이트는 프로젝트 전체에 자동으로 반영되지 않으므로 강제로 풀/푸시해야 합니다.구성이 실제로 한 곳에 저장되고 단일 변경으로 프로젝트 그룹에 즉시 반영할 수 있는 완전한 중앙 집중식 구성의 경우 툴킷 구성의 @include 기능을 사용해야 합니다. 이렇게 하면 각 프로젝트 구성이 실제 구성이 저장된 중앙 위치를 가리키도록 참조를 만들 수 있습니다.@include 구문을 사용하면 여러 파일을 함께 연결할 수 있습니다. 예를 들어 다음 컨텐츠가 포함된 /tmp/stuff.yml 파일이 있는 경우 다음과 같습니다.# paths to mayamaya_windows: 'C: Program  Files Autodesk Maya2012 bin maya.exe'maya_mac: '/Applications/Autodesk/maya2012/Maya.app'maya_linux: 'maya'# a configured toolkit appfile_manager:  allow_task_creation: true  file_extensions: []  hook_copy_file: default  hook_filter_publishes: default  hook_filter_work_files: default  hook_scene_operation: default  launch_at_startup: false  launch_change_work_area_at_startup: false  location: {name: tk-multi-workfiles, type: app_store, version: v0.4.8}  saveas_default_name: scene  saveas_prefer_version_up: false  sg_entity_type_filters: {}  sg_entity_types: [Shot, Asset]  task_extra_display_fields: []  template_publish: null  template_publish_area: null  template_work: null  template_work_area: null위에서 볼 수 있듯이 서로 다른 여러 레벨에서 include 정의를 만들 수 있습니다. 위의 경우에는 앱 정의와 세 개의 문자열 값이 있습니다. 그런 다음 환경 파일에서 이를 참조할 수 있습니다.includes: ['/tmp/stuff.yml']engines:  tk-maya:    # First all our app definitions    apps:        # normally, we would have the entire set of configuration parameters at this point.        # because we are using an include, we can reference an entire sub-section of configuration        # using the @ keyword:        tk-multi-workfiles: '@file_manager'        # alternatively, for simple values, we can use them as parameter values for apps:        tk-maya-launcher:          mac_path: '@maya_mac'          linux_path: '@maya_linux'          windows_path: '@maya_windows'          location: {name: tk-multi-launchapp, type: app_store, version: v0.2.19}    # and after the apps section follows specific configuration options for the engine    location: {name: tk-maya, type: app_store, version: v0.4.1}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: Flow Production Tracking File Manager...}    template_project: null    use_sgtk_as_menu_name: false또한 여러 include 파일을 차례로 읽을 수 있습니다. 두 개의 다른 파일에 동일한 include 정의가 존재하면 가장 최근에 읽은 파일이 우선합니다. 위 예시 환경을 확장할 수 있습니다.includes:    # first include a global config file which contains all the studio level app definitions    - '/studio/configurations/studio_apps.yml'    # now we can include an include containing overrides, for example based on project type.    # if the global config contains an entry named file_manager and the vfx_apps.yml contains    # the same, the vfx_apps definition will be used.    - '/studio/configurations/vfx_apps.yml'engines:  tk-maya:        apps:        tk-multi-workfiles: '@file_manager'    location: {name: tk-maya, type: app_store, version: v0.4.1}    use_sgtk_as_menu_name: false방금 설명한 방법으로 프로젝트 유형 기본값에 의해 재정의될 수 있는 스튜디오 기본값을 설정할 수 있으며 이 기본값은 특정 프로젝트 설정에 의해 재정의될 수 있습니다. 위의 예와 같이 앱 레벨에서 수행하거나 다음 섹션에서와 같이 엔진 레벨에서 수행할 수 있습니다.전역 구성 설정 모범 사례전역 구성을 설정하는 몇 가지 방법이 있습니다. 이를 설정하기 위한 모범 사례 접근 방식으로서 구성을 엔진별로 세분화하는 것이 좋습니다. 각 환경 파일은 완전히 비어 있으며 별도의 파일에 정의된 엔진(및 앱)을 참조합니다. 따라서 한 번에 엔진 하나씩 쉽게 조정하고 재구성할 수 있습니다.이러한 각 include 파일은 표준 형식으로 되어 있으며 엔진 이름을 따서 명명됩니다. 예를 들어, Maya 엔진을 사용하는 경우 include 파일에는 엔진과 해당 앱만 포함됩니다. 최상위 항목의 이름은 간단히 maya로 지정됩니다.maya:    apps:      tk-maya-breakdown:        hook_multi_update: default        hook_scan_scene: default        location: {name: tk-maya-breakdown, type: app_store, version: v0.2.13}      tk-multi-loader2:        action_mappings:          Maya Scene: [reference, import]          Photoshop Image: [texture_node]          Rendered Image: [texture_node]        actions_hook: '{self}/tk-maya_actions.py'        entities:        - caption: Assets          entity_type: Asset          filters:          - [project, is, '{context.project}']          hierarchy: [sg_asset_type, code]        filter_publishes_hook: '{self}/filter_publishes.py'        location: {name: tk-multi-loader2, type: app_store, version: v1.0.6}        menu_name: Load        publish_filters: []        title_name: Loader      [... additional app entries here ...]    debug_logging: true    location: {name: tk-maya, type: app_store, version: v0.3.10}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: Flow Production Tracking File Manager...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}    - {app_instance: tk-multi-workfiles, name: Flow Production Tracking Save As...}    - {app_instance: tk-multi-publish, name: Publish...}    template_project: shot_work_area_maya    use_sgtk_as_menu_name: false# each include file has a framworks section containing all the frameworks needed for# all apps in the fileframeworks:  tk-framework-shotgunutils_v1.x.x:    location: {name: tk-framework-shotgunutils, type: app_store, version: v1.0.8}스튜디오에서는 대부분 단일 Maya 설정이 없지만 다양한 부서 및 유형에 따라 수많은 다른 Maya 설정이 있을 수 있습니다. 파일 계층 구조로 구성된 각각에 대해 Maya include 파일을 설정하는 것이 좋습니다. 이 파일에는 위의 파일과 같이 최상위 maya 항목이 있습니다.이제 각 프로젝트에 여러 환경이 포함됩니다. 이러한 각 환경 파일은 특정 환경을 엔진 및 앱 설정 컬렉션에 연결하는 엔진 include 목록입니다. 스튜디오(이와 같은 include를 포함하는 모든 파일)에 대해 하나 이상의 기본 프로젝트 구성을 설정할 수 있으며, 이를 통해 이 실제 앱 및 엔진 페이로드가 include 파일 내에 완전히 포함되어 전역적으로 됩니다. 전역 include 파일을 변경하면 모든 프로젝트가 영향을 받습니다. 이 설정을 사용하면 환경 파일의 형식이 다음과 같이 됩니다.includes:         - '/studio/configurations/maya/asset.yml'    - '/studio/configurations/nuke/asset.yml'    - '/studio/configurations/houdini/generic.yml'engines:  tk-maya: '@maya'  tk-nuke: '@nuke'  tk-houdini: '@houdini'# we don't need any frameworks here because there are no apps or engines definedframeworks: null위의 설정을 세분화하여 일부 프로젝트 관련 항목을 정의하기 시작하려면 @maya를 환경 파일 자체에 있는 일련의 앱 및 엔진 정의로 간단하게 대체합니다.전역 구성 관리전역 구성을 관리하는 것은 일반 구성을 관리하는 것보다 복잡합니다. 여러 프로젝트를 하나의 파일 구조로 결합했기 때문에 프로젝트에서 tank updates 명령을 실행하고 앱 버전을 업데이트하도록 선택하면 다른 모든 프로젝트에 영향을 주므로 주의하여 진행해야 합니다.또한 복제할 대상이 이제 include만 포함하는 프로젝트 구성이기 때문에 표준 복제 워크플로우는 기본적으로 작동하지 않습니다.안전한 테스트 및 유지 관리를 위해 소스 컨트롤(예: git)에 전역 구성을 저장하고 특별한 테스트 프로젝트로 별도의 테스트 영역에서 업데이트하는 것이 좋습니다. 품질 관리가 통과되면 변경 사항을 커밋하여 실제 전역 구성으로 가져옵니다.",
    "url": "/60762324/",
    "relUrl": "/60762324/"
  },
  "23": {
    "id": "23",
    "title": "구성이 디스크의 유효한 번들을 가리키지 않습니다!",
    "content": "구성이 디스크의 유효한 번들을 가리키지 않습니다!활용 사례Flow Production Tracking 데스크톱을 처음 설치할 때 프로젝트를 연 후 파일 경로 뒤에 이 오류가 표시될 수 있습니다.해결 방법프로젝트의 파이프라인 구성 엔티티는 Windows의 구성에 대한 ... Flow Production Tracking Configurations 경로를 가리킵니다. 이는 올바른 경로가 아닐 수 있으므로 첫 단계에서 경로가 존재하는지 확인하거나 경로를 수정하십시오.또는 해당 경로 위치에 대한 액세스 권한이 없는 중앙 집중식 설정에서 액세스하려고 하는 것일 수도 있습니다. 이 경우 분산 설정으로 전환하면 도움이 됩니다.관련 링크커뮤니티에서 전체 스레드 참조",
    "url": "/84bb455b/",
    "relUrl": "/84bb455b/"
  },
  "24": {
    "id": "24",
    "title": "Connecting Your Studio With Your AWS VPC",
    "content": "Connecting Your Studio With Your AWS VPCYou can connect your studio networks with AWS using one of many options, described in detail in this Amazon Virtual Private Cloud Connectivity Options whitepaper.Some of the common options our clients have used include:VPN ConnectionUsing a VPN appliance - AWS-managed or client-managed - your studio can establish a secure connection between your data center (or offices) to your AWS private VPC.AWS Direct ConnectAWS Direct Connect creates a dedicated link between your studio and your AWS VPC. This will help segregate your studio’s network traffic to your private AWS VPC from general internet traffic.",
    "url": "/de0ef1a3/",
    "relUrl": "/de0ef1a3/"
  },
  "25": {
    "id": "25",
    "title": "내 컨텍스트에 태스크/단계가 누락되어 있는데 파일 이름의 일부로 존재하는 이유는 무엇입니까?",
    "content": "내 컨텍스트에 태스크/단계가 누락되어 있는데 파일 이름의 일부로 존재하는 이유는 무엇입니까?툴킷을 통해 폴더를 생성하면 조회를 수행할 수 있도록 엔티티에 대해 경로를 등록합니다. 즉, 경로가 지정되고 올바른 컨텍스트를 결정할 수 있습니다.툴킷은 스키마에서 생성된 폴더에 대해서만 레지스트리를 생성하므로 templates.yml 파일에 단독으로 정의된 파일 이름이나 폴더 등은 고려하지 않습니다.스키마에 Task 폴더가 없는 경우에는 툴킷이 파일의 태스크를 알고 있어야 하지만 경로만으로는 태스크를 알 수가 없는 상황에 빠질 수 있습니다.예시아래의 기본 스키마 구조 사용 시 폴더 생성 프로세스 중에 Asset 및 Step 폴더가 등록됩니다.다음과 같은 템플릿을 사용하여 파일 경로를 생성하고assets/{sg_asset_type}/{Asset}/{Step}/work/maya/{task_name}_{name}.v{version}.{maya_extension}`경로를 생성한 컨텍스트를 찾으려고 시도하면 Asset 및 Step만 설정할 수 있으며 파일 경로에 태스크 이름이 있어도 Task는 설정할 수 없습니다.솔루션스키마에 Step 폴더는 있고 Task 폴더는 없는 것이 대부분의 워크플로우에서 좋습니다. 일반적으로는 Workfiles 앱을 사용하여 작업할 태스크를 선택한 후 파일을 선택하여 씬 파일을 엽니다. 그런 다음 열린 파일의 경로에서 찾지 않고 UI에서 선택한 태스크를 사용하여 컨텍스트를 유도합니다.그러나 다음과 같은 상황에서는 경로에서 컨텍스트를 가져오는 것이 중요할 수 있습니다.  자동 컨텍스트 전환 기능을 사용하는 경우, 이 기능은 툴킷이 사용자가 소프트웨어의 기본 열기 대화상자에서 파일을 여는지 탐지하고(Workfiles 앱을 사용하지 않고) 현재 컨텍스트를 적절하게 전환할 수 있도록 해줍니다.  지정된 파일에 대한 컨텍스트를 찾아야 하는 독립 실행형 프로세스에서 API를 사용하는 경우이러한 상황을 해결할 수 있는 솔루션은 스키마에 Task 폴더를 추가하거나 자동 컨텍스트 전환을 사용하지 않는 것입니다. 또는 API 스크립트 사용 시에는 프로세스에 이미 필요한 컨텍스트 정보가 있는지 확인하면 이 조회를 수행할 필요가 없습니다.",
    "url": "/a10dadb2/",
    "relUrl": "/a10dadb2/"
  },
  "26": {
    "id": "26",
    "title": "기여 가이드",
    "content": "기여 가이드가능한 모든 사항을 공개하려는 노력의 일환으로 Autodesk Shotgun 팀에서는 Creative Commons 라이센스에 따라 공용 리포지토리에 개발자 문서를 올리기로 했습니다. 이 문서를 더 효율적으로 작성할 수 있는 방법을 아신다면 개선 사항과 함께 리포지토리에 대한 pull 요청을 주십시오. pull 요청을 수락하기 위해서는 다음 기여자 계약서 중 하나에 서명하여 보내 주셔야 합니다.  개별 분담금 계약서  기업 분담금 계약서위의 계약서 중 하나를 제출한 후에는 변경 사항 제출 방법에 대한 읽어보기의 지침을 따르면 됩니다.",
    "url": "/92b042bd/",
    "relUrl": "/92b042bd/"
  },
  "27": {
    "id": "27",
    "title": "여러 개의 저장소 루트를 사용하도록 구성을 수정하려면 어떻게 해야 합니까?",
    "content": "여러 개의 저장소 루트를 사용하도록 구성을 수정하려면 어떻게 해야 합니까?기본 구성은 단일 로컬 저장소 루트를 사용하도록 설정됩니다(즉, 모든 프로젝트 파일이 /sgtk/projects 같은 단일 루트 지점에 저장됨). 그리고 일부 프로젝트 파일을 저장할 새 저장소 루트를 추가할 수 있습니다. 보통 디스크 공간이 부족하거나 일부 미디어를 더 빠른 저장소에 저장하고 싶을 때 이렇게 하게 됩니다.그럼 이제 이름이 “secondary”인 다른 루트를 추가해 보겠습니다. 수행해야 할 단계는 다음과 같습니다.ShotGrid의 로컬 저장소 추가  Flow Production Tracking에서 관리자(Admin) &amp;gt; 사이트 기본 설정(Site Preferences)** 페이지로 이동**  파일 관리(File Management) 섹션 열기  [+] 로컬 파일 저장소 추가([+] Add Local File Storage) 클릭  해당하는 모든 플랫폼에서 이름(“secondary”) 및 저장소 루트 경로 입력. 특정 플랫폼을 사용하고 있지 않다면 그냥 비워 두어도 됩니다.  페이지 위나 아래에 있는 페이지 저장(Save Page) 버튼 클릭파이프라인 구성에 새 루트 추가툴킷은 파이프라인 구성에서 사용되는 로컬 저장소에 관한 정보를 config/core/roots.yml 파일에 캐시합니다. Flow Production Tracking에서 지금 막 생성한 새로운 보조 저장소 루트를 추가하려면 이 파일을 편집합니다.primary: {    linux_path: /mnt/hgfs/sgtk/projects,    mac_path: /sgtk/projects,    windows_path: 'z: sgtk projects'}secondary: {    linux_path: /mnt/hgfs/sgtk/secondaries,    mac_path: /sgtk/secondaries,    windows_path: 'z: sgtk secondaries'}                    참고: tk-core v0.18.141부터 roots.yml에 정의된 루트 이름이 SG에 정의된 로컬 저장소 이름과 일치할 필요가 없습니다. roots.yml 정의에 shotgun_storage_id: &amp;lt;id&amp;gt; 키/값 쌍을 포함하여 연결을 명시적으로 정의할 수 있습니다.예시:secondary: {    linux_path: /mnt/hgfs/sgtk/secondaries,    mac_path: /sgtk/secondaries,    windows_path: 'z: sgtk secondaries'    shotgun_storage_id: 123}저장소 ID는 현재 API 호출을 통해서만 쿼리할 수 있습니다.    새 로컬 저장소 루트를 사용하도록 스키마 수정이제 새 저장소 루트를 정의하고 툴킷에 이를 알렸으므로 앞으로 디렉토리 구조에서 어떻게 사용할 것인지 결정해야 합니다. 이 예에서는 모든 에셋 작업이 secondary 저장소에 저장되고, 모든 샷 작업이 primary 저장소에 저장된다고 가정해 보겠습니다. config/core/schema에서 다음과 같이 스키마를 설정해야 할 것입니다.config/core/schema/project.yml# the type of dynamic contenttype: &quot;project&quot;# name of project root as defined in roots.ymlroot_name: &quot;primary&quot;config/core/schema/secondary.yml# the type of dynamic contenttype: &quot;project&quot;# name of project root as defined in roots.ymlroot_name: &quot;secondary&quot;해당 필터에서 이 루트를 참조하는 모든 YAML 파일도 수정해야 합니다.예를 들어, secondary 폴더 아래 어딘가에 asset.yml이 있다면 필터를 업데이트하여 secondary 폴더 값을 기준으로 해당 프로젝트를 필터링해야 합니다.filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$secondary&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }템플릿 경로를 업데이트하여 사용할 루트 지정끝으로 config/core/templates.yml 파일에 정의되어 있는 경로를 업데이트하여1 어느 저장소 루트를 사용할지 지정하고, 필요 시 모든 경로를 업데이트해야 합니다. 템플릿 경로는 스키마의 ‘절친’이기 때문에 둘은 일치되어야 한다는 점을 기억하십시오. 템플릿 경로가 스키마에 정의되어 있는 경로와 올바로 일치되지 않도록 정의되어 있으면 오류가 발생합니다.예를 들어, 여기에서는 모든 에셋 작업을 secondary 저장소에 저장하려고 하기 때문에 maya_asset_work 템플릿 경로를 업데이트하려면 이를 다음과 같이 수정해야 합니다.maya_asset_work:    definition: '@asset_root/work/maya/{name}.v{version}.ma'    root_name: 'secondary'config/core/templates.yml 파일의 각 템플릿 경로에 대해 이와 같은 패턴을 따라야 합니다. 각각에 대해 올바른 root_name을 지정합니다(‘primary’ 또는 ‘secondary’).                    참고: 기본 저장소 루트를 사용하는 템플릿에 대한 root_name을 지정할 필요가 없습니다. 기본 루트는 roots.yml 파일에서 default: true를 지정하여 표시됩니다. roots.yml에 기본값이 명시적으로 정의되지 않은 경우 primary라는 루트를 기본값으로 간주합니다.    1 새 값을 설정하고 나면 툴킷이 이전 값을 사용하여 생성된 모든 이전 파일에 액세스할 수 없게 되기 때문에 경로를 업데이트하는 것이 반드시 이상적이라고 할 수는 없습니다. 즉, 템플릿 경로를 변경하고 나면 툴킷이 이전 작업 파일을 찾을 수 없습니다. 이것이 우려된다면 새 위치를 지정하여 새 템플릿(예: houdini_shot_publish_v2)을 생성한 다음, 새 버전을 사용하도록 앱을 업그레이드하면 됩니다. 모든 앱이 이 같은 폴백 컨셉을 처리할 수 있는 것은 아니지만 일부 앱이라도 이전 파일을 인식할 수 있게 됩니다. 게시는 항상 Flow Production Tracking의 게시에 링크되어 있기 때문에 영향을 받지 않습니다.",
    "url": "/9ea9dd4e/",
    "relUrl": "/9ea9dd4e/"
  },
  "28": {
    "id": "28",
    "title": "중요! 폴더 데이터로 Flow Production Tracking를 업데이트할 수 없습니다.",
    "content": "TankError: 디스크에 폴더를 만들 수 없습니다. 오류 보고: 중요! 폴더 데이터로 Flow Production Tracking를 업데이트할 수 없습니다.활용 사례중앙 집중식 구성을 사용하고 있으며 기존 프로젝트에 대한 Linux 지원을 추가하고 있지만 파일 시스템 구성에 문제가 있습니다.다음 작업을 완료했습니다.  roots.yml에 해당 루트 추가  파이프라인 구성, install_location.yml 등에 linux 경로 추가  소프트웨어 엔티티에 대한 linux 경로 추가이제 Flow Production Tracking 데스크톱이 성공적으로 시작되지만 프로그램을 시작하려고 하면 다음 오류가 발생합니다.TankError: Could not create folders on disk. Error reported: Critical! Could not update Shotgun with folder data. Please contact support. Error details: API batch() request with index 0 failed.  All requests rolled back.API create() CRUD ERROR #6: Create failed for [Attachment]: Path /mnt/cache/btltest3 doesn't match any defined Local Storage.마찬가지로 tank 폴더 및 기타 명령을 실행하려고 하면 동일한 오류가 출력됩니다.필요한 모든 곳에 linux 경로를 추가한 것으로 생각됩니다. 데이터베이스 동기화와 관련이 있을까요?특히 tank synchronize_folders가 출력됩니다.  이 경로는 Flow Production Tracking 개체와 관련이 없습니다.해결 방법사이트 기본 설정(Site Preferences) &amp;gt; 파일 관리(File Management)에서 Linux 경로를 Flow Production Tracking의 로컬 저장소에 추가합니다.관련 링크커뮤니티에서 전체 스레드 참조",
    "url": "/904fdaf9/",
    "relUrl": "/904fdaf9/"
  },
  "29": {
    "id": "29",
    "title": "API를 통해 게시물을 작성하려면 어떻게 해야 합니까?",
    "content": "API를 통해 게시물을 작성하려면 어떻게 해야 합니까?sgtk API는 Flow Production Tracking에서 PublishedFiles 엔티티를 등록할 수 있는 편의 방식를 제공합니다.또한 자체 API와 함께 Publish 앱도 제공합니다.Publish API는 궁극적으로 Core sgtk API 방식을 사용하여 PublishedFile을 등록하지만 사용자 지정 가능한 컬렉션, 유효성 확인 및 게시 관련 프레임워크도 제공합니다. 이와 관련하여 Publish API 설명서와 함께 파이프라인 튜토리얼에 자체 게시 플러그인 작성 예제도 제공합니다.register_publish() API 방식 사용로우 Flow Production Tracking API 호출을 사용하여 Flow Production Tracking에서 게시 레코드를 생성하는 것도 가능하지만 툴킷의 편의 방식을 이용하는 것이 훨씬 좋습니다.게시를 생성하는 모든 툴킷 앱은 sgtk.util.register_publish()라는 API 유틸리티 방식을 사용 중입니다.기본적으로 이 방식은 Flow Production Tracking에서 새로운 PublishedFile 엔티티를 생성하며, 툴킷 컨셉을 사용하여 생성을 쉽게 만들어줍니다. 여러분의 코드로 무언가를 실행하려면 다음의 행을 이용해야 할 것입니다.# Get access to the Toolkit APIimport sgtk# this is the file we want to publish.file_to_publish = &quot;/mnt/projects/proj/seq_abc/shot_123/comp/foreground.v034.nk&quot;# alternatively, for file sequences, we can just use# a standard sequence token# file_to_publish = &quot;/mnt/projects/proj/seq_abc/shot_123/comp/renders/v034/foreground.%04d.exr&quot;# The name for the publish should be the filename# without any version number or extensionname = &quot;foreground&quot;# initialize an API object. If you have used the Toolkit folder creation# to create the folders where the published file resides, you can use this path# to construct the API object. Alternatively you can create it from any Flow Production Tracking# entity using the sgtk_from_entity() method.tk = sgtk.sgtk_from_path(file_to_publish)# use the file to extract the context. The context denotes the current work area in Toolkit# and will control which entity and task the publish will be linked up to. If you have used the Toolkit# folder creation to create the folders where the published file resides, you can use this path# to construct the context.ctx = tk.context_from_path(file_to_publish)# alternatively, if the file you are trying to publish is not in a location that is# recognized by toolkit, you could create a context directly from a Flow Production Tracking entity instead:ctx = tk.context_from_entity(&quot;Shot&quot;, 123)ctx = tk.context_from_entity(&quot;Task&quot;, 123)# Finally, run the publish command.# the third parameter (file.nk) is typically the file name, without a version number.# this makes grouping inside of Flow Production Tracking easy. The last parameter is the version number.sgtk.util.register_publish(  tk,  ctx,  file_to_publish,  name,  published_file_type=&quot;Nuke Script&quot;,  version_number=34)위에 나온 기본 항목 외에도 사용자가 직접 입력할 수 있는 여러 가지 옵션이 있습니다.전체 매개변수 목록 및 매개변수의 기능에 대한 자세한 내용은 Core API 설명서를 참조하십시오.                    팁: 코드가 툴킷 앱 내에서 실행 중인 경우 self.sgtk를 통해 sgtk 인스턴스를 가져오고 self.context를 사용하여 컨텍스트를 가져올 수 있습니다.앱 내는 아니지만 툴킷 통합이 있는 소프트웨어 내에서 실행될 경우 다음 코드를 사용하여 현재 컨텍스트 및 sgtk 인스턴스에 액세스할 수 있습니다.import sgtkcurrentEngine = sgtk.platform.current_engine()tk = currentEngine.sgtkctx = currentEngine.context    ",
    "url": "/ed4bcc20/",
    "relUrl": "/ed4bcc20/"
  },
  "30": {
    "id": "30",
    "title": "Linux에서 Flow Production Tracking 데스크톱의 데스크톱/시작 관리자 아이콘을 어떻게 설정합니까?",
    "content": "Linux에서 Flow Production Tracking 데스크톱의 데스크톱/시작 관리자 아이콘을 어떻게 설정합니까?현재 Flow Production Tracking 데스크톱 설치 관리자는 단축키를 자동으로 생성하지 않고 항목을 자동으로 실행하지도 않기 때문에 설치 후에 수동으로 해주어야 합니다. 아이콘을 추가하는 과정은 간단하지만, 어느 Linux 버전을 사용 중인지에 따라 달라질 수 있습니다.Flow Production Tracking 데스크톱 설치 관리자를 실행하고 나면 Flow Production Tracking 데스크톱 실행 파일이 /opt/Shotgun folder에 생성됩니다. 실행 파일 이름은 Flow Production Tracking입니다.설치 관리자와 함께 배포되는 아이콘은 없습니다. Flow Production Tracking 데스크톱 엔진 github 리포지토리에서 다운로드하십시오.아이콘을 다운로드하고, 실행 파일(/opt/Shotgun/Shotgun)로 경로를 지정하고 나면 수동으로 필요한 데스크톱 또는 메뉴 시작 관리자를 생성하십시오. 이 프로세스는 Linux 버전에 따라 달라질 수 있지만 보통 데스크톱을 마우스 오른쪽 버튼으로 클릭한 다음 적절한 메뉴 옵션을 찾아 데스크톱 시작 관리자를 생성할 수 있습니다.",
    "url": "/d82ab5ce/",
    "relUrl": "/d82ab5ce/"
  },
  "31": {
    "id": "31",
    "title": "프로젝트 간 워크플로우",
    "content": "프로젝트 간 워크플로우모범 사례ShotGrid의 프로젝트 간 워크플로우를 이용하면 여러 프로젝트에서 에셋을 재사용 및 공유하여 작업을 수행할 수 있습니다. 에셋을 재사용하는 가장 일반적인 방법은 단일 “에셋 라이브러리” 프로젝트를 소스 프로젝트로 사용하는 것입니다. 단순함을 유지하기 위해 단일 “라이브러리” 프로젝트를 사용하는 쪽이 권장되지만 Flow Production Tracking를 사용해 모든 활성 프로젝트 전반에서 에셋을 링크할 수도 있습니다.에셋을 재사용하는 두 가지 주요 방법이 있습니다. 보다 민첩한 접근 방식은 소스 에셋을 “있는 그대로” 재사용하는 것입니다(직접 참조). 하지만 프로젝트와 파이프라인에 따라 한계나 제한 사항이 있을 수 있으므로 소스 에셋을 프로젝트에 복사하는 것도 방법일 수 있습니다(복제 또는 포크(Fork)).  직접 참조 - 소스 에셋을 그대로 재사용합니다. 에셋이 변경되면 현재 버전을 유지하거나 최신 버전으로 업데이트할 수 있습니다.  복제 또는 포크 - 다른 프로젝트에서 소스 에셋을 가져와(소스에 대한 모든 연결을 끊음) 이를 토대로 구축하거나 현재 프로젝트에서 제어 및 저장합니다.프로젝트 간/라이브러리 프로젝트 워크플로우이 튜토리얼에서는 Flow Production Tracking 툴킷을 사용하여 여러 프로젝트 간에 에셋을 재사용하고 스튜디오에서 아티스트가 쉽게 액세스할 수 있는 에셋 라이브러리를 구성하는 방법을 안내합니다. 이 작업을 시작하고 실행하기 위한 세 가지 주요 단계를 살펴보겠습니다.  프로젝트 간에 링크된 Flow Production Tracking 에셋 - 링크된 프로젝트(Linked Projects) 필드를 사용하여 에셋과 프로젝트 간에 링크  씬에 에셋 로드/참조 - Loader의 동적 탭 사용  에셋을 최신 상태로 유지 - Scene Breakdown 앱 사용1단계 - 에셋 링크에셋을 재사용하는 첫 번째 단계는 Flow Production Tracking에서 소스 에셋을 사용하려는 다른 프로젝트를 인식하게 만드는 것입니다.재사용하려는 원래 에셋이 있는 소스 프로젝트에서 에셋(Assets) 페이지로 이동합니다.링크된 프로젝트(Linked Projects) 필드를 에셋(Assets) 페이지에 추가합니다(아직 표시되지 않는 경우). 그런 다음 에셋을 재사용할 프로젝트를 지정합니다.자세한 내용은 여기에 있는 상세 문서를 참조하십시오.2단계 - 에셋 로드링크된 프로젝트(Linked Projects) 필드를 통해 에셋이 제대로 링크되면 Loader에 간단하고 동적인 탭이 생겨 링크되고 재사용된 에셋을 표시합니다. 이를 통해 아티스트와 크리에이티브 팀은 여러 프로젝트에서 에셋을 간편하게 재사용할 수 있습니다.에셋이 제대로 링크되면 다음을 수행할 수 있습니다.  원하는 컨텐츠 제작 소프트웨어(Maya, Houdini, Alias 등) 실행  작업 씬을 열거나 저장해 컨텍스트 설정  씬 컨텍스트가 설정되면 Flow Production Tracking 메뉴에서 Loader를 시작  이제 에셋 - 링크됨(Assets - Linked)이라는 탭이 표시되며 이를 이용해 프로젝트 간의 에셋에 대한 게시된 파일에 액세스할 수 있습니다.구성의 Loader에 이 탭을 추가하려면 여기에서 상세한 지침을 참조하십시오.여기에서는 컨텐츠 제작 소프트웨어 Loader 작업을 활용해 가져오기 등의 작업을 수행할 수 있습니다. 에셋을 복제하거나 포크할 계획이라면 소스에 대한 모든 연결을 끊거나 이 에셋의 현재 버전과 후속 버전에 대한 지속적인 연결을 위해 에셋을 참조하십시오.3단계 - 에셋 업데이트소스에 대한 연결을 유지하면서 에셋을 참조하도록 선택하는 경우 해당 소스 에셋에 대한 업데이트 및 변경 사항을 확인해야 할 것입니다. 이 경우, 다른 팀이 소스 에셋에 대해 반복적으로 작업을 수행하는 것이 일반적이며 따라서 사용자에게는 최신 버전이 필요합니다.구성에서 Scene Breakdown 2 앱을 사용하면 씬에서 현재 참조된 모든 항목을 볼 수 있습니다. 이러한 참조가 업데이트되면 Scene Breakdown이 충돌을 표시하고 변경된 내용에 대한 게시된 파일(Published File) 노트를 공유하며 게시된 파일의 최신 버전 또는 다른 버전으로 업데이트할 수 있게 해줍니다.참고: 에셋 업데이트는 고급 구성을 사용하는 경우에만 적용됩니다. 스튜디오에서 기본 구성을 사용하는 경우 이 Scene Breakdown 앱에 액세스할 수 없습니다.",
    "url": "/0d2b28cd/",
    "relUrl": "/0d2b28cd/"
  },
  "32": {
    "id": "32",
    "title": "커스텀 브라우저 프로토콜을 사용하여 응용프로그램 실행",
    "content": "커스텀 브라우저 프로토콜을 사용하여 응용프로그램 실행컨텐츠  프로토콜 등록          Windows에서 프로토콜 등록      macOS에서 프로토콜 등록      Linux에서 프로토콜 등록      가장 실질적인 AMI(액션 메뉴 항목) 버전은 로컬 컴퓨터에서 응용프로그램 또는 스크립트를 실행하는 AMI입니다. 이 AMI가 작동하도록 하려면 실행하려는 스크립트나 응용프로그램과 브라우저 간 연결을 설정해 주어야 합니다. 이 링크를 커스텀 브라우저 프로토콜이라고 합니다.사용자가 클릭하면 [foo] 응용프로그램이 실행되는 링크 유형을 설정한다고 해보겠습니다. ‘http’를 접두사로 쓰는 대신 ‘foo’ 같은 커스텀 프로토콜을 지정해야 합니다. 다음과 같은 링크가 될 것입니다.foo://some/info/here운영 체제가 프로토콜 처리 방법을 알아야 합니다. 기본적으로 현재의 모든 운영 체제는 ‘http’는 기본 웹 브라우저가 처리해야 하고 ‘mailto’는 기본 메일 클라이언트가 처리해야 한다는 것을 알고 있습니다. 때로 응용프로그램이 설치되면 OS에 등록되고, OS에 특정 프로토콜에서 이 응용프로그램을 실행하도록 알립니다.예를 들어 RV를 설치하는 경우, 응용프로그램이 rvlink://를 OS에 등록하고, RV가 모든 rvlink:// 프로토콜 요청을 처리하여 이미지나 시퀀스를 RV에 표시할 것임을 알립니다. 따라서 사용자가 Flow Production Tracking에서 하는 것처럼 rvlink://로 시작하는 링크를 클릭하면 운영 체제가 이를 인식하여 해당 링크를 통해 RV를 실행하고, 응용프로그램이 링크를 구문 분석하여 어떻게 처리할지 결정합니다.URL 및 “rvlink” 프로토콜에 대한 자세한 정보는 RV가 프로토콜 처리기 역할을 하는 방법에 대한 자세한 내용이 담긴 RV 사용자 매뉴얼을 참조하십시오.프로토콜 등록Windows에서 프로토콜 등록Windows에서 프로토콜 처리기를 등록할 때에는 Windows 레지스트리를 수정하게 됩니다. 다음은 해당 레지스트리 키의 일반적인 예입니다.HKEY_CLASSES_ROOTfoo(Default) = &quot;URL:foo Protocol&quot;URL Protocol = &quot;&quot;shellopencommand (Default) = &quot;foo_path&quot; &quot;%1&quot;대상 URL은 다음과 같습니다.foo://host/path...                    참고: 자세한 내용은 http://msdn.microsoft.com/en-us/library/aa767914(VS.85).aspx를 참조하십시오.    Windows QT/QSetting 예시개발 중인 응용프로그램이 QT(또는 PyQT / PySide) 프레임워크로 작성되었다면 QSetting 객체를 활용하여 레지스트리 키 생성을 관리할 수 있습니다.다음은 자동으로 응용프로그램이 레지스트리 키를 설정하도록 하기 위한 코드입니다.// cmdLine points to the foo path.//Add foo to the Os protocols and set foobar to handle the protocolQSettings fooKey(&quot;HKEY_CLASSES_ROOT  foo&quot;, QSettings::NativeFormat);mxKey.setValue(&quot;.&quot;, &quot;URL:foo Protocol&quot;);mxKey.setValue(&quot;URL Protocol&quot;, &quot;&quot;);QSettings fooOpenKey(&quot;HKEY_CLASSES_ROOT  foo  shell  open  command&quot;, QSettings::NativeFormat);mxOpenKey.setValue(&quot;.&quot;, cmdLine);Flow Production Tracking AMI를 통해 Python 스크립트를 시작하는 Windows 예로컬로 실행되는 많은 AMI가 Python 인터프리터를 통해 간단한 Python 스크립트를 시작하려고 합니다. 덕분에 GUI(PyQT, PySide 또는 사용자가 선택하는 GUI 프레임워크)를 통해 간단한 스크립트나 앱까지 실행할 수 있는 것입니다. 이렇게 시작해 보는 데 도움이 될 만한 유용한 예를 살펴보겠습니다.1단계: 커스텀 “ShotGrid” 프로토콜 설정Windows 레지스트리 편집기 사용:[HKEY_CLASSES_ROOT Flow Production Tracking]@=&quot;URL:Flow Production Tracking Protocol&quot;&quot;URL Protocol&quot;=&quot;&quot;[HKEY_CLASSES_ROOT Flow Production Tracking shell][HKEY_CLASSES_ROOT Flow Production Tracking shell open][HKEY_CLASSES_ROOT Flow Production Tracking shell open command]@=&quot;python&quot;&quot;sgTriggerScript.py&quot;&quot;%1&quot;이 설정을 통해 스크립트의 첫 번째 인자 sgTriggerScript.py 및 두 번째 인자 %1을 통해 python 인터프리터를 실행하는 Flow Production Tracking:// 프로토콜을 등록합니다. %1은 브라우저에서 클릭한 URL 또는 호출된 AMI의 URL로 대체된다는 점에 유의하십시오. 이는 사용자의 Python 스크립트에서 첫 번째 인자가 됩니다.                    정보: Python 인터프리터 및 Python 스크립트의 전체 경로가 필요할 수 있습니다. 적절하게 조정하십시오.    2단계: Python 스크립트의 수신 URL 구문 분석스크립트에서 제공되는 첫 번째 인자인 URL을 가져와 이를 구성요소 단위로 구문 분석하여 AMI가 호출된 컨텍스트를 파악합니다. 다음 코드에서 이를 어떻게 수행하는지 보여 주는 간단한 스캐폴딩을 확인할 수 있습니다.Python 스크립트import sysimport pprinttry:    from urlparse import parse_qsexcept ImportError:    from urllib.parse import parse_qsdef main(args):    # Make sure we have only one arg, the URL    if len(args) != 1:        sys.exit(&quot;This script requires exactly one argument&quot;)    # Make sure the argument have a : symbol    if args[0].find(&quot;:&quot;) &amp;lt; 0:        sys.exit(&quot;The argument is a url and requires the symbol ':'&quot;)    # Parse the URL    protocol, fullPath = args[0].split(&quot;:&quot;, 1)    # If there is a querystring, parse it    if fullPath.find(&quot;?&quot;) &amp;gt;= 0:        path, fullArgs = fullPath.split(&quot;?&quot;, 1)        action = path.strip(&quot;/&quot;)        params = parse_qs(fullArgs)    else:        action = fullPath.strip(&quot;/&quot;)        params = &quot;&quot;    # This is where you can do something productive based on the params and the    # action value in the URL. For now we'll just print out the contents of the    # parsed URL.    fh = open('output.txt', 'w')    fh.write(pprint.pformat((protocol, action, params)))    fh.close()if __name__ == '__main__':    sys.exit(main(sys.argv[1:])) 참고: 이 스크립트는 Python 3 및 Python 2와 호환됩니다.3단계: Flow Production Tracking 인터페이스를 커스텀 프로토콜, 그리고 궁극적으로는 스크립트와 연결끝으로 Flow Production Tracking에 AMI를 생성합니다. 해당 URL 값은 shotgrid://processVersion이 됩니다. 이 AMI를 원하는 어떠한 엔티티 유형에든 할당할 수 있지만 다음 예에서는 버전 엔티티를 사용합니다.버전 페이지로 이동하여 버전을 마우스 오른쪽 버튼으로 클릭하고 메뉴에서 AMI를 선택합니다. 이렇게 하면 브라우저가 shotgrid:// URL을 열고, 이 URL이 다시 등록된 커스텀 프로토콜을 통해 사용자의 스크립트로 리디렉션됩니다.이제 스크립트와 같은 디렉토리에 있는 output.txt 파일에서 다음과 같은 항목을 볼 수 있습니다.('processVersion', {'cols': ['code',           'image',           'entity',           'sg_status_list',           'user',           'description',           'created_at'],  'column_display_names': ['Version Name',                           'Thumbnail',                           'Link',                           'Status',                           'Artist',                           'Description',                           'Date Created'],  'entity_type': ['Version'],  'ids': ['6933,6934,6935'],  'page_id': ['4606'],  'project_id': ['86'],  'project_name': ['Test'],  'referrer_path': ['/detail/HumanUser/24'],  'selected_ids': ['6934'],  'server_hostname': ['my-site.shotgrid.autodesk.com'],  'session_uuid': ['9676a296-7e16-11e7-8758-0242ac110004'],  'sort_column': ['created_at'],  'sort_direction': ['asc'],  'user_id': ['24'],  'user_login': ['shotgrid_admin'],  'view': ['Default']})가능한 변형AMI에서 URL의 // 부분 뒤에 오는 키워드를 변경함으로써 스크립트 내 action 변수의 내용을 변경할 수 있습니다. 이때 같은 shotgrid:// 프로토콜이 유지되고, 커스텀 프로토콜 하나만 등록됩니다. 그러면 action 변수의 내용과 매개변수의 내용을 통해 의도된 동작이 무엇인지 스크립트가 파악할 수 있습니다.이 방법을 사용하여 응용프로그램을 열고, FTP 같은 서비스를 통해 컨텐츠를 업로드하고, 데이터를 보관하고, 이메일을 보내거나, PDF 보고서를 생성할 수 있습니다.macOS에서 프로토콜 등록macOS BigSur 및 Monterey에서 프로토콜을 등록하려면 응용프로그램 또는 스크립트를 실행하도록 구성된 .app 번들을 생성해야 합니다.1단계: AppleScript 스크립트 편집기먼저 AppleScript 스크립트 편집기에서 다음 스크립트를 작성하는 것부터 시작하십시오.on open location this_URL    do shell script &quot;sgTriggerScript.py '&quot; &amp;amp; this_URL &amp;amp; &quot;'&quot;end open location 디버깅 팁: 오류를 포착하고 팝업에 표시하면 자동으로 오류를 발생시키지 않고 Python 스크립트를 실행하는 데 문제가 있는지 확인할 수 있습니다. 다음은 오류 시도를 위해 AppleScript에 추가할 수 있는 예제 조각입니다.on open location this_URL	try		do shell script &quot;/path/to/script.py '&quot; &amp;amp; this_URL &amp;amp; &quot;'&quot;	on error errStr		display dialog &quot;error&quot; &amp;amp; errStr	end tryend open location   참고: tcsh 등의 특정 셸에서 Python을 실행하도록 하려면 do shell script를 다음과 같이 변경하면 됩니다. tcsh -c  &quot;sgTriggerScript.py '&quot; &amp;amp; this_URL &amp;amp; &quot;' &quot; 스크립트 편집기에서 간단한 스크립트를 _응용프로그램 번들_로 저장합니다.2단계: info.plist 파일 편집저장된 응용프로그램 번들을 찾아 컨텐츠를 엽니다.그런 다음 info.plist 파일을 열고, 다음을 plist dict에 추가합니다.&amp;lt;key&amp;gt;CFBundleIdentifier&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;com.mycompany.AppleScript.ShotGrid&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;CFBundleURLTypes&amp;lt;/key&amp;gt;&amp;lt;array&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;CFBundleURLName&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;ShotGrid&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;CFBundleURLSchemes&amp;lt;/key&amp;gt;&amp;lt;array&amp;gt;&amp;lt;string&amp;gt;ShotGrid&amp;lt;/string&amp;gt;&amp;lt;/array&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/array&amp;gt;다음 세 가지 문자열을 변경할 수도 있습니다(선택 사항).com.mycompany.AppleScript.ShotGridShotGridShotGrid세 번째 문자열은 프로토콜 처리기이므로 URL은 다음과 같습니다.shotgrid://somethingBigSur를 사용하는 경우 info.plist 파일에서 NSAppleEventsUsageDescription과 NSSystemAdministrationUsageDescription 사이에 있는 다음 줄을 _삭제_해야 합니다. BigSur 이전 버전을 사용 중인 경우 이 단계를 건너뛰고 아래의 3단계를 계속합니다.	&amp;lt;key&amp;gt;NSAppleMusicUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your music to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSCalendarsUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your calendars to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSCameraUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your camera to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSContactsUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your contacts to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSHomeKitUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your HomeKit Home to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSMicrophoneUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your microphone to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSPhotoLibraryUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your photos to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSRemindersUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your reminders to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSSiriUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to Siri to run.&amp;lt;/string&amp;gt; 3단계: .app 번들을 Applications 폴더로 이동끝으로, .app 번들을 Mac의 Applications 폴더로 옮깁니다. 그런 다음 번들을 두 번 클릭하여 프로토콜을 운영 체제에 등록합니다.데이터 흐름은 이렇습니다. Flow Production Tracking에서 AMI를 클릭하거나 shotgrid://으로 시작하는 URL을 클릭하면 .app 번들이 응답하여 이 URL을 Python 스크립트로 전달합니다. 이때 Windows 예에서 사용한 것과 같은 스크립트를 사용할 수 있으며, 동일한 가능성이 모두 적용됩니다.                    정보: Monterey 문제 해결에 대한 자세한 정보를 보려면 이 커뮤니티 게시물을 방문하십시오.    Linux에서 프로토콜 등록다음 코드를 사용합니다.gconftool-2 -t string -s /desktop/gnome/url-handlers/foo/command 'foo &quot;%s&quot;'gconftool-2 -s /desktop/gnome/url-handlers/foo/needs_terminal false -t boolgconftool-2 -s /desktop/gnome/url-handlers/foo/enabled true -t bool그리고 다음 위치에서 로컬 GConf 파일의 설정을 전역 기본값으로 사용합니다./etc/gconf/gconf.xml.defaults/%gconf-tree.xmlGnome 설정만 변경해도 KDE에도 적용됩니다. Firefox 및 GNU IceCat은 인식할 수 없는 접두사(foo:// 등)를 만나면 사용자가 실행 중인 창 관리자에 상관없이 gnome-open을 따릅니다. 때문에 KDE의 Konqueror 같은 다른 브라우저는 이 시나리오에서 작동하지 않습니다.Ubuntu에서 액션 메뉴 항목의 프로토콜 처리기를 설정하는 방법에 대한 자세한 정보는 https://askubuntu.com/questions/527166/how-to-set-subl-protocol-handler-with-unity를 참조하십시오.",
    "url": "/af0c94ce/",
    "relUrl": "/af0c94ce/"
  },
  "33": {
    "id": "33",
    "title": "sgtk.env.project.tk-nuke.tk-multi-workfiles2에서 파일 열기(File Open) 대화상자를 만들지 못했습니다!",
    "content": "data_handler_cache 오류 메시지: 오류 sgtk.env.project.tk-nuke.tk-multi-workfiles2 파일 열기(File Open) 대화상자를 만들지 못했습니다!활용 사례:Nuke와 같은 앱을 시작하면 tk-multi-workfiles2 파일 열기(File Open) 대화상자가 실패하고 data_handler_cache의 get_children 메서드에 대한 스택 트래킹 마지막에 오류가 발생합니다. dict가 필요한데 문자열 값이 전달되어 반복하지 못하는 상태가 발생합니다.전체 스택은 다음과 같습니다.2020-12-07 09:42:03,571 [7192 ERROR sgtk.env.project.tk-nuke.tk-multi-workfiles2] Failed to create File Open dialog!Traceback (most recent call last):  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles work_files.py&quot;, line 115, in _show_file_dlg    self._dialog_launcher(dlg_name, app, form)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install core python tank platform engine.py&quot;, line 1822, in show_dialog    dialog, widget = self._create_dialog_with_widget(title, bundle, widget_class, *args, **kwargs)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install core python tank platform engine.py&quot;, line 1684, in _create_dialog_with_widget    widget = self._create_widget(widget_class, *args, **kwargs)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install core python tank platform engine.py&quot;, line 1658, in _create_widget    widget = derived_widget_class(*args, **kwargs)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles file_open_form.py&quot;, line 46, in __init__    FileFormBase.__init__(self, parent)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles file_form_base.py&quot;, line 64, in __init__    self._my_tasks_model = self._build_my_tasks_model()  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles file_form_base.py&quot;, line 134, in _build_my_tasks_model    bg_task_manager=self._bg_task_manager)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles my_tasks my_tasks_model.py&quot;, line 57, in __init__    bg_task_manager=bg_task_manager  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles entity_models extended_model.py&quot;, line 74, in __init__    **kwargs  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-framework-shotgunutils v5.5.0 python shotgun_model shotgun_entity_model.py&quot;, line 70, in __init__    self._load_data(entity_type, filters, hierarchy, fields)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-framework-shotgunutils v5.5.0 python shotgun_model shotgun_model.py&quot;, line 367, in _load_data    self._create_item  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install core python tank log.py&quot;, line 503, in wrapper    response = func(*args, **kwargs)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-framework-shotgunutils v5.5.0 python shotgun_model data_handler.py&quot;, line 266, in generate_child_nodes    for data_item in self._cache.get_children(unique_id):  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-framework-shotgunutils v5.5.0 python shotgun_model data_handler_cache.py&quot;, line 129, in get_children    for item in cache_node[self.CACHE_CHILDREN].itervalues():AttributeError: 'str' object has no attribute 'itervalues'오류의 원인은 무엇입니까?캐싱에 문제가 있습니다. 캐시를 제거하면 수정할 수 있습니다(다음 섹션 참조).해결 방법이 지침에 따라 캐시를 찾아 제거합니다. 전체를 제거하면 다음에 데스크톱을 다시 시작할 때 모든 항목을 다운로드해야 하므로 지연이 발생할 수 있습니다. 따라서 루트 캐시 폴더 내에 있는 Flow Production Tracking 사이트의 이름을 따서 명명된 폴더를 지우는 것이 좋습니다. 그러면 그리 긴 지연이 발생하지 않습니다.커뮤니티에서 전체 스레드를 참조하십시오.",
    "url": "/aaac055f/",
    "relUrl": "/aaac055f/"
  },
  "34": {
    "id": "34",
    "title": "개발자 개요",
    "content": "개발자 개요Python APIFlow Production Tracking 소프트웨어는 Flow Production Tracking에 액세스하고 다른 도구와 통합하는 데 사용할 수 있는 Python 기반 API를 제공합니다. 이 API는 Flow Production Tracking 서버에서 생성, 읽기, 업데이트 및 삭제 액션의 실행을 허용하는 CRUD 패턴을 따릅니다. 각 요청은 단일 엔티티 유형에 작용하며, 특정 액션에 따라 필터, 반환할 열, 정렬 정보, 그 밖에 추가 옵션을 정의할 수 있습니다.  코드 리포지토리  설명서  포럼이벤트 트리거 프레임워크Flow Production Tracking 이벤트 스트림에 액세스하려면 이벤트 테이블을 모니터링하고 새로운 이벤트를 파악하여 처리하는 작업을 반복하는 것이 좋습니다.많은 항목이 성공적으로 작동하려면 이 프로세스를 거쳐야 하며, 비즈니스 규칙과 직접적인 관련이 없는 항목은 적용해야 하는지 여부를 결정해야 합니다.프레임워크의 역할은 비즈니스 로직 구현자를 대신해 따분한 모니터링 작업을 처리해 주는 것입니다.이 프레임워크는 서버에서 실행되면서 Flow Production Tracking 이벤트 스트림을 모니터링하는 데몬 프로세스입니다. 이벤트가 발견되면 데몬은 이벤트를 일련의 등록된 플러그인으로 전달합니다. 각각의 플러그인은 원하는 대로 이벤트를 처리할 수 있습니다.  코드 리포지토리  설명서액션 메뉴 항목 프레임워크API 개발자는 엔티티별로 상황에 맞는 메뉴 항목을 커스터마이즈할 수 있습니다. 예를 들어, 버전 페이지에서 여러 버전을 선택하고 마우스 오른쪽 버튼을 클릭한 후 PDF 보고서 작성 등을 선택할 수 있습니다. 이를 액션 메뉴 항목(AMI)이라고 합니다.  설명서  예제 코드 리포지토리",
    "url": "/1e047003/",
    "relUrl": "/1e047003/"
  },
  "35": {
    "id": "35",
    "title": "개발",
    "content": "개발툴킷을 사용한 개발을 기반으로 한 빠른 답변 모음입니다.  소프트웨어를 실행하기 전에 환경 변수는 어떻게 설정합니까?  커스텀 스크립트에서 인증 및 로그인 자격 증명 관련 작업은 어떻게 진행합니까?  내 컨텍스트에 존재하는 값이 as_template_fields()에서 누락되었습니다.  Maya에서 툴킷 앱 실행을 위한 쉘프 버튼을 추가하려면 어떻게 해야 합니까?  어떻게 하면 shotgunEvents 데몬을 사용하여 다른 Toolkit Core 모듈을 로드할 수 있습니까?  API를 사용하여 툴킷 구성을 프로그래밍 방식으로 업데이트하려면 어떻게 해야 합니까?  API를 통해 게시물을 작성하려면 어떻게 해야 합니까?",
    "url": "/16654f1f/",
    "relUrl": "/16654f1f/"
  },
  "36": {
    "id": "36",
    "title": "개발",
    "content": "개발툴킷은 무엇일까요?툴킷은 파이프라인 통합의 토대가 되는 플랫폼입니다.예를 들어 Maya에서 Flow Production Tracking Panel 앱을 사용하거나 Flow Production Tracking Create에서 Publish 앱을 실행하는 경우 툴킷 플랫폼을 기반으로 하는 도구를 사용하게 됩니다.툴킷을 사용하여 개발하려면 어떻게 해야 합니까?툴킷을 사용하여 개발하는 방법에는 여러 가지가 있습니다.  후크라고 하는 커스텀 코드를 작성하여 기존 앱, 엔진 또는 프레임워크 동작을 확장할 수 있습니다.  자체 앱, 엔진 또는 프레임워크를 작성할 수 있습니다.  또는 API를 사용하는 독립 실행형 스크립트를 작성할 수 있습니다.이러한 작업을 수행하려면 툴킷 API를 사용하는 방법을 이해하는 것이 중요합니다.ShotGrid에는 전체적으로 세 가지 주요 API가 있습니다.  Flow Production Tracking Python API  Flow Production Tracking REST API  Flow Production Tracking 툴킷 API툴킷 API는 Flow Production Tracking Python API 또는 REST API와 함께 사용하도록 설계된 Python API이며 대체용 API가 아닙니다.툴킷 API에 몇 가지 래퍼 방식이 있지만 일반적으로 Flow Production Tracking 사이트에서 데이터에 액세스해야 할 때는 Flow Production Tracking Python API 또는 REST API를 사용합니다.대신 툴킷 API는 파일 경로의 통합 및 관리에 중점을 둡니다.일부 툴킷 앱 및 프레임워크에는 자체 API도 있습니다.이 문서에서는 툴킷을 사용하여 개발하는 방법에 대해 설명합니다.",
    "url": "/a1cfe87c/",
    "relUrl": "/a1cfe87c/"
  },
  "37": {
    "id": "37",
    "title": "Direct Connect",
    "content": "Direct ConnectAWS Direct Connect is a service from AWS that allows you to establish a dedicated connection from your on-premise data center (or offices) to AWS. Direct Connect will allow you to create a dedicated link between your network and one of the AWS Direct Connect locations.Leveraging AWS Direct Connect ensure that you will benefit from the best experience possible when using the isolation feature set, optimizing reliability and performance for all your access points across the globe.",
    "url": "/0de47d40/",
    "relUrl": "/0de47d40/"
  },
  "38": {
    "id": "38",
    "title": "Flow Production Tracking AWS Direct Connect Onboarding",
    "content": "Flow Production Tracking AWS Direct Connect OnboardingIntroductionAWS Direct Connect (DX) is used to establish private connectivity between AWS and an on-prem facility. DX provides a private, high bandwidth network connection between your network and AWS Virtual Private Cloud (VPC) and bypasses the public internet. AWS has established 100 Direct Connect locations globally and leverages the AWS Partner Network to extend the footprint.Review of Shogun Configuration in AWSCustomer Types  Customer already has AWS Direct Connect dedicated connection  Customer has equipment and network presence in an AWS Direct Connect location  Customer does not have equipment or presence in an AWS Direct Connect locationSetup Options  Request a dedicated Direct Connect connection through AWS Console          Provision the required connectivity yourself      Work with Direct Connect Partner to help establish a dedicated connection to AWS equipment        Request a hosted Direct Connect connection through AWS Direct Connect PartnerCriteria to Determine Setup PathIf you answer “yes” to the following, then request a dedicated Direct Connect connection through the AWS Console (Option 1a):  Do you already have equipment and presence in an AWS Direct Connect location?  Do you know the process for requesting a cross-connect within the Direct Connect location facility?  Are you looking for any one of the following - 1Gbps, 10Gbps port, or a dedicated connection?If you answer “yes” to the following, then request a dedicated Direct Connect connection through the AWS Console and select a Partner to assist (Option 1b):  Are you planning to use AWS Direct Connect to connect to other AWS resources outside of Flow Production Tracking?  Do you have the time and resources to complete the setup?  Are you looking for any one of the following - 1Gbps, 10Gbps port, or a dedicated connection?If you answer “yes” to the following, then you should work with an AWS Direct Connect Partner to request a hosted Direct Connect connection (Option 2):  Are you already working with an AWS Direct Connect Partner?  Do you want a Partner to facilitate the setup?  Are you looking for a port less than 1Gbps or a hosted connection?Disclaimer:  All options are valid and the criteria are just a guide to help simplify the selection process. You can still pick any option based on more specific criteria.Setup DirectionsRequest through AWS Console - Option 1 (a and b)  Create a Connection in the AWS Console  Download the LOA-CFA. The LOA is the authorization to connect to AWS and is required to establish the cross-network connection.  (Option 1a only) Request cross-connects at AWS Direct Connect locations. Find contact information here.  (Option 1b only) Reach out to an AWS Partner and share the LOA with them.  Once the dedicated connection is provisioned into your account, set up logical connectivity (Virtual Interfaces).Request through AWS Direct Connect Partner - Option 2  Reach out to an AWS Partner. The criteria for choosing an AWS Partner are:          AWS Region      Providers      If you are already working with an AWS Direct Connect Partner        If hosted connection, accept a hosted connection. More information can be found here.  Once the hosted connection is provisioned into your account, set up logical connectivity (Virtual Interfaces).FAQHow long should it take to set up AWS Direct Connect?Short Answer - It depends. A lot of factors go into the time it takes to set up AWS Direct Connect. The timeline can vary from a few days to a few months. Some of the factors include current infrastructure, location of equipment, providers, partners, and more. If you are looking to expedite the process, consider using an AWS Direct Connect Partner who is geographically nearby.Further questions about AWS Direct Connect?AWS Direct Connect FAQsVPNA site-to-site VPN can be used as an alternative to AWS Direct Connect. Learn more about AWS VPN here.AWS Documentation &amp;amp; Resources  What is AWS Direct Connect?  Direct Connect User Guide  re:Invent 2018 - 400 level Deep Dive on Direct Connect  AWS Direct Connect Locations  AWS Direct Connect Partners",
    "url": "/8233001e/",
    "relUrl": "/8233001e/"
  },
  "39": {
    "id": "39",
    "title": "Flow Production Tracking 데스크톱의 브라우저 통합을 어떻게 비활성화할 수 있습니까?",
    "content": "Flow Production Tracking 데스크톱의 브라우저 통합을 어떻게 비활성화할 수 있습니까?브라우저 통합을 비활성화하려면 다음의 간단한 두 단계를 수행하십시오.      다음 위치에서 텍스트 파일을 생성하거나 엽니다.     Windows: %APPDATA% Flow Production Tracking preferences toolkit.ini Macosx: ~/Library/Preferences/ShotGrid/toolkit.ini Linux: ~/.ShotGrid/preferences/toolkit.ini            다음 섹션을 추가합니다.     [BrowserIntegration] enabled=0      브라우저 통합 구성 방법에 대한 자세한 내용은 관리자 안내서를 참조하십시오.대체 방법툴킷 파이프라인 구성을 인계받은 경우 대체 방법은 환경에서 tk-Flow Production Tracking 엔진을 제거하여 어떤 액션도 로드할 수 없도록 하는 것입니다.",
    "url": "/1bb3f6ad/",
    "relUrl": "/1bb3f6ad/"
  },
  "40": {
    "id": "40",
    "title": "파일 시스템 구성",
    "content": "동적 파일 시스템 구성이 안내서에서는 툴킷 파이프라인 구성을 수정하여 프로덕션 폴더 구조와 파일 명명 규칙을 커스터마이즈하는 방법을 설명합니다.안내서 정보파이프라인 관리의 가장 어려운 점 중 하나는 생성되는 다양한 파일을 추적하는 것입니다. 툴킷 파이프라인은 Flow Production Tracking의 데이터 및 구성된 폴더 구조를 기반으로 폴더를 만들고 올바른 위치에 표준화된 명명 규칙을 사용하여 자동으로 파일을 작성하는 방식으로 파일 시스템 관리를 자동화해 주므로 아티스트는 컨텐츠 생성에 집중할 수 있습니다. 파이프라인 구성은 기본 폴더 세트 및 파일 명명 규칙과 함께 제공되지만 프로덕션에서는 이를 커스터마이즈하는 경우가 많습니다. 이 안내서에서는 이러한 커스터마이즈에 필요한 지식을 제공합니다.기본 구성에서 에셋은 asset_type/asset/pipeline_step과 같은 폴더 구조로 관리됩니다. 이 안내서에서는 “Set”라는 커스텀 엔티티를 사용하여 각 에셋이 사용되는 프로덕션 세트별로 에셋을 추가 구성합니다. 먼저 Flow Production Tracking에서 커스텀 엔티티를 설정한 다음 이를 사용하여 지정된 세트에 생성된 에셋을 관리합니다. 폴더 구조는 set/asset_type/asset/pipeline_step과 같은 형태입니다.일부 씬은 차고에서 진행되고 나머지 씬은 다이닝룸에서 진행하는 프로젝트를 수행한다고 가정하고 세트별로 에셋을 구성하는 방식을 설명하겠습니다. 설정을 사용하면, “wrench”, “oilcan” 또는 “workbench”와 같은 에셋에 대한 파일은 “garage” 폴더에 구성되고 “plate”, “winebottle” 또는 “tablecloth”와 같은 에셋에 대한 파일은 “dining_room” 폴더에 구성됩니다. 예제에서 군침 도는 “filet” 에셋은 적절하게 다이닝룸에 배치됩니다.예제에서는 프로젝트에 대한 파일 명명 템플릿도 편집하여 에셋에 대한 Maya 작업 파일에 해당 이름의 세트가 포함되도록 합니다. 동적으로 생성된 파일 이름은 다이닝룸에 대한 파일과 다른 세트에서 사용된 파일로 구분됩니다.이 안내서는 다음과 같이 세 부분으로 구성됩니다.  Flow Production Tracking에서 “Set”라는 커스텀 엔티티 만들기. 아티스트가 만드는 다이닝룸 요소와 연결하는 데 사용됩니다.  스키마 폴더 편집. 툴킷이 폴더 구조에서 현재 세트를 기반으로 동적으로 이름이 지정된 폴더를 포함할 수 있게 합니다.  에셋 작업 파일 이름 지정에 사용되는 템플릿 편집. 툴킷이 파일 이름에 연관된 세트 이름을 포함할 수 있게 합니다.필수 요건이 안내서를 사용하려면 다음이 필요합니다.  활성 Flow Production Tracking 사이트 하나 이상의 에셋이 생성된 프로젝트가 있어야 합니다. 에셋에는 모델 태스크가 있어야 합니다.  Flow Production Tracking 사이트를 에셋 관리에 사용하는 방법에 대한 기본적인 이해  Flow Production Tracking 데스크톱이 시스템에 설치되어 있어야 합니다.  식별된 프로젝트에 대한 복제된 파이프라인 구성이나 구성 시작하기 안내서를 완료하고 해당 연습에서 생성한 구성 복제  YAML에 대한 기본 지식  파이프라인 구성이 저장된 파일 시스템에 대해 읽기 및 쓰기 권한을 적절하게 설정합니다.  툴킷이 프로덕션 파일 시스템에 읽고 쓸 수 있도록 읽기 및 쓰기 권한을 적절하게 설정합니다.  활성 상태의 Maya 서브스크립션. Maya의 30일 체험판을 구할 수 있습니다.이 안내서는 tk-config-default2 파이프라인 구성을 기반으로 합니다. 이 구성을 수정한 경우 YAML 설정의 파일, 폴더 및 블록의 위치가 여기에 설명된 것과 다를 수 있습니다.파일 스키마 및 템플릿 정보툴킷 파이프라인 구성에서 스키마 및 템플릿을 사용하면 Flow Production Tracking 데이터를 활용하여 디스크의 프로덕션 파일을 관리할 수 있습니다. 기본 구성의 스키마에는 샷, 시퀀스, 에셋, 에셋 유형 등의 엔티티가 포함됩니다. 레벨, 에피소드, 시즌과 같은 다른 엔티티나 앞에서 설명한 세트(Set)같은 커스텀 엔티티를 추가할 수 있습니다.툴킷 플랫폼을 통해 스키마를 사용하여 동적으로 폴더 구조를 빌드할 수 있습니다. 스키마는 실제 프로덕션 파일 시스템을 빌드할 때 템플릿으로 사용되는 프로덕션 폴더 구조의 미니어쳐 버전입니다. 스키마는 동적 폴더 생성을 위한 명시적 지침으로, YAML 파일을 사용하여 동적으로 생성된 폴더의 규칙을 정의합니다. 기본 구성에는 에셋 및 샷 파이프라인에 대한 폴더 생성을 지원하는 사전 구성된 스키마가 포함됩니다. 에셋 폴더 구조(/assets/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt;) 생성을 지원하는 스키마 부분을 수정하여 새로 생성하는 Set 엔티티도 지원할 수 있습니다.템플릿을 사용하면 Flow Production Tracking 데이터 및 스키마 구조의 정보를 사용하여 만든 파일을 동적으로 이름을 지정하고 저장할 수 있습니다. 기본 구성은 파이프라인의 요구에 맞게 편집할 수 있는 일련의 초보자용 템플릿을 제공합니다.Flow Production Tracking 통합의 기본 설정에는 파일 시스템 관리가 포함되지 않습니다. 프로젝트에 대한 파일 시스템 관리를 구성하려면 프로젝트에 고급 설정이 필요합니다. 첫 번째 안내서인 구성 시작하기에서 고급 설정 프로세스에 대해 설명합니다.연습 시작스키마 및 템플릿을 커스터마이즈하면 상차림, 뜨거운 필레미뇽, Penfolds Grange Hermitage 1951 와인, 감자 그라탱, 레몬 갈릭 아스파라거스 등 다이닝룸 세트를 만들 때 생성된 파일을 동적으로 관리할 수 있습니다. 다이닝룸 세트에 사용된 에셋은 보다 쉽게 관리할 수 있도록 “Dining Room” Set 엔티티와 연결됩니다. Set는 기본 구성과 함께 제공되는 표준 엔티티 유형이 아니므로 커스텀 엔티티를 활성화한 후 스키마 및 템플릿을 확장하기 전에 Set로 호출해야 사용할 수 있습니다.커스텀 엔티티 활성화하기1단계: 브라우저에서 Flow Production Tracking 사이트를 엽니다. 아바타를 클릭하고 관리자(ADMIN) &amp;gt; 사이트 기본 설정(Site Preferences)으로 이동합니다. 결과 페이지에서 엔티티(Entities) 섹션을 확장합니다.ShotGrid에서 사용할 수 있는 엔티티 유형 목록이 표시됩니다. 아래 이미지에서 목록 상단에는 현재 Flow Production Tracking 사이트에 구성된 일부 엔티티 유형이 있습니다. 이러한 엔티티 유형 아래에는 구성되지 않았거나 활성화되지 않은 몇 가지 커스텀 엔티티가 있습니다.커스텀 엔티티 유형 중 하나를 선택하고 구성하고 활성화합니다.2단계: 화살표를 선택하여 회색으로 비활성화된 커스텀 엔티티에 대한 설정을 엽니다. 예, 커스텀 엔티티 사용…(Yes, use Custom Entity…) 옆의 라디오 버튼을 선택하고 표시 이름(Display name)을 Set로 변경한 다음 창의 맨 위로 스크롤하여 변경 사항 저장(Save Changes)을 선택합니다.이렇게 하면 Flow Production Tracking에서 해당 커스텀 엔티티가 활성화되고 표시 이름이 Set로 표시됩니다. 기본적으로 엔티티의 시스템 이름은 CustomEntity01로 유지되므로 커스텀 엔티티에 대한 별칭을 작성합니다. 이 예제에서는 CustomEntity01을 사용하지만 다른 커스텀 엔티티를 사용할 수 있습니다.선택한 커스텀 엔티티의 시스템 이름을 기억하십시오.데이터 필드를 추가하여 에셋을 세트와 연결에셋 엔티티에 데이터 필드를 추가하면 에셋을 새 엔티티에 링크할 수 있습니다. 아티스트가 다이닝룸에 대해 만드는 에셋은 Dining Room Set 엔티티와 연결됩니다.3단계: 페이지 맨 위에 있는 프로젝트(Projects) 드롭다운을 선택하고 이 연습에서 사용할 프로젝트를 엽니다.4단계: 프로젝트 메뉴 막대에서 에셋(Assets)을 선택하여 에셋(Assets) 페이지로 이동합니다. 에셋(Assets) 메뉴에서 필드(Fields) &amp;gt; 에셋 필드 관리…(Manage Asset Fields…)를 선택합니다.그러면 에셋 필드 관리자가 표시됩니다.새 필드 추가(+ Add a new field)를 선택합니다.새 필드에 대한 매개변수를 선택합니다.새 필드 이름(New Field Name)에 “Set”를 입력합니다. 일반(GENERAL) 메뉴 아래 필드 유형(Field Type)에서 엔티티(Entity)를 선택하고 유형 제한(Restrict the type)을·스크롤하여 Set를 선택합니다. 다음(Next)을 선택합니다.이 안내서에서는 이를 현재 프로젝트만(Only the current project)으로 적용하고 필드 만들기(Create Field)를 선택합니다.ShotGrid가 새 필드를 구성합니다.변경 사항이 적용되면 완료(Done)를 선택할 수 있습니다.Dining Room Set 엔티티 만들기5단계: 에셋의 새 Set 필드를 선택하고 Dining Room을 입력합니다. 일치하는 항목을 찾을 수 없습니다. “Dining Room” 만들기라고 적힌 대화상자가 표시됩니다.“Dining Room” 만들기(Create “Dining Room”)를 선택합니다.Set 만들기(Create Set)를 선택합니다.에셋의 Set 필드에 Dining Room을 추가하면 Dining Room Set 엔티티와 연결이 만들어집니다.6단계: 테스트용으로 쉽게 찾을 수 있도록 필레 에셋에 대한 모델 태스크를 자신에게 할당합니다.스키마 설정이제 Set 커스텀 엔티티가 활성화되고 “Dining Room”이라는 Set 엔티티가 만들어지고 에셋 엔티티가 Dining Room Set에 링크되었습니다. Flow Production Tracking 사이트에서 모든 부분이 준비되었으며 이제 폴더 구조를 수정할 수 있습니다. 아티스트가 태스크에 대한 작업을 시작하면 툴킷은 연결된 Flow Production Tracking 데이터를 사용하여 파일 시스템에 만들 폴더를 결정합니다. 새 폴더가 생성되고 파이프라인 구성 스키마를 기반으로 이름이 자동으로 지정됩니다.이제 아티스트가 프로덕션 파이프라인을 단계별로 수행할 때 툴킷에서 동적으로 생성할 폴더 구조를 정의할 수 있습니다. 이 작업은 스키마를 편집하여 수행합니다.활성 프로덕션 구성에 영향을 주지 않도록 복제된 구성에서 구성을 테스트하는 것이 좋습니다. 복제 프로세스는 구성의 복사본을 만들어 변경 사항을 라이브 구성에 적용하기 전에 안전하게 편집할 수 있습니다. 구성 복제에 대한 자세한 내용은 구성 스테이징 및 롤아웃 문서에서 찾을 수 있습니다.”7단계: 파이프라인 구성으로 이동합니다. 스키마 폴더(&amp;lt;pipeline_configuration_root&amp;gt;/config/core/schema)로 찾아 들어가고 project 폴더를 엽니다.현재 스키마는 다음과 같으며&amp;lt;project&amp;gt;/assets/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt;다음 폴더 구조를 동적으로 만들 수 있습니다.the_other_side/assets/prop/filet/model여기서는 다음과 같은 구조가 필요합니다.the_other_side/assets/Dining-Room/Prop/filet/model이렇게 하려면 다음과 같은 스키마를 설정합니다.&amp;lt;project&amp;gt;/assets/&amp;lt;CustomEntity01&amp;gt;/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt;Set 엔티티는 CustomEntity01로 표시됩니다. Flow Production Tracking에서 Set의 표시 이름으로 CustomEntity01을 제공했지만 구성에서 항상 시스템 이름으로 CustomEntity01을 참조합니다.스키마가 YAML 파일을 사용하는 방법스키마는 정적 및 동적 폴더를 포함할 수 있습니다. “assets”라는 스키마에 정적 폴더가 있는 경우 “assets”라는 프로덕션 파일 시스템의 단일 폴더에 해당합니다. 반면 프로젝트의 각 에셋에 대한 하나의 폴더를 나타내는 “asset”이라는 스키마의 동적 폴더가 있을 수 있습니다. 모든 동적 폴더에는 그 옆에 폴더와 동일한 이름을 가진 YAML 파일이 있습니다(예: asset/ 및 asset.yml). 이 파일은 스키마 폴더를 기반으로 프로덕션 폴더를 생성하는 방법에 대한 규칙을 정의합니다.Set 엔티티에 대한 새 폴더 및 YAML 파일 만들기스키마에는 Flow Production Tracking에서 추적하는 다른 엔티티에 대한 폴더가 포함된 project 폴더가 있습니다. 새 에셋 엔티티 CustomEntity01을 추가하여 Flow Production Tracking에서 Set의 항목을 추적할 수 있도록 합니다. 이러한 항목은 에셋이므로 에셋에서 폴더 및 YAML 파일을 편집할 수 있습니다.다시 말하지만 우리의 목표는 asset_type/asset/step 폴더 구조에서 set/asset_type/asset/step 폴더 구조로 바꾸는 것입니다. 따라서 해당 YAML 파일을 사용하여 스키마에서 세트를 나타내는 폴더를 추가하려고 합니다. 커스텀 엔티티에 대한 시스템 이름을 사용해야 하므로 CustomEntity01/ 폴더와 CustomEntity01.yml을 만듭니다.8단계: 스키마의 project/assets 폴더 내에 CustomEntity01 폴더를 추가합니다.9단계: 다음 내용으로 CustomEntity01 폴더 옆에 CustomEntity01.yml 파일을 만듭니다.type: &quot;shotgun_entity&quot;name: &quot;code&quot;entity_type: &quot;CustomEntity01&quot;filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }YAML 파일은 툴킷에서 CustomEntity01 폴더 이름을 무엇으로 지정할지에 대한 지침을 제공합니다. 여기서는 유형이 Flow Production Tracking_entity인 폴더를 만들고 있으며 이는 Flow Production Tracking 쿼리에 해당함을 의미합니다.  entity_type 필드는 Flow Production Tracking에서 CustomEntity01 엔티티를 쿼리함을 나타내고 name필드는 쿼리할 엔티티에 대한 필드를 나타내며 여기서는 CustomEntity01에서 code 필드를 가져옵니다.filters 필드는 이 동적 폴더를 만들어야 하는 경우를 제한합니다.10단계: asset_type/ 및 asset_type.yml을 CustomEntity01 폴더로 이동합니다.Dining-Room/Prop/filet와 같은 폴더 구조가 필요하므로 계층에서 asset_type 폴더는 CustomEntity01 폴더 아래에 있어야 합니다. asset_type/ 및 asset_type.yml을 CustomEntity01 폴더로 이동합니다.asset.yml 파일 편집filters 필드는 지정 시간에 생성된 폴더가 있는 엔티티를 제한합니다. 현재 상태에서 asset.yml의 필터 필드는 다음과 같습니다.filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }에셋에 대한 폴더를 만들기로 결정할 때 올바른 프로젝트 폴더에 있는지 올바른 asset_type 폴더에 있는지 확인하고 싶습니다. 이제 세트 폴더를 추가했으며 세 번째 필터를 추가하려고 합니다. 이 작업을 하지 않고 다음과 같은 폴더로 끝내면 잘못됩니다.assets/Dining-Room/Prop/spoonassets/Garage/Prop/spoonassets/Classroom/Prop/spoon그렇게 되지 않도록 세 번째 필터를 추가하면 에셋의 폴더가 올바른 세트의 폴더에만 생성됩니다.11단계: asset.yml에서 filters 필드를 다음과 같이 수정합니다.filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }    - { &quot;path&quot;: &quot;sg_set&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$CustomEntity01&quot; ] }폴더 생성 테스트이제 Set 커스텀 엔티티별로 에셋을 구성하도록 스키마가 성공적으로 수정되었습니다. 이제 테스트해 보겠습니다.폴더는 툴킷 파이프라인 워크플로우의 몇 지점에서 생성됩니다.  응용프로그램 시작 관리자: 사용자가 태스크에 대한 DCC를 시작할 때마다 툴킷은 해당 태스크에 대한 디렉토리를 만듭니다(아직 없는 경우). 툴킷을 사용하여 수행하는 첫 번째 작업이 보통 DCC를 시작하는 것이기 때문에 이 방법이 디렉토리를 생성하는 가장 일반적인 방법입니다. 이 작업은 Flow Production Tracking 또는 Flow Production Tracking 데스크톱이나 Create 앱에서 마우스 오른쪽 버튼 클릭 메뉴를 통해 수행할 수 있습니다.  Flow Production Tracking 메뉴: 태스크에 대해 폴더를 만드는 가장 직접적인 방법은 Flow Production Tracking에서 태스크를 마우스 오른쪽 버튼으로 클릭하고 “폴더 만들기”(Create Folders) 메뉴 항목을 선택하는 것입니다.  툴킷 API: 툴킷 API를 통해 직접 디렉토리 생성 로직을 트리거할 수 있습니다. 툴킷 API는 커스텀 시작 관리자에 툴킷을 연결하거나, Flow Production Tracking에서 샷이 생성될 때 샷에 대한 디렉토리를 자동으로 만들려는 워크플로우의 이벤트 트리거 등에 사용할 수 있습니다.  tank 명령: Flow Production Tracking의 메뉴 항목과 유사하며 tank folders 터미널 명령도 태스크에 대한 폴더를 만듭니다.tank 명령을 사용하여 테스트하겠습니다.12단계: filet 에셋에서 tank folders를 실행합니다. 터미널에서 다음을 실행합니다.&amp;gt; cd &amp;lt;pipeline_configuration_root_folder&amp;gt;&amp;gt;  ./tank Asset Filet folders출력을 요약하면 다음과 같습니다.----------------------------------------------------------------------Command: Folders----------------------------------------------------------------------Creating folders, stand by...The following items were processed: - /Users/michelle/Documents/Shotgun/projects/the_other_side. . . - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/ - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/model - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/model/publish. . .In total, 23 folders were processed.최종 구조는 예상과 일치하며 Dining과 Room 사이에 대시가 추가될 정도로 툴킷이 스마트합니다./the_other_side/assets/Dining-Room/Prop/Filet/model파일을 읽고 쓰기 위한 툴킷 템플릿이제 폴더 구조가 설정되었으며 다음 단계는 프로덕션 파일의 이름이 적절하게 지정되고 생성 시 올바른 폴더에 들어가도록 템플릿을 편집하는 것입니다.툴킷 앱의 템플릿 사용 방법먼저 세트를 나타내는 CustomEntity01을 활성화한 다음 에셋 엔티티에 에셋과 세트 간 링크를 나타내는 링크 필드를 추가하면 Flow Production Tracking에서 세트와 에셋을 연결할 수 있습니다. 에셋과 세트 간에 관계를 설정한 후 폴더 스키마를 설정하여 해당 연결을 사용해 모든 에셋 폴더를 연결된 세트의 폴더 내에 배치합니다. 이제 파일의 이름을 동적으로 지정하고 툴킷 앱에서 자동으로 파일을 관리할 수 있습니다.아티스트가 프로젝트의 태스크 작업을 시작하면 필수 폴더 구조가 생성됩니다. 그러 다음 아티스트가 Workfiles 앱의 파일 저장(File Save) 액션을 시작하면 자동으로 파일 이름이 지정됩니다. 툴킷의 Workfiles 앱을 통해 액세스한 템플릿은 해당 파일의 이름을 지정하는 데 사용됩니다. Nuke Write 노드 및 Houdini Mantra 노드와 같은 렌더 앱은 템플릿을 사용하여 렌더링된 파일의 이름을 지정하고 파일을 저장합니다. 게시된 파일의 경우 Publisher 앱에서 수행하는 작업입니다.Workfiles 파일 열기(File Open) 액션을 사용하여 파일이 액세스되면 앱은 템플릿을 사용하여 해당 파일을 찾아 로드합니다. Publisher, Loader 및 Nuke Studio Export 앱도 템플릿을 사용하여 파일을 찾고 관리합니다. 아티스트는 파일 이름이나 위치에 대해 걱정할 필요가 없으며 툴킷이 템플릿과 수행할 태스크를 기반으로 모두 관리합니다.템플릿은 구성 파일 /&amp;lt;pipeline_configuration_root&amp;gt;/config/core/templates.yml에 의해 관리됩니다. 마지막 두 안내서에서는 작업 환경에 관련된 설정을 관리하고 만들었습니다. 스키마 및 템플릿 설정은 config/core 폴더에 저장되며 환경에 한정되지 않습니다. 모든 템플릿은 단일 파일에 저장되고 다른 환경 구성 파일의 앱 설정 시 이 파일에서 참조됩니다. 예를 들어 template_work는 작업 파일에 사용하기 위해 templates.yml에서 템플릿을 지정하는 Workfiles 앱의 설정입니다. Workfiles가 구성된 환경 및 엔진에 따라 이 구성 설정을 사용하여 templates.yml에서 maya_shot_work 템플릿 또는 houdini_asset_work 템플릿을 지정할 수 있습니다.13단계: 파이프라인의 구성에서 config/core/templates.yml을 엽니다.이 파일은 다음 세 개의 섹션으로 나뉩니다.  키: 템플릿 작성에 사용할 토큰 세트입니다(예: {version}, {Asset}, 등). 템플릿이 실제로 사용될 때 실제 값으로 대체됩니다. 각 키에는 필요한 이름과 유형 및 기타 선택적 매개변수가 있습니다.  경로: 키를 사용하여 디스크의 폴더 및 파일에 대한 경로를 나타내는 명명된 문자열입니다. paths 섹션의 템플릿은 유효성이 검사되고 디스크에 실제로 존재해야 합니다.  문자열: 경로 섹션과 유사하지만 임의 텍스트에 대한 템플릿입니다. 경로 섹션의 항목은 유효성이 검사되고 디스크의 실제 경로와 일치해야 하며 문자열은 툴킷 워크플로우에서 참조하려는 텍스트 데이터를 저장하는 데 사용할 수 있습니다.Set 엔티티에 대한 템플릿 키 추가가장 먼저 할 일은 엔티티의 시스템 이름을 사용하여 Set 엔티티에 대한 새 키를 정의하는 것입니다.14단계: 들여쓰기에 유의하여 templates.yml의 keys 섹션에 다음 줄을 추가합니다.       CustomEntity01:           type: str템플릿 수정템플릿은 툴킷이 파일을 읽고 쓰는 위치를 정의하기 때문에 여기에서 정의한 경로와 스키마에서 정의한 폴더 구조가 일치하는 것이 중요합니다. 결국 프로덕션 파일은 여기에서 생성하는 파일 시스템으로 이동해야 합니다. 따라서 모든 에셋 관련 템플릿을 스키마에서 정의한 새 폴더 구조와 일치하도록 수정합니다.그런 다음 Maya에서 에셋 단계의 작업 파일에 대한 템플릿을 수정하여 세트도 파일 이름에 포함하도록 합니다. 기본 구성에서 문제의 템플릿은 maya_asset_work이며 이 템플릿부터 살펴보겠습니다.Maya에서 에셋 기반 Workfiles에 대해 maya_asset_work라는 템플릿을 사용하는 것이 기본 구성의 규칙입니다. 올바른 템플릿인지 확인하려면 asset_step 환경(여기서는 GitHub)에서 tk-maya 엔진의 tk-multi-workfiles2에 대한 template_work 설정 값을 확인합니다.15단계: templates.yml을 열고 maya_asset_work를 찾습니다.   maya_asset_work:        definition: '@asset_root/work/maya/{name}.v{version}.{maya_extension}'maya_asset_work의 definition 값은 @asset_root로 시작합니다. @ 기호는 @asset_root 값이 다른 곳에서 정의된 것임을 나타냅니다.앞의 @ 기호는 환경 구성 파일에서처럼 templates.yml에서 포함을 나타내지 않습니다.각 통합, 각 앱 및 각 환경이 다른 설정을 사용할 수 있기 때문에 경로의 첫 번째 부분은 templates.yml 내의 다양한 지점에 사용될 수 있음을 가정할 수 있습니다. 구성은 단일 변수를 사용하여 공통 경로 루트를 저장한 다음 템플릿 내에서 해당 변수를 참조할 수 있도록 설정됩니다. 공통 루트를 참조할 수 있는 경우 경로 생성 설정의 각 인스턴스를 변경할 필요가 없습니다.기본 구성에는 세 개의 공통 루트 변수 @shot_root, @sequence_root 및 @asset_root가 있습니다. @asset_root를 수정하겠습니다. 이렇게 한 번 변경하면 모든 에셋 관련 템플릿에 영향이 미칩니다.템플릿을 파일 시스템 스키마의 경로와 일치하도록 편집16단계: templates.yml의 paths 섹션 맨 위에서 asset_root를 찾습니다. 기본 구성에서는 다음과 같습니다.asset_root: assets/{sg_asset_type}/{Asset}/{Step}스키마 수정 사항과 일치하도록 asset_root 경로에 CustomEntity01을 추가합니다.asset_root: assets/{CustomEntity01}/{sg_asset_type}/{Asset}/{Step}파일 이름에 세트 추가스키마 변경 사항을 반영하도록 파일의 폴더 구조를 변경했으며 이제 적절한 위치에서 파일을 읽고 쓸 수 있습니다. 그럼 이제 Maya 에셋 작업 파일 템플릿에 대한 파일 이름에도 세트가 포함되도록 수정하겠습니다.maya_asset_work 템플릿 정의를 다시 찾습니다. 현재 상태에서 파일 이름은 다음과 같습니다.{name}.v{version}.{maya_extension}{name} 템플릿 키는 Workfiles 앱의 파일 저장(File Save) 액션에서 사용자 입력을 나타내는 특수 키입니다. 템플릿에 어떤 사용자 입력도 포함하지 않고 대신 현재 세트 및 에셋으로만 구성되도록 수정하겠습니다.17단계: maya_asset_work 템플릿 정의를 다음과 같이 수정합니다.    maya_asset_work:        definition: '@asset_root/work/maya/{CustomEntity01}_{Asset}.v{version}.{maya_extension}'이 액션을 통해 파일 이름에 Dining-Room 엔티티의 적절한 이름을 사용할 수 있습니다. 결과는 Dining-Room_Filet.v1.mb와 같이 지정됩니다.이제 프로덕션 폴더 구조에 새 세트 폴더를 반영하고 Maya에서 에셋 태스크에 대한 작업 파일에 세트 이름을 포함하도록 templates.yml이 수정되었습니다. 변경 사항을 테스트해 보겠습니다.테스트18단계: Flow Production Tracking 데스크톱에서 Maya를 시작합니다.Maya에서 Flow Production Tracking &amp;gt; 파일 열기(File Open)로 이동하여 결과 대화상자에서, Flow Production Tracking에서 Set를 지정한 에셋에 대한 태스크를 선택합니다.+새 파일(+New File)을 선택합니다.간단한 3D 객체를 만들거나 Flow Production Tracking &amp;gt; 파일 저장(Save File)을 사용하여 파일을 저장할 수 있습니다.다 되었습니다!파일 저장(File Save) 대화상자에 새 템플릿 설정을 사용하여 미리보기: Dining-Room_scene.v001.ma(Preview: Dining-Room_scene.v001.ma)가 표시되어 있습니다.작업 영역(Work Area)에는 Workfiles가 파일을 저장하는 경로인 …ShotGrid/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/model/work/maya가 표시되어 있습니다.고급 항목예제 확장이 예제에서는 단일 템플릿을 수정했지만 파일 시스템 구성을 사용하여 수행할 수 있는 작업은 훨씬 많습니다. 실제 사례에서는 동일한 파일 명명 규칙을 갖도록 모든 에셋 관련 파일을 변경합니다. 다른 엔티티(시즌, 에피소드, 레벨 등)를 기반으로 수정하고, 사용자 폴더를 만들고, 정규 표현식으로 조작된 Flow Production Tracking 데이터를 기반으로 폴더 이름을 지정하는 등 많은 작업을 수행할 수 있습니다. 툴킷의 모든 폴더 및 스키마 옵션에 대한 자세한 내용은 파일 시스템 구성 참조를 참조하십시오.경로 캐시폴더가 생성될 때 디스크의 폴더와 Flow Production Tracking 엔티티 간에 매핑이 만들어집니다. 이러한 매핑은 Flow Production Tracking에 FilesystemLocation 엔티티로 저장되고 사용자 컴퓨터의 SQLite 데이터베이스에서 캐시됩니다. 경로 캐시 작동 방식과 이를 사용한 작업 방법에 대한 자세한 내용은 이 문서를 참조하십시오.추가 리소스  파일 시스템 구성 참조  툴킷 구성 소개 웨비나 동영상",
    "url": "/56b441c6/",
    "relUrl": "/56b441c6/"
  },
  "41": {
    "id": "41",
    "title": "구성 편집",
    "content": "파이프라인 구성 편집이 안내서를 통해 다음과 같은 기본 사항을 익힐 수 있습니다.  특정 툴킷 앱의 구성 설정 찾기  설정 편집  구성 설정에서 확장할 수 있는 다른 기능 살펴보기안내서 정보이 안내서에서는 기존 파이프라인 구성 내에서 설정을 프로젝트 파이프라인의 요구 사항에 맞게 편집하는 방법에 대해 설명합니다. 첫 번째 안내서인 구성 시작하기에서는 편집을 위해 파이프라인 구성을 준비하는 방법을 설명합니다. 편집 가능한 프로젝트 구성을 만드는 데 익숙하지 않다면 먼저 구성 시작하기를 전체적으로 검토하십시오.기본 구성을 확장하는 방법으로 Flow Production Tracking 툴킷에서 파이프라인 워크플로우 내의 태스크를 커스터마이즈할 수 있습니다. 커스터마이즈의 간단한 예로, 하나 이상의 소프트웨어 패키지 내에서 툴킷 앱의 버튼을 활성화 또는 비활성화하여 사용자들이 툴킷의 기능과 상호 작용하는 방식을 변경할 수 있습니다. 툴킷은 독자적인 구성을 지원하므로 커스텀 워크플로우를 생성하고, 반복적이고 일상적인 태스크를 자동화하고, 후크를 수정하고, 툴킷 플랫폼에 커스텀 도구를 추가함으로써 더 스마트하고 빠르게 작업할 수 있습니다. 그러나 Flow Production Tracking 소프트웨어 통합을 통해서만 액세스할 수 있으며 일상적인 작업용으로는 아직 출시되지 않았습니다.이 안내서의 연습을 통해 Flow Production Tracking 소프트웨어 통합 내에서 구성 설정 제어 액션을 찾는 방법과 설정이 존재하는 위치, 설정을 편집하는 방법을 익힐 수 있습니다. 특히 Maya 내에서 프로젝트 작업 중에 아티스트가 새 태스크를 생성하지 못하도록 +새 태스크(+New Task) 버튼의 동작을 관리하는 Workfiles 앱의 설정을 편집해 보겠습니다.이 문서 사용이 안내서를 사용하고 파이프라인 구성에 대한 편집을 수행하려면 다음이 필요합니다.  활성 Flow Production Tracking 사이트  하나 이상의 에셋이 있는 프로젝트. 첫 번째 안내서에서 생성한 the_other_side 프로젝트에 에셋을 추가할 수 있습니다. 구성 시작하기 안내서에서 프로젝트의 에셋을 생성하는 방법을 익힐 수 있습니다.  식별된 프로젝트에 대한 파이프라인 구성이나 구성 시작하기 안내서를 완료하고 해당 연습에서 생성한 구성을 사용합니다.  파이프라인 구성이 저장된 파일 시스템에 대해 읽기 및 쓰기 권한을 적절하게 설정합니다.  Flow Production Tracking 데스크톱이 시스템에 설치되어 있어야 합니다.  활성 상태의 Maya 서브스크립션. Maya의 30일 체험판은 여기에서 구할 수 있습니다.                    참고: 이 안내서는 tk-config-default2 파이프라인 구성을 기반으로 합니다. 이 구성을 수정한 경우 YAML 설정의 파일, 폴더 및 블록의 위치가 여기에 설명된 것과 다를 수 있습니다.    Workfiles 앱 정보Workfiles 앱은 Flow Production Tracking 소프트웨어 통합에서 파일 관리를 제어하고, 작업 파일을 검색하고 열고 저장하는 기능에 대한 액세스를 제어합니다. +새 태스크(+New Task) 버튼은 사용자가 이 작업을 수행하기 위해 Flow Production Tracking로 이동할 필요 없이 태스크를 추가할 수 있게 해 주는 Workfiles 앱의 동작입니다. 구성은 환경별 파일로 나뉩니다. 이를 통해 파일을 생성하고, 파일에 이름을 지정하고, 파일을 저장하는 시기 또는 태스크를 실행하거나 특정 기능을 수행하는 시기를 제어하는 등 파이프라인의 여러 단계와 관련된 기능을 관리할 수 있습니다. 이러한 구성은 Workfiles 앱의 모든 기능과 연관되며 앱 또는 엔진의 설정을 수정할 때도 적용됩니다. 자세한 내용은 이 문서의 끝부분에 있는 고급 항목을 참조하십시오.구성 파일 익히기ShotGrid의 파이프라인 구성 목록을 사용하여 작업 중인 프로젝트의 파이프라인 구성이 저장된 위치를 찾을 수 있습니다. 파일이 저장된 위치를 알고 있는 경우 5단계로 건너뛸 수 있습니다.파이프라인 구성 찾기1단계: 이 연습에서 사용하게 될 프로젝트를 관리하는 Flow Production Tracking 사이트를 엽니다.2단계: Flow Production Tracking 사이트의 프로젝트 페이지에서 프로젝트를 선택하여 액세스합니다.3단계: 오른쪽 상단에 있는 아바타를 선택하여 관리자(ADMIN) 메뉴를 표시하고 아래로 스크롤하여 기본 레이아웃(Default Layouts) &amp;gt; 파이프라인 구성(Pipeline Configuration) &amp;gt; 파이프라인 구성 목록(Pipeline Configuration List)을 선택합니다.4단계: 파이프라인 구성 목록(Pipeline Configuration List)이 표시되면 열 헤더 맨 오른쪽의 + 기호를 선택하여 다른 열을 추가합니다. 드롭다운 목록에서 적절한 운영 체제 경로를 선택합니다.경로가 새 필드에 표시됩니다.5단계: 터미널 또는 파일 관리자에서 프로젝트의 파이프라인 구성이 저장된 폴더를 찾아 폴더를 엽니다.툴킷 구성 루트 폴더에는 cache, config 및 install이라는 3개의 하위 폴더가 있습니다. config 폴더를 열면 몇 개의 하위 폴더와 파일이 중첩되어 있음을 확인할 수 있습니다.env 폴더는 아티스트가 작업하는 환경을 지원하는 통합 설정을 저장합니다. 환경을 통해 파이프라인의 여러 단계에서 구성을 커스터마이즈할 수 있습니다. 기본 구성이 일련의 미리 정의된 환경과 함께 제공되지만 이 구성은 파이프라인을 더 세부적으로 설정하기 위해 수정할 수 있습니다.6단계: env 폴더를 엽니다.툴킷은 YAML 파일을 사용하여 기능을 구성합니다. YAML은 툴킷 내의 파일 형식을 읽기 쉽고 간단하고 단순한 방식으로 커스터마이즈할 수 있기 때문에 YAML이 구성 언어로 선택되었습니다. YAML에 대한 자세한 내용은 여기를 참조하십시오. 구성은 식별자 엔진, 앱 및 프레임워크를 제공하는 중첩된 YAML 파일로 구성됩니다. 구성은 적용할 액션을 제어하는 특정 코드 번들로 안내하는 일종의 로드맵입니다.구성 파일 편집Flow Production Tracking 툴킷을 통해 다양한 소프트웨어 패키지 내에 통합된 앱으로 변경할 수 있습니다. Workfiles 앱의 기능 중 하나는 +새 태스크(+New Task) 버튼으로, 사용자가 파일 열기(File Open) 대화상자에서 새 태스크를 추가할 수 있게 해 줍니다. 기본적으로 이 기능은 모든 사용자에 대해 프로젝트의 모든 진행단계에서 활성화되어 있습니다. 그러나 이 기능을 제한하고 싶은 스튜디오도 있을 수 있습니다. 특정 명명 규칙이 있거나 프로젝트의 프로덕션 관리 팀만 태스크를 생성할 수 있도록 제한하려는 경우에 그렇습니다. 이 경우 아티스트가 Maya에서 작업할 파이프라인의 모든 지점에 대해 +새 태스크(+New Task) 버튼을 비활성화하면 됩니다.Maya에서 프로젝트에 대해 +새 태스크(+New Task) 버튼 비활성화7단계: Flow Production Tracking 데스크톱을 엽니다.8단계: 편집할 구성의 프로젝트를 선택합니다.9단계: Flow Production Tracking 데스크톱에서 Maya를 시작합니다.Flow Production Tracking 메뉴가 완전히 로드될 때까지 기다립니다. 인터넷 연결 속도가 느릴 경우 메뉴가 로드되는 동안 커피 한 잔 준비하는 것도 좋습니다.Maya와 Flow Production Tracking가 완전히 로드되면 파일 열기(File Open) 대화상자가 자동으로 열립니다. Flow Production Tracking 데스크톱에서 Maya를 실행하면 프로젝트 환경에서 Maya가 시작되고 툴킷 워크플로우의 구성이 config/env/project.yml 파일에 의해 구동됩니다. 기본 구성에서 식별되는 환경은 project, sequence, shot, shot_step, asset, asset_step입니다.10단계: 파일 열기(File Open) 대화상자의 왼쪽 창에서 에셋(Assets) 탭을 선택합니다. 검색 결과에 표시되는 폴더 내의 모든 에셋을 선택합니다.+새 태스크(+New Task) 버튼이 활성화되어 있습니다.+새 태스크(+New Task) 버튼을 제어하는 설정 찾기파이프라인 요구 사항을 충족하기 위해 툴킷 파이프라인 구성을 사용하여 사용자 환경을 커스터마이즈할 수 있습니다. 파이프라인 구성은 프로젝트 파이프라인의 요구 사항에 맞게 필요에 따라 기본 Flow Production Tracking 통합 설정을 재정의할 수 있습니다. Flow Production Tracking 코어 코드의 기본값과 다른 설정만 추가하여 구성을 간단하게 생성할 수 있는 구조입니다. 이 연습에서는 Workfiles 앱의 +새 태스크(+New Task) 버튼을 사용할 수 없게 할 예정이지만 그전에 이 버튼을 제어하는 구성 설정을 확인해야 합니다.11단계: 프로젝트(프로젝트 이름)(Project(프로젝트 이름)) 옆에 있는 파일 열기(File Open) 창의 오른쪽 상단에서 &amp;gt;를 선택합니다.이 참조 상자는 파일 열기(File Open) 창의 기능을 제어하는 구성 설정에 대한 상세한 정보를 보여 줍니다. 툴킷의 일부 앱에는 앱에 사용된 설정과 기본 설정을 보여 주는 참조 상자가 있습니다. 위치:(Location:) 식별자는 tk-multi-workfiles2입니다. 이 식별자는 Workfiles 앱을 만드는 코드 번들의 식별자입니다. 파이프라인 구성을 검색할 때 이 이름으로 앱의 설정이 있는 위치를 확인할 수 있습니다. Flow Production Tracking 통합에서 사용할 수 있는 모든 구성 설정, 앱 및 엔진이 나열된 앱 및 엔진 페이지가 있습니다.이 특정 환경에 대한 설정을 찾으려면 구성(Configuration) 헤더 아래를 확인하십시오.                    참고: my_tasks_filters 설정 다음이 launch_at_startup 설정입니다. 프로젝트 환경에서 파일 열기(File Open) 설정의 기본 설정이므로 유의해야 합니다. 이는 Flow Production Tracking 데스크톱에서 Maya가 실행되면 파일 열기(File Open) 대화상자가 자동으로 열린다는 의미입니다.    설정 allow_task_creation까지 아래로 스크롤합니다. 이 설정의 기본값은 True이므로 사용자가 Maya 프로젝트 환경에 있는 동안 새 태스크를 생성할 수 있습니다.설정을 검색할 때 다음 사항을 고려해야 합니다.  실행 중인 소프트웨어 응용프로그램  작업 중인 파일과 환경. 이 부분은 앱의 참조 상자에서 확인할 수 있습니다.  호출되는 설정. 이 부분은 앱의 참조 상자 또는 앱 및 엔진 페이지에서 확인할 수 있습니다.  확장할 YAML 파일. YAML 파일에 자세히 나와 있는 식별자와 로드맵으로 설정이 있는 위치를 확인할 수 있습니다.  확장할 YAML 파일 내의 특정 블록. 이는 로드맵에서 확인할 수 있습니다.  YAML 파일에서 사용되는 식별자 및 기호.  현재 프로젝트의 구성이 저장된 위치(가장 중요).설정은 파이프라인 구성 내의 여러 곳에서 활용될 수 있습니다. 적용할 소프트웨어 통합 및 변경할 파이프라인 프로세스에 따라 활용 방법이 결정됩니다.allow_task_creation 값을 설정할 위치 찾기12단계: 기본 Maya 창을 앞으로 가져옵니다.13단계: Maya 창의 오른쪽 상단에서 Flow Production Tracking 메뉴 항목을 찾습니다.팁: 메뉴가 표시되지 않을 경우 일부 숨겨진 메뉴 항목을 볼 수 있는 »가 표시됩니다. »를 선택하여 Flow Production Tracking 메뉴를 표시하거나 Maya 창을 넓히면 됩니다.14단계: 메뉴 오른쪽 상단에서 Flow Production Tracking &amp;gt; 프로젝트 the_other_side(Project the_other_side) &amp;gt; 작업 영역 정보…(Work Area Info…)를 선택합니다.작업 영역 정보(Work Area Info) 대화상자에는 현재 작업 영역이 어떻게 돌아가는지 및 상세 정보가 표시됩니다. 여기에는 작업 중인 환경 및 설정이 위치한 환경 구성 파일의 경로도 포함됩니다.15단계: 현재 작업 영역(Your Current Work Area) 대화상자에서 아래에 있는 환경(Environment) 탭을 선택합니다.첫 번째 항목에서 사용 중인 엔진이 확인됩니다. 엔진은 특정 소프트웨어 응용프로그램 내에서 Flow Production Tracking 도구를 통합하는 기능을 구동합니다. 여기에는 각 소프트웨어 통합에 해당하는 로직이 포함됩니다. 창에 표시된 두 번째 항목은 현재 프로젝트 환경이 위치한 경로를 보여 줍니다.마지막 두 폴더는 project.yml이고 그 다음에 config/env/이 표시됩니다. project.yml 파일은 현재 환경에 대한 설정이 있는 위치를 안내하는 로드맵의 시작입니다.16단계: 즐겨 사용하는 텍스트 편집기에서 project.yml을 엽니다.description: Apps and Engines when launching with a project only context.################################################################################includes:- ./includes/frameworks.yml- ./includes/settings/tk-3dsmaxplus.yml- ./includes/settings/tk-desktop.yml- ./includes/settings/tk-flame.yml- ./includes/settings/tk-houdini.yml- ./includes/settings/tk-mari.yml- ./includes/settings/tk-maya.yml- ./includes/settings/tk-motionbuilder.yml- ./includes/settings/tk-nuke.yml- ./includes/settings/tk-photoshopcc.yml- ./includes/settings/tk-shell.yml- ./includes/settings/tk-shotgun.yml################################################################################# configuration for all engines to load in a project contextengines:  tk-3dsmaxplus: &quot;@settings.tk-3dsmaxplus.project&quot;  tk-desktop: &quot;@settings.tk-desktop.project&quot;  tk-flame: &quot;@settings.tk-flame.project&quot;  tk-hiero: &quot;@settings.tk-nuke.hiero.project&quot;  tk-houdini: &quot;@settings.tk-houdini.project&quot;  tk-mari: &quot;@settings.tk-mari.project&quot;  tk-maya: &quot;@settings.tk-maya.project&quot;  tk-motionbuilder: &quot;@settings.tk-motionbuilder.project&quot;  tk-nuke: &quot;@settings.tk-nuke.project&quot;  tk-nukestudio: &quot;@settings.tk-nuke.nukestudio.project&quot;  tk-photoshopcc: &quot;@settings.tk-photoshopcc.project&quot;  tk-shell: &quot;@settings.tk-shell.project&quot;  tk-shotgun: &quot;@settings.tk-shotgun.project&quot;################################################################################# reference all of the common frameworksframeworks: &quot;@frameworks&quot;project.yml 내에는 설명 아래 세 가지 섹션 includes, engines 및 frameworks가 있습니다. includes 섹션은 구성에서 다른 YAML 파일을 참조하는 파일 포인터의 목록입니다. 기본 구성의 아키텍처에서는 파일을 간단하게 유지하기 위한 또 다른 방법으로 파일 중첩 및 포인터를 활용합니다. includes를 따라가면 원하는 구성 설정을 찾을 때까지 다음 파일로 이동합니다. 이는 적절한 구성 설정을 찾을 때까지 계속해서 내부에 포개진 인형이 하나씩 열리는 러시아 마트료시카 인형과 비슷합니다.모든 엔진은 tk-&amp;lt;name of software application&amp;gt;으로 식별됩니다. Maya에서 설정을 적용하려고 하므로 찾아야 할 식별자는 tk-maya입니다.project.yml 파일의 includes: 섹션에서 ./includes/settings/tk-maya.yml 행을 찾습니다. 이 행은 settings 폴더 내의 includes 폴더에 중첩된, Maya 엔진의 설정을 제어하는 구성 tk-maya를 나타냅니다.engines: 섹션에서 tk-maya 값을 찾습니다.tk-maya: &quot;@settings.tk-maya.project&quot;이 @ 기호는 값이 포함된 파일에서 제공되었음을 나타냅니다.settings 및 project는 프로젝트의 설정임을 나타냅니다. 이는 식별하는 데 도움이 되는 기본 구성 내의 명명 규칙입니다.이 전체 행은 Maya 엔진의 구성 설정인 tk-maya를 찾기 위해 포함된 파일에서 settings.tk-maya.project 블록을 찾는다는 것을 나타냅니다.Flow Production Tracking 툴킷은 YAML 파일에서 간단한 용어를 사용하여 설정의 이름과 설정으로 이동하는 경로를 나타냅니다. +새 태스크(+New Task) 버튼 수행 방식을 제어하는 코드 번들이 tk-multi-workfiles2로 식별되는 것은 Maya 파일 열기(File Open) 참조 상자를 볼 때 이미 알고 있습니다. 툴킷 번들은 이러한 식별자를 사용하여 YAML 파일에서 참조됩니다. ‘tk-multi-workfiles2’는 Workfiles 앱 코드 번들의 식별자이며 +새 태스크(+New Task) 버튼은 Workfiles 앱의 기능입니다.tk-maya.yml에서 Workfiles 앱 설정 찾기17단계: 파일 브라우저에서 env/includes/settings 폴더를 찾아 tk-maya.yml을 엽니다.18단계: project.yml에서 include를 따라가면서 tk-maya.yml 파일에서 settings.tk-maya.project를 찾습니다. 구체적으로는 특정 프로젝트의 프로젝트 환경에서 +새 태스크 (+New Task) 버튼을 비활성화하려고 합니다. 현재 해당 프로젝트에 대한 구성에 있으며 프로젝트 환경에 있는 동안 위치 정보를 얻었습니다.# projectsettings.tk-maya.project:  apps:    tk-multi-about:      location: &quot;@apps.tk-multi-about.location&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-multi-shotgunpanel: &quot;@settings.tk-multi-shotgunpanel&quot;    tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;  menu_favourites:  - {app_instance: tk-multi-workfiles2, name: File Open...}  location: &quot;@engines.tk-maya.location&quot;settings.tk-maya.projects 아래에 tk-multi-workfiles2 앱 설정이 다음과 같이 나열됩니다.tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;@ 기호는 tk-multi-workfiles2 값이 포함된 파일에서 제공된 것임을 나타냅니다. tk-maya.yml의 맨 위에 있는 includes 섹션에서 다음을 확인할 수 있습니다.includes:...- ./tk-multi-workfiles2.yml현재 파일 config/env/includes/settings와 동일한 디렉토리에 있는 tk-multi-workfiles2.yml 파일에서 settings.tk-multi-workfiles2.launch_at_startup을 찾아야 합니다.19단계: tk-multi-workfiles2.yml 파일을 열고 settings.tk-multi-workfiles2.launch_at_startup을 찾습니다.# launches at startup.settings.tk-multi-workfiles2.launch_at_startup:  launch_at_startup: true  entities:allow_task_creation 설정을 나타내는 Maya 참조 상자에서 기본값은 true입니다. 가장 좋은 방법은 파이프라인 구성에 기본 설정을 반영하지 않는 것입니다. 이렇게 하면 스파스 형식이 허용되어 기본 코드와 다른 설정만 구성에 추가됩니다. 설정이 명시적으로 제공되지 않는 경우 해당 설정이 액세스하는 모든 호출이 기본값을 받습니다. 툴킷이 구성을 읽고 환경을 빌드하면 해당 환경에서 실행되는 앱, 엔진 및 프레임워크는 해당 프로젝트의 파이프라인 구성 설정을 사용하고 구성에 있는 항목을 기반으로 모든 기본 설정을 재정의합니다.20단계: tk-multi-workfiles2.yml에서 settings.tk-multi-workfiles2.launch_at_startup: 아래 allow_task_creation을 추가하고 값을 false로 설정합니다.# launches at startup.settings.tk-multi-workfiles2.launch_at_startup:  allow_task_creation: false  launch_at_startup: true  entities:참고: 툴킷 기본 구성 설정은 특정 설정을 찾기 쉽도록 알파벳순으로 구성됩니다. 이 규칙을 유지해야 구성이 복잡해질 경우에도 처리하기가 편리합니다.21단계: 파일을 저장합니다.구성 다시 로드22단계: Maya 내의 파일 열기(File Open) 대화상자에서 참조 상자를 열고 엔진 및 앱 다시 로드(Reload Engines and Apps)를 선택합니다.그러면 구성 설정이 다시 로드됩니다.변경 사항 보기23단계: 파일 열기(File Open) 대화상자로 이동하여 에셋을 선택합니다.+새 태스크(+New Task) 버튼이 표시되지 않습니다.Workfiles 앱의 구성 설정을 수정하여 프로젝트 환경의 버튼 동작을 변경했습니다. 이 프로젝트 환경의 해당 설정만 수정했기 때문에 다른 환경에서 작업을 시작하면 +새 태스크(+New Task) 버튼에 대한 설정은 여전히 활성 상태입니다. 예를 들어 실제 프로덕션에서 모든환경에 대해 지금처럼 변경할 수 있습니다.환경 변경24단계: 에셋(Assets) 검색 결과에서 폴더를 열고 작업할 에셋을 선택합니다.25단계: +새 파일(+New File)을 선택합니다.+새 파일(+New File)을 선택하여 새 에셋에 대한 작업을 시작했으며 Maya에서 asset_step 환경이 로드되었습니다. 아티스트가 에셋 태스크를 선택하고 새 파일을 생성하거나 기존 파일을 열면 asset_step 환경이 자동으로 로드되어 파이프라인의 해당 단계에 구성된 도구 및 기능이 제공됩니다.작업 중인 환경 검색26단계: Maya 메뉴 오른쪽 상단에서 Flow Production Tracking를 선택합니다.아트, 에셋 텍스트 오버레이(Art, Asset Text Overlay)는 작업 중인 환경과 현재 환경을 알려 줍니다.27단계: 아트, 에셋 텍스트 오버레이((Art, Asset Text Overlay) &amp;gt; 작업 영역 정보…(Work Area Info…)를 선택하여 현재 작업 영역에 어떤 매개변수가 있는지 표시합니다.28단계: 아래에 있는 환경(Environment) 탭을 선택합니다.각 환경은 파이프라인 구성에서 설정이 있는 위치를 확인할 수 있도록 필요한 정보를 표시합니다. 아티스트가 새 태스크를 추가하지 않도록 하려면 아티스트가 작업하는 모든 환경에 대해 +새 태스크(+New Task) 버튼을 비활성화해야 합니다. 각 환경에 대해 위에 설명한 것과 동일한 단계를 사용하여 적절하게 구성을 편집합니다.참고: 각 환경은 독립적이며 프로젝트는 전용 구성을 사용하고 소프트웨어 통합은 프로젝트가 로드될 때 파이프라인 구성에서 해당 특정 소프트웨어의 설정만 읽습니다.지금까지 파이프라인 구성을 편집하여 앱 설정을 변경했습니다. 이제 본격적으로 Flow Production Tracking 툴킷 환경에서 수행할 수 있는 모든 작업에 대해 알아보겠습니다. 다음은 살펴볼 몇 가지 고급 항목입니다.고급 항목이 안내서에서는 단일 엔진(tk-maya) 및 단일 환경(project)에서 앱의 구성 설정을 간단하게 변경했습니다. 툴킷은 환경별로 구성되고, 모든 소프트웨어 구현에 있어 각 환경은 고유하며, 정의된 파이프라인 지점에서 아티스트가 특정 기능을 사용할 수 있도록 프로젝트 및 태스크별로 초점을 맞추는 것에 대해 학습했습니다. 간단한 변경 사항을 일반화하면 툴킷 파이프라인 구성을 얼마든지 커스터마이즈할 수 있습니다.기타 엔진Workfiles 앱의 시스템 이름은 tk-multi-workfiles2이고 여기서 multi는 이 앱이 다중 앱임을 암시합니다. 다중 앱은 소프트웨어에 구속받지 않는 앱으로, Maya, Nuke, Houdini에서 실행하든 기타 지원되는 앱에서 실행하든 앱의 기능이 동일합니다. 모든 소프트웨어 패키지의 Workfiles에서 태스크 생성을 비활성화하려면 모든 엔진(tk-nuke, tk-houdini 등)에 대해 이 안내서의 단계를 수행합니다.기타 환경여기서는 프로젝트 환경에서 태스크 생성을 비활성화했지만 실제 스튜디오 환경에서는 아티스트가 작업 중인 모든 환경에 대해 태스크 생성을 비활성화하고 싶을 수 있습니다. 이를 위해서는 안내서의 단계를 수행하되 project.yml에서 시작하는 대신 asset_step.yml, shot_step.yml 등에서 시작합니다.커스텀 환경 생성기본 구성은 일련의 미리 정의된 파이프라인 단계(project, sequence, shot, shot_step, asset 및 asset_step)와 함께 제공됩니다. 그러나 스튜디오에서는 파이프라인 단계(asset_step_rig, asset_step_model, shot_step_anim, shot_step_light 등)마다 다른 구성 설정을 원할 수 있습니다. 툴킷은 커스텀 환경을 지원합니다. 자세한 내용은 환경 구성 참조의 “커스텀 환경” 섹션을 참조하십시오.비디오 리소스  SIGGRAPH 2018 Developer Day의 툴킷 구성 소개  기본 구성 이해 웨비나앱 구성 설정을 수정하는 방법에 대해 알아보았습니다. 이제 툴킷 구성에 앱을 추가해 보십시오.",
    "url": "/37f575b8/",
    "relUrl": "/37f575b8/"
  },
  "42": {
    "id": "42",
    "title": "암호화 핸드쉐이크를 완료하지 않고 통신을 시도함",
    "content": "[ERROR] 암호화 핸드쉐이크를 완료하지 않고 통신을 시도함활용 사례:Flow Production Tracking 데스크톱의 브라우저 통합을 시작하고 실행하는 데 문제가 있습니다.Shotgun 데스크톱을 시작하면 웹 서버가 실행 중임을 알 수 있습니다.[    INFO] WebSocketServerFactory (TLS) starting on 9000[    INFO] Starting factory…그 다음에는 오류를 표시하지 않는 디버그 레코드가 로드됩니다.Flow Production Tracking 사이트에 로그인할 때 다음과 같은 메시지가 표시됩니다.[ INFO] Connection accepted.프로젝트를 마우스 오른쪽 버튼으로 클릭하면 Flow Production Tracking에서 작업을 검색 중이라고 표시되고 다음과 같은 로그 출력이 제공됩니다.[    INFO] Connection accepted.[   ERROR] Attempted to communicate without completing encryption handshake.[   ERROR] Attempted to communicate without completing encryption handshake.[    INFO] Connection closed.[   DEBUG] Reason received for connection loss: [Failure instance: Traceback (failure with no frames): : Connection to the other side was lost in a non-clean fashion: Connection lost.ShotGrid에서 프로젝트를 열면 다음과 같은 로그 출력이 생성됩니다.[    INFO] Connection accepted.[   ERROR] Attempted to communicate without completing encryption handshake.[   ERROR] Attempted to communicate without completing encryption handshake.[   ERROR] Attempted to communicate without completing encryption handshake.[   ERROR] Attempted to communicate without completing encryption handshake.[ WARNING] dropping connection to peer tcp4:127.0.0.1:52451 with abort=True: WebSocket closing handshake timeout (peer did not finish the opening handshake in time)[    INFO] Connection closed.[   DEBUG] Reason received for connection loss: [Failure instance: Traceback (failure with no frames): : Connection to the other side was lost in a non-clean fashion: Connection lost.해결 방법:프록시 무시 목록에 shotgunlocalhost.com을 추가합니다.이 오류가 발생하는 원인의 예:프록시 구성커뮤니티에서 전체 스레드를 참조하십시오.",
    "url": "/2fa5964e/",
    "relUrl": "/2fa5964e/"
  },
  "43": {
    "id": "43",
    "title": "VPC Endpoints",
    "content": "VPC EndpointsComing soon.",
    "url": "/8a9c5baf/",
    "relUrl": "/8a9c5baf/"
  },
  "44": {
    "id": "44",
    "title": "환경 구성 참조",
    "content": "환경 구성 참조소개툴킷 파이프라인의 핵심에는 환경 구성이 있습니다. 툴킷 파이프라인 구성 내에서 환경 구성 파일은 다양한 DCC 내에서 사용할 수 있는 툴킷 앱을 정의하고 각 설정을 커스터마이즈할 수 있는 곳입니다. 이 문서는 환경 구성 파일의 구조 및 기능을 전체적으로 소개하는 완전한 참조 자료입니다. 이 문서에서는 프로젝트 내에서 다양한 워크플로우를 구성할 수 있게 해 주는 툴킷 환경의 개념과 커스터마이즈할 수 있는 항목을 찾는 방법에 대해 설명합니다.                    참고: 이 문서는 환경 구성 파일에 대한 참조 자료로 사용될 수 있으며 툴킷 기본 사항 안내서의 파이프라인 구성 편집에서는 구성 설정 편집에 대한 단계별 예제를 확인할 수 있습니다.    환경이란?Flow Production Tracking 툴킷 플랫폼은 스튜디오 파이프라인을 구축하는 데 일반적으로 사용되는 컨텐츠 작성 소프트웨어를 위해 완전히 커스터마이즈 가능한 통합 세트를 제공합니다. 프로젝트 구성 내에서 통합이 있는 소프트웨어 패키지, 각각 사용 가능한 툴킷 앱, 각 앱에 대한 옵션을 지정하여 스튜디오의 요구 사항에 맞게 아티스트 워크플로우를 구축할 수 있습니다.하지만 대부분의 스튜디오 파이프라인에서는 아티스트 유형별로 다른 워크플로우를 사용하는 것이 일반적입니다. 간단한 예로, 에셋 작업 중인 아티스트의 경우 텍스처 페인팅 소프트웨어(예: Mari)를 사용하게 하고 샷 작업 중인 아티스트의 경우에는 컴포지팅 소프트웨어(예: Nuke)를 사용하게 할 수 있습니다.소프트웨어 패키지뿐 아니라 동일한 툴킷 앱에 대한 설정도 아티스트별로 다르게 지정할 수 있습니다. 예를 들어 샷 아티스트와 에셋 아티스트 둘 다 Workfiles 앱을 사용할 수 있지만 샷 아티스트는 샷 엔티티, 에셋 아티스트는 에셋 엔티티와 관련된 파일로만 파일 탐색을 제한할 수 있습니다.프로젝트 내에서 이렇게 서로 다른 워크플로우를 지원하기 위해 툴킷은 환경에서 앱과 엔진 구성을 분리합니다. 각 환경에는 소프트웨어 패키지 셋트의 통합과 설정이 모두 공통적으로 포함되어 있습니다.위의 예에서 에셋 작업 중인 아티스트는 에셋 단계 환경에서 작업하고 샷 작업 중인 아티스트는 샷 단계 환경에서 작업합니다. 각 환경은 서로 독립적으로 구성되므로 한 프로젝트 내에서 각기 다른 워크플로우를 사용할 수 있습니다.툴킷의 기본 구성에 대한 참고 사항툴킷은 환경을 구성하는 방식에 있어 매우 자유롭습니다. 이 문서에서는 사용 가능한 모든 옵션을 모두 소개하므로 파이프라인 요구 사항에 가장 적합한 선택을 하는 데 필요한 지식을 얻을 수 있습니다.또한 이 문서에서는 기본 구성이라는 시작점으로 제공되는 파이프라인 구성의 선택 사항에 대해서도 설명합니다. 파이프라인을 커스터마이즈할 준비가 된 경우 첫 번째 단계는 프로젝트에 대해 편집 가능한 파이프라인 구성을 만드는 것입니다.이러한 선택 사항은 일반적인 규칙일 뿐이고 툴킷 워크플로우에 하드코딩되지 않으므로, 기본 구성은 파이프라인을 커스터마이즈한 후 사용할 수 있는 기능을 학습하기 위한 예제로 참조하거나 고유의 구성을 설정하기 위한 모범 사례로 사용하는 것이 좋습니다. 또한 새로운 툴킷 사용자를 위한 시작점으로도 좋으며 몇 가지 규칙을 알아 두면 유용합니다. 이 문서에서는 툴킷 환경 구성의 일반적인 기능과 기본 구성에 특정한 선택 사항을 구분해 두었습니다. 기본 구성의 환경 구조에 대한 자세한 내용은 읽어보기 파일을 참조하십시오.파일 위치파이프라인 구성에서 config/ 디렉토리에는 커스터마이즈할 수 있는 모든 파일 및 폴더가 포함됩니다. config/에는 세 개의 하위 디렉토리(cache, core 및 env)가 있습니다. env 디렉토리에 환경 구성 파일이 있으므로 이 문서에서는 config/env의 파일을 참조합니다.기본 구성의 config/env/에는 다음 파일이 있습니다.asset.ymlasset_step.ymlproject.ymlsequence.ymlshot.ymlshot_step.yml이러한 각 파일이 환경에 해당하며 별도 파일을 사용하면 각 환경을 별도로 구성할 수 있습니다.툴킷이 현재 환경을 결정하는 방식툴킷은 pick_environment라는 코어 후크를 사용하여 현재 컨텍스트를 기반으로 지정된 시간에 사용할 환경 파일을 결정합니다. pick_environment 후크의 반환 값은 환경 구성 파일에 해당합니다. 예를 들어 pick_environment가 shot_step을 반환하는 경우 툴킷은 config/env/shot_step.yml을 사용하여 툴킷 환경을 구성합니다.커스텀 환경위에 나열된 환경 구성 파일은 기본 구성에서 제공하는 파일입니다. 그러나 일부 스튜디오에서는 다른 환경 또는 추가 환경을 필요로 할 수 있습니다. 예를 들어 스튜디오에서 파이프라인 단계(asset_step_rig, asset_step_model, shot_step_anim, shot_step_light 등)마다 다른 구성 설정을 사용해야 할 수 있습니다. 다행히도 사용 가능한 환경을 완전히 커스터마이즈할 수 있습니다.이렇게 하려면 원하는 환경 구성 파일을 config/env 디렉토리에 추가해야 합니다. 그런 다음 pick_environment 코어 후크를 재지정하여 새 환경을 사용할 때 정의하는 로직에 추가합니다.기본 구조툴킷의 구성 파일은 YAML로 작성됩니다. 모든 번들(앱, 엔진 또는 프레임워크)의 일반적인 구성은 다음과 같은 구조로 되어 있습니다.bundle_name:  setting1: value  setting2: value  complex_setting:    sub_setting1: value      Sub_setting2: value  location:    type: descriptor_type    descriptor_setting1: value    descriptor_setting2: value이 구조를 보여 주는 간단한 예제가 아래에 있습니다(단일 엔진이 있고 엔진 내에 단일 앱이 정의된 환경). 다음은 이 구성에서 project.yml의 내용이 될 수 있습니다.engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4엔진 블록모든 환경 구성 파일은 engines 블록으로 시작합니다. 해당 환경에 대해 정의된 모든 엔진이 이 블록 내에 중첩됩니다.이 예에서는 하나의 엔진, tk-maya만 정의되어 있습니다. 여기에는 두 개의 설정(apps 및 location)이 나열되어 있습니다.location은 모든 번들에 필요한 특수한 설정입니다. apps 설정은 엔진에 대해 정의된 모든 앱의 목록으로, 각 앱에는 자체 설정이 있습니다. 이 예에서는 엔진에 대해 하나의 앱, tk-multi-workfiles2만 정의되어 있습니다.위치 설명자모든 툴킷 번들에는 번들의 설명자라고 불리는 location 설정이 있습니다. 설명자를 통해 툴킷은 지정된 번들의 위치를 파악하고 해당 유형에 따라 직접 액세스할지 아니면 로컬로 캐시할지 여부를 파악합니다. 툴킷 번들을 가져올 수 있는 위치는 Flow Production Tracking 앱 스토어, git 리포지토리, 디스크의 경로 또는 Flow Production Tracking 사이트에 업로드된 ZIP 파일 등입니다. 이러한 각 위치에 해당하는 설명자 유형이 있으며 여기에는 해당 유형과 관련된 설정이 포함됩니다. 위 예제의 tk-maya 엔진에 대한 설명자는 다음과 같습니다.    location:        type: app_store        name: tk-maya        version: v0.9.4이 예는 app_store 유형의 설명자로, 툴킷이 Flow Production Tracking 앱 스토어에서 지정된 번들을 가져오도록 합니다. app_store 유형의 설명자에는 name 및 version 설정이 있습니다.한편, 커스텀 번들을 개발 중이고 스튜디오의 특정 워크플로우에 대한 툴킷 앱을 작성 중인 경우 디스크의 경로에서 직접 가져오고 싶을 수 있습니다. 이 경우 다음과 같이 dev 유형의 설명자를 사용합니다.    location:        type: dev        path: /path/to/appdev 설명자에는 app_store 설명자와 다른 설정이 있습니다. 다른 설정을 가져올 수 있지만 디스크에 있는 앱 위치를 가리키는 path 설정으로 간단하게 설정할 수 있습니다.사용 가능한 모든 설명자 유형 및 해당 설정에 대한 자세한 내용은 Toolkit Core API 문서의 설명자 섹션을 참조하십시오.앱 블록앱은 툴킷의 사용자 도구로, 각 앱은 서로 독립적으로 실행할 수 있습니다. 파이프라인 요구 사항에 맞게 사용할 앱을 선택할 수 있으며 엔진 블록 내의 apps 설정은 지정된 엔진에서 사용할 수 있는 앱을 정의하는 곳입니다.위 예제에서 apps 설정은 다음과 같습니다.engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8단일 앱인 tk-multi-workfiles2 앱이 정의되어 있는 것을 확인할 수 있습니다. 현재는 하나의 설정(설명자)만 정의되어 있습니다.project 환경의 tk-maya 엔진에서 다른 앱을 사용할 수 있도록 하려면 여기에 추가합니다. 엔진에 패널 tk-multi-shotgunpanel 및 앱 정보 tk-multi-about을 추가해 보겠습니다. project.yml 예제 파일은 이제 다음과 같이 표시됩니다.engines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4이때 다음과 같은 몇 가지 중요 사항에 유의해야 합니다.  기본 구성에는 번들이 알파벳순으로 나열되며 이 예에서는 해당 규칙을 따릅니다.  파일이 길어지기 시작하고 있지만 아직 어떤 구성 설정도 추가하지 않은 상태입니다.  다른 엔진 및 다른 환경에서도 이와 동일한 앱을 사용할 수 있습니다. 예를 들어 다른 엔진(예: Houdini, Nuke 또는 Photoshop) 및 다른 환경(예: asset_step 또는 shot_step)에도 이 세 개의 앱(Panel 앱, About 앱, Workfiles 앱)이 모두 있을 수 있습니다. 구성에서 여러 곳에 공통 앱 설정을 정의하면 변경 시에도 여러 곳에서 수정해야 합니다.마지막 두 가지 문제점을 해결하기 위해 툴킷 구성은 includes를 지원합니다.Includesincludes는 구성에서 한 파일의 섹션을 다른 파일에서 참조할 수 있게 해 줍니다. includes를 사용하면 한 곳에서 구성 설정을 설정한 후 여러 환경에서 사용할 수 있습니다.includes는 두 부분으로 구성됩니다.  includes 목록: 키가 includes인 YAML 사전이며 값은 포함할 모든 파일의 목록입니다.  구성 설정 내의 참조: 앞에 @ 기호가 붙고, 포함된 파일에서 참조할 섹션의 이름을 가리키도록 명명됩니다.위의 예제를 구체화하기 위해 모든 엔진에 대한 위치 설명자가 있는 단일 파일이 있다고 가정합니다. 이 파일을 includes 하위 폴더에 넣고 engine_locations.yml로 지정하겠습니다.engine_locations.yml의 내용은 다음과 같습니다.config/env/includes/engine_locations.yml:engines.tk-maya.location:  type: app_store  name: tk-maya  version: v0.9.4engines.tk-nuke.location:  type: app_store  name: tk-nuke  version: v0.11.5...이 파일은 모든 엔진 위치에 대한 단일 소스 역할을 하며 모든 환경 구성에서 참조할 수 있습니다. 이 포함 파일을 사용할 경우 예제는 이제 다음과 같이 표시됩니다.config/env/project.yml:includes:- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location: @engines.tk-maya.locationtk-maya 엔진에 대한 location 설정 값이 이제 포함된 YAML 파일의 키에 대한 참조임을 확인할 수 있습니다.                    참고: 이 예제에서와 같이 config/env/includes/engine_locations.yml 파일에 모든 엔진 위치가 있는 기본 구성의 규칙을 따릅니다.    앱 위치에 대한 두 번째 포함 파일을 추가할 수 있으며 사실 기본 구성은 이 작업을 수행합니다. 예제를 확장해 보겠습니다.config/env/includes/app_locations.yml:apps.tk-multi-about.location:  type: app_store  name: tk-multi-about  version: v0.2.8apps.tk-multi-shotgunpanel.location:  type: app_store  name: tk-multi-shotgunpanel  version: v1.6.3apps.tk-multi-workfiles2.location:  type: app_store  name: tk-multi-workfiles2  version: v0.11.8config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.location이제 포함된 engine_locations.yml 파일에서 tk-maya 엔진의 설명자를 가져오고 포함된 app_locations.yml 파일에서 tk-maya 엔진에 대해 정의된 각 앱의 설명자를 가져옵니다.                    참고: 기본 구성은 여기에 설명되지 않은 두 번째 중첩 수준을 사용합니다. 설명자 외에도 설정이 있는 모든 앱 또는 엔진에 includes/settings의 설정 파일(예: includes/settings/tk-maya.yml, includes/settings/tk-multi-workfiles2.yml)이 있습니다. 엔진 설정 파일에는 앱 설정 파일의 앱 설정이 포함되고 환경 구성 파일에는 엔진 설정 파일의 설정이 포함됩니다. 기본 구성의 구조에 대한 자세한 내용은 읽어보기 파일을 참조하십시오. 구성 설정 수정에 대한 자세한 내용은 툴킷 기본 사항 안내서의 파이프라인 구성 편집을 참조하십시오.    스파스 구성모든 툴킷 번들에는 각 기본값이 포함된 일련의 구성 설정이 있습니다. 툴킷은 스파스 구성을 허용하므로 환경 구성 파일(및/또는 포함 파일)에 구성 설정이 명시적으로 지정되지 않은 경우에는 번들의 기본값이 사용됩니다.이 예에서는 location을 제외하고 앱에 대한 어떤 설정도 지정하지 않았습니다. 따라서 구성의 현재 상태에서 세 개의 앱은 모든 설정에 대해 기본값을 사용합니다. 그렇다면 어떤 구성 설정을 사용할 수 있는지 어떻게 알 수 있을까요?                    참고: 툴킷 구성이 스파스일 필요는 없지만 기본 구성은 스파스 구성입니다.    사용 가능한 구성 설정 확인스파스 구성의 경우 단순히 구성 파일을 보는 것만으로는 앱에 대해 사용할 수 있는 구성 설정을 바로 확인할 수 없습니다. 사용 가능한 앱 구성 설정을 확인하려면 두 가지 방법이 있습니다.  앱 설명서: 각 앱에는 고유의 설명서 페이지가 있으며 이 각 페이지마다 “구성 옵션” 섹션이 있습니다. 이 섹션에는 각각의 설명 및 기본값을 포함하여 사용 가능한 모든 앱 구성 설정이 나와 있습니다. 예를 들어 Workfiles 설명서 페이지를 참조할 수 있습니다. 앱 및 엔진 페이지에는 모든 앱 및 엔진에 대한 문서 페이지가 나열되어 있습니다.  매니페스트: 모든 툴킷 번들에는 루트 디렉토리에 info.yml  파일이 포함되어 있습니다. 이 파일을 번들의 매니페스트라고 하며 각각의 설명 및 기본값을 포함하여 번들에 대해 사용 가능한 모든 구성 설정을 정의합니다. 매니페스트는 번들의 자체 캐시(예: 파이프라인 구성 내의 install/app_store/tk-multi-workfiles2/v0.11.8/info.yml) 또는 GitHub(Workfiles용)에서 찾을 수 있습니다.구성 설정 수정기본값에서 구성을 수정하려면 파이프라인의 구성에서 적절한 환경의 적절한 블록에 추가하고 값을 설정하면 됩니다.예제로 돌아가 프로젝트 환경에서 Maya를 시작할 때 tk-multi-workfiles2가 자동으로 시작되도록 구성한다고 가정해 보겠습니다. 앱의 매니페스트에서 응용프로그램 시작 시 Workfiles UI 시작 여부를 제어하는 launch_at_startup 설정이 있고 기본값은 False임을 확인할 수 있습니다. 따라서 launch_at_startup 옵션을 추가하고 해당 옵션을 True로 설정합니다. project.yml 파일은 이제 다음과 같이 표시됩니다.config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        launch_at_startup: True        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.locationtk-multi-workfiles2에 대한 설정을 포함 파일에서 가져온 경우 해당 파일에서 설정을 변경해야 합니다.추가 리소스  툴킷 기본 사항 안내서: 파이프라인 구성 편집  툴킷 기본 사항 안내서: 앱 추가  애니메이션 파이프라인 튜토리얼  설명자 참조 설명서  웨비나: 툴킷 관리  파일 시스템 구성 참조  기본 구성 환경 구조 읽어보기",
    "url": "/487a9f2c/",
    "relUrl": "/487a9f2c/"
  },
  "45": {
    "id": "45",
    "title": "프로토콜을 위반하여 EOF 발생",
    "content": "SSLError: [Errno 8] _ssl.c:504: 프로토콜을 위반하여 EOF 발생활용 사례데스크톱에서 Nuke 10.5를 열면 다음과 같은 SSL 오류가 표시됩니다.[13:57.14] ERROR: Shotgun Error: [ERROR tk-nuke] App /media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2 failed to initialize. It will not be loaded.Traceback (most recent call last):File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank/platform/engine.py”, line 2792, in __load_appsapp.init_app()File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/app.py”, line 26, in init_appself._tk_multi_workfiles = self.import_module(“tk_multi_workfiles”)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank/platform/bundle.py”, line 462, in import_moduleself.__module_uid, None, python_folder, (&quot;&quot;, “”, imp.PKG_DIRECTORY)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/init.py”, line 11, infrom . import tk_multi_workfilesFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/init.py”, line 14, infrom .file_open_form import FileOpenFormFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/file_open_form.py”, line 19, infrom .actions.file_action_factory import FileActionFactoryFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/actions/file_action_factory.py”, line 19, infrom .interactive_open_action import InteractiveOpenActionFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/actions/interactive_open_action.py”, line 17, infrom .open_file_action import OpenFileActionFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/actions/open_file_action.py”, line 22, infrom …work_area import WorkAreaFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/work_area.py”, line 19, infrom .user_cache import g_user_cacheFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/user_cache.py”, line 203, ing_user_cache = UserCache()File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/user_cache.py”, line 32, in initself._current_user = sgtk.util.get_current_user(self._app.sgtk)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank/util/login.py”, line 125, in get_current_user“HumanUser”, filters=[[“login”, “is”, current_login]], fields=fieldsFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 882, in find_oneadditional_filter_presets=additional_filter_presets)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 1003, in findadditional_filter_presets)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 1072, in _construct_read_parametersparams[“paging”] = {“entities_per_page”: self.config.records_per_page,File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 471, in records_per_pageself._records_per_page = self._sg.server_info.get(“api_max_entities_per_page”) or 500File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 763, in server_inforeturn self.server_caps.server_infoFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 778, in server_capsself._server_caps = ServerCapabilities(self.config.server, self.info())File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 833, in inforeturn self._call_rpc(“info”, None, include_auth_params=False)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank/authentication/shotgun_wrapper.py”, line 63, in _call_rpcreturn super(ShotgunWrapper, self)._call_rpc(*args, **kwargs)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 3302, in _call_rpcencoded_payload, req_headers)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 3442, in _make_callreturn self._http_request(verb, path, body, req_headers)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 3496, in _http_requestresp, content = conn.request(url, method=verb, body=body, headers=headers)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 2192, in requestcachekey,File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 1845, in _requestconn, request_uri, method, body, headersFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 1750, in _conn_requestconn.connect()File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 1399, in connectself.key_password,File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 109, in _ssl_wrap_socketssl_version=ssl_version,File “/usr/local/Nuke10.5v7/lib/python2.7/ssl.py”, line 381, in wrap_socketciphers=ciphers)File “/usr/local/Nuke10.5v7/lib/python2.7/ssl.py”, line 143, in initself.do_handshake()File “/usr/local/Nuke10.5v7/lib/python2.7/ssl.py”, line 305, in do_handshakeself._sslobj.do_handshake()SSLError: [Errno 8] _ssl.c:504: EOF occurred in violation of protocolNuke 버전 11 또는 12에서는 이러한 문제가 발생하지 않습니다.해결 방법Nuke 10.x는 TLS 1.2와 호환되지 않기 때문에 발생하는 문제입니다. 소프트웨어는 TLS를 준수해야 합니다.관련 링크커뮤니티에서 전체 스레드 참조",
    "url": "/4947c1f4/",
    "relUrl": "/4947c1f4/"
  },
  "46": {
    "id": "46",
    "title": "Nuke Studio의 에피소드 워크플로우",
    "content": "Nuke Studio의 에피소드 워크플로우소개 및 준비 작업이 문서에서는 Nuke Studio 또는 Hiero에서 tk-hiero-export 앱으로 에피소드 워크플로우를 시작하고 실행하는 방법에 대해 설명합니다. 명확하게 정해진 방법은 없으며 원하는 워크플로우에 따라 접근 방식이 약간 다를 수 있습니다. 이 예제에서는 다음과 같이 가정합니다.  목표는 Episode &amp;gt; Sequence &amp;gt; Shot의 3계층을 설정하는 것입니다.  파일 시스템 구성 안내서의 단계를 읽고 완료해야 합니다.  CustomEntity02가 아닌 Episode 엔티티 유형을 사용합니다(둘 다 이름만 다를 뿐 동일한 방식으로 작업할 수 있음).  Sequence 엔티티에는 episode라는 엔티티 필드가 있습니다.  Hiero의 경우에도 프로세스는 동일하지만 Nuke Studio를 사용합니다.  툴킷 프로젝트에 대한 기본 구성부터 시작합니다.시작하기 전에 Episode를 확인하는 방법도 결정해야 합니다. 기본 제공 Flow Production Tracking Hiero/Nuke Studio 내보내기 프로세스에서는 Nuke Studio 프로젝트의 컨텐츠에 기반하여 Flow Production Tracking 사이트에 Sequence 및 Shot 엔티티를 생성합니다. 따라서 툴킷을 사용하여 Maya에서 작업할 때는 에셋 및 태스크를 미리 만드는 것이 좋지만 이와 달리 Nuke Studio에서는 Episodes Sequences 또는 Shots을 미리 만들 필요가 없습니다. 즉, Nuke Studio에서 Episode를 정의하는 방법을 결정해야 합니다. 가능한 옵션은 다음과 같습니다.  먼저 Flow Production Tracking에서 에피소드를 만들고 에피소드 컨텍스트에서 작동하도록 Nuke Studio 툴킷 통합을 구성하면 내보낼 때 현재 씬 컨텍스트에서 Episode 엔티티를 가져올 수 있습니다.  Episode 엔티티가 아직 생성되지 않았다고 가정하고 Nuke Studio의 태그 지정 기능을 활용하여 에피소드 이름으로 시퀀스에 태그를 지정하고 이를 사용하여 내보낼 때 Episode를 확인합니다.Nuke Studio 시퀀스 또는 샷 이름의 일부에서 에피소드 이름을 추출(예: “ep1_s01” 시퀀스의 “ep1” 비트 사용)하는 등 워크플로우에 더 적합한 다른 방법이 있을 수 있습니다. 또는 내보내기 앱의 hiero_customize_export_ui.py 후크를 사용하여 에피소드와 내보내기를 링크할 GUI를 추가할 수 있습니다.이 예에서는 두 번째 옵션인 시퀀스 태그 지정 솔루션을 사용합니다.이 연습은 3개의 계층 레이어(Episode &amp;gt; Sequence &amp;gt; Shot)를 구현하기 위한 것입니다. 간단하게 Sequence 엔티티 유형을 Episodes 엔티티 유형으로 대체하는 프로세스(Episode &amp;gt; Shot)는 더 쉽습니다. 이 시나리오는 이 안내서의 마지막 부분에서 간단하게 다룹니다. 나머지 부분을 살펴보면 보다 잘 이해할 수 있습니다.스키마 및 템플릿앞서 설명한 바와 같이, 이 예에서는 스키마 및 템플릿을 업데이트했다고 가정합니다. 또한 올바른 부분에 에피소드 키를 포함하도록 templates.yml의 hiero_plate_path 및 hiero_render_path 경로 값도 업데이트해야 합니다.후크 및 설정Flow Production Tracking 내보내기 프로세스를 가져와 Episode를 올바르게 처리하려면 내보내기 후크의 일부를 수정해야 합니다. 이 문서에서는 후크가 무엇이고 기본 구현을 재정의하는 방법을 잘 알고 있다고 가정합니다.다음은 에피소드를 활성화하는 데 도움이 되는 두 개의 내보내기 후크입니다.  hiero_get_shot.py  hiero_resolve_custom_strings.py참고: hiero_translate_template.py라는 세 번째 후크가 있지만 이 예에서는 사용하지 않습니다. 이 후크는 시퀀스를 에피소드로 대체하고 두 개의 레이어 계층을 유지하려는 경우에만 필요합니다. 여기에 대해서는 문서 마지막에 좀 더 다룹니다.에피소드를 찾을 수 있도록 hiero_get_shot.py를 수정하고 Flow Production Tracking에서 이에 대한 엔티티를 만듭니다. 그리고 Nuke Studio가 경로에서 {Episode} 키에 제공할 값을 알 수 있도록 hiero_resolve_custom_strings.py를 수정합니다. 다음은 자세한 단계입니다.1. 에피소드 필드 추가이제 Episode라는 템플릿에 새 키가 있고 이를 확인하는 방법을 tk-hiero-export 앱에 지정해야 합니다. &amp;lt;pipeline_configuration&amp;gt;/config/env/includes/settings/tk-hiero-export.yml 파일에서 custom_template_fields를 다음과 같이 수정합니다. settings.tk-hiero-export:      custom_template_fields: [{keyword: Episode, description: The episode name}]   ... 그러면 {Episode}라는 유효한 내보내기 토큰이 Hiero 내보내기에 추가됩니다.2. hiero_get_shot 후크이제 hiero_get_shot.py 후크를 사용하여 내보내기 프로세스에서 에피소드 이름을 찾고 Flow Production Tracking에서 Episode를 만드는 방법을 지정해야 합니다.후크의 기본 버전(hiero_get_shot.py)은 TrackItem과 이름이 같은 Flow Production Tracking의 Shot을 반환합니다. Shot은 Nuke Studio 시퀀스 항목과 이름이 같은 Sequence에 링크되어야 합니다. Sequence 또는 Shot이 Flow Production Tracking에 없으면 후크가 이를 만듭니다. 다른 계층 수준을 추가하고 있으므로 Episode가 없는 경우 이 또한 후크가 만들도록 해야 합니다.Sequence는 Episode에 링크되므로 Sequence를 조회하는 코드에 연결해야 합니다(get_shot_parent() 메서드).구성의 후크 폴더에 hiero_get_shot.py 파일을 만들고 hook_get_shot: '{config}/hiero_get_shot.py'를 tk-hiero-export.yml 설정에 다음과 같이 추가합니다. settings.tk-hiero-export:      custom_template_fields: [{keyword: Episode, description: The episode name}]      hook_get_shot: '{config}/hiero_get_shot.py' 다음은 hiero_get_shot.py 후크에 대한 전체 코드입니다. 이를 사용자가 만든 후크에 추가합니다.from sgtk import Hookclass HieroGetShot(Hook):    &quot;&quot;&quot;    Return a  Flow Production Tracking  Shot dictionary for the given Hiero items    &quot;&quot;&quot;    def execute(self, task, item, data, **kwargs):        &quot;&quot;&quot;        Takes a hiero.core.TrackItem as input and returns a data dictionary for        the shot to update the cut info for.        &quot;&quot;&quot;       # get the parent entity for the Shot       parent = self.get_shot_parent(item.parentSequence(), data, item=item)       # shot parent field       parent_field = &quot;sg_sequence&quot;       # grab shot from  Flow Production Tracking        sg = self.parent.shotgun       filter = [           [&quot;project&quot;, &quot;is&quot;, self.parent.context.project],           [parent_field, &quot;is&quot;, parent],           [&quot;code&quot;, &quot;is&quot;, item.name()],        ]       # default the return fields to None to use the python-api default       fields = kwargs.get(&quot;fields&quot;, None)       shots = sg.find(&quot;Shot&quot;, filter, fields=fields)       if len(shots) &amp;gt; 1:           # can not handle multiple shots with the same name           raise StandardError(&quot;Multiple shots named '%s' found&quot;, item.name())       if len(shots) == 0:           # create shot in            shot_data = {               &quot;code&quot;: item.name(),               parent_field: parent,               &quot;project&quot;: self.parent.context.project,           }           shot = sg.create(&quot;Shot&quot;, shot_data, return_fields=fields)           self.parent.log_info(&quot;Created Shot in  Flow Production Tracking : %s&quot; % shot_data)       else:           shot = shots[0]       # update the thumbnail for the shot       upload_thumbnail = kwargs.get(&quot;upload_thumbnail&quot;, True)       if upload_thumbnail:           self.parent.execute_hook(               &quot;hook_upload_thumbnail&quot;,               entity=shot,               source=item.source(),               item=item,               task=kwargs.get(&quot;task&quot;)           )       return shot    def get_episode(self, data=None, hiero_sequence=None):        &quot;&quot;&quot;        Return the  episode for the given Nuke Studio items.        We define this as any tag linked to the sequence that starts        with 'Ep'.        &quot;&quot;&quot;       # If we had setup Nuke Studio to work in an episode context, then we could       # grab the episode directly from the current context. However in this example we are not doing this but here       # would be the code.       # return self.parent.context.entity       # stick a lookup cache on the data object.       if &quot;epi_cache&quot; not in data:           data[&quot;epi_cache&quot;] = {}       # find episode name from the tags on the sequence       nuke_studio_episode = None       for t in hiero_sequence.tags():           if t.name().startswith('Ep'):               nuke_studio_episode = t               break       if not nuke_studio_episode:           raise StandardError(&quot;No episode has been assigned to the sequence: %s&quot; % hiero_sequence.name())       # For performance reasons, lets check if we've already added the episode to the cache and reuse it       # Its not a necessary step, but it speeds things up if we don't have to check  for the episode again       # this session.       if nuke_studio_episode.guid() in data[&quot;epi_cache&quot;]:           return data[&quot;epi_cache&quot;][nuke_studio_episode.guid()]       # episode not found in cache, grab it from  Flow Production Tracking        sg = self.parent.shotgun       filters = [           [&quot;project&quot;, &quot;is&quot;, self.parent.context.project],           [&quot;code&quot;, &quot;is&quot;, nuke_studio_episode.name()],       ]       episodes = sg.find(&quot;Episode&quot;, filters, [&quot;code&quot;])       if len(episodes) &amp;gt; 1:           # can not handle multiple episodes with the same name           raise StandardError(&quot;Multiple episodes named '%s' found&quot; % nuke_studio_episode.name())       if len(episodes) == 0:           # no episode has previously been created with this name           # so we must create it in            epi_data = {               &quot;code&quot;: nuke_studio_episode.name(),               &quot;project&quot;: self.parent.context.project,           }           episode = sg.create(&quot;Episode&quot;, epi_data)           self.parent.log_info(&quot;Created Episode in  Flow Production Tracking : %s&quot; % epi_data)       else:           # we found one episode matching this name in , so we will resuse it, instead of creating a new one           episode = episodes[0]       # update the cache with the results       data[&quot;epi_cache&quot;][nuke_studio_episode.guid()] = episode       return episode    def get_shot_parent(self, hiero_sequence, data, **kwargs):        &quot;&quot;&quot;        Given a Hiero sequence and data cache, return the corresponding entity        in  Flow Production Tracking  to serve as the parent for contained Shots.        :param hiero_sequence: A Hiero sequence object        :param data: A dictionary with cached parent data.        .. note:: The data dict is typically the app's `preprocess_data` which maintains the cache across invocations of this hook.                        &quot;&quot;&quot;         # stick a lookup cache on the data object.         if &quot;parent_cache&quot; not in data:             data[&quot;parent_cache&quot;] = {}                 if hiero_sequence.guid() in data[&quot;parent_cache&quot;]:             return data[&quot;parent_cache&quot;][hiero_sequence.guid()]                 episode = self.get_episode(data, hiero_sequence)                 # parent not found in cache, grab it from  Flow Production Tracking                  sg = self.parent.shotgun filter = [             [&quot;project&quot;, &quot;is&quot;, self.parent.context.project],             [&quot;code&quot;, &quot;is&quot;, hiero_sequence.name()],             [&quot;episode&quot;, &quot;is&quot;, episode],             ]                 # the entity type of the parent.         par_entity_type = &quot;Sequence&quot;                 parents = sg.find(par_entity_type, filter)         if len(parents) &amp;gt; 1:             # can not handle multiple parents with the same name             raise StandardError(                 &quot;Multiple %s entities named '%s' found&quot; % (par_entity_type, hiero_sequence.name())                 )                     if len(parents) == 0:             # create the parent in              par_data = {                 &quot;code&quot;: hiero_sequence.name(),                 &quot;project&quot;: self.parent.context.project,                 &quot;episode&quot;: episode,                 }                         parent = sg.create(par_entity_type, par_data)             self.parent.log_info(                 &quot;Created %s in  Flow Production Tracking : %s&quot; % (par_entity_type, par_data)                )        else:             parent = parents[0]                         # update the thumbnail for the parent         upload_thumbnail = kwargs.get(&quot;upload_thumbnail&quot;, True)                 if upload_thumbnail:             self.parent.execute_hook(                 &quot;hook_upload_thumbnail&quot;, entity=parent, source=hiero_sequence, item=None             )                     # cache the results         data[&quot;parent_cache&quot;][hiero_sequence.guid()] = parent         return parent 시퀀스 가져오기위 코드를 사용하여 get_shot_parent() 메서드를 수정했습니다. 이제 Sequence를 찾거나 만들 때 새 get_episode() 방식에서 반환된 Episode를 사용합니다. Flow Production Tracking 데이터베이스의 기존 Sequence를 확인할 때 이제 episode&amp;lt;/code&amp;lt; field로 필터링되고 Sequence를 만들 때 시퀀스의 episode 필드가 get_episode()에서 반환된 Episode로 채워집니다.에피소드 가져오기그렇다면 에피소드는 어떻게 가져올까요? get_episode() 방식 코드는 get_shot_parent() 방식과 매우 유사하지만 Sequence 대신 Episode를 검색하도록 수정되었습니다.이 안내서에서는 태그를 사용하여 Nuke Studio에서 에피소드를 할당합니다. 예를 들어 Nuke Studio에서 “Ep01”이라는 태그를 만들 수 있습니다. 그런 다음 이 태그를 Nuke Studio의 시퀀스에 적용합니다.상위 수준에서 get_episode() 방식은 Nuke Studio의 시퀀스 항목에 적용된 모든 태그를 확인하여 “Ep”로 시작하는 태그가 있으면 에피소드 이름을 정의하는 태그로 가정합니다. 그런 다음 이 메서드는 Flow Production Tracking에서 일치하는 Episode를 찾아서 반환하고 아직 없는 경우에는 만듭니다. 또한 찾기 호출을 다시 수행할 필요가 없도록 이 정보를 캐시합니다.다른 방식으로 에피소드를 가져오려면, 예를 들어 컨텍스트에서 또는 시퀀스나 샷 이름의 첫 번째 섹션을 사용하여 가져오려면 이 방식의 해당 로직을 사용합니다.샷 가져오기hiero_get_shot 후크의 주 목적은 Flow Production Tracking에서 샷 데이터를 반환하는 것입니다. Sequence가 해당 상위를 가져오는 방법만 수정해야 하므로 실제로 샷을 가져오는 로직을 수정할 필요는 없습니다. 또한 커스텀 필드를 통해 Shot을 Episode와 링크하려면 실행 방식의 코드도 수정해야 합니다. parent[“episode”]와 같이 Sequence에서 Episode에 액세스한 다음 이를 만들기 호출의 샷에 링크합니다.3. Hiero_resolve_custom_strings.py인계받아야 할 두 번째 후크는 hiero_resolve_custom_strings.py입니다. 이를 통해 Nuke Studio 내보내기의 경로를 확인할 수 있습니다. 다시 한 번 후크 폴더에 후크를 만들고 hook_resolve_custom_strings: {config}/hiero_resolve_custom_strings.py 설정을 tk-hiero-export.yml 파일에 추가해야 합니다.1단계에서 추가한 커스텀 키 {Episode}가 이 후크로 전달되고 내보내기 앱에서는 확인된 폴더 이름이 반환될 것으로 예상합니다. 후크는 전달된 키가 {Episode}인지 확인해야 합니다. 맞을 경우 hiero_get_shot.py 후크에서 get_episode() 방식을 재사용하여 Episode 엔티티를 가져옵니다. Episode가 있으면 코드는 에피소드 이름을 추출하여 폴더를 생성할 수 있습니다.후크의 전체 코드는 다음과 같습니다.from sgtk import Hookclass HieroResolveCustomStrings(Hook):    &quot;&quot;&quot;Translates a keyword string into its resolved value for a given task.&quot;&quot;&quot;    # cache of shots that have already been pulled from     _sg_lookup_cache = {}    def execute(self, task, keyword, **kwargs):        &quot;&quot;&quot;        The default implementation of the custom resolver simply looks up        the keyword from the  shot dictionary.        For example, to pull the shot code, you would simply specify 'code'.        To pull the sequence code you would use 'sg_sequence.Sequence.code'.        &quot;&quot;&quot;        if keyword == &quot;{Episode}&quot;:            episode_entity = self.parent.execute_hook_method(                &quot;hook_get_shot&quot;,                &quot;get_episode&quot;,                data=self.parent.preprocess_data,                hiero_sequence=task._item.parentSequence(),            )            # hard coded to return the name of the episode            # if however your folder for the episode in the schema, is not just made up from the code field            # you need to get it to return what ever string value the folder would normally be created with.            return episode_entity['code']        shot_code = task._item.name()        # grab the shot from the cache, or the get_shot hook if not cached        sg_shot = self._sg_lookup_cache.get(shot_code)        if sg_shot is None:            fields = [ctf['keyword'] for ctf in self.parent.get_setting('custom_template_fields')]            sg_shot = self.parent.execute_hook(                &quot;hook_get_shot&quot;,                task=task,                item=task._item,                data=self.parent.preprocess_data,                fields=fields,                upload_thumbnail=False,            )            self._sg_lookup_cache[shot_code] = sg_shot        self.parent.log_info(&quot;_sg_lookup_cache: %s&quot; % (self._sg_lookup_cache))        if sg_shot is None:            raise RuntimeError(&quot;Could not find shot for custom resolver: %s&quot; % keyword)        # strip off the leading and trailing curly brackets        keyword = keyword[1:-1]        result = sg_shot.get(keyword, &quot;&quot;)        self.parent.log_debug(&quot;Custom resolver: %s[%s] -&amp;gt; %s&quot; % (shot_code, keyword, result))        return result 스키마 에피소드 폴더 이름이 code 필드가 아닌 다른 필드에서 생성되는 경우에는 해당 이름을 여기에 복제해야 합니다.좀 더 복잡하지만 보다 정확한 해결 방법은 templates.yml에 episode_root 템플릿을 추가한 다음 템플릿에서 필드를 가져오는 것입니다. 이렇게 하면 스키마에서 에피소드 폴더 이름을 변경해도 반환되는 폴더 이름은 항상 스키마와 일치합니다. 다음과 같습니다.ctx = tk.context_from_entity(&quot;Episode&quot;, episode_entity[id])my_template = tk.templates[&quot;episode_root&quot;]fields = my_template.get_fields(ctx.filesystem_locations[0])return fields[&quot;Episode&quot;] 마무리이제 마무리 단계입니다. 변경 사항이 제대로 작동하는지만 테스트하면 됩니다.Nuke Studio를 시작하고 프로젝트를 만들어 시퀀스와 footage로 채우면 이제 내보내기 프로세스를 테스트할 수 있습니다. 먼저 에피소드 태그를 만듭니다. Ep로 시작하는 시퀀스에 대한 태그를 찾도록 후크를 코딩했으므로 태그 이름을 Ep…로 지정해야 합니다.이제 시퀀스에 태그를 추가합니다. 완료되면 태그가 지정된 시퀀스에서 샷을 내보냅니다.구조 내보내기 계층이 스키마의 계층과 일치하는지 확인합니다. 일치하지 않을 경우 구조를 새로 고쳐야 할 수 있습니다.내보내기(Export)를 클릭하면 Flow Production Tracking 사이트에 에피소드, 시퀀스 및 샷이 만들어질 뿐만 아니라 디스크에 폴더 구조가 만들어집니다. 문제가 발생할 경우 발생할 수 있는 모든 오류에 대해 Nuke Studio 스크립트 편집기 또는 Flow Production Tracking 로그(tk-nukestudio.log)를 확인합니다.이로써 안내서가 완료되었습니다. 물론 이는 에피소드 작업을 수행하는 많은 방법 중 하나일 뿐이며 스튜디오에 가장 적합한 접근 방법 및 구조를 사용하면 됩니다.시퀀스를 에피소드와 교체위에서 간단하게 언급한 대로 기본 시퀀스/샷 계층을 에피소드/샷과 교체하려면 Nuke Studio 시퀀스 항목을 에피소드 이름의 소스로 사용할 수 있습니다.      에피소드/샷 구조를 사용하여 작업하도록 스키마 및 템플릿을 설정합니다.        위에 표시된 대로 기본 hiero_get_shot.py 후크를 인계받습니다. 그러나 이번에는 parent_field 변수 값을 sg_episode로 변경하고(샷 엔티티에 에피소드 필드가 있어야 함) par_entity_type variable value to Episode로 변경합니다.        hiero_translate_template.py 후크를 인계받고 후크 파일에서 매핑을 변경합니다.   mapping = {   &quot;{Episode}&quot;: &quot;{sequence}&quot;,   &quot;{Shot}&quot;: &quot;{shot}&quot;,   &quot;{name}&quot;: &quot;{clip}&quot;,   &quot;{version}&quot;: &quot;{tk_version}&quot;,} 에피소드 키는 Nuke Studio 시퀀스 키 값으로 확인됩니다.  팁:  이러한 변경을 수행하기 전에 Hiero/Nuke Studio 프로젝트를 열었거나, 변경하는 동안 테스트하려는 경우에는 내보내기 경로를 재설정해야 할 수 있습니다. 내보내기 대화상자를 열면 Nuke Studio가 내보내기 트리를 캐시하므로 변경 사항을 스키마로 다시 로드하려면 새로 고침 버튼을 눌러 다시 빌드해야 합니다.",
    "url": "/459f67b7/",
    "relUrl": "/459f67b7/"
  },
  "47": {
    "id": "47",
    "title": "작업 영역 변경 실패 - MEL 스크립트를 실행하는 동안 오류 발생",
    "content": "작업 영역 변경 실패 - MEL 스크립트를 실행하는 동안 오류 발생활용 사례네트워크에 대한 액세스 권한이 없는 프리랜서를 위해 새 특수 파이프라인 구성을 만들 때 새 루트 이름을 만들고 다른 경로를 지정했습니다. 프로덕션 파이프라인 구성에는 파일 서버를 가리키는 루트 경로가 있습니다.그러나 Maya에서 tk-multi-workfiles를 사용하여 새 파일을 만들 때 다음 오류가 발생합니다.Failed to change work area - Error during execution of MEL script: file: C:/Program files/Autodesk/Maya2019/scripts/others/setProject.mel line 332: New project location C: VetorZero work Shotgun-workflow_completo sequences Seq_001 SH_010 ANIM maya is not a valid directory, project not created.Calling Procedure: setProject, in file “C: Program Files Shotgun c” set project(“C: Vetorzero work SHOTGUN-workflow_completo sequences Seq_001 SH_010 ANIM maya”)폴더를 만들었지만 “maya” 폴더가 만들어지지 않았습니다.해결 방법“maya” 폴더가 실수로 삭제되지 않았는지 확인합니다. “maya” 폴더가 삭제된 경우 이 오류가 표시됩니다.관련 링크커뮤니티에서 전체 스레드 참조",
    "url": "/4f00a298/",
    "relUrl": "/4f00a298/"
  },
  "48": {
    "id": "48",
    "title": "API",
    "content": "APIregisterCallbacks프레임워크에 플러그인의 이벤트 처리 진입점에 대해 알리는 데 사용되는 모든 플러그인의 전역 수준 함수입니다.registerCallbacks(reg)  reg: Registrar과 상호 작용하여 프레임워크에 호출할 함수를 알립니다.RegistrarRegistrar은 프레임워크에 플러그인과 상호 작용하는 방법을 알리는 데 사용되는 객체이며 registerCallbacks 함수로 전달됩니다.속성loggergetLogger를 참조하십시오.메서드getLogger플러그인 내에서 메시지를 기록하는 데 사용되는 python Logger 객체를 가져옵니다.setEmails(*emails)이 플러그인 또는 해당 콜백 중 하나에서 잘못된 상황이 발생하는 경우 오류 및 중요한 알림을 수신해야 하는 이메일을 설정합니다.구성 파일에 지정된 기본 주소로 이메일을 보내려면(기본값)reg.setEmails(True)이메일을 비활성화하려면(오류 메시지를 받아볼 수 없게 되므로 이 방법은 권장되지 않음)reg.setEmails(False)특정 주소로 이메일을 보내려면reg.setEmails('user1@domain.com')또는reg.setEmails('user1@domain.com', 'user2@domain.com')registerCallback(sgScriptName, sgScriptKey, callback, matchEvents=None, args=None, stopOnError=True)이 플러그인에 대해 엔진에 콜백을 등록합니다.  sgScriptName: Flow Production Tracking 스크립트 페이지에서 가져온 스크립트의 이름입니다.  sgScriptKey: Flow Production Tracking 스크립트 페이지에서 가져온 스크립트의 응용프로그램 키입니다.  callback: __call__ 메서드가 있는 함수 또는 객체입니다. exampleCallback을 참조하십시오.  matchEvents: 콜백에 전달하려는 이벤트 필터입니다.  args: 프레임워크가 콜백으로 다시 전달되게 하려는 모든 객체입니다.  stopOnError: 부울이며 이 콜백의 예외가 이 플러그인의 모든 콜백에 의한 이벤트 처리를 중단해야 합니다. 기본값은 True입니다.sgScriptName은 Flow Production Tracking에 대한 플러그인을 식별하는 데 사용됩니다. 모든 이름은 여러 콜백에서 공유되거나, 단일 콜백에 대해 고유할 수 있습니다.sgScriptKey는 Flow Production Tracking에 대한 플러그인을 식별하는 데 사용되며 지정된 sgScriptName에 적합한 키여야 합니다.필터와 일치하는 이벤트를 처리해야 하는 경우 지정된 콜백 객체가 호출됩니다. 호출 가능한 모든 객체를 실행할 수 있어야 하지만 여기에 클래스를 사용하는 것은 적합하지 않습니다. 함수 또는 __call__ 메서드가 있는 인스턴스를 사용하는 것이 더 적합합니다.matchEvent 인수는 등록 중인 콜백의 관심 이벤트를 지정할 수 있는 필터입니다. matchEvents가 지정되지 않았거나 None을 지정하면 모든 이벤트가 콜백으로 전달됩니다. 그렇지 않으면 matchEvents 필터의 각 키는 이벤트 유형이고 각 값은 가능한 속성 이름 목록입니다.matchEvents = {    'Shotgun_Task_Change': ['sg_status_list'],}여러 이벤트 유형 또는 속성 이름이 있을 수 있습니다.matchEvents = {    'Shotgun_Task_Change': ['sg_status_list'],    'Shotgun_Version_Change': ['description', 'sg_status_list']}지정된 속성 이름이 있는 이벤트 유형을 필터링할 수 있습니다.matchEvents = {    '*': ['sg_status_list'],}또한 지정된 이벤트 유형의 속성 이름을 필터링할 수도 있습니다.matchEvents = {    'Shotgun_Version_Change': ['*']}다음은 유효하며 아무것도 지정하지 않는 것과 같은 기능을 하지만 실제로는 쓸모가 없습니다.matchEvents = {    '*': ['*']}“_New” 또는 “_Retirement” 등 필드용이 아닌 특정 이벤트 유형에 대해 일치시키는 경우 목록을 제공하지 않고 대신 None을 값으로 전달합니다.matchEvents = {    'Shotgun_Version_New': None}args 인수는 이벤트 프레임워크 자체에서 사용되지 않지만 수정 없이 콜백으로 다시 전달됩니다.                    참고: args 인수의 요점은 registerCallbacks 함수에서 시간이 많이 걸리는 작업을 처리할 수 있고 이벤트 처리 시 사용자에게 다시 전달할 수 있다는 것입니다.    args 인수의 또 다른 용도는 데이터를 공유하도록 여러 콜백에 대한 변경 가능한 공통 인수로 전달하는 것입니다(예: dict).stopOnError 인수는 이 콜백의 예외가 플러그인 내 모든 콜백에 대한 이벤트 처리가 중지될 수 있는지 여부를 시스템에 알려 줍니다. 기본적으로 이 값은 True이지만 False로 전환할 수 있습니다. 오류가 있는 경우 오류에 대한 메일 알림이 계속 표시되지만 이벤트 처리는 중지되지 않습니다. 콜백당 설정이므로 True인 중요한 콜백을 사용할 수 있지만 False인 다른 콜백을 사용할 수 있습니다.콜백Registrar.registerCallback에 의해 등록된 모든 플러그인 진입점은 일반적으로 다음과 같은 전역 수준 함수입니다.exampleCallback(sg, logger, event, args)  sg: Flow Production Tracking 연결 인스턴스  logger: 사용자를 위해 미리 구성된 Python logging.Logger 객체  event: 처리할 Flow Production Tracking 이벤트  args: 콜백 등록 시간에 지정된 args 인수                    참고: 콜백을 객체 인스턴스에 대한 __call__ 메서드로 구현할 수 있지만 사용자를 위한 연습으로 남겨둡니다.    ",
    "url": "/b04a53ae/",
    "relUrl": "/b04a53ae/"
  },
  "49": {
    "id": "49",
    "title": "구성",
    "content": "구성다음 안내서는 스튜디오에 대한 Flow Production TrackingEvents 구성을 지원합니다.ShotGridEvents에 대한 대부분의 구성은 shotgunEventDaemon.conf 파일에 의해 제어됩니다. 이 파일에는 요구사항에 따라 변경할 수 있는 여러 가지 설정이 있습니다. 대부분의 기본값은 대부분의 스튜디오에서 올바르게 작동하지만, 몇몇 설정은 반드시 구성해야 합니다(특히 Flow Production TrackingEventDaemon이 Flow Production Tracking 서버에 연결할 수 있도록 Flow Production Tracking 서버 URL, 스크립트 이름, 응용 프로그램 키 등).                    참고: Windows: Windows 사용자는 Windows에서 해당하는 구성 파일의 모든 경로를 변경해야 합니다. 로깅을 포함한 모든 경로를 단일 위치로 유지해 단순하게 관리하는 것이 좋습니다. 이 문서에서는 Windows 경로를 설명할 때 C: shotgun shotgunEvents를 주로 사용합니다.    Edit shotgunEventDaemon.confShotGridEvents를 설치했다면 다음 단계는 텍스트 편집기에서 shotgunEventDaemon.conf 파일을 열고 스튜디오의 요구사항에 맞게 설정을 수정하는 것입니다. 대부분의 스튜디오에는 기본값이 적합하지만, 데몬을 실행하기 위해서 반드시 제공해야 할 기본값이 없는 설정도 일부 있습니다.반드시 제공해야 하는 항목은 다음과 같습니다.  Flow Production Tracking 서버 URL  Flow Production Tracking에 연결하기 위한 스크립트 이름 및 응용프로그램 키  실행할 Flow Production TrackingEventDaemon 플러그인에 대한 전체 경로선택적으로, SMTP 서버 및 이메일 관련 설정을 지정하여 오류 이메일 알림을 설정할 수도 있습니다. 이 작업은 선택 사항이지만 이 값을 설정하도록 선택하면 이메일 섹션의 모든 구성 값을 입력해야 합니다.데몬에서 성능 문제가 발생한 경우 문제 해결에 도움이 될 수 있는 선택적 타이밍 로그에 대한 섹션도 있습니다. 타이밍 로깅을 활성화하면 자체 개별 로그 파일에 타이밍 정보가 입력됩니다.Flow Production Tracking 설정[ShotGrid] 섹션 아래에서 기본 토큰을 server, name 및 key에 대한 올바른 값으로 변경합니다. 이러한 값은 Flow Production Tracking에 연결하는 표준 API 스크립트에 제공한 값과 같아야 합니다.예server: https://awesome.shotgunstudio.comname: Flow Production TrackingEventDaemonkey: e37d855e4824216573472846e0cb3e49c7f6f7b1플러그인 설정실행할 플러그인을 찾을 위치를 Flow Production TrackingEventDaemon에 알려야 합니다. [plugins] 섹션 아래에서 기본 토큰을 paths에 대한 올바른 값으로 변경합니다.여러 위치를 지정할 수 있습니다(데몬을 사용하는 부서나 리포지토리가 여러 개인 경우 유용할 수 있음). 이 값은 읽을 수 있는 기존 디렉토리에 대한 전체 경로여야 합니다.예paths: /usr/local/shotgun/ShotGridEvents/plugins처음 시작할 때 테스트하기에 적절한 플러그인은 logArgs.py 디렉토리에 있는 /usr/local/shotgun/ShotGridEvents/src/examplePlugins 플러그인입니다. 이를 지정한 플러그인 폴더로 복사하고 이 폴더를 사용하여 테스트를 진행합니다.shotgunEventDaemon.conf의 위치기본적으로 데몬은 Flow Production TrackingEventDaemon.py가 있는 디렉토리와 /etc 디렉토리에서 shotgunEventDaemon.conf 파일을 찾습니다. conf 파일을 다른 디렉토리에 저장해야 하는 경우 현재 디렉토리에서 해당 위치에 대한 심볼릭 링크를 생성하는 것이 좋습니다.                    참고: 위 방법이 효과가 없는 경우 config 파일의 검색 경로는 shotgunEventDaemon.py 스크립트 하단의 _getConfigPath() 함수에 위치합니다.                        참고: Windows의 경우 Windows에 /etc가 존재하지 않으므로 구성 파일은 Python 파일과 동일한 디렉터리에 있어야 합니다.    데몬 테스트데몬은 백그라운드에서 실행되기 때문에 테스트하기가 어려울 수 있습니다. 항상 어떻게 작동하고 있는지 확인할 수 있는 명확한 방법이 없습니다. 다행스럽게도 Flow Production TrackingEventDaemon에는 이를 포그라운드 프로세스로 실행할 수 있는 옵션이 있습니다. 이제 최소 필수 설정을 완료했으므로 데몬을 테스트하고 어떻게 되는지 확인해 보겠습니다.                    참고: 여기에 사용된 기본값에는 루트 액세스 권한이 필요합니다(예: /var/log 디렉터리에 쓰려는 경우). 제공된 사용 예에서는 이를 위해 sudo를 사용하여 실행됩니다.    $ sudo ./ShotGridEventDaemon.py foregroundINFO:engine:Using Flow Production Tracking version 3.0.8INFO:engine:Loading plugin at /usr/local/shotgun/ShotGridEvents/src/examplePlugins/logArgs.pyINFO:engine:Last event id (248429) from the Flow Production Tracking database.스크립트를 시작할 때 위의 행이 표시됩니다(일부 세부 사항은 다를 수 있음). 스크립트를 포그라운드에서 실행하기로 선택했기 때문에 오류가 발생하면 스크립트가 종료됩니다. 중단되면 몇몇 일반적인 오류가 아래에 표시됩니다.logArgs.py 플러그인은 Flow Production Tracking에서 발생한 이벤트를 찾아 로거로 전달합니다. 아주 흥미진진하지는 않지만 스크립트가 실행되고 플러그인이 작동하게 하는 간단한 방법입니다. 분주한 스튜디오에 있다면 이미 빠르게 진행되는 메시지의 흐름을 알아차리셨을 것입니다. 그렇지 않은 경우 웹 브라우저에서 Flow Production Tracking 서버에 로그인하여 값을 변경하거나 값을 생성합니다. 터미널 창에 변경 사항으로 생성된 이벤트 유형에 해당하는 로그 구문이 출력됩니다.                    참고: logArgs.py 파일에는 적절한 값을 입력해야 하는 변수가 있습니다. 로깅이 올바르게 작동하려면 shotgunEventDaemon.conf 파일에 사용된 것과 동일한 값을 포함하도록 ‘$DEMO_SCRIPT_NAMES$’ 및 ‘$DEMO_API_KEY$’를 편집해야 합니다.    로그 파일에 로깅된 내용이 보이지 않는 경우 Flow Production TrackingEventDaemon.conf에서 로그 관련 설정을 확인하여 logging 값이 로그 INFO 수준 메시지로 설정되어 있고logging: 20logArgs 플러그인도 INFO 수준 메시지를 표시하도록 구성되어 있는지 확인하십시오. registerCallbacks() 메서드의 끝에는 읽어야 하는 행이 있습니다.reg.logger.setLevel(logging.INFO)모두 올바르게 표시된다고 가정하면, Flow Production TrackingEventDaemon 프로세스를 중지하려는 경우 터미널에 &amp;lt;ctrl&amp;gt;-c을 입력하면 스크립트가 종료되는 것을 확인할 수 있습니다.데몬 실행테스트 시 모든 것이 순조로웠다고 가정하면, 이제 의도대로 백그라운드에서 데몬을 실행할 수 있습니다.$ sudo ./ShotGridEventDaemon.py start결과가 표시되지 않으며 터미널에서 컨트롤이 반환되어야 합니다. 두 가지 방법으로 제대로 실행되고 있는지 확인할 수 있습니다. 첫 번째는 실행 중인 프로세스를 확인하고 이것이 그중 하나인지 확인하는 것입니다.$ ps -aux | grep shotgunEventDaemonkp              4029   0.0  0.0  2435492    192 s001  R+    9:37AM   0:00.00 grep shotgunEventDaemonroot            4020   0.0  0.1  2443824   4876   ??  S     9:36AM   0:00.02 /usr/bin/python ./ShotGridEventDaemon.py start반환된 두 번째 행에서 데몬이 실행 중임을 알 수 있습니다. 첫 번째 행은 방금 실행한 명령과 일치합니다. 따라서 실행되고 있음을 알 수는 있지만 플러그인이 제대로 작동하고 있으며 의도된 역할을 수행하고 있는지 확인하기 위해 로그 파일을 확인해 출력된 내용이 있는지 알아볼 수 있습니다.$ sudo tail -f /var/log/shotgunEventDaemon/shotgunEventDaemon2011-09-09 09:42:44,003 - engine - INFO - Using Flow Production Tracking version 3.0.82011-09-09 09:42:44,006 - engine - INFO - Loading plugin at /usr/local/shotgun/ShotGrid/src/plugins/logArgs.py2011-09-09 09:42:44,199 - engine - DEBUG - Starting the event processing loop.웹 브라우저로 돌아가서 엔티티를 약간 변경합니다. 그런 다음 터미널로 다시 돌아가 출력된 내용이 있는지 확인합니다. 다음과 같이 표시되어야 합니다.2011-09-09 09:42:44,003 - engine - INFO - Using Flow Production Tracking version 3.0.82011-09-09 09:42:44,006 - engine - INFO - Loading plugin at /usr/local/shotgun/ShotGrid/src/plugins/logArgs.py2011-09-09 09:42:44,199 - engine - DEBUG - Starting the event processing loop.2011-09-09 09:45:31,228 - plugin.logArgs.logArgs - INFO - {'attribute_name': 'sg_status_list', 'event_type': 'Shotgun_Shot_Change', 'entity': {'type': 'Shot', 'name': 'bunny_010_0010', 'id': 860}, 'project': {'type': 'Project', 'name': 'Big Buck Bunny', 'id': 65}, 'meta': {'entity_id': 860, 'attribute_name': 'sg_status_list', 'entity_type': 'Shot', 'old_value': 'omt', 'new_value': 'ip', 'type': 'attribute_change'}, 'user': {'type': 'HumanUser', 'name': 'Kevin Porterfield', 'id': 35}, 'session_uuid': '450e4da2-dafa-11e0-9ba7-0023dffffeab', 'type': 'EventLogEntry', 'id': 276560}출력의 정확한 세부 정보는 다를 수 있지만, 플러그인이 의도된 작업을 수행해 이벤트가 로그 파일에 로깅된 것이 확인되어야 합니다. 로그 파일에 로깅된 내역이 보이지 않을 경우, logging 값이 INFO 수준 메시지를 로깅하도록 설정되어 있고 logArgs 플러그인도 INFO 수준 메시지를 표시하도록 구성되어 있는지 확인하기 위해 Flow Production TrackingEventDaemon.conf에서 로그 관련 설정을 확인하십시오.로깅에 대한 참고 사항로그 회전은 Flow Production Tracking 데몬의 기능이라는 점에 유의하십시오. 로그는 매일 밤 자정에 회전되며 플러그인당 10개의 일일 파일이 보관됩니다.일반적인 오류다음은 직면할 수 있는 몇몇 일반적인 오류와 그 해결 방법에 대한 몇 가지 설명입니다. 문제가 발생하면 지원 사이트에서 도움을 요청하십시오.잘못된 경로: $PLUGIN_PATHS$shotgunEventDaemon.conf 파일에서 플러그인 경로를 지정해야 합니다.권한이 거부됨: ‘/var/log/shotgunEventDaemon’쓰기 작업을 위해 데몬에서 로그 파일을 열 수 없습니다.sudo로 데몬을 실행하거나 ShotgunEventDaemon.conf의 logPath 및 logFile 설정에서 지정한 로그 파일에 쓸 수 있는 권한이 있는 사용자로 데몬을 실행해야 할 수 있습니다. (기본 위치는 일반적으로 루트 소유의 /var/log/shotgunEventDaemon입니다.)ImportError: 이름이 shotgun_api3인 모듈 없음Flow Production Tracking API가 설치되어 있지 않습니다. 현재 디렉토리에 있거나 PYTHONPATH의 디렉토리에 있어야 합니다.sudo로 실행해야 하는데 PYTHONPATH가 올바르게 설정되어 있는 경우, sudo가 환경 변수를 재설정한다는 점을 기억하십시오. PYTHONPATH를 유지하거나 sudo -e(?)를 실행하도록 sudoers 파일을 편집할 수 있습니다.구성 파일 설정 리스트데몬 설정다음은 일반적인 데몬 작동 설정입니다.pidFilepidFile은 데몬이 실행 중인 동안 해당 프로세스 ID를 저장하는 위치입니다. 데몬이 실행되는 동안 이 파일이 제거되면 다음 이벤트 처리 루프를 거친 후 완전히 종료됩니다.디렉토리가 이미 있으며 쓰기 가능해야 합니다. 원하는 대로 파일 이름을 지정할 수 있지만 실행 중인 프로세스와 일치하는 기본 이름을 사용하는 것이 좋습니다.pidFile: /var/log/shotgunEventDaemon.pideventIdFileeventIdFile은 데몬이 마지막으로 처리된 Flow Production Tracking 이벤트의 ID를 저장할 위치를 나타냅니다. 이를 통해 데몬은 마지막 종료 시 중지된 지점으로 복귀할 수 있으므로 이벤트가 누락되지 않습니다. 데몬이 마지막으로 종료된 이후의 이벤트를 무시하려면 데몬을 시작하기 전에 이 파일을 제거해 시작된 후 새로 생성된 이벤트만 데몬이 처리하게 합니다.이 파일은 각 플러그인에 대한 마지막 이벤트 ID를 추적하여 이 정보를 pickle 형식으로 저장합니다.eventIdFile: /var/log/shotgunEventDaemon.idlogMode로깅 모드는 다음 두 값 중 하나로 설정할 수 있습니다.  0 = 기본 로그 파일에 모든 로그 메시지 기록  1 = 엔진에 대해 하나의 기본 파일, 플러그인당 하나의 파일값 1을 사용할 때 엔진에서 생성되는 로그 메시지는 logFile 구성 설정에서 지정한 기본 로그 파일에 로깅됩니다. 플러그인이 로깅하는 모든 메시지는 plugin.&amp;lt;plugin_name&amp;gt;라는 파일에 저장됩니다.logMode: 1logPath로그 파일을 저장할 경로(기본 엔진 및 플러그인 로그 파일 모두) 기본 로그 파일의 이름은 아래의 logFile 설정에 의해 제어됩니다.logPath: /var/log/shotgunEventDaemon                    참고: shotgunEventDaemon에 이 디렉터리에 대한 쓰기 권한이 있어야 합니다. 일반적인 설정에서는 시스템이 시작될 때 데몬이 자동으로 실행되도록 설정되고 해당 시점에 루트 권한이 부여됩니다.    logFile기본 데몬 로그 파일의 이름입니다. 로깅은 매일 밤 자정에 회전하는 로그 파일을 최대 10개까지 저장하도록 구성되어 있습니다.logFile: shotgunEventDaemonlogging로그 파일로 전송된 로그 메시지의 임계값 수준입니다. 이 값은 기본 디스패치 엔진의 기본값이며 플러그인별 기준으로 재정의될 수 있습니다. 이 값은 Python 로깅 모듈로 전달됩니다. 가장 일반적인 값은 다음과 같습니다.  10: 디버그  20: 정보  30: 경고  40: 오류  50: 중요logging: 20timing_log이 값을 on로 설정하여 타이밍 로깅을 활성화하면, 데몬의 성능 문제를 더 간단히 해결할 수 있게 해주는 타이밍 정보가 있는 별도의 로그 파일이 생성됩니다.각 콜백 호출에 대해 제공되는 타이밍 정보는 다음과 같습니다.  event_id 콜백을 트리거한 이벤트의 ID  created_at 이벤트가 Flow Production Tracking에서 생성된 시점의 ISO 형식 타임스탬프  callback plugin.callback 형식으로 호출된 콜백의 이름  start 콜백 처리 시작 시점의 ISO 형식 타임스탬프  end 콜백 처리 종료 시점의 ISO 형식 타임스탬프  duration 콜백 처리 시간의 DD:HH:MM:SS.micro_second 형식 지속 시간  error 콜백의 실패 여부 값은 False 또는 True일 수 있습니다.  delay 이벤트 생성과 콜백별 처리 시작 시간 사이의 지연 시간(DD:HH:MM:SS.micro_second 형식)conn_retry_sleepShotGrid에 대한 연결이 실패할 경우 다시 연결을 시도할 때까지 대기하는 시간(초)입니다. 이를 통해 간헐적인 네트워크 문제, 서버 재시작, 응용프로그램 유지 관리 작업 등이 발생할 수 있습니다.conn_retry_sleep = 60max_conn_retries오류 수준 메시지를 로깅하기 전에 연결을 다시 시도하는 횟수입니다(아래의 이메일 알림이 구성된 경우 이메일을 보낼 수 있음).max_conn_retries = 5fetch_interval각 이벤트 배치가 처리된 후 새 이벤트를 요청할 때까지 대기할 시간(초)입니다. 이 설정은 일반적으로 조정할 필요가 없습니다.fetch_interval = 5Flow Production Tracking 설정다음은 Flow Production Tracking 인스턴스와 관련된 설정입니다.server연결할 Flow Production Tracking 서버의 URL입니다.server: %(SG_ED_SITE_URL)s                    참고: 여기에는 기본값이 없습니다. SG_ED_SITE_URL 환경 변수를 Flow Production Tracking 서버의 URL(예: https://awesome.shotgunstudio.com)로 설정하십시오.    nameShotGridEventDaemon이 연결해야 하는 Flow Production Tracking 스크립트 이름입니다.name: %(SG_ED_SCRIPT_NAME)s                    참고: 여기에는 기본값이 없습니다. SG_ED_SCRIPT_NAME 환경 변수를 Flow Production Tracking 서버의 스크립트 이름(예: shotgunEventDaemon)    key위에 지정된 스크립트 이름에 대한 Flow Production Tracking 응용프로그램 키입니다.key: %(SG_ED_API_KEY)s                    참고: 여기에는 기본값이 없습니다. SG_ED_API_KEY 환경 변수를 위의 스크립트 이름에 대한 응용프로그램 키로 설정하십시오(예:0123456789abcdef0123456789abcdef01234567).    use_session_uuidFlow Production Tracking 인스턴스의 모든 이벤트에서 session_uuid를 설정해 플러그인이 생성한 모든 이벤트에 전파합니다. 이렇게 하면 Flow Production Tracking UI가 플러그인의 결과로 발생하는 업데이트를 표시할 수 있습니다.use_session_uuid: True  이 기능을 사용하려면 Flow Production Tracking server v2.3 이상이 필요합니다.  이 기능을 사용하려면 Flow Production Tracking API v3.0.5 이상이 필요합니다.                    참고: Flow Production Tracking UI는 원래 이벤트를 생성한 브라우저 세션에 대해서만 업데이트를 실시간으로 표시합니다. 동일한 페이지가 열려 있는 다른 브라우저 창에는 실시간 업데이트가 표시되지 않습니다.    플러그인 설정paths프레임워크가 로드할 플러그인을 찾아야 하는 쉼표로 구분된 전체 경로 목록입니다. 상대 경로를 사용하지 마십시오.paths: /usr/local/shotgun/plugins                    참고: 여기에는 기본값이 없습니다. 플러그인 파일(예: Windows의 경우 /usr/local/shotgun/shotgunEvents/plugins 또는 C: shotgun shotgunEvents plugins)의 위치로 값을 설정해야 합니다.    이메일 설정로그를 지속적으로 추적하기보다는 활성 알림 시스템을 가지고 있을 것이라는 점을 알고 있으므로 이 방식이 오류 보고에 사용됩니다.아래의 모든 설정이 제공되는 경우 레벨 40(ERROR)보다 높은 오류가 이메일을 통해 보고됩니다.이메일 알림이 전송되려면 이 모든 값을 입력해야 합니다.serverSMTP 연결에 사용해야 하는 서버입니다. SMTP 연결에 대한 자격 증명을 제공하기 위해 사용자 이름 및 암호 값의 주석 처리를 해제할 수 있습니다. 서버에서 인증을 사용하지 않는 경우에는 username 및 password에 대한 설정에 주석 처리를 해야 합니다.server: smtp.yourdomain.com                    참고: 여기에는 기본값이 없습니다. smtp.yourdomain.com 토큰을 SMTP 서버의 주소로 대체해야 합니다(즉, smtp.mystudio.com).    usernameSMTP 서버에 인증이 필요한 경우 이 행의 주석 처리를 제거하고 SMTP 서버에 연결하는 데 필요한 사용자 이름으로 SG_ED_EMAIL_USERNAME 환경 변수를 구성했는지 확인하십시오.username: %(SG_ED_EMAIL_USERNAME)spasswordSMTP 서버에 인증이 필요한 경우 이 행의 주석 처리를 제거하고 SMTP 서버에 연결하는 데 필요한 암호로 SG_ED_EMAIL_PASSWORD 환경 변수를 구성했는지 확인하십시오.password: %(SG_ED_EMAIL_PASSWORD)sfrom이메일에 사용되어야 하는 보낸 사람 주소입니다.from: support@yourdomain.com                    참고: 여기에는 기본값이 없습니다. support@yourdomain.com을 유효한 값으로 대체해야 합니다(예: noreply@mystudio.com).    to알림을 받을 이메일 주소의 쉼표로 구분된 목록입니다.to: you@yourdomain.com                    참고: 여기에는 기본값이 없습니다. you@yourdomain.com을 유효한 값으로 대체해야 합니다(예: shotgun_admin@mystudio.com).    subjectFlow Production Tracking 이벤트 프레임워크에서 보낸 알림을 정렬할 수 있도록 메일 클라이언트가 사용할 수 있는 이메일 제목 접두어입니다.subject: [SG]",
    "url": "/ed5161c4/",
    "relUrl": "/ed5161c4/"
  },
  "50": {
    "id": "50",
    "title": "예시 플러그인",
    "content": "예시 플러그인소스 코드에 예시 플러그인 폴더가 있습니다.이 페이지에는 누구나 시작할 수 있는 몇 가지 간단한 예제가 나와 있습니다. 이 코드를 복사해서 붙여넣으면 실행됩니다(참고: script_name 및 script_key 값을 설치에 해당되는 값으로 업데이트해야 함).먼저, 다음은 SG 이벤트 코드를 기록해야 하는 템플릿입니다.1. 코드 템플릿이를 복사하여 붙여넣으면 새 플러그인을 시작할 수 있습니다.&quot;&quot;&quot;Necessary Documentation of the codeAuthor: YouTemplate Author: Andrew Britton&quot;&quot;&quot;def registerCallbacks(reg):    # This takes the form of:    #    matchEvents = {'Shotgun_Entity_EventType': ['list', 'of', 'field', 'names', 'you', 'need', 'sg_custom_field']}    # the 'id' is always returned, in addition to any fields specifically requested by your callback    matchEvents = {        'Shotgun_Task_Change': ['content']    }    # script_name and script_key are defined by you whenever you create a SG script    # the entry_function_call refers to the function that performs the work of the event plugin    reg.registerCallback('script_name', 'script_key', entry_function_call, matchEvents, None)# This gives you#    shotgun handle = sg#    a logger object... please use this instead of python print, especially if you respect your time and your fellow developers#    an event object... this is the metadata that describes what's happening with the particular event.#        some very good information comes from the event['meta'] object, below is the example event['meta'] data from the subject renamer plugin#              {#                &quot;type&quot;: &quot;attribute_change&quot;,#                &quot;attribute_name&quot;: &quot;subject&quot;,#                &quot;entity_type&quot;: &quot;Note&quot;,#                &quot;entity_id&quot;: 2,#                &quot;field_data_type&quot;: &quot;text&quot;,#                &quot;old_value&quot;: &quot;My Note Subject&quot;,#                &quot;new_value&quot;: &quot;2017-05 May-09 - My Note Subject&quot;#              }def entry_function_call(sg, logger, event, args):    # Now do stuff    pass   2. 노트 제목 이름 바꾸기New 엔티티 이벤트 작업이 작업은 간단해서 시작하기 좋지만 Shotgun_Entity_New 이벤트를 포착하는 것은 매우 까다로운 측면이기도 합니다.import timefrom pprint import pprintdef registerCallbacks(reg):    matchEvents = {        'Shotgun_Note_New': ['*'],    }    reg.registerCallback('script_name', 'script_key', Function_Name, matchEvents, None)def Function_Name(sg, logger, event, args):    # Waiting here should allow the entity to be fully created            #     and all the necessary attributes to be added to the NOTE entity    time.sleep(1)    current_date = time.strftime(&quot;%Y-%m %b-%d&quot;)    asset_id = event['meta']['entity_id']    asset_type = event['meta']['entity_type']    asset = sg.find_one(asset_type, [['id', 'is', asset_id]], ['subject'])    if asset['subject'] is None:        current_name = current_date + ' - ' + event['project']['name'] + ' - ' + event['user']['name']    else:        current_name = current_date + ' - ' + asset['subject']    # Modify ALL notes except those in 'Software Development'    if event['project'] == None:        logger.info('Updated Note ID is #%d, and is being prepended with &quot;%s&quot;', asset_id, current_date)        logger.info(event)        sg.update(asset_type, asset_id, {'subject': current_name})        return    if event['project']['id'] != 116:        logger.info('Updated Note ID is #%d, and is being prepended with &quot;%s&quot;', asset_id, current_date)        logger.info(event)        sg.update(asset_type, asset_id, {'subject': current_name})    else:        logger.info('Dates are not prepended for notes in project id 116 - Software Development')        return함수 본문의 첫 번째 줄인 sleep 호출에 주목합니다. new 이벤트가 처리되는 방식을 다루기 때문입니다.  SG에서 새 엔티티가 생성될 때는 완전한 형태를 갖추지 않습니다. 즉, 엔티티를 사용할 때 해당 엔티티를 완전히 정의하는 데 필요한 모든 속성이 포함되어 있지 않습니다. 실제로 이 예제에서는 SG가 subject 이벤트를 내보내는 경우 Shotgun_Note_New 속성이 노트 엔티티에 있음을 보장할 수 없습니다.  필요한 모든 속성을 추가하기 위해 SG는 필요한 경우 SG가 모든 단일 속성을 엔티티에 추가하고 해당 속성의 값을 업데이트하는 일련의 Shotgun_Note_Change 이벤트를 게시합니다.  이렇게 하면 여러 개의 이벤트가 생성됩니다. 즉, 서로 다른 두 개의 속성이 있어야 하고 sleep 요소를 코드에 기록하지 않은 경우에는, 새로운 속성이 추가되고 값이 설정된 이벤트만 검색하는 내부 메타데이터 및 Shotgun_Note_Change 이벤트를 모두 거쳐야 합니다. 이 작업은 복잡한 프로세스이며 많은 Shotgun_Note_Change 이벤트 검색을 효과적으로 처리합니다(생성 시 노트별로 하나씩만).  적합한 솔루션은 Shotgun_Entity_New를 사용하고 짧은 기간 동안 스크립트가 절전 모드로 전환되도록 하는 것입니다. 절전 모드가 끝나면 SG는 해당 엔티티에 필요한 모든 속성을 업데이트한 다음 필요한 필드에 대해 동일한 엔티티를 다시 쿼리할 수 있습니다.2. 필드 삭제 경고노트 생성, 필드를 엔티티로 사용, 엔티티 삭제 이벤트&quot;&quot;&quot;Create a Note when a field is deletedAuthor: Andrew Britton&quot;&quot;&quot;def registerCallbacks(reg):    &quot;&quot;&quot;    fn: registerCallbacks    @brief required function. It connects to the event daemon and calls the trashedFieldWarning Function.    It runs every time a field is deleted (retired)    @param[in] reg variable that is required by shotgun event daemon plugins    @return none    &quot;&quot;&quot;    matchEvents = {        'Shotgun_DisplayColumn_Retirement': ['*']    }    reg.registerCallback('script_name', 'script_key',                         trashedFieldWarning, matchEvents, None)def CreateNote(sg, logger, event):    constants = {'note header': ':: FIELD DELETION :: '}    def GetListOfPipelineUsers():        pipeline_users = sg.find('Group', [['code', 'is', 'People_Who_Need_to_Know']], ['code', 'users', 'addressings_to',                                                                         'sg_ticket_type', 'sg_priority'])        return pipeline_users[0]['users']    def CreateToolsNote():        # Note to members of the pipeline group        # Body text = CreateNoteRequestText()        # Date Created = event['event']['created_at']        # Created By = event['user']['id']        # Project = Software Development['id']        # Subject = ':: Field Delete Warning :: ' + event['entity']['name']        note_data = {            'project': {'type': 'Project', 'id': 'ID OF PROJECT WHERE YOU WANT THE NOTE REPORTED TO'},            # ex: 'project': {'type': 'Project', 'id': 2},            'content': CreateNoteRequestText(),            'created_at': event['created_at'],            'created_by': event['user'],            'addressings_to': GetListOfPipelineUsers(),            'subject': constants['note header'] + event['meta']['display_name']        }        sg.create('Note', note_data)    def CreateNoteRequestText():        OUT = ''        # Tool Name = event['entity']['name']        # sg_assigned_to = members of the pipeline group        # Description = linked Ticket decription        # Project = decided in GUI        # sg_sg_request_ticket = event['entity']['id']        # task_template = Software task template        # Software Projects = defined in GUI        OUT = '::FIELD DELETION WARNING:: n'        OUT += ':: A Field was deleted :: n'        OUT += ':: It was called %s :: n'%event['meta']['display_name']        return OUT    logger.info('::WARNING:: A FIELD has been deleted')    CreateToolsNote()def trashedFieldWarning(sg, logger, event, args):    &quot;&quot;&quot;    fn: finalizeTasksFromShot    @brief Function to create and send a warning note, via SG, whenever a field is deleted    event['entity']['id'] yields the id of the current entity that was caught by the plugin as having been changed.    ie. this is the id of the field that was just deleted    @param[in] sg defines the Shotgun handle to access the database    @param[in] logger sets logging messages to the shotgun event daemon    @param[in] event the collection of shots that have changed    @param[in] args useless variable for this particular function    @return none    &quot;&quot;&quot;    if event['meta']['entity_type'] == 'DisplayColumn':        logger.info('This DisplayColumn was deleted %s', event['meta']['display_name'])    if event['event_type'] == 'Shotgun_DisplayColumn_Retirement':        logger.info('The incoming event call is for deleting a field from an entity. Field name: %s', event['meta']['display_name'])    # logger.info(' TEST ')    # logger.info('Deleted Field ID is #%d, and is called: %s', event['entity']['id'], event['entity']['name'])    CreateNote(sg, logger, event)매우 간단한 스크립트입니다. 삭제된 필드를 확인하는 특별한 로직이 없습니다. 필드가 삭제된 경우 노트가 생성되어 해당 정보를 알아야 하는 사용자 그룹으로 전송됩니다. 내 부서에서 그룹 ID를 ‘programmers’ 그룹으로 설정하고 노트의 프로젝트 ID는 ‘development’ 프로젝트로 설정했습니다.",
    "url": "/34048d1e/",
    "relUrl": "/34048d1e/"
  },
  "51": {
    "id": "51",
    "title": "설치",
    "content": "설치다음 안내서는 스튜디오에 대한 Flow Production TrackingEvents 구성을 지원합니다.시스템 요구사항데몬은 Python이 설치되어 있고 Flow Production Tracking 서버에 대한 네트워크 액세스 권한이 있는 모든 시스템에서 실행할 수 있습니다. Flow Production Tracking 서버 자체에서 실행할 필요가 없습니다. 실제로 Flow Production Tracking의 호스트된 버전을 사용하는 경우 이는 옵션이 아닙니다. 그러나 원하는 경우 Flow Production Tracking 서버에서 실행할 수 있습니다. 그렇지 않으면 서버가 해당 작업을 수행합니다.  Python v2.6, v2.7 또는 3.7  Flow Production Tracking Python API          Python 3.7 이상에 v3.1.0 이상을 사용합니다(참고: Python 2는 더 이상 지원되지 않음).      어떤 경우든 최신 Python API 버전을 사용하고 이 종속성을 시간이 지남에 따라 계속 업데이트하는 것이 좋습니다.        Flow Production Tracking 서버에 대한 네트워크 액세스Flow Production Tracking API 설치Python이 이미 컴퓨터에 설치되어 있다고 가정하면 Flow Production Tracking 이벤트 데몬에서 Python API를 사용하여 Flow Production Tracking 서버에 연결할 수 있도록 Flow Production Tracking Python API를 설치해야 합니다. 다음과 같은 방법으로 이 작업을 수행할 수 있습니다.  Flow Production Tracking 이벤트 데몬과 동일한 디렉토리에 배치합니다.  PYTHONPATH 환경 변수 에서 지정한 디렉토리 중 하나에 배치합니다.터미널 창에서 Flow Production Tracking API가 제대로 설치되었는지 테스트하려면:$ python -c &quot;import shotgun_api3&quot;출력이 표시되지 않아야 합니다. 아래 출력과 같은 결과가 있는 경우 PYTHONPATH가 올바르게 설정되었는지 또는 Flow Production Tracking API가 현재 디렉토리에 있는지 확인해야 합니다.$ python -c &quot;import shotgun_api3&quot;Traceback (most recent call last):File &quot;&amp;lt;string&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;ImportError: No module named shotgun_api3ShotGridEvents 설치ShotGridEvents 설치 위치는 사용자가 임의로 선택할 수 있습니다. 다시 말하지만 Python 및 Flow Production Tracking API가 컴퓨터에 설치되어 있고 Flow Production Tracking 서버에 대한 네트워크 액세스 권한이 있는 경우 어디에서나 실행할 수 있습니다. 그러나 스튜디오에 적합한 위치(예: /usr/local/shotgun/shotgunEvents)에 설치하는 것이 타당하므로 이 위치를 예제에서 사용합니다.소스 및 아카이브는 GitHub(https://github.com/shotgunsoftware/shotgunEvents)에서 사용할 수 있습니다.                    참고: Windows: Windows 서버가 있는 경우 C: shotgun shotgunEvents를 사용할 수 있지만 이 설명서에서는 Linux 경로를 사용합니다.    소스 복제컴퓨터에 git가 설치된 경우 소스를 가져오는 가장 쉬운 방법은 프로젝트를 복제하는 것입니다. 이러한 방식으로 업데이트를 쉽게 가져와 버그 수정 및 새로운 기능으로 최신 상태를 유지할 수도 있습니다.$ cd /usr/local/shotgun$ git clone git://github.com/shotgunsoftware/shotgunEvents.git                    경고: 아무 것도 손실되지 않도록 GitHub에서 업데이트를 가져오기 전에 항상 shotgunEvents의 구성, 플러그인 및 모든 수정 사항을 백업해야 합니다. 또는 자체 변경 리포지토리를 유지할 수 있도록 프로젝트를 직접 분기(fork)합니다. :)    아카이브 다운로드컴퓨터에 git가 없거나 단순히 소스 아카이브를 다운로드하려는 경우에는 다음 단계를 수행하여 시작할 수 있습니다.  https://github.com/shotgunsoftware/shotgunEvents/로 이동합니다.  원하는 형식으로 소스를 다운로드합니다.  이를 컴퓨터에 저장합니다.  /usr/local/shotgun 디렉토리에 파일을 추출합니다.  /usr/local/shotgun/shotgunsoftware-shotgunEvents-xxxxxxx 디렉토리 이름을 /usr/local/shotgun/shotgunEvents로 바꿉니다./usr/local/shotgun에 아카이브 압축 풀기.tar.gz 아카이브의 경우:$ tar -zxvf shotgunsoftware-shotgunEvents-v0.9-12-g1c0c3eb.tar.gz -C /usr/local/shotgun.zip 아카이브의 경우:$ unzip shotgunsoftware-shotgunEvents-v0.9-12-g1c0c3eb.zip -d /usr/local/shotgun그런 다음 GitHub에서 할당된 디렉토리 이름을 shotgunEvents로 바꿀 수 있습니다.$ mv shotgunsoftware-shotgunEvents-1c0c3eb shotgunEvents결과는 다음과 같습니다.$ ls -l /usr/local/shotgun/shotgunEventstotal 16-rw-r--r--  1 kp  wheel  1127 Sep  1 17:46 LICENSE-rw-r--r--  1 kp  wheel   268 Sep  1 17:46 README.mkddrwxr-xr-x  9 kp  wheel   306 Sep  1 17:46 docsdrwxr-xr-x  6 kp  wheel   204 Sep  1 17:46 src설치 요구사항리포지토리의 루트에 requirements.txt 파일이 제공됩니다. 이 파일을 사용하여 필요한 패키지를 설치해야 합니다.$ pip install -r /path/to/requirements.txtWindows 세부 사항Windows 시스템에 다음 중 하나가 필요합니다.  PyWin32가 설치된 Python  활성 Python활성 Python은 Flow Production Tracking 이벤트 데몬을 Windows 서비스 아키텍처와 통합하는 데 필요한 PyWin32 모듈과 함께 제공됩니다.다음 명령을 실행하여 서비스 데몬을 설치할 수 있습니다. C: Python27_32 python.exe가 Python 실행 파일의 경로라고 가정하므로 그에 맞게 조정합니다.&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py install또는 다음 방법으로 제거할 수 있습니다.&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py remove서비스 시작 및 중지는 일반 서비스 관리 도구 또는 다음과 같은 명령행을 통해 수행할 수 있습니다.&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py start&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py stop대부분의 경우 나열된 각 명령을 시스템의 관리 사용자로 실행해야 합니다. 이렇게 하려면 cmd 응용프로그램을 마우스 오른쪽 버튼으로 클릭하고 “관리자 권한으로 실행”을 선택합니다.                    참고: 네트워크 위치의 Windows에서 데몬을 설치한 경우 또는 네트워크 위치에서 로그 및 기타 리소스를 읽고 쓰도록 구성한 경우, 서비스를 실행하는 사용자를 로컬 시스템 계정에서 네트워크 리소스에 액세스할 수 있는 도메인 계정으로 변경하기 위해 서비스 특성을 편집해야 합니다.    ",
    "url": "/7c203655/",
    "relUrl": "/7c203655/"
  },
  "52": {
    "id": "52",
    "title": "플러그인",
    "content": "플러그인 개요플러그인 파일은 구성 파일에 지정된 플러그인 경로의 .py 파일입니다.코드 다운로드 시 src/examplePlugins 폴더에 몇 가지 예시 플러그인이 제공됩니다. 이러한 플러그인은 생성된 특정 이벤트를 찾기 위해 자체 플러그인을 빌드하고 해당 이벤트에 작동하여 Flow Production Tracking 인스턴스에서 다른 값을 변경하는 방법에 대한 간단한 예제를 제공합니다.플러그인을 업데이트할 때마다 데몬을 다시 시작할 필요가 없으며 데몬이 플러그인이 업데이트되었음을 감지하고 자동으로 다시 로드합니다.플러그인에서 오류가 발생할 경우 데몬이 충돌하지 않습니다. 플러그인은 다시 업데이트(수정)될 때까지 비활성화됩니다. 다른 모든 플러그인은 계속 실행되고, 이벤트는 계속 처리됩니다. 데몬은 오류가 발생한 플러그인이 성공적으로 처리된 마지막 이벤트 ID를 계속해서 트래킹합니다. 플러그인이 업데이트(수정)되면 데몬이 이를 다시 로드하고 해당 플러그인이 중단된 위치부터 이벤트를 처리하려고 시도합니다. 다시 모든 것이 정상이라고 가정하면 데몬은 현재 이벤트까지 플러그인을 포착한 다음 정상적으로 모든 플러그인을 사용하여 이벤트를 계속 처리합니다.Flow Production Tracking 이벤트 처리 플러그인에는 두 가지 주요 부분이 있습니다. 콜백 등록 함수와 콜백 수입니다.registerCallbacks 함수프레임워크에서 로드하려면 플러그인이 최소한 다음 함수를 구현해야 합니다.def registerCallbacks(reg):    pass이 함수는 이벤트 처리 시스템에 이벤트를 처리하기 위해 호출할 함수를 전달하는 데 사용됩니다.이 함수는 Registrar 객체인 하나의 인수를 사용해야 합니다.Registrar는 아주 중요한 한 가지 메서드를 사용합니다(Registrar.registerCallback).Flow Production Tracking 이벤트를 처리해야 하는 각 함수에 대해 Registrar.registerCallback을 적절한 인수와 함께 한 번 호출합니다.원하는 수만큼 함수를 등록할 수 있으며, 파일의 모든 함수를 이벤트 처리 콜백으로 등록해야 하는 것은 아닙니다.콜백시스템에 등록할 콜백은 다음 4개의 인수를 사용해야 합니다.  추가 정보를 위해 Flow Production Tracking를 쿼리해야 하는 경우 Flow Production Tracking 연결 인스턴스  보고에 사용해야 하는 Python Logger 객체. 오류 및 중요 메시지는 구성된 모든 사용자에게 이메일을 통해 전송됩니다.  처리할 Flow Production Tracking 이벤트  콜백 등록 시 전달되는 args 값. (참조 항목: Registrar.registerCallback)                    경고: 플러그인에서 원하는 모든 작업을 수행할 수 있지만 예외가 프레임워크에 다시 발생하면 디스크의 파일이 변경될 때까지(읽기: 수정) 잘못된 콜백(및 포함된 모든 콜백)이 있는 플러그인이 비활성화됩니다.    로깅이벤트 플러그인에서 print 문을 사용하는 것은 권장되지 않습니다. Python 표준 라이브러리에서 표준 로깅 모듈을 사용하는 것이 좋습니다. 로거 객체는 다양한 함수로 제공됩니다.def registerCallbacks(reg):    reg.setEmails('root@domain.com', 'tech@domain.com') # Optional    reg.logger.info('Info')    reg.logger.error('Error') # ERROR and above will be sent via email in default config및def exampleCallback(sg, logger, event, args):    logger.info('Info message')이벤트 프레임워크가 데몬으로 실행 중인 경우 이 프레임워크가 파일에 로깅되며, 그렇지 않으면 stdout에 로깅됩니다.강력한 플러그인 빌드데몬은 Flow Production Tracking에 대해 쿼리를 실행하지만 실패할 경우 find() 명령을 재시도하는 기본 기능이 포함되어 있어 데몬 자체에 특정한 수준의 안전성을 제공합니다.https://github.com/shotgunsoftware/shotgunEvents/blob/master/src/shotgunEventDaemon.py#L456플러그인에 네트워크 리소스(즉, Flow Production Tracking 또는 다른 리소스)가 필요한 경우 자체 재시도 메커니즘/안전성을 제공해야 합니다. Flow Production Tracking 액세스의 경우 데몬의 항목을 제거하고 해당 기능을 플러그인에 제공할 수 있는 도우미 함수 또는 클래스를 만들 수 있습니다.Flow Production Tracking Python API가 이미 네트워크 문제에 대해 어느 정도 재시도하지만 몇 분 동안 실행할 수 있는 Flow Production Tracking 유지보수 기간에 도달하거나 네트워크 문제가 발생하면 충분하지 않을 수 있습니다.https://github.com/shotgunsoftware/python-api/blob/master/shotgun_api3/shotgun.py#L1554플러그인이 수행하는 작업에 따라 이벤트를 처리하는 동안 문제가 발생하는 경우 트래킹을 계속하도록 플러그인을 등록할 수도 있습니다. registerCallback 함수의 stopOnError 인수를 확인합니다.https://github.com/shotgunsoftware/shotgunEvents/wiki/API#wiki-registerCallback                    참고: 플러그인이 중지되지 않지만 실패한 시도는 재시도하지 않습니다.    ",
    "url": "/3d05c112/",
    "relUrl": "/3d05c112/"
  },
  "53": {
    "id": "53",
    "title": "기술적 상세 정보",
    "content": "기술 개요이벤트 유형알림을 받을 수 있게 트리거를 등록할 수 있는 이벤트 유형은 일반적으로 다음 양식을 따릅니다. Shotgun_[entity_type]_[New|Change|Retirement|Revival]. 다음은 이 패턴의 몇 가지 예입니다.Shotgun_Note_NewShotgun_Shot_NewShotgun_Task_ChangeShotgun_CustomEntity06_ChangeShotgun_Playlist_RetirementShotgun_Playlist_Revival이 패턴의 일부는 엔티티 레코드 활동과 관련되지 않고 응용프로그램 동작의 요점과 관련된 이벤트에 사용됩니다.CRS_PlaylistShare_CreateCRS_PlaylistShare_RevokeSG_RV_Session_Validate_SuccessShotgun_Attachment_ViewShotgun_Big_QueryShotgun_NotesApp_Summary_EmailShotgun_User_FailedLoginShotgun_User_LoginShotgun_User_LogoutToolkit_App_StartupToolkit_Desktop_ProjectLaunchToolkit_Desktop_AppLaunchToolkit_Folders_CreateToolkit_Folders_Delete    이 목록은 완벽하지는 않지만 시작하기에 적합합니다. Flow Production Tracking 사이트의 활동 및 이벤트 유형에 대해 자세히 알아보려면 다른 엔티티 유형의 다른 그리드 페이지를 통해 필터링하고 검색할 수 있는 EventLogEntries 페이지를 참조하십시오.썸네일의 이벤트 로그 항목엔티티에 대한 새 썸네일이 업로드되면 `Type` == `Shotgun_&amp;lt;Entity_Type&amp;gt;_Change`인 이벤트 로그 항목이 생성됩니다(예: Shotgun_Shot_Change).  ‘is_transient’ 필드 값은 true로 설정됩니다.    { &quot;type&quot;: &quot;attribute_change&quot;,&quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: null, &quot;new_value&quot;: 11656, &quot;is_transient&quot;: true}        썸네일을 사용할 수 있게 되면 이제 ‘is_transient’ 필드 값을 false로 설정하여 새 이벤트 로그 항목이 생성됩니다.    { &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: null, &quot;new_value&quot;: 11656, &quot;is_transient&quot;: false}        썸네일을 다시 업데이트하면 다음 새 이벤트 로그 항목이 표시됩니다.    { &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: 11656, &quot;new_value&quot;: 11657, &quot;is_transient&quot;: true}{ &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: null, &quot;new_value&quot;: 11657, &quot;is_transient&quot;: false}        첨부 파일의 썸네일이 자리 표시자 썸네일인 경우 ‘old_value’ 필드는 null로 설정됩니다.플러그인 처리 순서각 이벤트는 항상 동일한 예측 가능한 순서로 처리되므로 플러그인이나 콜백이 상호 종속적인 경우 처리를 안전하게 구성할 수 있습니다.구성 파일은 하나 이상의 플러그인 위치를 포함하는 paths 구성을 지정합니다. 목록의 위치가 앞쪽일수록 포함된 플러그인이 더 빨리 처리됩니다.플러그인 경로 내의 각 플러그인은 알파벳 오름차순으로 처리됩니다.                    참고: 내부적으로 파일 이름은 목록에 추가되고 정렬됩니다.    마지막으로, 플러그인에 의해 등록된 각 콜백이 등록 순서대로 호출됩니다. 첫 번째 등록된 콜백이 첫 번째로 실행됩니다.하나 이상의 콜백과 같은 플러그인에서 상태를 공유해야 하는 기능을 유지하는 것이 좋습니다.상태 공유여러 콜백에 대해 상태를 공유해야 하는 여러 옵션이 있습니다.  전역 변수. Ick. 이 작업을 수행하지 마십시오.  상태 정보가 들어 있는 가져온 모듈. Ick, 단순한 전역보다는 낫습니다.  Registrar.registerCallback을 호출할 때 args 인수로 전달된 변경 가능한 것. 설계의 상태 객체 또는 dict처럼 간단한 것. 선호.  객체 인스턴스에 대해 __call__과 같은 콜백을 구현하고 콜백 객체 초기화 시 일부 공유 상태 객체를 제공합니다. 가장 강력하면서도 가장 어려운 방법입니다. 위의 args 인수 방법에 비해 중복될 수 있습니다.이벤트 백로그이 프레임워크는 모든 플러그인이 관심 있는 모든 단일 이벤트를 예외 없이 정확히 한 번만 처리하도록 설계되었습니다. 이를 위해, 프레임워크는 각 플러그인에 대해 처리되지 않은 이벤트의 백로그를 저장하고 각 플러그인이 제공된 마지막 이벤트를 기억합니다. 다음은 백로그가 발생할 수 있는 상황에 대한 설명입니다.이벤트 로그 항목 시퀀스의 간격으로 인한 백로그ShotGrid에서 발생하는 각 이벤트(필드 업데이트, 엔티티 생성, 엔티티 삭제 등)는 해당 이벤트 로그 항목에 대한 고유 ID 번호가 있습니다. 경우에 따라 ID 번호 시퀀스에 간격이 있을 수 있습니다. 이러한 간격은 여러 가지 이유로 발생할 수 있지만 그중 하나는 아직 완료되지 않은 대규모 데이터베이스 트랜잭션입니다.이벤트 로그 시퀀스에 간격이 생길 때마다 이후 처리를 위해 “누락된” 이벤트 ID가 백로그에 입력됩니다. 이렇게 하면 이벤트 데몬이 긴 데이터베이스 트랜잭션이 완료된 후 이 트랜잭션의 이벤트를 처리할 수 있습니다.실패한 트랜잭션 또는 되돌린 페이지 설정 수정과 같이 이벤트 로그 시퀀스의 간격을 채울 수 없는 경우도 있습니다. 이 경우 5분 시간 제한 후 시스템이 이벤트 로그 항목 ID 번호를 더 이상 기다리지 않고 백로그에서 제거합니다. 이렇게 되면 “백로그 이벤트 ID #에서 시간 제한이 경과됨”이라는 메시지가 표시됩니다. 이벤트 시퀀스의 간격이 처음 표시되고 이미 시간 제한을 초과한 것으로 간주되면 메시지가 “이벤트 # 발생하지 않음 - 무시 중”으로 표시되고 첫 번째 위치의 백로그에 입력되지 않습니다.플러그인 오류로 인한 백로그정상적으로 작동하는 동안 프레임워크는 항상 각 플러그인에서 처리된 마지막 이벤트를 트래킹합니다. 어떤 이유로든 실패한 플러그인이 있는 경우 추가 이벤트 처리를 중지합니다. 예를 들어 버그를 수정함으로써 플러그인을 수정하면, 마지막으로 저장된 이벤트에서 수정된 플러그인에 대한 이벤트 처리가 시작됩니다. 이 작업은 새로 수정된 플러그인이 과거에 실패와 수정 사이에 발생한 이벤트를 포함하여 모든 이벤트를 처리하도록 하기 위해 수행됩니다. 오래 전에 오류가 발생했다면 많은 이벤트를 재검토해야 할 수 있으며, 수정된 플러그인이 정상적으로 작동하던 다른 플러그인을 따라잡는 데 시간이 걸릴 수 있습니다.수정된 플러그인이 따라잡는 동안 다른 플러그인은 동일한 플러그인에 의해 단일 이벤트가 두 번 처리되지 않도록 하기 위해 이러한 이벤트를 무시합니다. 이렇게 되면 “이벤트 X가 너무 오래되었습니다. 마지막으로 처리된 이벤트는 (Y)입니다.”라는 메시지가 나타납니다. 이 메시지는 디버그 메시지이며 무시해도 됩니다.이를 회피할 수 있는 공식적인 방법은 없습니다. 이 프레임워크는 모든 단일 플러그인이 모든 이벤트를 한 번만 처리하도록 설계되었습니다. 그러나 Python과 그 pickle 데이터 형식에 익숙하다면 데몬을 중지하고 Python 인터프리터/대화식 셸로 .id 파일을 열고 해당 내용을 pickle 모듈로 디코딩하고 해당 내용을 편집하여 저장된 ID를 제거하면 누적 백로그를 건너뛸 수 있습니다. 이 방법은 지원되지 않으며 사용자 자신의 책임하에 수행해야 합니다. 이 작업을 수행하기 전에 .id 파일을 적절하게 백업하십시오.",
    "url": "/af5c969c/",
    "relUrl": "/af5c969c/"
  },
  "54": {
    "id": "54",
    "title": "이벤트 구동 트리거 작성",
    "content": "Flow Production Tracking 이벤트 프레임워크이 소프트웨어는 Rodeo Fx 및 Oblique의 지원을 받아 Patrick Boucher가 처음 개발했습니다. 이제 Flow Production Tracking 소프트웨어의 오픈 소스 이니셔티브에 포함되었습니다.이 소프트웨어는 라이선스 파일 또는 오픈 소스 이니셔티브 웹 사이트에서 찾을 수 있는 MIT 라이선스로 제공됩니다.컨텐츠:  개요  프레임워크의 이점  이벤트 구동 트리거 작성          활용 사례      이벤트 구동 트리거의 작동 방식      이벤트 로그 폴링과 트리거 비교      이벤트 유형      트랜잭션 및 잠재적 누락 이벤트      개요Flow Production Tracking 이벤트 스트림에 액세스하려면 이벤트 테이블을 모니터링하고 새로운 이벤트를 파악하여 처리하는 작업을 반복하는 것이 좋습니다.많은 항목이 성공적으로 작동하려면 이 프로세스를 거쳐야 하며, 비즈니스 규칙과 직접적인 관련이 없는 항목은 적용해야 하는지 여부를 결정해야 합니다.프레임워크의 역할은 비즈니스 로직 구현자를 대신해 따분한 모니터링 작업을 처리해 주는 것입니다.이 프레임워크는 서버에서 실행되면서 Flow Production Tracking 이벤트 스트림을 모니터링하는 데몬 프로세스입니다. 이벤트가 발견되면 데몬은 이벤트를 일련의 등록된 플러그인으로 전달합니다. 각각의 플러그인은 원하는 대로 이벤트를 처리할 수 있습니다.데몬은 다음을 처리합니다.  지정된 하나 이상의 경로에서 플러그인 등록  충돌하는 플러그인을 모두 비활성화  플러그인이 디스크에서 변경된 경우 다시 로드  Flow Production Tracking 이벤트 스트림 모니터링  마지막으로 처리된 이벤트 ID와 백로그 기억  데몬 시작 시 마지막으로 처리된 이벤트 ID부터 시작  연결 오류 확인  필요에 따라 stdout, 파일 또는 이메일에 정보 로깅  콜백에서 사용되는 Flow Production Tracking에 대한 연결 설정  등록된 콜백으로 이벤트 전달플러그인은 다음을 처리합니다.  콜백의 번호를 프레임워크에 등록  프레임워크에서 이벤트를 제공하는 경우 단일 이벤트 처리프레임워크의 이점  스크립트당이 아니라 모든 스크립트에 대해 하나의 모니터링 메커니즘만 처리합니다.  네트워크 및 데이터베이스 로드를 최소화합니다(단일 모니터만으로 여러 이벤트 처리 플러그인에 이벤트 공급).이벤트 구동 트리거 작성참고: 이벤트 구동 트리거에 대한 자세한 내용은 https://github.com/shotgunsoftware/shotgunEvents에 있는 설명서를 참조하십시오.ShotGrid는 Flow Production Tracking에서 수행된 모든 작업에 대해 이벤트 로그 항목을 작성합니다. 이 이벤트는 Flow Production Tracking 사이트와 Flow Production Tracking API를 통해 확인할 수 있습니다.ShotGrid에서 이벤트 세부 기록을 확인하는 것뿐 아니라, EventLog를 폴링하고 사용자가 관심을 두고 있는 특정 이벤트에 대해 작동하는 이벤트 리스너 스크립트를 직접 작성할 수도 있습니다. 이 스크립트는 파이프라인 내 다른 내부 스크립트를 실행하거나 Flow Production Tracking API를 사용하여 Flow Production Tracking 내 다른 정보를 업데이트할 수 있으며, 그 둘 모두도 가능합니다.활용 사례다음은 이벤트 구동 트리거의 몇 가지 활용 사례입니다.  샷의 ‘레이아웃(Layout)’ 태스크 상태가 ‘최종(final)’으로 지정되면 ‘애니메이션(Animation)’ 태스크 상태가 ‘시작 준비(ready to start)’로 자동 설정되기 때문에 애니메이터가 샷 작업을 시작할 수 있음을 알게 됩니다.  새 샷이 Flow Production Tracking에 생성되면 적절한 샷 디렉토리가 파일 시스템에 생성됩니다.  샷이 ‘대기 중(on hold)’ 상태가 되면 이 샷에 할당된 아티스트에게 알림이 전달됩니다.  자산이 마무리되면 디렉토리가 읽기 전용으로 설정됩니다.  Flow Production Tracking에서 버전이 리뷰에 추가되면 해당 버전(또는 테이크) 정보를 데일리 시스템에 복사합니다.  씬이 25개 샷으로 커지면 씬의 설명 필드에 적힌 세 번째 단어와 같은 글자로 시작하는 문구를 무작위로 트윗합니다.이벤트 구동 트리거의 작동 방식아래는 Flow Production Tracking에서 생성된 EventLogEntries의 간단한 다이어그램입니다. 스크립트는 API를 사용하여 마지막으로 요청한 이후 발생한 이벤트 목록을 가져옵니다. 그런 다음 각 이벤트 유형(예: Flow Production Tracking_Task_Change)을 살펴보고, 관심을 두고 있는 항목이 있는지 확인합니다.해당 이벤트를 찾으면 이벤트의 상세 정보(예: 변경된 필드, 변경된 값 등. 이 시점에서 API를 사용하여 필요한 엔티티에 대한 추가 정보를 요청할 수도 있음)를 확인합니다.이벤트가 유의미한 것으로 증명되면 스크립트가 해당 이벤트에 작동하여 사용자가 실행하도록 결정한 코드(Flow Production Tracking API를 사용하거나 파이프라인 내 항목을 사용하거나, 둘 다 사용할 수 있음)를 실행합니다. 살펴볼 이벤트가 더 이상 없으면 프로세스를 반복하면서 API를 사용하여 마지막으로 요청한 이후 발생한 이벤트 목록을 가져옵니다.이벤트 로그 폴링과 트리거 비교Flow Production Tracking 소프트웨어는 지속적인 이벤트 정보 스트림을 제공하며, 사용자는 이를 모두 수신하다가 원하는 이벤트에만 반응하면 됩니다. 이렇게 하면 Flow Production Tracking 소프트웨어가 트리거를 직접 제어하도록 하는 것과 비교해 다음과 같은 이점이 있습니다.  유연성: 사용자의 트리거 스크립트가 Flow Production Tracking 소프트웨어와 무관하게 실행될 수 있습니다. 덕분에 스크립트가 Flow Production Tracking 및 사용자 파이프라인 모두와 원하는 방식으로 상호 작용할 수 있습니다. 사용자는 어떠한 제약도 없이 원하는 대로 규칙 및 액션을 정의할 수 있습니다. Flow Production Tracking 소프트웨어는 사용자의 이벤트 트리거에 관해 아무것도 알 필요가 없습니다. 수행할 일이라고는 EventLogEntries를 지속적으로 생성하는 것뿐입니다. 그 뒤에 일어나는 다른 모든 일들은 사용자가 제어합니다.  원격: 사용자 스크립트가 네트워크를 통해 Flow Production Tracking 서버에 액세스할 수 있는 모든 위치에서 실행될 수 있습니다. 스크립트 실행에 필요한 것은 API 액세스뿐입니다.  다중성: 여러 스크립트를 동시에 실행할 수 있습니다. 각 부서마다 요구 사항이 서로 다르기 때문에 서로 다른 이벤트를 수신하는 경우가 있을 수 있습니다. 이런 경우에도 동일한 스크립트를 통해 모든 트리거를 실행하는 데 아무런 제약이 없습니다. 트리거를 개별적인 여러 논리 스크립트로 분할할 수도 있습니다. 폴링 쿼리는 매우 가볍기 때문에 성능에 별다른 영향을 미치지 않습니다.  책임성: 스크립트가 Flow Production Tracking에 어떤 변화를 가져오면 자체 이벤트도 생성하기 때문에 스크립트가 어떤 변화를 일으켰는지 정확하게 확인할 수 있습니다.이벤트 유형모든 내부 이벤트 유형은 Shotgun_[entity_type]_[New|Change|Retirement] 형식을 따릅니다. 예를 들어 Shotgun_Shot_New 및 Shotgun_Asset_Change가 있습니다. 자세한 내용은 이벤트 유형 문서를 참조하십시오.트랜잭션 및 잠재적 누락 이벤트Flow Production Tracking 소프트웨어는 트랜잭션에서 파괴적(destructive) 데이터베이스 쿼리를 실행하고, 트랜잭션이 완료된 경우에만 EventLog를 작성합니다. 이 때문에 여기에서 “highest ID” 방식을 사용하는 이벤트를 놓칠 수도 있습니다. 그러나 GitHub 사이트의 이벤트 트리거 프레임워크에 이 상황을 처리해 줄 코드가 있습니다.",
    "url": "/0d8a11d9/",
    "relUrl": "/0d8a11d9/"
  },
  "55": {
    "id": "55",
    "title": "Features Description",
    "content": "Isolation Feature SetThis section describes in detail each of the Isolation Features.To get the onboarding process started, go to Onboarding Process.To start the setup for any of the Isolation features, go to the Setup section.In This Section  Media Isolation  Media Traffic Isolation  Media Replication",
    "url": "/82f8da29/",
    "relUrl": "/82f8da29/"
  },
  "56": {
    "id": "56",
    "title": "파일 시스템 구성 참조",
    "content": "파일 시스템 구성 참조이 항목의 내용:  소개  1부 - 폴더 생성 구문          쿼리 폴더      다중 폴더      상위 폴더를 사용하여 만들기      선택 필드      정규식 토큰 일치      예      목록 필드 폴더      파이프라인 단계 폴더                  다양한 파이프라인 단계에 대한 다양한 파일 시스템 레이아웃                    고급 - 상위 항목 지정      태스크 폴더                  고급 - 상위 항목 지정                    작업공간 및 폴더 생성 유예      현재 사용자 폴더      정적 폴더      기호 링크      파일 및 폴더 무시      IO 및 권한 커스터마이즈                  후크에 전달된 데이터          후크에 자체 폴더 생성 지시문 전달          정적 폴더에 커스텀 구성 추가                    간단한 폴더 생성 방법 커스터마이즈        2부 - 파일 시스템 템플릿 구성          키 섹션                  예 - 영숫자 이름          예 - 버전 번호          예 - 스테레오 눈          예 - 이미지 시퀀스          예 - 별칭을 통해 버전 이름이 지정된 두 개의 필드          예 - 타임스탬프          예 - 매핑          예 - 두 개의 유효 값이 있는 문자열 필드          예 - 값 허용 안 함          예 - 문자열 하위 세트                    경로 섹션      문자열 섹션      템플릿에서 선택적 키 사용        고급 질문 및 문제 해결          파일 구조에 새 엔티티 유형을 추가하는 방법                  에피소드 &amp;gt; 시퀀스 &amp;gt; 샷 계층에 필요한 필드                          에피소드              시퀀스              샷              에피소드              툴킷 템플릿 정의                                          구조에 분기를 설정하는 방법      커스텀 파이프라인 단계를 만드는 방법      이 문서는 Flow Production Tracking Toolkit의 파일 시스템 중심 구성에 대한 완전한 참조 문서입니다. 여기에서는 템플릿 시스템 작동 방식 및 사용 가능한 옵션을 설명합니다. 또한 폴더 생성 구성에 포함할 수 있는 다양한 매개변수를 모두 보여 줍니다. 이 문서에서는 툴킷 구성에 대한 제어 권한을 갖고 있는 경우에만 사용할 수 있는 기능에 대해 설명합니다. 자세한 내용은 Flow Production Tracking 통합 관리자 안내서를 참조하십시오.소개이 문서에서는 파일 시스템과 관련된 툴킷 구성의 해당 부분을 구성하는 방법과 그 예를 설명합니다. 툴킷은 많은 파일과 디렉토리를 처리하며, 툴킷의 구성을 활용하여 경로의 결합 방법 및 의미를 표현할 수 있습니다. 일반적으로 파일 시스템은 완전히 다른 두 가지 방법으로 액세스됩니다.폴더 생성: Flow Production Tracking에서 객체를 만든 후에는 작업이 시작될 수 있도록 디스크에 폴더를 만들어야 합니다. 이 작업은 디스크에 샷을 나타내는 폴더를 생성하는 것처럼 간단할 수도 있고, 샷에 대해 작업하는 각 사용자가 디스크의 개별 영역에서 작업할 수 있도록 사용자별 작업 샌드박스를 설정하는 것처럼 복잡할 수 있습니다.  툴킷은 응용프로그램을 시작할 때(예: 샷 BECH_0010을 위해 Maya를 시작할 때) 폴더 생성을 자동화하며 Maya를 시작하기 전에 폴더가 있는지 확인합니다. 폴더가 없으면 즉시 생성됩니다. 또한 API 메서드, 쉘의 tank 명령, Flow Production Tracking의 폴더 만들기 메뉴를 통해 폴더를 생성할 수 있습니다. 이 폴더 생성 프로세스는 특별한 구성 파일 세트를 통해 진행됩니다. 자세한 정보는 아래 문서의 1부를 참조하십시오.작업 열기 및 저장: 작업하는 동안 디스크의 표준화된 위치에서 파일을 열고 저장해야 합니다. 이러한 파일 위치는 일반적으로 작업 시작 전에 만들어진 폴더 구조 내에 있습니다.  폴더 구조가 설정되면 해당 구조를 사용하여 디스크의 주요 위치를 식별할 수 있습니다. 이러한 위치를 템플릿이라고 합니다. 예를 들어 maya_shot_publish라는 템플릿을 정의하여 샷을 위해 게시된 Maya 파일을 참조할 수 있습니다. 툴킷 앱은 이 템플릿을 사용합니다. Publish 앱은 이 템플릿을 사용하여 파일을 작성해야 할 위치를 제어할 수 있으며 Workfiles 앱은 템플릿을 사용하여 파일을 열 위치를 확인할 수 있습니다. 툴킷의 환경 구성 내에서 각 앱이 사용하는 템플릿을 제어할 수 있습니다. 툴킷에서 사용되는 모든 주요 파일 위치는 단일 템플릿 파일에 정의되므로 쉽게 확인할 수 있습니다.1부 - 폴더 생성 구문폴더 구성은 Flow Production Tracking의 엔티티를 디스크의 위치에 매핑합니다. 구성은 단일 구성 파일을 사용하는 것이 아니라 구성된 각 단위의 템플릿 역할을 하는 “미니 파일 시스템” 형식입니다. 이를 스키마 구성이라고 합니다. 툴킷의 폴더 생성이 실행되면 폴더와 파일이 이 “미니 파일 시스템”에서 대상 위치로 복사됩니다. 동적 동작을 만들 수 있습니다. 예를 들어 폴더가 Flow Production Tracking에서 샷을 나타낼 수 있으며 해당 폴더의 이름 지정을 제어할 수 있습니다. 구체적으로 말하면, 여러 개의 Flow Production Tracking 필드에서 해당 폴더의 이름을 가져온 다음 폴더가 만들어지기 전에 문자 변환을 수행할 수 있습니다.위의 이미지는 스키마 구성을 보여 줍니다. 툴킷 폴더 생성을 실행하면 Flow Production Tracking의 엔티티와 디스크의 폴더 간에 연결이 설정됩니다. 툴킷은 폴더 스키마 구성을 사용하여 디스크에 일련의 폴더를 생성하고 이러한 각 폴더는 Flow Production Tracking의 Filesystem Location 엔티티로 등록됩니다. 즉, Flow Production Tracking 데이터(예: 샷 및 에셋 이름) 및 구성이 디스크 및 Flow Production Tracking의 실제 폴더에 “지정”된다고 생각할 수 있습니다. 구성은 항상 “project”라는 폴더에서 시작됩니다. 이 폴더는 항상 Flow Production Tracking의 연결된 프로젝트를 나타내며 프로젝트의 툴킷 이름으로 대체됩니다. 이 레벨 아래에는 정적 폴더가 있습니다. 폴더 작성자는 자동으로 sequences와 같은 폴더를 만듭니다.sequences 폴더 내에는 sequence 폴더와 sequence.yml 파일이 있습니다. 툴킷은 폴더와 같은 이름을 가진 YAML 파일을 발견할 때마다 YAML 파일의 컨텐츠를 읽고 원하는 동적 동작을 추가합니다. 이 경우, sequence.yml 파일에는 project 폴더 아래 세 가지 유형의 항목으로 구성된 구조가 있습니다.  일반 폴더 및 파일: 대상 위치로 간단히 복사됩니다.  YAML 파일이 있는 폴더(폴더와 같은 이름): 동적 컨텐츠를 나타냅니다. 예를 들어, shot 및 shot.yml이 있을 수 있으며 폴더가 생성될 때 이 shot 폴더는 여러 폴더(샷당 하나의 폴더)를 생성하는 데 사용되는 템플릿입니다.  name.symlink.yml 파일은 폴더가 처리될 때 기호 링크를 생성합니다. 기호 링크는 이 문서의 뒷부분에서 설명합니다.현재 YAML 파일에 표시된 동적 구성 설정은 다음 모드를 지원합니다.      Flow Production Tracking 쿼리 폴더: Flow Production Tracking 데이터베이스 쿼리를 기반으로 하는 동적 폴더 이름입니다. 예를 들어 이 모드는 프로젝트의 모든 샷에 대한 폴더를 생성하는 데 사용할 수 있습니다.        Flow Production Tracking 목록 필드 폴더: Flow Production Tracking 목록 필드를 기반으로 하는 동적 폴더 이름입니다. 예를 들어 이 모드는 Flow Production Tracking의 에셋 엔티티에 있는 Flow Production Tracking 목록 필드 “Asset Type”의 모든 값에 대한 폴더를 만드는 데 사용할 수 있습니다.        유예된 폴더: 툴킷 API의 폴더 생성 방식을 통해 두 번째 폴더 생성 패스가 요청될 때(일반적으로 Maya와 같은 응용프로그램이 시작될 때)만 실행됩니다. 일반적으로 이 방식은 응용프로그램을 시작하기 직전에 툴킷의 다양한 응용프로그램 시작 관리자에 의해 실행됩니다.        현재 사용자 폴더: 현재 사용자를 나타내는 특수 폴더입니다.  이러한 모드에 대해 자세히 살펴보겠습니다.쿼리 폴더Flow Production Tracking 쿼리에 해당하는 동적 폴더의 경우 YAML 파일에서 다음 구문을 사용합니다.# the type of dynamic contenttype: shotgun_entity# the Flow Production Tracking entity type to connect toentity_type: Asset# the Flow Production Tracking field to use for the folder namename: code# Flow Production Tracking filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std Flow Production Tracking API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]   동적 컨텐츠 type 필드의 값을 shotgun_entity로 설정합니다.  entity_type 필드는 데이터를 가져올 Flow Production Tracking 엔티티(예: “에셋”, “샷”, “시퀀스”, “CustomEntity02” 등)로 설정해야 합니다.      name 필드는 Flow Production Tracking의 데이터를 기반으로 각 폴더에 지정해야 하는 이름입니다.    위의 예와 같이 단일 필드를 사용할 수 있습니다(예: name: code).  여러 필드를 괄호로 묶어 사용할 수 있습니다(예: name:&quot;{asset_type}_{code}&quot;).  링크된 다른 엔티티의 필드를 포함하려면 표준 Flow Production Tracking 점 구문을 사용할 수 있습니다(예: name: &quot;{sg_sequence.Sequence.code}_{code}&quot;).  filters 필드는 Flow Production Tracking 쿼리이며 Flow Production Tracking API 구문을 비슷하게 따릅니다. 이는 사전 목록이며 각 사전에는 path, relation 및 values 키가 있어야 합니다. 유효한 $syntax 값은 상응하는 Flow Production Tracking 엔티티(예: 프로젝트의 경우 &quot;$project&quot;, sequence.yml이 상위 디렉토리 계층에 있는 경우 &quot;$sequence&quot;)가 있는 모든 상위 폴더입니다. Flow Production Tracking 엔티티 링크의 경우 $syntax(예: { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] })를 사용하여 구성에서 상위 폴더를 참조할 수 있습니다. 아래 예에서 자세히 설명합니다.다중 폴더한 번에 여러 폴더를 만드는 표현식을 만들려면 이름 정의에 슬래시를 포함합니다.# the type of dynamic contenttype: shotgun_entity# the Flow Production Tracking entity type to connect toentity_type: Asset# the Flow Production Tracking field to use for the folder namename: &quot;{sg_asset_type}/{code}&quot;# Flow Production Tracking filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std Flow Production Tracking API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ] 이러한 종류의 경로에 대한 파일 시스템 템플릿(자세한 정보는 이 문서의 2부 참조)을 만들 때 마지막 폴더는 Flow Production Tracking 엔티티를 나타냅니다. 예를 들어 위의 예는 다음 템플릿으로 표현될 수 있습니다.asset_step_folder: assets/{asset_type}/{Asset}/{Step}{asset_type} 및 {Asset}은 모두 문자열 템플릿 키로 정의되며 {Asset} 토큰은 지정된 경로의 컨텍스트를 결정할 때 컨텍스트 계산에서 사용합니다.상위 폴더를 사용하여 만들기ShotGrid에서는 Flow Production Tracking 데이터 구조 내에 중첩이 있습니다. 이 중첩은 상위-하위 또는 하위-상위 관계일 수 있습니다. 예를 들어 시퀀스는 일반적으로 파일 시스템에서 샷에 대한 상위 항목이며, 마찬가지로 샷은 일반적으로 시퀀스의 하위 항목입니다.                    참고: 이 파일 시스템 중첩 관계는 Flow Production Tracking 계층과는 별개이며 서로 연결되어 있지 않습니다. 이들은 완전히 독립적으로 구성됩니다.    shotgun_entity 유형 폴더는 폴더 생성 프로세스에서 상위 항목을 만들 때 하위 항목도 만들어지도록 반복할지 여부를 제어하는 선택적 플래그를 지원합니다. 플래그는 특정 고정 값(이 경우 “true” 또는 “false”)만을 지정할 수 있는 설정입니다. 이 플래그를 추가하려면 다음 예를 사용합니다.# recurse down from parent foldercreate_with_parent: true 언급한 바와 같이 이 설정은 선택 사항이며 기본적으로 false로 설정됩니다. true로 설정하면 툴킷에서 검색되는 모든 하위 엔티티에 대한 폴더를 만듭니다. 예를 사용하여 계속 진행하려면 상위 시퀀스가 만들어질 때마다 샷을 만들려면 샷에 대해 create_with_parent를 true로 설정합니다.                    참고: 기본 설정은 false입니다. 즉, 시퀀스에 대해 폴더를 만들어도 샷 폴더가 자동으로 만들어지지 않습니다. 마찬가지로 true로 설정하려면 이 플래그를 추가해야 합니다. false는 기본 동작이므로 shotgun_entity 폴더에는 false를 지정하는 플래그가 없습니다.    선택 필드일반적으로 폴더 이름을 정의(예: {code}_{sg_extra_field})할 때, 툴킷에서는 모든 필드의 값이 Flow Production Tracking에 있어야 합니다. 예를 들어 sg_extra_field가 비어 있으면 오류 메시지가 생성됩니다. 필드가 채워질 수도 있고 채워지지 않을 수도 있다면 해당 필드를 선택 필드로 만듭니다. 즉, 툴킷에서는 값이 있으면 필드가 포함되고 값이 오류 없이 공백이면 제외됩니다.선택 필드는 {code}[_{sg_extra_field}]와 같이 대괄호를 사용하여 정의합니다. 이렇게 하면 다음 폴더 이름이 생성됩니다.  code가 BECH_0010이고 sg_extra_field가 extra인 경우 폴더 이름은 BECH_0010_extra가 됩니다.  code가 BECH_0010이고 sg_extra_field가 비어 있는 경우 폴더 이름은 BECH_0010가 됩니다.                    참고: 선택 필드는 스키마에서 폴더 이름의 일부를 정의하는 데만 사용할 수 있습니다. 전체 폴더를 선택 필드로 지정할 수는 없습니다.    정규식 토큰 일치툴킷을 통해 정규식을 사용하여 Flow Production Tracking 필드 이름의 일부를 추출할 수 있습니다. 이렇게 하면 Flow Production Tracking의 값으로 폴더 생성을 유도할 수 있는 간단한 표현식을 만들 수 있습니다. 예를 들어 Flow Production Tracking의 모든 에셋 이름이 세 문자 접두어와 밑줄로 지정되면(예: AAT_Boulder7) 두 개의 파일 시스템 폴더 수준으로 나눌 수 있습니다(예: AAT/Boulder7).# the type of dynamic contenttype: shotgun_entity# the Flow Production Tracking entity type to connect toentity_type: Asset# Extract parts of the name using regular expressionsname: &quot;{code:^([^_]+)}/{code^[^_]+_(.*)}&quot;# Flow Production Tracking filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std Flow Production Tracking API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]구문은 템플릿 시스템의 subset 토큰과 유사합니다. Flow Production Tracking 필드 이름 다음에 콜론에 이어서 일반 표현식을 추가하기만 하면 됩니다. 정규식으로 정의된 모든 그룹(예: ()로 둘러싸인 섹션)은 값을 추출하는 데 사용됩니다. 정규식에 여러 그룹이 있는 경우 이 그룹이 함께 연결됩니다. 예를 들어 다음 표현식은 객체를 만든 사용자의 이니셜을 추출합니다. {created_by.HumanUser.code:^([A-Z])[a-z]* ([A-Z])[a-z]*}예다음은 필터 구문을 사용하는 방법을 보여 주는 사례 모음입니다.현재 프로젝트에 속해 있고 진행 중인 모든 샷을 찾으려면 아래 구문을 사용합니다. Flow Production Tracking 샷 엔티티에는 샷을 프로젝트에 연결하는 project라는 링크 필드가 있습니다. 현재 프로젝트와 연결된 샷의 폴더만 만들려고 합니다. 구성 파일 시스템에서 프로젝트 수준이 더 높기 때문에 $syntax를 통해 이를 참조할 수 있으며, 여기에 툴킷은 자동으로 Flow Production Tracking 엔티티 링크 참조를 만듭니다. 유효한 $syntax 값은 상응하는 Flow Production Tracking 엔티티(예: 프로젝트의 경우 &quot;$project&quot;, sequence.yml이 상위 디렉토리 계층에 있는 경우 &quot;$sequence&quot;)가 있는 모든 상위 폴더여야 합니다.entity_type: Shotfilters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;status&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;ip&quot; ] }트리의 상위에 시퀀스 폴더가 있고 해당 시퀀스에 속한 모든 샷에 대한 폴더를 만들려면 다음과 같은 필터를 만들 수 있습니다.entity_type: Shotfilters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] }모든 에셋을 찾으려면 이 구문을 사용합니다.entity_type: Assetfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]목록 필드 폴더예를 들어 Flow Production Tracking 목록 필드 폴더는 Flow Production Tracking의 모든 에셋 유형에 대해 하나의 폴더를 생성하려는 경우에 유용합니다. 에셋 유형은 Flow Production Tracking의 목록 필드이며 이 폴더 구성 유형을 사용하면 이러한 에셋 유형 목록이 반영된 파일 시스템의 계층을 정의할 수 있습니다.                    참고: 디스크에 폴더가 생성되면 연결된 데이터의 값(예: 에셋 유형)을 변경하지 않을 것을 강력히 권고합니다.    Flow Production Tracking 목록 필드의 모든 항목에 해당하는 동적 폴더의 경우 YAML 파일에서 다음 구문을 사용합니다.# the type of dynamic contenttype: &quot;shotgun_list_field&quot;# the Flow Production Tracking entity type to connect toentity_type: &quot;Asset&quot;# only create for values which are used in this project.# this is optional and will be set to false if not specified.skip_unused: false# by default, list fields are only created if they are needed by a child entity node# by setting the create_with_parent parameter to true you ensure that list field# nodes are always createdcreate_with_parent: false# the Flow Production Tracking field to use for the folder namefield_name: &quot;{sg_asset_type}_type&quot;  동적 컨텐츠 type 필드의 값을 shotgun_list_field로 설정합니다.  entity_type 필드는 데이터를 가져올 Flow Production Tracking 엔티티(예: “에셋”, “시퀀스”, “샷” 등)로 설정해야 합니다.      field_name 필드는 데이터를 가져온 Flow Production Tracking 필드로 설정해야 하며 목록 유형 필드여야 합니다. 표현식을 사용하여 정적 텍스트를 동적 컨텐츠와 함께 추가할 수 있습니다.field_name: &quot;{sg_asset_type}_type&quot; 이 표현식 예는 텍스트와 템플릿 키를 포함합니다.    선택적 skip_unused 매개변수는 사용되지 않는 목록 유형 필드 값에 대해 디렉토리가 생성되는 것을 방지합니다(위의 선택 필드 섹션 참조).                    참고: 이 값을 True로 설정하면 폴더 생성 성능에 부정적인 영향을 줄 수 있습니다. 또한, 컬링 알고리즘은 현재 완전하지 않아 관련 엔티티에 복잡한 필터가 적용된 시나리오에서는 작동하지 않습니다.      선택적 create_with_parent 매개변수는 현재 처리 중인 하위 엔티티 레벨 노드가 없는 경우에도 list_field 노드를 만듭니다(위의 상위 폴더를 사용하여 만들기 섹션 참조).파이프라인 단계 폴더파이프라인 단계 폴더는 Flow Production Tracking의 파이프라인 단계를 나타냅니다. 파이프라인 단계는 단계라고도 합니다.# the type of dynamic contenttype: &quot;shotgun_step&quot;# the Flow Production Tracking field to use for the folder name. This field needs to come from a step entity.name: &quot;short_name&quot;여기에서는 위에서 설명한 Flow Production Tracking 엔티티와 같은 방식으로 이름 표현식을 사용할 수 있습니다. 노드는 Flow Production Tracking 엔티티 폴더 구성을 찾을 때까지 상위, 최상위 항목을 검색합니다. 이 엔티티 폴더는 단계와 연관되며 엔티티의 유형은 작성할 단계를 결정하는 데 사용됩니다.                    참고: 파이프라인 단계가 있는 최상위 폴더를 만들려면 Flow Production Tracking 엔티티 노드를 사용하여 관련 유형을 단계로 설정합니다.    기본적으로 단계 폴더는 특정 엔티티에 대한 모든 관련 단계를 자동으로 만들려고 합니다. 예를 들어 5단계(레이아웃, 애니메이션, FX, 조명, 합성)가 있는 샷에 대해 폴더 생성이 트리거되면 5단계(레이아웃, 애니메이션, FX, 조명, 합성)에 대한 단계 폴더가 자동으로 만들어집니다.그러나 다음 구문을 사용하여 이 기능을 끌 수 있습니다.# recurse down from parent foldercreate_with_parent: false이 설정을 구성에 추가하면 샷 폴더를 만들 때 단계 폴더가 만들어지지 않습니다. 대신, 단계 폴더는 태스크에서 폴더 만들기를 실행할 때만 만들어집니다. 이 방법은 작업을 시작하기 직전에 만들어지는 사용자 샌드박스 및 기타 구조를 구성하려는 경우 유용할 수 있습니다.다양한 파이프라인 단계에 대한 다양한 파일 시스템 레이아웃조명 및 Comp(합성)에 대해 하나의 폴더 구조를 만들고, 다른 모든 폴더에 대해 하나의 폴더 구조를 만든다고 가정합니다. 여러 파이프라인 단계에 서로 다른 파일 시스템 레이아웃을 사용하려면 filter 절을 구성에 추가합니다. 이 필터를 사용하면 특정 단계의 구성에서 처리할 파이프라인 단계의 범위를 지정할 수 있습니다. 이 예에서는 두 개의 구성 파일 step_lightcomp.yml 및 step.yml을 만들 수 있습니다. 첫 번째 파일에서는 다음 필터를 추가합니다.filters: [ { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;in&quot;, &quot;values&quot;: [ &quot;Light&quot;, &quot;Comp&quot;  ] } ] 위의 구문은 Light 또는 Comp 유형의 단계 폴더가 만들어질 때만 사용됩니다. 다른 파일의 경우 다른 모든 항목에 대한 규칙을 만들려고 합니다.filters: [ { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;not_in&quot;, &quot;values&quot;: [ &quot;Light&quot;, &quot;Comp&quot;  ] } ]이제 이러한 각 폴더에서 별도의 하위 구조를 정의할 수 있습니다.고급 - 상위 항목 지정폴더 생성 중 툴킷은 파이프라인 단계를 엔티티(예: “샷”, “에셋” 등)와 연결해야 합니다. 기본적으로 툴킷은 폴더 트리를 검색하고 찾은 첫 번째 Flow Production Tracking 엔티티 폴더를 선택하여 이 작업을 수행합니다. 예를 들어 Sequence &amp;gt; Shot &amp;gt; Step 계층이 있는 경우, 일반적으로 원하는 대로 단계 폴더가 자동으로 샷과 연결됩니다.그러나 기본 엔티티 아래에 엔티티가 있는 계층(예: Sequence &amp;gt; Shot &amp;gt; Department &amp;gt; Step)에서는 기본적으로 단계가 부서 레벨과 연관되는데 이는 바람직하지 않습니다. 이 경우 찾을 위치를 툴킷에 명시적으로 지정해야 합니다. 단계 구성에 다음을 추가하여 이를 수행할 수 있습니다.associated_entity_type: Shot태스크 폴더작업 폴더는 Flow Production Tracking의 태스크를 나타냅니다. 기본적으로 태스크 폴더는 상위 폴더와 함께 만들어지지 않습니다. 예를 들어 태스크 노드가 연결된 샷에 대해 폴더 생성이 트리거되면 태스크 폴더가 자동으로 만들어지지 않습니다. 대신, 태스크 폴더는 태스크에 대해 폴더 생성이 실행될 때(예: Flow Production Tracking에서 태스크 시작)에만 만들어집니다.# the type of dynamic contenttype: &quot;shotgun_task&quot;# the Flow Production Tracking field to use for the folder name. This field needs to come from a task entity.name: &quot;content&quot; 그러나 다음 구문을 사용하여 상위 엔티티와 함께 태스크가 만들어지도록 생성을 켤 수 있습니다.# recurse down from parent foldercreate_with_parent: true단계와 마찬가지로, 폴더 구성이 작동해야 하는 태스크를 필터링하려면 선택적으로 filter 매개변수를 제공할 수도 있습니다.위에서 설명한 Flow Production Tracking 엔티티에서와 마찬가지로 이름 표현식을 사용할 수 있습니다. 여기서 동적 컨텐츠와 함께 정적 텍스트를 사용하여 동적 컨텍스트와 정적 컨텍스트를 모두 가진 이름을 만들 수 있습니다.name: &quot;task_{content}&quot;노드는 Flow Production Tracking 엔티티 폴더 구성을 찾을 때까지 상위, 최상위 항목을 검색합니다. 이 엔티티 폴더는 태스크와 연결되며 만들 태스크 폴더를 결정하는 데 사용됩니다.고급 - 상위 항목 지정폴더 생성 중 툴킷은 태스크를 엔티티(예: 샷, 에셋 등)와 연결해야 합니다. 기본적으로 툴킷은 폴더 트리를 검색하고 찾은 첫 번째 Flow Production Tracking 엔티티 폴더를 선택하여 이 작업을 수행합니다. 예를 들어 Sequence &amp;gt; Shot &amp;gt; Task 계층이 있는 경우, 일반적으로 원하는 대로 태스크 폴더가 자동으로 샷과 연결됩니다.그러나 기본 엔티티(예: 샷) 아래에 엔티티가 있는 계층(예: Sequence &amp;gt; Shot &amp;gt; Department &amp;gt; Task,)에서는 툴킷이 기본적으로 태스크가 부서 레벨과 연관되는데 이는 바람직하지 않습니다. 이 경우 이전 섹션의 단계로 업데이트하는 방법과 같이 찾을 위치를 툴킷에 명시적으로 지정해야 합니다. 태스크 구성에 다음을 추가하여 이 작업을 수행할 수 있습니다.associated_entity_type: Shot작업공간 및 폴더 생성 유예폴더 생성 유예란 툴킷 API의 폴더 생성 방식에서 선택적 engine 매개변수를 통해 두 번째 폴더 생성 패스가 요청된 경우에만 생성이 실행됨을 의미합니다. 일반적으로 이 방식은 응용프로그램을 시작하기 직전에 툴킷의 다양한 응용프로그램 시작 관리자에 의해 실행됩니다. 대부분의 폴더 유형은 유예됨 플래그(기본적으로 false)를 지원합니다. 폴더 생성 유예를 true로 설정하려면 이 플래그를 추가합니다.# only create this folder when tk.create_filesystem_structure is# called with tk-maya, tk-nuke or any-custom-string.defer_creation: [&quot;tk-maya&quot;, &quot;tk-nuke&quot;, &quot;any-custom-string]# create this folder when any application launches, but not when normal folder# creation runsdefer_creation: true이 플래그를 사용하면 첫 번째 “전역” 패스에서 실행되는 절반 부분과 나중에 두 번째 패스에서 실행되는 부분으로 폴더 생성을 분리할 수 있습니다. 일반적으로 두 번째 패스는 기본값이 false이기 때문에 자동으로 수행되지는 않지만 엔진 시작과 관련되어 있으므로 엔진이 시작되기 직전에 사용자가 폴더를 만들 수 있습니다. 이렇게 하면 두 가지 기본 워크플로우가 허용됩니다.  작업공간: 응용프로그램별 폴더 설정입니다. 응용프로그램이 시작되기 직전에 폴더를 만들 수 있습니다.  이를 위한 일반적인 워크플로우에는 샷에 필요한 항목과 아티스트가 선택하는 처리 방법에 따라 Houdini, Maya 및 다른 엔진이 필요한 파이프라인 단계가 있습니다. 아티스트는 처음에 해당 파이프라인 단계에 대해 maya/, houdini/ 및 기타 디렉토리를 만들 수 있지만 지정된 샷의 아티스트가 Maya에서만 계속 작업하는 경우 Houdini 및 기타 다른 엔진의 빈 폴더는 필요하지 않습니다. 따라서 개별 엔진 시작 시점에 발생하는 폴더 생성을 유예하는 경우 아티스트가 Houdini를 사용하지 않는다면 해당 샷에 대해 houdini/ 폴더가 생성되지 않습니다.  사용자 폴더: 사용자 폴더는 응용프로그램 시작 직전에 만들어집니다. 위에서 설명한 사용자 폴더 구성 구조는 기본적으로 유예됩니다.  이렇게 하면 Flow Production Tracking에서 할당된 사용자를 기반으로 하는 사용자 폴더 대신 엔진을 시작할 때마다 현재 사용자에 대한 폴더를 만들 수 있습니다. 예를 들어 샷에서 작업을 시작하고 Maya를 시작하면 사용자 이름 폴더가 Flow Production Tracking의 사용자 이름을 기반으로 만들어지고 다른 사용자 작업에 영향을 주지 않습니다.팁: Maya와 같은 응용프로그램이 시작될 때 일반적이고 정적인 폴더를 만들려면 폴더와 동일한 이름의 구성 YAML 파일을 만들고 다음을 추가합니다.# type of contenttype: &quot;static&quot;# only create this folder for mayadefer_creation: &quot;tk-maya&quot;# type of contenttype: &quot;static&quot;# only create this folder when tk.create_filesystem_structure is# called with any-custom-string.defer_creation: &quot;any-custom-string&quot; 현재 사용자 폴더현재 사용자 폴더는 다른 사용자의 작업 영역을 설정할 수 있도록 하는 특수한 구성입니다. 일반적인 시나리오는 한 부서에서 근무하는 여러 아티스트가 같은 샷에 대해 작업하는 경우입니다. 아티스트가 자신의 디렉토리에 작업 파일을 저장할 수 있으므로 사용자 폴더가 사용될 수 있으며 Workfiles 앱에서 자신의 파일에 대해서만 필터링할 수 있습니다. 이 경우 구성 파일에 다음 옵션이 포함되어야 합니다.# the type of dynamic contenttype: &quot;user_workspace&quot;name: &quot;login&quot;  type 필드의 값을 user_workspace로 설정합니다.  name 필드는 사용자 폴더에 지정해야 하는 이름입니다. Flow Production Tracking의 작업자(People)에서 가져온 필드(ShotGrid의 HumanUser)의 조합으로 구성되어야 합니다.  위의 예와 같이 단일 필드를 사용할 수 있습니다(예: name: login).  여러 필드를 괄호로 묶어 사용할 수 있습니다(예: name: &quot;{firstname}_{lastname}&quot;).  링크된 다른 엔티티의 필드를 포함하려면 표준 Flow Production Tracking 점 구문을 사용할 수 있습니다(예: name: &quot;{sg_group.Group.code}_{login}&quot;).현재 사용자 폴더는 기본적으로 유예된 폴더로 만들어집니다. 즉, 툴킷 API의 폴더 생성 메서드에서 선택적 매개변수인 engine을 통해 두 번째 폴더 생성 패스가 요청된 경우에만 생성이 실행됩니다.정적 폴더정적 폴더(및 파일)는 가장 간단한 유형입니다. 폴더를 구성 구조에 놓을 수 있으며 폴더 생성 프로세스가 실행될 때 자동으로 복사됩니다. 다음은 정적 폴더의 몇 가지 예(https://github.com/shotgunsoftware/tk-config-default/tree/master/core/schema/project)이며 이는 기본 구성에 있습니다(정적 폴더에는 해당 YAML 파일이 없음).대개 정적 폴더에서는 이 작업 이외에 수행해야 할 작업이 없지만, 툴킷은 정적 폴더에 대한 몇 가지 고급 기능을 지원합니다. 동적 조건을 정의하여 정적 폴더를 만들지 여부를 결정할 수 있습니다. 예를 들어 편집 유형의 파이프라인 단계에 대해서만 생성되는 특별한 정적 폴더가 필요할 수 있습니다. 이 경우 정적 폴더 옆에 YAML 구성 파일을 추가하고 동일한 이름(확장자는 “yml”)을 지정해야 합니다. 이제 다음 구문을 사용합니다.# the type of dynamic contenttype: &quot;static&quot;# pick one of the Flow Production Tracking folders that are above this folder# in the folder hierarchy. In this case it is a parent folder# named step that we want to look at when deciding if this# static folder should be created or not.constrain_by_entity: &quot;$step&quot;# we can now define constraints for this step. Constraints are simple# Flow Production Tracking queries, following the same syntax as the other Flow Production Tracking filters# shown in previous sections.# In our example, if the parent step matches the constraints given# in the filter below, the static folder will be created. If not,# it (and its children) will be ignored by the folder creation process.constraints:    - { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;edit&quot; ] } 기본적으로 정적 폴더는 상위 폴더와 함께 자동으로 만들어집니다. 이렇게 되는 것을 원하지 않을 수 있으며, 그럴 경우 정적 폴더가 상위 폴더와 함께 만들어지지 않도록 특수 플래그를 추가합니다.# do not recurse down automaticallycreate_with_parent: false기호 링크동적 폴더 생성 중에 기호 링크(symlink)를 만들 수 있습니다. 이름이 artwork인 기호 링크를 만들려면 스키마 구성에서 artwork.symlink.yml이라는 파일을 만듭니다. 이 파일은 시스템에서 기호 링크 요청으로 식별되며 복사되지 않는 대신 처리됩니다.artwork.symlink.yml 파일에는 적어도 target 키가 포함되어야 합니다.# Example of a .symlink.yml file# A target parameter is required.target: &quot;../Stuff/$Project/$Shot&quot;# Additional parameters will be passed to the hook as metadata# so you can for example include permission hints or other stuff# that you may need for advanced customizationadditional_param1: abcadditional_param2: def 대상 매개변수에 $Asset, $Shot 또는 $Project 등의 $EntityType 토큰이 포함되면 해당 엔티티(에셋, 샷, 프로젝트 등)를 나타내는 폴더의 이름으로 확인하려고 시도합니다. 툴킷은 파일 시스템 트리에서 이러한 값을 검색하고 트리에서 상위 항목으로 정의되지 않은 경우 오류가 보고됩니다.에셋의 에셋 유형과 같은 목록 필드는 엔티티 유형을 포함하는 구문으로 표현됩니다(예: $Asset.sg_asset_type). 예를 들면 다음과 같습니다.# Example of a .symlink.yml file# A target parameter is required.target: &quot;../renders/$Project/$Asset.sg_asset_type/$Asset&quot;기호 링크 생성은 모든 입력/출력 또는 I/O와 같이 폴더 처리 후크 내부에서 발생합니다. 특별한 symlink액션이 시스템에서 후크로 전달되면 기호 링크의 이름, 완전히 확인된 대상 그리고 이 요청과 함께 정의 파일에 포함된 모든 YAML 메타데이터를 가져옵니다. 위의 artwork예의 경우 샷 아래에 다음과 같은 폴더를 만듭니다. {'action': 'symlink',  'path': '/mnt/projects/chasing_the_light/Sequences/AA/AA001/artwork'  'target': '../Stuff/chasing_the_light/AA001',  'metadata': {'target': '../Stuff/$Project/$Shot', 'additional_param1': 'abc', 'additional_param2': 'def'}  }파일 및 폴더 무시스키마 스캐폴드에 배치된 파일은 폴더 생성 중에 대상 영역으로 복사됩니다. 이 복사 프로세스는 코어 후크에 의해 처리되므로 예를 들어 프로젝트 또는 스튜디오에 대한 권한 처리를 커스터마이즈할 수 있습니다.                    참고: 이 유형의 처리에 대한 자세한 내용은 간단한 커스터마이즈 아래의 I/O 및 권한 커스터마이즈 섹션I/O 및 권한 커스터마이즈 섹션을 참조하십시오. 많은 폴더 설정을 처리하는 process_folder_creation 코어 후크(https://github.com/shotgunsoftware/tk-core/blob/master/hooks/process_folder_creation.py#L62-L71)가 있습니다. 이 후크에 chmod 호출을 추가하여(및/또는 mkdir 시 권한 설정) 만드는 폴더에 대한 권한을 설정할 수 있습니다.    폴더 생성 중에 특정 파일 및 폴더를 복사 대상에서 제외하려는 경우에도 유용할 수 있습니다. 예를 들어 Git 또는 SVN에 폴더 생성 구성을 저장하는 경우 각 샷 또는 에셋 폴더로 복사하지 않으려는 .git 및 .svn 폴더가 있습니다. 복사하지 않으려는 파일이 있는 경우 ignore_files 파일을 프로젝트 구성 내의 config/core/schema 폴더에 놓을 수 있습니다. 이 파일에는 복사하지 않을 파일을 정의하는 전역 스타일의 패턴이 있어야 합니다. 각 패턴은 별도의 줄에 있어야 합니다.# This is a good example of a standard ignore_files file.svn                # no svn temp files to be copied across at folder creation time.git                # no git temp files to be copied across at folder creation time.DS_Store           # no mac temp files to be copied across at folder creation time와일드카드를 사용할 수도 있습니다. 예를 들어 TMP 익스텐션이 있는 모든 파일을 제외해야 하는 경우 *.tmp 행을 파일에 추가하기만 하면 됩니다.# This is a good example of a standard ignore_files file.svn                # no svn temp files to be copied across at folder creation time.git                # no git temp files to be copied across at folder creation time*.tmp           # no files with tmp extension to be copied across at folder creation timeIO 및 권한 커스터마이즈샷 및 에셋 폴더를 특별한 권한 및 매개변수를 사용하여 만들어야 하는 경우가 많이 있습니다. 이 작업은 폴더 생성 중에 권한 비트를 설정하는 것처럼 간단할 수도 있고, 적절한 자격 증명, 그룹 및 권한이 있는 폴더를 만드는 특정 폴더 생성 서버에 원격 요청을 보내는 것처럼 복잡할 수도 있습니다.또한 파일 시스템 트리 내 다양한 수준의 폴더가 서로 다른 권한을 가져야 하는 경우가 일반적입니다. 작업 영역 폴더는 일반적으로 모든 사람에게 쓰기 권한이 있지만 샷 폴더는 훨씬 더 엄격한 권한이 있을 수 있습니다.툴킷을 사용하면 단일 후크를 통해 폴더 생성을 커스터마이즈할 수 있습니다. 이는 코어 후크이며 이름은 process_folder_creation.py입니다. 폴더 생성 API 호출은 폴더 구성을 탐색하여 만들어야 하는 폴더를 결정할 때 만들 수 있는 항목 목록을 작성합니다. 이러한 항목은 파일일 수도 있고 폴더일 수 있습니다. 폴더 생성의 마지막 단계로 이 목록이 실제 폴더 프로세싱을 처리하기 위해 후크로 전달됩니다. 기본 process_folder_creation 코어 후크는 여기(https://github.com/shotgunsoftware/tk-core/blob/master/hooks/process_folder_creation.py#L62-L71)에서 검토할 수 있습니다.후크에 전달된 데이터폴더 생성 후크는 각 폴더 생성 요청에 대해 한 번만 실행됩니다. 목록의 모든 폴더 생성 데이터는 후크로 전달되며 후크는 일반적으로 이 작업을 반복하고 Core API에서 전달된 매개변수에 따라 폴더를 만듭니다.목록의 데이터는 항상 깊이를 우선하여 반복되며 최상위 레벨의 폴더 및 파일부터 시작하여 점점 더 깊게 이동합니다. 다음 예에서 후크에 전달된 데이터를 보여 줍니다.    [         {'action': 'entity_folder',      'entity': {'id': 88, 'name': 'Chasing the Light', 'type': 'Project'},      'metadata': {'root_name': 'primary', 'type': 'project'},      'path': '/mnt/projects/chasing_the_light'},         {'action': 'folder',      'metadata': {'type': 'static'},      'path': '/mnt/projects/chasing_the_light/sequences'},         {'action': 'entity_folder',      'entity': {'id': 32, 'name': 'aa2', 'type': 'Sequence'},      'metadata': {'entity_type': 'Sequence',                   'filters': [{'path': 'project',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04c90&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'path': '/mnt/projects/chasing_the_light/sequences/aa2'},         {'action': 'entity_folder',      'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'},         {'action': 'copy',      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'source_path': '/mnt/software/tank/chasing_the_light/config/core/schema/project/sequences/sequence/shot/sgtk_overrides.yml',      'target_path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87/sgtk_overrides.yml'},         {'action': 'create_file',      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'content': 'foo bar',      'target_path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87/automatic_content.txt'},         {'action': 'symlink',      'path': '/mnt/projects/chasing_the_light/Sequences/AA/AA001/artwork'      'target': '../Stuff/chasing_the_light/AA001',      'metadata': {'target': '../Stuff/$Project/$Shot', 'additional_param1': 'abc', 'additional_param2': 'def'}      },        ]데이터는 사전 목록입니다. 각 사전에는 action이라는 키가 있습니다. 이 키는 요청된 I/O 항목의 유형을 나타냅니다. 폴더 생성 후크를 구현하는 경우 다음과 같은 다양한 액션에 대한 지원을 추가해야 합니다.  entity_folder: Flow Production Tracking 엔티티와 관련된 디스크상의 폴더  folder: 디스크상의 폴더  copy: 소스 위치에서 대상 위치로 복사해야 하는 파일  create_file: 디스크에 만들어야 하는 파일  symlink: 만들어야 하는 기호 링크각각의 액션에는 각기 다른 사전 키 집합이 있습니다. 예를 들어 entity_folder 액션에는 연결된 엔티티의 상세 정보를 포함하는 entity key가 있습니다. create_file에는 source_path 및 target_path 키가 있으며, 이 키를 통해 후크에서 복사할 파일과 위치를 알 수 있습니다.또한 모든 actions에는 metadata라는 키가 있습니다. 이 키는 스키마 설정의 관련 구성 파일에서 가져온 YAML 구성 데이터를 나타냅니다. 위의 예에서 스키마 구성 내에 설정된 모든 필터 및 이름 지정 정보가 Flow Production Tracking 폴더의 metadata 키에 어떻게 포함되어 있는지 볼 수 있습니다. 예를 들어 위의 예에서 샷 폴더의 메타데이터는 다음과 같습니다.    {'action': 'entity_folder',      'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'} …shot.yml 스키마 구성 파일에 해당합니다.# Copyright (c) 2013 Flow Production Tracking Software Inc.## CONFIDENTIAL AND PROPRIETARY## This work is provided &quot;AS IS&quot; and subject to the Flow Production Tracking Toolkit# Source Code License included in this distribution package. See LICENSE.# By accessing, using, copying or modifying this work you indicate your# agreement to the Flow Production Tracking Toolkit Source Code License. All rights# not expressly granted therein are reserved by Flow Production Tracking Software Inc.# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the Flow Production Tracking field to use for the folder namename: &quot;code&quot;# the Flow Production Tracking entity type to connect toentity_type: &quot;Shot&quot;# Flow Production Tracking filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std Flow Production Tracking API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ] 동적 토큰 $sequence는 런타임에 실제 객체로 해석되었습니다.후크에 자체 폴더 생성 지시문 전달툴킷에서 필요로 하는 다양한 구성 지시문 외에도 스키마 구성의 일부로 고유한 구성 항목을 정의할 수도 있습니다. 이러한 항목은 위에서 설명한 metadata 키를 통해 후크로 전달되며 폴더 생성을 유도하는 데 사용할 수 있습니다.예를 들어 스키마 설정의 구조가 다음과 같은 경우입니다.# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the Flow Production Tracking field to use for the folder namename: &quot;code&quot;# the Flow Production Tracking entity type to connect toentity_type: &quot;Shot&quot;# Flow Production Tracking filters to apply when getting the list of itemsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ]# user settingsstudio_permissions_level: &quot;admin&quot; …폴더 생성 후크를 통해 데이터가 전달됩니다.    {'action': 'entity_folder',      'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity',                   'studio_permissions_level': 'admin'},      'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'} 이제 특별한 매개변수 studio_permissions_level이 후크로 전달되면 이를 사용하여 파일 권한 제어 등을 수행할 수 있습니다. 이 방법을 사용하여 임의로 복잡한 데이터 구조를 전달할 수도 있습니다. 이에 대한 일반적인 활용 사례는 매우 상세한 레벨에서 권한을 제어하는 것입니다.정적 폴더에 커스텀 구성 추가일반적으로 폴더 스키마 구성 내에 폴더를 만들고 해당 YAML 파일이 없는 경우, 툴킷은 정적 폴더로 가정하고 간단하게 만듭니다.커스텀 구성 메타데이터를 정적 폴더와 연관시키려는 경우 static 유형으로 YAML 구성 파일을 만들어야 합니다. 예를 들어 프로젝트 루트 바로 아래에 정적 assets 폴더가 있고 에셋을 그룹화하여 커스텀 구성 메타데이터를 추가하려고 한다고 가정합니다. 이를 수행하려면 다음 assets.yml 파일을 만듭니다.type: staticstudio_permissions_level: &quot;admin&quot;그러면 후크에 전달된 구성 데이터에 다음 내용이 포함됩니다.{'action': 'folder', 'metadata': {'studio_permissions_level': 'admin', 'type': 'static'}, 'path': '/mnt/projects/chasing_the_light/assets'},다시 말하지만, 임의로 복잡한 데이터는 YAML 구성 파일에서 이런 방법으로 후크에 전달될 수 있습니다.간단한 폴더 생성 방법 커스터마이즈간단한 폴더 생성 후크는 다음과 같이 표시될 수 있습니다.    class ProcessFolderCreation(Hook):            def execute(self, items, preview_mode, **kwargs):            &quot;&quot;&quot;     The default implementation creates folders recursively using open permissions.         This hook should return a list of created items.         Items is a list of dictionaries. Each dictionary can be of the following type:         Standard Folder     ---------------     This represents a standard folder in the file system which is not associated     with anything in Flow Production Tracking. It contains the following keys:         * &quot;action&quot;: &quot;folder&quot;     * &quot;metadata&quot;: The configuration yaml data for this item     * &quot;path&quot;: path on disk to the item         Entity Folder     -------------     This represents a folder in the file system which is associated with a     Flow Production Tracking entity. It contains the following keys:         * &quot;action&quot;: &quot;entity_folder&quot;     * &quot;metadata&quot;: The configuration yaml data for this item     * &quot;path&quot;: path on disk to the item     * &quot;entity&quot;: Flow Production Tracking entity link dict with keys type, id and name.         File Copy     ---------     This represents a file copy operation which should be carried out.     It contains the following keys:         * &quot;action&quot;: &quot;copy&quot;     * &quot;metadata&quot;: The configuration yaml data associated with the directory level     on which this object exists.     * &quot;source_path&quot;: location of the file that should be copied     * &quot;target_path&quot;: target location to where the file should be copied.         File Creation     -------------     This is similar to the file copy, but instead of a source path, a chunk     of data is specified. It contains the following keys:         * &quot;action&quot;: &quot;create_file&quot;     * &quot;metadata&quot;: The configuration yaml data associated with the directory level     on which this object exists.     * &quot;content&quot;: file content     * &quot;target_path&quot;: target location to where the file should be copied.         &quot;&quot;&quot;                # set the umask so that we get true permissions            old_umask = os.umask(0)            folders = []            try:                    # loop through our list of items                for i in items:                        action = i.get(&quot;action&quot;)                        if action == &quot;entity_folder&quot; or action == &quot;folder&quot;:                        # folder creation                        path = i.get(&quot;path&quot;)                        if not os.path.exists(path):                            if not preview_mode:                                # create the folder using open permissions                                os.makedirs(path, 0777)                            folders.append(path)                        elif action == &quot;copy&quot;:                        # a file copy                        source_path = i.get(&quot;source_path&quot;)                        target_path = i.get(&quot;target_path&quot;)                        if not os.path.exists(target_path):                            if not preview_mode:                                # do a standard file copy                                shutil.copy(source_path, target_path)                                # set permissions to open                                os.chmod(target_path, 0666)                            folders.append(target_path)                        elif action == &quot;create_file&quot;:                        # create a new file based on content                        path = i.get(&quot;path&quot;)                        parent_folder = os.path.dirname(path)                        content = i.get(&quot;content&quot;)                        if not os.path.exists(parent_folder) and not preview_mode:                            os.makedirs(parent_folder, 0777)                        if not os.path.exists(path):                            if not preview_mode:                                # create the file                                fp = open(path, &quot;wb&quot;)                                fp.write(content)                                fp.close()                                # and set permissions to open                                os.chmod(path, 0666)                            folders.append(path)                        else:                        raise Exception(&quot;Unknown folder hook action '%s'&quot; % action)                finally:                # reset umask                os.umask(old_umask)                return folders 2부 - 파일 시스템 템플릿 구성툴킷 템플릿 파일은 툴킷 구성의 허브 중 하나입니다. 프로젝트마다 항상 이러한 파일 중 하나가 있으며 파이프라인 구성 내의 config/core 폴더 내에 있습니다.이 파일에는 템플릿 과 해당 키 에 대한 정의가 있습니다.키는 정의된 동적 필드로서 이름, 버전 번호, 화면 해상도, 샷 이름 등이 될 수 있습니다. 키는 유형으로 구성되므로 예를 들어 키를 문자열 또는 정수로 정의할 수 있습니다. 또한 형식화되어 있기 때문에 문자열에 영숫자만 포함하거나 모든 정수를 8개의 0으로 채우도록 정의할 수 있습니다.템플릿은 동적 경로입니다. 템플릿의 예는 shots/{shot}/publish/{name}.{version}.ma입니다. 이 템플릿을 사용하여 Maya에서 샷을 위해 게시할 수 있습니다. 괄호로 묶인 필드는 키입니다.템플릿 파일은 키, 경로 및 문자열의 세 부분으로 나뉩니다.키 섹션키는 필드에 허용되는 값을 정의합니다. 템플릿 구성 파일에서 키는 다음 형식으로 정의됩니다.key_name:   type: key_type   option: option_value   option: option_value 키 유형은 str, int 또는 sequence 중 하나입니다. str 키는 값이 문자열인 키이고, int 키는 값이 정수인 키이고, sequence 키는 값이 정수 시퀀스인 키입니다.유형을 지정하는 것 외에도 추가 옵션을 지정할 수 있습니다. 다음과 같은 옵션이 있습니다.      default: default_value - 값이 제공되지 않은 경우 사용되는 값입니다. 예를 들어 툴킷 API를 사용하는 중 필드 값 세트를 경로로 해석하려고 하는 경우 발생할 수 있습니다.        choices: [choice1, choice2, etc] - 이 키에 사용할 수 있는 값의 열거입니다.        exclusions: [bad1, bad2, etc] - 이 키에 사용할 수 없는 값의 열거입니다. 키가 sequence 유형인 경우, 이 설정으로 프레임 사양 값을 무효화할 수 없습니다.        length: 12 - 이 키는 정확한 길이여야 합니다.        alias: new_name - key_name 대신 이 키를 사용하여 템플릿에서 사용할 이름을 제공합니다. 예를 들어 버전 번호에 대한 두 가지 개념이 있는 경우 하나는 클라이언트가 원하는 방식대로 4개의 0으로 채워지고, 다른 하나는 내부적으로 처리되는 방식대로 3개의 0으로 채워집니다. 이 경우 키 이름은 고유해야 하므로 두 키의 이름을 “version”으로 지정하는 것은 실제 가능하지 않습니다. 이 경우 별칭을 만들 수 있습니다. 자세한 정보는 아래 예 중 하나를 참조하십시오.        filter_by: alphanumeric - string 유형의 키에만 작동합니다. 이 옵션을 지정하면 영숫자 값(일반적으로 ASCII 문자열의 경우 a-z, A-Z 및 0-9이지만 입력 데이터가 유니코드인 경우 다른 문자를 포함할 수 있음)을 포함하는 문자열만 유효한 값으로 간주됩니다.        filter_by: alpha - string 유형의 키에만 작동합니다. 이 옵션을 지정하면 영문자 값(일반적으로 ASCII 문자열의 경우 a-z 및 A-Z이지만 입력 데이터가 유니코드인 경우 다른 문자를 포함할 수 있음)을 포함하는 문자열만 유효한 값으로 간주됩니다.        filter_by: '^[0-9]{4}_[a-z]{3}$' - string 유형의 키에만 작동합니다. 정규식을 유효성 확인 마스크로 정의할 수 있습니다. 예를 들어, 위의 예에서는 키에 4자리 숫자, 밑줄 및 3개의 소문자가 필요합니다.        format_spec: &quot;04&quot; - int 및 sequence 유형의 키의 경우 이 설정은 int 또는 sequence 숫자가 0이거나 공백으로 채워짐을 의미합니다. 이 예에서와 같이 “04”를 지정하면 0으로 채워진 4자리 숫자(예: 0003)가 됩니다. “03”을 지정하면 0으로 채워진 3자리 숫자(예: 042)가 됩니다. “3”을 지정하면 공백으로 채워진 3자리 숫자(예: “ 3”)가 됩니다. timestamp 유형 키의 경우 format_spec은 strftime 및 strptime 규칙을 따릅니다.        strict_matching: true - int 유형의 키에서만 작동합니다. 이 설정은 해당 필드가 적절한 형식의 숫자일 때만 일치함을 의미합니다. 예를 들어 strict_matching이 true로 설정된 경우 “003”을 지정하면 “002”, “12345” 및 “042”는 일치하지만 “00003” 또는 “2”는 일치하지 않습니다. 엄격하게 일치하도록 해야 하면 strict_matching을 false로 설정합니다. 기본 동작은 엄격하게 일치시키는 것입니다.        shotgun_entity_type - shotgun_field_name 옵션과 함께 사용하면 Flow Production Tracking에 값을 직접 쿼리할 수 있습니다. 이렇게 하면 폴더 구조에 없는 필드의 값을 파일 이름에 사용할 수 있습니다.        shotgun_field_name - shotgun_entity_type과 함께 사용해야 합니다.        abstract - 추상 필드임을 나타냅니다. 추상 필드는 이미지 시퀀스(%04d) 또는 스테레오(%V)와 같이 경로를 설명하는 데 패턴이 필요한 경우 사용됩니다. 추상 필드에는 기본값이 필요합니다.        subset 및 subset_format - 지정된 입력 문자열의 하위 집합을 추출하여 키 값으로 만듭니다. 예를 들어 사용자 이름 전체에서 이니셜 키를 만들거나 모든 샷 이름의 첫 세 글자를 포함하는 키를 만들 수 있습니다.  템플릿 키에 대한 기술적인 상세 정보는 API 참조를 참조하십시오.예 - 영숫자 이름기본값이 “comp”인 영숫자 이름입니다.name:    type: str    default: &quot;comp&quot;    filter_by: alphanumericnuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{name}.v{version}.nk 예 - 버전 번호002, 102, 034, 12341과 같이 숫자와 일치하는 버전 번호입니다.version:    type: int    format_spec: &quot;03&quot; 002, 102, 034, 12341뿐만 아니라 0002, 2 및 0102와 같이 숫자와 일치하는 버전 번호입니다.version:    type: int    format_spec: &quot;03&quot;    strict_matching: false 예 - 스테레오 눈일반적인 스테레오 눈 설정입니다. 눈 필드는 L 또는 R이지만 소프트웨어에서 사용되는 경우 일반적으로 추상적인 방식으로 %V로 참조됩니다. 실제 %V는 파일 이름이 아니라 파일 컬렉션을 참조하므로 abstract 플래그를 설정합니다. 추상 필드에는 추상 표현이 요청될 때마다 가져오는 기본값이 있어야 합니다.eye:    type: str    choices: [&quot;L&quot;, &quot;R&quot;, &quot;%V&quot;]    default: &quot;%V&quot;    abstract: truenuke_shot_render_stereo: sequences/{Sequence}/{Shot}/{Step}/work/images/{Shot}_{name}_{eye}_v{version}.{SEQ}.exr예 - 이미지 시퀀스이미지 시퀀스는 추상으로 정의되며 별도로 지정하지 않는 한 기본값은 %0Xd로 설정됩니다. 아래 시퀀스 사양은 0001, 1234 및 12345와 같은 프레임 번호를 식별합니다.SEQ:    type: sequence    format_spec: &quot;04&quot;nuke_shot_render_stereo: sequences/{Sequence}/{Shot}/{Step}/work/images/{Shot}_{name}_{channel}_{eye}_v{version}.{SEQ}.exr 예 - 별칭을 통해 버전 이름이 지정된 두 개의 필드“version”이라는 이름의 키가 필요한 코드에서 사용할 수 있는 버전 번호의 두 가지 정의입니다. 이는 두 개의 툴킷 앱이 각 버전 필드가 필요하지만 버전 필드의 형식을 다르게 지정하려는 경우에 유용합니다.nuke_version:    type: int    format_spec: &quot;03&quot;    alias: versionmaya_version:    type: int    format_spec: &quot;04&quot;    alias: version# nuke versions are using numbers on the form 003, 004, 005# the nuke publish app requires a field called {version}# however {nuke_version} is a valid replacement for {version}# because it has an alias definednuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{name}.v{nuke_version}.nk# maya versions are using numbers on the form 0004, 0005, 0006maya_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{maya_version}.ma 예 - 타임스탬프현재 로컬 시간으로 기본 설정되는 YYYY-MM-DD-HH-MM-SS 형식의 타임스탬프입니다.now:    type: timestamp    format_spec: &quot;%Y-%m-%d-%H-%M-%S&quot;    default: now UTC 시간으로 기본 설정되는 YYYY.MM.DD 형식의 타임스탬프입니다.year_month_day:    type: timestamp    format_spec: &quot;%Y.%m.%d&quot;    default: utc_now 9:00:00로 기본 설정되는 HH-MM-SS 형식의 타임스탬프입니다.nine_am_time:    type: timestamp    format_spec: &quot;%H-%M-%S&quot;    default: &quot;09-00-00&quot; 예 - 매핑예를 들어 파일 이름에 Flow Production Tracking 필드를 추가하려는 경우에 유용합니다. 파일 이름에 사용자 이름을 포함하려는 경우 다음 정의를 사용합니다.current_user_name:    type: str    shotgun_entity_type: HumanUser    shotgun_field_name: loginnuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{current_user_name}_{name}.v{version}.nk툴킷 앱이 context.as_template_fields() 방식을 통해 모든 컨텍스트 필드를 입력하면 상위 레벨 필드인 Shot, Sequence 및 Step이 자동으로 입력됩니다. 또한 shotgun_entity_type이 정의된 모든 필드(위의 current_user_name 필드와 같이)를 스캔합니다. Flow Production Tracking 엔티티가 컨텍스트에 정의되어 있으면 자동으로 값을 확인할 수 있습니다. 현재 사용자는 컨텍스트에서 항상 트래킹되며, 위의 예에서는 샷, 시퀀스 및 단계의 필드에서 데이터를 가져올 수도 있습니다. 이는 이러한 데이터가 상위 레벨 경로의 일부로 정의되어 컨텍스트의 일부로 정의되기 때문입니다. 그러나 툴킷이 Flow Production Tracking의 어떤 에셋에서 데이터를 가져오는지 알 수 없으므로 위의 예에서는 필드의 에셋 엔티티를 참조할 수 없습니다.예 - 두 개의 유효 값이 있는 문자열 필드스튜디오에는 ASCII 및 바이너리 Maya 파일을 저장해야 하는 프로젝트가 있는 경우가 종종 있습니다. 이 시나리오에서 두 개의 유효 값이 있는 문자열 값은 다음과 같습니다.maya_file_extension:    type: str    choices: [&quot;ma&quot;, &quot;mb&quot;]                     참고: 기본 앱은 templates.yml에 구성된 항목에 따라 .ma 또는 .mb 중 하나를 사용합니다. 예를 들어 프로젝트에서 .ma 대신 .mb를 저장하도록 Work Files 앱을 변경하려는 경우 샷에 대한 다음의 세 템플릿을 변경할 수 있습니다.    maya_shot_work:  '@shot_root/work/maya/{name}.v{version}.ma'maya_shot_snapshot:  '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'maya_shot_publish:  '@shot_root/publish/maya/{name}.v{version}.ma'대신 .mb로 끝낼 경우 앱이 Maya 바이너리로 저장됩니다.maya_shot_work:  '@shot_root/work/maya/{name}.v{version}.mb'maya_shot_snapshot:  '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.mb'maya_shot_publish:  '@shot_root/publish/maya/{name}.v{version}.mb' 자세한 정보는 아래의 경로 섹션을 참조하십시오.예 - 값 허용 안 함“assets” 값이 허용되지 않는 문자열 필드입니다. 예를 들어 프로젝트의 모든 시퀀스에 대한 폴더를 포함하는 폴더와 모든 에셋이 보관된 단일 “assets” 폴더를 함께 가지고 있는 경우 유용합니다.project |--- sequence1 |--- sequence2 |--- sequence3  --- assets 툴킷에서 assets 폴더가 다른 시퀀스가 아니라는 것을 올바로 이해하게 하려면 “assets”가 시퀀스 템플릿의 유효한 값이 아니라고 정의할 수 있습니다.sequence:    type: str    exclusions: [&quot;assets&quot;] 위의 예외 필드를 사용하면 두 개의 템플릿 모두 올바르게 확인되도록 정의할 수 있습니다.sequence_work_area: {sequence}/{shot}/workasset_work_area: assets/{asset}/work 예 - 문자열 하위 세트다음 예는 앞의 예를 확장하여 파일 이름 앞에 사용자의 이니셜을 사용하는 방법을 보여 줍니다.user_initials:    type: str    shotgun_entity_type: HumanUser    shotgun_field_name: login    subset: '([A-Z])[a-z]*  ([A-Z])[a-z]*'    subset_format: '{0}{1}'nuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{user_initials}_{name}.v{version}.nk 경로 섹션경로 섹션은 작업을 저장할 위치를 지정합니다. 모든 경로는 최소한 하나의 이름과 정의로 구성되며, 정의는 괄호로 묶여 있는 키 이름의 조합이며 경로를 나타내는 키가 아닌 값을 섞어서 사용합니다. 예를 들어 샷 작업 파일의 정의는 다음과 같습니다.shot_work: sequences/{Sequence}/{Shot}/{Step}/work/{Shot}.v{version}.ma 시퀀스, 샷, 단계 및 버전은 동일한 템플릿 파일에 정의된 키입니다.                    참고: 문자열 키의 이름이 연관된 Flow Production Tracking 엔티티가 있는 동적 스키마 폴더의 엔티티 유형과 일치하면 해당 폴더 이름이 토큰으로 대체됩니다. 예를 들어 위의 코드 조각과 같이 ‘string’ 유형의 {Sequence} 템플릿 키를 사용하고 스키마에서 ‘sequence’라는 동적 폴더가 있는 경우 해당 sequence.yml 파일에서 shotgun_entity 유형으로 정의되며 Flow Production Tracking의 ‘Sequence’ 엔티티 유형에 연결됩니다. 툴킷은 템플릿 키가 이 동적 폴더의 엔티티 유형이라는 것을 인식합니다(여기서는 둘 다 Sequence임). 따라서 툴킷은 폴더 이름(즉, 특정 시퀀스의 이름)을 가져와서 템플릿 키로 대체합니다.    선택적 속성을 정의해야 하는 경우 이 양식이 필요합니다. 현재 유일한 선택적 속성은 root_name이며 이 속성은 여러 루트가 있는 프로젝트의 경로에 대한 프로젝트 루트를 지정하는 데 사용할 수 있습니다. 다중 루트는 새로운 저장소 루트를 추가하여 일부 프로젝트 파일을 저장할 때 사용됩니다.root_name: name_of_project_root예를 들어 다음과 같이 표시될 수 있습니다.shot_work:  definition: sequences/{Sequence}/{Shot}/{Step}/work/{Shot}.v{version}.ma  root_name: primary 기본 저장소가 아닌 다른 저장소 루트를 사용하려면 위의 형식을 사용해야 합니다. 이 예에서 이 간단한 형식을 사용한다는 것은 모든 항목에 대해 기본 루트를 사용한다는 의미입니다.문자열 섹션문자열은 이름과 정의를 포함해야 한다는 점에서 경로와 비슷하며 이는 간단한 형식으로 제공할 수 있습니다.string_name: string_definition문자열 정의는 파일 시스템 경로가 아니라 문자열로 해석되는 키 이름 및 다른 값으로 구성된 템플릿입니다. Flow Production Tracking에서 게시용으로 사용된 이름의 예는 다음과 같습니다.maya_publish_sg_name: &quot;Maya  publish,  {name},  v{version}&quot;name과 version은 동일한 파일에 정의된 키 이름입니다.템플릿에서 선택적 키 사용템플릿의 선택적 키는 여러 가지 이유로 유용합니다. 한 가지 일반적인 예로 {SEQ}는 렌더링된 이미지에 대해 선택적입니다. 이 예에서는 /path/to/render/shot.101.exr(및 102, 103 등)과 같은 프레임 번호로 구성된 exr 세트가 있을 수 있지만 /path/to/render/shot.qt와 같은 Quicktime 영상에 대해서도 동일한 템플릿을 사용할 수 있습니다. 또 다른 일반적인 예로는 스테레오 이미지를 렌더링하는 경우가 있습니다. left eye: file.LFT.exr, right eye: file.RGT.exr, stereo image: file.exr? 규칙이 있는 스튜디오에서 {eye}를 선택적 키로 만들 수 있습니다.선택적 섹션은 대괄호를 사용하여 정의할 수 있습니다.shot_work: sequences/{Shot}/work/{Shot}.[v{version}.]ma 선택적 섹션에는 하나 이상의 키가 있어야 합니다. 선택적 섹션의 키에 대한 값이 없는 경로를 해석하면 해당 섹션이 정의에 없는 것처럼 경로가 해석됩니다. 위의 예는 단일 정의로 만들어진 두 개의 템플릿으로 생각할 수 있습니다.shot_work: sequences/{Shot}/work/{Shot}.v{version}.mashot_work: sequences/{Shot}/work/{Shot}.ma 필드 사전을 전달할 때 툴킷은 값에 따라 올바른 버전의 템플릿을 선택합니다.&amp;gt;&amp;gt;&amp;gt; template = tk.templates[&quot;shot_work&quot;]&amp;gt;&amp;gt;&amp;gt; template.apply_fields({&quot;Shot&quot;:&quot;ABC_123&quot;, &quot;version&quot;: 12}/project/sequences/ABC_123/work/ABC_123.v12.ma&amp;gt;&amp;gt;&amp;gt; template.apply_fields({&quot;Shot&quot;:&quot;ABC_123&quot;}/project/sequences/ABC_123/work/ABC_123.ma 고급 질문 및 문제 해결파일 구조에 새 엔티티 유형을 추가하는 방법Flow Production Tracking 사이트에서 장편 및 단편 애니메이션 작업을 하여 에피소드를 만들었다고 가정해 보겠습니다. 에피소드 워크플로우를 툴킷에 통합하는 방법을 살펴보겠습니다. 가장 먼저 해야 할 일은 Flow Production Tracking에 계층을 설정하여 여기의 지침에 따라 에피소드 작업을 수행하는 것입니다.                    참고: 위의 상위 폴더를 사용하여 만들기 섹션을 참조하여 툴킷의 중첩 관계를 다시 확인합니다(ShotGrid의 프로젝트 계층과는 완전히 독립적임).    추가 참조:  에피소드 엔티티는 어떻게 작동합니까?  엔티티 계층 커스터마이즈에피소드 &amp;gt; 시퀀스 &amp;gt; 샷 계층에 필요한 필드Episode용 커스텀 엔티티(사이트 기본 설정(Site Preferences) &amp;gt; 엔티티(Entities))를 사용하도록 선택하거나 Flow Production Tracking 7.0.7.0에서 사용할 수 있었던 공식 에피소드 엔티티를 사용할 수 있습니다. 7.0.7.0 이전의 Flow Production Tracking(2017년 이전)에 가입했다면 “TV Show” 템플릿에서 에피소드용 CustomEntity02를 사용합니다. CustomEntity02 또는 공식 에피소드 엔티티가 아닌 다른 엔티티를 사용하는 경우에는 신경쓸 필요가 없습니다. Flow Production Tracking 및 툴킷은 유연합니다. 두 경우를 모두 살펴보겠습니다.이 연습을 위해 에피소드(CustomEntity02)와 공식 에피소드 엔티티를 프로젝트 계층 업데이트에 에피소드를 통합하는 방법의 예(둘 중 하나 또는 둘 다 사용할 수 있음)로 사용합니다. 첫째, 프로젝트의 에피소드(Episode) &amp;gt; 시퀀스(Sequence) &amp;gt; 샷(Shot) 계층을 올바르게 설정하는 방법은 다음 필드가 Flow Production Tracking에 있는지 확인하는 것입니다.에피소드a) 공식 에피소드 엔티티 사용: “에피소드” 엔티티는 프로젝트 템플릿에서 TV Show 프로젝트를 만들 때 사용되는 엔티티일 수 있습니다.또는b) 커스텀 엔티티 사용: CustomEntity02는 프로젝트 템플릿에서 TV Show 프로젝트를 만들 때 사용되는 커스텀 엔티티일 수 있습니다. 앞에서 언급했듯이, 다른 커스텀 엔티티를 활성화하고 CustomEntity02 대신 사용할 수 있습니다. 모든 CustomEntity02를 사용자가 활성화한 특정 엔티티로 바꿔야 합니다.시퀀스에피소드 엔티티에 링크되는 에피소드라는 단일 엔티티 링크(sg_episode)가 필요합니다.공식 Episode 엔티티 사용CustomEntity02 사용샷시퀀스 엔티티에 링크되는 시퀀스라는 단일 엔티티 필드(sg_sequence)입니다. 이미 Flow Production Tracking의 TV Show 프로젝트 템플릿의 일부로 있어야 합니다.공식 Episode 엔티티 사용CustomEntity02 사용툴킷 스키마 정의다음과 같은 계층을 가정해 봅니다. 여기서 {}의 폴더는 Flow Production Tracking의 이름을 기반으로 동적으로 이름이 지정됩니다.- {project_name} - shots episode.yml - {episode_name} sequence.yml - {sequence_name} shot.yml - {shot_name} ... …에피소드config/core/schema/project/shots 폴더에서 episode라는 이름의 폴더를 다음 컨텐츠와 동일한 디렉토리에 해당 episode.yml 파일과 함께 만듭니다.공식 Episode 엔티티 사용# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the Flow Production Tracking field to use for the folder namename: &quot;code&quot;# the Flow Production Tracking entity type to connect toentity_type: &quot;Episode&quot;# Flow Production Tracking filters to apply when getting the list of items# this should be a list of dicts, each dict containing # three fields: path, relation and values# (this is std Flow Production Tracking API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]CustomEntity02 사용# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the Flow Production Tracking field to use for the folder namename: &quot;code&quot;# the Flow Production Tracking entity type to connect toentity_type: &quot;CustomEntity02&quot;# Flow Production Tracking filters to apply when getting the list of items# this should be a list of dicts, each dict containing # three fields: path, relation and values# (this is std Flow Production Tracking API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ] 이렇게 하면 툴킷이 이 프로젝트의 모든 에피소드에 대한 폴더를 만듭니다.시퀀스config/core/schema/project/shots/episode 폴더에서 sequence라는 이름의 폴더를 다음 컨텐츠와 동일한 디렉토리에 해당 sequence.yml 파일과 함께 만듭니다.# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the Flow Production Tracking field to use for the folder namename: &quot;code&quot;# the Flow Production Tracking entity type to connect toentity_type: &quot;Sequence&quot;# Flow Production Tracking filters to apply when getting the list of items# this should be a list of dicts, each dict containing # three fields: path, relation and values# (this is std Flow Production Tracking API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_episode&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$episode&quot; ] } ]` 이렇게 하면 툴킷이 디렉토리 트리에서 위의 에피소드에 링크된 모든 시퀀스에 대한 폴더를 만듭니다.샷config/core/schema/project/shots/episode/sequence 폴더에서 shot라는 이름의 폴더를 다음 컨텐츠와 동일한 디렉토리에 해당 shot.yml 파일과 함께 만듭니다.# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the Flow Production Tracking field to use for the folder namename: &quot;code&quot;# the Flow Production Tracking entity type to connect toentity_type: &quot;Shot&quot;# Flow Production Tracking filters to apply when getting the list of items# this should be a list of dicts, each dict containing # three fields: path, relation and values# (this is std Flow Production Tracking API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ]` 이렇게 하면 툴킷이 디렉토리 트리에서 위의 시퀀스에 링크된 모든 샷에 대한 폴더를 만듭니다.이 작업을 완료한 후에 스키마에 다음이 반영되어야 합니다.툴킷 템플릿 정의툴킷이 스키마에서 에피소드를 사용하도록 하려면 맨 위에 있는 키 섹션에 새 키를 만들어 정의해야 합니다.공식 Episode 엔티티 사용keys:    ...    Episode:        type: str    ... 그런 다음 아래의 템플릿 경로에서 디렉토리 구조에 에피소드를 지정하기 위해 {Episode}를 적절한 위치에 삽입하여 에피소드 계층과 일치하도록 샷 계층에 있는 다른 템플릿 경로와 함께 shot_root 템플릿을 업데이트합니다....    paths:        shot_root: shots/{Episode}/{Sequence}/{Shot}/{Step}        … CustomEntity02 사용keys:    ...    CustomEntity02:        type: str    ...그런 다음 아래의 템플릿 경로에서 디렉토리 구조에 에피소드를 지정하기 위해 {CustomEntity02}를 적절한 위치에 삽입하여 에피소드 계층과 일치하도록 샷 계층에 있는 다른 템플릿 경로와 함께 shot_root 템플릿을 업데이트합니다....    paths:        shot_root: shots/{CustomEntity02}/{Sequence}/{Shot}/{Step}        … 기본 에피소드&amp;gt; 시퀀스&amp;gt; 샷 워크플로우에 필요한 작업이 모두 끝났습니다.구조에 분기를 설정하는 방법이는 서로 다른 파이프라인 단계에 대한 각기 다른 파일 시스템 레이아웃과 관련이 있습니다. 특히, 구조에 분기를 추가하려는 경우에 더욱 그렇습니다. 예를 들어 “파이프라인 단계 A”에 대한 구조 하나와 다른 모든 파이프라인 단계에 대한 구조 하나를 설정할 수 있습니다.파이프라인에 다른 종류의 에셋 유형을 추가하고 새로운 에셋 유형이 차량이라고 가정해 봅니다 차량에 대한 파일 구조를 변경하여 각 파이프라인 단계(예: “geoprep” 및 “lookdev”)에 대해 서로 다른 폴더가 있도록 하고 각 파이프라인 단계 폴더 내에 추가 폴더가 있도록 하려고 합니다. 이 업데이트와 병행하여 현재 에셋을 만드는 방법은 동일하게 유지되어야 합니다. 이 새로운 흐름을 위해 파이프라인을 업데이트하는 방법을 살펴보겠습니다.1단계: 스키마 수정먼저 새 에셋 유형으로 폴더 구조가 표시되는 방식을 반영하도록 스키마를 수정합니다.  스키마에서 새로운 에셋 유형인 차량에 대한 새 분기를 만들어 시작합니다.  asset/ 및 asset.yml과 같은 레벨에서 asset_vehicle/ 폴더 및 asset_vehicle.yml을 추가합니다.  이러한 YAML 파일에도 필터 설정이 있습니다. asset.yml의 필터를 수정하여 차량을 제외_한 모든 에셋에 적용한 다음 asset_vehicle.yml을 수정하여 차량 유형의 에셋_에만 적용합니다. 여기 예에서 필터를 보여 줍니다.      asset 및 asset_vehicles를 나타내는 두 개의 폴더가 있으므로 해당 에셋(예: geoprep, lookdev 등)에 대해 만들 asset_vehicle 아래에 모든 폴더를 추가합니다.    이러한 에셋에 대한 파일을 저장하고 게시하는 경우 core/templates.yml에서 저장되고 게시된 파일에 대한 파일 경로를 설명하는 템플릿을 만듭니다. 예를 들어 maya_asset_work 외에도 maya_asset_work_vehicle이라는 템플릿을 만들 수 있으며, 그 정의는 차량 에셋에 Maya 작업 파일을 저장하려는 템플릿 경로가 됩니다.2단계: 새 환경 파일 만들기현재 새 에셋 유형에 대한 디렉토리 구조가 있으며 새 디렉토리 구조에서 파일을 저장하고 게시할 위치를 설명하는 템플릿이 있습니다. 이제 툴킷에 이러한 새 템플릿을 사용할 시기를 알려야 합니다. 이렇게 하려면 새 환경 파일을 만듭니다.  env/asset_vehicle_step.yml이라는 env/asset_step.yml 사본을 만듭니다. env/asset_vehicle_step.yml이 새 템플릿을 사용한다는 점을 제외하면 이 두 파일은 동일합니다. maya_asset_work의 모든 인스턴스를 maya_asset_work_vehicle로 바꿉니다. 만든 다른 차량 템플릿에 대해서도 같은 작업을 수행합니다.  마지막으로 툴킷에서 새로운 환경을 선택할 시기를 지정해야 합니다. 이렇게 하려면 컨텍스트의 에셋이 vehicle 유형인 경우 pick_environment 코어 후크를 수정하여 asset_vehicle 또는 asset_vehicle_step을 반환합니다. 이제 이 새로운 유형의 에셋(차량)을 사용하여 작업할 때 툴킷이 해당 환경 구성을 사용하고 파일을 대체 파일 시스템 구조에 저장하고 게시할 수 있게 됩니다.커스텀 파이프라인 단계를 만드는 방법Flow Production Tracking 7.0.6.0에서는 관리자 메뉴를 통한 파이프라인 단계 관리가 도입되었습니다. 이 기능을 사용하면 파이프라인 단계에 커스텀 필드를 쉽게 추가할 수 있습니다. 전문가 팁: 대부분의 경우 파이프라인 단계에서 커스텀 필드를 사용하면 해당 파이프라인 단계를 관리할 커스텀 엔티티를 만드는 것보다 체계적으로 파이프라인을 유지할 수 있습니다.",
    "url": "/82ff76f7/",
    "relUrl": "/82ff76f7/"
  },
  "57": {
    "id": "57",
    "title": "Python API에서 SSL: CERTIFICATE_VERIFY_FAILED 문제 수정",
    "content": "Python API에서 SSL: CERTIFICATE_VERIFY_FAILED 문제 수정Python API는 Flow Production Tracking에서 사용하는 다양한 웹 서비스에 연결하기 위해 사용자 시스템에 있고 API와 함께 번들로 제공되는 인증서 목록을 사용합니다. 그러나 새 인증서 인증 기관이 릴리즈되어 Python API 또는 OS와 함께 번들로 제공되지 않을 수 있습니다.Python API는 최신 인증서 사본을 제공하지만 2019년 2월 21일부터 최신 API 버전을 사용하는 경우에도 API에서 Amazon S3 업로드에 대해 해당 인증서를 사용하지 못하도록 하는 버그가 있습니다. 자세한 내용은 이 AWS 블로그 게시물을 참조하십시오. 다음 솔루션을 통해 상황을 일시적으로 해결할 수 있습니다.                    참고: 이 방법은 임시적인 해결 방법이며 장기적 솔루션을 찾고 있는 중입니다.    기본 솔루션필요한 CA 인증서를 Windows 인증서 저장소에 추가합니다. Windows 7 사용자가 이 솔루션을 사용하려면 먼저 PowerShell 3.0으로 업그레이드하거나 certutil을 사용하여 필요한 인증서를 추가해야 할 수 있습니다.      시작을 마우스 오른쪽 버튼으로 클릭한 다음 Windows PowerShell(관리자) 항목을 마우스 왼쪽 버튼으로 클릭하여 승격된 PowerShell을 시작합니다.        PowerShell 창에 다음 명령을 붙여넣은 후 Return 키를 눌러 실행합니다.     $cert_url = &quot;https://www.amazontrust.com/repository/SFSRootCAG2.cer&quot; $cert_file = New-TemporaryFile Invoke-WebRequest -Uri $cert_url -UseBasicParsing -OutFile $cert_file.FullName Import-Certificate -FilePath $cert_file.FullName -CertStoreLocation Cert: LocalMachine Root            추가된 인증서에 포함된 자세한 지문 925A8F8D2C6D04E0665F596AFF22D863E8256F3F가 표시되면 작업이 완료된 것이며 PowerShell을 닫을 수 있습니다.  대체 솔루션Python API만 사용 중인 경우      Python API v3.0.39로 업그레이드합니다.        a. SHOTGUN_API_CACERTS를 /path/to/shotgun_api3/lib/httplib2/cacerts.txt로 설정합니다.    또는    b. 스크립트를 업데이트하고 Shotgun 개체를 인스턴스화할 때 ca_certs=/path/to/shotgun_api3/lib/httplib2/cacerts.txt를 설정합니다.  툴킷을 사용 중인 경우      툴킷 배포 방법에 따라 tank core 명령을 통해 최신 버전의 툴킷 API로 업그레이드하거나 파이프라인 구성의 core/core_api.yml 파일을 업데이트하는 방법으로 업그레이드합니다.        https://github.com/certifi/python-certifi/blob/master/certifi/cacert.pem에서 최신 인증서 목록을 다운로드합니다.        SHOTGUN_API_CACERTS를 이 파일을 저장한 위치로 설정합니다. 하지만 툴킷은 Python API에서처럼 연결을 만들 때 ca_certs 매개변수 지정을 허용하지 않습니다.  Python API 또는 툴킷을 업데이트할 수 없는 경우      https://github.com/certifi/python-certifi/blob/master/certifi/cacert.pem에서 최신 인증서 목록을 다운로드합니다.        SSL_CERT_FILE 환경 변수를 이 파일을 저장한 위치로 설정합니다.  ",
    "url": "/c593f0aa/",
    "relUrl": "/c593f0aa/"
  },
  "58": {
    "id": "58",
    "title": "폴더 작성이 중단됨",
    "content": "폴더 작성 실패: 폴더를 작성하지 못함활용 사례현재 웹 인터페이스에서 새 프로젝트를 만든 다음 Flow Production Tracking 데스크톱을 사용하여 툴킷을 중앙 집중식 설정으로 구성합니다. 하지만 에셋 이름을 편집하려고 하면 더 이상 작동하지 않고(아티스트가 Maya와 같은 CCD에서 편집하기 위해 파일을 열 수 없음) “폴더를 작성하지 못함”이라는 오류가 반환됩니다. Flow Production Tracking에서는 문제를 해결하기 위해 tank 명령을 다시 실행하여 에셋을 등록 해제한 후 다시 등록하라고 하는 데 어디서 실행해야 할지 알 수 없습니다.해결 방법프로젝트에서 고급 설정 마법사를 실행하면 이 마법사를 실행하는 옵션이 의도적으로 제거됩니다. 하지만 원하는 경우 프로젝트를 다시 설정할 수 있습니다.오류 메시지에 언급된 tank 명령을 실행해야 합니다.tank.bat Asset ch03_rockat_drummer unregister_folderstank.bat는 설치한 구성의 루트에서 찾을 수 있으며 위치를 잘 모르는 경우 이 항목을 참조하십시오.관련 링크커뮤니티에서 전체 스레드 참조",
    "url": "/25a37fc0/",
    "relUrl": "/25a37fc0/"
  },
  "59": {
    "id": "59",
    "title": "프레임 서버에 오류가 발생함",
    "content": "프레임 서버에 오류가 발생함활용 사례SG 데스크톱에서 Nuke를 시작할 때 “프레임 서버에 오류가 발생했습니다.”라는 오류 메시지가 표시되고 계속해서 작업할 수 있습니다.완료 오류:The Frame Server has encountered an error.Nuke 12.1v5, 64 bit, built Sep 30 2020.Copyright (c) 2020 The Foundry Visionmongers Ltd. All Rights Reserved.Loading - init.pyTraceback (most recent call last):File “/Applications/Nuke12.1v5/Nuke12.1v5.app/Contents/Resources/pythonextensions/site-packages/foundry/frameserver/nuke/workerapplication.py”, line 18, infrom util import(asUtf8, asUnicode)ImportError: cannot import name asUtf8cannot import name asUtf8해결 방법이 오류는 구성에 아직 개발 경로가 있는 경우 발생할 수 있습니다.관련 링크커뮤니티에서 전체 스레드 참조",
    "url": "/2f35b796/",
    "relUrl": "/2f35b796/"
  },
  "60": {
    "id": "60",
    "title": "Getting Started",
    "content": "Isolation Feature Set - Getting StartedWant to learn more about the isolation features? See About the Isolation Feature Set for more details about what is in store for you. The Isolation feature set is available to clients with an active Flow Production Tracking subscription. Before starting, please be sure to complete your subscription purchase.To get the onboarding process started, go to Onboarding Process.To start the setup for any of the Isolation features, go to the Setup sectionIn This Section  About the Isolation Feature Set  Client Responsibilities  Onboarding Process  Planning Your Setup",
    "url": "/0f6d8a60/",
    "relUrl": "/0f6d8a60/"
  },
  "61": {
    "id": "61",
    "title": "시작하기",
    "content": "시작하기Flow Production Tracking 툴킷은 스튜디오 파이프라인 생성을 위해 매우 세부적인 사항까지 커스터마이즈할 수 있는 일련의 도구를 제공합니다. 이 도구를 통해 아티스트는 컨텐츠 생성 소프트웨어를 종료하지 않고도 Flow Production Tracking의 정보에 액세스하고 아티스트 간에 작업을 공유할 수 있습니다. 이 안내서는 실습을 통해 커스텀 툴킷 파이프라인 설정을 시작할 수 있도록 디자인되었습니다. Flow Production Tracking 데스크톱 앱을 사용하여 편집 가능한 프로젝트 구성을 생성하고, 기존 앱에서 설정을 수정하고, 다른 아티스트 환경에 툴킷 앱을 추가하여 커스텀 파이프라인을 디자인할 수 있습니다. 각 안내서는 이전 안내서를 토대로 작성되지만 어디서나 이동할 수 있는 지침이 포함되어 있습니다.",
    "url": "/3c5b69aa/",
    "relUrl": "/3c5b69aa/"
  },
  "62": {
    "id": "62",
    "title": "오류 18:13:28.365:Hiero(34236) 오류! 태스크 유형",
    "content": "오류 18:13:28.365:Hiero(34236): 오류! 태스크 유형활용 사례:config_default2로 업데이트한 후 nuke_studio가 초기화되지 않습니다. Nuke 12.0 Studio에서는 스크립트 편집기에 오류가 표시되지 않지만 Nuke 11.1v3에서는 다음과 같은 메시지가 표시됩니다.ERROR 18:13:28.365:Hiero(34236): Error! Task type tk_hiero_export.sg_shot_processor.ShotgunShotProcessor Not recognised롤백 후 오류가 발생하지 않아도 tk-nuke 엔진이 초기화되지 않고 Flow Production Tracking에서 아무것도 로드하지 못합니다…커뮤니티 게시물에 자세한 내용을 볼 수 있는 전체 로그가 포함되어 있습니다.오류의 원인은 무엇입니까?NukeStudio 시작으로 처리하지 않고 대신 표준 Nuke 시작으로 처리하는 것일 수 있습니다.경로가 있는 Nuke Studio 소프트웨어 엔티티를 정의하고 인자를 -studio로 설정했습니다. 인자는 --studio여야 합니다.해결 방법소프트웨어 엔티티의 인자를 -studio로 설정해야 합니다.커뮤니티에서 전체 스레드를 참조하십시오.",
    "url": "/8edc0d13/",
    "relUrl": "/8edc0d13/"
  },
  "63": {
    "id": "63",
    "title": "Houdini Flow Production Tracking 통합이 시작되지 않는 이유는 무엇일까요?",
    "content": "Houdini Flow Production Tracking 통합이 시작되지 않는 이유는 무엇일까요?여기서는 Houdini에서 Flow Production Tracking 통합을 시작할 수 없는 가장 일반적인 원인을 살펴봅니다. 이 경우, Houdini는 Flow Production Tracking 데스크톱, Flow Production Tracking 웹 사이트 또는 tank 명령으로 오류 없이 시작됩니다. 하지만 Houdini가 시작된 후에 Flow Production Tracking 메뉴 또는 쉘프가 나타나지 않습니다.원인은 Flow Production Tracking가 재정의된 HOUDINI_PATH 환경 변수를 사용하여 시작 스크립트 경로를 전달하기 때문인 경우가 많습니다.ShotGrid에서 Houdini가 시작되면 시작 앱 로직에서는 Flow Production Tracking 부트스트랩(Bootstrap) 스크립트 경로를 HOUDINI_PATH 환경 변수에 추가합니다. 그러나 Houdini에 houdini.env 파일이 있는 경우 문제가 발생할 수 있습니다. 이 파일을 통해 사용자는 Houdini가 로드될 때 제공되는 환경 변수를 설정할 수 있지만 파일에 정의된 모든 값이 현재 세션의 기존 환경 변수를 덮어씁니다.이 문제를 해결하려면 기존의 HOUDINI_PATH 환경 변수를 해당 변수에 대한 새 정의에 포함해야 합니다.예를 들어 houdini.env 파일에 다음과 같은 내용이 이미 있는 경우HOUDINI_PATH = /example/of/an/existing/path;&amp;amp;파일에 정의된 경로 끝에 $HOUDINI_PATH;를 추가하고 저장해야 합니다.HOUDINI_PATH = /example/of/an/existing/path;$HOUDINI_PATH;&amp;amp;그러면 Houdini가 시작될 때 Flow Production Tracking 설정 값을 유지할 수 있습니다.                    주의: Windows에서 $HOUDINI_PATH에 문제가 발생하는 경우가 있습니다. 간혹 Flow Production Tracking 통합을 여러 번 부트스트랩(Bootstrap)하며 다음과 같은 오류가 발생합니다.Toolkit bootstrap is missing a required variable : TANK_CONTEXT이 오류가 발생하면 대신 %HOUDINI_PATH%를 사용해야 합니다.    그래도 문제가 해결되지 않으면 문제를 진단할 수 있도록 당사의 지원 팀에 문의하십시오.",
    "url": "/eecfb05b/",
    "relUrl": "/eecfb05b/"
  },
  "64": {
    "id": "64",
    "title": "개요",
    "content": "",
    "url": "/",
    "relUrl": "/"
  },
  "65": {
    "id": "65",
    "title": "Windows에서 Flow Production Tracking 데스크톱을 자동으로 설치하려면 어떻게 해야 합니까?",
    "content": "Windows에서 Flow Production Tracking 데스크톱을 자동으로 설치하려면 어떻게 해야 합니까?Flow Production Tracking 데스크톱 설치 프로그램을 자동으로 실행하려면 다음 방법으로 Flow Production Tracking 데스크톱 설치 프로그램을 실행하십시오.ShotgunInstaller_Current.exe /S설치 폴더를 지정하고 싶다면 /D 인자를 사용하여 실행하면 됩니다.ShotgunInstaller_Current.exe /S /D=X: path to install folder.                    참고: /D 인자는 마지막 인자여야 하며, 경로에 공백이 있다고 하더라도 &quot;를 사용해서는 안 됩니다.    ",
    "url": "/3a27b3da/",
    "relUrl": "/3a27b3da/"
  },
  "66": {
    "id": "66",
    "title": "앱 추가",
    "content": "앱 추가이 안내서를 마치면 툴킷의 구성 관리 도구를 간단히 익히고 다음과 같은 작업을 수행하는 방법을 익힐 수 있습니다.  활성 파이프라인 구성의 복사본을 안전하게 생성  앱을 구성에 추가  특정 환경에서 앱을 사용하는 데 필요한 설정 추가  활성 구성에 변경 사항 다시 적용안내서 정보이 안내서에서는 Flow Production Tracking 툴킷 앱을 기존 파이프라인 구성에 추가하는 방법을 살펴보고 구성 관리 도구에 대해 간단히 알아보겠습니다.여기서 추가할 앱은 Flow Production Tracking Python 콘솔 앱입니다. Maya에는 자체 Python 콘솔이 있지만 이 툴킷 앱에는 Maya 콘솔에 없는 일부 기능이 있습니다.이 안내서에서는 파이프라인 구성 편집 안내서에서 생성한 파이프라인 구성을 활용합니다. 이 안내서를 완료하지 않았다면 기존 파이프라인 구성을 사용하여 앱을 추가할 수 있습니다.이 문서 사용이 안내서를 사용하고 툴킷 앱을 설치하려면 다음이 필요합니다.  활성 Flow Production Tracking 사이트  식별된 프로젝트에 대한 파이프라인 구성이나 구성 시작하기 안내서를 완료하고 해당 연습에서 생성한 구성을 사용합니다.  파이프라인 구성이 저장된 파일 시스템에 대해 읽기 및 쓰기 권한을 적절하게 설정합니다.  Flow Production Tracking 데스크톱이 시스템에 설치되어 있어야 합니다.  활성 상태의 Maya 서브스크립션. 여기에서 Maya 30일 체험판을 다운로드하십시오.                    참고: 이 안내서는 tk-config-default2 파이프라인 구성을 기반으로 합니다. 이 구성을 수정한 경우 YAML 설정의 파일, 폴더 및 블록의 위치가 여기에 설명된 것과 다를 수 있습니다.    Flow Production Tracking 툴킷 앱 정보Toolkit 앱의 작동 방식파이프라인 구성에서 참조하는 앱은 다양한 위치에서 가져온 것일 수 있습니다. 기본 구성에서 표준인 앱은 Flow Production Tracking 앱 스토어에서 가져온 것입니다. 파이프라인 구성의 파일은 툴킷에 “주소록에서 Python 콘솔 앱의 주소를 찾아줄래?”라고 묻는 것처럼 Flow Production Tracking 통합이 앱에 액세스하는 방법을 지정합니다. 파이프라인 구성 파일은 툴킷에 특정 앱에 활용되는 코드의 번들을 찾는 위치를 알려줍니다.기본 구성에서 툴킷 앱의 “주소”는 config/env/includes/app_locations.yml 파일에 나열되어 있으며 코드를 찾는 위치를 지정합니다. 이러한 “주소”를 디스크립터라고 합니다. Flow Production Tracking 통합은 앱에 대한 코드 번들을 찾는 위치뿐 아니라 앱을 사용하는 환경도 알아야 합니다.다음은 앱 설치 방법과 Flow Production Tracking 통합에 앱을 사용하는 위치를 알리는 방법에 대한 개념적인 개요입니다. 여기서는 구성을 확장하고 툴킷에 디스크립터를 조회하도록 요청하고 Flow Production Tracking에 앱을 사용하는 위치를 알리는 단계를 간략하게 설명합니다. 이 안내서에서는 다음 단계를 자세히 살펴봅니다.  추가하려는 앱의 디스크립터를 결정합니다.  앱 디스크립터를 추가하려는 활성 파이프라인 구성의 복사본을 생성합니다.  앱의 디스크립터가 구성에 존재하는지 확인하고, 존재하지 않는 경우 추가합니다.  들여쓰기에 탭이 아니라 공백을 사용하여 YAML 파일의 서식을 올바르게 지정합니다.  앱이 사용되는 환경을 결정합니다.  이러한 환경 내에서 Flow Production Tracking가 앱을 사용할 수 있도록 허용하는 설정을 추가합니다.  새 구성을 테스트합니다.  확장된 구성을 라이브로 적용합니다.Python 콘솔 앱에 대한 위치 디스크립터 찾기1단계: 앱 및 엔진 페이지를 열고 Maya에서 Flow Production Tracking Python 콘솔에 대한 정보를 찾습니다. 제목을 선택합니다.그러면 주소록에 필요한 항목이 모두 포함된 앱 관련 정보가 표시됩니다.시스템 이름이 주 식별자이며 tk-multi-pythonconsole입니다. 또한 최신 버전: v1.1.2도 필요합니다.Maya의 프로젝트 환경에서 Python 콘솔 앱이 없음을 확인2단계: Maya를 실행하고 Flow Production Tracking 메뉴 Flow Production Tracking &amp;gt; 프로젝트 the_other_side(Project the_other_side)를 선택하면 프로젝트 환경에 해당 프로젝트에 사용할 수 있는 앱 목록이 표시됩니다.구성 확장프로덕션 단계에 적용된 구성을 편집하려면 복사본을 먼저 생성한 후 편집해야 합니다. 그러면 라이브 구성에 영향을 미치지 않고 편집한 구성을 라이브로 적용하기 전에 테스트할 수 있는 안전한 공간이 만들어집니다. 스테이징 샌드박스를 생성하면 현재 프로덕션에서 사용되는 파이프라인 구성의 복사본을 시험해 볼 수 있습니다. 샌드박스에서 구성의 복사본을 변경한 후 변경 사항을 프로덕션에 라이브로 적용하기 전에 테스트해 볼 수 있습니다.파이프라인 구성을 복제하면 새 구성을 라이브 프로덕션에 적용하기 전에 복사본을 시험해 볼 수 있는 샌드박스를 구축하여 복사본 생성 프로세스를 자동화할 수 있습니다.앱을 추가하려는 파이프라인 구성 복제파이프라인 구성 목록으로 이동합니다.3단계: Flow Production Tracking를 열고 오른쪽 위에서 관리자(Admin) 메뉴(아바타) &amp;gt; 기본 레이아웃(Default Layouts) &amp;gt; 파이프라인 구성(Pipeline Configuration) &amp;gt; 파이프라인 구성 목록(Pipeline Configuration List)을 선택합니다.이렇게 하면 Flow Production Tracking 사이트의 파이프라인 구성이 모두 포함된 상세 목록이 표시됩니다.4단계: 파이프라인 구성 목록이 표시되면 열 헤더의 맨 오른쪽에 있는 + 기호를 선택하고 프로젝트(Projects) 열을 추가합니다.프로젝트 구성의 위치 리뷰5단계: 또한, 운영 체제에 적합한 경로(Path) 필드를 추가합니다.그러면 구성 파일의 경로가 표시됩니다.6단계: 기본(Primary) 행 항목 옆에 있는 빈 공간을 마우스 오른쪽 버튼으로 클릭하고 상황에 맞는 메뉴에서 이 구성 복제…(Clone this Configuration…)를 선택합니다.7단계: 구성 목록의 구성과 디렉토리의 파일의 이름을 각각 “Primary Clone Config 2”와 “the_other_side_clone2”로 지정합니다. 확인(OK)을 선택합니다.ShotGrid에서 구성에 포함된 모든 파일 및 폴더가 복사되고 앱에 대한 캐시가 생성될 때까지 기다립니다. 이제 앱을 사용할 수 있으므로 입에서 살살 녹는 크로아상과 함께 에스프레소를 마시면서 여유를 즐기십시오.완료되면 구성 목록에 복제된 구성 관련 정보가 업데이트되고 새 구성이 로컬 구성 폴더에 추가됩니다.                    참고: 사용자 제한(User Restrictions)에 사용자 이름이 추가되었습니다. 구성을 만든 작업자만 새 구성에 액세스할 수 있도록 자동으로 제한이 적용됩니다. 이 구성을 편집 및 테스트하고, 사용하게 하려는 작업자가 있으면 직접 추가할 수 있습니다. 또한 Flow Production Tracking는 유연성과 제어 기능을 지원합니다.    복제된 구성을 프로젝트와 연결8단계: Flow Production Tracking 데스크톱을 열고 복제된 구성을 생성한 프로젝트를 선택합니다. 오른쪽 위에 있는 아래쪽 화살표를 선택하여 이 프로젝트와 연결된 구성을 표시하고 방금 생성한 Primary Clone Config 2를 선택합니다.Flow Production Tracking 데스크톱이 이제 이 프로젝트에 대해 복제된 구성을 사용합니다.파이프라인 구성 편집9단계: 파일 시스템에서 복제된 구성을 생성할 때 지정한 경로에서 해당 구성을 찾습니다. config/env/includes/app_locations.yml 파일을 봅니다.app_locations.yml 파일이 기본 구성의 주소록이며 앱의 디스크립터가 이 파일에 나열되어 있습니다. 이 파일에 앱의 위치가 지정되며 이 파일을 사용하여 앱에 대한 설정을 생성할 수 있습니다.사용하려는 앱이 이 주소록에서 참조되지 않을 경우 툴킷에 앱을 찾을 위치를 알려야 합니다.툴킷에 앱을 찾을 위치 알리기10단계: 파일에서 pythonconsole을 검색합니다. 프로젝트에 기본 구성을 사용한 경우 Python 콘솔 앱에 대한 디스크립터가 이 파일에 나열되어 있는 것을 볼 수 있습니다. 이 디스크립터는 이 과정을 시작할 때 살펴본 Maya 앱의 목록에 있는 설명과 일치해야 합니다. 버전이 Maya 앱 목록에서 확인한 항목과 일치하는지 확인합니다.apps.tk-multi-pythonconsole.location:	type: app_store	name: tk-multi-pythonconsole	version: v1.1.2                    참고: 다른 구성을 사용하는 경우 파일에 디스크립터를 추가해야 할 수 있습니다.    모든 앱과 엔진에는 디스크립터가 있습니다. Core API 문서의 디스크립터 섹션에서 디스크립터의 작동 방식과 type:를 설정하는 방법을 확인할 수 있습니다.툴킷에 디스크립터를 사용하도록 지시이제 Maya의 프로젝트 환경에 있는 동안 툴킷에 디스크립터를 사용하여 Python 콘솔 앱을 찾아 사용하도록 지시해야 합니다.11단계: 복제된 구성에서 config/env/project.yml 파일을 열고 tk-maya 엔진에 대한 설정을 찾습니다.# configuration for all engines to load in a project contextengines:  tk-3dsmaxplus: &quot;@settings.tk-3dsmaxplus.project&quot;  tk-desktop: &quot;@settings.tk-desktop.project&quot;  tk-flame: &quot;@settings.tk-flame.project&quot;  tk-hiero: &quot;@settings.tk-nuke.hiero.project&quot;  tk-houdini: &quot;@settings.tk-houdini.project&quot;  tk-mari: &quot;@settings.tk-mari.project&quot;  tk-maya: &quot;@settings.tk-maya.project&quot;  tk-motionbuilder: &quot;@settings.tk-motionbuilder.project&quot;  tk-nuke: &quot;@settings.tk-nuke.project&quot;  tk-nukestudio: &quot;@settings.tk-nuke.nukestudio.project&quot;  tk-photoshopcc: &quot;@settings.tk-photoshopcc.project&quot;  tk-shell: &quot;@settings.tk-shell.project&quot;  tk-shotgun: &quot;@settings.tk-shotgun.project&quot;@settings를 사용하는 tk-maya: “@settings.tk-maya.project” 행은 설정이 포함된 파일에 있음을 나타냅니다. tk-maya는 Maya 엔진을 나타내고 project는 환경을 나타냅니다.YAML 파일Flow Production Tracking 툴킷 파이프라인 구성은 YAML 파일에서 단순한 용어를 사용하여 앱과 엔진의 위치와 해당 설정을 식별합니다.이 블록에서  settings는 기본 구성에 대해 설정 폴더의 참조로 선택된 항목입니다.  project는 기본 구성에 대해 프로젝트 환경의 참조로 선택된 항목입니다.  tk-maya는 Maya에 대한 툴킷 엔진의 식별자입니다.  @은 설정 값을 포함된 파일에서 가져온다는 것을 나타내는 데 사용되는 툴킷 용어입니다.YAML 파일은 Flow Production Tracking 통합으로 통하는 창입니다. 이 파일을 사용하면 파이프라인의 요구사항을 충족하는 작업 환경을 더욱 손쉽게 구성할 수 있습니다.구성이 툴킷 번들을 참조하는 방식Flow Production Tracking 통합의 코드는 앱, 엔진 및 프레임워크에 대한 번들로 구성됩니다. 번들은 툴킷의 YAML 파일에서 tk-maya, tk-multi-pythonconsole 등과 같은 식별자로 참조됩니다. YAML에서 각 번들에 해당하는 블록에는 식별된 번들의 액세스 및 활용 방식을 제어하는 설정이 포함됩니다.Python 콘솔에 대한 설정을 추가할 위치기본 구성의 이 블록에서 ‘tk-maya.project’는 프로젝트 환경에서 Maya 엔진을 나타내는 식별자입니다. 여기서 목표는 Python 콘솔 앱 코드 번들을 프로젝트 환경의 Maya 엔진에 추가하는 것입니다. 사용된 용어를 보면 tk-maya.yml은 프로젝트 환경의 설정이 위치한 YAML 파일의 이름입니다. tk-maya.yml 파일에서 apps에 대한 settings.tk-maya.project를 찾습니다.13단계: 파일을 찾기 위해 엔진 위에 있는 includes 섹션에서 tk-maya.yml을 찾습니다../includes/settings/tk-maya.yml14단계: 복제된 구성에서 텍스트 편집기로 config/env/includes/settings/tk-maya.yml을 열고 settings.tk-maya.project를 검색합니다.15단계: 다음 아래에 위치 디스크립터를 추가합니다.settings.tk-maya.project:  apps:위치 디스크립터를 추가하는 방법에 대한 가이드로 about 앱인 tk-multi-about:을 사용한 후 파일을 저장합니다.                    참고: YAML 파일의 서식이 탭이 아니라 공백을 사용하여 올바르게 지정되었는지 확인하십시오.    # projectsettings.tk-maya.project:  apps:    tk-multi-about:      location: &quot;@apps.tk-multi-about.location&quot;    tk-multi-pythonconsole:      location: &quot;@apps.tk-multi-pythonconsole.location&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-multi-shotgunpanel: &quot;@settings.tk-multi-shotgunpanel&quot;    tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;Screening Room, Flow Production Tracking Panel 및 Workfiles2 앱의 위치 식별자가 포함된 다른 파일에 나열되어 있고 About 앱과 다르게 액세스되는 것을 알 수 있습니다.  이러한 앱에는 추가 설정이 있으므로 정리를 위해 포함된 설정 폴더로 분리되었습니다.                    참고: Python 콘솔 앱은 기본 구성에 이미 있지만, 사용 중인 구성에 이전에 추가한 적이 없는 앱을 추가할 경우 또는 앱의 버전을 변경하고 중앙 집중식 구성을 사용하는 경우에는 추가 단계를 수행해야 합니다. 터미널을 열고 복제된 구성이 저장된 위치를 찾습니다. 복제된 구성의 루트 폴더에서 다음 명령을 실행합니다.Linux 또는 Mac:./tank cache_appsWindows:tank.bat cache_apps이렇게 하면 앱, 엔진 및 프레임워크에 대해 구성을 스캔하고 모두 다운로드되었는지 확인합니다.    Maya에서 변경 사항 보기16단계: Flow Production Tracking 데스크톱을 열고 작업하는 프로젝트를 선택한 후 복제된 구성을 사용하고 있는지 확인합니다.프로젝트 이름 아래, 생성된 복제본의 이름에 파란색 막대가 표시됩니다.                    참고: 기본 항목을 사용하는 경우 파란색 막대가 없고 구성 이름이 표시되지 않습니다.    17단계: 데스크톱에서 Maya를 실행하고 Flow Production Tracking &amp;gt; 프로젝트(Project) &amp;gt; … 메뉴를 선택합니다.다음에 해당하는 경우:  방금 편집한 복제된 구성을 사용합니다.  복제된 구성이 올바르게 확장되었습니다.  확장된 파일을 저장했습니다.  복제된 구성과 프로젝트를 연결했습니다.  Flow Production Tracking 데스크톱에서 Maya를 다시 실행했습니다.Python 콘솔 앱을 Maya에서 사용할 수 있습니다.변경 사항을 프로덕션에 적용Python 콘솔 앱이 올바르게 추가된 것을 확인하고 나면 변경 사항을 라이브로 적용할 수 있습니다.18단계: 터미널을 열고 복제된 구성이 저장된 위치를 찾습니다. 복제된 구성의 루트 폴더에서 다음 명령을 실행합니다.Linux 또는 Mac:./tank push_configurationWindows:tank.bat push_configuration프롬프트에 따라 변경 사항을 적용하려는 구성인 프로젝트 기본 구성의 ID를 입력합니다.$ lscache		config		install		tank		tank.bat$ ./tank push_configurationWelcome to the Flow Production Tracking Toolkit!For documentation, see https://developer.shotgridsoftware.comStarting Toolkit for your current path'/Users/michelle/Documents/Shotgun/configs/the_other_side_clone2'- The path is not associated with any Shotgun object.- Falling back on default project settings.- Running as user 'Michelle'- Using configuration 'Primary Clone Config 2' and Core v0.18.159- Setting the Context to Project the_other_side.- Running command push_configuration...----------------------------------------------------------------------Command: Push configuration----------------------------------------------------------------------This command will push the configuration in the current pipeline configuration('Primary Clone Config 2') to another pipeline configuration in the project.By default, the data will be copied to the target config folder. If pass a--symlink parameter, it will create a symlink instead.Your existing configuration will be backed up.The following pipeline configurations are available to push to: - [1] Primary (/Users/michelle/Documents/Shotgun/configs/the_other_side)Please type in the id of the configuration to push to (ENTER to exit):복제된 구성을 적용할 수 있는 사용 가능한 파이프라인 구성 목록이 표시됩니다. 구성을 업데이트하려는 프로젝트에 대한 기본 파이프라인 구성의 ID를 입력합니다.                    참고: 이 안내서의 3단계에서 확인한 Flow Production Tracking의 파이프라인 구성(Pipeline Configuration) 페이지에서 파이프라인 구성의 ID를 찾을 수도 있습니다. 프로젝트 ID를 찾으려면 구성 목록(Configuration List)으로 이동하고 ID 열을 추가하십시오.    ID를 입력하면 Flow Production Tracking에서 다음 작업을 수행합니다.  기본 구성 백업  복제된 구성 복사  복제본을 그대로 둔 상태로 복제된 구성의 복사본을 프로젝트와 연결  기본 구성이 저장된 위치 표시  다운로드하고 캐시해야 할 앱이 있는지 여부 확인Please type in the id of the configuration to push to (ENTER to exit): 1Hold on, pushing config…Your old configuration has been backed up into the following folder:/Users/michelle/Documents/Shotgun/configs/the_other_side/config.bak.20190118_111627Checking if there are any apps that need downloading…Push Complete!기본 구성에서 수행한 변경 사항 표시19단계: Flow Production Tracking 데스크톱의 오른쪽 위에 있는 화살표를 클릭하고 구성(CONFIGURATION) 목록에서 기본(Primary)을 선택합니다.20단계: 데스크톱에서 Maya를 실행하고 Flow Production Tracking &amp;gt; 프로젝트(Project) &amp;gt; … 메뉴에서 Flow Production Tracking Python 콘솔…(Python Console…)을 찾습니다.Python 콘솔 앱이 선택한 프로젝트의 프로젝트 환경에 추가되었습니다. 두 번째 안내서인 “구성 편집“에서 각 환경은 서로 독립적이고, 프로젝트마다 전용 구성이 있으며, 프로젝트가 로드될 때 소프트웨어 통합이 파이프라인 구성에서 설정을 수집한다는 것을 살펴봤습니다. 환경에서 Python 콘솔을 사용할 수 있으려면 app_locations.yml 파일에서 위치 디스크립터를 찾는 지침이 환경에 제공되어야 합니다. 이 점을 고려해 볼 때 파이프라인에서 Python 콘솔 앱을 사용할 수 있게 할 위치에 “여기서 Python 콘솔 앱 사용”과 같은 설정을 지정해야 합니다.고급 항목Flow Production Tracking 개발자 커뮤니티툴킷의 놀라운 특징 중 하나는 모든 작업자가 툴킷 앱을 작성할 수 있다는 점입니다. 앱을 전용 앱으로 사용할 수도 있지만, Flow Production Tracking 도구에 추가할 수 있도록 Flow Production Tracking 커뮤니티에서 공유할 수도 있습니다. Flow Production Tracking 커뮤니티 페이지에서 공유할 뛰어난 기능을 생성한 경우 도움을 받으려면 지원 사이트를 방문하십시오.표준 툴킷 앱과 Flow Production Tracking 커뮤니티에서 생성된 앱에 대한 활발한 논의가 Flow Production Tracking-dev Google 그룹에서 진행되고 있습니다. Flow Production Tracking 커뮤니티에 새로운 정보 제공 사례가 늘어남에 따라 이러한 기술 및 도구 기반은 끊임없이 확장되고 있습니다.구성을 확장하는 방법 연구프로젝트에 사용할 구성을 선택할 때 Python 콘솔 앱을 Flow Production Tracking 데스크톱 드롭다운에서 찾을 수 있다는 것을 아셨을 것입니다.파이프라인 구성에 추가하려는 앱을 사용하고 있는 환경이 있다면 간단한 탐색 작업을 거쳐 앱을 구성에 추가하는 데 필요한 정보를 찾을 수 있습니다. 환경의 구성 파일에서 앱이 사용되는 위치를 파악하면 앱 위치 디스크립터와 설정을 추가하는 방법을 확인할 수 있습니다.데스크톱 앱은 프로젝트 환경에서 열리므로 project.yml 파일에서 tk-desktop을 찾습니다.config/env/project.yml을 엽니다.엔진 블록에서 tk-desktop은 포함된 컨텐츠를 가리킵니다.includes:  - ./includes/settings/tk-desktop.ymlengines:  tk-desktop: &quot;@settings.tk-desktop.project&quot;include의 경로를 따라 config/env/includes/settings/tk-desktop.yml을 열고 settings.tk-desktop.project 블록을 찾습니다. 해당 블록에서 다음을 확인할 수 있습니다.apps:  tk-multi-pythonconsole:  location: &quot;@apps.tk-multi-pythonconsole.location&quot;이러한 블록은 프로젝트 단계에서 Python 콘솔 앱을 데스크톱 엔진에 추가합니다.include의 경로를 ../includes/app_locations.yml까지 따라가 apps.tk-multi-pythonconsole.location을 검색하여 다음을 확인합니다.# pythonconsoleapps.tk-multi-pythonconsole.location:  type: app_store  name: tk-multi-pythonconsole  version: v1.1.2모든 앱, 엔진 및 프레임워크에는 툴킷에 특정 번들에 액세스하는 위치를 알리는 데 사용되는 위치 디스크립터가 있습니다. 대부분의 앱 디스크립터는 app_locations.yml 파일에 있지만, Python 콘솔 앱에서 확인한 것처럼 원하는 위치에서 참조되지 않을 수도 있습니다. 모든 표준 앱 및 엔진은 앱 및 엔진 페이지에 나와 있습니다.ShotGrid에서 지원하는 적합한 소프트웨어 통합에 앱을 추가할 수도 있고, 자신만의 전용 응용프로그램을 자체 툴킷 도구에 추가할 수도 있습니다. 지원되는 모든 소프트웨어 응용프로그램도 통합의 앱 및 엔진 페이지에 나와 있습니다.원하는 앱을 찾을 수 없는 경우 직접 작성할 수 있습니다. 다른 Flow Production Tracking 사용자도 동일한 기능을 필요로 할 수 있으므로 새로 만든 앱을 공유하는 것도 Flow Production Tracking 커뮤니티에 기여하는 한 가지 방법입니다.다음 안내서에서는 스튜디오의 구조에 따라 프로덕션 폴더 구조를 커스터마이즈하는 방법을 알아봅니다.",
    "url": "/4d147fb2/",
    "relUrl": "/4d147fb2/"
  },
  "67": {
    "id": "67",
    "title": "Flow Production Tracking 통합 관리자 안내서",
    "content": "Flow Production Tracking 통합 관리자 안내서소개이 문서는 Flow Production Tracking 통합 관리자를 위한 안내서 역할을 합니다. 사용자 안내서, 관리자 안내서, 개발자 안내서 중 하나입니다. 사용자 안내서는 일상적인 워크플로우에서 Flow Production Tracking 통합의 최종 사용자가 될 아티스트를 위한 것이며 개발자 안내서는 Python 코드를 작성하여 기능을 확장하려는 개발자를 위한 기술 문서입니다. 이 문서는 이 두 지점 사이에 존재합니다. 스튜디오에서 Flow Production Tracking 통합을 구현하고, 소프트웨어 버전을 관리하며 게시된 파일의 저장소를 결정하는 사용자를 위해 작성되었습니다.표준 파이프라인 구성툴킷 설정의 중심에는 파이프라인 구성이 있습니다. 파이프라인 구성은 설치된 앱부터 소프트웨어 버전까지 모든 것을 관리하는 YAML 파일 세트이며, 프로덕션 디렉토리 구조 및 파일 이름을 설정하기 위한 템플릿까지 보유하는 경우도 있습니다. 파이프라인 구성은 매우 세부적인 사항까지 커스터마이즈할 수 있지만 두 가지 시작 지점이 제공됩니다.기초 구성기본 제공 통합은 구성 파일을 설정하거나 수정할 필요 없이 실행할 수 있도록 디자인되었습니다. 기본 제공 통합을 사용할 때에는 관리할 필요가 없습니다. 하지만 툴킷이 내부에서 함축된 파이프라인 구성을 사용하는 경우에는 이 파이프라인 구성을 기초 구성이라고 합니다. 기초 구성은 지원되는 모든 소프트웨어 패키지에서 사용할 수 있는 3개의 툴킷 앱(Panel, Publisher 및 Loader)을 구성하며, Flow Production Tracking의 소프트웨어 엔티티를 고려하여 Flow Production Tracking 데스크톱에 표시할 소프트웨어 패키지를 결정합니다. 기초 구성에는 파일 시스템 위치 지원이 포함되지 않습니다. 프로젝트에서 기본 제공 통합을 사용할 때에는 데스크톱을 시작할 때마다 기초 구성 사본이 자동으로 업데이트되므로 통합을 항상 최신 버전으로 유지할 수 있습니다. 여기에서 릴리즈 정보를 구독하고 여기에서 Github의 기초 구성을 확인할 수 있습니다.기본 구성고급 프로젝트 설정의 기본 시작 지점입니다. 여기에는 파일 시스템 위치 지원과 다양한 툴킷 앱 및 엔진이 포함됩니다.여기에서 Github의 기본 구성을 확인할 수 있습니다. 기본 구성 구조에 대한 자세한 정보는 파이프라인 구성에 있는 config/env/README.md 파일을 참조하거나 Github에서 확인하십시오.                    참고: 이전 구성 구조를 살펴보시겠습니까? v1.1 통합 릴리즈의 경우 효율성과 가독성을 극대화하고 기초 구성의 구조를 보다 일관되게 유지할 수 있도록 기본 구성 구조를 재편성했습니다. 여전히 레거시 기본 구성을 기반으로 프로젝트를 만들 수 있습니다. 데스크톱 설정 프로젝트 마법사에 구성을 선택하라는 메시지가 표시되면 ‘레거시 기본값(Legacy Default)’을 선택하기만 하면 됩니다.    PublisherPublisher는 기본 제공 워크플로우와 전체 파이프라인 구성 간에 쉽게 전환할 수 있도록 설계되었었습니다. 기본 제공 설정의 경우 파일이 즉시 게시되기 때문에 템플릿 또는 파일 시스템 스키마를 정의할 필요가 없습니다. 프로젝트가 고급 설정 단계를 지나 전체 파이프라인 구성을 갖추고 나면 동일한 게시 플러그인이 앱 설정으로의 템플릿 도입을 인식하고 게시 전에 파일을 지정된 게시 위치로 복사하기 시작합니다. 그러면 스튜디오는 전체 구성을 가진 프로젝트에 필요한 대로 환경별 또는 DCC 기준별로 템플릿 기반 설정을 도입할 수 있습니다. 기본 구성은 템플릿 기반 워크플로우에 대해 완전히 구성된 상태로 제공되며 Publish 앱에서 템플릿을 어떻게 구성할 수 있는지 살펴볼 수 있는 좋은 참조가 됩니다. 자세한 정보는 Github의 기본 구성에 있는 tk-multi-publish2.yml 파일을 참조하십시오.Publisher용 플러그인 작성에 대한 자세한 정보는 개발자 안내서의 Publisher 섹션을 참조하십시오.소프트웨어 시작 구성ShotGrid이 시스템에 있는 호스트 응용프로그램을 자동으로 탐지하는 기능에 맡기면 됩니다. Flow Production Tracking 데스크톱을 시작하고 프로젝트만 선택하면 데스크톱에 지원되는 모든 소프트웨어 패키지(표준 응용프로그램 디렉토리에서 확인 가능)의 시작 관리자가 표시됩니다. 스튜디오에서 보다 세밀하게 소프트웨어를 관리할 수 있는 견고한 도구도 역시 제공됩니다. 응용프로그램 가시성을 특정 프로젝트, 그룹 또는 개별 사용자로도 제한할 수 있습니다. 버전을 지정하고 전체 사이트에서 특정 소프트웨어 패키지를 비활성화하며 소프트웨어 패키지 그룹을 지정할 수 있습니다. 이 모든 것이 Flow Production Tracking의 소프트웨어 엔티티를 통해 관리됩니다.새 Flow Production Tracking 사이트를 만들면 기본 소프트웨어 엔티티 세트가 설정됩니다(지원되는 호스트 응용프로그램에 대해 각각 하나씩). 이러한 엔티티를 수정하고 자체 엔티티를 추가하여 데스크톱에 나타나는 소프트웨어를 원하는 방식으로 관리할 수 있습니다.ShotGrid의 소프트웨어 엔티티를 보려면 화면 오른쪽 위에 있는 프로파일 아이콘을 클릭하여 관리자(Admin) 메뉴를 열고 Software를 선택합니다.소프트웨어 엔티티에는 다음과 같은 필드가 있습니다.  소프트웨어 이름(Software Name): 데스크톱에 표시되는 소프트웨어 이름입니다.  썸네일(Thumbnail): 데스크톱 아이콘용으로 업로드된 이미지 파일입니다.  상태(Status): 소프트웨어 사용 가능 여부를 제어합니다.  엔진(Engine): 컨텐츠 생성 도구용 통합의 이름입니다.  제품(Products): 변형(예: Houdini와 Houdini FX)이 포함된 소프트웨어 패키지의 경우 여기에서 쉼표로 구분된 목록을 지정할 수 있습니다. 수동 모드가 아닌 자동 탐지 모드에서만 유효합니다.  버전(Versions): 표시할 특정 소프트웨어 버전을 지정합니다. 여기에서 쉼표로 구분된 목록을 지정할 수 있습니다. 수동 모드가 아닌 자동 탐지 모드에서만 유효합니다.  그룹(Group): Group 필드의 값이 동일한 엔티티는 데스크톱의 경우 단일 아이콘 아래에 그리고 Flow Production Tracking의 경우 단일 메뉴 아래에 그룹 지정됩니다. 예를 들어, Houdini 및 Nuke를 포함하는 FX 그룹을 만들 수 있습니다.  그룹 기본값(Group Default): 그룹의 한 구성원이 Group Default을 선택한 경우 해당 그룹의 아이콘 또는 메뉴 항목을 클릭하면 이 소프트웨어가 시작됩니다.  프로젝트(Projects): 소프트웨어를 특정 프로젝트로 제한하는 방법입니다.  사용자 제한(User Restrictions): 소프트웨어를 특정 사용자 또는 그룹으로 제한하는 방법입니다.  Linux/Mac/Windows 경로(Linux/Mac/Windows Path): 이 필드를 사용하여 소프트웨어에 대한 OS별 경로를 명시적으로 지정합니다.  Linux/Mac/Windows 인자(Linux/Mac/Windows Args): 소프트웨어 시작 시 명령에 추가할 명령행 인자입니다.이러한 필드를 사용하는 몇 가지 방법을 살펴봄으로써 이러한 필드가 함께 작동하는 방식에 대해 많은 것을 배울 수 있습니다.예: 동일한 응용프로그램 버전 그룹 지정, 자동 탐지파일 시스템에 세 가지 버전의 Maya(Maya 2016, Maya 2017 및 Maya 2018)가 있는 경우 아티스트는 이러한 버전을 모두 사용할 수 있으며 이들을 데스크톱에 있는 단일 아이콘 아래에 그룹으로 지정할 수 있습니다.이러한 세 가지 버전의 Maya가 파일 시스템에 있는 표준 위치에 설치된 경우에는 그룹 지정이 모두 자동으로 이루어집니다. 데스크톱에서 프로젝트를 선택하면 로컬 컴퓨터에 있는 표준 응용프로그램 디렉토리를 스캔하여 세 버전을 찾습니다. 이미 Flow Production Tracking에는 Maya 소프트웨어 엔티티가 있기 때문에 특정 버전 또는 경로를 지정하지 않아도 데스크톱에서 찾은 모든 버전이 표시됩니다.몇 가지 참고 사항:  Flow Production Tracking가 소프트웨어를 자동 탐지하면 단일 소프트웨어 엔티티가 모든 버전에 대한 메뉴 항목을 생성합니다.  어느 경로 필드에도 값이 지정되지 않습니다. 소프트웨어 엔티티는 자동 탐지 모드이므로 앱은 표준 위치에 있는 것으로 간주됩니다.이러한 항목은 여기서 보는 것처럼 데스크톱에도 표시됩니다(사용 가능한 모든 버전을 나열하는 드롭다운이 있는 단일 Maya 아이콘). 아이콘을 클릭한 경우 최신 버전의 Maya가 시작됩니다.예: 동일한 응용프로그램 버전 그룹 지정, 수동 모드스튜디오의 비표준 위치에 Maya를 저장하기에 완벽한 조건입니다. 자체 소프트웨어 엔티티를 만든 다음 Flow Production Tracking에서 소프트웨어를 어디서 찾아야 하는지 알 수 있도록 경로를 지정하기만 하면 됩니다. 설정은 다음과 같을 수 있습니다.몇 가지 참고 사항:  자동 탐지 모드와는 달리, 여기에서는 특정 소프트웨어 패키지의 각 버전마다 소프트웨어 엔티티가 있습니다.  이를 그룹으로 지정하려면 Group 및 Group Default 필드를 사용합니다. Group에 대해 동일한 값을 공유하는 소프트웨어 엔티티는 데스크톱에서 단일 아이콘 아래에 드롭다운 형태로 그룹 지정되며 해당 이름으로 Group 값을 사용합니다.  아이콘을 클릭하면 Group Default가 선택된 그룹 내에서 소프트웨어가 시작됩니다.  소프트웨어 엔티티에서 Linux 경로, Mac 경로 또는 Windows 경로에 대해 어떤 값이라도 지정한 경우 해당 엔티티가 수동 모드로 전환됩니다. 경로 필드가 비어 있을 때 소프트웨어가 데스크톱에 표시되는 자동 탐지 모드와 달리 수동 모드에서는 해당 운영 체제에 대해 경로가 지정되어 있고, 파일이 지정된 경로에 존재하는 경우에만 해당 운영 체제에 소프트웨어 패키지가 표시됩니다.  이 예에서는 Windows Path가 지정되지 않았기 때문에 Windows상의 데스크톱에 세 가지 Maya 버전 중 어느 것도 표시되지 않습니다.예: 사용자 또는 그룹별로 제한현재 마지막 예에서 언급한 것처럼 아직 모든 사용자가 Maya 2018을 사용하도록 할 준비가 되지 않았습니다. 하지만 TD, 개발자, QA 엔지니어, Tessa 테스터는 액세스할 수 있어야 합니다. 이는 User Restrictions 필드를 통해 처리할 수 있습니다. 다음은 예입니다.마지막 예에서 다음과 같이 몇 가지 사항을 변경했습니다.  그룹 기본값은 현재 Maya 2017입니다. 여기서는 프로덕션 버전을 원하기 때문에 해당 체크박스를 선택한 상태에서 Maya 아이콘을 클릭하면 이제 이 버전으로 이동합니다.  User Restrictions 필드에 일부 값을 추가했습니다. 이는 사용자 및 그룹 모두에 적용될 수 있고 Dev 및 TD 그룹뿐만 아니라 사용자 Tessa 테스터도 추가했습니다. 이제 이 사람들만이 데스크톱에서 Maya 2018을 확인할 수 있습니다.예: 프로젝트별 소프트웨어 버전 제한스튜디오의 프로젝트 전체에서 좀 더 복잡한 버전 관리를 해야 하는 경우가 있습니다. 신속하게 전달해야 하는 프로젝트가 있을 경우 새 소프트웨어 버전을 차단해야 하는데, 그와 동시에 후속 버전이 시작되어 최신 버전을 평가할 수 있게 될 수도 있습니다. 이런 경우 다음과 같이 소프트웨어 엔티티를 설정해야 할 수 있습니다.몇 가지 중요 참고 사항:  여기에서 Group 및 Group Default 값은 제거되었는데, 특정 환경에서는 하나의 Maya 버전만 데스크톱에 표시되기 때문입니다.  세 “Maya” 버전 모두에 대해 Software Name을 설정했습니다. 이렇게 하면 모든 프로젝트에서 사용자에게 동일한 이름의 아이콘이 표시되지만 여기에서 구성한 내용에 따라 다른 버전을 가리키게 됩니다.  Maya 2016의 Status 필드를 Disabled으로 설정했습니다. 스튜디오에서는 더 이상 이 버전을 사용하지 않으며 이 필드는 모든 프로젝트에 대해 전역 가시성을 전환합니다.  Maya 2017 및 Maya 2018에 대해 Projects의 값을 지정했습니다. 이 Projects 필드는 제한 역할을 합니다. Maya 2017은 오직 Chicken Planet 프로젝트에만 표시되고 Maya 2018은 Chicken Planet II에만 표시됩니다.  소프트웨어 엔티티에 대해 Projects의 값을 지정하면 해당 소프트웨어는 여러분이 지정한 프로젝트에만 표시됩니다. 따라서 스튜디오에 Chicken Planet 시리즈 외에 다른 프로젝트가 있을 경우 해당 프로젝트에 대해 명시적으로 소프트웨어를 지정해야 합니다.예: 보유 중인 소프트웨어 추가새 소프트웨어 엔티티를 추가하는 데에는 Flow Production Tracking 데스크톱이 시스템에서 자동 탐지한 것 외에도 다음과 같은 몇 가지 이유가 있습니다.  사용자가 데스크톱을 통해 사용할 수 있는 엔진이 없는 응용프로그램을 만들고 싶습니다.  직접 엔진을 작성한 내부 소프트웨어 또는 해당 통합이 없는 타사 소프트웨어를 보유하고 있습니다.  소프트웨어가 표준 위치에 있지 않으므로 수동으로 Flow Production Tracking이 이를 가리키도록 하고 싶습니다. (이 사례는 위에 있는 “동일한 응용프로그램 버전 그룹 지정, 수동 모드” 예에서 설명했습니다.)이런 경우 보유 중인 소프트웨어 엔티티를 추가할 수 있습니다. Software Name 필드의 값을 입력해야 합니다. 소프트웨어용 내부 엔진을 사용 중인 경우 Engine 필드에 엔진 이름을 지정합니다. 일부 스튜디오에서는 아티스트의 편의를 위해 데스크톱에 Flow Production Tracking 통합이 없는 앱을 포함할 수 있습니다. 아티스트는 데스크톱에서 해당 앱을 바로 시작할 수 있습니다. 위 설정을 모두 사용하여 버전을 관리하고 사용을 제한할 수도 있습니다. 이 경우 Engine 필드는 비워 두고, 대신 Mac Path, Linux Path 및 Windows Path 중 적어도 하나의 값을 지정해야 합니다.게시된 파일 경로 해석 구성파일을 게시하면 Publisher가 Flow Production Tracking에 PublishedFile 엔티티를 만드는데, 여기에는 파일/링크 필드(Path라고 함)가 포함됩니다. 나중에 다른 사용자가 Loader를 사용하여 자신의 작업 세션에 이 파일을 로드하려고 할 수 있습니다. 로더는 복잡한 로직을 사용하여 전체 운영 체제에서 PublishedFile의 유효한 로컬 경로를 해석합니다.로더가 게시 데이터를 경로로 해석하려고 시도하는 방법은 해당 게시가 로컬 파일 링크 또는 file:// URL과 연결되어 있는지 여부에 따라 다릅니다.로컬 파일 링크 해석게시 중인 경로가 Flow Production Tracking 사이트 기본 설정에서 정의한 로컬 저장소와 일치하는 경우 게시할 때 로컬 파일 링크가 자동으로 생성됩니다. 게시가 로컬 파일 링크인 경우에는 해당 로컬 운영 체제 표현이 사용됩니다. 로컬 파일 링크에 대한 자세한 정보는 여기를 참조하십시오.로컬 저장소가 현재 사용 중인 운영 체제의 경로를 정의하지 않는 경우에는 환경 변수를 사용하여 로컬 저장소 루트를 지정할 수 있습니다. 환경 변수 이름은 SHOTGUN_PATH_&amp;lt;WINDOWS|MAC|LINUX&amp;gt;_&amp;lt;STORAGENAME&amp;gt; 형식이어야 합니다. 따라서, Mac에 “Renders”라고 하는 저장소 루트에 대한 경로를 정의하려면 SHOTGUN_PATH_MAC_RENDERS 환경 변수를 만들어야 합니다. 이 예를 더 구체적으로 살펴보겠습니다.  Flow Production Tracking 사이트에 경로가 다음과 같이 지정된 “Renders”라고 하는 저장소 루트가 있다고 가정합니다.  Linux 경로: /studio/renders/  Windows 경로: S: renders       Mac 경로: &amp;lt;blank&amp;gt;        현재 Mac을 사용 중입니다.    경로 /studio/renders/sq100/sh001/bg/bg.001.exr의 게시를 세션에 로드하려고 합니다.로더는 해당 경로를 구문 분석하여 /studio/renders/가 저장소 루트의 일부이지만 Mac에 대해 정의되어 있는 저장소 루트가 없다는 것을 추론할 수 있습니다. 따라서 SHOTGUN_PATH_MAC_RENDERS 환경 변수를 찾게 되고, 이를 찾는 경우 경로에 있는 /studio/renders를 해당 값으로 대체합니다.참고: SHOTGUN_PATH_MAC_RENDERS 환경 변수를 정의하고 로컬 저장소 렌더에 Mac 경로가 설정되어 있는 경우 해당 로컬 저장소 값이 사용되고 경고가 기록됩니다.참고: 현재 운영 체제에 대한 저장소를 해석할 수 없는 경우 PublishPathNotDefinedError가 발생합니다.파일 URL 해석로더는 file:// URL 해석도 지원합니다. 게시할 때 게시 중인 경로가 사이트의 로컬 저장소와 일치하지 않는 경우 경로는 file:// URL로 저장됩니다. 로컬 파일 링크와는 달리, 이러한 경로는 다중 OS 표현으로 저장되지 않으며 해당 링크가 만들어진 운영 체제에 대해서만 정의됩니다.해당 URL이 만들어진 운영 체제와 다른 운영 체제에서 file:// URL을 해석하려는 경우 로더는 다음과 같은 일련의 접근 방식을 사용하여 유효한 경로로 URL을 해석하려고 시도합니다.  먼저 세 가지 환경 변수 SHOTGUN_PATH_WINDOWS, SHOTGUN_PATH_MAC 및 SHOTGUN_PATH_LINUX를 찾습니다. 이러한 환경 변수가 정의되어 있으면 방식이 이런 식으로 경로를 변환하려고 시도합니다. 예를 들어, Windows에서 file:///prod/proj_x/assets/bush/file.txt를 해석하려는 경우 경로를 해석해야 하는 방법에 대한 힌트를 제공하기 위해 SHOTGUN_PATH_WINDOWS=P: prod 및 SHOTGUN_PATH_LINUX=/prod를 설정할 수 있습니다.  둘 이상의 환경 변수 세트를 사용하려는 경우 여러 저장소를 표현하려면 위 변수 이름 구문을 다음 접미사로 확장하면 됩니다.  렌더용 저장소가 있는 경우 SHOTGUN_PATH_LINUX_RENDERS, SHOTGUN_PATH_MAC_RENDERS 및 SHOTGUN_PATH_WINDOWS_RENDERS 등을 정의하여 게시된 모든 file:// URL에 대해 렌더 저장소 내부의 데이터를 참조하는 변환 메커니즘을 제공할 수 있습니다.  그런 다음 편집 데이터를 위한 저장소도 있는 경우 SHOTGUN_PATH_LINUX_EDITORIAL, SHOTGUN_PATH_MAC_EDITORIAL 및 SHOTGUN_PATH_WINDOWS_EDITORIAL을 정의하여 편집 저장소 루트에 변환 메커니즘을 제공할 수 있습니다.이러한 환경 변수를 표준화하고 나면 이를 Flow Production Tracking 로컬 저장소로 변환하는 것을 고려할 수 있습니다. Flow Production Tracking 기본 설정에서 이 환경 변수를 정의하고 나면 자동으로 선택되기 때문에 환경 변수가 필요하지 않습니다.  위 내용 외에도 Flow Production Tracking 기본 설정에 정의되어 있는 모든 로컬 저장소는 동일한 방식으로 처리됩니다.  로컬 저장소는 정의되었지만 운영 체제가 없는 경우 환경 변수를 통해 제공할 수 있습니다. 예를 들어, Linux 및 Windows에서 정의되어 있는 Renders라는 로컬 저장소가 있는 경우 이름이 SHOTGUN_PATH_MAC_RENDERS인 환경 변수를 생성하여 Mac을 지원하도록 확장할 수 있습니다. 이에 대한 일반 구문은 SHOTGUN_PATH_&amp;lt;WINDOWS|MAC|LINUX&amp;gt;_&amp;lt;STORAGENAME&amp;gt;입니다.  일치하는 루트가 없는 경우 해당 파일 경로는 그대로 반환됩니다.다음은 예입니다./projects/some/file.txt 파일을 Linux에 게시했고 URL이 file:///projects/some/file.txt인 Flow Production Tracking 게시가 생성되었다고 가정해 보겠습니다. 스튜디오에서 Linux 경로 /projects는 Windows의 Q: projects와 동일하기 때문에 전체 경로가 Q: projects some file.txt로 변환될 것으로 예상할 수 있습니다.다음 설정은 모두 이를 처리합니다.  일반 환경 기반 재정의:  SHOTGUN_PATH_LINUX=/projects  SHOTGUN_PATH_WINDOWS=Q: projects      SHOTGUN_PATH_MAC=/projects        다음과 같이 설정된 “Projects”라고 하는 Flow Production Tracking 로컬 저장소:    Linux 경로: /projects  Windows 경로: Q: projects      Mac 경로: /projects        다음 환경 변수를 인자로 가지는 “Projects”라고 하는 Flow Production Tracking 로컬 저장소:    Linux 경로: /projects  Windows 경로:  Mac 경로: /projects  SHOTGUN_PATH_WINDOWS_PROJECTS=Q: projects참고: Flow Production Tracking에서 Linux path 설정을 통해 로컬 저장소 Renders를 정의했고 SHOTGUN_PATH_LINUX_RENDERS 환경 변수도 정의한 경우 해당 저장소가 우선 순위를 가지고, 환경 변수는 무시되며 경고가 기록됩니다. 일반적으로 로컬 저장소 정의는 항상 환경 변수보다 우선 순위를 가집니다.고급 구성PublishedFile 경로 해석을 수행하는 기본 방법에 대한 자세한 정보는 개발자 참조 문서를 참조하십시오.고급 프로젝트 설정을 사용하는 경우 resolve_publish 코어 후크를 커스터마이즈하는 방식으로 로컬 파일 링크 및 file:// URL 이상의 지원을 추가할 수 있습니다. 가능한 커스터마이즈 항목은 다음과 같습니다.  관련 업로드 파일과 함께 게시된 항목은 코어 후크에 의해 캐시 위치에 자동으로 다운로드되고 해당 경로가 반환됩니다.  커스텀 URL 구성표(예: perforce://)는 로컬 경로로 해석될 수 있습니다.브라우저 통합Flow Production Tracking 툴킷의 브라우저 통합 덕분에 Flow Production Tracking 웹 응용프로그램의 상황에 맞는 메뉴를 마우스 오른쪽 버튼으로 클릭하여 툴킷 앱 및 시작 관리자에 액세스할 수 있습니다. 위에 표시된 예와 같이 이러한 메뉴에는 다양한 엔티티 유형에 대해 구성된 액션이 있습니다. 한 프로젝트에 여러 파이프라인 구성을 사용하는 경우 액션은 파이프라인 구성별로 구성됩니다. 브라우저 통합을 통해 Maya 또는 Nuke와 같이 Flow Production Tracking 컨텍스트를 인식하고 있는 컨텐츠 생성 소프트웨어를 브라우저에서 바로 시작할 수 있습니다.간단한 브라우저 통합 내역지난 몇 년간, Flow Production Tracking 툴킷의 브라우저 통합은 여러 형태를 거쳤습니다. 기술 및 보안 요구사항이 발전함에 따라 브라우저 통합을 구현하는 접근 방식이 필요합니다.Java 애플릿(더 이상 사용되지 않음)첫 번째 구현은 Flow Production Tracking 웹 응용프로그램에서 로컬 데스크톱에 액세스할 수 있게 해 주는 Java 애플릿으로 구성됩니다. Java 애플릿은 악용될 수 있는 보안 위험 요소로 인식되었기 때문에 선호도가 낮아져 이제는 더 이상 사용되지 않습니다.브라우저 플러그인(더 이상 사용되지 않음)더 이상 사용되지 않는 Java 애플릿을 대체한 것은 브라우저 플러그인으로, NPAPI를 사용하여 Flow Production Tracking 웹 응용프로그램에서 로컬 데스크톱으로 액세스할 수 있었습니다. NPAPI도 보안 위험 요소로 인식되었기 때문에 주요 웹 브라우저에서 사용을 중단하기 시작했습니다. 이로 인해 브라우저 플러그인은 더 이상 사용하지 않게 되었습니다.Flow Production Tracking 데스크톱을 통한 Websockets v1(레거시)Flow Production Tracking 데스크톱 앱에서 Websocket 서버를 호스트하는 방식은 과거에도, 그리고 현재에도 Flow Production Tracking 웹 응용프로그램에서 로컬 데스크톱과 통신하는 방식입니다. 이 Websocket 서버의 RPC API를 이용한 첫 번째 구현에는 이전에 Java 애플릿 및 브라우저 플러그인을 위해 개발된 것과 동일한 기반 기술이 활용되었습니다. 서버가 Flow Production Tracking로부터 요청을 받으면 관련 프로젝트의 파이프라인 구성에 있는 탱크 명령을 사용하여 액션 메뉴에 표시할 명령 목록을 가져옵니다.Flow Production Tracking 데스크톱을 통한 Websockets v2Websocket 서버의 RPC API를 이용한 두 번째 반복은 툴킷 액션을 가져오고, 캐싱 및 실행하는 데 사용되는 기반 메커니즘을 변경합니다. 이 구현은 이전의 브라우저 통합과 관련된 많은 성능 문제를 해결하고 액션 메뉴의 시각적 구성을 개선하며 명시적으로 툴킷을 구성하지 않아도 작동하는 기본적인 Flow Production Tracking 통합에 대한 지원을 추가합니다. 이것이 현재 구현되어 있는 브라우저 통합입니다.구성각 엔티티 유형마다 사용자에게 표시되는 액션을 제어하려면 프로젝트의 파이프라인 구성에서 YAML 환경 파일을 수정합니다. 처음 커스터마이즈를 시도할 때 이해하고 고려할 몇 가지 사항이 있습니다.구성할 엔진Flow Production Tracking 웹 앱 내에서 툴킷 액션을 관리하는 툴킷 엔진은 tk-shotgun이므로 이것이 액션 메뉴에 표시되는 항목을 제어하는 이 엔진의 구성입니다.위의 tk-config-basic 예에는 많은 엔진 명령이 메뉴 액션으로 바뀌게 되는 두 가지 앱이 구성되어 있습니다. 툴킷 앱은 액션 메뉴에 포함될 명령을 등록합니다. 여기에는 Flow Production Tracking 사이트의 소프트웨어 엔티티 목록에 해당하는 로컬 시스템의 각 소프트웨어 패키지에 대한 시작 관리자 명령이 포함됩니다. 그 결과가 다음과 같이 표시되는 메뉴 액션 목록입니다.브라우저 통합 코드는 사용자의 시스템에 Houdini, Maya, Nuke 및 Photoshop을 설치할 때 찾을 수 있으며 이러한 각 통합을 시작하기 위한 메뉴 액션이 됩니다. 특정 환경 구성 파일에서 해당 소프트웨어의 시작 관리자가 해당 환경의 엔티티를 표시하도록 하려면 소프트웨어 엔티티의 _엔진_이 있어야 합니다. 따라서 이 예에서는 이 코드 조각을 가져온 파일에 tk-houdini, tk-maya, tk-nuke 및 tk-photoshopcc 엔진이 모두 있어야 합니다. 예를 들어, 이 엔티티에 있는 시작 관리자 목록에서 Maya를 제거하려면 환경 구성 파일에서 tk-maya 엔진 블록만 제거하면 됩니다.이러한 시작 관리자뿐만 아니라 Publish 앱의 “게시…(Publish…)” 명령도 메뉴에 포함됩니다.YML 파일이란 무엇입니까?기본 환경 구성(config/env/*.yml)을 활용하며 구성의 pick_environment.py core hook에 의해 제어되는 경로와 tk-config-default에 의해 적용된 레거시 접근 방식(config/env/shotgun_&amp;lt;entity_type&amp;gt;.yml 파일 사용)을 활용하는 경로 중 하나를 사용할 수 있습니다.표준 환경 파일이 사용된 경우 브라우저 통합은 pick_environment 코어 후크를 사용하여 특정 엔티티의 액션 메뉴에 사용할 환경 구성 파일을 결정합니다. 가장 간단한 사례에서는 환경이 곧 엔티티 유형에 해당합니다. 예를 들어, 샷을 마우스 오른쪽 버튼으로 클릭하면 최종 액션 메뉴가 tk-shotgun 블록에 의해 config/env/shot.yml에 구성됩니다. pick_environment 후크를 커스터마이즈하여 보다 복잡한 로직을 사용할 수 있습니다. 표준 환경 파일에는 tk-shotgun 엔진을 구성해서는 안 됩니다. shotgun_&amp;lt;entity_type&amp;gt;.yml 파일이 있으면 대체될 수 있습니다. 이렇게 하면 브라우저 통합이 엔티티 특정 환경 파일을 사용하는 레거시 구성과 연동될 수 있습니다.팁: tk-config-default2를 사용하여 브라우저 시작 관리자에서 소프트웨어 제거Flow Production Tracking 브라우저에서 소프트웨어를 시작하기 위한 구성을 업데이트하는 작업은 tk-config-default부터 tk-config-default2까지 다양합니다.tk-config-default2를 사용하면 업데이트를 config/env/includes/settings/tk-shotgun.yml에 적용해야 합니다. 반면에 tk-config-default에서는 업데이트를 config/env/shotgun_task.yml에 적용했습니다.예를 들어 브라우저를 통해 에셋에서 실행할 때 옵션 목록에서 Mari를 제거해 보겠습니다.먼저 config/env/asset.yml로 이동하여 tk-shotgun 엔진 블록이 어떻게 @settings.tk-shotgun.asset을 가리키는지 확인합니다. @ 기호는 구성 값이 포함된 파일에서 제공된 것임을 나타냅니다. 즉, 업데이트하려면 env/includes/settings/tk-shotgun.yml로 이동해야 합니다.env/includes/settings/tk-shotgun.yml에서 각 블록이 엔티티에 대해 어떻게 되는지 확인하십시오. 예를 들어 에셋은 먼저 다음과 같이 됩니다.&amp;lt;a name=&quot;asset&quot;&amp;gt;&amp;lt;/a&amp;gt;# assetsettings.tk-shotgun.asset:  apps:    tk-multi-launchapp: &quot;@settings.tk-multi-launchapp&quot;    tk-multi-launchmari: &quot;@settings.tk-multi-launchapp.mari&quot;    tk-multi-launchmotionbuilder: &quot;@settings.tk-multi-launchapp.motionbuilder&quot;    tk-multi-publish2: &quot;@settings.tk-multi-publish2.standalone&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-shotgun-folders: &quot;@settings.tk-shotgun-folders&quot;    tk-shotgun-launchfolder: &quot;@settings.tk-shotgun-launchfolder&quot;  location: &quot;@engines.tk-shotgun.location&quot;브라우저에서 에셋에 대한 목록에서 Mari를 제거하려면 Mari 행(tk-multi-launchmari: &quot;@settings.tk-multi-launchapp.mari&quot;)을 제거합니다.&amp;lt;a name=&quot;asset&quot;&amp;gt;&amp;lt;/a&amp;gt;# assetsettings.tk-shotgun.asset:  apps:    tk-multi-launchapp: &quot;@settings.tk-multi-launchapp&quot;    tk-multi-launchmotionbuilder: &quot;@settings.tk-multi-launchapp.motionbuilder&quot;    tk-multi-publish2: &quot;@settings.tk-multi-publish2.standalone&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-shotgun-folders: &quot;@settings.tk-shotgun-folders&quot;    tk-shotgun-launchfolder: &quot;@settings.tk-shotgun-launchfolder&quot;  location: &quot;@engines.tk-shotgun.location&quot;그런 다음 Flow Production Tracking 브라우저에서 특정 소프트웨어를 시작하는 기능을 제거하려는 각 엔티티(Shot과 같은)에 대해 동일한 지침을 따릅니다. 파일을 저장하고 나면 잠시 기다렸다가 브라우저를 새로 고침하여 적용해야 할 수 있습니다.캐싱브라우저 통합의 강력한 캐싱 메커니즘을 통해 사용자에게 메뉴 액션을 최대한 빨리 표시할 수 있습니다. 캐싱이 필요한 이유는 툴킷 부트스트래핑 및 엔진 명령 목록 가져오기 프로세스에 많은 시간이 소요될 수 있기 때문입니다.캐시가 무효화되는 경우는 언제입니까?Websocket 서버의 RPC API는 두 가지(YAML 파일 수정 시간 및 사이트의 소프트웨어 엔티티 컨텐츠)를 확인하여 캐시된 데이터가 여전히 유효한지 여부를 결정합니다. 캐시 데이터가 작성된 이후 특정 구성의 환경 YAML 파일 중 하나가 수정된 경우 필수 데이터가 다시 캐시되어 새 데이터가 Flow Production Tracking 웹 응용프로그램으로 반환됩니다. 마찬가지로, 해당 데이터가 캐시된 이후 Flow Production Tracking에서 소프트웨어 엔티티에 있는 필드가 수정된 경우 툴킷은 부트스트래핑되고 새 데이터가 캐시됩니다.디스크에서 캐시 파일은 어디에 위치합니까?캐시 파일 위치는 운영 체제에 따라 다릅니다.OS X: ~/Library/Caches/Shotgun/&amp;lt;site_name&amp;gt;/site.basic.desktop/tk-desktopWindows: %APPDATA% Shotgun &amp;lt;site_name&amp;gt; site.basic.desktop tk-desktopLinux: ~/.shotgun &amp;lt;site_name&amp;gt; site.basic.desktop tk-desktop후크 방법browser_integration.py 후크는 tk-framework-desktopserver에 포함되어 있으며 다음과 같은 후크 방법을 제공합니다.  get_cache_key: 이 방법을 통해 특정 구성 URI, 프로젝트 엔티티 및 엔티티 유형에 대한 캐시 항목 키를 확인합니다. 기본 구현에서는 구성 URI와 엔티티 유형을 결합합니다.  get_site_state_data: 이 방법은 Flow Production Tracking의 추가 쿼리 데이터를 캐시된 데이터의 유효성을 테스트하는 데 사용된 해시에 포함할 때 사용할 수 있습니다. 기본적으로 사이트에 존재하는 모든 소프트웨어 엔티티의 현재 상태 그대로 사용되지만 해시에 추가 데이터를 포함해야 하는 경우 이 후크 방법으로 구현할 수 있습니다.  process_commands: 이 방법을 사용해 Flow Production Tracking 웹 응용프로그램으로 반환되는 명령을 커스터마이즈 또는 변경할 수 있습니다. 이 방법에 제공되는 데이터의 구조는 사전 목록으로, 각 사전은 단일 메뉴 액션을 나타냅니다. 데이터는 변경하거나, 필터링하거나, 아니면 그대로 목록에 추가할 수 있으며 즉각적인 툴킷 액션을 요청하는 메뉴에 반영됩니다.로그브라우저 통합 로그는 툴킷의 표준 로그 위치에서 확인할 수 있습니다. 관련 로그 파일은 tk-desktop.log 및 tk-shotgun.log입니다. 또한 Google Chrome을 사용하는 경우 브라우저의 개발자 콘솔에서 몇 가지 관련 로그 출력을 사용할 수도 있습니다.문제 해결웹 응용프로그램과 로컬 데스크톱 사이의 통신은 복잡하기 때문에 그 과정에서 장애가 발생할 수도 있습니다. 다음은 그러한 몇 가지 상황과 장애 발생 시 취해야 하는 첫 번째 단계의 제안 사항입니다.액션 메뉴에 “Flow Production Tracking 데스크톱을 열거나 설치…(Open or install Flow Production Tracking Toolkit…)”가 표시됨다음 세 가지 중 하나를 의미합니다.      현재 로컬 컴퓨터에서 Flow Production Tracking 데스크톱이 실행되고 있지 않습니다. 실행되는 것처럼 보이더라도 반드시 다시 확인할 필요가 있습니다.        Chrome 또는 Python Websocket 서버가 연결을 거부했기 때문에 Flow Production Tracking 웹 응용프로그램에서 Flow Production Tracking 데스크톱과 통신할 수 없습니다. 이 상황은 대부분 자체 서명된 인증서와 관련되어 있으며 요청 시 연결을 설정할 수 있습니다. 이러한 인증서를 처음부터 다시 생성하면 문제가 해결되기도 하며 다음과 같이 Flow Production Tracking 데스크톱에서 트리거할 수 있습니다.    시작 시 Flow Production Tracking 데스크톱의 Websocket 서버를 시작하지 못했습니다. 이 상황은 잘못된 Websocket 서버 릴리즈가 사용자에게 공개된 경우에만 해당되며 거의 발생하지 않습니다. 이 상황의 경우 tk-desktop.log에 해당 오류를 설명하는 로그가 기록되며 이 로그를 Flow Production Tracking의 지원 팀에 전달할 수 있습니다.액션 메뉴에 표시되는 액션이 없음이 엔티티 유형에 대한 액션이 예상되었던 경우 구성에 문제가 있음을 의미합니다. 몇 가지 가능한 문제:      tk-shotgun 엔진이 올바른 환경 YAML 파일에서 구성되었지만 해당 구성에 앱이 없습니다. 이 경우, 이 엔티티 유형에 대한 액션이 없는 것이 의도된 것일 수 있습니다.        tk-shotgun 엔진이 올바른 환경 YAML 파일에서 구성되었고 앱도 있지만 메뉴에 여전히 액션이 표시되지 않습니다. 앱을 초기화하지 못한 것이 원인일 가능성이 높습니다. 이 경우 tk-shotgun.log 및 tk-desktop.log에 문제를 설명하는 정보가 있을 것입니다.        이 엔티티 유형에 해당하는 환경에 tk-shotgun에 대한 구성이 포함되어 있지 않습니다. 최종 결과는 이 목록에 있는 1번과 동일합니다. 이 경우, 파이프라인 구성의 pick_environment 후크를 살펴보고 이 엔티티 유형에 대해 로드되고 있는 환경을 살펴본 후에 거기에서 tk-shotgun의 구성을 검증하면 됩니다.        디스크에 캐시된 메뉴 액션 목록이 비어 있습니다. 강제로 캐시를 다시 생성할 수 있는 몇 가지 방법이 있습니다.          프로젝트 구성에서 YAML 파일의 수정 시간을 업데이트합니다. 이렇게 하면 다음에 Flow Production Tracking에서 요청했을 때 메뉴 액션이 다시 캐시됩니다. 단, 이 방법을 사용하면 해당 프로젝트에서 작업 중인 모든 사용자를 다시 캐시합니다.      Flow Production Tracking 사이트에서 소프트웨어 엔티티의 필드 값을 업데이트합니다. 여기서 수행되는 작업은 YAML 파일 수정 시간에 관한 위 옵션과 동일하지만 Flow Production Tracking 사이트에서 모든 프로젝트의 모든 사용자에 대해 캐시된 데이터를 무효화합니다. 소프트웨어 엔티티는 비 프로젝트 엔티티이므로 모든 프로젝트에서 공유됩니다. 소프트웨어 엔티티의 데이터를 변경하면 모든 프로젝트가 영향을 받습니다.      문제가 발생한 호스트에 있는 캐시 파일은 삭제할 수 있습니다. 일반적으로 캐시는 제거해도 문제가 없으며 각 호스트에 로컬로 저장되기 때문에 해당 시스템에서 데이터만 처음부터 다시 캐시합니다. 캐시는 Flow Production Tracking 캐시 위치 내부의 다음 SQLite 파일에 저장됩니다. &amp;lt;site-name&amp;gt;/site.basic.desktop/tk-desktop/shotgun_engine_commands_v1.sqlite      “툴킷: 액션 검색 중…(Toolkit: Retrieving actions…)”이 메뉴 액션으로 대체되지 않음이 문제가 발생할 수 있는 몇 가지 원인이 있습니다.      Websocket 서버가 아직 캐싱 액션을 완료하지 않았습니다. 이번이 프로젝트 구성에 대한 중요한 업데이트 후 검색하는 첫 번째 액션인 경우 프로세스를 완료하는 데 시간이 약간 걸릴 수 있습니다. 조금 더 기다리다가 아직 진행 중인지 확인하려면 tk-desktop.log의 내용을 살펴봅니다.        Websocket 서버가 계속 응답하지 않습니다. 이런 상황은 드물게 나타나지만 tk-desktop.log를 살펴보았을 때 액션 요청의 결과로 발생하는 추가 프로세스가 없는 것이 확실하다면, Flow Production Tracking 지원 팀에 문의하고 관련 로그 데이터를 제공합니다.        사용자가 두 개 이상의 Flow Production Tracking 사이트에서 작업 중입니다. 단일 사이트에서 Flow Production Tracking 데스크톱을 인증한 상태에서 두 번째 Flow Production Tracking 사이트에서 메뉴 액션을 요청하면 사용자에게 Flow Production Tracking 데스크톱을 다시 시작하여 새 사이트에 로그인하라는 메시지가 표시됩니다. 해당 요청을 무시하면 두 번째 사이트는 메뉴 액션 목록을 받을 수 없습니다.  툴킷 구성 파일스튜디오에서 프록시 서버를 사용하는 경우, 초기 로그인 화면에 몇 가지 값을 미리 입력해 두려는 경우 또는 브라우저 기반 응용프로그램 시작 관리자가 Flow Production Tracking 데스크톱과 상호 작용하는 방식을 변경하려는 경우에 사용할 수 있는 toolkit.ini라는 특수 구성 파일이 있습니다. Flow Production Tracking 데스크톱을 실행하는 데는 이 파일이 필요하지 않으며 데스크톱의 동작을 구성해야 하는 경우에만 필요합니다. 툴킷은 다음과 같은 순서로 여러 위치에서 이 파일을 찾습니다.  파일 경로를 가리키는 SGTK_PREFERENCES_LOCATION이라는 환경 변수  Flow Production Tracking 툴킷 기본 설정 폴더 내: (이 파일은 기본적으로 이러한 위치에 없으며 직접 생성해야 함)          Windows: %APPDATA% Shotgun Preferences toolkit.ini      macOS: ~/Library/Preferences/Shotgun/toolkit.ini      Linux: ~/.shotgun/preferences/toolkit.ini      SGTK_PREFERENCES_LOCATION 환경 변수 옵션을 사용하면 컴퓨터 또는 네트워크의 다른 곳에 구성 파일을 저장할 수 있습니다. toolkit.ini가 현재 표준 파일 이름입니다. config.ini를 사용 중인 경우 아래 “레거시 위치” 섹션을 확인하십시오.여기에서 설명된 구성 파일의 예를 확인할 수 있습니다.이 예제 파일은 config.ini라고 하지만 toolkit.ini로 이름을 바꿀 수도 있습니다.또한 이 파일에서 환경 변수는 물론 하드 코딩된 값도 사용할 수 있습니다. 예를 들면, Windows에 있는 USERNAME 변수를 통해 사용자에게 제안할 기본 사용자 이름을 선택할 수 있습니다.레거시 위치(더 이상 사용되지 않음)toolkit.ini가 현재 표준 파일 이름이지만 이전에는 config.ini 파일을 동일한 용도로 사용했습니다. toolkit.ini 및 config.ini의 내용은 동일합니다. 더 이상 사용되지 않는 다음 위치를 사용하면 config.ini가 검색됩니다.  파일을 가리키는 SGTK_DESKTOP_CONFIG_LOCATION이라는 환경 변수  다음 경로:          Windows: %APPDATA% Flow Production Tracking Toolkit config config.ini      macOS: ~/Library/Caches/Shotgun/desktop/config/config.ini      Linux: ~/shotgun/desktop/config/config.ini      프록시 구성스튜디오에서 프록시를 통해 인터넷에 액세스하는 경우 인터넷에 액세스할 때 이 프록시를 사용하도록 툴킷을 설정해야 합니다. 그렇게 하려면 프록시를 http_proxy 설정 값으로 지정하면 됩니다.http_proxy: &amp;lt;proxy_server_address&amp;gt;로컬에서 호스팅되는 사이트를 통해 Flow Production Tracking 데스크톱 실행Flow Production Tracking 사이트 URL이 shotgunstudio.com 또는 shotgrid.autodesk.com으로 끝나지 않는 경우 로컬 Flow Production Tracking 사이트에서 실행 중임을 의미합니다. 이 경우 아직 사이트가 Flow Production Tracking 통합에 맞춰 완벽하게 준비되지 않았을 가능성이 있기 때문에 Flow Production Tracking 팀에서 현장을 방문하여 통합을 진행하기 전에 약간의 조정 작업을 해야 할 수 있습니다! 이 경우 티켓을 제출하면 준비를 지원해 드리겠습니다.로컬에서 호스팅되는 사이트를 통해 앱 스토어에 연결로컬 Flow Production Tracking 사이트를 사용하여 프록시를 통해 인터넷에 액세스하는 경우 로컬 Flow Production Tracking 웹 사이트가 아닌 앱 스토어에 액세스하도록 HTTP 프록시를 설정할 수 있습니다. 이렇게 하려면 다음 행을 toolkit.ini에 추가하면 됩니다.app_store_http_proxy: &amp;lt;proxy_server_address&amp;gt;여기서 &amp;lt;proxy_server_address&amp;gt;는 개발자 문서에 문서화된 규칙을 따르는 문자열입니다.프로젝트에 따라 이 설정을 재지정해야 하는 경우 프로젝트의 파이프라인 구성에 있는 config/core/shotgun.yml에서 수행할 수 있습니다.오프라인 사용 시나리오일반적 사용 시 Flow Production Tracking 데스크톱은 시작할 때 데스크톱 앱, tk-desktop 엔진 및 기초 구성에 대한 업데이트를 자동으로 확인합니다. 그러나 오프라인 상태 또는 인터넷 연결이 완전히 해제된 컴퓨터에서 통합을 실행해야 하는 경우도 있습니다. 다음 섹션에서는 이러한 각 시나리오에서의 해결 방법에 대해 설명합니다.Flow Production Tracking Create이 문서에 설명된 오프라인 사용 시나리오의 해결 방법은 Flow Production Tracking Create에서 제공하는 통합 기능에도 적용됩니다. Flow Production Tracking 툴킷의 동작을 맞춤 설정하는 데 사용되는 다양한 환경 변수(예: SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS)는 Flow Production Tracking Create를 Flow Production Tracking 데스크톱과 동일한 방법으로 사용하는 경우 적용됩니다.오프라인 상태에서 통합 실행시나리오: Flow Production Tracking 통합을 실행하고 싶지만 인터넷에 연결되어 있지 않습니다. 우리에게는 로컬 Flow Production Tracking 설치가 있습니다.솔루션  일시적으로 인터넷에 연결할 수 있는 경우 그냥 Flow Production Tracking 데스크톱을 다운로드합니다. 여기에는 일련의 통합 항목이 미리 패키징되어 있으며 지원되는 모든 DCC에서 Flow Production Tracking 통합에 필요한 모든 앱과 엔진을 사전 번들로 제공합니다. 데스크톱을 시작하면 자동으로 업그레이드를 검색합니다. 하지만, Flow Production Tracking 앱 스토어에 연결할 수 없는 경우 로컬에 있는 가장 최신 버전을 실행합니다.유용한 정보  일부 툴킷 작업(예: 게시 등록)을 사용하려면 Flow Production Tracking 사이트에 액세스해야 합니다. 따라서 이 솔루션은 로컬에서 호스팅되는 사이트에서만 유효합니다.  업데이트는 로컬 컴퓨터에 다운로드됩니다.  연결과 연결 해제 사이를 오가는 경우 데스크톱뿐만 아니라 Maya 및 Nuke에 있는 앱 내 통합도 시작 시 업그레이드를 다운로드합니다(연결되어 있을 때마다).수동 다운로드를 통해 업데이트 관리시나리오: 아티스트의 워크스테이션이 인터넷에 연결되어 있지 않기 때문에 데스크톱에서 자동 업데이트를 사용할 수 없습니다. 업데이트를 다운로드하고 싶지만 단일 온라인 컴퓨터를 통해 다운로드한 다음 이를 수동으로 아티스트의 컴퓨터 또는 중앙 위치로 전송해야 합니다.솔루션  인터넷에 연결된 워크스테이션에서 Flow Production Tracking 데스크톱을 실행합니다. 시작할 때 최신 업그레이드가 자동으로 다운로드됩니다.  옵션 1: 공유 데스크톱 번들  번들 캐시를 모든 컴퓨터가 액세스할 수 있는 공유 위치에 복사합니다.  오프라인 컴퓨터에서 SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS 환경 변수가 이 위치를 가리키도록 설정합니다.  오프라인 컴퓨터에서 데스크톱을 시작하면 번들 캐시에서 사용할 수 있는 최신 업그레이드를 선택합니다.  옵션 2: 로컬 배포  업데이트된 번들 캐시를 각 로컬 컴퓨터의 올바른 번들 캐시 위치에 배포합니다.유용한 정보  옵션 1을 사용하면 SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS에 정의된 위치에서 툴킷 코드가 로드됩니다. 이 위치가 공유 저장소인 경우 작은 파일을 여러 개 로드할 수 있는지 확인합니다.  Windows 설정에서는 이 옵션이 적합하지 않은 경우가 많습니다. 여기서는 옵션 2를 권장합니다.업데이트 잠그기데스크톱의 자동 업데이트는 항상 최신 버전을 사용할 수 있다는 점에서 편리하지만, 간혹 프로젝트 또는 사이트 전체를 동결하고 특정 버전으로 잠그거나 모든 업데이트를 차단해야 하는 경우가 있을 수도 있습니다.단일 프로젝트에 대한 업데이트 중지시나리오: 프로젝트가 거의 마무리 단계인데 Flow Production Tracking 통합 업데이트가 자동으로 다운로드되지 않도록 프로젝트를 동결하려고 합니다.솔루션  프로젝트를 잠글 버전을 결정합니다. 통합 릴리즈는 여기에서 확인할 수 있습니다.  Flow Production Tracking에서 잠그려는 프로젝트에 대한 파이프라인 구성 엔티티를 만들고 다음 필드를 입력합니다(이 예에서는 v1.0.36의 통합을 사용하도록 구성을 잠금).  이름: Primary  프로젝트: 잠그려는 프로젝트  플러그인 ID: basic.*      디스크립터: sgtk:descriptor:app_store?name=tk-config-basic&amp;amp;version=v1.0.36    이제 프로젝트에서 Flow Production Tracking 데스크톱을 시작하는 모든 사람은 항상 v1.0.36을 사용합니다. 프로젝트에서 작업을 시작하는 새 사용자도 v1.0.36을 받게 됩니다.유용한 정보  업데이트는 로컬 컴퓨터에 다운로드됩니다.  다음에 사용자가 인터넷에 연결된 상태에서 데스크톱을 시작하면 기초 구성 v1.0.36 및 해당 기초 구성의 모든 관련 코드가 컴퓨터로 다운로드됩니다.  basic.*은 기초 구성에 있는 모든 플러그인이 이 재정의를 선택하게 됨을 의미합니다. 예를 들어, Nuke 및 Maya 통합만 중지하려는 경우 basic.maya, basic.nuke를 지정하면 됩니다.  테스트하려면 이 파이프라인 구성 엔티티를 복제한 다음 User Restrictions 필드에 사용자 이름을 추가하면 됩니다. 이렇게 하면 엔티티를 제한하게 되는데, 사용자에게만 적용되고 다른 사용자에게는 영향을 주지 않습니다. 그런 다음 이 복제 구성에서 Maya 또는 다른 소프트웨어를 시작하여 예상 통합 버전을 실행 중인지 확인할 수 있습니다.알려진 문제  Flame 통합의 네임스페이스는 basic.flame으로 지정되기 때문에 basic.*의 일부로 생각될 수 있습니다. 그러나 실제로 Flame 통합은 기초 구성에 포함되지 않습니다. 따라서 프로젝트에 Flame을 사용 중이고 이 재정의를 구현하는 경우 Flame 통합의 작동이 중지됩니다.  이 솔루션은 특히 Flame에 있어 추가 파이프라인 구성 재정의를 생성하게 됩니다.  이름: Primary  프로젝트: 잠그려는 프로젝트(또는 모든 프로젝트에 대해 “없음(None)”)  플러그인 ID: basic.flame  디스크립터: sgtk:descriptor:app_store?name=tk-config-flameplugin사이트에 대한 업데이트 중지시나리오: 업데이트를 하고 싶지 않습니다. 다운로드되는 항목과 스튜디오의 모든 프로젝트에서 사용되는 항목을 완전하게 제어하고 싶습니다.솔루션  위의 예에 있는 단계를 따르고 Project 필드만 비워 둡니다. Project 필드를 재정의하지 않은 상태에서 이 파이프라인 구성 엔티티는 “사이트” 프로젝트(즉, 프로젝트 외부에 있는 데스크톱에서 사용되는 사이트 구성)를 포함한 모든 프로젝트에 적용됩니다.유용한 정보  이는 “사이트 구성을 잠그려는” 경우 사용할 워크플로우입니다. 이렇게 하면 모든 항목이 잠기며 이제 데스크톱 메뉴를 통해 고급 프로젝트 설정으로 진행할 수 있습니다.  사용할 사이트 전체를 잠글 경우에도(예: v1.2.3) 개별 프로젝트를 잠근 후 다른 구성을 사용할 수 있습니다.알려진 문제  이 작업은 Flame에 영향을 줍니다. 솔루션은 위 시나리오의 ‘알려진 문제’ 섹션을 참조하십시오.하나만 제외하고 모든 프로젝트에 대한 업데이트 중지시나리오: 자동 업데이트를 계속 허용할 테스트 프로젝트를 제외하고 사이트에 있는 모든 프로젝트를 잠그려고 합니다.솔루션  위 섹션에서 설명한 대로 사이트에 대한 업데이트를 중지합니다.  예외 프로젝트의 파이프라인 구성 엔티티가 다음 필드 값을 갖도록 구성합니다.  이름: Primary  프로젝트: 잠그지 않으려는 프로젝트  플러그인 ID: basic.*  디스크립터: sgtk:descriptor:app_store?name=tk-config-basic유용한 정보  프로젝트의 디스크립터 필드에서 버전 번호를 생략했습니다. 따라서 프로젝트가 최신 기초 구성 릴리즈를 추적하게 됩니다.잠긴 사이트의 안전한 업그레이드  시나리오: 현재 v1.0.0으로 잠근 상태인데 v2.0.0으로 업그레이드하려고 합니다. 스튜디오로 배포하기 전에 먼저 새 버전을 테스트하고 싶습니다.*솔루션  Flow Production Tracking에서 파이프라인 구성 엔티티를 마우스 오른쪽 버튼으로 클릭하고 “선택 항목 복제(Duplicate Selected)”를 선택하여 복제합니다.  복제한 구성 이름을 “update test”로 지정하고 자신을 사용자 제한(User Restrictions) 필드에 할당합니다.  이제 이 파이프라인 구성을 사용하기 시작합니다.  테스트할 버전을 가리키도록 디스크립터를 변경합니다.  테스트에 참여하게 하려는 모든 사용자를 사용자 제한(User Restrictions) 필드에 추가하면 초대할 수 있습니다.  테스트에 만족한 경우 기본 파이프라인 구성이 해당 버전을 사용하도록 업데이트하기만 하면 됩니다.  사용자가 데스크톱 또는 DCC를 다시 시작하면 해당 업데이트가 선택됩니다.파이프라인 구성 가져오기구성을 전혀 설정하지 않고 기본 Flow Production Tracking 통합 항목을 즉시 가져올 수 있습니다. 이 문서에서는 이러한 기본 제공 통합에서 수행 가능한 관리 작업 유형에 대해 설명합니다. 이 기본 설정은 Flow Production Tracking의 툴킷 플랫폼을 기반으로 하기 때문에 훨씬 더 다양한 커스터마이즈를 지원합니다. 데스크톱의 툴킷 프로젝트 설정 마법사가 프로젝트에서 커스터마이즈 가능한 파이프라인 구성을 완벽하게 생성하는 프로세스를 안내합니다.아래의 각 섹션에서는 설정 방법을 잘 모르는 사용자를 위해 적절한 기본값에 대한 예시 및 제안 사항과 함께 마법사의 각 단계를 자세히 설명합니다.데스크톱에서 설정 마법사 시작프로젝트로 이동하면 데스크톱 오른쪽 아래 사용자 메뉴에 “고급 프로젝트 설정…(Advanced Project Setup…)” 메뉴 항목이 있습니다. 이 메뉴 항목을 클릭하여 툴킷 설정 마법사를 시작합니다.구성 유형 선택새 프로젝트 구성을 시작할 때 가장 먼저 결정해야 할 _사항은 사용할 구성 템플릿_입니다. 구성 템플릿은 기본적으로 프로젝트를 실행하는 데 필요한 모든 설정, 파일 시스템 템플릿, 앱 및 로직이 포함된 완전한 프로젝트 구성입니다.  프로젝트를 처음 사용하는 경우 Flow Production Tracking 기본값으로 시작하는 것이 좋습니다.  이전 프로젝트에서 이미 프로젝트 및 구성을 구성한 경험이 있는 경우 기존 프로젝트를 기반으로 새 프로젝트를 만들면 이러한 항목을 쉽게 다시 사용할 수 있습니다.  고급 워크플로우의 경우 외부 구성이나 git 리포지토리에 저장된 구성을 사용할 수 있습니다.기본 구성기본 툴킷 VFX 구성이며 일반적으로 설정을 시작할 때 유용한 시작점이 됩니다. 기본 구성은 3dsmax, Flame, Houdini, Nuke, Mari, Maya, Motionbuilder 및 Photoshop 설정과 함께 제공되며 단순하고 간편한 디스크 폴더 설정이 포함됩니다.구성에는 다음과 같은 다양한 항목이 포함됩니다.  파일 시스템 설정  디스크의 주요 위치를 식별하기 위한 일련의 템플릿  워크플로우에 함께 연결되어 있는 미리 구성된 일련의 엔진 및 앱파일 시스템 개요표준 구성은 Flow Production Tracking에서 에셋 및 샷을 처리합니다. 표준 구성은 파이프라인을 단계별로 나눕니다. 파이프라인 단계는 부서와 유사합니다. 각 파이프라인 단계에는 지원되는 다양한 응용프로그램에 대한 작업 및 게시 영역이 포함됩니다. 샷 구조는 다음과 같은 형태입니다.응용프로그램 및 워크플로우구성에는 다음과 같은 구성 요소가 포함됩니다.  Maya, Mari, Nuke, 3dsmax, Flame, Houdini, Photoshop 및 Motionbuilder 지원  Flow Production Tracking 응용프로그램 시작 관리자  게시, 스냅샷 만들기 및 버전 제어  Nuke 커스텀 Write Node  Flow Production Tracking 통합  기타 수많은 도구 및 유틸리티위에 나온 앱 외에도 구성을 설치하면 추가 앱과 엔진을 쉽게 설치할 수 있습니다.기존 프로젝트를 기반으로 새 프로젝트 만들기이전 프로젝트에서 사용했던 모든 기본값과 설정으로 새 프로젝트를 실행할 수 있는 빠르고 간편한 방법입니다. 툴킷에서 이전 설정의 모든 구성을 새 프로젝트로 간단하게 복사합니다. 이는 구성을 발전시키는 간단하고 실용적인 방법입니다(각각의 새 프로젝트는 기존 프로젝트를 기반으로 함).파이프라인 구성을 발전시키고 유지하는 방법에 대한 자세한 내용과 문서는 다음을 참조하십시오.프로젝트 구성 관리git의 구성 템플릿 사용소스 제어에 연결된 프로젝트 구성을 유지하려는 경우 이 옵션을 사용합니다. 원격 git 또는 github 리포지토리에 대한 URL을 지정하면 설정 프로세스가 이를 복제합니다. 이는 단지 github뿐만 아니라 모든 git 리포지토리에서도 작동합니다. 리포지토리 경로가 .git으로 끝나기만 하면 툴킷이 이를 git 설정으로 처리하려고 시도합니다. 프로젝트 구성은 git 리포지토리이기 때문에 마스터 리포지토리를 변경하고 해당 변경 사항을 푸시할 수 있으며 이후 다른 프로젝트에서도 가능합니다. github 기반 구성을 사용하면 여러 툴킷 프로젝트를 지속적으로 동기화할 수 있습니다. 다음에서 자세한 내용을 확인할 수 있습니다.프로젝트 구성 관리Windows에서 실행 중인 경우 컴퓨터에 git를 설치하고 PATH에서 액세스할 수 있어야 합니다. Linux 및 Mac OS X에서는 기본적으로 설치되어 있습니다.구성 템플릿 찾아보기디스크에 구성이 있는 경우 이 옵션을 사용합니다(폴더로 또는 zip 파일로 압축). 이 옵션은 다른 사람이 이메일로 구성을 보냈거나 모든 프로젝트의 기반이 되는 마스터 구성을 디스크에 유지하는 경우 유용할 수 있습니다. 이는 일반적으로 전문가 옵션이며 다른 프로젝트의 구성을 사용하거나 앱 스토어 기본 구성 중 하나를 사용하는 것이 좋습니다.저장소 설정각 툴킷 프로젝트는 모든 파일 및 데이터를 디스크에 있는 하나 이상의 공유 저장소 위치에 씁니다. 예를 들어, 구성에서 텍스처를 유지할 저장소 하나, 렌더를 유지할 저장소 하나 그리고 씬 파일을 저장할 저장소 하나를 요구할 수도 있습니다. 일반적으로 이러한 저장소는 Flow Production Tracking 사이트 기본 설정의 파일 관리(File Management) 탭에서 제어됩니다.툴킷 설정 마법사는 구성에 필요한 각 저장소 루트를 Flow Production Tracking의 로컬 저장소에 매핑하도록 요청합니다.필수 루트는 설명(구성의 roots.yml 파일에 정의된 대로)과 함께 왼쪽에 나열됩니다. 오른쪽에는 기존 Flow Production Tracking 로컬 저장소 목록이 나열됩니다. 필수 루트마다 저장소를 선택하고 현재 OS의 경로가 Flow Production Tracking에 없는 경우 해당 경로를 입력해야 합니다.또한 정의되지 않은 다른 운영 체제에 대한 경로를 추가할 수 있습니다. 기존 경로는 잘못해서 해당 저장소 경로를 사용하는 다른 프로젝트에 영향을 주지 않도록 잠겨 있습니다. 마법사의 매핑 페이지를 통해 각 필수 루트를 매핑했으며 각 매핑이 유효한지 확인합니다.저장소 선택 목록 끝에 있는 +New 항목을 선택하여 마법사에서 새 로컬 저장소를 만들 수도 있습니다. 현재 OS의 로컬 저장소 이름과 경로를 묻는 메시지가 나타납니다.프로젝트가 설정되면 툴킷에서 각 저장소 위치에 각 새 프로젝트에 대한 폴더를 생성합니다. 예를 들어, 기본 저장소 위치가 /mnt/projects인 경우 _The Edwardian Cry_라는 프로젝트는 /mnt/projects/the_edwardian_cry에 생성됩니다. 그리고 구성에서 기본 저장소 외에 더 많은 저장소를 사용하는 경우 각 저장소는 the_edwardian_cry 폴더에 생성됩니다.기본 저장소 위치는 일반적으로 /mnt/projects 또는   studio projects와 유사한 형태이며 보통 이미 프로젝트 데이터를 프로젝트별로 그룹 지정하여 저장하고 있는 위치입니다. 이 위치는 거의 항상 공유 네트워크 저장소입니다.프로젝트 폴더 이름 선택이제 프로젝트의 디스크 이름을 선택할 시간입니다. 이 폴더는 구성에서 필요로 하는 서로 다른 모든 저장소에 생성됩니다. 저장소는 UI에서 빠르게 미리 볼 수 있습니다. 대부분의 구성은 기본 저장소만 미리 볼 수 있지만 다중 루트 구성을 사용 중인 경우 추가 저장소도 표시됩니다. 툴킷은 Flow Production Tracking에서의 이름을 기반으로 기본 프로젝트 이름을 제안하지만, 각자의 설정에 맞게 원하는 대로 이름을 바꿀 수 있습니다.구성 위치 선택마지막으로 디스크에서 구성 파일을 저장할 위치를 결정하십시오. 툴킷은 이전 프로젝트를 기반으로 위치를 제안하기 때문에 모든 구성 파일은 동일한 디스크 위치에 저장됩니다.일반적으로 구성은 공유 저장소 또는 디스크에 있으므로 스튜디오에서 이를 필요로 하는 모든 사용자가 액세스할 수 있습니다. 이 프로젝트에서 둘 이상의 운영 체제 사용을 계획 중인 경우 필요한 모든 경로를 입력해야 합니다. 모든 경로는 동일한 디스크 위치를 나타내야 합니다. 종종 Mac OS X과 Linux에서는 경로가 같을 수 있지만 Windows에서는 다릅니다.이번이 첫 번째 프로젝트라면 대개의 경우 향후 모든 파이프라인 구성을 저장할 디스크의 공유 영역을 확인해야 할 것입니다. 일반적으로 이 위치는 스튜디오 전체에서 공유하는 소프트웨어 또는 소프트웨어 설정을 저장하는 위치입니다. 형식은 /mnt/software/shotgun과 비슷할 수 있으며, 스튜디오 네트워크 및 파일 명명 규칙에 따라 다를 수 있습니다.첫 번째 구성을 설정할 때는 스튜디오에서 사용하는 모든 플랫폼에 대한 경로로 설정합니다. 이렇게 하면 나중에 모든 컴퓨터에서 액세스할 수 있는 환경을 쉽게 생성할 수 있습니다. 예를 들면, 프로젝트 이름이 _Golden Circle_인 경우 다음 세 경로를 입력할 수 있습니다.linux:   /mnt/software/shotgun/golden_circlemacosx:  /servers/production/software/shotgun/golden_circlewindows:   prod software shotgun golden_circle구성을 완료하면 어떤 작업을 수행할 수 있습니까?첫 번째 구성을 완료 및 실행했으면 ‘다음 단계’ 문서로 이동하여 스튜디오 요구 사항에 더 잘 맞게 툴킷을 구성 및 조정하는 방법에 대해 알아보십시오.첫 번째 프로젝트 실행 이후 작업고급 기능자동 설치Windows 네트워크를 사용하는 경우 “/S” 인자를 사용하여 .exe Flow Production Tracking 데스크톱 설치 프로그램이 자동 설치를 수행하도록 할 수 있습니다. 그런 다음 실행 파일 단축키 사본을 시작 폴더로 푸시하면 됩니다.",
    "url": "/8085533c/",
    "relUrl": "/8085533c/"
  },
  "68": {
    "id": "68",
    "title": "통합",
    "content": "RV 통합RV는 서로 다른 기능 세트를 가진 여러 Flow Production Tracking 통합(Flow Production Tracking Integration, RV용 Screening Room 및 Flow Production Tracking Review)을 비롯해 Nuke 및 Maya를 위한 통합 도구가 함께 제공됩니다.앞쪽의 두 문서에서는 Nuke 및 Maya 통합의 설치 및 워크플로우에 대해 설명하며, 뒤쪽의 두 문서에서는 선택에 도움을 주기 위해 다양한 Flow Production Tracking 통합에 대해 설명합니다.",
    "url": "/268002fe/",
    "relUrl": "/268002fe/"
  },
  "69": {
    "id": "69",
    "title": "잘못된 LUT가 선택됨",
    "content": "오류 잘못된 LUT 선택: Gamma2.2활용 사례:ACES 색상 관리 프로젝트에서 작업할 때 기본 툴킷 게시를 사용하면 Invalid LUT selected : Gamma2.2 오류가 발생하여 작업이 실패합니다.오류의 원인은 무엇입니까?Nuke에서 툴킷 게시의 일부인 QuickTime을 만드는 tk-multi-reviewsubmission이라는 앱이 있으며, 기본적으로 Nuke 표준 색상 모델에서 작동하는 QT를 만듭니다.해결 방법ACES(ICIO 모델이라고 가정함)를 사용 중이므로 tk-multi-reviewsubmission 앱에서 색상 공간 설정을 인계받아 codec_settings.py 후크에 추가하여 변경해야 합니다.코덱은 기본 설정에 따라 다르지만 이 예에서는 Output - sRGB Codec을 사용하므로 codec_settings.py 후크에서 설정에 적합한 위치에 settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot; 설정을 추가합니다. (도처에 추가함)        settings = {}        if sys.platform in [&quot;darwin&quot;, &quot;win32&quot;]:            settings[&quot;file_type&quot;] = &quot;mov&quot;            if nuke.NUKE_VERSION_MAJOR &amp;gt;= 9:                # Nuke 9.0v1 changed the codec knob name to meta_codec and added an encoder knob                # (which defaults to the new mov64 encoder/decoder).                                  settings[&quot;meta_codec&quot;] = &quot;jpeg&quot;                settings[&quot;mov64_quality_max&quot;] = &quot;3&quot;                settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;            else:                settings[&quot;codec&quot;] = &quot;jpeg&quot;                settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;        elif sys.platform == &quot;linux2&quot;:            if nuke.NUKE_VERSION_MAJOR &amp;gt;= 9:                # Nuke 9.0v1 removed ffmpeg and replaced it with the mov64 writer                # https://help.thefoundry.co.uk/nuke/9.0/#appendices/appendixc/supported_file_formats.html                settings[&quot;file_type&quot;] = &quot;mov64&quot;                settings[&quot;mov64_codec&quot;] = &quot;jpeg&quot;                settings[&quot;mov64_quality_max&quot;] = &quot;3&quot;                settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;            else:                # the 'codec' knob name was changed to 'format' in Nuke 7.0                settings[&quot;file_type&quot;] = &quot;ffmpeg&quot;                settings[&quot;format&quot;] = &quot;MOV format (mov)&quot;                settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;        return settings이제 이 모든 사항이 완료되면 Nuke에서 게시할 때 ACES 호환 색상 공간에서 QT가 생성됩니다.커뮤니티에서 전체 스레드 보기",
    "url": "/749984aa/",
    "relUrl": "/749984aa/"
  },
  "70": {
    "id": "70",
    "title": "Knowledge",
    "content": "Generic KnowledgeIn This Section  Connecting Your Studio With Your AWS VPC  Flow Production Tracking AWS Direct Connect Onboarding  S3  VPC / IAM / Security Group  Direct Connect  Private Link  VPC Endpoints  AWS Knowledge",
    "url": "/540597cc/",
    "relUrl": "/540597cc/"
  },
  "71": {
    "id": "71",
    "title": "Learn",
    "content": "Flow Production Tracking Isolation - LearnThis section will host a learning curriculum for Flow Production Tracking Isolation features n the near future.",
    "url": "/da5a2d10/",
    "relUrl": "/da5a2d10/"
  },
  "72": {
    "id": "72",
    "title": "Maya에서 context.task를 출력하면 비어 있음(&quot;None&quot;)",
    "content": "Maya에서 context.task를 출력하면 비어 있음(“None”)활용 사례Maya에서 context.task를 출력한 후에는 empty “None”이지만 다른 단계/태스크에서 다른 레이아웃 파일을 시도할 때는 context.task 상세 정보를 표시합니다. Open &amp;gt; Layout &amp;gt; new file을 통해 이동할 때도 context.task 상세 정보를 출력할 수 있지만 파일 저장(File Save)을 통해 파일을 저장할 때는 context.task가 없음(None)으로 표시됩니다.해결 방법작동하지 않는 샷 중 하나에 대해 폴더 등록을 취소한 다음 해당 폴더에 대한 폴더 생성을 다시 실행합니다.관련 링크커뮤니티에서 전체 스레드 참조",
    "url": "/38c4e054/",
    "relUrl": "/38c4e054/"
  },
  "73": {
    "id": "73",
    "title": "Maya에서 툴킷 앱 실행을 위한 쉘프 버튼을 추가하려면 어떻게 해야 합니까?",
    "content": "Maya에서 툴킷 앱 실행을 위한 쉘프 버튼을 추가하려면 어떻게 해야 합니까?Maya에서 툴킷 앱을 실행하기 위한 선반 버튼을 Maya에 추가하는 작업은 정말 간단합니다. 다음은 Loader 앱을 여는 커스텀 쉘프 버튼을 추가하는 방법을 보여 주는 예입니다.                    참고: 이 예는 툴킷이 현재 Maya 세션에서 활성화되어 있다고 가정한 것입니다. 이 예제 코드는 툴킷을 부트스트랩(Bootstrap)하지 않습니다.    Maya에서 스크립트 편집기를 열고 다음 Python 코드를 붙여 넣습니다. import maya.cmds as cmds# Define the name of the app command we want to run.# If your not sure on the actual name you can print the current_engine.commands to get a full list, see below.tk_app = &quot;Publish...&quot;try:    import sgtk    # get the current engine (e.g. tk-maya)    current_engine = sgtk.platform.current_engine()    if not current_engine:        cmds.error(&quot;Flow Production Tracking integration is not available!&quot;)    # find the current instance of the app.    # You can print current_engine.commands to list all available commands.    command = current_engine.commands.get(tk_app)    if not app:        cmds.error(&quot;The Toolkit app '%s' is not available!&quot; % tk_app)    # now we have the command we need to call the registered callback    command['callback']()except Exception, e:    msg = &quot;Unable to launch Toolkit app '%s': %s&quot; % (tk_app, e)    cmds.confirmDialog(title=&quot;Toolkit Error&quot;, icon=&quot;critical&quot;, message=msg)    cmds.error(msg)이 코드를 선택하고 커스텀 쉘프로 끌어다 놓습니다. 커스텀 쉘프 버튼으로 작업하는 방법에 대한 자세한 정보는 Maya 설명서를 참조하십시오.이 코드 예를 사용하면 위쪽에 있는 tk_app 및 call_func 값을 수정하여 Maya에서 활성화되어 있는 툴킷 앱을 실행할 수 있을 것입니다.",
    "url": "/dba779a5/",
    "relUrl": "/dba779a5/"
  },
  "74": {
    "id": "74",
    "title": "Media Isolation",
    "content": "Media IsolationMedia Isolation allows your studio to retain ownership and control of the media and attachments that you upload to Flow Production Tracking. With Media Isolation, all the content that you upload to Flow Production Tracking is stored in your studio’s private S3 Bucket. Access to the media is provided to the Flow Production Tracking services only, using AWS AssumeRole keyless Security Token Service.Client-Owned S3 BucketStoring media and attachments in an S3 bucket that you own means that you remain the legal owner of these artifacts, allowing you to comply with your company’s security and legal policies. Your studio retains control of asset storage and access, access that you can revoke at will.More about AccessWhen using Flow Production Tracking to upload and download media it is transferred directly to / from AWS S3 without transiting through Autodesk infrastructure. Flow Production Tracking will only access media in two situations:  The Flow Production Tracking Transcoding service will get read/write access once, soon after upload, when transcoding the media. See Ephemeral Transcoding for details.  When the Flow Production Tracking service generates S3 Links to your sources and transcoded media.This is rendered possible by leveraging AWS AssumeRole keyless Security Token Service. When setting up Media Isolation, an AWS Role allowing Flow Production Tracking to access your media for the action listed above is created, and the Flow Production Tracking service is allowed to assume that role.Flow Production Tracking Support staff do not have access to your S3 Bucket under any circumstances.CostsWhen activating Media Isolation the following costs, previously covered by Autodesk, become the responsibility of the client:  S3 Costs. All the S3 storage costs will be assumed by the customer. See Media Isolation for more details about how to reduce costs.  S3 Bandwidth. Bandwidth out of the S3 bucket will be assumed by the customer.What Media Isolation is not providingActivating Media Isolation doesn’t guarantee that the access to your Flow Production Tracking site or media takes place within a closed network.",
    "url": "/a3c0e676/",
    "relUrl": "/a3c0e676/"
  },
  "75": {
    "id": "75",
    "title": "Media Replication",
    "content": "Media ReplicationFlow Production Tracking is compatible with the S3 Cross-Region replication feature, allowing your users located in different regions to read from the region closer to them in order to reduce latency and increase throughput. Replication to one region is currently supported.Pre-requisitesMedia Isolation is required in order to elect Media Replication.Configuration by usersWhen using Media Replication, each user can customize which region data is read from. A user can either specify the region to use, or use automatic mode. In automatic mode Flow Production Tracking selects the replica determined by the user’s IP address using IP ranges specified in the Isolation Preferences.How it worksFlow Production Tracking can be configured to read from up to two different buckets. Using the AWS S3 Replication feature, you can configure replication between buckets in different regions, and then consume media from the region closest to your users. It is important to underline that media is always uploaded to the main bucket.Following AWS service level agreement, S3 guarantees the replication of 99.99% of the object within 15 minutes.Replication DelayA small amount of time, typically under 15 minutes, is required before replication happens. The replication time depends on the size of the object to replicate. In order to alleviate that replication delay, Flow Production Tracking will, for a small period of time, generate links from to object in the source bucket instead of the replica. The duration of this transitional state is configurable in the Isolation Preferences.CostsActivating the Media Replication feature can increase your AWS costs considerabibly. Before activating, be aware that:  Your S3 cost linked to Flow Production Tracking usage will more or less double, because the media is now stored in two regions.  You will be charged for the transfer cost between the source and the destination region. See AWS S3 CRR and the destination region for more details.Next StepsSee Media Replication Setup for setup instructions.",
    "url": "/0221297e/",
    "relUrl": "/0221297e/"
  },
  "76": {
    "id": "76",
    "title": "Media Traffic Isolation",
    "content": "Media Traffic Isolation using AWS PrivateLink for Amazon S3                    Disclaimer: This documentation is provided solely as an example. It explains how to set up your Flow Production Tracking Isolation environment so that it can be connected to Flow Production Tracking cloud infrastructure. Please adapt it to your studio security requirements as needed. As Flow Production Tracking has no visibility on your AWS Account, ensuring that this account is secure is a client responsibility.    The media traffic isolation feature allows your users to access media in your AWS S3 bucket privately (not transiting over the public Internet). Please note that if you have a multi-region setup and that leverages the Flow Production Tracking Transcoding service there may still be instances where media transits across the public Internet. Reach out to our support team for more details.Media Isolation activation is a pre-requisite to enable this feature. If you haven’t done so already, see Media Isolation.Set up a VPC in your S3 bucket AWS regionYou will need to deploy a VPC with the required VPC endpoint. We provide a private VPC CloudFormation templates as starting points. This template create the necessary VPC, subnets and VPC endpoint.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL to https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-vpc-s3-privatelink.yml  Click Next  Set a stack name. Eg. Flow Production Tracking-vpc  Choose network ranges that doesn’t conflict with your studio network and set subnet CIDR values accordingly  Set your S3 bucket name  Click Next  Click NextSet up access from your site network to your AWS VPCOptions provided by AWS:  AWS Site-to-Site VPN  AWS Direct Connect                    Note: If Direct Connect is chosen, we recommend testing with a simpler / faster solution in the meantime to validate your Isolation setup. You can then replace that solution with Direct Connect once it is available.    Add an S3 endpoint to your VPC                    Note: This step should only be performed if the CloudFormation template was not used.    Simply add an com.amazonaws.us-west-2.s3 Interface VPC Endpoint to your existing VPC. Make sure the associated security group allow traffic from your site network.Add the VPC to your S3 bucket policyIn order for the S3 VPC endpoint to communicate with your S3 bucket your bucket policy must allow access from the S3 endpoint’s VPC. You can find instructions on how to configure the policy in the Fine Tuning step.ValidationTest the S3 VPC endpointUse the endpoint URL to list objects in your bucket using AWS CLI. In the following example, replace the VPC endpoint ID vpce-1a2b3c4d-5e6f.s3.us-east-1.vpce.amazonaws.com and bucket name my-bucket with appropriate information.    aws s3 --endpoint-url https://bucket.vpce-1a2b3c4d-5e6f.s3.us-east-1.vpce.amazonaws.com ls s3://my-bucket/Configure site to use your S3 VPC endpointYou can test by adding a temporary entry to the S3 Configuration site preference on your site.The complete entry will look like the following:{​​​​​​​​   &quot;&amp;lt;S3_CONFIG_NAME&amp;gt;&quot;: {​​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​,   &quot;&amp;lt;S3_CONFIG_NAME_WITH_S3_VPC_ENDPOINT&amp;gt;&quot;: {​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;,     &quot;s3_interface_vpc_endpoint_dns_name&quot;: &quot;vpce-1234567-5e6f.s3.us-east-1.vpce.amazonaws.com&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​After the configuration has been updated on your site, navigate to the /admin/speedtest route of your Flow Production Tracking site. Select the new S3_CONFIG_NAME_WITH_S3_VPC_ENDPOINT and start the test to confirm that all the upload/download tests work as intended.Once it has been verified to work correctly, add the value from s3_interface_vpc_endpoint_dns_name to the main S3 configuration S3_CONFIG_NAME and your current setup should be using Media Traffic Isolation.Erase the S3_CONFIG_NAME_WITH_S3_VPC_ENDPOINT entry from the S3 Configuration to clean up your configurations.Next StepsSee Media Replication to activate the Media Replication Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/2ab85e3e/",
    "relUrl": "/2ab85e3e/"
  },
  "77": {
    "id": "77",
    "title": "Media Traffic Isolation - S3 Proxy",
    "content": "                    Deprecated: The preferred way is to use S3 Private Link instead of a S3 proxy, see Media Traffic Isolation    Media Traffic Isolation using an S3 proxy (DEPRECATED)                    Disclaimer: This documentation is provided solely as an example. It explains how to set up your Flow Production Tracking Isolation environment so that it can be connected to Flow Production Tracking cloud infrastructure. Please adapt it to your studio security requirements as needed. As Flow Production Tracking has no visibility on your AWS Account, ensuring that this account is secure is a client responsibility.    The media traffic isolation feature allows your users to access media in your AWS S3 bucket privately (not transiting over the public Internet). Please note that if you have a multi-region setup and that leverages the Flow Production Tracking Transcoding service there may still be instances where media transits across the public Internet. Reach out to our support team for more details.Media Isolation activation is a pre-requisite to enable this feature. If you haven’t done so already, see Media Isolation.Set up a VPC in your S3 bucket AWS region                    Disclaimer: Before starting, decide whether your S3 proxy will be privately accessible within your VPC or publicly accessible via the Internet and choose the relevant templates in the following instructions.    You will need to deploy a VPC with the required VPC endpoints. We provide both private VPC and public VPC CloudFormation templates as starting points. These template create the necessary VPCs, subnets and VPC endpoints.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL depending upon your desired configuration          Private VPC (default):https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-vpc.yml      Public VPC:https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-public-vpc.yml        Click Next  Set a stack name. Eg. shotgun-vpc  Choose network ranges that doesn’t conflict with your studio network and set subnet CIDR values accordingly  Set your S3 bucket name  Click Next  Click NextSet up access from your site network to your AWS VPCOptions provided by AWS:  AWS Site-to-Site VPN  AWS Direct Connect                    Note: If Direct Connect is chosen, we recommend testing with a simpler / faster solution in the meantime to validate your Isolation setup. You can then replace that solution with Direct Connect once it is available.    Add an S3 endpoint to your VPC                    Note: This step should only be performed if the CloudFormation template was not used when configuring Media Isolation.    Set up S3 proxyYou will need to deploy an S3 proxy in your VPC to forward traffic to the S3 VPC endpoint. We provide both private and public S3 proxy CloudFormation templates as starting points for this purpose. These will create the necessary Elastic Container Service (ECS) cluster and other resources to run the S3 proxy on AWS Fargate behind an AWS Application Load Balancer (ALB).Make the Docker image available from a private AWS ECR repository  Create a new Elastic Container Registry (ECR) repository  Name the repository s3-proxy  Upload the s3-proxy Docker image to the newly created ECR repository          Install Docker on your workstation      Follow the docker login instructions shown by clicking the View push commands button      Run the following commands, substituting the ECR endpoint in the example for yours:        docker pull quay.io/shotgun/s3-proxy:1.0.6docker tag quay.io/shotgun/s3-proxy:1.0.6 627791357434.dkr.ecr.us-west-2.amazonaws.com/s3-proxy:1.0.6docker push 627791357434.dkr.ecr.us-west-2.amazonaws.com/s3-proxy:1.0.6                    Create S3 proxy CloudFormation stackCreate a new stack in AWS Console using either the private or public CloudFormation template.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL depending upon your desired configuration          Private S3 proxy (default):https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-s3-proxy.yml      Public S3 proxy:https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-s3-proxy-public.yml        Click Next  Set a stack name up to 32 characters in length. Eg. shotgun-s3-proxy  Set the parameters that do not have default values with those used when creating the ECR repository, VPC and S3 bucket previously  Click Next  Accept I acknowledge that AWS CloudFormation might create IAM resources  Click NextConfigure HTTPSFlow Production Tracking requires that the S3 proxy be accessed via HTTPS, therefore the AWS ALB handling requests for your newly created S3 proxy stack must be configured to accept HTTPS requests.  Create a DNS entry pointing to your S3 proxy, depending upon whether public or private          Private S3 proxy (default):                  Go to the EC2 Load Balancers dashboard, select your S3 proxy’s ALB and make a note of the DNS name          Add a DNS CNAME record pointing to the DNS name of the ALBEg. s3-proxy.mystudio.com. 300 IN CNAME s3proxy-12R1MXX0MFFAV-2025360147.us-east-1.elb.amazonaws.com.                    Public S3 proxy:                  Go to the AWS Global Accelerator dashboard and make a note of the DNS name associated with your S3 proxy’s accelerator          Add a DNS CNAME record pointing to the DNS name of the Global AcceleratorEg. s3-proxy.mystudio.com. 300 IN CNAME a48a2a8de7cfd28d3.awsglobalaccelerator.com.                      Obtain an SSL certificate for your chosen URL, we recommend using AWS Certificate Manager (ACM) for this  Configure HTTPS for the S3 proxy by adding a new HTTPS listener to the AWS ALB          Go to the EC2 Load Balancers dashboard, select your S3 proxy’s ALB and click on the Listeners tab      Click Add listener      Select HTTPS from the Protocol dropdown menu      Click Add action -&amp;gt; Forward to…      Select your S3 proxy’s target group from the Target group dropdown menu      Select the Security policy you’d like to use. Eg. TLS-1-2-Ext-2018-06 (See AWS documentation for more information)      Select the SSL certificate you’d like to use from ACM or import a new certificate      Click Save      Add S3 proxy VPC to S3 bucket policyIn order for the S3 proxy to communicate with your S3 bucket your bucket policy must allow access from the S3 proxy’s VPC. You can find instructions on how to configure the policy in the Fine Tuning step.ValidationTest the S3 proxyTry to access your S3 proxy using the ping route. Eg. https://s3-proxy.mystudio.com/pingConfigure your test site to use the S3 proxy  Navigate to the Site Preferences menu within Flow Production Tracking and expand the Isolation section  Set S3 Proxy Host Address to the S3 proxy url. Eg. https://s3-proxy.mystudio.com then click Save changes  Confirm that you are still able to access existing media  Attempt to upload new mediaNext StepsSee Media Replication to activate the Media Replicaton Traffic Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/85124db5/",
    "relUrl": "/85124db5/"
  },
  "78": {
    "id": "78",
    "title": "Media Traffic Isolation",
    "content": "Media Traffic IsolationCommunication between your client systems and S3 bucket targets a number of AWS network endpoints and data traverses the open Internet by default. Media Traffic Isolation allows you to limit the number of network endpoints used to transfer data to and from your S3 bucket and optionally restrict access to your AWS VPC or a defined set of public address scopes.ConfigurationAn S3 interface VPC endpoint is deployed within your VPC; which is then used as the endpoint for all S3 communication.How it worksFlow Production Tracking can be configured to use an S3 interface VPC endpoint to communicate with your S3 bucket. Deploying the S3 VPC endpoint within your VPC makes it possible to isolate traffic from the public Internet completely, or to allow more tightly controlled access from the Internet to your media.CostsActivating the Media Traffic Isolation feature will increase your AWS costs. Before activating, be aware that:  There are costs associated with running the S3 interface VPC Endpoint. See AWS PrivateLink pricing for more details.Next StepsSee Media Traffic Isolation for setup instructions.",
    "url": "/58919eae/",
    "relUrl": "/58919eae/"
  },
  "79": {
    "id": "79",
    "title": "Flow Production Tracking 데스크톱에서 Nuke/Maya 등을 실행했는데 Flow Production Tracking 메뉴에 해당 항목이 없습니다",
    "content": "제가 Flow Production Tracking 데스크톱에서 Nuke/Maya 등을 실행했는데 Flow Production Tracking 메뉴에 해당 항목이 없습니다.Flow Production Tracking 메뉴에 표시되는 액션은 상황에 맞게 구성됩니다. 즉, 사용 가능한 액션 목록은 상황에 따라 다를 수 있습니다.잘못된 상황에 있기 때문에 앱이 표시되지 않을 수 있습니다.예시Flow Production Tracking 데스크톱에서 응용프로그램을 실행하면 기본적으로 프로젝트 환경으로 이동합니다. 이 환경은 config/env/project.yml에 있는 파이프라인 구성의 구성 파일에 의해 관리됩니다. 대부분의 사용자 작업이 이 환경에서 수행되지 않을 것이므로 이 환경에는 작업에 사용하는 앱이 대부분 구성되어 있지 않습니다.기본 Maya 프로젝트 액션:Flow Production Tracking Workfiles 앱을 사용하여 작업할 에셋, 샷 또는 태스크를 선택할 수 있습니다. 이렇게 하면 적합한 새 환경이 로드되고 Flow Production Tracking 메뉴에 더 많은 앱과 메뉴 항목이 활성화됩니다.기본 Maya 에셋 태스크 액션올바른 환경에 있는데도 액션이 표시되지 않을 경우 다음 단계는 관련 로그에 오류가 있는지 확인하는 것입니다.전체 출력을 얻으려면 디버그 로깅을 활성화해야 합니다.",
    "url": "/901110e2/",
    "relUrl": "/901110e2/"
  },
  "80": {
    "id": "80",
    "title": "Migration",
    "content": "MigrationOnce everything is configured and properly tested with the migration test site, it’s now time to migrate your production site to use the isolation features.Test migrationAsk the Flow Production Tracking team to start the migration process in support ticket/slack.  Flow Production Tracking will clone your production site database to your migration test site.  You will do a first sync of the media from Flow Production Tracking’s S3 bucket to your bucket. Flow Production Tracking will provide the exact instructions.  You can now test your site to be sure your existing media is available.Final migrationThe second test is to definitly migrate your site to use your own S3 bucket.  You will do a second sync of the media from Flow Production Tracking’s S3 bucket to your bucket.  Flow Production Tracking will reconfigure your hosted site with media isolation. Some media will be missing until the final media sync is completed.  You will do a final media sync.",
    "url": "/09699c82/",
    "relUrl": "/09699c82/"
  },
  "81": {
    "id": "81",
    "title": "{% include product %} 데스크톱을 시작할 때 오류 모듈 'tank'에 'support_url' 특성이 없음",
    "content": "Flow Production Tracking 데스크톱을 시작할 때 오류 모듈 ‘tank’에 ‘support_url’ 특성이 없음문제버전을 업그레이드한 후 Flow Production Tracking 데스크톱을 시작하면 다음 메시지가 나타납니다.Flow Production Tracking Toolkit Error:Error: module 'tank' has no attribute 'support_url'원인디스크립터 버전이 최신 Flow Production Tracking 데스크톱 버전 1.7.3과 호환되지 않습니다. ‘support_url’은 tk-core v0.19.18에서 도입되었습니다.솔루션이 문제를 해결하려면 다음을 수행합니다.  Flow Production Tracking 웹 사이트의 파이프라인 구성 목록(Pipeline Configuration List) 페이지에 액세스합니다.  디스크립터 필드에 최신 Flow Production Tracking 데스크톱 버전과 호환되지 않는 이전 버전이 있는지 확인합니다.관련 링크  기술 자료 지원 문서",
    "url": "/2c67d8b6/",
    "relUrl": "/2c67d8b6/"
  },
  "82": {
    "id": "82",
    "title": "ModuleNotFoundError",
    "content": "ModuleNotFoundError활용 사례분산 구성을 사용하는 경우 엔진 외부에서 tk.templates 명령에 액세스하기 위해 tk-shell 부트스트래핑을 수행할 때 이 오류가 표시됩니다. 이 문서(4부)에 따라 설치 폴더에서 sgtk v0.19.18을 가져올 때 다음 오류가 발생합니다.Traceback (most recent call last):  File &quot;.../_wip/sgtk_bootstrap.py&quot;, line 9, in &amp;lt;module&amp;gt;    import sgtk  File &quot;L:/_tech/sgtk_sandbox/install/core/python sgtk __init__.py&quot;, line 16, in &amp;lt;module&amp;gt;    import tank  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank __init__.py&quot;, line 58, in &amp;lt;module&amp;gt;    from . import authentication  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication __init__.py&quot;, line 33, in &amp;lt;module&amp;gt;    from .shotgun_authenticator import ShotgunAuthenticator  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication shotgun_authenticator.py&quot;, line 13, in &amp;lt;module&amp;gt;    from .sso_saml2 import (  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication sso_saml2 __init__.py&quot;, line 15, in &amp;lt;module&amp;gt;    from .core.errors import (  # noqa  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication sso_saml2 core __init__.py&quot;, line 15, in &amp;lt;module&amp;gt;    from .sso_saml2_core import (  # noqa  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication sso_saml2 core sso_saml2_core.py&quot;, line 19, in &amp;lt;module&amp;gt;    from Cookie import SimpleCookieModuleNotFoundError: No module named 'Cookie'해결 방법이 문제는 Python 3을 사용하기 때문일 수 있습니다(이전 버전의 Python은 더 이상 지원되지 않음).관련 링크커뮤니티에서 전체 스레드 보기",
    "url": "/d8981e04/",
    "relUrl": "/d8981e04/"
  },
  "83": {
    "id": "83",
    "title": "파이프라인 구성을 새 위치로 이동하려면 어떻게 해야 합니까?",
    "content": "파이프라인 구성을 새 위치로 이동하려면 어떻게 해야 합니까?                    참고: 이 문서의 내용은 중앙 집중식 구성 설정에만 적용됩니다. 분산 구성은 개별 클라이언트 시스템에 로컬로 캐시되고 툴킷에서 자동으로 관리됩니다.    파이프라인 구성을 새 위치로 옮길 수 있는 가장 쉬운 방법은 tank move_configuration 명령을 사용하는 것입니다. 이렇게 하면 파일을 이동하고, Flow Production Tracking를 업데이트하고, 새 위치를 가리키도록 구성 파일을 업데이트하는 작업이 모두 이루어집니다.이 명령은 단일 운영 체제의 위치만 옮기거나 이전에는 특정 운영 체제를 사용하지 않았지만 이제 운영 체제를 추가하고 싶은 경우에도 유용합니다. 이동하거나 추가해야 하는 항목과 그렇지 않은 항목은 툴킷이 감지하여 진행할 작업을 미리 보여 주기 때문에 진행하기 전에 확인할 수 있습니다.  tank move_configuration 명령 사용  수동으로 파이프라인 구성 이동                    주의: 현지화된 코어가 있는 구성을 옮기려고 하고, 이 파이프라인 구성에 포함된 Toolkit Core를 사용 중인 다른 프로젝트가 있는 경우에는(즉, 다른 구성에서 공유 코어로 사용) 해당 프로젝트의 구성 파일을 이 파이프라인 구성의 새 위치를 가리키도록 수동으로 업데이트해야 합니다. 이 파일의 위치는 다음과 같습니다.  /path/to/pipeline_configuration/install/core/core_Darwin.cfg  /path/to/pipeline_configuration/install/core/core_Linux.cfg  /path/to/pipeline_configuration/install/core/core_Windows.cfg    tank move_configuration 명령 사용:    $ cd /sgtk/software/shotgun/scarlet    $ ./tank move_configuration    Welcome to the Flow Production Tracking Toolkit!    For documentation, see https://developer.shotgridsoftware.com/d587be80/?title=Integrations+User+Guide    Starting Toolkit for your current path '/sgtk/software/shotgun/scarlet'    - The path is not associated with any Flow Production Tracking object.    - Falling back on default project settings.    - Using configuration 'Primary' and Core v0.15.22    - Setting the Context to Scarlet.    - Running command move_configuration...    ----------------------------------------------------------------------    Command: Move configuration    ----------------------------------------------------------------------    Syntax: move_configuration linux_path windows_path mac_path    This will move the location of the given pipeline configuration.    You can also use this command to add a new platform to the pipeline    configuration.    Current Paths    --------------------------------------------------------------    Current Linux Path:   '/mnt/hgfs/sgtk/software/shotgun/scarlet'    Current Windows Path: 'z: sgtk software shotgun scarlet'    Current Mac Path:     '/sgtk/software/shotgun/scarlet'    You typically need to quote your paths, like this:    &amp;gt; tank move_configuration &quot;/linux_root/my_config&quot; &quot;p: configs my_config&quot;    &quot;/mac_root/my_config&quot;    If you want to leave a platform blank, just just empty quotes. For example, if    you want a configuration which only works on windows, do like this:    &amp;gt; tank move_configuration &quot;&quot; &quot;p: configs my_config&quot; &quot;&quot;예시:    $ cd /sgtk/software/shotgun/scarlet    $ ./tank move_configuration &quot;/mnt/hgfs/sgtk/software/shotgun/scarlet_new&quot; &quot;z: sgtk software shotgun scarlet_new&quot; &quot;/sgtk/software/shotgun/scarlet_new&quot;    Welcome to the Flow Production Tracking Toolkit!    For documentation, see https://developer.shotgridsoftware.com/d587be80/?title=Integrations+User+Guide    Starting toolkit for path '/sgtk/software/shotgun/scarlet'    - The path is not associated with any Flow Production Tracking object.    - Falling back on default project settings.    - Using configuration 'Primary' and Core v0.15.22    - Setting the Context to Scarlet.    - Running command move_configuration...    ----------------------------------------------------------------------    Command: Move configuration    ----------------------------------------------------------------------    Current Paths    --------------------------------------------------------------    Current Linux Path:   '/sgtk/software/shotgun/scarlet'    Current Windows Path: 'z: sgtk software shotgun scarlet'    Current Mac Path:     '/sgtk/software/shotgun/scarlet'    New Paths    --------------------------------------------------------------    New Linux Path:   '/mnt/hgfs/sgtk/software/shotgun/scarlet_new'    New Windows Path: 'z: sgtk software shotgun scarlet_new'    New Mac Path:     '/sgtk/software/shotgun/scarlet_new'    The configuration will be moved to reflect the specified path changes.    Note for advanced users: If your configuration is localized and you have other    projects which are linked to the core API embedded in this configuration,    these links must be manually updated after the move operation.    Are you sure you want to move your configuration? [Yes/No] yes    Copying '/sgtk/software/shotgun/scarlet' -&amp;gt; '/sgtk/software/shotgun/scarlet_new'    Copying /sgtk/software/shotgun/scarlet/cache...    Copying /sgtk/software/shotgun/scarlet/config...    Copying /sgtk/software/shotgun/scarlet/config/core...    Copying /sgtk/software/shotgun/scarlet/config/core/hooks...    Copying /sgtk/software/shotgun/scarlet/config/core/schema...    Copying /sgtk/software/shotgun/scarlet/config/env...    Copying /sgtk/software/shotgun/scarlet/config/env/includes...    Copying /sgtk/software/shotgun/scarlet/config/hooks...    Copying /sgtk/software/shotgun/scarlet/config/icons...    Copying /sgtk/software/shotgun/scarlet/install...    Copying /sgtk/software/shotgun/scarlet/install/apps...    Copying /sgtk/software/shotgun/scarlet/install/apps/app_store...    Copying /sgtk/software/shotgun/scarlet/install/core...    Copying /sgtk/software/shotgun/scarlet/install/core/python...    Copying /sgtk/software/shotgun/scarlet/install/core.backup...    Copying /sgtk/software/shotgun/scarlet/install/core.backup/20150518_143244...    Copying /sgtk/software/shotgun/scarlet/install/core.backup/20150518_143940...    Copying /sgtk/software/shotgun/scarlet/install/engines...    Copying /sgtk/software/shotgun/scarlet/install/engines/app_store...    Copying /sgtk/software/shotgun/scarlet/install/frameworks...    Copying /sgtk/software/shotgun/scarlet/install/frameworks/app_store...    Updating cached locations in /sgtk/software/shotgun/scarlet_new/config/core/install_location.yml...    Updating Flow Production Tracking Configuration Record...    Deleting original configuration files...    All done! Your configuration has been successfully moved.수동으로 파이프라인 구성 이동                    중요: 아직 파이프라인 구성을 옮기지 않았다면 위의 기본 제공 tank 명령을 사용하여 이를 자동으로 처리하는 것이 가장 좋습니다.    이미 수동 이동을 시작했는데 중간에 막혀 버렸다면 툴킷이 이제 새 위치에 있는 파이프라인 구성을 통해 계속 작동하도록 하기 위해 변경해야 하는 사항들이 있습니다.      파이프라인 구성 파일을 새 위치로 이동     $ mv /sgtk/software/shotgun/scarlet /mnt/newserver/sgtk/software/shotgun/scarlet_new            툴킷이 파이프라인 구성의 위치를 파악하는 데 도움을 주도록 install_location.yml을 편집:     $ vi /mnt/newserver/sgtk/software/shotgun/scarlet_new/config/core/install_location.yml        해당하는 모든 플랫폼에서 이 파일의 경로가 새 파이프라인 구성 위치를 가리키도록 업데이트합니다. 플랫폼을 사용하고 있지 않다면 빈 문자열 ''을 입력합니다.     # Flow Production Tracking Toolkit configuration file # This file was automatically created by setup_project # This file reflects the paths in the primary pipeline # configuration defined for this project. Windows: 'Y: sgtk software shotgun scarlet_new' Darwin: '/mnt/newserver/sgtk/software/shotgun/scarlet_new' Linux: '' # End of file.            Flow Production Tracking에서 이 프로젝트에 대한 해당 파이프라인 구성 엔티티를 찾아 Linux 경로, Mac 경로 및 Windows 경로 필드 값이 위에서 변경한 사항과 일치하도록 수정합니다.  이제 파이프라인 구성이 새 위치에서 기대한 대로 작동할 것입니다.                    참고: SG 데스크톱을 사용 중인 경우 프로젝트에서 나와 프로젝트 아이콘을 다시 클릭해서 파이프라인 구성을 새 위치에서 다시 로드해야 합니다.    ",
    "url": "/18e34e3c/",
    "relUrl": "/18e34e3c/"
  },
  "84": {
    "id": "84",
    "title": "내 프로젝트 디렉토리를 새 로컬 저장소 루트로 어떻게 옮깁니까?",
    "content": "내 프로젝트 디렉토리를 새 로컬 저장소 루트로 어떻게 옮깁니까?                    주의: 프로젝트 위치를 이동하면 Flow Production Tracking 툴킷을 넘어 확장해도 중간 프로젝트에 많은 영향을 미칠 수 있습니다. 가볍게 처리해서는 안 됩니다.    간혹 프로젝트 파일(씬 파일, 렌더 등)을 새 루트 저장소 위치로 옮겨야 할 때가 있습니다(예: /mnt/smalldrive에서 /mnt/bigdrive/foo로). 이동은 단일 루트 구성을 사용 중이든 다중 루트 구성을 사용 중이든 상관없이 가능합니다. 이름이 “asset_storage”인 저장소를 옮기는 예를 살펴보겠습니다.  이전 위치에서 새 위치로 프로젝트 파일을 복사(또는 이동)합니다.  Flow Production Tracking에서 관리자(Admin) &amp;gt; 사이트 기본 설정(Site Preferences) 페이지로 이동해 파일 관리(File Management) 섹션을 엽니다.   각 플랫폼의 경로와 함께 이름이 “primary”인 로컬 파일 저장소를 프로젝트 파일의 새 저장소로 업데이트합니다. 특정 플랫폼을 사용하고 있지 않다면 그냥 비워 두십시오.  페이지 위나 아래에 있는 “변경 사항 저장(Save Changes)” 버튼을 클릭합니다.  지금 막 Flow Production Tracking에 저장한 새로운 경로 값과 일치하도록 프로젝트 구성의 config/core/roots.yml 파일을 업데이트합니다.툴킷이 게시 경로를 저장소 루트의 상대 경로로 저장합니다. 이전 저장소 루트도 마찬가지로 경로가 다음과 같이 확장되었습니다.[asset_storage]/assets/Character/betty =&amp;gt; /mnt/smalldrive/assets/Character/betty새 저장소 루트 정의의 경우에는 이제 경로가 다음과 같이 확장됩니다.[asset-storage]/assets/Character/betty =&amp;gt; /mnt/bigdrive/foo/assets/Character/betty그리고 Flow Production Tracking 또는 툴킷에서 어떤 다른 게시 정보를 업데이트하는 일은 신경 쓸 필요가 없습니다!                    경고: 위 단계에서는 기존 저장소 루트 경로를 재지정한다고 가정합니다. 대신 기존 경로를 삭제하거나 새 경로를 만드는 경우 모든 폴더를 다시 등록하고 PublishedFiles 엔티티를 다시 게시해야 합니다.    참조어떤 씬 파일에 이전 경로를 가리키는 참조가 있는 경우에는 직접 해당 참조를 업데이트하거나 참조가 올바로 해석되도록 심볼릭 링크를 만들어야 합니다.버전ShotGrid에 이 변경 사항의 영향을 받는 영상 경로 또는 프레임 경로 필드에 정보를 저장하는 버전 엔티티가 있는 경우 이 필드는 미디어에 대한 절대 경로를 포함하고 있는 문자열 필드이기 때문에 해당 버전 역시 새 위치를 가리키도록 업데이트되어야 합니다.",
    "url": "/9aaa493a/",
    "relUrl": "/9aaa493a/"
  },
  "85": {
    "id": "85",
    "title": "“MTsetToggleMenuItem” 프로시저를 찾을 수 없음",
    "content": "“MTsetToggleMenuItem” 프로시저를 찾을 수 없음관련 오류 메시지:일반적인 시작 화면 후 전체 창을 로드하기 직전에 Maya에서 충돌이 발생합니다.  “MTsetToggleMenuItem” 프로시저를 찾을 수 없음해결 방법:Maya를 시작하기 전에 before_app_launch 후크에서 의도치 않게 특정 항목이 경로에서 제거되어 Maya 시작 시 오류가 발생할 수 있습니다. 이 경우 Python 설치를 PTHONPATH에 추가하면 Maya 2019에서 플러그인 경로를 찾을 수 없습니다.이 오류가 발생하는 원인의 예:이 후크에서 C: Python27이 PYTHONPATH로 설정되고 이 PYTHONPATH를 사용하여 워크스테이션을 실제로 설치했을 때 사용자에게 몇 가지 문제가 있었습니다.커뮤니티에서 전체 스레드를 참조하십시오.",
    "url": "/74106124/",
    "relUrl": "/74106124/"
  },
  "86": {
    "id": "86",
    "title": "App Store에 my-app이라는 항목이 포함되어 있지 않음",
    "content": "오류: App Store에 my-app이라는 항목이 포함되어 있지 않음해결 방법:이 오류는 커스텀 앱의 위치 설명자와 관련이 있습니다. 이 문서를 확인하십시오.위치에 대해서는 경로 설명자를 사용하여 my-app을 설정합니다. 자세한 내용은 여기를 참조하십시오.이 오류가 발생하는 원인의 예:tk-multi-snapshot이 Maya에 표시되지 않아 tank 유효성 검사를 사용하려는 동안 커스텀 앱의 유효성을 검사하려고 하면 해당 앱이 App Store에 없다는 오류가 표시됩니다.커뮤니티에서 전체 스레드를 참조하십시오.",
    "url": "/226a0069/",
    "relUrl": "/226a0069/"
  },
  "87": {
    "id": "87",
    "title": "NUKE_PATH 환경 변수를 설정하면 Nuke 통합이 시작되지 않는 이유가 무엇입니까?",
    "content": "NUKE_PATH 환경 변수를 설정하면 Nuke 통합이 시작되지 않는 이유가 무엇입니까?통합은 Nuke 시작 프로세스 중에 부트스트랩(Bootstrap) 스크립트가 실행되도록 Nuke 시작 시 NUKE_PATH 환경 변수를 설정합니다.before_launch_app.py 후크를 실행하기 전에 특별히 NUKE_PATH를 정의하는 tk-multi-launchapp입니다.os.environ['NUKE_PATH'] = &quot;/my/custom/path&quot; 등을 사용하여 시작 프로세스 중에 이 환경 변수를 설정하면 환경 변수에서 시작 스크립트 경로를 제거하기 때문에 Flow Production Tracking 통합을 시작할 수도 없습니다.경로를 툴킷 부트스트랩(Bootstrap)으로 유지하는 동안에는 경로를 NUKE_PATH 환경 변수에 추가하거나 접두사로 붙이는 다음 함수를 tank.util에 사용하십시오.tank.util.append_path_to_env_var(&quot;NUKE_PATH&quot;, &quot;/my/custom/path&quot;)아니면, prepend_path_to_env_var()을 사용하여 경로를 접두사로 붙여도 됩니다.",
    "url": "/fc2af72c/",
    "relUrl": "/fc2af72c/"
  },
  "88": {
    "id": "88",
    "title": "오프라인 사용 및 자동 업데이트 끄기",
    "content": "오프라인 사용 및 자동 업데이트 끄기  자동 업데이트          자동 업데이트되는 부분      자동으로 업데이트되지 않는 부분        오프라인으로 통합 실행          초기 설정      업데이트 관리        자동 업데이트 끄기          프로젝트 또는 사이트 수준에서 업데이트 끄기      한 프로젝트만 제외하고 모든 프로젝트에 대한 업데이트 끄기      업그레이드      자동 업데이트자동 업데이트되는 부분기본적으로 Flow Production Tracking 데스크톱은 업데이트를 자동으로 확인하고, 업데이트가 있을 경우 로컬 컴퓨터에 설치합니다.다음 두 구성요소에 대한 업데이트를 확인합니다.  tk-framework-desktopstartup - Flow Production Tracking 데스크톱 시작을 지원하는 프레임 작업입니다.  tk-config-basic - 기본 사이트 구성입니다.구성은 Flow Production Tracking 데스크톱에서 사용해야 하는 앱, 엔진, 프레임워크 및 코어 버전의 매니페스트 역할을 합니다.구성을 업데이트해야 이러한 구성요소도 업데이트할 수 있게 됩니다.업데이트가 검색되면 다운로드되어 Flow Production Tracking 데스크톱에 설치된 원래 파일을 수정하지 않고 사용자의 로컬 캐시에 저장됩니다.응용프로그램인 Flow Production Tracking Create는 Flow Production Tracking 데스크톱과는 별개의 자체 업데이트 메커니즘을 보유하고 있습니다(여기서는 다루지 않음).그러나 Flow Production Tracking Create에서 제공되는 통합 기능은 유사한 방식으로 작동하며 tk-config-basic도 동일한 사용자 캐시로 자동 업데이트됩니다.자동으로 업데이트되지 않는 부분      사이트 구성을 인계받은 경우 tk-config-basic에 새로운 업데이트가 있는지 확인하지 않고 그 아래 단위에서만 추가 사항을 확인합니다.        기본 사이트 구성을 사용하지 않는 프로젝트(예: 툴킷 고급 설정 마법사를 실행한 프로젝트)에서는 해당 구성이 자동 업데이트되지 않습니다.        Flow Production Tracking 데스크톱과 함께 번들로 제공되는 Python 및 QT와 같은 리소스는 자동 업데이트되지 않습니다. 이러한 부분을 업데이트해야 할 경우에는 새 Flow Production Tracking 데스크톱 설치 프로그램을 릴리즈해야 합니다.  오프라인으로 통합 실행초기 설정스튜디오에서 인터넷 액세스를 제한했거나 인터넷에 액세스할 수 없는 경우 필요한 모든 부분이 로컬로 캐시되어야 합니다.Flow Production Tracking Create 또는 Flow Production Tracking 데스크톱을 다운로드하려면 인터넷에 연결할 수 있는 컴퓨터가 한 대 있어야 합니다.Flow Production Tracking 데스크톱에는 기본 통합을 실행하는 데 필요한 모든 종속 요소가 미리 패키징되어 있습니다.또한 Flow Production Tracking Create는 종속 요소와 함께 번들로 제공되지만 업데이트 관리에 설명된 단계도 따라야 합니다.둘 중 하나를 시작하면 자동으로 업그레이드를 검색합니다. Flow Production Tracking 앱 스토어에 연결할 수 없는 경우에는 로컬에 있는 가장 최신 버전을 실행합니다.설치 프로그램과 함께 번들로 제공되는 구성요소가 최신 버전이 아닐 수도 있으므로 Flow Production Tracking 데스크톱을 설치한 후에는 업데이트 관리 단계를 따르는 것이 좋습니다.                    참고: 네트워크 설정에 따라서는 업데이트를 액세스할 수 없더라도 온라인에서 업데이트를 찾는 것이 이따금씩 중단될 수 있습니다.이 경우 SHOTGUN_DISABLE_APPSTORE_ACCESS 환경 변수를 &quot;1&quot;로 설정하여 검색을 중지할 수 있습니다.                        참고: Flow Production Tracking 사이트에는 계속 연결할 수 있어야 합니다. 오프라인은 앱 스토어에 연결하여 업데이트를 다운로드할 수 없는 것을 말합니다.    업데이트 관리tk-framework-desktopstartup 구성요소를 업데이트하려면 최신 버전을 다운로드하고 디스크의 해당 위치를 가리키도록 SGTK_DESKTOP_STARTUP_LOCATION 환경 변수를 설정해야 합니다(Flow Production Tracking 데스크톱에만 적용됨).tk-config-basic 구성요소의 경우 모든 종속성으로 인해 약간 더 까다로워집니다.  인터넷에 연결된 워크스테이션에서 Flow Production Tracking 데스크톱 또는 Flow Production Tracking Create를 실행합니다.  시작할 때 최신 업그레이드가 자동으로 다운로드됩니다.(이 컴퓨터에 SHOTGUN_DISABLE_APPSTORE_ACCESS 항목이 설정되어 있지 않은 것을 확인하십시오.)  번들 캐시를 모든 컴퓨터가 액세스할 수 있는 공유 위치에 복사합니다.  오프라인 컴퓨터에서 SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS 환경 변수가 이 위치를 가리키도록 설정합니다.  오프라인 컴퓨터에서 Flow Production Tracking 데스크톱 또는 Flow Production Tracking Create를 시작하면 오프라인 컴퓨터가 번들 캐시에 있는 최신 업그레이드를 선택합니다.                    경고: 네트워크 설정에 따라서는 업데이트를 액세스할 수 없더라도 온라인에서 업데이트를 찾는 것이 이따금씩 중단될 수 있습니다.이 경우 SHOTGUN_DISABLE_APPSTORE_ACCESS 환경 변수를 &quot;1&quot;로 설정하여 검색을 중지할 수 있습니다.    자동 업데이트 끄기프로젝트 또는 사이트 수준에서 업데이트 끄기                    참고: 가능하면 자동 업데이트를 계속 허용하여 새로운 기능 및 버그 수정에 대한 업데이트가 누락되지 않도록 하는 것이 좋습니다.    통합에 대한 자동 업데이트를 끄려면 다음 단계를 수행하십시오.  유지할 버전을 결정합니다. 통합 릴리즈는 여기에서 찾을 수 있습니다.      Flow Production Tracking의 프로젝트 또는 전역 페이지에서 파이프라인 구성 엔티티를 만들고 다음 필드를 입력합니다(이 예에서는 v1.0.36의 통합을 사용하도록 구성을 잠금).          이름: Primary      프로젝트: 모든 프로젝트에 대해 업데이트를 끄려면 비어 있는 상태로 두고, 단일 프로젝트에 대해서만 잠그려면 특정 프로젝트를 선택합니다.      플러그인 ID: basic.*      디스크립터: sgtk:descriptor:app_store?name=tk-config-basic&amp;amp;version=v1.0.36                Flow Production Tracking 데스크톱을 시작합니다. 프로젝트 필드를 비워 둔 경우에는 Flow Production Tracking 데스크톱이 이 버전을 사용하도록 전환됩니다(아직 사용하지 않은 경우).        프로젝트를 설정한 경우 해당 프로젝트만 영향을 받으며 Flow Production Tracking 데스크톱 정보 창에 변경 사항이 표시되지 않습니다.    [선택 사항] tk-framework-desktopstartup 버전을 잠그려면 최신 버전을 다운로드하고 디스크의 해당 위치를 가리키도록 SGTK_DESKTOP_STARTUP_LOCATION 환경 변수를 설정해야 합니다(Flow Production Tracking 데스크톱에만 적용됨).대부분의 기능은 이전 단계에서 잠글 수 있는 구성에 의해 제어되지만 “자동 업데이트되는 부분” 섹션에서 설명한 대로 구성요소도 업데이트되며 구성과 별도로 처리됩니다. 이 또한 Flow Production Tracking 데스크톱에만 적용됩니다.유용한 정보  구성의 릴리즈를 수동으로 다운로드할 필요가 없으며, Flow Production Tracking 데스크톱은 이 구성이 실행되거나 프로젝트를 시작할 때 이 문제를 처리합니다.  basic.*은 기초 구성에 있는 모든 플러그인이 이 재정의를 선택하게 됨을 의미합니다. 예를 들어 Nuke 및 Maya 통합만 중지하려는 경우 basic.maya, basic.nuke를 지정하면 됩니다.  테스트하려면 이 파이프라인 구성 엔티티를 복제한 다음 User Restrictions 필드에 사용자 이름을 추가하면 됩니다. 이렇게 하면 엔티티를 제한하게 되는데, 사용자에게만 적용되고 다른 사용자에게는 영향을 주지 않습니다. 그런 다음 이 복제 구성에서 Maya 또는 다른 소프트웨어를 시작하여 예상 통합 버전을 실행 중인지 확인할 수 있습니다.      프로젝트 필드를 비워 두면 사이트 구성을 사용하는 것입니다. Flow Production Tracking 데스크톱은 프로젝트 외부에서 작동하므로 사이트 구성을 사용합니다. Flow Production Tracking 데스크톱에서 프로젝트를 선택하면 프로젝트 구성도 로드됩니다.    Flame 통합의 네임스페이스는 basic.flame으로 지정되기 때문에 basic.*의 일부로 생각될 수 있습니다. 그러나 실제로 Flame 통합은 기초 구성에 포함되지 않습니다. 따라서 프로젝트에 Flame을 사용 중이고 이 재정의를 구현하는 경우 Flame 통합의 작동이 중지됩니다. 이 솔루션은 특히 Flame에 있어 추가 파이프라인 구성 재정의를 생성하게 됩니다.          이름: Primary      프로젝트: 잠그려는 프로젝트(또는 모든 프로젝트에 대해 “없음(None)”)      플러그인 ID: basic.flame      디스크립터: sgtk:descriptor:app_store?name=tk-config-flameplugin      하나만 제외하고 모든 프로젝트에 대한 업데이트 끄기위의 예에서 설명한 대로 모든 프로젝트에 대한 업데이트를 껐지만 특정 프로젝트에 대해 업데이트를 사용하려는 경우 다음을 수행할 수 있습니다.  위 섹션에서 설명한 대로 사이트에 대한 업데이트를 끕니다.  예외 프로젝트의 파이프라인 구성 엔티티가 다음 필드 값을 갖도록 구성합니다.          이름: Primary      프로젝트: 잠그지 않으려는 프로젝트      플러그인 ID: basic.*      디스크립터: sgtk:descriptor:app_store?name=tk-config-basic  디스크립터 필드에서 생략한 버전 번호로 이제 프로젝트는 기본 구성의 최신 릴리즈를 추적합니다.      업그레이드구성을 업데이트하게 되면 모든 사용자에게 롤아웃하기 전에 최신 버전을 테스트할 수 있습니다.  Flow Production Tracking에서 파이프라인 구성 엔티티를 마우스 오른쪽 버튼으로 클릭하고 “선택 항목 복제(Duplicate Selected)”를 선택하여 복제합니다.  복제한 구성 이름을 “update test”로 지정하고 자신을 사용자 제한(User Restrictions) 필드에 할당합니다.  이제 이 파이프라인 구성을 사용하기 시작합니다.  테스트할 버전을 가리키도록 디스크립터를 변경합니다.  테스트에 참여하게 하려는 모든 사용자를 User Restrictions 필드에 추가하면 초대할 수 있습니다.  테스트에 만족한 경우 기본 파이프라인 구성이 해당 버전을 사용하도록 업데이트하기만 하면 됩니다.  사용자가 Flow Production Tracking 데스크톱을 다시 시작하고 Flow Production Tracking 통합이 실행 중인 상태에서 현재 열려 있는 소프트웨어를 다시 시작하면 업데이트가 선택됩니다.",
    "url": "/b31ed3ef/",
    "relUrl": "/b31ed3ef/"
  },
  "89": {
    "id": "89",
    "title": "Onboarding Process",
    "content": "Onboarding ProcessLeveraging the isolation features requires adopters to become AWS users. In order to ensure that this joint venture between Autodesk, AWS, and our clients is as streamlined as possible, we decided to work closely with AWS to define a cooperative onboarding process that would meet client expectations for a premium offering.Autodesk will provide dedicated resources during the onboarding process to help you on this journey.To start the on-boarding process for any of the Isolation features, please fill out this short survey, before proceeding with your setup.Onboarding Process OverviewDuring the onboarding process, you’ll have direct access to Autodesk resources who will support you during the implementation.Setup / Test / Activation:	Iterative installation process where you connect your AWS resources to Flow Production Tracking, and activate the isolation features.Onboarding ResourcesFlow Production Tracking Community: The Flow Production Tracking Isolation Community forum can be used to ask questions that can be answered by either Flow Production Tracking Experts or other isolation features users. This should be your first stop when asking general questions about isolation features, during setup and beyond.Dedicated Microsoft Teams team: During the onboarding, you will be given access to a Microsoft Teams team. Your Flow Production Tracking leaders will be available for quick feedback, answers, and ad-hoc meetings to help you progress as fast as possible with your Flow Production Tracking Isolation setup. This channel will be available only for the onboarding period.Flow Production Tracking Support: A Flow Production Tracking Support ticket will be used to track your onboarding at a higher level. Once your Flow Production Tracking Isolation setup is complete, follow-up support tickets can be opened with the support team as needed.Next StepsOnce the onboarding process is started, you can start thinking about your setup",
    "url": "/f66c5afa/",
    "relUrl": "/f66c5afa/"
  },
  "90": {
    "id": "90",
    "title": "기타 통합",
    "content": "기타 통합Flow Production Tracking API를 사용하면 많은 타사 패키지를 통합할 수 있는데 즉각적으로 Flow Production Tracking와 통합할 수 있는 패키지도 몇 가지 있습니다.CinesyncCinesync를 사용하면 여러 위치 간에 동시에 동기화하여 재생할 수 있습니다. Flow Production Tracking 통합을 통해 버전 재생 목록을 만들고, 이를 Cinesync에서 재생하고, 세션 중에 작성한 노트를 Flow Production Tracking로 바로 보낼 수 있습니다.자세한 내용은 https://www.cinesync.com/manual/latest를 참조하십시오.DeadlineFlow+Production+Tracking+Deadline 통합을 사용하면 썸네일, 프레임 링크 및 기타 메타데이터가 모두 포함된 렌더링된 버전을 Flow Production Tracking에 자동으로 제출할 수 있습니다.자세한 내용은 https://docs.thinkboxsoftware.com/products/deadline/5.2/User%20Manual/manual/shotgunevent.html을 참조하십시오.RushDeadline 통합과 마찬가지로, Flow+Production+Tracking+Rush 통합을 사용하면 썸네일, 프레임 링크 및 기타 메타데이터가 모두 포함된 렌더링된 버전을 Flow Production Tracking에 자동으로 제출할 수 있습니다.자세한 내용은 https://seriss.com/rush-current/index.html을 참조하십시오.Subversion(SVN)ShotGrid는 저희가 내부에서도 사용하고 있는 가볍지만 유연한 통합으로, 이를 사용하여 리비전 내역을 트래킹하고, Flow Production Tracking에 있는 티켓 및 릴리즈에 링크할 수 있습니다. 또한 외부 웹 SVN 리포지토리 뷰어를 통합하기 위한 Trac 링크도 제공합니다. 커밋에서 몇몇 ENV 변수를 가져온 다음 Flow Production Tracking에서 여러 필드가 입력되어 있는 리비전 엔티티를 생성하는 Flow Production Tracking API 스크립트인 SVN에 포스트 커밋(post-commit) 후크만 추가하면 모든 작업이 이루어집니다. SVN은 스튜디오 요구 사항에 맞게 수정할 수 있으며 API만 사용하기 때문에 로컬 또는 호스팅되는 설치에 사용할 수 있습니다. 자세한 내용은 https://subversion.apache.org/docs를 참조하십시오.",
    "url": "/f0ee6c48/",
    "relUrl": "/f0ee6c48/"
  },
  "91": {
    "id": "91",
    "title": "“&lt;PATH&gt;” 경로가 {% include product %} 엔티티 `&lt;ENTITY&gt;`와 이미 연결되어 있음",
    "content": "데이터베이스 동시성 문제: &amp;lt;PATH&amp;gt; 경로가 Flow Production Tracking 엔티티 &amp;lt;ENTITY&amp;gt;와 이미 연결되어 있음관련 오류 메시지:  데이터베이스 동시성 문제: &amp;lt;PATH&amp;gt; 경로가 Flow Production Tracking 엔티티 &amp;lt;ENTITY&amp;gt;와 이미 연결되어 있습니다.  경로에 대한 행 ID를 확인할 수 없습니다!예시:이 오류는 툴킷 사용자가 폴더를 작성하려고 할 때 발생합니다. 다음은 전체 오류입니다.ERROR: Database concurrency problems: The path'Z: projects SpaceRocks shots ABC_0059' is already associated withShotgun entity {'type': 'Shot', 'id': 1809, 'name': 'ABC_0059'}. Please re-runfolder creation to try again.오류의 원인은 무엇입니까?이미 FilesystemLocation 엔티티가 있는 폴더에 대해 이 엔티티를 만들려고 하는 경우에 발생합니다.해결 방법잘못된 FilesystemLocation 엔티티를 지웁니다. 잘못된 FilesystemLocation 엔티티 세트로 범위를 좁힐 수 있는 경우 해당 엔티티 세트를 제거합니다. 그러나 대부분의 경우 프로젝트의 모든 경로가 손상되어 모두 이동해야 합니다.  FilesystemLocation 엔티티를 지우는 방법: 이상적으로는 tank unregister_folders를 실행할 수 있습니다. 모든 엔티티를 지우려면 tank unregister_folders --all을 실행합니다. (tank unregister_folders의 모든 옵션에 대해 인자 없이 실행하면 사용 정보가 출력됩니다.)  그러나 DB가 이미 불안정한 상태이므로 작동하지 않거나 부분적으로만 작동할 수 있습니다. 명령을 실행하고 나면 Flow Production Tracking의 FilesystemLocations로 돌아가서 삭제될 것으로 예상되는 항목이 실제로 사라졌는지 확인합니다. 그렇지 않은 경우 잘못된 엔티티를 선택하고 수동으로 휴지통으로 이동합니다.이때 Flow Production Tracking의 FilesystemLocations는 정리되지만 아티스트의 로컬 캐시에 변경 사항이 반영되지 않을 수 있습니다. 마지막 단계는 각 사용자의 컴퓨터에서 로컬 캐시를 실제로 동기화하는 것입니다. 이렇게 하려면 tank synchronize_folders --full을 실행해야 합니다.이 모든 단계를 수행하고 나면 경로 캐시가 양호한 상태가 되고 해당 오류가 더 이상 나타나지 않아야 합니다.관련 링크  해당 코드의 내용  경로 캐시는 무엇입니까? 파일 시스템 위치는 무엇입니까?커뮤니티에서 전체 스레드를 참조하십시오.",
    "url": "/3636e362/",
    "relUrl": "/3636e362/"
  },
  "92": {
    "id": "92",
    "title": "너무 긴 Windows 경로로 인한 오류",
    "content": "너무 긴 Windows 경로(256자 초과)로 인한 오류사실 정보Windows는 경로 이름의 기본 제한 문자 수가 255자/260자로 매우 낮습니다. 이 제한에 대한 Microsoft의 정보는 여기에 있으며 여기에서 자세한 기술 정보를 확인할 수 있습니다.오류이 문제는 여러 가지 방식으로 자체 발생하지만 대개는 SG 데스크톱이 구성을 처음 로드하는 경우에 발생하며 번들 캐시에 항목을 다운로드하는 동안 이 오류가 발생합니다. 이 오류는 Windows 10의 최신 버전에서 약간 개선된 것처럼 보이긴 하지만 다소 난해할 수 있습니다. 다음은 표시될 수 있는 몇 가지 예입니다.[ WARNING] Attempt 1: Attachment download of id 3265791 from https://xxxxx.shotgunstudio.com failed: [Error 206] The filename or extension is too long: 'C:  Users  xxxxx  AppData  Roaming  Shotgun  bundle_cache  tmp  0933a8b9a91440a2baf3dd7df44b40ce  bundle_cache  git  tk-framework-imageutils.git  v0.0.2  python  vendors  osx  lib  python2.7  site-packages  pip  _vendor  requests  packages  urllib3  packages  ssl_match_hostname'[ WARNING] File 'c: users xxxxx appdata local temp ab35bd0eb2b14c3b9458c67bceeed935_tank.zip' could not be deleted, skipping: [Error 32] The process cannot access the file because it is being used by another process: 'c:  users  xxxxx  appdata  local  temp  ab35bd0eb2b14c3b9458c67bceeed935_tank.zip'ERROR sgtk.core.descriptor.io_descriptor.downloadable] Failed to download into path C: Users xxxxx AppData Roaming Shotgun bundle_cache tmp 123456789012a34b567c890d1e23456: Failed to download sgtk:descriptor:shotgun?entity_type=PipelineConfiguration&amp;amp;field=uploaded_config&amp;amp;id=38&amp;amp;version=123456 from https://xxxxx.shotgunstudio.com. Error: Failed to download from 'https://xxxxx.shotgunstudio.com' after 5 retries. See error log for details.. Attempting to remove it.WARNING sgtk.core.util.shotgun.download Attempt 4: Attachment download of id 1182 from https://xxxxx.shotgunstudio.com failed: [Errno 2] No such file or directory: 'C:  Users  xxxxx  AppData  Roaming  Shotgun  bundle_cache  tmp  dd2cc0804122403a87ac71efccd383ea  bundle_cache  app_store  tk-framework-desktopserver  v1.3.1  resources  python  build  pip  _vendor  requests  packages  urllib3  packages  ssl_match_hostname  _implementation.py'WARNING sgtk.core.util.filesystem File 'c: users xxxxx appdata local temp 08f94bfe9b6d43e7a7beba30c192a43c_tank.zip' could not be deleted, skipping: [Error 32] The process cannot access the file because it is being used by another process: 'c:  users  xxxxx  appdata  local  temp  08f94bfe9b6d43e7a7beba30c192a43c_tank.zip'ERROR sgtk.core.descriptor.io_descriptor.downloadable] Failed to download into path C: Users xxxxx AppData Roaming Shotgun bundle_cache tmp dd2cc0804122403a87ac71efccd383ea: Failed to download sgtk:descriptor:shotgun?entity_type=PipelineConfiguration&amp;amp;field=sg_uploaded_config&amp;amp;id=1&amp;amp;version=1182 from https://xxxxx.shotgunstudio.com. Error: Failed to download from 'https://xxxxx.shotgunstudio.com' after 5 retries. See error log for details.. Attempting to remove it.ERROR sgtk.core.bootstrap.cached_configuration Failed to install configuration sgtk:descriptor:shotgun?entity_type=PipelineConfiguration&amp;amp;field=sg_uploaded_config&amp;amp;id=1&amp;amp;version=1182. Error: Failed to download into path C: Users xxxxx AppData Roaming Shotgun bundle_cache tmp dd2cc0804122403a87ac71efccd383ea: Failed to download sgtk:descriptor:shotgun?entity_type=PipelineConfiguration&amp;amp;field=sg_uploaded_config&amp;amp;id=1&amp;amp;version=1182 from https://xxxxx.shotgunstudio.com. Error: Failed to download from 'https://xxxxx.shotgunstudio.com' after 5 retries. See error log for details.. Cannot continue.이 문제가 발생하는 이유Windows에서 Flow Production Tracking 데스크톱은 데이터를 %APPDATA% 폴더(일반적으로 C: Users jane AppData Roaming Shotgun)에 저장합니다. 표준 default2 툴킷 구성을 사용할 때는 사용자 이름이 지나치게 길지만 않으면 대부분 괜찮습니다. 그러나 자체 앱, 엔진 또는 프레임워크를 만드는 경우, 특히 코드와 함께 종속성을 번들로 묶고(여기서처럼) 번들에 디렉토리의 깊은 트리가 있는 경우 이 문제가 발생할 위험이 더 클 수 있습니다.문제 해결이 문제를 해결하는 방법은 일반적으로 $SHOTGUN_HOME 환경 변수를 C: SG와 같이 매우 짧게 설정하는 것입니다. 이렇게 하면 SG 데스크톱이 C: Users jane AppData Roaming Shotgun 대신 C: SG에 해당 데이터를 저장하게 되며 문자 길이가 줄어들어 일반적으로 제한 수준을 유지할 수 있습니다. 여기에서 환경 변수에 대해 읽을 수 있습니다.향후 가능성여기에 설명된 대로 레지스트리 업데이트를 통해 Windows 10의 최신 버전에서 이 문제를 완화하는 다른 방법이 있을 수도 있지만 SG 데스크톱에서 매니페스트 파일을 업데이트하여 longPathAware 설정을 활용하도록 하는 것도 필요하다고 생각합니다. 제가 Mac 사용자라 그런지는 모르겠지만 말입니다. ;)커뮤니티에서 전체 스레드 보기",
    "url": "/aed84d1f/",
    "relUrl": "/aed84d1f/"
  },
  "93": {
    "id": "93",
    "title": "성능 문제 해결",
    "content": "성능 문제 해결툴킷 사용 시 속도가 느려지는 문제가 발생할 수 있습니다. 이러한 문제의 원인으로는 서버 속도, 인터넷 연결 등의 클라이언트 측 인프라 문제부터 툴킷 또는 Flow Production Tracking 구성 시 성능이 고려되지 않은 구성 관련 문제, 그리고 최적화를 추가적으로 적용할 코드 영역까지 다양할 수 있습니다.다음은 확인해야 할 사항의 목록으로, 아래에서 자세히 살펴보겠습니다.  앱, 엔진, 프레임워크, 코어 및 Flow Production Tracking 데스크톱이 최신 상태인지 확인합니다.  일반적인 사용 중에 디버그 로깅이 활성화되지 않았는지 확인합니다.  필요한 폴더만 생성하며 폴더가 실제로 필요할 때만 생성되도록 제한합니다. 너무 많은 폴더를 스키마에 추가하면 속도가 느려집니다.  서버에 사용자 캐시를 저장하면 속도가 느려질 수 있습니다. 로컬 드라이브 위치를 가리키도록 Flow Production Tracking Flow Production Tracking_HOME 환경 변수 를 설정하여 사용자의 캐시를 리디렉션할 수 있습니다.  아티스트에게 필요하지 않은 컨텐츠는 필터링하여 제외하도록 Workfiles 및 Loader 앱을 구성합니다. 엔티티 목록을 아티스트의 현재 태스크와 관련이 있는 항목으로 간결하게 유지하려면 상태를 기준으로 필터링해 보십시오.  커스텀 후크가 있는지 그리고 이러한 커스텀 후크로 인해 오버헤드가 증가하지는 않는지 확인하십시오.아래 목록에는 모범 사례와 속도 저하 문제가 발생하는 일반적인 사례가 정리되어 있습니다. 전체 사례가 수록된 완전한 목록은 아니며 새로운 패턴이 발견되는 대로 목록에 추가하겠습니다. 이 안내서가 문제 원인을 파악하는 데 도움이 되지 않을 경우 언제든지 지원 티켓을 제출해 주십시오. Shotgun 팀이 도와드리겠습니다.목차:  일반적인 모범 사례          캐시 위치      최신 버전 유지      중앙 집중식 구성과 분산 구성 비교      디버깅        소프트웨어의 시작 속도가 느림          진단      문제가 시작 전에 발생합니까? 아니면 시작 후에 발생합니까?      로그 확인      소프트웨어의 실행 속도가 느려지는 일반적인 원인        File Open, File Save 또는 Loader 앱의 속도가 느립니까?  폴더 생성 속도가 느림          입출력량 문제 해결      폴더 등록      일반적인 모범 사례캐시 위치Flow Production Tracking 툴킷은 사용자의 홈 디렉토리에 데이터를 캐시합니다. 이 캐시에는 여러 가지 SQLite 데이터베이스와 캐시된 앱 및 구성이 포함될 수 있습니다. 대개 사용자의 홈 디렉토리는 시스템의 로컬 하드 드라이브에 저장되지만, 스튜디오에서 이를 네트워크 저장소로 리디렉션하는 경우가 많습니다. 이렇게 되면 성능에 영향을 미칠 수 있습니다. 특히, 브라우저 통합 및 폴더 생성/조회 등에 사용되는 SQLite 데이터베이스에 주로 영향을 미칩니다.사용자 디렉토리가 서버 위치에 저장되는 경우 Flow Production Tracking_HOME 환경 변수를 사용하여 Flow Production Tracking 툴킷 캐시의 경로를 변경하는 것이 좋습니다. Flow Production Tracking_HOME 환경 변수는 툴킷이 번들 캐시, 썸네일, 그리고 데이터의 빠른 조회에 사용되는 SQLite 데이터베이스 등과 같은 다양한 데이터를 캐시하는 위치를 설정하는 데 사용됩니다.디버깅Flow Production Tracking 툴킷에서 디버그 로깅을 활성화할 수 있습니다. 그러면 다양한 프로세스에 대한 출력을 더욱 상세하게 얻을 수 있습니다.  문제를 진단하는 데 아주 유용한 기능이지만, 디버그 설정은 일상적인 사용 중에는 활성화되도록 설계되지 않았습니다. 로깅 출력이 늘어나면 성능에 상당한 영향을 미칠 수 있습니다.성능 문제가 발생하면, 특히 특정 시스템 또는 사용자에 국한되어 성능 문제가 발생하는 경우 먼저 디버그 로깅이 활성화되지 않았는지 확인합니다.최신 버전 유지성능 문제가 발생하면 코어, 앱, 엔진 및 프레임워크가 최신 상태인지 확인하십시오. 최신 버전에서는 이미 수정 사항 또는 최적화 기능이 제공되었을 수 있습니다.중앙 집중식 구성과 분산 구성 비교고급 툴킷 구성은 중앙 집중식 구성과 분산 구성이라는 두 가지 방법으로 설정할 수 있습니다. 주된 차이점은 중앙 집중식 구성의 경우 일반적으로 모든 사용자가 액세스할 수 있는 스튜디오의 네트워크 저장소에 저장되며, 분산 구성의 경우 대개 클라우드에 저장되고 사용자별로 로컬로 캐시된다는 점입니다.이러한 차이점은 성능 이외의 측면에도 영향을 미치지만 성능 차원에서도 각기 다른 장단점을 가집니다. 다음 표에는 성능 측면의 장단점이 정리되어 있습니다.                   장점      단점                  중앙 집중식 구성      - 초기 설정 프로세스가 완료되면 필요한 모든 항목이 이미 다운로드되어 모든 사용자가 이용할 수 있게 준비됩니다.      - 중앙 집중식 구성은 일반적으로 네트워크 저장소에 유지되므로 일반적인 툴킷 사용 중에 성능 저하가 나타날 수 있습니다.                     - 이후에 업데이트할 때는 중앙의 위치에 한 번만 다운로드하면 됩니다.      - 툴킷 구성에는 작은 파일이 많이 포함되므로 이러한 작은 파일에 대한 메타데이터 작업 처리가 상당히 느려지고 서버에 부담을 줄 수 있습니다. 또한, 구성을 빠르게 읽어올 수 없으므로 툴킷 사용을 통한 읽기 작업이든 일반적인 서버 사용을 통한 읽기 작업이든 읽기 작업이 과도하게 많은 경우 툴킷의 성능에 영향을 미칠 수 있습니다.              분산 구성      - 캐시된 앱, 엔진, 프레임워크 및 코어가 로컬로 캐시된 다른 구성과 공유할 수 있는 방식으로 저장됩니다. 즉, 여러 프로젝트가 동일한 종속 항목을 공유하는 경우 이러한 프로젝트를 이후에 로드할 때 캐시가 더 빨라질 수 있습니다.      - 분산 구성은 사용자별로 로컬에 캐시되어야 합니다. 보통, 이 과정에서 구성과 함께 필요한 모든 앱, 엔진, 프레임워크 및 코어가 다운로드됩니다.                     - 이러한 항목은 사용자의 로컬 하드 드라이브에 있는 캐시에 저장되며, 따라서 일반적으로 서버 속도보다 빠릅니다. 즉, 초기 캐시 후 성능이 중앙 집중식 구성보다 빠릅니다.      - 이 프로세스는 백그라운드에서 원활히 수행될 수 있지만, 이러한 항목을 다운로드해야 하는 초기 부담이 여전히 존재합니다.                            - 구성이 종속 항목의 새 버전을 가리키도록 업데이트될 때마다 구성과 새 종속 항목이 모두 캐시되어야 합니다.      요약하자면 저장 장치의 속도는 느리지만 인터넷 연결 속도가 괜찮다면 분산 구성이 가장 좋은 선택이 될 수 있고, 서버 저장 장치 성능은 좋지만 인터넷 속도는 좋지 않을 경우에는 중앙 집중식 구성이 적합할 수 있습니다.                    참고: 분산 구성을 사용하고 싶지만 시스템별로 종속 항목을 다운로드하는 것이 염려된다면 번들 캐시를 중앙 집중화하여 모든 사용자가 공유하도록 할 수 있습니다.    분산 구성을 사용하는 경우 사용자는 캐시에 없는 항목만 다운로드하면 되며, 한 사용자가 다운로드한 항목을 다른 사용자도 활용할 수 있게 됩니다. 이렇게 하려면 각 시스템에서 공유 위치를 가리키도록 Flow Production Tracking_BUNDLE_CACHE_PATH 환경 변수를 설정하면 됩니다.소프트웨어의 시작 속도가 느림Maya, Nuke, Houdini 등의 소프트웨어를 시작할 때 Flow Production Tracking 없이 시작할 때보다 시간이 오래 걸리는 것을 알아차리셨을 것입니다.  Flow Production Tracking 없이 시작하는 경우보다 시간이 약간 더 오래 걸리는 것은 당연하겠지만, 용납할 수 없을 정도로 오래 걸리는 경우도 있을 수 있습니다. 소프트웨어에 따라 다르지만 대개 1분 안에 시작되어야 합니다.  소프트웨어를 시작하는 데는 많은 프로세스가 관련되기 때문에 이 문제를 진단하는 것은 더 어려울 수 있습니다.진단먼저, 이 문제가 어떠한 상황에서 발생하는지 파악해야 합니다.  Flow Production Tracking 없이 시작할 때도 속도가 느립니까? - 뻔한 이야기일 수 있지만 Flow Production Tracking와 함께 시작할 때만 문제가 발생하는지 확인하는 것이 좋습니다.  시작 방법에 상관없이 동일하게 속도가 느립니까? 즉, SG 데스크톱에서 시작할 때나, 브라우저 통합을 사용하여 SG 사이트에서 시작할 때 느린 속도에 차이가 없습니까? - Flow Production Tracking 사이트에서 시작할 때는 속도가 느리지만 SG 데스크톱에서 시작할 때는 속도가 느리지 않은 경우 브라우저 통합 문제이거나 디스크에 폴더를 생성하는 것과 관련한 문제가 있음을 나타낼 수 있습니다. 프로젝트 이외의 컨텍스트에서 시작하는 경우 디스크에 추가로 폴더를 생성해 보면 시간이 어디서 많이 걸리는지 확인할 수 있습니다. 소프트웨어가 시작될 때마다 필요한 폴더가 존재하는지 확인한다는 사실도 주목해야 합니다.  모든 프로젝트에서 이 문제가 발생합니까? - 그렇지 않다면 구성이 설정된 방식과 관련하여 문제가 있을 가능성이 큽니다.  하루 중 특정 시간에만 이 문제가 발생합니까? - 그렇다면 하루 중 특정 시간에 서버 사용량이 많은 경우와 같이 인프라에 대한 수요가 높다는 것을 나타낼 수 있습니다.  모든 시스템/OS에서 이 문제가 발생합니까? - 특정 시스템에서만 속도가 느린 경우 툴킷 외부에 문제의 원인이 있을 가능성이 있습니다. 이 경우, 먼저 해당 시스템에서 툴킷 캐시를 지우는 것이 좋습니다. OS마다 제공되는 소프트웨어 버전 및 Python 패키지가 다르며, 특정 빌드에서 성능 문제가 발생하는 경우가 있을 수 있습니다. 특히, Samba(SMB) 공유를 사용하는 Windows에서 성능 문제를 확인했습니다. 이러한 문제에 대한 수정 사항은 없지만, Windows를 사용하는 경우 유의하시기 바랍니다.문제가 특정 OS, Python 패키지 또는 소프트웨어 버전으로 국한된다고 판단되는 경우 Shotgun 지원 팀에서 추가적인 조사를 진행할 수 있도록 알려주시기 바랍니다.  모든 사용자에게 이 문제가 발생합니까? - 위와 마찬가지로 동일한 시스템의 다른 사용자에게는 이 문제가 발생하지 않을 수 있습니다. 이 경우, 사용자의 로컬 Flow Production Tracking 캐시를 먼저 지우십시오. 또한, 정상적으로 프로덕션 환경에서 사용할 때 디버그 로깅이 활성화되지 않은 것을 확인하십시오. 활성화할 경우 성능에 영향을 미치게 됩니다.  느린 시작 문제가 특정 앱/소프트웨어에만 국한됩니까? 아니면 모든 앱/소프트웨어가 비정상적으로 느리게 시작됩니까? - 특정 소프트웨어만 느리게 시작되는 경우 구성 문제가 있을 수 있습니다. 성능에 영향을 미칠 수 있는 커스텀 후크가 시작 전이나 후에 실행되도록 설정되었는지 확인하는 것이 좋습니다. 시작에 사용되는 일반 후크는 before_app_launch.py, app_launch.py이며 코어 후크는 engine_init.py입니다. 최신 버전의 소프트웨어가 출시될 때 Shotgun 통합이 갑자기 훨씬 더 느리게 시작되는 등의 문제가 발생할 수도 있습니다. 이러한 경우 지원 팀에 문의하여 이에 대해 알고 있는지, 그리고 알려진 수정 사항이 있는지 확인해야 합니다. 이때 현재 사용 중인 소프트웨어의 버전 번호(해당하는 경우 패치/서비스 팩 포함)와 현재 실행 중인 tk 엔진 및 코어의 버전을 알려 주십시오.문제가 시작 전에 발생합니까? 아니면 시작 후에 발생합니까?위의 방법으로 문제의 원인이 좁혀지지 않을 경우 다음 단계로 시작 프로세스가 언제 느려지는지 파악해야 합니다. 툴킷을 통해 소프트웨어를 시작하는 경우 대개 두 단계 프로세스로 간추릴 수 있습니다.첫 번째 단계에서는 소프트웨어를 시작하는 데 필요한 정보를 수집하고 컨텍스트에서 폴더를 자동으로 생성한 후 소프트웨어를 실제로 시작하는 등의 초기 작업을 수행합니다. 소프트웨어가 시작된 후 두 번째 단계에서는 툴킷 통합을 시작합니다.일반적으로, 성능 문제가 프로세스의 첫 번째 단계에서 발생하는지 아니면 두 번째 단계에서 발생하는지는 로그를 확인하지 않고도 알 수 있습니다.  소프트웨어의 시작 화면이 시작하는 데 오래 걸리는 경우 첫 번째 단계에 문제가 있을 가능성이 큽니다.  소프트웨어가 시작 과정의 초반에는 상대적으로 속도가 빨랐다가 초기화가 완료되고 Flow Production Tracking 메뉴가 표시된 후 느려지는지 확인하십시오.  이 경우 두 번째 단계에 문제가 있는 것입니다.이를 파악하고 나면 로그에서 무엇을 확인해야 할지 알 수 있습니다.로그 확인이제 이 문제가 시작의 첫 번째 단계에서 발생했는지 아니면 두 번째 단계에서 발생했는지 파악되었을 것이므로 이에 따라 로그에서 확인할 부분을 결정할 수 있습니다. 로그는 엔진별로 나뉘어 있으므로 문제가 시작 전 단계에서 발생한 경우 SG 데스크톱에서 시작했는지 아니면 SG 사이트에서 시작했는지에 따라 각각 tk-desktop.log 또는 tk-ShotGrid.log를 확인해야 합니다.다음으로 수행해야 하는 작업은 디버그 로깅을 활성화하는 것입니다.                    참고: 위에서 설명한 대로 디버그 로깅이 이미 활성화된 경우 이것이 속도 저하 문제의 원인이 될 수 있으므로 디버그 로깅이 활성화되지 않은 상태에서도 테스트해야 합니다.    디버그 로깅을 활성화하고 나면 기존 로그를 지운 후 시작 프로세스를 다시 실행해야 합니다. 그런 후에는 로그의 타임스탬프를 조사하여 시간이 갑자기 건너뛴 부분을 확인할 수 있습니다.예를 들어, 다음은 폴더 생성 중에 시간이 5초 이후로 건너뛴 행을 보여줍니다.2019-05-01 11:27:56,835 [82801 DEBUG sgtk.core.path_cache] Path cache syncing not necessary - local folders already up to date!2019-05-01 11:28:01,847 [82801 INFO sgtk.env.asset.tk-shotgun.tk-shotgun-folders] 1 Asset processed - Processed 66 folders on disk.시간이 건너뛴 부분을 찾고 나면 해당 로그 행에서 폴더를 생성 중이었는지 아니면 Flow Production Tracking에 연결 중이었는지와 같이 해당 단계에서 어떠한 작업이 수행 중이었는지 확인할 수 있습니다.로그를 읽는 것이 어렵거나 내용이 이해되지 않는 경우에는 지원 팀에 문의하여 도움을 받으십시오.소프트웨어의 실행 속도가 느려지는 일반적인 원인            인터넷 속도가 느림      툴킷 사용의 거의 모든 부분에서 Flow Production Tracking 사이트에 연결하고 통신해야 하므로 인터넷 속도가 느릴 경우 영향을 받을 수 있습니다.  이 경우, 소프트웨어를 시작할 때뿐 아니라 다른 경우에도 속도 문제가 나타날 수 있습니다. 그러나, 연결 속도가 아닌 안정성에 문제가 있다면 프로세스 전반에 걸쳐 Flow Production Tracking 통신이 꽤 많이 필요하기 때문에 시작 단계에서 성능 문제가 나타날 가능성이 더 큽니다.              서버 액세스가 느림      이 경우 시작 시간에 확실히 영향을 미칠 수 있습니다. 중앙 집중식 구성(구성이 중앙 서버에 저장됨)을 사용하는 경우 구성 파일을 읽을 때마다 많은 입출력이 발생할 수 있습니다. 또한, 소프트웨어를 시작하면 시작 컨텍스트에 대해 폴더 생성 작업이 트리거됩니다. 즉, 폴더가 생성되었는지 확인하고 생성되지 않은 경우 폴더가 새로 만들어집니다.              폴더 생성      위에 설명한 대로 폴더 생성은 속도 저하 문제를 일으키는 일반적인 원인이 될 수 있습니다. 자세한 내용은 아래에서 폴더 생성과 관련한 성능 문제 해결 단원을 참조하십시오.      File Open, File Save 또는 Loader 앱의 속도가 느립니까?가장 먼저 문제가 있는 앱에서 어느 부분이 느려지는지 확인해야 합니다.  앱을 시작할 때 속도가 느립니까? 아니면 탭을 탐색할 때 속도가 느립니까?          앱이 너무 많은 정보를 표시하도록 구성되어 있는 것일 수 있습니다. 이 경우 목록에서 불필요한 엔티티를 필터링하여 제외하도록 내 태스크(My Tasks) 탭 및 기타 탭을 구성할 수 있습니다. 예를 들어, 대기 중(hld) 또는 최종(fin)과 같은 특정 상태의 태스크를 필터링하여 제외할 수 있습니다. 이렇게 하면 성능이 향상되고 아티스트는 중요한 정보만 볼 수 있게 됩니다. Loader 앱 및 Workfiles 앱에서 모두 필터링이 가능합니다. 단, Workfiles에는 현재 필터링에 대한 특정 섹션이 없으며, 계층 설정을 통해 필터링을 적용할 수 있습니다.      File Open 앱에서는 계층의 하위 항목이 확장될 때까지 하위 항목의 로드를 유예하도록 구성할 수 있습니다. 현재, 기본 구성 설정이지만 이전 구성을 사용하는 경우에는 이 설정을 사용하도록 전환할 수 있습니다.      디버그 로깅이 활성화되지 않은 것을 확인하십시오. 활성화되어 있으면 추가 입출력이 많이 발생하며, 이에 따라 속도가 느려질 수 있습니다. 이 앱은 많은 디버깅 출력을 포함합니다.        새 파일을 열거나 저장하거나 생성할 때 속도가 느립니까?          씬 작업 또는 액션 후크를 인계받았는지 확인하고 이러한 기능과 관련하여 속도를 저하시킬 수 있는 커스텀 동작이 있는지 확인합니다.      파일을 만들거나 저장할 때 Workfiles는 컨텍스트에 필요한 모든 폴더가 생성되었는지 확인합니다. 폴더 생성은 성능 문제가 흔히 발생하는 부분입니다.      폴더 생성 속도가 느림폴더 생성은 여러 가지 부분으로 구성되기 때문에 문제가 발생하는 경우 프로세스 속도 저하가 나타날 수 있습니다.폴더 생성 과정은 다음과 같습니다.  로컬 경로 캐시를 동기화합니다.  구성 스키마를 읽어옵니다.  특정 컨텍스트에 따라 만들어야 하는 경로 목록을 생성합니다.  로컬로 저장된 경로 레지스트리와 비교하여 경로를 확인합니다.  아직 등록되지 않은 경우 SG 사이트와 로컬 모두에 새 경로를 등록하려고 시도합니다.  폴더의 등록 여부에 상관없이 폴더가 실제로 디스크에 있는지 확인하고 없는 경우 폴더를 생성합니다.정리하면, 폴더 생성 시 로컬 데이터베이스에 기록하고 SG 사이트와 통신하는 외에도 디스크에서 상당한 양의 입출력이 발생할 수 있습니다.입출력량 문제 해결저장 장치가 대량의 작은 읽기-쓰기 작업을 처리하기에 느리거나 비효율적일 가능성이 있으므로 인프라를 개선하기 위해 수행하는 작업이라면 무엇이든 폴더 생성 속도를 높이는 데 도움이 됩니다. 하지만, 최대한 부담을 줄이기 위해 툴킷 구성 측면에서 수행할 수 있는 단계가 있습니다.첫 번째 단계는 해당 컨텍스트와 작업 환경에 중요한 폴더만 생성되도록 폴더를 제한하는 것입니다. 예를 들어, Maya의 샷에 대한 태스크를 진행하는 경우 해당하는 샷과 소프트웨어에 대한 폴더만 확인하고 생성하는 것이 바람직합니다.기본적으로, 작업물을 저장하고 게시하는 데 필요한 최소한의 폴더만 생성하는 것이 좋습니다.상위 폴더와 동시에 생성스키마 폴더에 적용될 수 있는 create_with_parent 설정이 있습니다.이 설정을 True로 설정하면 폴더와 상위 폴더가 동시에 생성됩니다. 이 설정을 True로 설정하면 대량 폴더에 대해 확인 및 생성 작업이 수행되지 않도록 주의해야 합니다.예시시퀀스/샷 폴더 계층이 있고 샷 폴더를 상위 폴더인 시퀀스 폴더와 함께 생성하도록 설정한 경우 시퀀스 폴더가 생성될 때마다 연결된 모든 샷에 대해 확인 작업이 수행되고 이에 대한 폴더가 생성됩니다.때로는 이러한 동작이 편리할 수 있지만 이로 인해 더 많은 폴더가 확인 작업을 거쳐 동시에 생성되는 문제가 발생합니다. 이러한 경우, 샷에 대한 태스크의 작업 파일에 새 파일을 생성하려고 하면 샷의 상위 폴더인 시퀀스 폴더의 생성 작업이 트리거되고, 이에 따라 현재 작업하는 샷만이 아니라 모든 하위 폴더인 샷 폴더가 생성됩니다.                    참고: 단계 스키마 폴더에 대한 설정은 기본적으로 true로 설정됩니다.    생성 유예defer_creation 설정을 사용하면 특정 엔진이 실행 중일 때에만 폴더 생성이 발생하도록 제한하여 폴더가 생성되는 경우를 세부적으로 조정할 수 있습니다. 커스텀 이름을 사용하여 sgtk API를 통해 이에 대한 생성 작업을 트리거할 수도 있습니다.예시게시 단계에서만 생성해야 하는 폴더가 여러 개 있을 수 있습니다. 이 경우, maya_publish의 유예 키워드로 커스텀을 설정한 후 API를 사용하여 이 키워드를 엔진 이름으로 사용하여 폴더를 만들 수 있습니다.스키마 내 폴더는 다음과 같습니다.# the type of dynamic contenttype: &quot;static&quot;# defer creation and only create this folder when Photoshop startsdefer_creation: &quot;publish&quot;그런 다음, 다음과 같은 스크립트를 사용하여 폴더를 만듭니다.sgtk.create_filesystem_structure(entity[&quot;type&quot;], entity[&quot;id&quot;], engine=&quot;publish&quot;)확장된 예시폴더를 유예하는 방법에서 더 나아가 프로젝트의 루트에 동적이 아닌 폴더가 여러 개 있는 경우 일반적으로 한 번만 생성하면 됩니다. 예를 들어, 기본 구성 스키마의 루트에 있는 “editorial” 및 “reference” 폴더는 프로젝트 시작 시 한 번만 생성하면 되지만, 기본적으로 폴더 생성 작업 시 항상 이 폴더의 존재 여부를 확인합니다.이 폴더에 대해 yml 파일을 생성하여 이를 제한할 수 있습니다. 이 yml 파일에서는 폴더 생성이 특정 엔진에서 실행되거나 유예 키워드가 전달되는 경우에만 폴더가 생성되도록 유예 키워드를 설정할 수 있습니다. 유예 키워드를 tk-shell로 설정한 후 tank folders와 같은 tank 명령을 통해 폴더 생성을 실행할 수 있습니다.그러면 폴더 생성이 tank 명령을 통해 실행되는 경우에만 폴더가 생성됩니다. 이 작업은 툴킷 관리자가 처음으로 프로젝트를 설정할 때 수행할 수 있습니다. 또는, 위의 예시와 같은 커스텀 키워드를 사용하여 폴더 생성을 실행하는 간단한 스크립트를 작성할 수도 있습니다.폴더 등록향후 컨텍스트를 조회할 때 경로가 사용될 수 있도록 폴더 생성 프로세스 중에 폴더가 등록됩니다. 위에서 설명한 대로 이 프로세스 부분을 실행하기 위해서는 레지스트리가 저장된 중앙 위치인 Flow Production Tracking 사이트와의 통신이 필요합니다. 하지만, 도구에서 더욱 신속하게 조회할 수 있도록 이러한 레지스트리는 로컬로도 캐시됩니다.SQLite 데이터베이스로컬 경로 캐시에서는 데이터를 저장하기 위해 SQLite 데이터베이스를 사용합니다. 데이터베이스가 네트워크 저장소에 저장되는 경우 데이터베이스 읽기 및 쓰기 관련 성능이 심각한 영향을 받을 수 있습니다.초기 동기화많은 폴더가 등록된 프로젝트에 대해 로컬 캐시를 처음부터 생성해야 하는 경우가 있을 수 있습니다(예: 이미 진행 중인 프로젝트에 새 사용자가 참여하는 경우). 이 프로세스는 아주 긴 시간이 걸릴 수 있지만, 다행인 점은 이러한 현상이 해당 프로젝트에 대해 한 번만 발생한다는 것입니다.후속 동기화에서는 로컬 캐시와 사이트 레지스트리 사이의 차이점만 가져옵니다. 사용자의 프로젝트 작업 빈도가 낮고 세션 간에 많은 폴더가 생성되는 경우 모든 항목이 캐시되는 동안 대기하는 시간이 길어질 수 있습니다.사용자가 이러한 문제에 사용하는 것으로 확인된 한 가지 방법은 최신 버전의 로컬 캐시를 사용자 시스템으로 전송하는 것입니다.                    참고: 이 방법은 프로젝트에 대해 과도하게 많은 폴더가 생성되는 경우에만 사용해야 합니다.    이 업데이트 프로세스는 코어 후크 cache_location.py를 사용하여 자동으로 수행될 수 있습니다. 위치를 변경하는 대신 이 후크를 사용하여 캐시 위치를 설정할 수 있으며, 이 후크를 사용하여 비용이 많이 드는 전체 동기화를 수행할 필요 없이 중앙 위치의 path_cache.db 파일을 사용자의 기본 위치로 복사할 수 있습니다.이렇게 중앙에 저장된 경로 캐시는 작업자의 캐시에서 수동으로 복사하거나 정기적으로 이러한 캐시를 전송하는 스크립트를 작성하여 주기적으로 업데이트할 수 있습니다.                    경고: cache_location.py 후크를 사용하여 캐시의 위치를 설정할 수 있지만, 모든 사용자에 대해 단일 위치를 가리키도록 설정하지 않아야 합니다. 그러면 하나 이상의 프로세스에서 동시에 데이터베이스를 편집하려고 할 때 데이터베이스 잠금이 발생할 수 있습니다.    ",
    "url": "/396dd133/",
    "relUrl": "/396dd133/"
  },
  "94": {
    "id": "94",
    "title": "파이프라인 통합 구성요소",
    "content": "파이프라인 통합 구성요소여기에서는 툴킷 플랫폼의 구성요소에 대한 참조 문서를 찾을 수 있습니다.",
    "url": "/162eaa4b/",
    "relUrl": "/162eaa4b/"
  },
  "95": {
    "id": "95",
    "title": "파이프라인 통합",
    "content": "파이프라인 통합ShotGrid의 파이프라인 통합을 통해 Flow Production Tracking 데이터를 아티스트에게 제공할 수 있습니다. 인기 있는 컨텐츠 제작 소프트웨어 내에서 UI를 커스터마이즈하여 아티스트들이 태스크에 대한 정보를 확인하고, 노트를 읽고 추가하며, 팀 구성원과 파일을 공유할 수 있도록 기본적인 도구를 제공할 수 있습니다. 파이프라인 통합은 Flow Production Tracking 툴킷 플랫폼을 기반으로 하며, 개발자는 툴킷 API를 사용하여 기능을 확장하거나 커스텀 툴킷 앱을 만들 수 있습니다.이 섹션에는 Flow Production Tracking 파이프라인 관리를 시작하는 데 도움이 되는 학습 자료가 포함되어 있습니다. 파이프라인 구성 및 프로덕션 파일 시스템 관리에 대한 안내서, 기본 VFX 파이프라인을 빌드하기 위한 튜토리얼, 자체 파이프라인 도구를 작성하기 위한 리소스가 제공됩니다.",
    "url": "/e058fbea/",
    "relUrl": "/e058fbea/"
  },
  "96": {
    "id": "96",
    "title": "애니메이션 파이프라인 튜토리얼",
    "content": "애니메이션 파이프라인 튜토리얼이 튜토리얼에서는 애니메이션이나 시각 효과 프로덕션을 위한 단순하면서도 전형적인 파이프라인을 빌드하는 방법을 다룹니다. 이 튜토리얼을 수행하면 에셋을 모델링에서부터 모양 개발, 그리고 프로덕션 씬으로 푸시하는 데 필요한 모든 부분을 제공하는 파이프라인을 빌드하게 됩니다.이 파이프라인에서 다루는 대부분의 워크플로우는 Flow Production Tracking의 기본 제공 통합에서 기본적으로 작동합니다. 이 튜토리얼은 스튜디오에서 커스텀 솔루션을 많이 빌드하는 파이프라인 부분에 대해 툴킷 플랫폼을 사용하여 아티스트 워크플로우를 커스터마이즈하는 프로세스를 안내합니다.다음은 이 튜토리얼에서 빌드할 파이프라인의 개략적인 뷰입니다.    파이프라인 개요파이프라인 개요편의상 사용되는 DCC(디지털 컨텐츠 생성) 소프트웨어는 최소로 유지되며 Maya 및 Nuke로 제한됩니다. 마찬가지 이유로 파이프라인 단계 간에 전달되는 데이터는 Maya ascii 파일, Alembic 캐시 및 렌더링된 이미지 시퀀스로 제한됩니다.                    참고: 이 튜토리얼에 설명된 단순 파이프라인은 프로덕션에서 테스트되지 않았으므로 Flow Production Tracking 기반 파이프라인을 어떻게 빌드할 수 있는지에 대한 예제로만 사용해야 합니다.    필수 요건      작업 중인 Flow Production Tracking 프로젝트 - 이 튜토리얼에서는 프로덕션 데이터 트래킹 및 관리를 위해 Flow Production Tracking을 사용하는 환경이라고 가정합니다.        Flow Production Tracking 통합 이해 - Flow Production Tracking는 통합 기능을 통해 수동 구성이 필요 없는 몇 가지 간단한 프로덕션 워크플로우를 제공합니다. 이 튜토리얼에 설명된 수동 구성 및 커스터마이제이션에 대해 자세히 알아보기 전에 이러한 워크플로우의 기능 및 범위를 이해해야 합니다. Flow Production Tracking 통합에 대한 자세한 정보는 여기를 참조하십시오.        Maya 및 Nuke 환경 - 이 튜토리얼은 Nuke와 Maya를 사용하여 간단한 파이프라인을 빌드하도록 설계되었습니다. Flow Production Tracking에서 제공하는 통합을 커스터마이즈하기 위해서는 이러한 패키지를 기본적으로 이해하고 있어야 합니다.        Python 실무 지식 - 이 튜토리얼에서는 Python으로 작성된 “후크”를 통해 Flow Production Tracking 통합 기능을 수정해야 합니다.        YAML 사용 경험 - 빌드할 파이프라인의 대부분의 구성은 YAML 파일을 수정하여 처리됩니다.  추가 리소스      Flow Production Tracking 지원 사이트        Flow Production Tracking 통합                  사용자 안내서                    관리자 안내서                    개발자 안내서            프로젝트 작성 및 설정이 튜토리얼에서는 Flow Production Tracking에 새 프로젝트를 만들고 프로덕션을 위해 시작할 준비가 된 것처럼 구성해야 합니다. 여기에는 필요한 모든 Flow Production Tracking 엔티티가 제대로 배치되고 링크되어 있는지 확인하는 것도 포함됩니다. 이 튜토리얼에서는 에셋, 시퀀스, 샷 및 태스크 엔티티가 필요하며 새 프로젝트에서 기본값으로 사용할 수 있어야 합니다. 다음을 만듭니다.      두 개의 에셋:                  주전자 캐릭터                    테이블 소품                  하나의 시퀀스        만든 시퀀스에 링크된 하나의 샷        파이프라인 단계별 태스크  다음은 구성된 프로젝트 엔티티가 Flow Production Tracking에서 어떻게 표시되는지 보여 주는 일부 스크린샷입니다.    주전자 및 테이블 에셋    시퀀스에 링크된 샷    태스크소프트웨어 시작 관리자다음으로, Flow Production Tracking 데스크톱에서 Maya 및 Nuke를 시작할 수 있는지 확인해야 합니다. 이러한 각 패키지는 데스크톱에서 해당 아이콘을 클릭하여 시작할 수 있습니다. 각 패키지의 적절한 버전이 시작되는지 확인합니다.응용프로그램이 데스크톱에 표시되지 않거나 예상한 버전이 시작되지 않을 경우 소프트웨어 엔티티를 통해 Flow Production Tracking에서의 시작을 수동으로 구성해야 할 수 있습니다.    Flow Production Tracking에 정의된 기본 소프트웨어 엔티티소프트웨어 엔티티는 프로덕션에 사용할 DCC 패키지를 구동하는 데 사용됩니다. 기본적으로 통합은 표준 설치 위치에서 이러한 패키지를 검색하고 데스크톱을 통해 시작할 수 있도록 합니다. 둘 이상의 버전을 설치하거나 표준 위치가 아닌 곳에 설치한 경우 아티스트의 시작 환경을 조정하기 위해 Flow Production Tracking의 해당 소프트웨어 엔티티 항목을 업데이트해야 할 수도 있습니다.소프트웨어 엔티티 및 적절한 구성 방법에 대한 자세한 정보는 통합 관리자 안내서를 참조하십시오. 예상한 방식으로 DCC가 시작되면 다음 섹션으로 진행할 수 있습니다.구성구성은 프로젝트에 대한 아티스트 워크플로우를 정의합니다. 여기에는 아티스트가 시작하는 DCC 내에 포함할 Flow Production Tracking 통합, 프로젝트의 폴더 구조 정의 방법 및 아티스트가 데이터를 공유할 때 만든 파일 및 폴더에 대한 명명 규칙 지정이 포함됩니다.기본적으로 모든 새 프로젝트는 다양한 기성 소프트웨어 패키지를 사용하여 아티스트 간에 공유 파일에 대한 기본 워크플로우를 제공하는 기본 Flow Production Tracking 통합을 사용하도록 구성됩니다. 다음 섹션에서는 프로젝트의 파이프라인 구성을 인계받고 스튜디오에 맞게 커스터마이즈하는 방법에 대해 설명합니다.프로젝트 구성 설정하기Flow Production Tracking 데스크톱을 사용하여 프로젝트의 구성을 인계받습니다. 데스크톱 내에서 마우스 오른쪽 버튼을 클릭하거나 오른쪽 하단의 사용자 아이콘을 클릭하면 팝업 메뉴가 표시됩니다. 고급 프로젝트 설정…(Advanced project setup…) 옵션을 선택하고 마법사를 수행하여 프로젝트 구성을 로컬로 설치합니다. 아래 이미지는 필요한 단계를 보여 줍니다. 통합 관리자 안내서에 설명된 파이프라인 구성 가져오기 단계를 수행할 수도 있습니다.    데스크톱 팝업 메뉴에서 고급 프로젝트 설정…(Advanced project setup…)을 선택합니다.    Flow Production Tracking 기본값(Flow Production Tracking Default) 구성 유형을 선택합니다.이번에 처음으로 Flow Production Tracking 프로젝트를 설정하는 경우 프로젝트 데이터의 저장소 위치를 정의하라는 메시지가 표시될 수도 있습니다. 아니면 기존 저장소 위치를 선택할 수 있습니다.    새 저장소를 만듭니다.    새 저장소 이름을 지정합니다. 이 저장소는 사이트 전체 수준의 저장소이며 프로젝트별 저장소가 아닙니다.    사용할 운영 체제에서 이 저장소에 액세스할 수 있는 경로를 설정합니다.사이트 기본 설정(Site Preferences)의 파일 관리(File Management) 섹션에서 Flow Production Tracking 사이트에 대한 저장소를 보고 편집할 수 있습니다. 이러한 설정에 대한 자세한 내용은 여기에서 확인할 수 있습니다.저장소 위치를 선택했으므로 이제 해당 위치에서 새 프로젝트에 대한 디렉토리 이름을 선택합니다.    프로젝트의 파일을 저장할 폴더 이름을 입력합니다.이 튜토리얼에서는 중앙 집중식 구성을 사용합니다. 분산 설정(Distributed Setup) 옵션은 다른 혜택을 제공할 수 있는 대체 옵션을 제공하며 빠른 공유 저장소가 없는 스튜디오의 경우 자주 사용하는 옵션이 될 수 있습니다. 다른 구성 설정의 장단점에 대한 자세한 내용은 툴킷 관리 프리젠테이션에서 확인할 수 있습니다사이트 전체 수준의 저장소와 달리 구성은 프로젝트별로 다르므로 여기서 선택하는 디렉토리는 구성을 저장하는 데 직접 사용됩니다.    현재 운영 체제에 대해 선택하는 구성 경로를 기록합니다.위 화면에서 선택하는 폴더가 구성이 설치될 위치입니다. 이 튜토리얼에서는 이 폴더의 구성 컨텐츠를 살펴보고 수정합니다.위 화면에서 설정 실행(Run Setup)을 클릭하면 데스크톱에서 구성에 필요한 모든 구성 요소를 다운로드하고 설치하기 시작합니다. 설치 프로세스를 완료하는 데 몇 분 정도 걸릴 수 있습니다. 설치가 완료되면 전체 프로젝트 구성의 로컬 사본이 생기고 이를 다음 단계에서 수정합니다.데스크톱 설치 튜토리얼에서 지정한 구성 위치는 Flow Production Tracking에서 해당 프로젝트에 대한 파이프라인 구성(Pipeline Configurations) 페이지에 기록됩니다.    Flow Production Tracking에서 파이프라인 구성 엔티티 복제다음 섹션을 위한 준비로 이 폴더의 컨텐츠를 숙지합니다.구성 편성간단한 파이프라인 빌드 프로세스를 시작하기 전에 파이프라인 구성 편성 및 작동 방식을 이해해야 합니다. 다음 그래프에서 구성의 주요 구성 요소 및 해당 용도를 중점적으로 설명합니다. 구성 및 관리에 대한 자세한 정보는 툴킷 관리 문서를 참조하십시오.    프로젝트 스키마이 튜토리얼에서 빌드할 간단한 파이프라인은 기본 구성에서 제공되는 프로젝트 스키마를 사용합니다. config/core/schema 폴더를 검색하면 툴킷 앱에서 디스크에 파일을 작성할 때 생성되는 구조에 대해 파악할 수 있습니다. 프로젝트 디렉토리 구조 구성에 대한 자세한 정보는 파일 시스템 구성 참조 설명서를 참조하십시오.템플릿또한 이 튜토리얼에서는 기본 파이프라인 구성에 정의된 템플릿을 사용합니다. config/core/templates.yml 파일을 열고 디스크상의 경로에 입력 및 출력 파일을 매핑하기 위해 앱에서 가장 많이 사용되는 템플릿을 가져올 수 있습니다. 템플릿 시스템에 대한 자세한 정보는 파일 시스템 구성 참조 설명서를 참조하십시오.후크이 튜토리얼의 대부분에는 아티스트 워크플로우를 커스터마이즈하기 위한 앱 후크 수정 작업이 포함됩니다. 이 커스터마이제이션에 대해 자세히 알아보기 전에 후크가 무엇인지, 어떻게 작동하는지, 어디에 있는지에 대한 기본적인 이해가 필요합니다. 관리 문서의 후크 섹션을 참조하십시오.튜토리얼을 진행하면서 툴킷 앱 중 하나에서 정의된 후크를 “인계”받으라는 요청을 받게 됩니다. 앱 후크를 인계받는 프로세스는 간단합니다. 해당 요청을 받을 때마다 다음 단계를 수행하기만 하면 됩니다.      구성의 설치 폴더에서 재지정할 후크가 포함된 앱을 찾습니다. 해당 앱의 hooks 하위 디렉토리를 검색하여 재지정할 후크 파일을 찾습니다.        구성의 최상위 수준 hooks 디렉토리에 후크를 복사하고 필요한 경우 이름을 바꿉니다.      파일이 구성의 hooks 폴더에 있기만 하면 코드를 변경하고 커스터마이즈할 수 있습니다. 해당 앱을 이 새 위치로 지정하려면 추가 단계가 필요합니다. 이 단계는 튜토리얼의 후반부에 나옵니다.파이프라인 빌드이제 파이프라인을 빌드할 준비가 되었습니다. Flow Production Tracking에서 프로젝트를 설정하고 데스크톱을 통해 Maya &amp;amp; Nuke를 시작할 수 있으며 프로젝트 구성을 제어했습니다. 또한 구성의 기본 구조를 이해하고 아티스트 워크플로우를 구체화할 준비가 되었습니다.다음 섹션에서는 각 파이프라인 단계를 수행하면서 기본 제공 기능을 중점적으로 설명하고 Flow Production Tracking 통합을 커스터마이즈하는 프로세스를 안내합니다. 이 섹션을 마칠 때쯤에는 완벽한 기능을 갖춘 간단한 전체 프로덕션 파이프라인을 갖게 됩니다. 또한 아티스트가 프로덕션에서 작업할 때 수행하는 단계도 파악할 수 있습니다.                    참고: 이 튜토리얼의 모든 코드 및 구성은 tk-config-default2 리포지토리의 pipeline_tutorial 분기에서 찾을 수 있습니다. 파일이 있을 위치, 코드를 추가할 위치 등의 힌트가 필요한 경우 자유롭게 이 분기를 사용합니다.    모델링 워크플로우간단한 파이프라인의 첫 번째 단계는 모델링입니다. 이 섹션에서는 프로젝트의 주전자 에셋에 대한 첫 번째 반복을 만듭니다. 이를 프로젝트의 폴더 구조로 디스크에 저장한 다음 게시합니다.먼저 Flow Production Tracking 데스크톱에서 Maya를 시작합니다.Maya가 완전히 로드되면 파일 열기(File Open) 대화상자가 나타납니다. 이 대화상자를 사용하여 프로젝트 내의 기존 Maya 파일을 찾을 수 있습니다. 또한 Flow Production Tracking 통합에서 인식하는 새 파일을 만들 수 있습니다.에셋(Assets) 탭을 선택하고 주전자의 모델링 태스크로 찾아 들어갑니다. 이 태스크에 대한 아티스트 작업 파일이 아직 없으므로 + 새 파일(+ New File) 버튼을 클릭합니다.    이 버튼을 클릭하여 비어 있는 새 Maya 세션을 만들고 현재 작업 중인 컨텍스트를 주전자 에셋의 모델 태스크로 설정합니다.                    참고: 이 튜토리얼에서 언제든지 Maya 또는 Nuke의 Flow Production Tracking 메뉴를 통해 Flow Production Tracking 패널을 시작할 수 있습니다. 이 패널에서는 DCC를 종료하지 않고 프로젝트 데이터에 뷰를 제공합니다. 현재 작업 중인 컨텍스트와 해당 컨텍스트 내의 최근 액티비티가 표시됩니다. 또한 패널로 직접 피드백에 대한 노트를 추가할 수 있습니다. 자세한 정보는 Flow Production Tracking 패널 설명서를 참조하십시오.    다음으로, 주전자를 모델링하거나 제공된 주전자를 다운로드하여 가져옵니다.    주전자 모델이 만족스러우면 Flow Production Tracking &amp;gt; 파일 저장…(File Save…) 메뉴 액션을 선택합니다. 이 대화상자에 지정된 이름, 버전 및 유형으로 파일을 저장할지 묻는 메시지가 표시됩니다.    대화상자에 전체 저장 경로를 지정하라는 메시지는 표시되지 않는데 이는 앱이 maya_asset_work 템플릿으로 저장하도록 구성되었기 때문입니다. 이 템플릿은 기본적으로 다음과 같이 정의됩니다.@asset_root/work/maya/{name}.v{version}.{maya_extension}토큰화된 필드, {name}, {version} 및 {maya_extension}은 모두 앱에서 전체 경로를 입력해야 하는 필드입니다. 템플릿의 @asset_root 부분은 다음으로 정의됩니다.assets/{sg_asset_type}/{Asset}/{Step}여기서 토큰화된 필드는 위에서 새 파일을 만들 때 설정한 현재 작업 중인 컨텍스트에 따라 툴킷 플랫폼에 의해 자동으로 추정될 수 있습니다.또한 대화상자 하단에서 작성될 파일 이름 및 경로의 미리보기를 확인합니다. 프로젝트 구성을 설정할 때 정의한 기본 저장소 및 프로젝트 폴더가 템플릿 경로의 루트를 구성합니다.저장(Save) 버튼을 클릭하여 주전자 모델을 저장합니다.이때 주의해야 할 중요한 점은 방금 완료한 단계가 아티스트가 파이프라인 전체에서 작업 파일을 열고 저장할 때 수행할 단계와 동일하다는 점입니다. 파일 열기(File Open) 및 파일 저장(File Save) 대화상자는 Workfiles 앱의 일부입니다. 이 “다중” 앱은 Flow Production Tracking 통합에서 지원하는 모든 DCC에서 실행되며 모든 아티스트에 대해 일관된 워크플로우를 제공합니다.다음 단계는 주전자를 약간 변경하는 것입니다. 뚜껑 지오메트리가 나중에 리깅할 수 있도록 모델의 나머지 부분과 분리되는지 확인합니다.    작업이 만족스러우면 Flow Production Tracking &amp;gt; 파일 저장…(File Save…) 메뉴 액션을 다시 실행합니다. 이번 대화상자에서는 기본적으로 버전 번호가 2로 설정됩니다. 파일 버전 자동 증분을 사용하면 아티스트가 수행한 전체 작업 내역을 관리할 수 있습니다. 저장(Save) 버튼을 클릭합니다.    주전자 모델을 버전 2로 저장하고 나면 튜토리얼의 이번 섹션에서 마지막 단계를 진행할 준비가 된 것입니다.이제 주전자 모델이 준비되면 서페이스 처리 및 리깅할 수 있도록 게시해야 합니다. 게시하려면 Flow Production Tracking &amp;gt; 게시…(Publish…) 메뉴 액션을 클릭합니다. Publish 앱 대화상자가 표시됩니다.    대화상자에 게시될 항목의 트리가 표시됩니다. 트리에서 일부는 게시할 항목을 나타내고 일부는 게시 작업 중 수행할 액션을 나타냅니다.대화상자의 왼쪽에 현재 Maya 세션을 나타내는 항목이 표시됩니다. 그 아래에 Flow Production Tracking에 게시(Publish to Flow Production Tracking) 하위 액션이 표시됩니다. 모든 세션 지오메트리(All Session Geometry)를 나타내는 추가 항목이 현재 세션의 하위 항목으로 표시됩니다. 여기에도 Flow Production Tracking에 게시(Publish to Flow Production Tracking) 하위 액션이 있습니다.                    참고: 모든 세션 지오메트리(All Session Geometry) 항목이 표시되지 않으면 Maya에서 Alembic 내보내기 플러그인이 활성화되어 있는지 확인합니다.    트리 왼쪽의 항목을 클릭하여 Publish 앱을 탐색합니다. 수행할 항목을 선택하면 게시되는 항목에 대한 설명을 입력할 수 있습니다. 오른쪽의 카메라 아이콘을 클릭하여 항목과 관련된 스크린샷을 찍을 수 있습니다.준비가 되었으면 오른쪽 하단에 있는 게시(Publish) 버튼을 클릭하여 현재 작업 파일과 주전자 지오메트리를 게시합니다. 완료되면 Flow Production Tracking에서 주전자 에셋을 검색하여 게시가 성공적으로 완료되었는지 확인할 수 있습니다.    위 이미지에서 주전자 모델이 포함되어 있는 게시된 Alembic 파일을 볼 수 있습니다. Maya 세션 파일에 대한 게시도 볼 수 있습니다. 이러한 게시는 Publish 앱의 트리 뷰에 있는 항목에 해당됩니다.파일 저장(File Save) 대화상자 사용 시 만든 작업 파일과 마찬가지로 이러한 두 게시의 출력 경로는 템플릿으로 구동됩니다. 다음과 같이 표시됩니다(나중에 앱에서 이 템플릿이 구성된 위치를 확인할 수 있음).Maya 세션 게시:@asset_root/publish/maya/{name}.v{version}.{maya_extension}이 템플릿은 기본적으로 작업 파일 템플릿과 매우 유사하며 유일한 차이점은 publish 폴더에 있다는 것입니다.에셋 게시:@asset_root/publish/caches/{name}.v{version}.abc이 템플릿은 Maya 세션 게시 템플릿과 유사하지만 파일이 caches 폴더에 작성됩니다.File Save 대화상자와 달리, 게시할 때는 이름, 버전 또는 파일 확장자 값을 제공할 필요가 없습니다. 왜냐하면 기본적으로 게시자가 작업 파일 경로에서 이러한 값을 가져오기 때문입니다. 후드에서 작업 템플릿을 통해 이러한 값을 추출한 다음 게시 템플릿에 적용합니다. 이 개념은 템플릿을 사용하여 한 파이프라인 단계의 출력을 다른 파이프라인 단계의 입력에 연결하는 방법 및 툴킷 플랫폼과 관련하여 중요한 개념입니다. 자세한 정보는 이후 섹션에서 다룹니다.디스크에서 파일을 찾아 올바른 위치에 만들어졌는지 확인합니다.축하합니다! 주전자의 첫 번째 게시된 반복을 성공적으로 만들었습니다. 학습한 내용을 활용하여 테이블 소품의 모델링 태스크에서 테이블 모델을 게시할 수 있는지 확인합니다. 결과는 다음과 같아야 합니다.    다음 단계는 서페이스 처리 워크플로우입니다.서페이스 처리 워크플로우이 섹션은 모델링 섹션에서 배운 내용을 기반으로 합니다. Loader 앱을 사용하여 이전 섹션에서 만든 주전자 모델을 로드하는 방법을 배우게 됩니다. 또한 Publish 앱을 커스터마이즈하여 주전자 셰이더를 게시하는 방법도 배우게 됩니다.데스크톱에서 Maya를 실행하여 시작합니다. 이전 섹션의 작업 후에 계속 Maya가 열려 있는 경우 Maya를 다시 시작할 필요가 없습니다. Maya가 열려 있으면 Flow Production Tracking &amp;gt; 파일 열기…(File Open…) 메뉴 항목을 사용하여 Workfiles 앱을 엽니다. 모델링 섹션에서와 마찬가지로 에셋(Assets) 탭을 사용하여 주전자 에셋의 태스크로 찾아 들어갑니다. 이때 서페이스 처리 태스크를 선택하고 + 새 파일(+ New File)을 클릭합니다.    이제 주전자의 서페이스 처리 태스크에서 작업하게 됩니다. 올바른 프로덕션 컨텍스트에 있는지 쉽게 확인하는 방법은 Flow Production Tracking 메뉴의 첫 번째 항목을 확인하는 것입니다.    다음으로 주전자 모델을 새 서페이스 처리 작업 파일로 로드해야 합니다. 이렇게 하려면 Maya의 Flow Production Tracking &amp;gt; 로드…(Load…) 메뉴 항목을 통해 Loader 앱을 시작합니다.    Loader 앱의 레이아웃은 Workfiles 앱과 유사하지만 지금은 작업 파일을 여는 대신 게시된 파일을 검색하여 로드합니다.에셋(Assets) 탭에서 주전자 캐릭터를 찾아 이전 섹션에서 만든 주전자 게시를 표시합니다. Maya 씬 및 Alembic 캐시 게시를 볼 수 있습니다. Alembic 캐시 게시를 선택하면 대화상자 오른쪽에 상세 정보가 표시됩니다. 그런 다음 Alembic 캐시 게시의 액션(Actions) 메뉴에서 참조 만들기(Create Reference) 항목을 클릭합니다. 기본적으로 추가 액션을 수행할 수 있게 Loader가 계속 열려 있지만 Loader를 닫고 계속 진행할 수 있습니다. 모델링 태스크에서 주전자 게시를 가리키는 참조가 생성된 것을 Maya에서 볼 수 있습니다.    다음으로, 주전자에 간단한 프로시쥬얼 셰이더를 추가합니다.    파이프라인을 빌드할 때 셰이더 관리는 시간이 오래 걸리는 복잡한 태스크일 수 있습니다. 이는 특히 스튜디오에만 해당되는 경우가 많습니다. 왜냐하면 제공되는 Maya 통합에서 셰이더 또는 텍스처 관리 기본 기능을 처리하지 않기 때문입니다.계속하기 전에 Flow Production Tracking &amp;gt; 파일 저장…(File Save…) 메뉴 액션을 사용하여 현재 세션을 저장합니다.커스텀 셰이더 게시이 간단한 파이프라인의 목적에 맞게 Publisher 앱을 커스터마이즈하여 서페이스 처리 단계에서 추가 게시 항목으로 Maya 셰이더 네트워크를 내보냅니다. 튜토리얼 후반에서 다운스트림 참조 시 셰이더를 Alembic 지오메트리 캐시에 다시 연결할 수 있는 빠르고 간편한 솔루션을 만듭니다.                    참고: 추가할 커스터마이즈는 확실히 매우 간단하고 쉽습니다. 보다 강력한 솔루션을 위해 외부 이미지를 텍스처 맵으로 사용하는 에셋 관리 측면뿐만 아니라 서페이스 처리된 캐릭터의 대체 표현을 고려해야 할 수 있습니다. 이 예제는 실제 솔루션을 빌드하기 위한 시작점만 제공합니다.                        참고: 플러그인을 작성하는 방법에 대한 자세한 정보는 여기에서 확인할 수 있습니다.    Maya 컬렉터 재지정먼저 Publish 앱의 컬렉션 로직을 수정해야 합니다. 게시자는 앱에 게시하고 표시할 “수집” 항목에 대한 로직을 정의하는 컬렉터 후크로 구성됩니다. 프로젝트 구성 내의 다음 파일에서 구성된 앱의 설정을 찾을 수 있습니다.env/includes/settings/tk-multi-publish2.yml이 파일은 모든 아티스트 환경 내에서 Publish 앱이 사용되는 방법을 정의합니다. 파일을 열고 Maya 섹션, 특히 에셋 단계에 대한 구성을 검색합니다. 다음과 같이 표시됩니다.    컬렉터 설정은 Publisher의 컬렉션 로직이 존재하는 후크를 정의합니다. 기본적으로 이 값은 다음과 같습니다.collector: &quot;{self}/collector.py:{engine}/tk-multi-publish2/basic/collector.py&quot;이 정의에는 두 개의 파일이 포함되어 있습니다. 후크 설정에 여러 파일이 나열된 경우 상속을 의미합니다. 첫 번째 파일에는 설치된 Publish 앱의 후크 폴더로 평가할 {self} 토큰이 포함되어 있습니다. 두 번째 파일에는 현재 엔진(이 경우 설치된 Maya 엔진)의 후크 폴더로 평가할 {engine} 토큰이 포함되어 있습니다. 요약하면, 이 값은 Maya 고유의 컬렉터에 Publish 앱의 컬렉터가 상속됨을 의미합니다. 앱의 컬렉터 후크는 실행 중인 DCC에 관계없이 유용한 로직을 갖기 때문에 이러한 형태가 Publisher 구성의 일반적인 패턴입니다. DCC 고유 로직은 해당 기본 로직으로부터 상속받고 기본 로직을 확장하여 현재 세션에 해당되는 항목을 수집합니다.                    참고: 에셋 단계 환경에 대한 컬렉터 설정만 변경하므로 다른 컨텍스트(예: 샷 단계)에서 작업 중인 아티스트는 변경 사항을 볼 수 없습니다. 아티스트는 제공되는 기본 Maya 컬렉터를 계속 사용합니다.    구성 섹션에서 후크를 인계받는 방법을 배웠습니다. 구성에 Maya 엔진의 컬렉터 후크를 인계받아 커스터마이제이션 프로세스를 시작합니다.    위의 이미지는 이 작업을 수행하는 방법을 보여 줍니다. 먼저 프로젝트 구성의 hooks 폴더에 폴더 구조를 만듭니다. 나중에 다른 DCC에 대해 동일한 후크를 재지정할 수 있으므로 이렇게 하면 컬렉터 플러그인에 약간의 네임스페이스를 제공합니다. 다음으로, install 폴더에서 Maya 엔진의 컬렉터 후크를 새 후크 폴더 구조로 복사합니다. 이제 구성에 다음 경로를 가진 Maya 컬렉터 사본이 생겼습니다.config/hooks/tk-multi-publish2/maya/collector.py다음으로, 새 후크 위치를 가리키도록 publish2 설정 파일을 업데이트합니다. 이제 컬렉터 설정은 다음 값을 갖습니다.collector: &quot;{self}/collector.py:{config}/tk-multi-publish2/maya/collector.py&quot;{config} 토큰을 확인합니다. 이제 경로가 프로젝트 구성에서 hooks 폴더로 해석됩니다. 새 컬렉터 사본이 앱 자체에서 정의되는 컬렉터에서 상속됩니다.                    참고: 이때 게시하면 게시 로직은 새 위치에서 간단하게 복사하고 참조한 컬렉터와 정확히 동일합니다.    이제 원하는 IDE 또는 텍스트 편집기에서 컬렉터 사본을 연 다음 process_current_session 메서드를 찾습니다. 이 메서드는 현재 DCC 세션에서 모든 게시 항목 수집을 담당합니다. 새 게시 유형을 수집하게 되므로 이 메서드의 하단으로 이동하여 다음 행을 추가합니다.self._collect_meshes(item)현재 세션에 있는 모든 메쉬를 수집하기 위해 추가하는 새로운 메서드입니다. 이 방식은 나중에 만들 예정인 셰이더 게시 플러그인이 작동할 수 있는 메쉬 항목을 만듭니다. 전달되는 항목은 메쉬 항목의 상위가 될 세션 항목입니다.                    참고: 이 방식은 기존 게시 플러그인을 수정하는 매우 직접적인 접근 방법입니다. Publisher 구조 및 움직이는 모든 부분에 대한 자세한 정보는 개발자 문서를 참조하십시오.    이제 파일 하단에 아래 새 메서드 정의를 추가합니다.    def _collect_meshes(self, parent_item):       &quot;&quot;&quot;       Collect mesh definitions and create publish items for them.       :param parent_item: The maya session parent item       &quot;&quot;&quot;       # build a path for the icon to use for each item. the disk       # location refers to the path of this hook file. this means that       # the icon should live one level above the hook in an &quot;icons&quot;       # folder.       icon_path = os.path.join(           self.disk_location,           os.pardir,           &quot;icons&quot;,           &quot;mesh.png&quot;       )       # iterate over all top-level transforms and create mesh items       # for any mesh.       for object in cmds.ls(assemblies=True):           if not cmds.ls(object, dag=True, type=&quot;mesh&quot;):               # ignore non-meshes               continue           # create a new item parented to the supplied session item. We           # define an item type (maya.session.mesh) that will be           # used by an associated shader publish plugin as it searches for           # items to act upon. We also give the item a display type and           # display name (the group name). In the future, other publish           # plugins might attach to these mesh items to publish other things           mesh_item = parent_item.create_item(               &quot;maya.session.mesh&quot;,               &quot;Mesh&quot;,               object           )                     # set the icon for the item           mesh_item.set_icon_from_path(icon_path)           # finally, add information to the mesh item that can be used           # by the publish plugin to identify and export it properly           mesh_item.properties[&quot;object&quot;] = object코드가 주석 처리되어 있으며 수행할 작업에 대한 정보를 제공합니다. 요점은 이제 현재 세션에서 최상위 수준 메쉬에 대한 메쉬 항목을 수집하는 로직을 추가한 것입니다. 그러나 이때 게시자를 실행하면 항목 트리에서 어떤 메쉬 항목도 볼 수 없습니다. 왜냐하면 작동하도록 정의된 게시 플러그인이 없기 때문입니다. 다음으로, 메쉬 항목을 연결하고 다운스트림을 사용하기 위해 해당 항목 게시를 처리할 새 셰이더 게시 플러그인을 작성합니다.                    참고: 위 코드에는 메쉬 항목에 대한 아이콘을 설정하는 호출이 있습니다. 이 작업을 위해 다음과 같이 지정된 경로로 구성에 아이콘을 추가해야 합니다.    config/hooks/tk-multi-publish2/icons/mesh.png셰이더 게시 플러그인 만들기다음 단계에서는 메쉬의 셰이더를 디스크로 내보내 게시할 수 있는 게시 플러그인에 새로 수집한 메쉬 항목을 연결합니다. 이렇게 하려면 새 게시 플러그인을 만들어야 합니다. 이 후크의 소스 코드에 대한 이 링크를 따라 이동하고 이를 hooks/tk-multi-publish2/maya 폴더에 저장하고 이름을 publish_shader_network.py로 지정합니다.                    참고: 이 플러그인은 툴킷 플랫폼 및 게시 코드를 처음 사용하는 경우 실행할 다량의 코드입니다. 지금은 걱정할 필요가 없습니다. 이 튜토리얼을 진행하면서 진행되는 상황을 이해하고 게시자 기능을 사용하게 됩니다. 지금은 파일을 만들고 그 용도가 셰이더 네트워크를 디스크에 작성하는 것이라는 점만 알아도 됩니다.    셰이더를 게시하기 전의 마지막 단계는 새 Publish Shaders 플러그인에서 정의한 템플릿 및 구성을 추가하는 것입니다. settings 속성에서 플러그인에 의해 정의된 설정을 다음과 같이 볼 수 있습니다.    @property    def settings(self):       &quot;”” … &quot;””       # inherit the settings from the base publish plugin       plugin_settings = super(MayaShaderPublishPlugin, self).settings or {}       # settings specific to this class       shader_publish_settings = {           &quot;Publish Template&quot;: {               &quot;type&quot;: &quot;template&quot;,               &quot;default&quot;: None,               &quot;description&quot;: &quot;Template path for published shader networks. &quot;                              &quot;Should correspond to a template defined in &quot;                              &quot;templates.yml.&quot;,           }       }       # update the base settings       plugin_settings.update(shader_publish_settings)       return plugin_settings이 메서드는 플러그인에 대한 구성 인터페이스를 정의합니다. “게시 템플릿(Publish Template)” 설정에는 디스크에 셰이더 네트워크를 작성하는 플러그인이 필요합니다. 새 게시 플러그인을 Publisher 구성에 추가하고 템플릿 설정을 포함합니다. 이는 컬렉터를 인계받기 전에 수정한 구성 블록과 동일합니다. 해당 내용은 다음 파일에 정의되어 있습니다.env/includes/settings/tk-multi-publish2.yml이제 구성은 다음과 같습니다.    마지막으로, 구성에 새 maya_shader_network_publish 템플릿을 정의해야 합니다. 다음 파일을 편집하여 추가합니다.config/core/templates.yml에셋 관련 Maya 템플릿이 정의된 섹션을 찾아 새 템플릿 정의를 추가합니다. 정의는 다음과 같습니다.    모든 것이 정의되었습니다. 셰이더를 게시할 메쉬를 찾기 위해 Publish 앱의 컬렉터 후크를 재지정했습니다. 수집한 셰이더 항목에 연결할 새 게시 플러그인을 구현하고 디스크에 셰이더 네트워크를 작성할 새 게시 템플릿을 정의하고 구성했습니다.                    참고: 구성을 커스터마이즈하는 동안 Maya를 닫아도 괜찮습니다. 간단히 Maya를 다시 시작하고 파일 열기(File Open) 대화상자를 사용하여 서페이스 처리 작업 파일을 열 수 있습니다. 아래의 다시 로드 단계는 건너뛸 수 있습니다.    Flow Production Tracking 통합 다시 로드커스터마이제이션을 시도하려면 Maya 세션에서 통합을 다시 로드해야 합니다. 이렇게 하려면 Flow Production Tracking &amp;gt; 태스크 이름(Task Name) &amp;gt; 작업 영역 정보…(Work Area Info…) 메뉴 액션을 클릭합니다.    현재 컨텍스트에 대한 정보를 제공하는 Work Area Info 앱이 시작됩니다. 구성을 변경할 때 통합을 다시 로드할 수 있는 유용한 버튼도 있습니다. 버튼을 클릭하여 앱 및 엔진을 다시 로드한 다음 대화상자를 닫습니다.    셰이더 네트워크 게시이제 프로젝트 구성 변경 결과를 보겠습니다. Flow Production Tracking 메뉴에서 Publish 앱을 시작합니다. 다음과 같이 Publish Shaders 플러그인이 연결된 수집된 주전자 메쉬 항목이 표시됩니다.    작업 설명을 입력하고 게시된 파일과 연결할 서페이스 처리된 주전자의 썸네일을 캡처합니다. 마지막으로, 게시(Publish)를 클릭하여 주전자 셰이더를 디스크로 내보내고 파일을 Flow Production Tracking의 게시로 등록합니다. 완료되면 세션 게시 플러그인이 자동으로 작업 파일을 다음 사용 가능한 버전으로 저장했는지 확인합니다. 지금까지가 Flow Production Tracking 통합에서 지원되는 모든 DCC 내의 기본 동작입니다.이제 Flow Production Tracking에서 주전자 에셋을 검색하여 모두 예상대로 작동되는지 확인할 수 있습니다.    축하합니다! 성공적으로 파이프라인을 커스터마이즈하고 주전자에 대한 셰이더를 게시했습니다. 학습한 내용을 활용하여 테이블 소품의 서페이스 처리 태스크에서 셰이더를 게시할 수 있는지 확인합니다. 결과는 다음과 같아야 합니다.    다음 단계는 리깅 워크플로우입니다.리깅 워크플로우이제는 Flow Production Tracking에서 제공하는 Workfile 및 Publish 앱을 사용하여 작업 파일을 열거나 만들고 저장하고 게시하는 것이 어렵지 않을 것입니다. 또한 Loader 앱을 사용하여 업스트림에서 게시를 로드하기도 했습니다. 학습한 내용을 활용하여 다음 태스크를 완료합니다.      Flow Production Tracking 데스크톱에서 Maya 시작        주전자 에셋의 리깅 단계에서 새 작업 파일 만들기        모델링 단계에서 주전자 alembic 캐시 게시 로드(참조)        주전자 뚜껑을 리깅하여 열고 닫기(간단하게 유지)        주전자 리그 저장 및 게시  Flow Production Tracking에 다음과 같이 나타납니다.    다음으로, 아티스트가 해당 워크플로우에서 업스트림 변경을 처리하는 방법을 알아보겠습니다. 모델링 작업 파일을 열고 주전자 모델을 약간 변경합니다. 그런 다음 업데이트된 작업을 게시합니다. 결과는 다음과 같습니다.    주전자의 리깅 단계에서 작업 파일을 다시 엽니다(Flow Production Tracking &amp;gt; 파일 열기…(File Open…)). 이제 Flow Production Tracking &amp;gt; 씬 분할…(Scene Breakdown…) 메뉴 액션을 시작합니다. 작업 파일에 참조한 모든 업스트림 게시를 보여 주는 Breakdown 앱이 시작됩니다. 이 경우 업스트림 주전자 모델만 있습니다. 다음과 같이 표시됩니다.    앱은 각 참조에 대해 두 개의 표시기 중 하나를 표시합니다. 초록색 체크 표시는 참조된 게시가 최신 버전임을 나타내고 빨간색 “x”는 사용 가능한 최신 게시물이 있음을 나타냅니다. 이 경우에는 사용 가능한 최신 게시물이 있음을 확인할 수 있습니다.이제 참조된 주전자 Alembic 캐시 항목을 선택한 다음(또는 하단의 모든 빨간색 항목 선택(Select All Red) 버튼 클릭) 선택 항목 업데이트(Update Selected)를 클릭합니다.앱에서 Maya 참조가 주전자 Alembic 캐시의 최신 반복으로 업데이트됩니다. 이제 파일에 새 모델이 표시됩니다.    새 모델에 고려해야 하는 리깅 설정을 조정한 다음 변경 사항을 게시합니다.다음 섹션에서는 샷 컨텍스트에서 작업합니다. 다음 단계는 샷 레이아웃입니다.레이아웃 워크플로우이 섹션에서는 프로젝트에 대해 만든 샷에서 작업을 시작합니다. 이전 섹션에서 만든 에셋을 로드하고 샷을 실행해 봅니다. 그런 다음 게시자를 다시 커스터마이즈하고 이번에는 샷 카메라를 게시합니다.이전 섹션에서 학습한 내용을 활용하여 다음 태스크를 완료합니다.      Flow Production Tracking 데스크톱에서 Maya 시작        샷의 레이아웃 단계에서 새 작업 파일 만들기(힌트: Loader에서 샷(Shots) 탭 사용)        주전자의 리깅 단계에서 주전자 게시 로드(참조)        테이블의 모델 단계에서 테이블 게시 로드(참조)  이제 테이블에 주전자가 있는 간단한 씬을 실행합니다. 씬에 camMain이라는 카메라를 추가하고 몇 프레임에 애니메이션을 적용하여 샷의 카메라 이동을 만듭니다.    샷 레이아웃이 만족스러우면 Flow Production Tracking &amp;gt; 파일 저장…(File Save…) 메뉴 액션을 통해 파일을 저장합니다. 이때 계속 진행하여 게시하면 게시할 수 있는 항목으로 전체 Maya 세션만 표시됩니다.파이프라인에 추가하여 많은 유연성을 제공하는 쉬운 커스터마이제이션은 다른 패키지에 쉽게 가져올 수 있는 파일 형식으로 독립 실행형 카메라를 게시하는 기능입니다. 이렇게 하면 일반적으로 레이아웃에 카메라를 한 번 생성한 다음 애니메이션, 조명 및 합성 등의 다른 모든 파이프라인 단계를 수행하고 직접 사용할 수 있습니다.카메라 수집셰이더 게시에서와 같이 첫 번째 단계는 컬렉터 후크를 커스터마이즈하는 것입니다. 이미 Maya에 대한 컬렉터 후크를 인계받고 에셋 단계에 구성했습니다. 이제 샷 파이프라인 단계에 대한 구성을 업데이트해야 합니다. 이렇게 하려면 Publisher의 구성 파일을 수정하고 Maya 샷 단계 컬렉터 설정을 편집합니다.    이제 샷 컨텍스트 내의 태스크에서 작업할 때 커스텀 컬렉터 로직이 실행됩니다. 다음 단계에서는 커스텀 카메라 컬렉션 로직을 추가합니다.커스텀 컬렉터 후크를 열고 서페이스 처리 섹션에서 메쉬를 수집하는 호출을 추가한 process_current_session 메서드의 하단에 다음 메서드 호출을 추가합니다.self._collect_cameras(item)다음으로 파일 하단에 다음과 같이 메서드를 추가합니다.    def _collect_cameras(self, parent_item):       &quot;&quot;&quot;       Creates items for each camera in the session.       :param parent_item: The maya session parent item       &quot;&quot;&quot;       # build a path for the icon to use for each item. the disk       # location refers to the path of this hook file. this means that       # the icon should live one level above the hook in an &quot;icons&quot;       # folder.       icon_path = os.path.join(           self.disk_location,           os.pardir,           &quot;icons&quot;,           &quot;camera.png&quot;       )       # iterate over each camera and create an item for it       for camera_shape in cmds.ls(cameras=True):           # try to determine the camera display name           try:               camera_name = cmds.listRelatives(camera_shape, parent=True)[0]           except Exception:               # could not determine the name, just use the shape               camera_name = camera_shape           # create a new item parented to the supplied session item. We           # define an item type (maya.session.camera) that will be           # used by an associated camera publish plugin as it searches for           # items to act upon. We also give the item a display type and           # display name. In the future, other publish plugins might attach to           # these camera items to perform other actions           cam_item = parent_item.create_item(               &quot;maya.session.camera&quot;,               &quot;Camera&quot;,               camera_name           )           # set the icon for the item           cam_item.set_icon_from_path(icon_path)           # store the camera name so that any attached plugin knows which           # camera this item represents!           cam_item.properties[&quot;camera_name&quot;] = camera_name           cam_item.properties[&quot;camera_shape&quot;] = camera_shape다시 한 번 언급하지만 코드가 주석 처리되어 있으며 수행할 작업에 대한 정보를 제공합니다. 현재 세션의 모든 카메라에 대한 카메라 항목을 수집하는 로직을 추가했습니다. 이전과 마찬가지로, 이때 게시자를 실행하면 항목 트리에서 어떤 카메라 항목도 볼 수 없습니다. 왜냐하면 작동하도록 정의된 게시 플러그인이 없기 때문입니다. 다음으로, 이러한 항목을 연결하고 다운스트림을 사용하기 위해 해당 항목 게시를 처리할 카메라 게시 플러그인을 작성합니다.                    참고: 위 코드에는 카메라 항목에 대한 아이콘을 설정하는 호출이 있습니다. 이 작업을 위해 다음과 같이 지정된 경로로 구성에 아이콘을 추가해야 합니다.    config/hooks/tk-multi-publish2/icons/camera.png커스텀 카메라 게시 플러그인다음 단계에서는 메쉬의 셰이더를 디스크로 내보내 게시할 수 있는 게시 플러그인에 새로 수집한 메쉬 항목을 연결합니다. 이렇게 하려면 새 게시 플러그인을 만들어야 합니다. 이 후크의 소스 코드에 대한 이 링크를 따라 이동하고 이를 hooks/tk-multi-publish2/maya 폴더에 저장하고 이름을 publish_camera.py로 지정합니다.카메라 게시 구성마지막으로, 샷 단계에 대한 Publish 앱의 구성을 업데이트해야 합니다. 설정 파일을 편집하여 새 플러그인을 추가합니다.env/includes/settings/tk-multi-publish2.yml이제 구성은 다음과 같습니다.    새 플러그인의 settings 메서드에서 정의한 대로 파일에 추가된 두 개의 설정을 확인할 수 있습니다. 셰이더 플러그인과 마찬가지로 카메라 파일이 작성될 위치를 정의하는 게시 템플릿(Publish Template) 설정이 있습니다. 카메라 설정은 플러그인이 작동해야 할 카메라를 구동하는 카메라 문자열의 목록입니다. 즉, 일부 유형의 카메라 명명 규칙이 있고 이 설정을 사용하면 사용자가 규칙과 일치하지 않는 카메라의 항목을 게시할 수 없습니다. 위의 이미지에서는 camMain 카메라만 게시할 수 있도록 제공됩니다. 추가한 플러그인의 구현은 cam* 같이 와일드카드 패턴으로도 작동합니다.변경 사항을 테스트하기 전 마지막 단계는 새 카메라 게시 템플릿에 대한 정의를 추가하는 것입니다. config/core/templates.yml 파일을 편집하고 Maya 샷 템플릿 섹션에 템플릿 정의를 추가합니다.    이제 새 플러그인을 사용하여 카메라를 게시할 수 있습니다. Work Area Info 앱을 사용하여 통합을 다시 로드한 다음 Publisher를 시작합니다.    이미지에서 볼 수 있듯이, 새 카메라 항목이 수집되고 게시 플러그인이 연결됩니다. 계속 진행하여 게시(Publish)를 클릭하여 디스크에 카메라를 작성하고 Flow Production Tracking에 등록합니다.                    참고: Alembic 내보내기와 유사하게 카메라 게시 플러그인을 사용하려면 FBX 내보내기 플러그인을 로드해야 합니다. 카메라 게시 플러그인 항목이 표시되지 않으면 FBX 플러그인이 로드되었는지 확인하고 파일을 게시하면 Publisher를 다시 시작합니다.    Flow Production Tracking에 다음과 같이 나타납니다.    이제 완료되었습니다. 다음 단계는 애니메이션입니다.애니메이션 워크플로우지금까지는 커스텀 파일 유형/컨텐츠를 디스크에 작성하고 다른 파이프라인 단계에서 공유하기 위해 Publish 앱만 커스터마이즈했습니다. 이 섹션에서는 Loader 앱의 구성을 커스터마이즈하여 커스텀 게시를 가져오거나 참조할 수 있도록 하는 작업을 완료합니다.이전 섹션에서 학습한 내용을 활용하여 다음 태스크를 완료합니다.      Flow Production Tracking 데스크톱에서 Maya 시작        샷의 애니메이션 단계에서 새 작업 파일 만들기        샷의 레이아웃 단계에서 Maya 세션 게시 로드(참조)                      참고: 레이아웃 세션 게시 파일에 카메라가 포함되었음을 확인할 수 있습니다. 강력한 파이프라인에서 별도의 카메라 게시 파일이 하나의 실제 카메라 정의가 될 수 있도록 세션 게시에서 카메라를 명시적으로 숨기거나 제외할 수 있습니다. 계속 진행하여 참조로 포함된 카메라를 삭제하거나 숨깁니다.    커스텀 카메라 로더 액션카메라 게시를 가져오거나 참조하도록 Loader 앱을 커스터마이즈하려면 앱의 설정 파일을 편집해야 합니다. 구성에서 파일 경로는 다음과 같습니다.config/env/includes/settings/tk-multi-loader2.ymlMaya에 대해 앱이 구성된 섹션을 찾고 action_mappings 설정의 액션 목록에 다음 줄을 추가합니다.FBX Camera: [reference, import]커스텀 카메라 게시 플러그인에서, 디스크에 카메라를 작성하는 데는 Maya의 FBXExport mel 명령이 사용되었으며 Flow Production Tracking에 파일을 등록하는 데 사용된 게시 유형은 FBX Camera입니다. 설정에 추가한 행은 FBX Camera 유형의 게시에 대해 reference 및 import 액션을 표시하도록 로더에 지시합니다. 이러한 액션은 Loader 앱의 tk-maya-actions.py 후크에 정의되어 있습니다. 이러한 액션은 Maya가 참조하거나 가져올 수 있는 모든 파일 유형을 처리하는 방식으로 구현됩니다. 커스텀 플러그인에 의해 생성된 .fbx 파일은 이 범주에 해당하므로 이 작업이 게시된 카메라를 로드하는 데 필요한 유일한 변경 사항입니다.이제 앱 설정은 다음과 같습니다.    이제 Work Area Info 앱을 통해 통합을 다시 로드하고 새 설정을 선택한 다음 레이아웃에서 게시된 카메라를 찾습니다.    새 게시 유형별로 필터링한 다음 카메라에 대한 참조를 만듭니다. 로더를 닫고 새 참조 카메라를 사용하여 이전 섹션에서 만든 카메라 모션을 다시 재생할 수 있습니다.다음으로, 주전자 모델이 무언가를 수행하는 애니메이션을 적용합니다(간단하게 유지).    애니메이션이 만족스러우면 이전 섹션에서와 같이 작업 파일을 저장하고 게시합니다.다음 단계는 조명입니다.조명 워크플로우이 섹션에서는 이전 섹션에서 게시한 모든 것을 함께 가져와 샷을 렌더링합니다. 이렇게 하려면 주전자 에셋의 서페이스 처리 단계에서 게시한 셰이더를 로드하도록 Loader 앱을 커스터마이즈합니다.먼저, 이전 섹션에서 학습한 내용을 활용하여 다음 태스크를 완료합니다.      Flow Production Tracking 데스크톱에서 Maya 시작        샷의 조명 단계에서 새 작업 파일 만들기        샷의 애니메이션 단계에서 Maya 세션 게시 로드(참조)        샷의 레이아웃 단계에서 카메라 게시 로드(참조)  커스텀 셰이더 로더 액션서페이스 처리 단계에서 게시한 셰이더를 로드하려면 이전 섹션에서 언급한 tk-maya-actions.py 후크를 인계받아야 합니다. 해당 후크를 설치 위치에서 구성으로 복사합니다.    이 후크는 지정된 게시에 대해 수행할 수 있는 액션 목록 생성을 담당합니다. Loader 앱은 제공된 통합에서 지원되는 각 DCC에 대해 이 후크와 다른 버전을 정의합니다.서페이스 처리 워크플로우 섹션에서 게시된 셰이더는 바로 Maya 파일이므로 내보낸 카메라와 같이 기존 로직을 변경하지 않고 로더에서 참조할 수 있습니다. 유일하게 변경해야 할 사항은 셰이더가 파일에 참조된 후 적절한 메쉬에 셰이더를 연결하도록 액션 후크에 새 로직을 추가하는 것입니다.액션 후크의 마지막에(클래스 외부) 다음 메서드를 추가합니다.    def _hookup_shaders(reference_node):       &quot;&quot;&quot;       Reconnects published shaders to the corresponding mesh.       :return:       &quot;&quot;&quot;       # find all shader hookup script nodes and extract the mesh object info       hookup_prefix = &quot;SHADER_HOOKUP_&quot;       shader_hookups = {}       for node in cmds.ls(type=&quot;script&quot;):           node_parts = node.split(&quot;:&quot;)           node_base = node_parts[-1]           node_namespace = &quot;:&quot;.join(node_parts[:-1])           if not node_base.startswith(hookup_prefix):               continue           obj_pattern = node_base.replace(hookup_prefix, &quot;&quot;) + &quot; d*&quot;           obj_pattern = &quot;^&quot; + obj_pattern + &quot;$&quot;           shader = cmds.scriptNode(node, query=True, beforeScript=True)           shader_hookups[obj_pattern] = node_namespace + &quot;:&quot; + shader       # if the object name matches an object in the file, connect the shaders       for node in (cmds.ls(references=True, transforms=True) or []):           for (obj_pattern, shader) in shader_hookups.iteritems():               # get rid of namespacing               node_base = node.split(&quot;:&quot;)[-1]               if re.match(obj_pattern, node_base, re.IGNORECASE):                   # assign the shader to the object                   cmds.select(node, replace=True)                   cmds.hyperShade(assign=shader)이제 셰이더 연결 로직을 호출하기 위해 _create_reference 메서드 마지막에 다음 두 줄을 추가합니다.    reference_node = cmds.referenceQuery(path, referenceNode=True)    _hookup_shaders(reference_node)&amp;lt;/td&amp;gt;코드는 새 참조가 만들어질 때마다 실행되므로 셰이더가 이미 파일에 있는 경우 새 지오메트리 참조 시 셰이더를 할당해야 합니다. 마찬가지로, 셰이더를 참조하고 지오메트리가 이미 존재할 때 작동합니다.                    참고: 이 연결 로직은 매우 억지스럽고 프로덕션에서 바로 사용할 수 있는 파이프라인을 구현할 때 고려해야 할 네임스페이스 및 기타 Maya와 관련된 미묘한 문제를 적절하게 처리하지 않습니다.    마지막으로, 다음 파일을 편집하여 샷의 Loader 설정을 새 후크로 지정합니다.config/env/includes/settings/tk-multi-loader2.yml또한 Maya 셰이더 네트워크 게시 유형을 참조 액션과 연결합니다. 이제 Loader 설정은 다음과 같습니다.    이제 Work Area Info 앱을 통해 통합을 다시 로드하여 새 설정을 선택한 다음 서페이스 처리에서 게시된 셰이더를 검색합니다.주전자 셰이더 네트워크 게시에 대한 참조를 만듭니다.    이제 테이블 셰이더 네트워크를 로드합니다. Maya에서 하드웨어 렌더링을 켜면 셰이더가 애니메이션 단계에서 자동으로 메쉬 참조에 연결해야 합니다.    이제 씬에 약간의 조명을 추가합니다(간단하게 유지).    Maya 렌더 게시디스크에 샷을 렌더링합니다.                        참고: 여기에서 볼 수 있듯이 주전자 및 테이블 에셋 둘 다 서페이스 처리에 문제가 있습니다. 이 튜토리얼에서는 의도된 예술적 선택이었다고 가정합니다. 이러한 문제를 해결하려면 언제든지 이러한 에셋의 서페이스 처리 작업 파일을 로드하고 셰이더를 조정하여 다시 게시할 수 있습니다. 이 경우, 조명 작업 파일의 참조를 업데이트하고 다시 렌더링해야 합니다. 단계를 진행하면 참조를 다시 로드한 후 Breakdown 앱이 업데이트된 셰이더를 다시 연결하지 않는다는 사실을 알 수 있습니다. 셰이더 참조를 연결하도록 Loader를 수정한 경험을 기반으로 필요한 로직을 추가하도록 Breakdown 앱의 씬 작업 후크를 업데이트할 수 있어야 합니다. 이 파일의 업데이트 메서드를 참조하십시오.    제공된 Flow Production Tracking 통합은 파일에 정의된 렌더 레이어를 확인하여 이미지 시퀀스를 수집합니다. 렌더가 완료되면 게시자를 시작합니다. 렌더링된 시퀀스가 트리의 항목으로 표시됩니다.    계속 진행하여 세션 및 렌더링된 이미지 파일 시퀀스를 게시합니다. Flow Production Tracking에 다음과 같이 나타납니다.    다음 단계는 합성입니다.합성 워크플로우이 마지막 튜토리얼 섹션에서는 Nuke에서 제공하는 기본 통합의 일부를 소개합니다. 이전 섹션에서 확인한 앱 외에도 Flow Production Tracking 인식 쓰기 노드와 리뷰를 위해 다른 작업자에게 빠르게 렌더를 보낼 수 있는 앱에 대해 알아봅니다.다음 단계를 수행하여 작업 파일을 준비합니다.      Flow Production Tracking 데스크톱에서 Nuke를 시작합니다.        Maya에서와 마찬가지로, Flow Production Tracking &amp;gt; 파일 열기…(File Open…) 메뉴 액션을 사용하여 샷의 합성 단계에서 새 작업 파일을 만듭니다.  Loader 앱을 통해 이전 섹션에서 렌더링 및 게시된 이미지 시퀀스를 로드합니다.    Image 및 Rendered Image 게시 유형(유형은 파일 확장자에 따라 다름)에 정의된 액션은 읽기 노드 만들기(Create Read Node)입니다. 이 액션을 클릭하여 Nuke 세션에 새 Read 노드를 만듭니다.Nuke 프로젝트 설정 출력 형식이 렌더링된 이미지와 일치하는지 확인합니다. 배경으로 사용할 균일 색상을 만들고 읽기 노드와 병합합니다. 합성을 볼 뷰어를 연결합니다.    합성에 만족하면 Flow Production Tracking &amp;gt; 파일 저장…(File Save…) 메뉴 액션을 사용하여 작업 파일을 저장합니다.다음으로, Nuke의 왼쪽 메뉴에 있는 Flow Production Tracking 로고를 클릭합니다. 해당 메뉴에서 Flow Production Tracking 인식 쓰기 노드 중 하나를 클릭합니다.    Flow Production Tracking Write Node 앱에서는 기본 제공 Nuke Write node의 맨 위에 현재 Flow Production Tracking 컨텍스트를 기반으로 출력 경로를 자동으로 평가하는 레이어를 제공합니다.    디스크로 이미지 프레임을 렌더링합니다. 이제 Nuke 세션을 게시하여 렌더링된 이미지와 작업 파일을 연결할 수 있습니다. 기본적으로 게시자는 렌더링된 프레임을 수집하고 플러그인을 연결하여 Flow Production Tracking로 프레임을 등록합니다. 두 번째 플러그인은 백그라운드에서 실행되는 리뷰 제출이라는 통합 방식으로 리뷰할 프레임을 업로드합니다. 이 앱은 Nuke를 사용하여 업로드되어 리뷰에 사용할 수 있는 Quicktime을 생성합니다.    또 다른 유용한 통합은 Quick Review 앱입니다. 이 앱은 Quicktime을 빠르게 생성하고 리뷰를 위해 Flow Production Tracking에 업로드하는 출력 노드입니다. 이 앱은 Flow Production Tracking Write Node 옆의 왼쪽 메뉴에서 찾을 수 있습니다.    빠른 리뷰 노드를 만든 다음 Upload 버튼을 클릭하여 디스크로 입력을 렌더링하고 Quicktime을 생성하고 리뷰를 위해 결과를 Flow Production Tracking에 업로드합니다. 프레임을 제출하기 전에 몇 가지 표준 옵션이 제공됩니다.    업로드된 Quicktime을 모두 보려면 Flow Production Tracking의 미디어(Media) 탭을 확인합니다.    Flow Production Tracking의 미디어 리뷰에 대한 자세한 정보는 공식 설명서를 참조하십시오.결론축하합니다. 모두 완료했습니다. 이 튜토리얼이 Flow Production Tracking 통합을 사용하여 고유한 커스텀 파이프라인을 빌드하는 시작점이 되었기를 바랍니다. 기본 통합을 확장하여 스튜디오의 특정 요구 사항을 충족하는 방법을 이해할 수 있어야 합니다.shotgun-dev Google 그룹에서 다른 스튜디오에서는 툴킷을 어떻게 사용하는지 질문하고 배울 수 있습니다. 최신 게시물을 보려면 등록하십시오.기본 통합에서 제공되지 않는 기능이나 워크플로우가 있으면 언제든 자체 앱을 작성할 수 있습니다. 첫 번째 앱 작성을 시작하려면 이 문서를 참조하십시오.언제나처럼 이 튜토리얼에 대한 추가 질문이나 Flow Production Tracking 또는 툴킷 플랫폼에 대한 일반적인 질문이 있으면 언제든지 커뮤니티에 문의하십시오.",
    "url": "/cb8926fc/",
    "relUrl": "/cb8926fc/"
  },
  "97": {
    "id": "97",
    "title": "Planning Your Setup",
    "content": "Planning Your SetupPick your optionsPick which features you want to activate  Media Isolation  Media Traffic Isolation  Media ReplicationAWS Account CreationBefore going further, you will require an AWS Account. If you don’t already have an AWS Account, create your AWS Account.Choose an AWS RegionChoose an AWS Region for your AWS S3 bucket and VPC. Which region to use? You should chose the a region that is the closest possible to your studio.If your company is located in different locations, consider enabling the media replication feature to reduce latency and improve performancePlan the VPC IP rangesPlan your AWS VPC and subnets IP ranges if you plan to use Media Traffic Isolation.IP Range Example            Region      VPC      Subnet 1      Subnet 2      Subnet 3                  ap-southeast-2      10.1.0.0/16      10.1.0.0/24      10.1.1.0/24      10.1.2.0/24      Plan how you will privately access your AWS VPCIf you plan to activate any of the Traffic Isolation feature, you will need a way to connect your AWS VPC and your network infrastructure. The main options are:  AWS Direct Connect  Other VPN solutionWe highly recommand you to leverage Direct Connect. Direct Connect guarantees the lowest latency possible to the Flow Production Tracking services, a consistent network experience, and allow you to leverage the optimization AWS is relying on to guarantee an optimal performance across the globe.Next StepWith your plan layed down, you are ready to start implementing the AWS building blocks that will allow you to activate the isolation features.See Media Isolation for activating the Media Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/7897b2e2/",
    "relUrl": "/7897b2e2/"
  },
  "98": {
    "id": "98",
    "title": "Private Link",
    "content": "Private LinkAWS PrivateLink is an AWS service that connects different AWS VPCs without going through the public internet.In conjunction with AWS Direct Connect, PrivateLink helps create a dedicated connection between your studio and Flow Production Tracking’s infrastructure.",
    "url": "/9da985a7/",
    "relUrl": "/9da985a7/"
  },
  "99": {
    "id": "99",
    "title": "urlopen 오류 SSL CERTIFICATE_VERIFY_FAILED 인증서 확인 실패(_ssl.c:726)",
    "content": "[ERROR publish_creation] &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;활용 사례Houdini 17.5에서 디지털 에셋을 위한 도구를 개발하는 동시에 빌드 툴킷 앱을 사용하여 게시된 파일을 등록하는 후크를 실행합니다.스크립트는 다음 코드를 실행합니다.    args = {        &quot;tk&quot;: self.parent.tank,        &quot;context&quot;: self.parent.engine.context,        &quot;path&quot;: esto['operator'],        &quot;name&quot;: os.path.basename(esto['operator']),        &quot;version_number&quot;: 6,        &quot;published_file_type&quot;: &quot;Library item&quot;,    }    print 'sgtk: ', sgtk.__file__    sg_publish = sgtk.util.register_publish(**args)게시된 파일은 Flow Production Tracking에 올바르게 등록되지만 다음과 같은 오류가 표시됩니다.---------------------------------------------------------------------------[ERROR publish_creation] &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;Traceback (most recent call last):  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank/util/shotgun/publish_creation.py&quot;, line 308, in register_publish    tk.shotgun.upload_thumbnail(published_file_entity_type, entity.get(&quot;id&quot;), no_thumb)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank_vendor/shotgun_api3/shotgun.py&quot;, line 2173, in upload_thumbnail    field_name=&quot;thumb_image&quot;, **kwargs)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank_vendor/shotgun_api3/shotgun.py&quot;, line 2263, in upload    tag_list, is_thumbnail)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank_vendor/shotgun_api3/shotgun.py&quot;, line 2383, in _upload_to_sg    result = self._send_form(url, params)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank_vendor/shotgun_api3/shotgun.py&quot;, line 3806, in _send_form    resp = opener.open(url, params)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 429, in open    response = self._open(req, data)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 447, in _open    '_open', req)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 407, in _call_chain    result = func(*args)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 1241, in https_open    context=self._context)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 1198, in do_open    raise URLError(err)URLError: &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;Traceback (most recent call last):  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/config/hooks/publish_digital_asset.py&quot;, line 66, in register_publishedfile    description='Alembic nodes.')  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank/log.py&quot;, line 503, in wrapper    response = func(*args, **kwargs)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank/util/shotgun/publish_creation.py&quot;, line 323, in register_publish    entity=entityShotgunPublishError: Unable to complete publishing because of the following error: &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;, although PublishedFile PIGS_libary_tool_hda_asasas_v017.hda (id: 114715) was created.---------------------------------------------------------------------------오류의 원인은 무엇입니까?cacert.pem 및 해당 위치를 가리키는 필수 환경 변수 SHOTGUN_API_CACERTS가 누락되었습니다.해결 방법cacert.pem 및 위치를 가리키는 환경 변수 SHOTGUN_API_CACERTS를 추가합니다.커뮤니티에서 전체 스레드를 참조하십시오.",
    "url": "/02a75bb2/",
    "relUrl": "/02a75bb2/"
  },
  "100": {
    "id": "100",
    "title": "Python 3 Porting Best Practices",
    "content": "Python 3 Porting Best PracticesWhy the move to Python 3?There are a few compelling reasons to make the leap to Python 3.  Perhaps the most dramatic is the Python 2 end of life, which occurred on January 1, 20201. With the sunsetting of Python 2, all support for Python 2 ceases, meaning that even new security vulnerabilities found in Python 2 will not be addressed.Things to Consider Before StartingWhen considering moving to Python 3, it’s good to look at the requirements and application of your codebase to set expectations.  Obviously, any host applications your code runs in will help drive this decision.  Knowing whether you need to support many different Python interpreter versions and, if so, which ones, will be important information as you decide on the porting process that makes sense for you.Next, take an audit of what libraries your code depends on.  If any of these libraries do not have Python 3 compatible versions, you’ll need to find an alternative library, or fork the library to provide compatibility yourself. Both of these options could potentially be costly decisions and are important to consider early on.  Additionally, even libraries that do offer Python 3 compatible versions may not be drop-in replacements, and some libraries choose to fork for Python 3 support rather than maintain compatibility for both Python 2 and 3 as a single source.  We’ll discuss this in more depth in the “Porting Options” section below.Finally, it’s worth noting that while it is possible to continue to support Python versions older than 2.5 and Python 3 simultaneously2, this will make your life much harder.  Since Python 2.5 is very old and not used in modern DCC versions, this guide will work under the assumption that Python 2.5 and earlier will not be targeted.  If you do need to support older versions of Python, a branching approach as described in the “Porting Options” section below may be your best option.What’s Different in Python 3Python 3 comes with some slight syntax changes, changes to builtin functions, new features, and small behavior changes.  There are many great guides that enumerate these specific changes and provide examples.  Rather than dive into specifics here, the goal of this guide will be to describe the porting process from a higher-level perspective, with a few small deep dives where compatibility may be more complicated than just matching syntax.Porting OptionsFor most of us, porting our code to only support Python 3 is not yet an option.  Many DCCs still require Python 2 support, and this is unlikely to change overnight.  This means that in the real world, it will be a necessity to be able to support both Python 2 and 3.There are two major approaches to supporting Python 2 and 3 simultaneously.  We’ll discuss both of them briefly:BranchingIn this approach, a new Python 3 compatible branch of your code is maintained in parallel with the current (Python 2 compatible) branch.  This has the advantage of letting you write cleaner, easier to read Python 3 code, and allows you to fully leverage new features without needing branching logic to maintain Python 2 support.  It also means that when the time comes to drop support for Python 2, you’ll be left with a cleaner, more modern starting point in your Python 3 branch.  The obvious downside here is that maintaining two branches can be unwieldy and mean more work, especially if the Python 3 and Python 2 code starts to diverge as the Python 3 branch can leverage new features that can significantly change how your code looks (e.g. asyncio.)Cross-CompatibilityIn this approach, a single branch is maintained that uses the subset of syntax and builtins that are compatible with both Python 2 and 3.  This allows for a graceful transition from Python 2 to 3 without maintaining multiple branches of your code.  There are a few popular libraries designed to help with this approach, and it’s a commonly-used solution to the problem of transition from Python 2 to 3.  In addition to the reduced complexity compared to maintaining multiple branches, this approach also means you don’t need to change your code distribution mechanisms or worry about using the correct (Python 2 or 3) version of your code at import time.The two most commonly used libraries for this approach are future and six.futureThe future module is probably the most popular choice for Python 2 + 3 compatibility.  It backports many Python 3 libraries to Python 2, and aims to allow you to move your codebase to a pure Python 3 syntax.  Because it backports modules and works by shadowing builtins, it is slightly more invasive than six.  Given the variety of DCCs and unknown client code in VFX environments, future may be too invasive and in an environment like this may pose a greater risk of causing problems down the road.  For this reason, we will focus on using six instead.sixThe six module does not attempt to backport Python 3 modules, or allow you to write pure Python 3 syntax, but instead unifies renamed modules and changed interfaces inside the six.moves namespace.  This allows you to update imports and use six’s helper functions to write code that is both Python 2 and 3 compatible.Testing and LintingBlackThe porting process requires an examination of the entire python codebase, and introduces a fair amount of noise in the revision control history.  This makes it a good opportunity to take care of any other housekeeping that may have similar impacts.  We took this opportunity to apply black to our code.  This is not strictly necessary or directly related to Python 3 compatibility (unless your code is mixing tabs and spaces3), but given the reasons identified above, we decided this was a good opportunity to modernize our code formatting.TestsTest coverage was incredibly valuable during the porting process since it allowed us to quickly find problems that still needed to be addressed, and verify that large sections of code were working as expected without as much manual intervention.  In many cases, we found it worthwhile to increase test coverage as part of the porting process to ensure that Python 2/3 specific cases (e.g. unicode handling) were being addressed correctly.  This being said, we recognize that in many cases the realities of production mean that test coverage is sparse, and that adding tests to code that has little or no coverage may be too time consuming to be worthwhile as part of a project like adding Python 3 compatibility.  For those in this situation, there may still be some value in using coverage measurement tools and some more basic testing code during the porting process, as these tools can provide fast feedback on what code has been covered and what may still need attention.Porting ProcedureAutomated Porting using modernizepython-modernize is a tool that can be very useful for automatically generating Python 3 compatible code.  modernize usually produces runnable code with minimal human intervention, and because of this can be a great tool to get most of the way to Python 3 compatibility very quickly.  Of course, as an automated tool it does come with the drawbacks one would expect.  It frequently produces less readable and less efficient code (e.g. wrapping all iterables in a list() instantiation.)  In some cases, modernize can even introduce regressions that might be difficult to spot.  There are also some areas where you’ll find modernize is not much help at all, like when dealing with bytes and text.  Since these decisions require a bit more understanding of context, you’ll likely have to spend some time manually addressing the handling of strings in your code even if you do rely on modernize for the bulk of the compatibility work.The alternative to using an automated tool like modernize, of course, is to go through code manually to fix incompatibilities.  This can be tedious, but in our experience generally produces nicer looking code.For our process we went with a hybrid approach, using modernize with a select set of fixers, and doing some of the work manually.  We also broke the process into two stages; first doing a pure syntax compatibility and code formatting pass, and then doing a more manual Python 3 port.  Our process was as follows:In a branch:  Run modernize with the except, numliterals, and print fixers  python-modernize --no-diffs --nobackups -f except -f numliterals -f print -w .  Make sure the resulting code is Python 3 syntax compliant by compiling it with Python 3.  The goal here is not to have your code work in Python 3, but to ensure that the basic formatting and automatable syntax fixes are in place.  If your code does not successfully compile after this step, you’ll need to find the source of the problem and either add additional fixers to the above step, or manually fix the incompatibilities.  Ensure that any changes you make manually at this stage are syntax only and will not change the behavior of the code in Python 2.  python3 -m compileall .  Run black on the resulting codeThis branch should not change any behavior or functionality, and should not introduce regressions, so it is considered safe to merge at this point.  This helps keep the history easier to read, and means that the Python 3 compatibility branch and master will diverge less during the porting process, making for an easier merge once the work is done.In a new branch, the actual Python 3 port can now begin:  Search for method names that may require some work to deal with list/view/iterator differences between Python 2 and 3.  In Python 3 .values(), .items() and .keys() return an iterator or view instead of a list, so in cases where these methods are called the code should be able to handle both iterator and list returns, otherwise the result will need to be cast to a list.  Similarly, the filter() method returned a list in Python 2, but now returns an iterator.  Change calls from dict.iteritems() and dict.itervalues() to dict.items() and dict.values() if the returned collection won’t be too big.  In these cases, the resulting cleaner code at the cost of a slight performance hit in Python 2 is preferable.  In cases where the collection might contain thousands of items or more, use six.iteritems and six.itervalues instead.  If dict.iterkeys() was used, simply replace the code with something like for key in dictionary:, since this will iterate on keys in both Python versions.  Watch out that returning an iterator in Python 3 doesn’t change the semantics of the code however. If a method used to return dict.values(), you’ll need to wrap the call inside list(dict.values()) to ensure the method always returns a list in all versions on Python.  Search for str, basestring, unicode, open, pickle, encode, decode since these will be areas of the code that likely require some attention to handling of bytes and strings.  We used the coercion helper methods provided by six (e.g. ensure_string) where needed.  See the sections on bytes and pickle below.  Unless generating a super long range, xrange can be changed to range for simplicity, otherwise six.range can be used.  After committing the manual changes from above, run a full python-modernize and go through the diff manually.  Many of the resulting changes will be unwanted, as discussed above, however this is a good way to catch potential problems that were overlooked in the manual porting process.  python-modernize --no-diffs --nobackups -f default . -w &amp;amp;&amp;amp; git diff HEAD  Test the resulting code to find the remaining problems.  There are some incompatibilities that don’t have fixers (this is a good resource to look at to get an idea of what those changes entail), and it’s easy to overlook text/binary problems during the port process.We chose to use this process because we believe it allowed us to maintain a standard of more readable, efficient code than would have been automatically generated by using modernize on its own.GotchasBytes WoesPython 3 introduces a strict separation between binary and textual data.  This is a long-called-for addition that most see as an improvement, but for Python 2 + 3 compatible code it adds some headaches.  Since Python 2 does not enforce this separation, and Python 3 introduces new types to do so, code that deals with data and strings will likely need some attention.  For the most part this just means making sure that strings are encoded / decoded properly, for which the six.ensure_binary and six.ensure_text helper functions are invaluable.  See the examples below for common applications of these methods.  In some cases, however, this can be more complicated.  For an example of this, see the pickle section below.# base64.encodestring expects str in Python 2, and bytes in Python 3.# By using six.ensure_binary() we can ensure that the we always# pass it the correct type.base64.encodestring(six.ensure_binary(some_string))# In this example (from tk-multi-publish2), we get a list of files# from a QDropEvent in Pyside.  The  filenames are unicode, however# they're being passed to code that expects str.# In Python 2, this had looked like:if isinstance(category_type, unicode):                    category_type = category_type.encode(&quot;utf-8&quot;)# Using six, we can get the same behavior in Python 2, and ensure# compatibility with Python 3 with:category_type = six.ensure_str(category_type)The pickle PicklePickle in Python 3 returns a bytes object from dumps(), where previously it had returned a str.  Additionally, the output of pickle.dumps() in Python 3 contains  x00 bytes, which cannot be decoded. This is not a  problem if the data is being stored in a file, but if the pickled data is being stored in, for example, an environment variable, this can become problematic.  As a workaround, we found that by forcing pickle to use protocol 0, no 0 bytes were included, and the output is once again decodable.  This comes at the cost of the slightly less efficient and fewer-featured older protocol.# Dumping data to a pickle string:DUMP_KWARGS = {&quot;protocol&quot;: 0}# Force pickle protocol 0, since this is a non-binary pickle protocol.# See https://docs.python.org/2/library/pickle.html#pickle.HIGHEST_PROTOCOL# Decode the result to a str before returning.pickled_data = six.ensure_str(cPickle.dumps(data, **DUMP_KWARGS))# Loading data from a pickle string:LOAD_KWARGS = {&quot;encoding&quot;: &quot;bytes&quot;} if six.PY3 else {}data = cPickle.loads(six.ensure_binary(data), **LOAD_KWARGS)Regex  W flagIn Python 3, regular expression metacharacters match unicode characters where in Python 2 they do not.  To reproduce the previous behavior, Python 3 introduces a new re.ASCII flag, which does not exist in Python 2.  To maintain consistent behavior across Python 2 and 3, we wrapped re functions to include this flag across the board in Python 3.Dictionary OrderPrior to Python 3.7, dictionary order was not guaranteed.  As of Python 3.7, insertion order is preserved in dictionaries[11].  In practice, on Python 2.7 dictionary order was random but deterministic (though this was not guaranteed), on some versions of Python (including some version of Python 3) dictionary order is non-deterministic[10].  While code prior to Python 3.7 should not rely on dictionary key order being deterministic, there were instances where this assumption was made in our unit tests.  These tests broke in Python 3.7, and needed to be updated to ensure that dictionary key order was not relied upon.sys.platformIn Python 3.3+ sys.platform on Linux returns linux, where previously it had returned “linux” appended with the kernel major version (i.e. linux2).  Of course when testing for Linux it is easy enough to check sys.platform.startswith('linux').  We chose to centralize these tests and platform “normalization”, and introduced functions sgtk.util.is_windows(), sgtk.util.is_linux(), sgtk.util.is_macos(), as well as a sgsix.platform constant that contains a normalized platform string that can be used for consistent mapping to platform names across python versions.Notes            https://www.python.org/doc/sunset-python-2/ &amp;#8617;              https://docs.python.org/3/howto/pyporting.html#drop-support-for-python-2-6-and-older &amp;#8617;              https://portingguide.readthedocs.io/en/latest/syntax.html#tabs-and-spaces &amp;#8617;      ",
    "url": "/5583eab1/",
    "relUrl": "/5583eab1/"
  },
  "101": {
    "id": "101",
    "title": "Python API 모범 사례",
    "content": "Python API 모범 사례다음은 Flow Production Tracking Python API 사용 시의 모범 사례 목록입니다.성능  스크립트에 필요하지 않은 필드를 요청하지 않습니다. 추가 필드를 포함하면 요청에 불필요한 오버헤드가 추가될 수 있습니다.  필터는 최대한 구체적으로 만듭니다. 가능하면 결과를 얻은 후에 분석하는 것보다 API 쿼리에서 필터링하는 것이 좋습니다.  정확한 일치 필터는 부분 일치 필터보다 성능이 우수합니다. 예를 들어 “포함(contains)”보다 “일치함(is)”을 사용하는 것이 더 좋습니다.제어 및 디버깅  스크립트에는 별도의 키를 사용하므로 모든 도구에 대해 고유한 키를 사용합니다. 이는 디버깅에 매우 중요합니다.  모든 스크립트에는 소유자 또는 관리자(Admin)가 있어야 하며 관리자(Admin) 메뉴에서 스크립트(Scripts) 페이지의 정보는 최신 상태여야 합니다.  API 사용자용 읽기 전용 권한 그룹을 만드는 것이 좋습니다. 많은 스크립트는 읽기 액세스 권한만 필요하므로 실수로 변경되는 경우를 제한할 수 있습니다.  사용 중인 키를 트래킹하여 이전 스크립트를 제거할 수 있습니다. 이 작업을 쉽게 하기 위해 일부 스튜디오는 API 래퍼로 감사 정보를 스크립팅합니다.  Flow Production Tracking의 각 필드 이름은 UI에서 사용되는 표시 이름(반드시 고유하지는 않음)과 API에서 사용되는 내부 필드 이름, 두 가지가 있습니다. 표시 이름은 언제든지 변경할 수 있기 때문에 표시 이름에서 필드 이름을 안정적으로 예측할 수 없습니다. 관리자(Admin) 메뉴의 필드 옵션으로 이동하여 필드 이름을 보거나 https://developer.shotgridsoftware.com/python-api/reference.html?%20read#working-with-the-shotgun-schema에서 설명한 대로 schema_read(), schema_field_read(), schema_entity_read() methods를 사용할 수 있습니다.디자인  큰 스튜디오의 경우 특히 API 격리 레이어(래퍼)를 사용하는 것이 좋습니다. 이렇게 하면 Flow Production Tracking API가 변경되지 않도록 도구가 격리됩니다. 또한 API 자체를 수정할 필요 없이 API 액세스를 제어하고 디버깅을 관리하고 감사를 추적할 수 있다는 것을 의미합니다.  최신 버전의 API를 사용합니다. 최신 버전에는 버그 수정 및 성능 향상이 포함됩니다.  스크립트가 실행되는 위치를 알고 있어야 합니다. Flow Production Tracking에 동일한 정보를 분당 1000번 호출하는 렌더 팜에서 실행되는 스크립트는 사이트 성능에 영향을 줄 수 있습니다. 이와 같은 경우 불필요하게 반복되는 호출을 줄이기 위해 읽기 전용 캐싱 레이어를 구현하는 것이 좋습니다.  스크립트의 이벤트 생성을 해제할 수 있습니다. 이는 나중에 트래킹할 필요가 없는 이벤트를 자주 실행하는 스크립트에 가장 유용합니다. 매우 자주 실행되는 스크립트의 경우 이벤트 로그가 매우 커질 수 있으므로 이 방법을 사용하는 것이 좋습니다.",
    "url": "/09b77cf4/",
    "relUrl": "/09b77cf4/"
  },
  "102": {
    "id": "102",
    "title": "API 스크립트 만들기 및 관리",
    "content": "API 스크립트 만들기 및 관리아래 단계에 따라 새 스크립트를 만듭니다.  관리자(Admin) 메뉴로 이동하여 “스크립트(Scripts)”를 선택합니다.   ”+ 스크립트(+ Script)” 버튼을 사용하여 새 스크립트를 만듭니다.      응용프로그램 키 값을 확인합니다. Flow Production Tracking에 연결하려면 이 값이 필요합니다.           참고: API 키는 암호처럼 처리되고 생성된 후에는 Flow Production Tracking 웹 앱 또는 API를 통해 다시 볼 수 없습니다. 계속하기 전에 키를 복사해야 합니다.        이제 스크립트 키를 사용하여 Flow Production Tracking에 연결할 수 있습니다. 스크립트를 사용하여 Flow Production Tracking에 연결하는 방법에 대한 자세한 정보는 API 설명서에 있는 “Flow Production Tracking 메서드”를 참조하십시오.  팁: 어떤 이유로 스크립트의 응용프로그램 키를 재설정해야 하는 경우 이를 수행하려면 새 Flow Production Tracking 스크립트 엔티티를 만들어야 합니다. 먼저 기존 스크립트의 이름을 변경(예: “[My Script]—OLD”)한 다음 이를 삭제합니다. 새 스크립트를 만듭니다. 이전 스크립트의 이름을 변경해야 하는 이유는 Flow Production Tracking 소프트웨어가 각 스크립트에 대해 고유한 이름을 요구하기 때문입니다.새 스크립트를 설정해야 하는 경우스크립트 액션은 기록될 수 있습니다. 개별 스크립트 키를 보다 세밀하게 사용할수록 디버깅용으로 변경되는 스크립트를 쉽게 트래킹할 수 있습니다. 별도의 스크립트를 사용하면 Flow Production Tracking사이트의 변경에 영향을 받는 스크립트 및 스크립트 관리자를 트래킹하기 좋습니다.",
    "url": "/99105475/",
    "relUrl": "/99105475/"
  },
  "103": {
    "id": "103",
    "title": "Python API",
    "content": "Python API여기에서는 Python API에 대한 참조 문서를 찾을 수 있습니다.",
    "url": "/682204e9/",
    "relUrl": "/682204e9/"
  },
  "104": {
    "id": "104",
    "title": "API 개요",
    "content": "API 개요참고: Flow Production Tracking API에 대한 자세한 내용은 API 설명서를 참조하십시오.Flow Production Tracking Python API(응용프로그램 인터페이스)를 통해 사용자는 Flow Production Tracking 소프트웨어와 자신의 도구를 쉽게 통합할 수 있습니다. 이를 통해 자동화된 프로세스를 만들고, 많은 타사 소프트웨어 패키지와 통합하며, 스튜디오 내 기존 도구와 통신할 수 있습니다. 스튜디오마다 요구 사항이 매우 다르기 때문에 Flow Production Tracking API는 강력한 로우 레벨 기능을 제공하며 대부분의 비즈니스 로직을 유지합니다.API는 미디어 및 엔터테인먼트 업계 전반에 널리 사용되는 공통 프로그래밍 언어인 Python을 사용하여 빌드됩니다. Flow Production Tracking Python API 사용은 Flow Production Tracking 사이트에서 무료로 이용할 수 있습니다.API는 CRUD 패턴을 따르므로 스크립트가 단일 엔티티 유형에 대한 만들기, 읽기, 업데이트 및 삭제 액션을 실행할 수 있습니다. 많은 작업에는 필터, 반환할 열 및 정렬 결과를 정의하는 기능이 포함됩니다.Python API 개요 동영상을 사용하여 환경 설정스크립트 키API를 통해 Flow Production Tracking 서버와 통신하기 위해 사용자의 자격 증명을 제공하거나 스크립트 키를 사용해 서버로 스크립트를 인증할 수 있습니다. 관리자(Admin) 메뉴에 나열된 스크립트(Scripts) 페이지에서 새 스크립트 키를 생성할 수 있습니다.팁: 스크립트를 별도로 등록하여 각각에 대해 개별 API 키를 생성합니다. 이렇게 하면 이벤트 로그에서 각 스크립트와 스크립트가 수행하는 액션을 훨씬 정확하게 모니터링할 수 있습니다.개인 액세스 토큰(PAT)Flow Production Tracking 사이트와 통신하려면 스크립트 키 외에 개인 액세스 토큰(PAT)도 설정해야 합니다. 다음 동영상 문서를 참조하여 설정해 보십시오.  개인 액세스 토큰(PAT) 구성일반적인 첫 번째 프로젝트https://github.com/shotgunsoftware/python-api/에서 API를 다운로드할 수 있습니다. 다음은 몇 가지 일반적인 첫 번째 프로젝트입니다.  버전 만들기 및 샷에 링크. 리뷰를 위해 새 렌더의 제출을 자동화할 수 있습니다.  썸네일 업로드. 사이트의 모든 항목은 수동으로 추가하지 않고도 최신 썸네일을 보유할 수 있습니다.  SVN과 같은 코드 리포지토리와 Flow Production Tracking 통합. 프로젝트에 Flow Production Tracking 소프트웨어를 활용하여 모든 소프트웨어 개발을 관리합니다.API를 사용하여 수행할 수 없는 작업  권한 규칙 액세스 또는 변경(보안상의 이유)  페이지 설정 읽기 또는 변경  개별 페이지 또는 위젯에 대한 필터 또는 쿼리 설정 액세스  UI와 상호 작용  조건부 형식 지정 규칙 추가, 편집 또는 제거  쿼리 필드 만들기 또는 편집AMI(액션 메뉴 항목)AMI를 통해 Flow Production Tracking 인터페이스 내에서 쉽게 시작할 수 있는 스크립트를 작성할 수 있습니다. AMI는 데이터 행을 마우스 오른쪽 버튼으로 클릭할 때 나타나는 상황에 맞는 메뉴에 표시되는 커스터마이즈 가능한 옵션입니다. 해당 옵션을 클릭하면 상황에 맞는 데이터 덤프를 웹 서버 또는 커스텀 브라우저 프로토콜 처리기로 보내 커스텀 비즈니스 로직을 실행할 수 있습니다.다른 엔티티에 다른 AMI를 설정할 수 있으며 프로젝트별 또는 권한 그룹별로 액세스를 제한할 수 있습니다.이벤트 트리거 데몬ShotGrid에서 액션이 수행될 때마다(사용자 또는 API 스크립트에 의해) 이벤트가 생성됩니다. 이벤트 데몬은 해당 이벤트 스트림을 모니터링한 다음 사용자가 정의한 조건에 따라 특정 API 스크립트를 실행할 수 있습니다. 다음과 같은 예를 들 수 있습니다.  업스트림 태스크 상태에 따라 다운스트림 태스크 상태를 자동으로 변경합니다.  값이 변경되면 관련 컷 기간 필드를 다시 계산합니다.  샷이 특정 상태로 설정될 때 파일 패키징 및 전송 작업을 수행합니다.추가 정보Flow Production Tracking API에 대한 자세한 정보는 다음 문서를 참조하십시오.  GitHub에서 Flow Production Tracking API 다운로드  Flow Production Tracking API 문서  Flow Production Tracking-dev list(공용)  Flow Production Tracking 이벤트 데몬 샘플 코드  이벤트 구동 트리거 작성  Flow Production Tracking 스키마  API 모범 사례기여 및 협업Flow Production Tracking 소프트웨어로 세계와 공유하고 싶은 놀라운 도구를 만드셨다구요? 훌륭합니다. 서로 공유하고 협업하기를 원하는 활발한 개발자 커뮤니티가 있습니다. 참여하려면 다음을 수행하십시오.  Flow Production Tracking 커뮤니티에 가입합니다.  GitHub에 코드를 게시합니다. 코드는 특정 파이프라인에 맞게 작성되지 않고 잘 기술되어야 하며 .txt 또는 .mdk 형식의 읽어보기가 있어야 합니다.  dev 목록에 링크와 설명을 게시합니다. Dev 커뮤니티 및 Flow Production Tracking 개발자들이 검토한 후 피드백을 제공하고 활발하게 의견을 남길 것입니다.우리는 고객이 만든 많은 도구 및 통합을 통해 끊임없이 놀라운 영감을 얻습니다. 여러분도 할 수 있습니다.",
    "url": "/b6636515/",
    "relUrl": "/b6636515/"
  },
  "105": {
    "id": "105",
    "title": "API 사용자 권한 그룹",
    "content": "API 사용자 권한 그룹API 사용자를 위한 별도의 권한 그룹을 만들어 작업자와 마찬가지로 스크립트 및 키에 다른 권한 레벨을 지정할 수 있습니다.API 사용자 페이지 액세스관리자(Admin) 메뉴로 이동하여 권한 - 스크립트(Permissions - Scripts)를 선택합니다.사용법은 을 참조하십시오.API 사용자 권한 그룹 사용 방법초기 API 관리자(Admin) 이외의 API 권한 그룹을 만든 후에는 API 스크립트에 사용할 수 있습니다.  관리자(Admin) 메뉴에서 “스크립트(Scripts)”를 선택합니다.  권한 그룹(Permission Group) 열을 표시하고 적절한 권한 그룹을 선택합니다.예그렇다면 이 권한 그룹을 사용하는 이유는 무엇일까요? 많은 잠재적인 용도가 있지만 다음과 같은 경우에 사용할 수 있습니다.예 1: 전체 관리자(Admin) 권한이 없는 스튜디오의 누군가에게 API 키를 제공할 수 있습니다.예 2: 읽기 전용 API 키를 파트너 스튜디오에 제공하여 내  데이터베이스에서 파트너 스튜디오의  데이터베이스로 단방향 동기화를 수행하고 제한된 엔티티 세트만 노출할 수 있습니다.예 3: 프로젝트당 API 스크립트를 제한할 수 있습니다.  관리자(Admin) 메뉴를 통해 권한 - 스크립트(Permissions - Scripts) 페이지로 이동하여 새 역할을 만듭니다. “할당된 프로젝트만 보기(See Assigned Projects Only)” 고급 권한이 활성화되어 있어야 합니다. 필요한 다른 권한을 조정할 수도 있습니다(예: 특정 엔티티/필드에 대해 읽기 액세스 권한만 필요한 경우).  관리자(Admin) 메뉴를 통해 스크립트(Scripts) 페이지로 이동합니다. “프로젝트(Projects)” 필드를 노출합니다. 여기서 프로젝트를 입력하여 스크립트 범위를 제한할 수 있습니다.  “권한 그룹(Permission Group)” 필드를 통해 1단계에서 만든 새 프로젝트에 해당 스크립트 권한을 할당해야 합니다.",
    "url": "/bbae2ca7/",
    "relUrl": "/bbae2ca7/"
  },
  "106": {
    "id": "106",
    "title": "Flow Production Tracking 데스크톱을 사용하여 툴킷 프로젝트를 다시 설정하려면 어떻게 해야 합니까?",
    "content": "Flow Production Tracking 데스크톱을 사용하여 툴킷 프로젝트를 다시 설정하려면 어떻게 해야 합니까?프로젝트에 대한 툴킷 구성을 이미 설정하고 새로 시작해야 하는 경우 Flow Production Tracking 데스크톱의 고급 설정 마법사는 이전의 설정 구성을 제거하기 전에는 프로젝트를 다시 설정할 수 없습니다.수동으로 해당 설정을 제거하는 단계는 다음과 같습니다.  Flow Production Tracking에서 프로젝트에 연결된 모든 PipelineConfiguration 엔티티를 삭제합니다.  Flow Production Tracking의 Project 엔티티에서 Tank Name 필드를 빈 값으로 설정합니다.  디스크에서 해당하는 파이프라인 구성 디렉토리를 모두 제거합니다.  Flow Production Tracking 데스크톱에서 설정할 프로젝트를 선택합니다.  프로젝트를 보고 있던 중이라면 프로젝트 목록 보기로 이동했다가 다시 프로젝트로 돌아옵니다.  이제 프로젝트 설정 프로세스를 다시 실행할 수 있습니다.대체 방법명령줄을 사용하여 tank setup_project 명령으로 프로젝트를 설정한 경우 명령 끝에 --force 인자를 추가할 수 있습니다. 이렇게 하면 위에 나열된 단계를 수동으로 수행하지 않고도 이전에 설정한 프로젝트를 설정할 수 있습니다.tank setup_project --force&quot;",
    "url": "/fb5544b1/",
    "relUrl": "/fb5544b1/"
  },
  "107": {
    "id": "107",
    "title": "Client Responsibilities",
    "content": "Client ResponsibilitiesBelow, we have outlined setup responsibilities between Autodesk and You.Isolation SetupYou are entirely responsible for the validity, security, and execution of the Isolation setup in Your AWS Account. Autodesk should not, under any circumstances, be granted access to Your AWS environment.Autodesk is available during the process for assistance, but the configuration of Isolation features in Your AWS Account is to be executed by You on Your own.Isolation feature set activation requires the Flow Production Tracking Support team’s intervention. Activation delays are to be expected and will depend on demand. You understand that an estimated period of 2-8 weeks is usually required to complete the setup necessary to implement the isolation feature set. The setup time is highly dependent on your cooperation, so please plan to dedicate resources for the setup before beginning the onboarding process.Autodesk does not guarantee any timeline for setup completion.Onboarding            Type      Description / Agreement      Responsibility      Available for Assistance                  AWS Knowledge      Acquiring the AWS-specific knowledge required to set up the isolation features.      You      N/A              S3      Setting up the S3 Bucket that will host Your media Securing access to the S3 Bucket. Additional high-availability measures (versioning, bucket replication, etc.)      You      Flow Production Tracking and *AWS              Closed VPC      Setting up DirectConnect/VPN, etc. to allow closed access to the VPC. Securing the VPC by putting the correct Security Groups in place.      You      *AWS              Media Isolation      Creating the S3 end-points. Deploying the S3 Proxy.      You      Flow Production Tracking and *AWS              Traffic Isolation      Creating VPCs. Creating Subnets.      You      Flow Production Tracking              Monitoring and Reliability      Maintaining uptime up to Autodesk standards. High availability and redundancy of Cloud Services. Metadata and database resiliency and redundancy. Maintaining Recovery Point Objective (RPO) for metadata and database.      Flow Production Tracking      N/A              Service Level Objective      Maintaining Flow Production Tracking target RPO and RTO (See Flow Production Tracking Security White Paper for more details).      Flow Production Tracking      N/A              Security and Governance      Maintaining the Flow Production Tracking Cloud Services that Isolation clients are interfacing with, so that they are meeting expectations in terms of security, vulnerability patching, scanning, auditing, etc. (See Flow Production Tracking Security White Paper for more details).      Flow Production Tracking      N/A      *You are solely responsible to seek or obtain any support services AWS may provide under any existing relationship between You and AWS. Autodesk teams are not parties to Your relationship with AWS and therefore not responsible or liable for any services or lack thereof provided by AWS to You.",
    "url": "/2f59bc69/",
    "relUrl": "/2f59bc69/"
  },
  "108": {
    "id": "108",
    "title": "예외 리뷰 제출에 실패했습니다. 리뷰 관련 시퀀스를 렌더링하고 제출할 수 없습니다.",
    "content": "예외: 리뷰 제출에 실패했습니다. 리뷰 관련 시퀀스를 렌더링하고 제출할 수 없습니다.활용 사례:Nuke에서 ‘게시를 위해 제출’이 작동하지 않았습니다.질문 1:상속 스트림을 찾는 가장 좋은 방법은 무엇입니까? ‘HookBaseClass’까지는 찾았지만 제대로 되지 않았습니다.현재 문제는 Nuke에서 리뷰를 위해 제출하는 것입니다.Nuke의 SG 게시 GUI에서 다음 오류가 발생합니다.Traceback (most recent call last):  File &quot;C: Users STEVE AppData Roaming Shotgun bundle_cache app_store tk-multi-publish2 v2.4.1 python tk_multi_publish2 api plugins publish_plugin_instance.py&quot;, line 282, in _handle_plugin_error    yield  File &quot;C: Users STEVE AppData Roaming Shotgun bundle_cache app_store tk-multi-publish2 v2.4.1 python tk_multi_publish2 api plugins publish_plugin_instance.py&quot;, line 198, in run_publish    self._hook_instance.publish(settings, item)  File &quot;C: Users STEVE AppData Roaming Shotgun bundle_cache app_store tk-nuke v0.12.5 hooks tk-multi-publish2 basic submit_for_review.py&quot;, line 272, in publish    raise Exception(&quot;Review submission failed. Could not render and &quot;Exception: Review submission failed. Could not render and submit the review associated sequence.다음 예외도 표시됩니다.'sg_publish_data' was not found in the item's properties. Review Submission for 'path/to/sequences/AB/AB_001/comp/work/images/AB_001_comp_v002_output/AB_001_comp_v002_output.%04d.jpg' failed. This property must be set by a publish plugin that has run before this one.‘publish_plugin_instance.py’에서 다음을 찾을 수 있습니다._handle_plugin_error    yieldrun_publish    self._hook_instance.publish(settings, item)이러한 파일은 로컬 Appdata 폴더에서는 찾을 수 있지만 기본 설치에서는 찾을 수 없으므로 이 문제를 해결하려면 ‘submit_for_review.py’를 찾아야 한다고 생각됩니다.이 파일에서 상속 체인 ‘HookBaseClass’ 상위 계층의 항목에 대한 설정 및 정보를 확인할 수 있습니다.‘sg_publish_data’가 ‘submit_for_review.py’에 설정되어 있는 위치를 찾습니다. 225행은 다음과 같습니다. sg_publish_data = item.properties.get(&quot;sg_publish_data&quot;)질문 2그렇다면 업스트림 ‘item.properties’는 어디에 설정되어 있습니까? nuke collector.py라고 짐작되지만 ‘sg_publish_data’가 없고 ‘HookBaseClass’의 하위이기도 합니다.해결 방법간단한 답변:커스텀 코드를 추가하지 않았거나 구성을 너무 많이 수정한 경우 리뷰를 위해 제출하는 항목에 대해 Publish to Flow Production Tracking를 선택했는지 확인해야 합니다.자세한 답변:먼저 여기에 게시자 API에 대한 설명서가 있습니다. 이 문제를 해결하는 데 관련된 대부분의 개념이 여기에 설명되어 있습니다. 하지만 구체적인 문제에 대한 분석 내용은 아래와 같습니다. 이러한 과정을 거치는 것이 향후 문제를 해결하는 데도 도움이 될 것입니다.위 스크린샷의 ShorgunWrite1 항목 아래에 두 개의 plugins이 있습니다. 이러한 플러그인은 구성에 정의된 플러그인에 해당합니다.이러한 플러그인은 순서대로 실행되며 메모리의 동일한 항목에 대해 작동합니다. 문제의 원인을 파악하기 위해 이 두 플러그인의 코드를 살펴보십시오. hook 설정을 보면 이러한 항목이 있는 위치를 확인할 수 있습니다.tk-multi-publish2에 대한 설정을 보고 있으므로 첫 번째 플러그인의 경우 {self}는 tk-multi-publish2를 나타냅니다. 따라서 다음과 같습니다.{self}/publish_file.py다음과 같이 tk-multi-publish2 앱 폴더에서 찾을 수 있습니다.파일 시스템에 앱이 있는 위치는 app_locations.yml이 구성된 방식에 따라 달라지지만 아무 것도 변경하지 않은 경우 번들 캐시 폴더에서 앱을 찾을 수 있습니다. 필요한 경우 캐시 위치를 찾는 방법을 참조하십시오.두 번째 플러그인의 경우 후크 경로는 다음과 같습니다.{engine}/tk-multi-publish2/basic/submit_for_review.pyNuke에서 tk-nuke 엔진을 실행 중이므로 이 게시 후크를 찾으려면 다시 번들 캐시에서 tk-nuke를 확인해야 합니다.이제 코드를 찾을 위치를 알았으므로 첫 번째 플러그인이 두 번째 플러그인에 존재하는 것으로 예상되는 값을 설정함을 알 수 있습니다.이 두 플러그인의 조합은 게시되는 항목을 리뷰하기 위해 제출하는 플러그인이며 변경되지 않습니다. 따라서 워크플로우는 먼저 소스 파일을 게시한 다음 리뷰를 위해 이 파일에서 SG 버전을 만드는 것입니다. 해당 버전은 게시에도 링크됩니다. 첫 번째 플러그인은 파일을 게시하고, 두 번째 게시가 사용할 수 있도록 해당 정보를 항목에 저장합니다.상속에 대해 언급하셨으므로 이에 대해서도 명확히 밝히고 싶습니다. 설명서에서 언급하는 내용은 Python 상속이 아닌 구성에 의해 구동되는 후크 상속을 의미하는 것 같습니다.Python 파일에서 모든 후크는 HookBaseClass에서 상속됩니다. 그러나 구성의 후크 메커니즘을 통해 기본적으로 이러한 기본 후크를 같이 처리하고 결합하여 코드를 재사용하는 동안 필요한 모든 기능을 얻을 수 있습니다. tk-multi-publish2 구성에서 이에 대한 예를 확인할 수 있습니다.settings.tk-multi-publish2.nuke.shot_step:  collector: &quot;{self}/collector.py:{engine}/tk-multi-publish2/basic/collector.py&quot;여기에 정의된 컬렉터는 Python 파일에 없습니다. 실제로 tk-multi-publish2의 collector.py와 tk-nuke의 collector.py가 조합된 것입니다.빠른 해결 방법으로 충분하지 않고 이러한 후크를 수정해야 하는 경우 게시 워크플로우 커스터마이즈 동영상을 확인하십시오. 시작하는 데 도움이 될 것입니다.커뮤니티에서 전체 스레드를 참조하십시오.",
    "url": "/1d15d7ad/",
    "relUrl": "/1d15d7ad/"
  },
  "109": {
    "id": "109",
    "title": "리뷰",
    "content": "리뷰RV의 수상 경력에 빛나는 디지털 리뷰 도구 제품군을 최대한 활용하는 방법을 알아보고 협업 도구 및 심도 깊은 통합 기능을 사용하여 디지털 미디어를 재생, 비교 및 변환할 수 있습니다.노드 그래프, 커스텀 셰이더, 이벤트 처리 및 네트워킹에 대해 완전히 이해할 수 있도록 RV의 참조 매뉴얼을 꼼꼼히 살펴보십시오.RV-SDI 매뉴얼에서 NVIDIA SDI 동영상 장치를 프리젠테이션 모드 장치로 구현하는 방법을 알아보십시오.Maya, Nuke 및 Flow Production Tracking를 사용한 원활한 워크플로우를 위해 통합 패키지를 살펴보십시오.",
    "url": "/61e62b21/",
    "relUrl": "/61e62b21/"
  },
  "110": {
    "id": "110",
    "title": "경로에 대한 행 ID를 확인할 수 없습니다!",
    "content": "경로에 대한 행 ID를 확인할 수 없습니다!관련 오류 메시지:  경로에 대한 행 ID를 확인할 수 없습니다!  데이터베이스 동시성 문제: &amp;lt;PATH&amp;gt; 경로가 Flow Production Tracking 엔티티 &amp;lt;ENTITY&amp;gt;와 이미 연결되어 있습니다.예시:툴킷 사용자가 폴더를 만들 때 “경로에 대한 행 ID를 확인할 수 없습니다!” 라는 오류가 표시됩니다.일반적으로 이 오류는 FileSystemLocation 엔티티를 만들지만 경우에 따라 중복 항목이 생성되어 전체 호스트 문제를 일으킬 수 있습니다.전체 오류는 다음과 같습니다.Creating folders, stand by...ERROR: Could not resolve row id for path! Please contact support! trying toresolve path '  server nas_production CLICK 00_CG scenes Animation 01 001'.Source data set: [{'path_cache_row_id': 8711, 'path':'    server  NAS_Production  CLICK  00_CG  scenes  Animation  01  001','metadata': {'type': 'ShotGrid_entity', 'name': 'sg_scenenum', 'filters':[{'path': 'sg_sequence', 'values': ['$sequence'], 'relation': 'is'}],'entity_type': 'Shot'}, 'primary': True, 'entity': {'type': 'Shot', 'id':1571, 'name': '001_01_001'}}, {'path_cache_row_id': 8712, 'path':'    server  NAS_Production  CLICK  00_CG  scenes  Animation  01  001  Fx','metadata': {'type': 'ShotGrid_step', 'name': 'short_name'}, 'primary': True,'entity': {'type': 'Step', 'id': 6, 'name': 'FX'}}, {'path_cache_row_id':8713, 'path':'    server  NAS_Production  CLICK  00_CG  scenes  Animation  01  001  Comp',참고: 이보다 훨씬 더 길게 표시될 수 있습니다.오류의 원인은 무엇입니까?이 오류는 Flow Production Tracking(사이트 기본 설정(Site Prefs) -&amp;gt; 파일 관리(File Management))에서 지정된 저장소 루트와 파이프라인 구성의 config/core/roots.yml 간의 불일치를 가리킵니다.Windows를 실행하는 스튜디오에서 대소문자 불일치로 인해 종종 발생합니다. 해당 경로는 대소문자를 구분하지 않지만, 구성은 대소문자를 구분합니다. E: Projects와 E: projects처럼 간단한 차이로도 이 오류가 발생할 수 있습니다.백그라운드에서 어떤 일이 발생합니까?코드는 방금 생성한 경로에 대한 FilesystemLocation 엔티티를 Flow Production Tracking에서 만들고, Flow Production Tracking의 저장소 루트를 사용하여 경로의 루트를 결정합니다. 그런 다음 로컬 캐시에 동일한 항목을 만들고 데이터베이스에서 저장할 위치를 결정해야 합니다. 로컬 캐시의 경우 roots.yml을 사용하여 경로의 루트를 확인하며, 대소문자가 일치하지 않기 때문에 생성 경로가 Flow Production Tracking에서 입력한 경로와 일치하지 않습니다. 여기서 오류가 발생합니다.특히 오류가 명확하게 발생하지 않아 좋지 않은 결과가 발생했습니다. 폴더가 작성되고, FilesystemLocation 항목이 작성되고, 로컬 경로 캐시에서 동기화되지 않았으며, 저장소 루트가 일치하지 않아 동기화할 수도 없습니다.해결 방법먼저 사이트 기본 설정(Site Prefs)의 저장소 루트 경로가 config/core/roots.yml의 경로와 일치하는지 확인합니다. 불일치를 수정하면 후속 폴더 생성 호출 시 오류가 사라집니다.그런 다음 잘못된 FilesystemLocation 엔티티를 지웁니다. 잘못된 FilesystemLocation 엔티티 세트로 범위를 좁힐 수 있는 경우 해당 엔티티 세트를 제거합니다. 그러나 대부분의 경우 프로젝트의 모든 경로가 손상되어 모두 이동해야 합니다.  FilesystemLocation 엔티티를 지우는 방법: 이상적으로는 tank unregister_folders를 실행할 수 있습니다. 모든 엔티티를 지우려면 tank unregister_folders --all을 실행합니다. (tank unregister_folders의 모든 옵션에 대해 인자 없이 실행하면 사용 정보가 출력됩니다.)  그러나 DB가 이미 불안정한 상태이므로 작동하지 않거나 부분적으로만 작동할 수 있습니다. 명령을 실행하고 나면 Flow Production Tracking의 FilesystemLocations로 돌아가서 삭제될 것으로 예상되는 항목이 실제로 사라졌는지 확인합니다. 그렇지 않은 경우 잘못된 엔티티를 선택하고 수동으로 휴지통으로 이동합니다.이때 Flow Production Tracking의 FilesystemLocations는 정리되지만 아티스트의 로컬 캐시에 변경 사항이 반영되지 않을 수 있습니다. 마지막 단계는 각 사용자의 컴퓨터에서 로컬 캐시를 실제로 동기화하는 것입니다. 이렇게 하려면 tank synchronize_folders --full을 실행해야 합니다.이 모든 단계를 수행하고 나면 경로 캐시가 양호한 상태가 되고 해당 오류가 더 이상 나타나지 않아야 합니다.관련 링크  해당 코드의 내용  경로 캐시는 무엇입니까? 파일 시스템 위치는 무엇입니까?커뮤니티에서 전체 스레드를 참조하십시오.",
    "url": "/da6b219a/",
    "relUrl": "/da6b219a/"
  },
  "111": {
    "id": "111",
    "title": "RV 개발자 개요",
    "content": "RV 개발자 개요RV 코어 참조사용자 매뉴얼사용자 매뉴얼에는 RV 및 RVIO 시작 방법을 소개하는 자료와 전체 명령행 및 GUI 사용법이 포함되어 있습니다. 또한, 설치 참고 사항과 성능 극대화 팁, 그리고 LUT, RV 픽셀 파이프라인, 입체 3D, 패키지를 이용한 RV 확장, RV 및 RVLS 미디어 목록 유틸리티에 대한 자세한 정보도 살펴볼 수 있습니다.  RV 사용자 매뉴얼  질문 및 문제 해결 포럼기술 참조 매뉴얼이 참조 매뉴얼은 RV를 사용자화하는 방법을 배울 때 처음으로 참조할 수 있는 자료입니다. 이 매뉴얼에는 RV 패키지 시스템 및 Mu 스크립팅 기능에 대한 개요가 포함되어 있습니다. 핫 키를 변경하거나, 메뉴를 추가하거나, 색상 관리를 사용자화하거나, 새 위젯을 작성하거나, RV를 파이프라인에 통합하려는 경우 가장 먼저 이 매뉴얼을 참조하십시오.  기술 참조 매뉴얼  RV 확장 포럼RV-SDI 매뉴얼이 매뉴얼에서는 프리젠테이션 모드 장치로서 NVIDIA SDI 비디오 장치의 미세조정 구현에 대해 설명합니다. 프리젠테이션 모드와 이 모드가 일반적으로 RV와 어떠한 관련이 있는지에 대한 자세한 내용은 RV 사용자 매뉴얼을 참조하십시오. RV-SDI를 사용하려면 “rv”(또는 “rv.exe”) 실행 파일을 실행해야 하며 “rvsdi” 라이선스가 있어야 합니다.  RV-SDI 매뉴얼RV 통합RV/Nuke 통합이제 RV는 Nuke 통합 도구와 함께 제공됩니다. 이 문서에서는 개별 또는 시스템 전체 설정을 위한 설치에 대해 설명하고, RV/Nuke의 워크플로우, 도구, 컨셉 및 사용법에 대해서도 설명합니다.  RV-Nuke 통합 설명서RV/Maya 통합이제 RV는 Maya 통합 기능과 함께 제공됩니다. 이 문서에서는 RV/Maya 패키지를 설치하는 방법과 RV/Maya 워크플로우, Playblast를 비교 및 정리하는 방법, 그리고 편집, A/B 비교 및 레이아웃으로 렌더링하는 방법에 대해 설명합니다.  RV-Maya 통합 설명서",
    "url": "/7e1071f0/",
    "relUrl": "/7e1071f0/"
  },
  "112": {
    "id": "112",
    "title": "S3",
    "content": "S3Amazon S3 is an object storage service offered by AWS. It can be thought of as a highly durable storage space in the cloud. Flow Production Tracking uses S3 to store uploaded media and files.In order to use Flow Production Tracking isolation features, you will bring your own S3 bucket and configure Flow Production Tracking to use it for storage. Please refer to our S3 Bucket Setup article for details on how to do this.",
    "url": "/dfc0cc1b/",
    "relUrl": "/dfc0cc1b/"
  },
  "113": {
    "id": "113",
    "title": "Media Isolation",
    "content": "Media Isolation                    Disclaimer: The security of your S3 bucket is solely a client responsibility, and the integrity of your data will be at risk without it. We very strongly recommend securing your S3 bucket properly.    AWS Account CreationYou can quickly create your AWS Account.You should also contact your AWS contacts to get help with your AWS account setup.AWS CloudFormation templateIt’s possible to start from the Private S3 bucket AWS CloudFormation template and customize it for your needs for a faster deployment.                    Disclaimer: This template is provided as an example only. It is your responsibility to validate that running the template will result in the configuration/policy/security settings your studio requires.      Go the CloudFormation service in AWS Console  Select Template is ready  Set Amazon S3 URL to https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-s3-bucket.yml  Next  Set a stack name like Flow Production Tracking-s3-bucket  Set your S3 bucket name and your Flow Production Tracking site name  Next  Accept I acknowledge that AWS CloudFormation might create IAM resources  NextCORS ConfigurationCORS policy on your S3 bucket will be minimally configured, allowing only the required origin (your site) and methods, amongst other things.IAM RoleThe template will create an AWS Role with the following permissions on your bucket:  Allow Flow Production Tracking to access your S3 bucket.  Allow the Flow Production Tracking account to assume the role by setting the role Trust Relationship.Media Isolation ActivationPlease contact Flow Production Tracking support via the dedicated Microsoft Teams channel and provide the following information:  Flow Production Tracking IAM Role ARNFlow Production Tracking will allow your site to use your IAM role.Media Configuration SetupNavigate to your site’s site preferences and under the Isolation section, fill in the S3 Configuration preference with the following JSON:{​​​​​​​   &quot;&amp;lt;S3_CONFIG_NAME&amp;gt;&quot;: {​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​}​​Fields description            Field      Description                  S3_CONFIG_NAME      Unique name for the configuration. This will be selectable as a bucket later on.              BUCKET_REGION      Isolation bucket’s region              BUCKET_NAME      Isolation bucket’s name              BUCKET_PREFIX      The S3 prefix where the media is located on the isolation bucket              ROLE_ARN      AWS Role ARN that Flow Production Tracking can use to access the bucket. This must be the same role specified in the Initial Setup              S3_INTERFACE_VPC_ENDPOINT      Optional - This is only needed if Media Traffic Isolation is utilized.      Testing Media ConfigurationAfter the configuration has been updated on your site, navigate to the /admin/speedtest route of your Flow Production Tracking site. Select the new S3_CONFIG_NAME that was just set up previously and start the test to confirm that all the upload/download tests work as intended.Next StepsSee Media Traffic Isolation to activate the Media Traffic Isolation feature.See Media Replication to activate the Media Replication Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/439f0627/",
    "relUrl": "/439f0627/"
  },
  "114": {
    "id": "114",
    "title": "Media Replication",
    "content": "Media ReplicationDescriptionIt’s possible to add S3 replication between two S3 buckets in different regions and configure Flow Production Tracking to leverage it for faster access to media.Features  Support one replica bucket in another region leveraging the AWS S3 replication featureHow it worksWhen S3 bucket replication is activated, users will be able download media files from the replica S3 bucket.For each user, the S3 replication is activated by the Use S3 Replication field.            Value      Behavior                  no      Never use replica S3 bucket (default)              yes      Use replica S3 bucket when delay is over              auto      Use replica S3 bucket when delay is over and the client IP is in IP Adresses for S3 replication range      The IP Adresses for S3 replication preference can be edited in Site Preferences under the Isolation category.Limitations  Only one replica S3 bucket can be configured  Only downloading from the replica bucket is supported  Configurable delay for new media to be replicated before being made available to usersSetup steps  Create the replica S3 bucket in a new AWS region. See Media Isolation  Update your existing Flow Production Tracking role policy to allow Flow Production Tracking to also access the replica bucket  Setup the replication rules on the primary S3 bucket. See How do I add a replication rule to an S3 bucket?  Setup a VPC + Direct Connect + S3 proxy in the new AWS region if needed. See Media Traffic IsolationConfigure your siteTo configure S3 replication, you will need to add an additional entry to the “S3 Configuration” site preference.The complete entry may look something like the following:{​​​​​​​​   &quot;&amp;lt;S3_CONFIG_NAME&amp;gt;&quot;: {​​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;,     &quot;s3_interface_vpc_endpoint_dns_name&quot;: &quot;&amp;lt;S3_INTERFACE_VPC_ENDPOINT&amp;gt;&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​,   &quot;&amp;lt;S3_CONFIG_NAME_REPLICA&amp;gt;&quot;: {​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION_REPLICA&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME_REPLICA&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX_REPLICA&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;,     &quot;s3_interface_vpc_endpoint_dns_name&quot;: &quot;&amp;lt;S3_INTERFACE_VPC_ENDPOINT_REPLICA&amp;gt;&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​After the configuration has been updated on your site, navigate to the /admin/speedtest route of your Flow Production Tracking site. Select the new S3_CONFIG_NAME_REPLICA and start the test to confirm that all the upload/download tests work as intended.Update the following Site Preferences:  S3 Bucket for Replication - This should have the same value as S3_CONFIG_NAME_REPLICA from the S3 Configuration  S3 Replication Delay - Set this to something reasonable such as 60 seconds.FAQCopy existing mediaS3 replication only applies to media uploaded after the feature has been enabled. Existing media in the primary bucket must be copied to the replica bucket manually. You can simply use aws-cli sync or use Amazon S3 Batch Operations if you have a lot of media to achieve this.Next StepsSee Fine Tuning to finalize your setup and optimize costs and security.Go to Setup for an overview of the possible next steps.",
    "url": "/44623c83/",
    "relUrl": "/44623c83/"
  },
  "115": {
    "id": "115",
    "title": "통합 사용자 안내서",
    "content": "통합 사용자 안내서이 안내서의 내용:  소개  데스크톱 시작하기          데스크톱 설치                  최신 버전의 데스크톱 설치                    자체 호스팅되거나 프록시 서버 뒤에 있는 경우 로그인                  인증 및 브라우저 통합                    시스템 트레이      프로젝트 브라우저      명령 실행기      콘솔        응용프로그램 실행  패널          개요      UI 상세 정보                  액티비티 스트림          노트 생성 및 노트에 회신          노트, 버전, 게시 및 태스크          정보 탭          검색          액션          현재 작업 영역 및 내 영역          현재 작업 영역                      Publisher          개요      인터페이스 구성요소 및 개념      기본 워크플로우                  컨텐츠 생성 소프트웨어 내에서 게시          항목 및 태스크 게시                          컨텍스트              유효성 확인              다중 문서 워크플로우                                독립 실행형 게시          게시 유형                          독립 실행형              3ds Max              Houdini              Maya              Nuke              Nuke Studio              Photoshop CC                                            Loader          개요      트리 뷰      네비게이션      게시 살펴보기      하나 이상의 게시를 씬으로 가져오기      이전 게시를 사용하는 작업      연관 리뷰        고급 기능  감사의 인사소개Flow Production Tracking 통합은 Flow Production Tracking를 컨텐츠 생성 도구로 이용할 수 있도록 해 줍니다. Flow Production Tracking 통합을 이용하면 간편하게 소프트웨어를 실행하고, 패널을 사용하여 Flow Production Tracking의 태스크 관련 노트 및 데이터를 트래킹하고, Publisher 및 Loader를 통해 파일을 트래킹하고 이를 씬으로 가져올 수 있습니다. 아티스트는 앱 내에서 바로 태스크에 관한 모든 Flow Production Tracking 데이터와 프로젝트의 모든 태스크에 액세스할 수 있습니다. 또한 노트에 회신하고, 버전을 재생하고, 파일을 게시하고, 동료가 게시한 파일에서 이를 로드할 수 있습니다.Flow Production Tracking 통합에 대한 최신 업데이트는 릴리즈 정보를 구독하십시오.데스크톱 시작하기Flow Production Tracking 데스크톱 앱은 이 통합의 심장에 해당합니다. Flow Production Tracking 경험을 로컬 컴퓨터로 확장시켜 주는 소프트웨어 응용프로그램이며, 컴퓨터에서 바로 쉽게 Flow Production Tracking 데이터에 액세스하고, 응용프로그램을 실행하고, 파이프라인 통합 도구를 실행할 수 있도록 해 줍니다.툴킷 클래식 또는 커스텀 설정 실행?Flow Production Tracking 통합은 자동으로 설치됩니다. 클래식 툴킷 구성을 설치하려는 앞선 고객이거나 데스크톱 설정 마법사를 통해 설치하려는 커스텀 툴킷 설정이 있는 경우에는 관리자 안내서에서 그 방법을 알아보십시오.데스크톱 설치앱 메뉴에서 Flow Production Tracking 데스크톱을 다운로드할 수 있습니다.메시지에 따라 진행하면서 Mac용, Windows용, Linux용 데스크톱 중에서 어느 것을 다운로드할지 선택합니다.최신 버전의 데스크톱 설치현재 버전을 제거하지 않고 지원되는 모든 운영 체제에서 Flow Production Tracking 데스크톱을 업데이트할 수 있습니다. 그러나 Flow Production Tracking 데스크톱 버전을 업데이트하기 전에 기존 세션을 닫아야 합니다.참고: Windows에서 버전을 업데이트하는 동안 데스크톱이 실행 중이면 바이너리 잠금이 설치를 방해하고 설치 프로그램을 중지시킵니다. 이렇게 하면 일부 파일이 이미 복사되었으므로 설치가 완료되지 않습니다. 이 문제를 해결하려면 데스크톱을 종료하고 “재시도”를 선택하십시오.자체 호스팅되거나 프록시 서버 뒤에 있는 경우 로그인참고: 로그인에 관한 다음 내용은 자체 호스팅되거나 프록시 서버를 사용하는 경우에 필요합니다. 이는 기본 동작이 아닙니다.자체 호스팅되거나 프록시 서버를 사용하는 경우 처음 데스크톱을 열면 인증서에 관해 묻는 메시지가 브라우저에 표시됩니다. 이는 Flow Production Tracking를 데스크톱 앱과 연결하기 위한 것입니다. 인증서를 설정하는 데 문제가 있는 경우 Firefox 및 Chrome 및 기타 브라우저에 대한 문제 해결 문서를 참조하십시오.보안 인증서 목록은 한 번만 업데이트하면 됩니다. Mac과 Windows에서만 인증서에 관한 메시지가 표시되고, Linux에서는 표시되지 않습니다.설정을 마치면 Flow Production Tracking 사이트에 로그인해야 합니다.프록시를 이용하는 경우 추가 구성도 필요합니다. 이 작업을 수행하는 방법에 대한 지침은 관리자 안내서를 참조하십시오.인증 및 브라우저 통합데스크톱은 Flow Production Tracking 웹 응용프로그램이 컴퓨터와 상호 작용할 수 있도록 해 주는 서비스를 제공합니다. 이를 통해 로컬 파일 링크 및 소프트웨어 실행 같은 기능을 이용할 수 있습니다. 보안을 위해 브라우저에서와 같은 Flow Production Tracking 사이트에서 동일한 사용자로 데스크톱에 로그인해야 합니다. 다른 사용자로 또는 다른 사이트에서 데스크톱에 로그인하면 계정을 전환하라는 메시지가 표시되고, 계정을 전환하면 데스크톱이 다시 시작되고 해당 자격 증명을 묻는 메시지가 표시됩니다.시스템 트레이응용프로그램을 시작하면 시스템 트레이에 아이콘이 나타납니다. 응용프로그램 창을 열려면 아이콘을 클릭하십시오. 기본적으로 창은 시스템 트레이에 고정되기 때문에 사용하지 않으면 자동으로 숨겨집니다.사용자 메뉴에서 “메뉴에서 고정 해제(Undock from Menu)”를 선택하거나 헤더를 드래그해서 창의 고정을 해제할 수 있습니다. 고정 해제된 창은 일반 창과 비슷하게 보이고, 사용하지 않더라도 더 이상 숨겨지지 않습니다.창이 고정 해제되면 닫기 버튼을 클릭해 숨길 수 있습니다. 다시 나타나게 하려면 시스템 트레이 아이콘을 클릭하면 됩니다.프로젝트 브라우저앱의 첫 번째 메인 뷰는 프로젝트 브라우저입니다. 여기에서 Flow Production Tracking 인스턴스의 모든 프로젝트를 볼 수 있습니다. 가장 최근에 액세스한 프로젝트가 첫 번째로 나열됩니다.창 오른쪽 아래 근처에는 Flow Production Tracking 계정의 썸네일이 있습니다. 이는 사용자 메뉴로, 여기에서 창을 고정 및 고정 해제하고, 창을 다른 창 위에 고정하고, 로깅 콘솔을 표시하는 등의 작업이 가능합니다.창 위쪽에 있는 돋보기 아이콘을 클릭하면 검색란이 나타납니다. 이 검색란에 검색어를 입력하면 프로젝트 목록이 필터링되면서 입력한 검색어가 포함된 프로젝트만 표시됩니다.프로젝트를 클릭하면 해당 프로젝트의 명령 실행기 뷰로 이동하여, 해당 프로젝트에 사용할 수 있는 도구를 실행할 수 있습니다.명령 실행기프로젝트를 선택하면 해당 프로젝트의 명령 실행기로 이동합니다. 이 창에는 해당 프로젝트에 사용할 수 있는 모든 도구 및 응용프로그램이 격자 모양으로 배치된 버튼으로 표시됩니다. 응용프로그램을 실행하려면 버튼을 클릭하기만 하면 됩니다. 그러면 프로젝트 전용 환경에서 응용프로그램이 실행되고, Flow Production Tracking에 통합이 설정되어 있는 경우에는 사용 가능한 모든 도구가 나와 있는 Flow Production Tracking 메뉴가 표시됩니다.콘솔이 콘솔은 사용자 메뉴에서 실행할 수 있습니다. 프로젝트 실행과 관련한 로그가 여기에 표시됩니다. 오류가 발생하는 경우 오류 상세 정보가 여기에 표시되어야 합니다.콘솔을 마우스 오른쪽 버튼으로 클릭하면 표준 편집 메뉴가 표시되어 콘솔에서 모든 텍스트를 선택하고, 선택 사항을 복사하거나 텍스트를 지울 수 있습니다.응용프로그램 실행Flow Production Tracking 데스크톱을 실행하고 프로젝트를 선택하면 데스크톱이 사용 중인 운영 체제에 대한 표준 응용프로그램 디렉토리를 스캔합니다. 데스크톱에서 해당하는 통합이 설정되어 있는 응용프로그램의 시작 관리자를 표시합니다. 같은 소프트웨어의 버전이 여러 개인 경우 시작 관리자는 사용 가능한 모든 버전이 포함된 드롭다운 목록을 보여 줍니다. 시작 관리자 아이콘 자체를 클릭하면 최신 버전이 실행됩니다.Maya 및 Nuke 같은 응용프로그램은 Flow Production Tracking 데스크톱에서 직접 실행해도 되고, Flow Production Tracking에서 바로 실행해도 됩니다. 어떻게 실행하든 응용프로그램 내에서 Flow Production Tracking 통합을 사용할 수 있습니다.스튜디오에는 보통 기본 제공되는 것 외에 추가 구성이 필요하기 마련입니다. 스튜디오의 소프트웨어가 표준이 아닌 위치에 있거나 스튜디오가 기본적으로 지원되지 않는 내부 엔진을 사용 중인 경우가 있을 수 있습니다. 이 경우에도 Flow Production Tracking 웹 앱 내에서 바로 구성하기는 쉽습니다. 자세한 내용은 관리자 안내서를 참조하십시오.원하는 앱이 표시되지 않으면 관리자 안내서의 Flow Production Tracking 데스크톱에서 소프트웨어 구성 섹션을 참조하십시오.패널개요데스크톱 또는 Flow Production Tracking에서 응용프로그램을 실행하면 Flow Production Tracking 패널이 나타납니다. Flow Production Tracking 패널은 작고 가벼운 버전의 Flow Production Tracking로서 Maya 및 Nuke 같은 아티스트 응용프로그램 내에서 바로 실행됩니다. 이 패널을 이용하면 작업 중인 응용프로그램에서 나오지 않고도 Flow Production Tracking 정보에 빠르게 액세스할 수 있습니다. 또한 현재 태스크에 관한 정보에 쉽게 액세스하고, Flow Production Tracking에서 액티비티 스트림, 노트, 태스크, 버전 및 Publisher에 즉시 액세스할 수 있습니다. 다른 팀원이 리뷰를 위해 전송한 버전을 재생해 보고, 노트에 회신하고, 새 태스크를 생성하고, Flow Production Tracking 사이트를 검색할 수도 있습니다.UI 상세 정보Flow Production Tracking 패널은 다양한 기본 UI 요소들로 이루어져 있습니다. 맨 위에는 네비게이션 및 검색을 위한 버튼으로 이루어진 도구막대 가 있습니다. 도구막대 오른쪽 아래에는 현재 보고 있는 항목에 관한 정보가 나와 있는 상세 정보 영역 이 있습니다. 이 상세 정보 영역은 구성이 가능하기 때문에 커스텀 필드를 표시하고 싶다거나 파이프라인에서 특히 중요한 데이터가 있는 경우 이곳에 표시되도록 쉽게 구성할 수 있습니다. 끝으로 많은 컨텐츠 탭 이 있습니다. 이 탭에는 모두 Flow Production Tracking 데이터가 표시되며, 이를 통해 Flow Production Tracking 패널을 쉽게 탐색하면서 게시 등의 항목을 빠르게 찾고, 버전을 리뷰하거나, 현재 선택한 항목에 링크되어 있는 태스크에 누가 할당되어 있는지 확인할 수 있습니다.통합이 고정 기능을 지원하는 응용프로그램에서는 Flow Production Tracking 패널이 UI 내에 깔끔하게 고정된 상태로 나타납니다. 그 외의 응용프로그램에서는 보통의 창으로 표시됩니다.아래는 Flow Production Tracking 패널에서 사용할 수 있는 다양한 탭과 기능을 간략히 요약한 내용입니다.액티비티 스트림액티비티 스트림은 Flow Production Tracking의 액티비티 스트림과 유사하게 작동합니다. 다음과 같이 현재 표시된 객체와 관련하여 일어나는 일들을 모두 보여 줍니다.  노트를 작성하는 사용자  리뷰를 위해 제출되는 버전  파이프라인에 의해 생성되는 게시액티비티 스트림에서 바로 새 노트를 추가하거나 기존 노트에 회신할 수 있습니다. 첨부 파일은 자동으로 표시되고, 이 파일을 클릭하면 큰 미리보기로 표시됩니다.이 파일을 업로드한 후 자리 표시자 아이콘을 볼 수 있습니다. 패널을 수동으로 새로 고치면 최종 썸네일을 표시하여 사용할 수 있습니다.노트 생성 및 노트에 회신Flow Production Tracking 패널에서 노트를 생성하거나 노트에 회신하는 일은 간단합니다. 액티비티 스트림 또는 노트 상세 정보 페이지로 이동한 다음 노트 생성(create note) 또는 노트에 회신(reply to note) 을 클릭하면 됩니다. 그러면 노트 텍스트를 입력할 수 있는 대화상자가 나타납니다. 노트를 특정인에게 전송하고 싶다면 @name 표기법을 사용하면 됩니다. 그러면 그 사람이 노트의 받는 사람 필드에 자동으로 추가됩니다.노트, 버전, 게시 및 태스크노트(Notes), 버전(Versions), 게시(Publishes) 및 태스크(Tasks) 탭은 모두 같은 방식으로 작동하여, 현재 사용자가 보고 있는 항목과 연관된 데이터를 표시합니다. 원하는 항목을 두 번 클릭하면 해당 항목을 집중해서 보여 줍니다. 게시(Publish) 로 이동했다면 해당 게시에 대한 종속성을 볼 수 있는데, 이는 파이프라인이 종속성 정보를 트래킹하는 경우 유용한 기능으로 에셋이 상호 연결되어 있는 방식을 즉시 파악할 수 있도록 해 줍니다.정보 탭다른 탭에서 원하는 정보를 찾지 못한 경우 정보(Info) 탭으로 이동해 보십시오. 이 탭에는 해당 엔티티에 대한 대부분의 Flow Production Tracking 필드가 나와 있으며, 파란색 하이퍼링크를 클릭하여 다른 Flow Production Tracking 위치로 이동할 수도 있습니다.검색ShotGrid에서 다른 위치 또는 다른 객체로 빠르게 이동하고 싶다면 기본 제공되는 검색 기능을 이용하면 됩니다. 이는 Flow Production Tracking 웹 응용프로그램의 전역 검색 기능과 유사합니다. 찾고 싶은 항목의 이름이나 설명을 입력하기 시작하여 세 자 이상 입력하면 결과가 표시됩니다.액션Flow Production Tracking 패널을 통해 Flow Production Tracking 데이터를 이용하여 씬에서 작업을 실행할 수도 있습니다. Loader와 마찬가지로 Panel에도 메뉴에 의해 트리거되는 코드 조각을 브라우저의 항목에 쉽게 등록할 수 있도록 해 주는 액션 시스템이 있습니다. 상세 정보 영역과 목록에서 액션에 액세스할 수 있습니다. 상세 정보 영역의 액션 버튼에는 Flow Production Tracking로 빠르게 이동하거나 현재 뷰를 새로 고침하는 등 몇 가지 편리한 기본 제공 기능도 포함되어 있습니다.현재 작업 영역 및 내 영역왼쪽 위에 있는 아이콘을 클릭하면 현재 작업 영역으로 이동합니다. 이 영역은 주로 현재 작업 중인 태스크이며, 여기에서 빠르게 노트에 액세스하고, 버전을 리뷰하고, 현재 작업 중인 항목과 관련한 기타 정보를 확인할 수 있습니다. 이곳은 Flow Production Tracking 패널이 항상 처음으로 포커스를 두는 위치이기도 합니다.오른쪽 위에는 현재 사용자의 썸네일이 표시되는 버튼이 있습니다. 이 버튼을 클릭하면 현재 사용자와 관련된 정보를 보여 주는 페이지로 이동합니다. 여기에는 다음 정보가 포함됩니다.  사용자가 제출한 모든 게시 및 버전  사용자에게 할당된 태스크  사용자가 참여하고 있거나 노트가 사용자와 연관되어 있는 모든 노트 대화(예: 사용자에게 할당된 태스크와 연관된 노트)현재 작업 영역태스크에 대한 작업을 시작할 때 Panel을 사용하여 현재 작업 영역을 설정할 수 있습니다. 그러면 작업을 게시할 때 이 영역이 Flow Production Tracking의 현재 태스크와 연결됩니다.Publisher개요아티스트는 Publish 앱을 통해 아티스트 다운스트림에서 사용할 수 있도록 작업물을 게시할 수 있습니다. 아티스트의 컨텐츠 생성 소프트웨어 내에서 기존 게시 워크플로우를 지원하고 디스크상의 파일을 독립 실행형으로 게시할 수 있습니다. 컨텐츠 생성 소프트웨어에서 작업하거나 기본 Flow Production Tracking 통합을 사용하여 작업할 때 이 앱은 아티스트가 게시할 수 있는 항목을 자동으로 검색해 표시해 줍니다. 보다 정교한 프로덕션이 필요한 경우 스튜디오는 커스텀 게시 플러그인을 작성하여 아티스트 워크플로우를 진행할 수 있습니다.다음 섹션에서는 Publisher UI 및 기본 통합 워크플로우를 다룹니다. 스튜디오의 특정한 요구사항에 맞게 Publisher를 커스터마이즈하는 방법은 Publisher Dev 안내서를 참조하십시오.인터페이스 구성요소 및 개념로컬 파일 시스템 어디에서든 파일을 드래그 앤 드롭합니다. 찾아보기(Browse) 버튼을 사용하여 파일 브라우저를 열고 게시할 파일을 하나 이상 선택합니다.왼쪽의 항목 트리가 게시되는 항목을 보여 줍니다. 최고 레벨 항목들에는 작업 파일 내에서 생성된 렌더나 캐시 등 관련된 하위 항목이 포함될 수 있습니다. 각 항목 아래에는 게시할 때 수행되는 액션을 나타내는 하나 이상의 게시 태스크가 있습니다.항목 자체는 게시된 파일이 연결되는 Flow Production Tracking 컨텍스트를 나타내는 컨텍스트 헤더 아래에 그룹화됩니다.최고 레벨 항목이 둘 이상인 경우에는 게시하는 항목과 실행할 액션을 전체적으로 보여 주는 요약 항목이 존재합니다.항목을 선택하면 인터페이스 오른쪽에 항목의 상세 정보가 표시됩니다. 상세 정보에는 대상 컨텍스트뿐 아니라 게시의 썸네일과 설명도 포함됩니다. 해당 항목과 하위 항목에 대한 요약도 포함될 수 있습니다.인터페이스 아래쪽을 보면 왼쪽에 일련의 도구 버튼이 있습니다. 다음과 같은 버튼이 있습니다.  찾아보기(Browse): 게시할 파일을 찾습니다  새로 고침(Refresh): 게시 항목 목록을 새로 고칩니다  삭제(Delete): 선택한 항목을 목록에서 제거합니다  확장(Expand): 목록의 모든 항목을 확장합니다  축소(Collapse): 목록의 모든 항목을 축소합니다  설명서(Documentation): 워크플로우 설명서를 엽니다가운데는 상태 레이블입니다. 이 레이블은 게시자가 유효성 확인을 수행하고 게시 태스크를 실행하면 업데이트됩니다. 클릭하면 진행 상세 정보가 오버레이로 표시됩니다.맨 오른쪽에는 확인(Validate) 및 게시(Publish) 버튼이 있습니다. 확인(Validate) 버튼을 클릭하면 모든 항목과 태스크에 대한 초기 유효성 확인을 실행하여 모두 게시 가능한 상태인지 확인합니다. 게시(Publish) 버튼을 클릭하면 목록에 있는 항목의 게시가 시작됩니다.진행 상세 정보 오버레이에는 목록 내 항목의 수집, 유효성 확인 및 게시 결과가 표시됩니다.클립보드에 복사(Copy to Clipboard) 버튼을 이용하면 게시 로그를 쉽게 공유할 수 있습니다. 유효성 확인 또는 게시 오류가 발생하면 로그 메시지에 액션 버튼이 포함될 수 있으며, 이 버튼을 클릭하면 추가 정보, 그리고 때로는 즉시 해결 방법까지 확인할 수 있습니다.기본 워크플로우아티스트가 자신의 작업물을 다른 아티스트들도 사용할 수 있도록 만드는 것, 그것을 가능하게 해 주는 것이 Publish 앱의 목적입니다. Flow Production Tracking에서 파일을 게시한다는 것은 곧 게시되는 파일에 관한 정보(경로, 버전 번호, 아티스트 정보, 관련 Flow Production Tracking 컨텍스트 등)가 담긴 레코드를 Flow Production Tracking에 생성하는 것을 의미합니다. 파일이 Flow Production Tracking에서 트래킹되고 나면 다른 사용자들도 Loader 앱을 통해 이 파일을 사용할 수 있습니다.기본 Flow Production Tracking 통합은 파이프라인에서 Publish 앱을 사용할 수 있는 두 가지 방법, 독립적으로 게시하는 방법과 컨텐츠 생성 소프트웨어 내에서 게시하는 방법을 제공합니다. 다음 섹션은 각 시나리오의 워크플로우를 설명한 것입니다.컨텐츠 생성 소프트웨어 내에서 게시기본 Flow Production Tracking 통합은 3dsMax, Houdini, Maya, Nuke, Nuke Studio, Photoshop 같은 컨텐츠 생성 소프트웨어를 위한 게시 워크플로우를 지원합니다. 컨텐츠 생성 소프트웨어를 통해 실행되는 게시자는 자동으로 게시할 항목을 찾습니다. 게시할 수 있는 항목은 소프트웨어, 그리고 아티스트의 작업 파일 컨텐츠에 따라 조금씩 다르지만 게시에 대한 기본적인 컨셉은 동일합니다. 다음은 Nuke에서 게시하는 경우를 예로 든 것입니다.항목 및 태스크 게시왼쪽에 수집된 게시 항목들이 있습니다. 게시 항목은 세 가지로, 선택한 항목은 그 아래 하위 항목이 두 가지 있는 작업 파일 자체입니다. 또한, 이미지 파일 시퀀스와 Alembic 캐시도 있습니다. 이 항목들은 각각 Flow Production Tracking에 게시(Publish to Flow Production Tracking) 게시 태스크가 첨부되어 있어, 이를 실행하면 개별 파일 또는 이미지 시퀀스를 트래킹할 수 있도록 Flow Production Tracking에 게시 항목을 생성하는 작업이 진행됩니다.Nuke 스크립트를 나타내는 상위 항목에는 파일 버전 지정 시작(Begin file versioning) 플러그인이 부착되어 있습니다. 이 플러그인은 작업 파일의 경로에 버전 번호가 없는 경우 나타납니다. 이 체크박스를 선택하면 이 태스크를 통해 게시 전 파일 이름에 버전 번호가 삽입됩니다. 이 경우에는 파일 이름이 bunny_010_0010.nk에서 bunny_010_0010.v001.nk로 바뀝니다. 이렇게 하면 아티스트 작업 파일의 내역을 기록할 수 있습니다. 기본적으로 이 태스크는 선택되어 있지 않고, 반드시 실행할 필요도 없습니다. 이 태스크를 활성화한 상태로 항목을 게시하고 나면 다음에 해당 작업 파일을 게시할 때에는 파일 이름에 버전 번호가 이미 있기 때문에 이 태스크가 표시되지 않습니다.게시 태스크는 원하는 대로 켜거나 끌 수 있습니다. 항목의 체크박스는 하위 태스크의 선택 상태를 반영하고 제어합니다. 예를 들어, 항목을 선택 취소하면 그 태스크도 모두 선택 취소됩니다. 여러 태스크 중 하나를 선택 취소하면 항목이 반만 선택한 상태가 됩니다. 특정 유형의 태스크 모두(예: Flow Production Tracking에 게시(Publish to Shotgun) 태스크 모두)의 선택 상태를 토글하려면 체크박스를 선택할 때 Shift 키를 누른 채로 선택하면 됩니다.게시 태스크를 선택하면 해당 태스크에 관한 정보가 표시됩니다.컨텍스트위의 Nuke 스크립트 항목의 경우, 게시된 항목이 Flow Production Tracking에서 연결되는 컨텍스트의 이름을 볼 수 있습니다. 이 이름은 인터페이스 오른쪽의 태스크(Task) 및/또는 링크(Link) 필드를 변경하여 수정할 수 있습니다. 여러 항목을 게시하는 경우에는 서로 다른 컨텍스트에 표시될 수도 있습니다. 게시 항목 왼쪽에 가로줄이 세 개 있는 아이콘은 한 컨텍스트에서 다른 컨텍스트로 항목을 옮기기 위한 드래그 핸들입니다.태스크(Task) 항목 필드 옆에는 메뉴 드롭다운 버튼도 있습니다. 이 메뉴를 클릭하면 사용자와 관련이 있을 수 있는 여러 태스크 그룹이 나타날 수 있습니다. 여기에는 현재 사용자에게 할당된 태스크, 현재 컨텍스트에 관련된 태스크(같은 샷에 할당된 다른 태스크 등), 최근에 찾아본 태스크가 표시됩니다.태스크 또는 엔티티 링크를 검색하려면 필드 중 하나를 클릭하거나 검색 아이콘을 클릭하고 원하는 컨텍스트 이름을 입력하면 됩니다. 이 필드에 일치하는 태스크 또는 엔티티 링크가 표시되면 이를 클릭하거나 원하는 컨텍스트로 이동할 수 있습니다.각 게시 항목마다 카메라 아이콘을 클릭하면 화면 일부를 선택해 Flow Production Tracking에서 해당 게시의 썸네일로 사용할 수 있습니다. 하위 항목이 있는 경우에는 기본적으로 상위 항목의 썸네일을 상속합니다. 하위 항목의 썸네일은 하위 항목을 선택하고 썸네일을 클릭해서 재정의할 수 있습니다.입력한 설명은 Flow Production Tracking의 게시 데이터에 포함됩니다. 썸네일과 마찬가지로 설명도 상위 항목에게서 상속되지만 하위 항목의 상세 정보 항목에 새로운 설명을 입력해 재정의할 수 있습니다.유효성 확인항목을 게시할 준비가 되면 확인(Validate) 버튼을 클릭해 파일 및 게시 항목의 상태가 게시가 원하는 대로 완료될 수 있는 상태인지 확인할 수 있습니다.모든 항목이 이상 없는 것으로 확인되면 오른쪽에 초록색 체크 표시가 나타납니다. 확인을 통과하지 못한 항목에는 경고 아이콘이 나타납니다.이 상태는 Publisher 아래쪽에 있는 상태 레이블 영역에도 표시됩니다.항목의 아이콘 또는 상태 레이블을 클릭하면 진행 상황 상세 정보 오버레이가 열리고, 유효성 확인 문제가 강조 표시됩니다.위 예에서는 Nuke 스크립트가 저장되지 않았습니다. 간혹 문제 해결 방법을 빠르게 알려주거나 문제에 관한 자세한 정보를 제공하는 액션 버튼이 제공됩니다. 여기에서는 Nuke 저장 대화상자가 열리는 다른 이름으로 저장…(Save As…) 액션 버튼이 보입니다.유효성 확인 문제가 모두 해결되면 진행 상황 상세 정보 오버레이를 닫고 게시 항목 뷰로 돌아갈 수 있습니다. 유효성 확인은 게시 태스크 경고 또는 오류를 해결하는 동안 필요한 만큼 얼마든지 실행할 수 있습니다.게시(Publish) 버튼을 누르면 앱이 목록의 항목과 태스크를 살펴보면서 다시 하나씩 유효성 확인을 실행한 다음, 게시 로직을 실행하여 Flow Production Tracking에 항목을 생성하고, 썸네일을 업로드하고, 작업 파일 버전을 수정하는 등의 작업을 처리합니다. 각 항목에 대한 게시를 요약하고 필요한 정리 작업을 수행하기 위한 최종 확인도 실행됩니다.전체 프로세스의 결과는 나중에 Publisher 아래쪽에 있는 상태 레이블을 클릭해 진행 상황 상세 정보 오버레이를 열어 검토할 수 있습니다. 게시하는 동안 진행 상황 상세 정보 뷰를 열어둔 채로 게시 결과를 살펴볼 수도 있습니다. 여기에서는 Flow Production Tracking에 새로 생성된 게시 항목으로 빠르게 이동하기 위한 추가 액션 버튼도 볼 수 있습니다.다중 문서 워크플로우Photoshop 또는 Nuke Studio 같은 컨텐츠 생성 소프트웨어에서 이루어지는 다중 문서 워크플로우의 경우 게시 항목 목록에 최고 레벨 항목이 여러 개 표시됩니다.그중에서 현재/활성 문서만 확장 및 선택된 상태로 표시됩니다. 게시할 모든 문서를 선택하려면 Shift 키를 누른 채로 선택 취소된 항목의 체크박스 하나를 클릭하십시오. 축소된 항목을 확장하려면 아래쪽 도구막대에 있는 확장 버튼을 사용합니다.최고 레벨 항목이 여러 개인 경우에는 목록 맨 위에 요약 항목도 포함됩니다.이 항목을 선택하면 게시를 위해 선택한 모든 항목의 전체 요약이 표시됩니다. 위에서는 서로 다른 네 가지 컨텍스트에서 총 여덟 개 태스크가 실행될 네 개 항목을 볼 수 있습니다. 원한다면 이 뷰에서 모든 항목의 컨텍스트와 설명을 재정의할 수 있습니다.위 이미지에서는 리뷰용 업로드(Upload for review) 태스크도 볼 수 있습니다. 이 태스크는 Photoshop 워크플로우로 한정되지 않습니다. 리뷰 가능한 미디어로 트랜스코딩하여 Flow Production Tracking에 업로드할 수 있는 모든 파일 유형에 대해 가능한 태스크입니다.독립 실행형 게시Publish 앱을 꼭 컨텐츠 생성 소프트웨어 내에서 실행할 필요는 없습니다.여기에서는 Publisher를 Flow Production Tracking 데스크톱에서 직접 실행할 수 있음을 알 수 있습니다. 독립 실행형 모드에서 앱을 실행하면 파일을 찾아보거나 드래그 앤 드롭할 수 있는 영역이 나타납니다.찾아보기(Browse) 버튼을 클릭하면 게시할 파일을 선택할 수 있는 표준 파일 브라우저가 열립니다.브라우저에서 파일을 선택하거나 파일 시스템에서 드래그 앤 드롭하고 나면 앱이 해당 파일을 게시할 최고 레벨 항목으로 보여 줍니다.이전 예에서와 마찬가지로 각 항목의 컨텍스트를 선택하고, 설명을 설정하고, 게시 시 실행되어야 하는 태스크를 식별할 수 있습니다.게시 유형다음 섹션에서는 각각의 기본 Flow Production Tracking 통합에 대해 자동으로 수집되는 게시 유형을 설명합니다.독립 실행형독립 실행형 워크플로우는 게시를 위한 파일을 자동으로 수집하지 않습니다. 대신 사용자가 인터페이스로 파일 경로를 드래그하거나 게시할 파일을 찾아야 합니다. 게시자는 게시(Publish) 버튼을 클릭하기 전까지는 사용자가 찾거나 드롭한 파일을 언제든 수용합니다. 기본 통합에서는 Flow Production Tracking 게시 유형과 연결되는 것으로 알려진 파일 유형을 사용하는 모든 파일 확장자를 사용할 수 있습니다. 파일 확장자가 인식되지 않으면 파일의 MIME 유형이 사용됩니다. 인식된 이미지 및 동영상 MIME 유형은 게시 가능하며, 리뷰용 업로드에 부착된 태스크가 있습니다.기본 통합은 드롭된 폴더에 이미지 시퀀스가 포함되어 있다고 가정합니다. 폴더에서 발견되는 인식된 모든 이미지 시퀀스는 게시 항목으로 표시됩니다. 발견된 시퀀스가 없다면 게시를 위한 항목이 생성되지 않습니다.3ds Max현재 Max 세션은 Loader를 통해 다른 Max 세션으로 병합 또는 참조될 수 있는 3dsmax 씬의 게시 유형으로 게시를 위해 수집됩니다.현재 세션에 대한 프로젝트 폴더를 지정할 수 있다면 그 프로젝트의 export 폴더에 있는 모든 파일이 게시 항목으로 표시되고, 마찬가지로 프로젝트의 preview 폴더에 있는 모든 영상 파일도 게시할 수 있게 됩니다.Houdini현재 Houdini 세션은 Loader를 통해 다른 Houdini 세션으로 병합될 수 있는 Houdini 씬의 게시 유형으로 게시를 위해 수집됩니다.다음 유형의 노드에서 디스크로 작성된 모든 파일 역시 게시 항목으로 자동 수집 및 표시됩니다.  alembic  comp  ifd  opengl  wrenMaya현재 Maya 세션은 Loader를 통해 다른 Maya 세션으로 가져오거나 참조될 수 있는 Maya 씬의 게시 유형으로 게시를 위해 수집됩니다.현재 세션에 대한 프로젝트 루트를 지정할 수 있다면 그 프로젝트의 cache/Alembic 폴더에 있는 모든 Alembic 파일이 게시 항목으로 표시되고, 마찬가지로 프로젝트의 movies 폴더에 있는 모든 영상 파일도 게시할 수 있게 됩니다.Nuke현재 Nuke 세션은 Loader를 통해 다른 Nuke 세션으로 가져오거나 새 세션으로 열 수 있는 Nuke 스크립트 게시 유형으로 게시를 위해 수집됩니다.다음 유형의 노드에서 디스크로 작성된 모든 파일 역시 게시 항목으로 자동 수집 및 표시됩니다.  Write  WriteGeoNuke Studio열려 있는 Nuke Studio 프로젝트는 다른 Nuke Studio 세션에서 Loader를 통해 새 프로젝트로 열 수 있는 NukeStudio 프로젝트 게시 유형으로 게시를 위해 수집됩니다.Photoshop CC열려 있는 Photoshop 문서는 다른 Photoshop 세션에서 Loader를 통해 새 레이어로 로드하거나 새 문서로 열 수 있는 Photoshop 이미지 게시 유형으로 게시를 위해 수집됩니다.LoaderFlow Production Tracking Loader를 사용하면 Flow Production Tracking에 게시한 파일을 신속하게 확인하고 탐색할 수 있습니다. 검색 가능한 트리 뷰 네비게이션 시스템 덕분에 원하는 태스크, 샷 또는 에셋을 빠르고 쉽게 찾을 수 있고, 찾고 나면 Loader가 해당 항목의 모든 게시에 대한 개요를 기반으로 썸네일을 보여 줍니다. 그러면 구성 가능한 후크를 통해 쉽게 게시를 참조하거나 현재 씬으로 가져올 수 있습니다.게시는 Flow Production Tracking의 레코드로, 각각 디스크의 파일 또는 파일의 시퀀스(예: 이미지 시퀀스)를 나타냅니다. 게시는 모든 응용프로그램을 통해 생성할 수 있지만 보통 게시자를 통해 생성합니다.게시를 생성하고 나면 파이프라인의 다른 사람이 로드할 수 있는데 바로 여기에서 Loader가 등장합니다. Loader를 사용하면 파일 시스템 브라우저와 비슷한 방식으로 Flow Production Tracking 내에 저장되어 있는 게시를 찾을 수 있습니다.개요Loader 앱을 사용하면 Flow Production Tracking에 게시된 파일을 빠르게 찾을 수 있습니다. 이 앱은 검색 가능한 트리 뷰 네비게이션 시스템을 갖추고 있어 태스크, 샷 또는 에셋의 썸네일을 쉽게 확인할 수 있습니다.트리 뷰왼쪽의 트리 뷰를 사용하여 원하는 샷, 에셋 또는 태스크를 빠르게 찾을 수 있습니다. 찾고 있는 항목의 이름을 알고 있는 경우 검색란에 입력하면 검색어와 일치하는 항목만 트리에 표시됩니다.검색어를 입력하기 시작하면 더 이상 전체 트리를 보는 것이 아님을 나타내는 파란색 막대가 트리 주변에 나타나고, 검색어를 기반으로 트리에 해당 항목의 하위 세트만 표시됩니다. 검색을 시작하면 트리의 모든 노드가 자동으로 확장됩니다. 트리를 마우스 오른쪽 버튼으로 클릭하면 트리의 모든 노드를 간편하게 확장 또는 축소할 수 있는 옵션이 나타납니다.네비게이션트리 뷰 맨 위에는 세 가지 네비게이션 버튼이 있습니다.홈 버튼을 클릭하면 Loader가 현재 작업 영역을 나타내는 샷 또는 에셋으로 자동으로 이동합니다. 현재 진행 중인 작업과 관련된 무언가를 빠르게 로드하고 싶을 때 유용한 기능입니다. 이 화면은 시작 시 Loader가 기본적으로 표시하는 위치이기도 합니다. 트리 뷰에서 다른 항목을 선택하면 점점 내역이 생성됩니다. 내역은 브라우저처럼 뒤로 및 앞으로 버튼을 사용하여 탐색할 수 있습니다.게시 살펴보기트리에서 항목을 선택하면 UI 가운데의 게시 영역에 사용 가능한 게시가 표시됩니다. 이 뷰의 각 항목은 게시 스트림 내 최신 항목을 나타냅니다. 예를 들어, 텍스처 버전 15를 보게 된다면 이는 해당 항목의 버전 내역에 이전 버전이 14개 있다는 의미입니다.게시뿐 아니라 샷, 시퀀스, 에셋 또는 기타 Flow Production Tracking 엔티티 유형을 나타내는 폴더 아이콘도 표시됩니다. 객체의 썸네일이 있는 경우 이 썸네일은 빠른 시각적 탐색을 위해 폴더 위에 겹쳐서 표시됩니다. 계층에서 폴더를 두 번 클릭하면 해당 폴더를 자세히 탐색합니다.뷰 모드는 두 가지입니다. 썸네일 모드는 시각적으로 찾아볼 때(예: 텍스처를 찾아볼 때) 아주 유용합니다. 목록을 빠르게 훑어보고, 줌 핸들을 사용해 빠르게 확대 및 축소할 수 있습니다.Nuke 스크립트나 Maya 파일처럼 텍스처보다 덜 시각적인 항목을 찾아보는 경우에는 썸네일 뷰 대신 목록 뷰를 사용하면 됩니다. 이 모드는 보다 많은 정보를 제공하고, 보다 콤팩트한 형태이기 때문에 많은 항목을 스크롤하면서 빠르게 살펴보기에 좋습니다.특정 유형의 항목만 보고 싶다면 왼쪽 아래에 있는 필터 패널 을 사용해 게시를 빠르게 숨기거나 표시하면 됩니다. 목록의 각 유형 옆에는 요약 정보도 나와 있는데, 현재 선택한 트리 항목에 대해 각 유형별로 몇 개의 게시를 찾았는지 알려줍니다.하나 이상의 게시를 씬으로 가져오기한 항목을 씬으로 가져오려는 경우 해당 항목을 두 번 클릭하면 Loader가 게시를 위한 기본 액션 을 실행합니다. 항목을 씬으로 추가(예: Maya에서 다른 Maya 파일을 참조하거나 씬으로 가져오려는 경우)하는 방법이 둘 이상일 수도 있는데, 이 경우에는 액션(Actions) 드롭다운 메뉴를 클릭하거나 게시에서 아무 곳이나 마우스 오른쪽 버튼으로 클릭하면 사용 가능한 모든 옵션이 나타납니다.여러 항목을 씬으로 가져오려는 경우에는 여러 항목을 선택하고 선택 모음에서 아무 항목이나 마우스 오른쪽 버튼으로 클릭하면 액션(Actions) 팝업 메뉴가 나타납니다. 선택 모음의 모든 항목에 적용할 수 있는 액션만 표시됩니다.게시 대신 샷 또는 에셋 폴더 객체를 선택하는 경우에는 해당 항목을 Flow Production Tracking 또는 파일 시스템에 표시하기 위한 옵션이 표시됩니다.이전 게시를 사용하는 작업오른쪽의 상세 정보 창을 열면 선택한 게시의 모든 버전 내역을 볼 수 있습니다. 여기에서 이전 버전을 로드할 수 있습니다. 이전 버전을 로드하려면 메인 뷰의 게시와 마찬가지로 버전 내역에서 해당 버전을 선택하고 액션 메뉴를 사용하여 로드하면 됩니다.연관 리뷰게시에 연관 리뷰 버전이 있는 경우 상세 정보 창에 재생 버튼이 표시됩니다. 이 버튼을 클릭하면 웹 페이지에서 Screening Room을 실행되어 빠르게 노트를 확인하거나 버전에 노트를 추가할 수 있고, 연관 리뷰 Quicktime을 재생할 수도 있습니다.고급 기능ShotGrid의 모든 통합은 툴킷이라는 파이프라인 생성을 위한 커스터마이즈 범위가 넓고 확장성이 뛰어난 플랫폼에서 생성됩니다. 이 기능에 액세스하고 구성하는 방법에 대한 자세한 내용은 관리자 안내서를 참조하십시오.감사의 인사  PySide의 버그 수정 버전은 Flow Production Tracking 데스크톱과 함께 배포되며 여기에서 사용할 수 있습니다.  Big Buck Bunny - footage 제공: (CC) Blender Foundation, www.blender.org이 특별 마크업(TANK_NO_HEADER)을 추가해 헤더가 없어도 된다고 문서 생성 시스템에 알리십시오.",
    "url": "/d587be80/",
    "relUrl": "/d587be80/"
  },
  "116": {
    "id": "116",
    "title": "데스크톱용 Python 3 설정",
    "content": "Python 2를 Flow Production Tracking 데스크톱의 기본 Python 버전으로 설정                    경고: 이 항목은 Flow Production Tracking Toolkit 버전 1.7.3을 사용하는 경우에만 유효하며, 최신 버전의 Flow Production Tracking Toolkit을 사용하는 경우 이러한 단계가 더 이상 필요하지 않습니다. 보안상의 이유로 Flow Production Tracking Toolkit 1.8.0이 출시되면서 2023년 1월 26일에 Python 2가 제거되었습니다. 자세한 내용은 여기를 참조하십시오.      Windows  MacOS  CentOS 7WindowsWindows에서 SHOTGUN_PYTHON_VERSION 환경을 2로 수동 설정  Windows 작업 표시줄에서 Windows 아이콘을 마우스 오른쪽 버튼으로 클릭하고 시스템을 선택한 다음 제어판/시스템 및 보안/시스템으로 이동합니다.  고급 시스템 설정을 선택합니다.  시스템 속성에서 환경 변수를 선택합니다.  환경 변수 창에서 새로 만들기…를 선택하여 경로를 추가/편집할 수 있습니다.  변수 이름으로 SHOTGUN_PYTHON_VERSION을 추가하고 변수 값을 2으로 설정합니다.  Flow Production Tracking 데스크톱 응용프로그램을 다시 시작합니다. 이제 Python 2를 실행하도록 Python 버전이 업데이트된 것을 볼 수 있습니다.MacOSMacOS에서 SHOTGUN_PYTHON_VERSION 환경을 2로 설정  이름이 my.startup.plist인 ~/Library/LaunchAgents/에서 특성 파일 작성$ vi my.startup.plist  다음을 my.startup.plist에 추가하고 저장합니다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;https://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt; &amp;lt;plist version=&quot;1.0&quot;&amp;gt; &amp;lt;dict&amp;gt;   &amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;   &amp;lt;string&amp;gt;my.startup&amp;lt;/string&amp;gt;   &amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt;   &amp;lt;array&amp;gt;     &amp;lt;string&amp;gt;sh&amp;lt;/string&amp;gt;     &amp;lt;string&amp;gt;-c&amp;lt;/string&amp;gt;     &amp;lt;string&amp;gt;launchctl setenv SHOTGUN_PYTHON_VERSION 2&amp;lt;/string&amp;gt;   &amp;lt;/array&amp;gt;   &amp;lt;key&amp;gt;RunAtLoad&amp;lt;/key&amp;gt;   &amp;lt;true/&amp;gt; &amp;lt;/dict&amp;gt; &amp;lt;/plist&amp;gt;      Mac을 재부팅하면 새 환경 변수가 활성 상태로 유지됩니다.        Flow Production Tracking 데스크톱 응용프로그램을 다시 시작합니다. 이제 Python 2를 실행하도록 Python 버전이 업데이트된 것을 볼 수 있습니다.  CentOS 7CentOS 7에서 SHOTGUN_PYTHON_VERSION 환경을 2로 설정  ~/.bashrc 파일에 다음을 추가합니다.export SHOTGUN_PYTHON_VERSION=&quot;2&quot;  다음을 실행하여 OS를 재부팅합니다.$ sudo reboot   Flow Production Tracking 데스크톱 응용프로그램을 다시 시작합니다. 이제 Python 2를 실행하도록 Python 버전이 업데이트된 것을 볼 수 있습니다.",
    "url": "/69833488/",
    "relUrl": "/69833488/"
  },
  "117": {
    "id": "117",
    "title": "소프트웨어를 실행하기 전에 환경 변수는 어떻게 설정합니까?",
    "content": "소프트웨어를 실행하기 전에 환경 변수는 어떻게 설정합니까?Flow Production Tracking 툴킷을 사용하면 실행 프로세스 중에 후크를 사용하여 환경을 구성하고 커스텀 코드를 실행할 수 있습니다.Nuke 또는 Maya와 같은 소프트웨어를 실행할 때 Flow Production Tracking 데스크톱 또는 브라우저 통합을 통해 tk-multi-launchapp가 실행됩니다.이 앱은 소프트웨어 실행을 담당하며 Flow Production Tracking 통합이 예상대로 시작되게 합니다. 이 프로세스 중에 후크를 통해 표시되는 두 지점을 사용하여 커스텀 코드를 실행할 수 있습니다.before_app_launch.pybefore_app_launch.py 후크는 소프트웨어가 실행되기 직전에 호출됩니다.이를 통해 실행된 소프트웨어에 전달될 모든 커스텀 환경 변수를 완벽하게 설정할 수 있습니다.예시:import osimport tankclass BeforeAppLaunch(tank.Hook):    def execute(self, app_path, app_args, version, engine_name, **kwargs):        if engine_name == &quot;tk-maya&quot;:            os.environ[&quot;MY_CUSTOM_MAYA_ENV_VAR&quot;] = &quot;Some Maya specific setting&quot;                    경고: Flow Production Tracking에서 설정된 환경 변수를 완전히 다시 정의하지 않도록 주의해야 합니다.예를 들어 NUKE_PATH(Nuke) 또는 PYTHONPATH(Maya)에 경로를 추가해야 하는 경우 경로를 변경하는 대신 기존 값에 경로를 추가해야 합니다.이 경우 다음과 같이 편리한 방법을 사용할 수 있습니다.tank.util.append_path_to_env_var(&quot;NUKE_PATH&quot;, &quot;/my/custom/path&quot;)    커스텀 래퍼일부 스튜디오에서는 환경 변수 설정 및 소프트웨어 실행을 처리하는 커스텀 래퍼를 사용합니다.이와 같은 커스텀 코드를 사용하여 환경을 설정하려는 경우 Software 엔티티의 경로 필드를 실행 가능한 래퍼로 지정하면 tk-multi-launchapp이 대신 실행합니다.                    경고: 이 경우 Flow Production Tracking에서 설정한 환경 변수를 유지해야 합니다. 그러지 않으면 통합이 시작되지 않습니다.    ",
    "url": "/624f2593/",
    "relUrl": "/624f2593/"
  },
  "118": {
    "id": "118",
    "title": "Setup",
    "content": "Flow Production Tracking Isolation Feature Set - SetupIsolation the isolation features are independent of each other, and can be activated independently of each other. Media replication have as pre-requisite for Media Isolation to be implemented.The setup process will depend on which feature you want to activate for your site.In This Section  Planning your Setup  Media Isolation  Media Traffic Isolation  Media Replication  Isolation Fine Tuning  ActivationSetup OverviewUnderstand your responsibilitiesMake sure that you understand the client responsibilities and the implication of activating any of the Isolation feature.Start the onboarding processLeveraging the isolation features requires adopters to become AWS users. The features activation also requires Autodesk Support intervention. In order to ensure that this joint venture between Autodesk, AWS, and our clients is as streamlined as possible, we decided to work closely with AWS to define a cooperative onboarding process that would meet client expectations for a premium offering. Kick-start the onboarding process before going further.Planning your SetupBefore you start working on your setup, put a plan in place. Choose the features you need and get the required security/legal approval from your team to get started with the Isolation feature set.Media IsolationThis feature allow you to use a S3 Bucket owned by your studio to store media.Media Traffic IsolationThis feature allows for private routing of the media through the AWS Backbone and your studio network, isolating the media traffic from the public internet.Media ReplicationThis feature allows the media to be replicated between AWS Regions, for faster access in your world wide studios. Media Isolation is required.Fine TuningOnce the isolation features you need are activated, make sure that you everything is properly configured for security and cost-efficiency by reviewing this fine tuning guide.ActivationOnce everything is ready, it’s now time to migrate your production site to use the isolation features.",
    "url": "/8128c5fb/",
    "relUrl": "/8128c5fb/"
  },
  "119": {
    "id": "119",
    "title": "Flow Production Tracking 데스크톱이 Ubuntu 같은 Debian 시스템에서도 작동합니까?",
    "content": "Flow Production Tracking 데스크톱이 Ubuntu 같은 Debian 시스템에서도 작동합니까?현재는 Flow Production Tracking 데스크톱용 Debian 기반 배포판을 지원하지 않습니다.과거에 몇몇 고객이 이를 구현하려고 했던 적이 있었는데, cpio를 사용하여 RPM에서 Flow Production Tracking 데스크톱을 추출한 다음 라이브러리 종속성을 충족하려고 했지만 그리 좋은 결과를 내진 못했습니다. 추가 내용은 dev 그룹에서 이 스레드를 확인할 수 있습니다.Python 자체가 많은 시스템 레벨 라이브러리 위에 위치하기 때문에 명시적인 라이브러리 종속성 목록은 없습니다.지금으로서는 Debian 지원에 대한 공식적인 계획이 없습니다. Ubuntu를 위한 빌드에는 문제가 있지만 한편으로는 결코 사소하다고 할 수 없는 변화를 구현하다 보면 추가 운영 체제를 QA 및 지원해야 할 필요도 있습니다.Flow Production Tracking 데스크톱 없이 툴킷을 수동으로 실행 및 활성화하려는 경우(여기 문서에서 설명) - 설명서 페이지에서 activate_shotgun_pipeline_toolkit.py 스크립트를 다운로드하십시오. 이 안내서의 8단계에 있으며, “다운로드하려면 클릭…“(click to download…) 헤더를 클릭하면 됩니다.",
    "url": "/3830df9d/",
    "relUrl": "/3830df9d/"
  },
  "120": {
    "id": "120",
    "title": "앱 개발",
    "content": "자체 앱 개발소개이 안내서에서는 툴킷 앱의 정의, 툴킷 앱을 제작하는 방법 및 앱 개발과 관련한 몇 가지 기본적인 사항에 대해 설명합니다. Flow Production Tracking Toolkit은 Flow Production Tracking 소프트웨어가 관리하는 앱과 엔진의 모음일 뿐 아니라 커스텀 파이프라인 도구를 빠르고 쉽게 빌드할 수 있게 해 주는 개발 플랫폼이기도 합니다!  툴킷 앱이란?  자체 앱 제작단계:  개발 샌드박스 생성  초보자 앱 리포지토리 포크(fork) 또는 다운로드  구성에 앱 추가  앱 개발          템플릿 스타터 앱의 구조      구성 설정      프레임워크      변경 사항 다시 로드        테스트  첫 번째 릴리즈 준비추가 정보:  기존 앱 수정          기여      툴킷 앱이란?툴킷 앱은 다음과 같이 정의할 수 있습니다.  일반적으로 최종 사용자가 Flow Production Tracking 통합을 통해 실행하는 도구입니다.  앱은 대개 사용자가 앱의 작업을 안내할 수 있는 그래픽 사용자 인터페이스를 갖추고 있지만 필수 사항은 아닙니다. 또한 앱은 통합에 등록된 명령일 수 있습니다. 이러한 명령은 호스트 소프트웨어의 Flow Production Tracking 메뉴에서 사용자가 실행할 수 있습니다.  다른 프로세스 또는 앱이 상호 작용할 수 있는 API/공용 방식을 가질 수 있습니다.  다중 플랫폼에 기반하며 소프트웨어에 구속받지 않습니다.  환경별로 다르게 구성할 수 있습니다.  컨텍스트를 인식할 수 있습니다. 예를 들어 앱은 사용자가 작업 중인 태스크를 인식하고 그에 따라 작업을 수행할 수 있습니다.  툴킷 엔진에서만 실행할 수 있습니다.툴킷 앱은 툴킷 엔진에 의해 초기화됩니다. 엔진은 특정 소프트웨어 환경에서 실행되도록 설계되었으며 툴킷 앱을 실행할 인터페이스를 제공합니다. 엔진은 앱에서 다양한 소프트웨어 환경을 처리하는 데 필요한 복잡성을 추상화합니다. 따라서 앱은 해당 목적을 이행하기 위한 기능을 제공하는 데만 중점을 두며 창 부모-자식 관리, 사용자의 컨텍스트 추적 또는 앱 시작 단축키 등의 기능을 처리할 필요가 없습니다.자체 앱 제작Flow Production Tracking 소프트웨어를 통해 관리 및 릴리즈되는 모든 앱과 엔진은 오픈 소스로, GitHub에서 찾아볼 수 있습니다.이 섹션에서는 스타터 템플릿을 사용하여 새 앱을 생성하는 방법을 살펴봅니다. 사용자들이 이미 GitHub 및 git 워크플로우에 익숙할 것으로 생각되기는 하지만 git을 소스 제어 솔루션으로 사용하고 있지 않더라도 툴킷 개발은 얼마든지 진행할 수 있습니다.1부: 개발 샌드박스 생성시작하기 전에 프로젝트 구성을 복제하여 개발 샌드박스를 설정하는 것이 좋습니다. 이렇게 하면 프로덕션에 참여하는 다른 누구에게도 영향을 미치지 않고 코드 개발 및 변경 사항 테스트를 수행할 수 있는 별도의 구성이 만들어집니다.2부: 스타터 앱 리포지토리 포크(fork) 또는 다운로드자체 앱의 시작점으로 사용할 수 있는 템플릿 스타터 앱을 제공합니다. 이 앱을 사용하면 본인에게 맞게 설정된 모든 표준 툴킷 보일러플레이트(boilerplate) 코드 및 기본 예제 GUI를 가져올 수 있습니다.이 방식을 사용하려면 git 리포지토리를 포크(fork)한 다음 디스크의 로컬 dev 영역에 복제하거나, 이 단계에서 git 소스 제어를 사용하지 않으려면 GitHub에서 파일을 zip 파일로 다운로드하고 로컬에 압축을 풀면 됩니다(나중에 언제든지 git 리포지토리를 설정할 수 있음). 어느 방법을 사용하든 목표는 스타터 앱 코드의 로컬 사본을 만들어 수정할 수 있도록 하는 것입니다.3부: 구성에 앱 추가구성에 앱을 추가하는 방법에 대한 자세한 내용은 “앱 추가” 안내서를 참조하십시오.앱을 구성에 추가할 때는 앱이 사용되는 위치(예: Nuke에서만 사용, 여러 다른 소프트웨어 또는 Flow Production Tracking 데스크톱에서 독립 실행형으로 사용)를 고려해야 합니다. 또한 앱의 기반 컨텍스트도 고려해야 합니다. 예를 들어 사용자가 작업 중인 태스크에 대해 알고 있는 경우에만 앱을 실행하거나, 알려진 프로젝트에서만 실행할 수 있습니까? 이을 알면 그에 맞게 앱 설정을 추가해야 하는 환경 YAML 및 엔진을 지정합니다.확실하지 않을 경우에는 먼저 프로젝트 환경의 tk-shell 엔진에 추가해 두는 것이 좋습니다. 이 방법을 사용하면 IDE에서 실행하거나, 중앙 집중식 구성이 있는 경우에는 tank 명령을 사용하여 명령행을 통해 실행할 수 있습니다. 이렇게 하면 개발 속도가 빨라집니다.시작하려면 앱 위치로 dev 디스크립터를 사용합니다.tk-multi-starterapp:  location:    type: dev    path: /path/to/source_code/tk-multi-starterapp이렇게 하면 코드를 변경하고 싶은 경우에는 언제든지, 툴킷이 개발에 용이한 지정된 위치의 디스크에서 직접 앱 코드를 로드합니다. 나중에 앱을 프로덕션 구성에 추가할 때는 다른 디스크립터를 사용할 수 있습니다.이제 앱을 환경에 추가했으니 앱을 실행할 수 있습니다. 실행하는 방법은 정의한 엔진 및 환경에 따라 다릅니다.4부: 앱 개발이제 앱 개발을 시작할 준비가 되었습니다.템플릿 스타터 앱의 구조템플릿 스타터 앱의 기본 구조는 다음과 같습니다.  app.py - 앱 진입점 및 메뉴 등록은 app.py 파일에서 찾을 수 있습니다. 이 파일에서 보통 클래스를 설정하고, 항목을 초기화하고, 메뉴 항목을 등록합니다.  info.yml - 매니페스트 파일이라고도 합니다. 앱 설치 시 필요한 다른 모든 설정과 해당하는 기본값(제공할 경우)을 정의합니다. 재사용 가능한 앱을 원하고, 앱 자체에서는 어떠한 값도 하드 코딩하고 싶지 않은 경우 대개 이러한 설정이 유용합니다.  python/app/dialog.py - 여기에는 기본 앱 창을 생성하는 로직, 이벤트 콜백 등이 포함됩니다.  python/app/ui - 이 폴더에는 자동 생성된 UI 코드 및 리소스 파일이 포함됩니다. 이 파일을 직접 편집하지 말고, 대신 resources 폴더의 Qt UI 파일을 편집하십시오.  resources/ - resources 폴더에 있는 dialog.ui 파일은 사용자가 열어서 앱의 모양을 빠르게 디자인하고 정의하는 데 사용할 수 있는 QT Designer 파일입니다. 변경한 후에는 build_resources.sh 스크립트를 실행하여 UI 파일을 Python 코드로 변환하고 /python/app/ui/dialog.py로 저장해야 합니다.  style.qss - 이 파일에서 UI에 대한 QSS(Qt 스타일 시트)를 정의할 수 있습니다.                    참고: UI는 앱의 필수 사항이 아닙니다. 유효한 앱에 대한 최소 요구 사항은 Application 클래스와 info.yml을 포함하는 app.py입니다.    구성 설정매니페스트 파일 내에 configuration 섹션이 있어야 하며, 여기서 앱 설정을 정의할 수 있습니다.매니페스트 파일의 설정을 정의하면 환경 YAML 파일에서 앱에 대해 다른 설정 값을 구성할 수 있습니다. 이 기능은 앱이 환경에 따라 다르게 동작해야 하는 경우에 유용합니다.예를 들어 파일을 저장할 때 사용할 템플릿을 정의하는 설정을 지정할 수 있습니다.save_template:    type: template    default_value: &quot;maya_asset_work&quot;    description: The template to use when building the path to save the file into    allows_empty: False이 설정을 지정하면 앱 코드에서 템플릿 이름을 하드 코딩할 필요가 없고 대신 info.yml에 기본적으로 정의되거나 환경 YAML 파일에서 재정의된 설정에서 값을 가져올 수 있습니다.template = app.get_setting(&quot;save_template&quot;)즉, 앱이 실행되는 환경에 따라 다른 템플릿을 사용하도록 앱을 구성할 수 있습니다.참조 문서에서 구성 설정에 대한 자세한 내용을 확인할 수 있습니다.프레임워크앞으로 프레임워크를 사용할 것이라면 프레임워크를 매니페스트 파일에 추가할 수 있습니다.예를 들어 Qt Widgets 및 Flow Production Tracking 유틸리티 프레임워크를 앱에 사용할 것이라면 다음을 info.yml에 추가하십시오.# the frameworks required to run this appframeworks:    - {&quot;name&quot;: &quot;tk-framework-shotgunutils&quot;, &quot;version&quot;: &quot;v2.x.x&quot;}    - {&quot;name&quot;: &quot;tk-framework-qtwidgets&quot;, &quot;version&quot;: &quot;v1.x.x&quot;}최소한으로 필요한 프레임워크 버전최소한으로 필요한 프레임워크 버전이 있다면 minimum_version 설정을 info.yml에서 사용할 수 있습니다.# the frameworks required to run this appframeworks:    - {&quot;name&quot;: &quot;tk-framework-shotgunutils&quot;, &quot;version&quot;: &quot;v2.x.x&quot;}    - {&quot;name&quot;: &quot;tk-framework-qtwidgets&quot;, &quot;version&quot;: &quot;v1.x.x&quot;, &quot;minimum_version&quot;: &quot;v1.5.0&quot;}위 내용은 tk-framework-qtwidgets의 v1.5.0을 앱에 사용할 수 있도록 해줍니다. 그렇지 않으면 앱이 시작 시 로드되지 않고, 콘솔에 오류가 표시됩니다. tank updates를 사용하여 앱을 업데이트하면 구성되어 있는 프레임워크 중 최소한으로 필요한 버전을 충족하지 않는 프레임워크는 자동으로 앱과 함께 업데이트됩니다.프레임워크와 그 유용성에 대한 자세한 정보는 다음 링크에서 확인하십시오.  QT Widgets 프레임워크  Flow Production Tracking 유틸리티 프레임워크변경 사항 다시 로드Maya 등의 소프트웨어 내에서 앱을 테스트하는 경우, 구성에 하나 이상의 dev 항목을 추가한 즉시 툴킷에서 자동으로 Flow Production Tracking 메뉴에 다시 로드 및 다시 시작(Reload and Restart) 옵션을 추가합니다. 이 버튼을 클릭하면 구성 및 코드가 다시 로드되고 엔진이 다시 시작됩니다. 즉, Maya를 시작하고, 시도해 보려는 코드나 구성 변경을 적용할 때마다 다시 로드 및 다시 시작(Reload and Restart) 버튼을 누르기만 하면 변경 사항을 가져오는 과정을 빠르게 반복할 수 있습니다.                    참고: 화면에 활성 상태인 UI가 있는 경우 이 UI는 자동으로 업데이트되지 않으며, 메뉴에서 해당 UI로 이동하여 다시 실행해 주어야 합니다.    5부: 테스트코드를 테스트하려면 다른 사용자들을 Flow Production Tracking에서 PipelineConfiguration 엔티티의 User Restrictions 필드에 추가하여 dev 샌드박스로 초대하기만 하면 됩니다. 사용자를 추가하면 바로 Flow Production Tracking Create 및 브라우저 액션 내의 메뉴에 새 항목이 표시되고, Flow Production Tracking 데스크톱 내부에서 구성을 선택하는 옵션도 제공됩니다.                    참고: 사용자들이 앱 코드에도 액세스하여 볼 수 있도록 해야 합니다. 그렇지 않으면 앱이 로드되지 않습니다.    6부: 첫 번째 릴리즈 준비3부에서는 dev 디스크립터를 사용하여 앱을 가리키도록 구성을 설정했습니다. 릴리즈한 소프트웨어의 경우 모든 사용자가 앱에 액세스할 수 있고 안전하고 쉽게 업그레이드할 수 있도록 버전이 지정되어야 할 것입니다.ShotGrid에서 제공하는 모든 앱은 툴킷 앱 스토어를 사용하여 업데이트 및 릴리즈를 트래킹합니다. 앱은 다음과 비슷한 형식의 위치 태그를 가집니다.location:   name: tk-multi-setframerange   type: app_store   version: v0.1.7이 태그를 통해 툴킷(예: tank updates 명령)은 업데이트가 제공될 때 이를 확인하여 매우 안전한 방식으로 구성을 업데이트 및 관리할 수 있습니다. 업데이트 명령이 실행되고 새 버전이 나올 때마다 툴킷은 코드를 다운로드하여, 디스크의 로컬 “번들 캐시”에 배치하고, 사용자가 여기에 액세스할 수 있도록 합니다.앱 릴리즈를 소싱하는 몇 가지 옵션이 있습니다.  Git 및 GitHub  Flow Production Tracking 업로드  로컬 경로프로덕션 구성에서 앱을 추가하고 필요에 맞는 디스크립터를 사용하도록 전환합니다.Git 기반 디스크립터git 디스크립터 사용 여부에 관계없이 소스 제어를 사용하여 변경 사항이 트래킹되게 하는 것이 좋습니다.툴킷은 기본적으로 git(https://git-scm.com/)을 지원하므로 구성에서 tank updates를 실행할 경우에도 앱 스토어 디스크립터와 마찬가지로 git 리포지토리에서 최신 릴리즈를 확인하고 구성을 업데이트할 수 있습니다.이에 대한 요구 사항은 다음과 같습니다.  git 리포지토리에는 단일 앱만 포함되어야 합니다.  git 리포지토리의 구조는 스타터 앱 리포지토리와 같아야 합니다.  태그를 생성할 때는 시맨틱(Semantic) 버전을 사용해야 합니다. 툴킷은 이 버전 번호를 사용하여 어느 버전이 최신인지 판단하고 vX.Y.Z 규칙을 따릅니다.git에 첫 번째 태그를 생성하고 나면(예: v1.0.0) 태그를 가리키는 git 디스크립터를 사용하도록 구성을 설정할 수 있습니다. 설정하고 나면 tank updates를 간단히 실행할 수 있고, 새 태그가 생성되었다면 업그레이드할지 묻는 메시지가 나타납니다. 이제 워크플로우는 공식 앱 스토어 앱의 경우와 동일합니다.                    주의: git 디스크립터는 중앙 집중식 구성에서 잘 작동합니다. 중앙 집중식 구성에서 앱 캐싱은 일반적으로 관리자(Admin)가 실행하며 모든 사용자가 액세스할 수 있는 중앙 위치에 저장됩니다. 그러나 분산 구성을 사용하는 경우에는 적합하지 않을 수 있습니다. 앱이 사용자별로 다운로드되므로 각 사용자가 리포지토리에서 인증받고 코드에 액세스하기 위해 git를 설치하고 설정해야 합니다.    기존 앱 수정빈 스타터 템플릿으로 시작하는 것보다 기존 앱(예: Flow Production Tracking 소프트웨어의 표준 앱 중 하나)에 작은 기능을 추가하는 것이 좋을 때도 있습니다. 수정된 버전의 앱으로 작업할 때에는 보통 소스 앱과 비교하여 차이점을 ‘트래킹’하면서 변경 사항이나 버그 픽스를 정기적으로 끌어오는 방식을 사용합니다.이러한 유형의 개발을 진행할 때에는 부모 코드를 픽업한 다음 일부 변경 사항을 적용하고, 이를 파이프라인에 릴리즈합니다. 릴리즈는 실질적으로 앱의 기본 버전과 여러분이 적용한 로컬 변경 사항으로 구성됩니다. 기존 버전 번호에 버전 접미사를 추가하는 것이 좋습니다. 이렇게 하면 툴킷과 매끄럽게 연동되고, 비교적 직관적인 방법입니다. 다음 워크플로우는 진행 방식을 보여 줍니다.  부모 앱을 포크(fork)하고, 자체 리포지토리를 생성합니다. 포크(fork)를 통해 모든 git 태그를 가져옵니다. 최신 태그는 v0.2.12이며, 마스터 분기는 기본적으로 이 태그의 컨텐츠와 동일하다고 가정해 보겠습니다.  변경 사항을 적용하고 마스터 분기로 커밋합니다. 이제 v0.2.12 및 변경 사항이 준비되었습니다. 이를 프로덕션으로 릴리즈할 때 태그를 생성해야 합니다. 태그 이름을 v0.2.12.1로 지정하여 코드가 v0.2.12를 기반으로 하고 있으며, 이것이 첫 번째 릴리즈임을 나타냅니다.  누군가가 수정 사항에서 버그를 발견합니다. 버그를 수정하고, 태그를 지정한 다음 v0.2.12.2를 릴리즈합니다.  다수의 중요한 버그 픽스가 부모 리포지토리에 릴리즈되었습니다. 이를 여러분의 리포지토리로 끌어옵니다. 이제 가장 최신 태그는 부모 리포지토리에서 이루어진 릴리즈로 인해 v0.2.15가 됩니다. 변경 사항을 마스터와 병합하고, 테스트합니다. 이제 기본적으로 부모 앱 v0.2.15에 변경 사항이 병합됩니다. v0.2.15.1에 태그를 지정합니다.위에서 설명한 태그 지정 체계를 따르면 툴킷 업데이트가 올바로 작동하고, 포크(fork)의 각 태그가 어느 코드를 기반으로 하는지 쉽고 빠르게 확인할 수 있습니다.기여저희는 여러분들의 요청을 환영합니다. 다른 사람에게도 도움이 될 만한 변경 사항이 있다면 주저하지 말고 사용자 요청으로 알려 주십시오. 피드백을 앱의 메인 버전에 적용할 수도 있을 것입니다. 또는 로드맵 페이지에 새 아이디어에 대한 제안서를 추가하십시오.커뮤니티와 공유하려는 전체 앱을 작성한 경우 포럼을 통해 알려 주십시오.",
    "url": "/2e5ed7bb/",
    "relUrl": "/2e5ed7bb/"
  },
  "121": {
    "id": "121",
    "title": "앱 부트스트랩 및 실행",
    "content": "앱 부트스트랩(Bootstrapping) 및 실행이 안내서에서는 커스텀 코드를 실행하거나 앱을 시작할 수 있도록 툴킷 엔진을 초기화하는 과정을 안내합니다. 부트스트랩(Bootstrapping)이라고도 하는 과정입니다.부트스트랩(Bootstrapping)은 툴킷 엔진이 아직 시작되지 않고 API를 사용해야 하는 경우에 유용합니다.예를 들어 렌더 팜에서 실행되는 처리 스크립트가 있을 수 있고 툴킷 API를 활용하여 경로 및 컨텍스트를 처리해야 할 수 있습니다.또는 즐겨찾는 IDE에서 툴킷 앱을 실행할 수도 있습니다.                    참고: 분산 구성을 사용하는 경우 툴킷 엔진은 툴킷 API 방식을 실행하기 전에 초기화되어야 합니다. 중앙 집중식 구성을 사용하는 경우 엔진을 부트스트랩(Bootstrapping)하지 않고 팩토리 방식을 사용하여 API를 사용할 수 있지만 sgtk를 가져올 때 프로젝트에 맞는 올바른 Core API의 경로를 수동으로 찾아야 합니다.    요구사항  Python 프로그래밍 기본 사항에 대한 이해  고급 구성을 사용하는 프로젝트. 구성을 설정하지 않은 경우 “구성 시작하기” 안내서를 참조하십시오.단계  부트스트랩(Bootstrapping)을 위한 툴킷 API 가져오기  로깅  인증  엔진 부트스트랩(Bootstrapping)  앱 시작  전체 스크립트1부: 부트스트랩(Bootstrapping)을 위한 툴킷 API 가져오기어디에서 sgtk를 가져와야 합니까?“경로 생성 및 게시” 안내서에 sgtk 가져오기 단계에 대해 나와 있습니다.이 안내서에는 작업할 프로젝트 구성에서 sgtk 패키지를 가져와야 한다고 설명되어 있습니다.맞는 설명이기는 하지만 부트스트랩(Bootstrapping)을 사용할 경우에는 툴킷 API가 다른 프로젝트 구성으로 부트스트랩 작업을 수행할 수 있으므로 어떤 초기 sgtk 패키지를 가져오는지는 중요하지 않습니다.부트스트랩(Bootstrap) 프로세스는 현재 가져온 sgtk 패키지를 새 프로젝트 구성의 툴킷 API로 교체합니다.독립 실행형 Toolkit Core API 다운로드시작하려면 tk-core에 있는 sgtk API 패키지를 가져와야 합니다.기존 프로젝트에서 가져올 수도 있지만 이 방법은 좀더 까다로울 수 있습니다.권장되는 방법은 순수하게 부트스트랩(Bootstrapping) 용도로 사용되는 최신 Core API의 독립 실행형 사본을 다운로드하는 것입니다.이 파일을 편리하게 가져올 수 있는 위치에 저장해야 합니다.추가하는 경로가 sgtk 패키지가 위치하는 tk-core 폴더 내의 python 폴더를 가리키는지 확인하십시오.코드# If your sgtk package is not located in a location where Python will automatically look# then add the path to sys.path.import syssys.path.insert(0, &quot;/path/to/tk-core/python&quot;)import sgtk2부: 로깅IDE 또는 셸을 통해 이 스크립트를 실행 중인 경우 대부분은 로깅을 활성화하여 출력되게 할 수 있습니다.이렇게 하려면 LogManager().initialize_custom_handler()를 실행해야 합니다.이 작업을 위해 커스텀 처리기를 제공할 필요는 없습니다. 커스텀 처리기를 제공하지 않으면 표준 스트림 기반의 로깅 처리기가 설정됩니다.필요한 경우 LogManager().global_debug = True를 설정하여 보다 상세하게 출력을 표시할 수도 있습니다.이렇게 설정하면 코드에서 logger.debug() 호출 시 출력이 수행됩니다.로깅은 성능에 영향을 줄 수 있으므로 개발 시에만 디버그 로깅을 활성화하고 정상 작동 중에 가시성을 높이는 것이 중요한 영역에 대한 logger.info() 방식 호출의 양을 제한해야 합니다.import sgtk# Initialize the logger so we get output to our terminal.sgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing).sgtk.LogManager().global_debug = True3부: 인증Flow Production Tracking 툴킷이 이미 시작된 환경 외부에서 툴킷 API를 사용하는 스크립트를 실행하는 경우 항상 인증을 거쳐야 합니다.따라서 부트스트랩(Bootstrapping)을 수행하려면 먼저 Flow Production Tracking 사이트에서 툴킷 API를 인증받아야 합니다.사용자 자격 증명 또는 스크립트 자격 증명으로 인증받을 수 있습니다.  앱 시작 또는 사용자 입력이 필요한 일부 코드를 실행하는 등 사용자 대상 프로세스를 부트스트랩(Bootstrapping)하는 것이 목적이라면 사용자 인증을 진행하는 것이 가장 좋습니다(모든 통합의 기본적인 작동 방식임).  스크립트를 작성하여 자동화하려고 할 때 사용자가 아직 인증되지 않은 경우 스크립트 자격 증명을 사용해야 합니다.인증은 Flow Production TrackingAuthenticator 클래스를 통해 처리됩니다.다음은 사용자 인증과 스크립트 인증을 모두 보여 주는 예입니다.사용자 인증# Import Toolkit so we can access to Toolkit specific features.import sgtk# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Optionally you can clear any previously cached sessions. This will force you to enter credentials each time.authenticator.clear_default_user()# The user will be prompted for their username,# password, and optional 2-factor authentication code. If a QApplication is# available, a UI will pop-up. If not, the credentials will be prompted# on the command line. The user object returned encapsulates the login# information.user = authenticator.get_user()# Tells Toolkit which user to use for connecting to Flow Production Tracking. Note that this should# always take place before creating an `Sgtk` instance.sgtk.set_authenticated_user(user)스크립트 인증# Import Toolkit so we can access to Toolkit specific features.import sgtk# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your Flow Production Tracking site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to Flow Production Tracking.sgtk.set_authenticated_user(user)4부: 엔진 부트스트랩(Bootstrapping)이제 세션을 위해 툴킷 API를 인증받았으므로 부트스트랩(Bootstrapping) 프로세스를 시작할 수 있습니다.참조 문서에서 부트스트랩(Bootstrap) API에 관한 많은 정보를 확인할 수 있습니다.부트스트랩(Bootstrapping) 프로세스는 기본적으로 다음과 같은 단계를 수행합니다.  툴킷 구성 폴더를 검색하거나 찾습니다.  앱 및 엔진과 같은 구성 종속 요소가 번들 캐시에 있는지 확인합니다.구성 종속 요소가 없고 app_store 또는 Flow Production Tracking과 같은 클라우드 기반 디스크립터를 사용하는 경우 번들 캐시에 이러한 디스크립터를 다운로드합니다.  현재 로드된 Sgtk Core를 구성에 적합한 Sgtk Core로 교체합니다.  엔진, 앱 및 프레임워크를 초기화합니다.                    참고: 일반적으로 부트스트랩(Bootstrapping)은 해당 엔진이 성공적으로 실행되기 위해 필요한 모든 사항을 처리합니다.그러나 엔진이 부트스트랩(Bootstrapping) 프로세스를 벗어나는 설정 요구사항을 가지고 있다면 개별적으로 처리해야 할 수도 있습니다.    부트스트랩(Bootstrap) 준비부트스트랩(Bootstrap)하려면 먼저 ToolkitManager 인스턴스를 작성해야 합니다.mgr = sgtk.bootstrap.ToolkitManager(user)  user가 ToolkitManager의 이니셜라이저로 전달되지 않는 경우 ShotgunAuthenticator().get_user()가 내부적으로 호출되어 현재 인증된 Flow Production Tracking 사용자를 반환합니다. 다른 HumanUser 또는 ScriptUser를 사용하여 부트스트랩하려면 ShotgunAuthenticator.create_session_user 또는 ShotgunAuthenticator.create_script_user를 통해 생성된 사용자를 전달합니다.툴킷을 부트스트랩(Bootstrapping)하려면 최소한 엔티티, 플러그인 ID 및 엔진에 대해 알아야 합니다.이 안내서에서는 사용 가능한 모든 매개변수와 옵션 중 일부만을 설명합니다. 전체 내용은 참조 문서에서 참조하십시오.플러그인 ID부트스트랩(Bootstrap) 방식을 호출하기 전에 문자열을 ToolkitManager.plugin_id 매개변수로 전달하여 플러그인 ID를 정의할 수 있습니다.이 안내서에서는 참조 문서에 설명된 규칙에 따라 적합한 플러그인 ID 이름을 제공해야 하므로 tk-shell 엔진을 부트스트랩(Bootstrapping)합니다.mgr.plugin_id = &quot;basic.shell&quot;엔진Maya 또는 Nuke와 같은 소프트웨어 외의 독립 실행형 Python 환경에서 앱을 시작하거나 툴킷 코드를 실행하는 것이 목표인 경우 tk-shell이 부트스트랩(Bootstrapping)할 엔진입니다.지원되는 소프트웨어 내에서 툴킷 앱을 실행하려는 경우 적절한 엔진(예: tk-maya 또는 tk-nuke)을 선택해야 합니다.이 매개변수는 ToolkitManager.bootstrap_engine() 방식에 직접 전달됩니다. 아래 엔티티 섹션의 예를 참조하십시오.엔티티ToolkitManager.bootstrap_engine() 방식 entity 매개변수는 시작한 엔진에 대해 컨텍스트 및 환경을 설정하는 데 사용됩니다.이 엔티티는 구성이 작동하도록 설정된 엔티티 유형 중 하나일 수 있습니다.예를 들어 Project 엔티티를 제공하는 경우 엔진은 프로젝트 환경 설정을 사용하여 프로젝트 컨텍스트에서 시작됩니다.마찬가지로, 태스크가 Asset에 링크되어 있는 Task 엔티티를 제공할 수 있으며, 이 엔티티는 asset_step.yml 환경을 사용하여 시작됩니다.이는 기본 구성 동작을 기반으로 하며, 선택한 환경은 코어 후크, pick_environment.py를 통해 제어되므로 컨텍스트 또는 기타 매개변수를 기반으로 다른 환경을 선택하도록 변경할 수 있습니다.유형과 ID를 하나 이상 포함해야 하는 Flow Production Tracking 엔티티 사전(dictionary) 형식으로 엔티티를 제공해야 합니다.task = {&quot;type&quot;: &quot;Task&quot;, &quot;id&quot;: 17264}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=task)Project 외의 다른 엔티티 유형으로 부트스트랩(Bootstrapping)하는 경우 경로 캐시가 동기화되어 있는지 확인해야 할 수 있습니다. 그렇지 않으면 템플릿을 해석하려고 시도하는 등의 경우에 환경을 로드할 수 없을 수 있습니다.부트스트랩하기 전에는 Sgtk 인스턴스가 없으므로 부트스트랩(Bootstrapping) 프로세스가 Sgtk 인스턴스를 생성한 후, 엔진을 시작하기 전에 동기화하도록 해야 합니다.이 작업은 ToolkitManager.pre_engine_start_callback 특성을 커스텀 방식을 가리키도록 설정하여 수행할 수 있습니다.그런 다음 해당 방식으로 동기화를 실행할 수 있습니다.def pre_engine_start_callback(ctx):    '''    Called before the engine is started.    :param :class:&quot;~sgtk.Context&quot; ctx: Context into        which the engine will be launched. This can also be used        to access the Toolkit instance.    '''    ctx.sgtk.synchronize_filesystem_structure()mgr.pre_engine_start_callback = pre_engine_start_callback구성 선택부트스트랩할 구성을 명시적으로 정의할 수도 있고 부트스트랩(Bootstrapping) 로직이 적절한 구성을 자동 감지하도록 할 수도 있습니다.적절한 구성이 자동으로 감지되지 않는 경우 폴백 구성을 설정할 수도 있습니다.이 안내서에서는 프로젝트에 이미 구성이 설정되어 있고 자동으로 검색된다고 가정합니다.부트스트랩(Bootstrapping)모든 ToolkitManager 매개변수가 설정된 경우 ToolkitManager.bootstrap_engine() 방식을 호출하면 엔진이 시작되고 엔진 인스턴스로 포인터가 반환됩니다.다음은 지금까지 코드의 요약입니다.# Import Toolkit so we can access to Toolkit specific features.import sgtk# Initialize the logger so we get output to our terminal.sgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing).sgtk.LogManager().global_debug = True# Authentication################# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your Flow Production Tracking site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to Flow Production Tracking.# This is actually not necessary when using the ToolkitManager. The authenticated user will be set# before launching the engine.# sgtk.set_authenticated_user(user)# Bootstrap############ create an instance of the ToolkitManager which we will use to set a bunch of settings before initiating the bootstrap.mgr = sgtk.bootstrap.ToolkitManager(user)mgr.plugin_id = &quot;basic.shell&quot;project = {&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=project)5부: 앱 시작이제 엔진 인스턴스가 있으므로 툴킷 API를 사용할 준비가 되었습니다.앱을 시작하는 방법을 설명하기 전에 엔진을 통해 현재 컨텍스트, Sgtk 인스턴스 및 Flow Production Tracking API 인스턴스를 확인할 수 있습니다.engine.contextengine.sgtkengine.shotgun이 안내서의 최종 목표는 앱 시작 방법을 보여 주는 것입니다. 이 시점에서 위의 속성을 사용하여 일부 코드 조각을 테스트하거나 툴킷 API를 사용하는 일부 자동화를 실행할 수 있습니다.앱 시작엔진이 시작되면 환경에 대해 정의된 모든 앱이 초기화됩니다.앱이 차례로 엔진에 명령을 등록하며, Maya와 같은 소프트웨어에서 실행하는 경우 엔진은 대개 이 명령을 메뉴에 액션으로 표시합니다.명령 찾기등록된 명령을 먼저 확인하려면 Engine.commands 특성을 출력하면 됩니다.# use pprint to give us a nicely formatted output.import pprintpprint.pprint(engine.commands.keys())&amp;gt;&amp;gt; ['houdini_fx_17.5.360', 'nukestudio_11.2v5', 'nukestudio_11.3v2', 'after_effects_cc_2019', 'maya_2019', 'maya_2018', 'Jump to Screening Room Web Player', 'Publish...',...]출력된 목록에서 등록된 명령 및 실행 가능한 명령을 확인할 수 있습니다.명령 실행현재 표준화된 방식이 없으므로 명령을 실행하는 방법은 엔진에 따라 달라집니다.tk-shell 엔진의 경우 편리한 Engine.execute_command() 방식을 사용할 수 있습니다.앞의 목록에 있는 명령 문자열 이름과 앱의 명령을 전달할 매개변수 목록이 필요합니다.if &quot;Publish...&quot; in engine.commands:    # Launch the Publish app, and it doesn't require any arguments to run so provide an empty list.    engine.execute_command(&quot;Publish...&quot;,[])tk-shell 엔진에서 실행하지 않는 경우 등록된 콜백을 직접 호출하도록 폴백할 수 있습니다.# now find the command we specifically want to executeapp_command = engine.commands.get(&quot;Publish...&quot;)if app_command:    # now run the command, which in this case will launch the Publish app.    app_command[&quot;callback&quot;]()이제 앱이 시작되고 tk-shell 엔진을 실행 중인 경우 출력이 터미널/콘솔에 표시됩니다.6부: 전체 스크립트# Import Toolkit so we can access to Toolkit specific features.import sgtk# Initialize the logger so we get output to our terminalsgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing)sgtk.LogManager().global_debug = True# Authentication################# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your Flow Production Tracking site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to Flow Production Tracking.# This is actually not necessary when using the ToolkitManager. The authenticated user will be set# before launching the engine.# sgtk.set_authenticated_user(user)# Bootstrap############ create an instance of the ToolkitManager which we will use to set a bunch of settings before initiating the bootstrap.mgr = sgtk.bootstrap.ToolkitManager(user)mgr.plugin_id = &quot;basic.shell&quot;project = {&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=project)# Optionally print out the list of registered commands:# use pprint to give us a nicely formatted output.# import pprint# pprint.pprint(engine.commands.keys())if &quot;Publish...&quot; in engine.commands:    # Launch the Publish app, and it doesn't require any arguments to run so provide an empty list.    engine.execute_command(&quot;Publish...&quot;,[])",
    "url": "/3d8cc69a/",
    "relUrl": "/3d8cc69a/"
  },
  "122": {
    "id": "122",
    "title": "엔진 개발",
    "content": "자체 엔진 개발소개이 문서에서는 툴킷 엔진 개발에 관한 몇 가지 기술적인 정보를 간략히 소개합니다.목차:  툴킷 엔진이란?  시작하기 전에 알아야 할 사항  엔진 통합 방식          QT, PyQt/PySide 및 Python이 포함되는 호스트 소프트웨어      QT 및 Python은 포함되지만 PySide/PyQt는 포함되지 않는 호스트 소프트웨어      Python이 포함되는 호스트 소프트웨어      Python이 포함되지 않지만 플러그인을 작성할 수 있는 호스트 소프트웨어      스크립트 작성 기능을 전혀 제공하지 않는 호스트 소프트웨어        Qt 창 부모-자식 관리  시작 동작  호스트 소프트웨어 위시리스트툴킷 엔진이란?엔진 개발 시, 엔진에 로드되는 다양한 툴킷 앱 및 프레임워크와 호스트 소프트웨어를 효과적으로 연결할 수 있습니다.엔진을 사용하면 소프트웨어 간의 차이점을 추상화할 수 있기 때문에 Python 및 QT를 사용하여 소프트웨어에 구속받지 않는 방식으로 앱을 작성할 수 있습니다.엔진은 파일 모음으로 앱과 구조가 비슷합니다. 엔진은 engine.py 파일을 포함하며 이는 코어 Engine 기본 클래스에서 파생되어야 합니다.그러면 다양한 엔진이 내부 복잡성에 따라 이 기본 클래스의 여러 요소를 다시 구현합니다.엔진은 일반적으로 다음과 같은 서비스를 처리 또는 제공합니다.  메뉴 관리. 엔진 시작 시 앱이 로드되고 나면 엔진은 해당 Flow Production Tracking 메뉴를 생성하고, 여러 앱을 이 메뉴에 추가합니다.  일반적으로 로깅 방식은 소프트웨어의 로그/콘솔에 기록하도록 재정의됩니다.  UI 대화상자 및 창을 표시하는 방식. 엔진이 QT를 처리하는 방식이 기본적인 기본 클래스 동작과 다를 경우 이 방식은 툴킷 앱 및 기본 호스트 소프트웨어 창 관리 설정에서 시작한 창을 원활하게 통합할 수 있도록 재정의됩니다.  앱에 의해 등록된 모든 명령 객체를 포함하는 commands 사전(dictionary) 제공. 보통 메뉴 항목이 생성될 때 이 사전에 액세스합니다.  기본 클래스는 시작 프로세스의 여러 지점에서 실행되는 다양한 init 및 destroy 방식을 제공합니다. 시작 및 종료 실행을 제어하기 위해 이 방식을 재정의할 수 있습니다.  자동 소프트웨어 탐색 및 시작 시 tk-multi-launchapp에 의해 호출되는 시작 로직.엔진은 sgtk.platform.start_engine() 또는 sgtk.bootstrap.ToolkitManager.bootstrap_engine() 방식을 사용하여 툴킷 플랫폼에 의해 시작됩니다.이 명령은 구성 파일을 읽고, 엔진을 시작하고, 모든 앱을 로드하는 등의 역할을 수행합니다.엔진의 목표는 일단 시작된 후에 앱에 일관된 Python/QT 인터페이스를 제공하는 것입니다.모든 엔진이 같은 기본 클래스를 구현하므로 앱은 UI 생성 등의 작업을 수행하기 위해 엔진에서 이 방식을 호출할 수 있습니다.호스트 소프트웨어 내에서 원활하게 작동하도록 이 방식을 구현하는 것은 각 엔진의 몫입니다.시작하기 전에 알아야 할 사항Shotgun 팀에서는 가장 일반적으로 사용되는 컨텐츠 생성 소프트웨어에 대한 통합을 제공합니다.툴킷 커뮤니티 멤버가 작성해 공유한 엔진도 있습니다. 하지만 툴킷 엔진이 없는 소프트웨어에 대한 파이프라인 통합이 필요한 경우도 있습니다.시간과 리소스가 있다면 누락된 엔진 중 사용하고 싶은 엔진을 직접 작성하여 툴킷 커뮤니티(그리고 여러분 자신)를 지원해 주시기 바랍니다!코드 작성을 시작하기 전에 저희에게 알려 주십시오! 약속을 드리기는 어렵지만 귀하의 의견을 제안해 주시면 감사하겠습니다.관심이 있거나 같은 엔진에서 작업한 경험이 있는 다른 사용자들과 연결해 드릴 수 있을 것입니다.가능한 경우 툴킷을 통합하려는 소프트웨어의 기술 담당자나 개발자와의 커뮤니케이션 채널을 열어 두면가능성이나 장애물에 대한 정보를 파악할 수 있어 작업을 진행하는 데 도움이 될 것입니다.커뮤니케이션 채널을 설정하고 생각하고 있는 기본적인 사항에 대한 이야기를 나눈 후에는 저희 팀을 대화에 초대해 함께 미팅을 진행하면서 엔진의 특정 요소에 대한 대화를 나눌 수 있습니다.Flow Production Tracking 커뮤니티 포럼에서 툴킷 커뮤니티에 참여할 수도 있습니다.더욱 발전할 새로운 통합을 기대합니다! 툴킷 커뮤니티에 열성적으로 참여해 주시는 여러분의 노력에 늘 감사드립니다.                    팁: 자체 앱 개발에는 앱 개발에 대한 단계별 안내가 포함되어 있으며 이 안내서에서 다루지 않는 엔진 개발에 적용되는 원칙도 포함됩니다.    엔진 통합 방식호스트 앱의 기능이 무엇인지에 따라 엔진 개발의 복잡성이 결정됩니다.이 섹션에서는 엔진 개발 중에 지금까지 발견된 여러 복잡성 수준을 간략하게 살펴봅니다.Qt , PyQt/PySide 및 Python이 포함되는 호스트 소프트웨어이 방식이 최선의 툴킷 설정입니다. 엔진을 Qt, Python 및 PySide를 지원하는 호스트 소프트웨어에 구현하는 작업은 매우 직관적입니다.Nuke 엔진 또는 Maya 엔진이 좋은 예입니다. 통합은 단지 일부 로그 파일 관리를 연결하는 것이며, 코드를 작성하여 Flow Production Tracking 메뉴를 설정합니다.Qt 및 Python은 포함되지만 PySide/PyQt는 포함되지 않는 호스트 소프트웨어이 소프트웨어 클래스에는 Motionbuilder 등이 포함되며 비교적 통합이 간단합니다.호스트 소프트웨어 자체는 Qt로 작성되고, Python 인터프리터를 포함하고 있기 때문에 PySide 또는 PyQt 버전을 컴파일하고, 엔진과 함께 배포할 수 있습니다.그러면 이 PySide가 Python 환경에 추가되고, Python을 이용한 Qt 객체 액세스가 가능해집니다.일반적으로 PySide를 컴파일할 때는 샷 응용프로그램을 컴파일할 때 사용한 정확한 컴파일러 설정을 사용해야 올바로 작동합니다.Python이 포함되는 호스트 소프트웨어이 소프트웨어 클래스에는 타사 통합 Unreal 등이 포함됩니다.이 호스트 소프트웨어는 비-Qt UI를 갖고 있지만 Python 인터프리터를 포함합니다.즉, Python 코드를 환경 내에서 실행할 수 있지만 실행 중인 기존 Qt 이벤트 루프는 없습니다.이 경우에는 Qt 및 PySide가 엔진에 포함되어야 하며, Qt 메시지 펌프(이벤트) 루프가 UI 내 메인 이벤트 루프와 연결되어야 합니다.간혹 이 작업을 정확히 수행하기 위한 특별한 방식이 호스트 소프트웨어에 포함되기도 합니다.포함되어 있지 않으면 정렬을 수행하여 Qt 이벤트 루프가 정기적으로(예: on-idle 호출을 통해) 실행되도록 해야 합니다.Python이 포함되지 않지만 플러그인을 작성할 수 있는 호스트 소프트웨어이 클래스에는 Photoshop 및 After Effects가 포함됩니다.Python 스크립팅이 없지만 C++ 플러그인을 생성할 수 있습니다.이 경우에는 IPC 레이어를 포함하며, 시작 시 별도 프로세스로 Qt 및 Python을 실행하는 플러그인을 생성하는 것이 일반적인 전략입니다.보조 프로세스가 실행되고 나면 IPC 레이어를 사용하여 명령이 양방향으로 전송됩니다.이 호스트 소프트웨어 유형의 경우 적절한 엔진 솔루션을 얻기 위해서는 상당한 작업이 필요합니다.                    팁: Shotgun 팀에서는 Photoshop 및 After Effects 엔진을 사용하여 실제로 Adobe 플러그인을 처리하는 프레임워크를 만들었습니다.두 엔진 모두 프레임워크를 사용해 호스트 소프트웨어와 커뮤니케이션하고 나머지 Adobe 제품군에 대한 엔진을 더 쉽게 빌드할 수 있습니다.    스크립트 작성 기능을 전혀 제공하지 않는 호스트 소프트웨어호스트 소프트웨어를 프로그래밍 방식으로 액세스할 수 없는 경우에는 엔진을 생성할 수 없습니다.Qt 창 부모-자식 관리보통 창 부모-자식 관리에는 특별한 주의를 기울여야 합니다.일반적으로 PySide 창은 위젯 계층에 친부모가 없으며, 이는 명시적으로 호출해야 합니다.창 부모-자식 관리는 일관된 환경을 제공하는 데 중요한 요소이며, 이를 구현하지 않으면 툴킷 앱 창이 메인 창 뒤에 표시되어 혼동을 줄 수 있습니다.시작 동작엔진은 소프트웨어 시작 방법 및 통합의 시작 방법도 담당합니다.이 로직은 tk-multi-launchapp이 엔진을 사용해 소프트웨어를 시작하려고 할 때 호출됩니다.이 설정 방법에 대한 자세한 내용은 코어 설명서에서 확인할 수 있습니다.호스트 소프트웨어 위시리스트다음 호스트 소프트웨어 특성을 툴킷 엔진이 활용할 수 있습니다.많은 특성이 지원될수록 엔진 사용 환경이 향상됩니다!  기본 제공 Python 인터프리터, Qt 및 PySide!  소프트웨어 시작/초기화 시 코드를 실행할 수 있는 능력.  두 시점(소프트웨어가 시작 및 실행되고 있을 때와 UI가 완전히 초기화되었을 때)에 코드에 액세스하여 자동 실행할 수 있는 능력.  파일 시스템 상호 작용을 래핑하는 API 명령: 열기, 저장, 다른 이름으로 저장, 참조 추가 등.      UI 요소를 추가하기 위한 API 명령          커스텀 Qt 위젯을 앱에 패널로 추가(이상적으로는 번들 PySide를 통해 추가)      커스텀 메뉴/상황에 맞는 메뉴 항목 추가      노드 기반 패키지의 커스텀 노드(상호 작용을 위한 커스텀 UI 통합 용이)      선택한 항목/노드 등을 가져오기 위한 인트로스펙션        유연한 이벤트 시스템          “흥미로운” 이벤트가 커스텀 노드 트리거 가능        비동기적 UI 실행 지원          예를 들면, 커스텀 메뉴 항목이 트리거되면 나타나지만 인터페이스를 잠그지 않는 팝업 대화상자      커스텀 UI 창의 부모-자식 관계가 올바로 지정되도록 최상위 창에 핸들 제공      ",
    "url": "/be19bc87/",
    "relUrl": "/be19bc87/"
  },
  "123": {
    "id": "123",
    "title": "프레임워크 개발",
    "content": "자체 프레임워크 개발소개이 문서에서는 Toolkit 프레임워크 개발에 관한 몇 가지 기술적인 정보를 간략히 소개합니다.목차:  툴킷 프레임워크란?  사전 작성된 Flow Production Tracking 프레임워크  프레임워크 작성  후크에서 프레임워크 사용툴킷 프레임워크란?툴킷 프레임워크는 툴킷 앱과 매우 유사합니다.주요 차이점은 프레임워크는 자체적으로 실행할 수 없다는 점입니다.프레임워크는 앱이나 엔진으로 가져오는 방식으로 사용됩니다. 따라서 여러 엔진과 앱에서 사용할 수 있도록 재사용 가능한 로직을 분리할 수 있습니다.재사용 가능한 UI 구성요소 라이브러리를 프레임워크의 예로 들 수 있습니다. 여기에는 재생 목록 선택기 구성요소가 포함될 수 있습니다.그런 다음 앱에서 해당 프레임워크를 가져오고 재생 목록 선택기 구성 요소를 메인 앱 UI에 연결할 수 있습니다.사전 작성된 Flow Production Tracking 프레임워크ShotGrid는 자체 앱을 제작할 때 유용한 몇 가지 사전 작성 프레임워크를 제공합니다.Qt Widgets 및 Flow Production Tracking 유틸리티 프레임워크는 앱 개발 시 특히 유용합니다.프레임워크 작성자체 프레임워크를 작성하는 경우 설정은 앱을 작성하는 것과 거의 동일합니다. “자체 앱 개발” 안내서에서 자세한 내용을 확인할 수 있습니다.프레임워크에는 app.py 파일 대신 프레임워크 패키지의 루트에 Framework 기본 클래스에서 파생된 클래스가 포함된 framework.py가 있습니다. 또한 프레임워크는 엔진에 명령을 등록하지 않습니다.대신, 프레임워크 인스턴스 자체에 방식을 직접 저장하거나 python/ 폴더 내에 모듈을 저장할 수 있습니다.예를 들어 shotgunutils 프레임워크는 이를 python 폴더에 저장합니다.여기에 액세스하려면 프레임워크를 가져온 다음 import_module() 방식을 사용하여 하위 모듈에 액세스합니다.API 문서에는 프레임워크를 가져오는 방법에 대한 예가 있습니다.후크에서 프레임워크 사용후크를 통해 몇 가지 공통 로직을 공유하도록 프레임워크를 생성하는 것이 유용할 수 있습니다.Hook.load_framework() 방식을 이용하면 앱/프레임워크에서 매니페스트 파일에 명시적으로 요구하지 않는 경우에도 앱 또는 기타 프레임워크 후크에서 프레임워크를 사용할 수 있습니다. 코어 후크에서는 이 방식을 사용하더라도 프레임워크를 사용할 수 없습니다.",
    "url": "/312b792f/",
    "relUrl": "/312b792f/"
  },
  "124": {
    "id": "124",
    "title": "경로 생성 및 게시",
    "content": "경로 생성 및 게시이 안내서에서는 파이프라인 통합을 빌드하는 Flow Production Tracking 툴킷 Python API를 시작하는 방법에 대해 설명합니다.이 안내서를 통해 API를 사용하는 방법에 대한 기본적인 예제를 살펴보십시오. 학습을 모두 마치면 툴킷 API를 가져와 경로를 생성하고 게시할 수 있게 될 것입니다.요구사항  Python 프로그래밍 기본 사항에 대한 이해  고급 구성을 사용하는 프로젝트. 구성을 설정하지 않은 경우 구성 시작하기 안내서를 참조하십시오.단계  Sgtk 가져오기  Sgtk 인스턴스 가져오기  컨텍스트 가져오기  폴더 생성  템플릿을 사용하여 경로 빌드  기존 파일 찾기 및 최신 버전 번호 가져오기  게시된 파일 등록  전체 스크립트로 모두 가져오기1부: Sgtk 가져오기툴킷 API는 sgtk라는 Python 패키지에 포함되어 있습니다.각 툴킷 구성에는 tk-core의 일부로 제공되는 자체 API 사본이 있습니다.프로젝트 구성에서 API를 사용하려면 작업할 구성에서 sgtk 패키지를 가져와야 합니다. 이 패키지를 다른 구성에서 가져오면 오류가 발생합니다.                    참고: 경우에 따라 tank 패키지에 대한 참조가 있을 수 있습니다. 이는 동일한 작업에 대한 이전 이름입니다. 앞으로 계속 사용할 수 있는 올바른 이름은 sgtk입니다.    API를 가져오려면 코어의 python 폴더에 대한 경로가 sys.path에 있는지 확인해야 합니다.그러나 이 예의 경우 Flow Production Tracking 데스크톱의 Python 콘솔에서 이 코드를 실행하는 것이 좋습니다.이 경우 올바른 sgtk 패키지 경로가 sys.path에 이미 추가되어 있습니다.마찬가지로, Flow Production Tracking 통합이 이미 실행 중인 소프트웨어 내에서 이 코드를 실행하는 경우에는 경로를 추가할 필요가 없습니다.ShotGrid가 이미 시작된 환경에서 코드를 실행하는 경우 다음과 같이 간단한 방식으로 API를 가져올 수 있습니다.import sgtkFlow Production Tracking 통합 외부에서 API를 사용하려면(예: 즐겨 사용하는 IDE에서 테스트하는 경우) 먼저 API에 대한 경로를 설정해야 합니다.import syssys.path.append(&quot;/shotgun/configs/my_project_config/install/core/python&quot;)import sgtk                    참고: 분산 구성을 사용 중이고 툴킷이 이미 부트스트랩(Bootstrapping)되지 않은 환경에서 sgtk를 가져오려는 경우에는 다른 방법을 사용해야 합니다. 자세한 내용은 부트스트랩 안내서를 참조하십시오.    2부: Sgtk 인스턴스 가져오기툴킷 API를 사용하려면 Sgtk 클래스의 인스턴스를 만들어야 합니다.Sgtk는 sgtk 패키지의 클래스로, API에 대한 메인 인터페이스 역할을 합니다.Sgtk 인스턴스를 만들면 컨텍스트 가져오기, 폴더 만들기 또는 템플릿 액세스 같은 작업을 수행할 수 있습니다.API 설명서에 언급된 것처럼 Sgtk 인스턴스를 직접 만들지는 않습니다. 다음은 Sgtk 인스턴스를 가져오기 위한 몇 가지 옵션입니다.      Flow Production Tracking 통합이 이미 실행 중인 환경(예: Maya가 Flow Production Tracking에서 시작된 경우 Maya Python 콘솔)에서 Python 코드를 실행하는 경우 현재 엔진에서 Sgtk 인스턴스를 가져올 수 있습니다.Engine.sgtk 특성은 엔진의 Sgtk 인스턴스를 유지합니다.따라서 Maya와 같은 응용프로그램에서 다음을 실행할 수 있습니다.    # Get the engine that is currently running.current_engine = sgtk.platform.current_engine()# Grab the already created Sgtk instance from the current engine.tk = current_engine.sgtk        Engine.sgtk 특성을 통해 Sgtk 인스턴스에 액세스할 수 있습니다.    참고: Engine.sgtk 특성을 1부에서 가져온 sgtk 패키지와 혼동하거나 동일하게 간주해서는 안 됩니다.        sgtk.sgtk_from_entity() - 엔진이 아직 시작되지 않은 환경에서 실행 중인 경우 이 방식을 사용하여 엔티티 ID에 맞게 Sgtk 인스턴스를 가져올 수 있습니다.ID를 제공하는 엔티티는 sgtk API를 가져온 프로젝트에 속해야 합니다.이 방식은 분산 구성에서 작동하지 않습니다. 자세한 내용은 부트스트랩 안내서를 참조하십시오.        sgtk.sgtk_from_path() - 구성 경로나 프로젝트 루트 폴더 내부 또는 이에 대한 경로(예: 작업 파일 또는 샷 폴더)를 허용하는 경우를 제외하고 sgtk_from_entity()와 비슷합니다.이 방식은 분산 구성에서 작동하지 않습니다. 자세한 내용은 부트스트랩 안내서를 참조하십시오.  이 안내서에서는 엔진이 이미 시작된 환경에서 이 코드를 실행한다고 가정하므로 옵션 1을 사용합니다.또한 Sgtk 클래스 인스턴스를 tk라는 변수에 저장합니다.Flow Production Tracking Python 콘솔을 사용 중인 경우 tk 변수가 이미 전역 변수로 미리 정의되어 있습니다.이제 Sgtk 인스턴스가 있으므로 API를 사용할 준비가 되었습니다.이제 게시 스크립트는 다음과 같습니다.import sgtk# Get the engine that is currently running.current_engine = sgtk.platform.current_engine()# Grab the already created Sgtk instance from the current engine.tk = current_engine.sgtk3부: 컨텍스트 가져오기컨텍스트는 무엇이며 필요한 이유는 무엇입니까?툴킷에서 발생하는 많은 작업은 컨텍스트를 중심으로 이루어집니다. 즉, 사용자가 무슨 작업 중인지 인지하고 이에 맞게 진행한다는 의미입니다.툴킷 API를 사용하여 작업 중인 엔티티에 대한 중요한 상세 정보를 저장하고 앱 또는 다른 프로세스와 공유할 수 있어야, 이렇게 컨텍스트를 인식한 작동이 가능합니다.예를 들어 툴킷에서 작업 중인 태스크를 인식할 경우 게시된 파일을 Flow Production Tracking에서 해당하는 태스크에 자동으로 링크할 수 있습니다.Context 클래스는 이러한 정보의 컨테이너로 사용됩니다.클래스 인스턴스 내에 몇 가지 항목 중 Task, Step, entity(예: Shot 또는 Asset), Project 및 현재 HumanUser를 저장할 수 있습니다.지정된 세션에서 원하는 만큼의 컨텍스트 객체 유형을 생성할 수 있습니다. 그러나 엔진이 있는 경우 엔진이 트래킹할 수 있는 단일 컨텍스트의 개념이 적용됩니다.이 개념이 사용자가 현재 작업 중이고 앱이 작동해야 하는 컨텍스트입니다.이후 단계에서는 이 컨텍스트를 사용하여 파일을 저장하거나 복사하는 데 사용할 수 있는 경로를 해석합니다.컨텍스트 획득컨텍스트를 생성하려면 생성자 방식 Sgtk.context_from_entity(), Sgtk.context_from_entity_dictionary() 또는 Sgtk.context_from_path() 중 하나를 사용해야 합니다.이전 단계에서 만든, tk 변수에 저장한 Sgtk 인스턴스를 통해 이러한 방식에 액세스합니다.                    참고: 경로에서 컨텍스트를 가져오려면 이미 생성된 폴더가 있어야 합니다. 이 부분은 안내서의 다음 단계에서 설명합니다.    그러나 새 컨텍스트를 생성하는 대신 다음과 같이 2부에서 수집한 현재 컨텍스트를 엔진에서 가져올 수 있습니다.context = current_engine.context이후 단계에서 샷의 태스크 파일 경로를 해석하는 데 컨텍스트를 사용하므로 관련 정보가 컨텍스트에 포함되어 있어야 합니다.코드가 툴킷 앱의 일부로 실행되고 앱이 shot_step 환경에서만 실행되도록 구성된 경우에는 적합한 현재 컨텍스트를 가져온다고 충분히 가정할 수 있습니다.그러나 이 안내서에서는 보다 확실하게 하기 위해 Sgtk.context_from_entity()를 사용하여 Task(Shot에 속해야 함)에서 명시적으로 컨텍스트를 생성합니다.컨텍스트를 생성할 때는 작업에 필요한 가장 깊은 수준을 제공합니다.예를 들어 태스크에서 컨텍스트를 만들 수 있으며 툴킷이 나머지 컨텍스트 매개변수를 처리합니다.context = tk.context_from_entity(&quot;Task&quot;, 13155)컨텍스트 인스턴스 표현을 출력할 경우 다음과 같이 나타납니다.print(repr(context))&amp;gt;&amp;gt; &amp;lt;Sgtk Context:   Project: {'type': 'Project', 'name': 'My Project', 'id': 176}  Entity: {'type': 'Shot', 'name': 'shot01_running_away', 'id': 1381}  Step: {'type': 'Step', 'name': 'Comp', 'id': 8}  Task: {'type': 'Task', 'name': 'Comp', 'id': 13155}  User: None  Shotgun URL: https://mysite.shotgunstudio.com/detail/Task/13155  Additional Entities: []  Source Entity: {'type': 'Shot', 'name': 'shot01_running_away', 'id': 1381}&amp;gt;태스크만 제공했는데 다른 관련 세부 사항도 채워져 있습니다.이제 게시 스크립트는 다음과 같이 됩니다.import sgtk# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work.context = tk.context_from_entity(&quot;Task&quot;, 13155)4부: 폴더 생성툴킷은 프로젝트 엔티티를 기반으로 디스크에 폴더 구조를 동적으로 생성할 수 있습니다.이 단계는 두 가지 목적을 충족합니다.  파일을 배치할 수 있는 디스크에 조직화된 구조를 생성합니다.  이렇게 하면 툴킷이 프로그래밍 방식으로 구조를 이해하고 해당 구조에서 컨텍스트를 파생하고 파일을 배치할 위치를 알 수 있습니다.나중에 경로를 해석할 수 있도록 디스크에 폴더가 있는지 확인해야 합니다.이를 위해서는 Sgtk.create_filesystem_structure() 방식을 사용합니다.tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])컨텍스트 객체를 사용하여 태스크 ID를 가져와 폴더를 생성할 수 있습니다.이제 코드는 다음과 같아야 합니다.import sgtk# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task, this Task must belong to a Shot for the future steps to work.context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the task.tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])이제 모든 준비 단계를 완료했으며 템플릿을 사용한 경로 생성 단계를 진행할 준비가 되었습니다.5부: 템플릿을 사용하여 경로 빌드경로 생성파일을 배치하거나 툴킷에서 찾을 위치를 확인해야 할 때 템플릿을 사용하여 디스크 내에서의 절대 경로를 해석할 수 있습니다.템플릿은 기본적으로 컨텍스트 및 기타 데이터를 적용할 때 파일 시스템 경로로 해석할 수 있는 토큰화된 문자열입니다.템플릿은 프로젝트의 파이프라인 구성을 통해 커스터마이즈할 수 있으며 템플릿의 목적은 파일이 저장된 위치에서 작업하기 위한 표준화된 방법을 제공하는 것입니다.가장 먼저 수행할 작업은 생성하려는 경로에 대한 템플릿 인스턴스를 가져오는 것입니다.생성한 Sgtk 인스턴스를 사용하여 Sgtk.templates 속성을 통해 원하는 Template 인스턴스에 액세스할 수 있습니다. 이 속성은 키가 템플릿 이름이고 값이 Template 인스턴스인 사전(dictionary)입니다.template = tk.templates[&quot;maya_shot_publish&quot;]이 예에서는 maya_shot_publish 템플릿을 사용합니다.기본 구성에서 해석되지 않은 템플릿 경로는 다음과 같습니다.'sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{version}.{maya_extension}'템플릿은 실제 값으로 해석되어야 하는 키로 구성됩니다.대부분의 키에 대한 정보가 컨텍스트에 충분히 포함되어 있으므로 이를 사용하여 값을 추출할 수 있습니다.fields = context.as_template_fields(template)&amp;gt;&amp;gt; {'Sequence': 'seq01_chase', 'Shot': 'shot01_running_away', 'Step': 'comp'}Context.as_template_fields() 방식을 사용하면 템플릿 키를 올바르게 해석하기 위한 값을 포함하는 사전(dictionary)이 제공됩니다.그러나 모든 키에 대해 값이 제공되지는 않습니다. name, version 및 maya_extension은 여전히 누락된 상태입니다.maya_extension 키는 템플릿 키 섹션에서 기본값을 정의하므로 기본값을 제외한 다른 값을 원하더라도 해당 값을 제공할 필요가 없습니다.그러면 name과 version이 남습니다. 이름은 선택의 문제이므로 기본값을 하드 코딩하거나 인터페이스를 팝업하는 등의 방식으로 사용자가 값을 입력할 수 있는 기회를 제공할 수 있습니다.지금은 둘 다 모두 하드 코딩하지만, 다음 단계에서는 사용 가능한 다음 버전 번호를 찾는 방법을 알아보겠습니다.fields[&quot;name&quot;] = &quot;myscene&quot;fields[&quot;version&quot;] = 1이제 모든 필드가 준비되었습니다. 다음과 같이 Template.apply_fields()를 사용하여 템플릿을 절대 경로로 해석할 준비가 되었습니다.publish_path = template.apply_fields(fields)&amp;gt;&amp;gt; /sg_toolkit/mysite.shotgunstudio.com/my_project/sequences/seq01_chase/shot01_running_away/comp/publish/maya/myscene.v001.ma폴더 존재 여부 확인앞에서 폴더 생성 방식을 실행했지만 모든 폴더가 있는지 확인하기 위해 추가 단계를 수행해야 할 수 있습니다.이 단계는 예를 들어 템플릿이 스키마에 없는 폴더를 정의하여 이에 따라 원래 create_filesystem_structure() 호출에서 생성되지 않은 폴더를 정의하는 경우에 필요할 수 있습니다.이 작업을 수행할 때 편리하게 사용할 수 있는 몇 가지 방법이 있습니다.코드가 툴킷 앱 또는 후크에서 실행 중인 경우 Application.ensure_folder_exists() 방식을 사용할 수 있습니다.엔진이 있는 경우 Engine.ensure_folder_exists() 방식을 사용할 수 있습니다.또는 엔진 외부에서 코드를 실행하는 경우 sgtk.util.filesystem.ensure_folder_exists() 방식을 사용할 수 있습니다.전체 파일 경로가 아닌 해당 디렉토리의 폴더만 생성해야 합니다.os 모듈을 가져오고 os.path.dirname(publish_path)를 실행하여 폴더의 전체 파일 경로를 추출할 수 있습니다.경로를 사용하여 파일 생성 또는 복사이 시점에는 경로가 있으며, 이 경로를 사용하여 Maya에 파일을 저장하거나 다른 위치에서 파일을 복사하도록 지시할 수 있습니다.이 안내서에서는 해당 위치에서 디스크에 파일을 실제로 생성하는 동작을 구현하는 것은 중요하게 다루지 않습니다.해당 위치에 파일이 없더라도 경로를 게시할 수 있습니다.그러나 sgtk.util.filesystem.touch_file()을 사용하여 툴킷이 디스크에 빈 파일을 생성하도록 할 수 있습니다.최종 결과import sgtkimport os# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work.context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the task.tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])# Get a template instance by providing a name of a valid template in your config's templates.yml.template = tk.templates[&quot;maya_shot_publish&quot;]# Use the context to resolve as many of the template fields as possible.fields = context.as_template_fields(template)# Manually resolve the remaining fields that can't be figured out automatically from context.fields[&quot;name&quot;] = &quot;myscene&quot;fields[&quot;version&quot;] = 1# Use the fields to resolve the template path into an absolute path.publish_path = template.apply_fields(fields)# Make sure we create any missing folders.current_engine.ensure_folder_exists(os.path.dirname(publish_path))# Create an empty file on disk. (optional - should be replaced by actual file save or copy logic)sgtk.util.filesystem.touch_file(publish_path)다음 단계는 하드 코딩하지 않고 다음 버전 번호를 동적으로 처리하는 것입니다.6부: 기존 파일 찾기 및 최신 버전 번호 가져오기여기에서 사용할 수 있는 두 가지 방법이 있습니다.  이 특별한 예제에서는 게시 파일을 해석하므로 Flow Production Tracking API를 사용하여 PublishedFile 엔티티에 대해 다음으로 사용 가능한 버전 번호를 쿼리할 수 있습니다.  디스크의 파일을 스캔하고 이미 있는 버전을 확인한 후 다음 버전 번호를 추출할 수도 있습니다.이 옵션은 작업 중인 파일이 Flow Production Tracking에서 트래킹되지 않는 경우(예: 작업 파일)에 유용합니다.첫 번째 옵션이 이 안내서의 예에 가장 적합하지만 두 방법 모두 각자 용도가 있으므로 사용되므로 둘 다 설명하겠습니다.ShotGrid에 다음 버전 번호 쿼리Flow Production Tracking API와 summarize() 방식을 사용하여 동일한 이름과 태스크를 공유하는 PublishedFile 엔티티 중에서 가장 높은 버전 번호를 가져온 다음 1을 추가하면 됩니다.r = sg.summarize(entity_type=&quot;PublishedFile&quot;,                 filters = [[&quot;task&quot;, &quot;is&quot;, {&quot;type&quot;:&quot;Task&quot;, &quot;id&quot;: context.task[&quot;id&quot;]}],                            [&quot;name&quot;,&quot;is&quot;, fields[&quot;name&quot;] + &quot;.ma&quot;]],                 summary_fields=[{&quot;field&quot;:&quot;version_number&quot;, &quot;type&quot;:&quot;maximum&quot;}])# Extract the version number and add 1 to it.# In scenarios where there are no files already this summary will return 0.# Apply the version number to the fields dictionary, that will be used to resolve the template into a path.fields[&quot;version&quot;] = r[&quot;summaries&quot;][&quot;version_number&quot;] + 1파일 시스템에서 다음 버전 번호 검색툴킷 API를 사용하여 기존 파일 목록을 수집하고 기존 파일에서 템플릿 필드 값을 추출한 후 다음 버전을 계산할 수 있습니다.아래 예에서는 작업 파일 템플릿에서 최신 버전을 수집합니다.작업 파일 템플릿과 게시 파일 템플릿에 동일한 필드가 있다고 가정하면 아래의 방식을 동일한 필드로 두 번 호출하여 가장 높은 게시 및 작업 파일 버전을 확인하고 두 버전의 조합을 사용할지 결정할 수 있습니다.def get_next_version_number(tk, template_name, fields):    template = tk.templates[template_name]    # Get a list of existing file paths on disk that match the template and provided fields    # Skip the version field as we want to find all versions, not a specific version.    skip_fields = [&quot;version&quot;]    file_paths = tk.paths_from_template(                 template,                 fields,                 skip_fields,                 skip_missing_optional_keys=True             )    versions = []    for a_file in file_paths:        # extract the values from the path so we can read the version.        path_fields = template.get_fields(a_file)        versions.append(path_fields[&quot;version&quot;])    # find the highest version in the list and add one.    return max(versions) + 1# Set the version number in the fields dictionary, that will be used to resolve the template into a path.fields[&quot;version&quot;] = get_next_version_number(tk, &quot;maya_shot_work&quot;, fields)sgtk.paths_from_template() 방식은 제공된 템플릿 및 필드와 일치하는 디스크의 파일을 모두 수집합니다.이 방식은 파일 목록을 찾아서 사용자에게 표시하려는 시나리오에도 유용합니다.두 옵션 중 하나를 사용하도록 선택할 수 있으며, 이 안내서에서는 코드를 간단하게 유지할 수 있도록 옵션 1의 코드를 사용합니다.7부: 게시된 파일 등록이제 경로가 생성되고 게시할 준비가 되었습니다. 유틸리티 방식 sgtk.util.register_publish()를 사용하여 이 작업을 수행할 수 있습니다.Flow Production Tracking API의 Flow Production Tracking.create() 방식을 사용하여 PublishedFile 엔티티를 만들 수도 있지만 필요한 모든 필드가 제공되고 올바르게 입력되기 때문에 툴킷 API를 사용하는 것이 가장 좋습니다.# So as to match the Publish app's default behavior, we are adding the extension to the end of the publish name.# This is optional, however.publish_name = fields[&quot;name&quot;] + &quot;.ma&quot;version_number = fields[&quot;version&quot;]# Now register the publishsgtk.util.register_publish(tk,                           context,                           publish_path,                           publish_name,                           version_number,                           published_file_type = &quot;Maya Scene&quot;)또한 Publish 앱이 자체 API와 함께 제공된다는 점도 주목할 만합니다.이 경우에도 기본적으로 동일한 sgtk.util.register_publish() 방식을 사용하지만 컬렉션, 유효성 확인 및 게시를 처리하는 프레임워크를 제공하여 게시 프로세스를 기반으로 빌드합니다.8부: 전체 스크립트# Initialization# ==============import sgtkimport os# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work.context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the tasktk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])# Generating a Path# =================# Get a template instance by providing a name of a valid template in your config's templates.ymltemplate = tk.templates[&quot;maya_shot_publish&quot;]# Use the context to resolve as many of the template fields as possible.fields = context.as_template_fields(template)# Manually resolve the remaining fields that can't be figured out automatically from context.fields[&quot;name&quot;] = &quot;myscene&quot;# Get an authenticated Shotgun API instance from the enginesg = current_engine.shotgun# Run a Shotgun API query to summarize the maximum version number on PublishedFiles that# are linked to the task and match the provided name.# Since PublishedFiles generated by the Publish app have the extension on the end of the name we need to add the# extension in our filter.r = sg.summarize(entity_type=&quot;PublishedFile&quot;,                 filters = [[&quot;task&quot;, &quot;is&quot;, {&quot;type&quot;:&quot;Task&quot;, &quot;id&quot;: context.task[&quot;id&quot;]}],                            [&quot;name&quot;,&quot;is&quot;, fields[&quot;name&quot;] + &quot;.ma&quot;]],                 summary_fields=[{&quot;field&quot;:&quot;version_number&quot;, &quot;type&quot;:&quot;maximum&quot;}])# Extract the version number and add 1 to it.# In scenarios where there are no files already this summary will return 0.# Apply the version number to the fields dictionary, that will be used to resolve the template into a path.fields[&quot;version&quot;] = r[&quot;summaries&quot;][&quot;version_number&quot;] + 1# Use the fields to resolve the template path into an absolute path.publish_path = template.apply_fields(fields)# Make sure we create any missing folderscurrent_engine.ensure_folder_exists(os.path.dirname(publish_path))# Creating a file# ===============# This is the bit where you would add your own logic to copy or save a file using the path.# In the absence of any file saving in the example, we'll use the following to create an empty file on disk.sgtk.util.filesystem.touch_file(publish_path)# Publishing# ==========# So as to match publishes created by the Publish app's, we are adding the extension to the end of the publish name.publish_name = fields[&quot;name&quot;] + &quot;.ma&quot;version_number = fields[&quot;version&quot;]# Now register the publishsgtk.util.register_publish(tk,                           context,                           publish_path,                           publish_name,                           version_number,                           published_file_type = &quot;Maya Scene&quot;)                    팁: 지금까지 코드가 약간 길었으므로 다음 단계에서는 여러 방식으로 나누는 방법을 알아보겠습니다.    최종 의견이 안내서를 통해 툴킷 API를 시작하는 방법에 대한 기본적인 이해를 갖추게 되었기를 바랍니다.물론 API를 사용하는 다른 방법도 많이 있으므로 자세한 내용은 tk-core API를 참조해 주십시오.또한 API에 대한 질문에 답을 구하고 이 안내서에 대해 피드백을 남길 수 있는 포럼도 방문해 주십시오.",
    "url": "/836446f3/",
    "relUrl": "/836446f3/"
  },
  "125": {
    "id": "125",
    "title": "통합 개발자 가이드",
    "content": "통합 개발자 가이드패널패널 액션 예는 https://github.com/shotgunsoftware/tk-multi-shotgunpanel/tree/master/hooks를 참조하십시오.표시 내용 구성상세 정보 영역의 값과 목록은 둘 다 shotgun_fields 후크를 통해 구성할 수 있습니다. 이 후크를 소분류하고, 그 구현 결과를 변경하여 원하는 정확한 값을 표시할 수 있습니다.템플릿 시스템후크는 간단한 템플릿 언어를 지원하므로 유연성이 뛰어납니다. 또한 Qt에서 지원하는 HTML 하위 세트를 지원하므로 표시되는 값의 색상, 글꼴 크기, 두께 등을 제어할 수 있습니다.템플릿 언어는 다음과 같은 방식으로 작동합니다.      Flow Production Tracking 값은 {brackets}로 묶여 있습니다(예: &amp;lt;b&amp;gt;Description:&amp;lt;/b&amp;gt; {description}). 이 템플릿이 렌더링되면 {description} 부분은 설명 필드 값으로 대체됩니다.        값의 선택적 접두사 또는 접미사(값이 비어 있지 않은 경우에만 표시)를 원한다면 {[Prefix]sg_field[suffix]} 구문을 사용하면 됩니다. 템플릿 {[Start: ]start_date} {[End: ]end_date}는 두 값이 모두 입력될 경우 Start: 12 July 2009 End: 14 July 2012를 렌더링하지만 종료 날짜가 설정되지 않은 경우 Start: 12 July 2009를 렌더링합니다.        일부 값이 설정되지 않은 경우에는 폴백을 정의할 수 있습니다. Flow Production Tracking 버전의 경우 제작자가 아티스트 대신 버전을 제출하는 워크플로우를 지원하기 위해 artist 필드가 created_by 필드보다 우선권을 가집니다. 이 경우, 버전은 제작자에 의해 생성되지만 artist 필드는 아티스트로 설정됩니다. 그러나 항상 그렇지는 않습니다. 아티스트가 자신의 작업을 제출하는 파이프라인에 아티스트를 비워 두는 경우도 있습니다. 따라서 버전을 표시할 때에는 artist 필드를 먼저 확인하고, 이 필드가 설정되어 있지 않은 경우에는 created_by 필드로 폴백할 수 있도록 하는 것이 좋습니다. 이 작업은 {field1|field2} 구문을 사용하여 수행할 수 있습니다(예: Created By: {artist|created_by}). 이 구문을 선택적 필드(예: {[Created By: ]artist|created_by})와 결합할 수도 있습니다.  이 후크에는 다음 방식이 포함됩니다.목록에 표시되는 항목 제어get_list_item_definition() 방식은 Flow Production Tracking 엔티티 유형이 지정된 다양한 목록의 항목 모양을 제어하는 사전을 반환합니다. top_left, top_right 및 body 키가 포함된 사전을 반환합니다. 예를 들면 다음과 같습니다.{ &quot;top_left&quot;: &quot;&amp;lt;big&amp;gt;{code}&amp;lt;/big&amp;gt;&quot;, &quot;top_right&quot;: &quot;{updated_at}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}상단 상세 정보 영역 제어get_main_view_definition() 방식은 Flow Production Tracking 엔티티 유형에 따라 키 title 및 body를 사용하여 사전을 반환합니다. 이 값은 상세 정보 영역의 객체 모양을 제어합니다. 예를 들면 다음과 같습니다.{ &quot;title&quot;: &quot;{type} {code}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}정보(Info) 탭에 표시되는 필드 제어get_all_fields() 방식은 정보(Info) 탭에 렌더링될 때 해당하는 엔티티에 따라 표시할 필드의 목록을 반환합니다.액션 구성액션은 Flow Production Tracking 데이터에서 작동하는 작은 코드 조각입니다. 다음과 같은 예를 들 수 있습니다.  지정된 Flow Production Tracking 버전에 대해 RV를 시작하는 액션  사용자가 지정된 태스크에 자신을 할당할 수 있는 액션  Maya에 Flow Production Tracking 게시를 Maya 참조로 로드하는 액션액션의 실제 페이로드는 액션 후크 에 정의됩니다. 액션 로직을 정의한 후에는 앱 구성에서 해당 액션을 Flow Production Tracking 객체에 매핑할 수 있습니다. 이 액션 매핑은 다음 예와 같은 모습입니다.action_mappings:  PublishedFile:  - actions: [reference, import]    filters: {published_file_type: Maya Scene}  - actions: [texture_node]    filters: {published_file_type: Rendered Image}  Task:  - actions: [assign_task]    filters: {}  Version:  - actions: [play_in_rv]    filters: {}위의 예에서는 reference, import, texture_node, assign_task 및 play_in_rv 액션을 사용합니다. 다음으로 다양한 Flow Production Tracking 객체 및 조건에 액션을 매핑합니다. 예를 들어 모든 Maya 씬 게시 유형에 import 액션을 표시하려고 합니다.객체가 패널에 로드되면 위의 액션 구성을 확인하고 분석합니다. 현재 객체에 대한 적절한 액션 목록이 판별되고 generate_actions() 후크 방식이 실행됩니다. 이때 지정된 엔티티의 Flow Production Tracking 데이터가 후크로 전달되므로 후크 코드가 이 특정 Flow Production Tracking 객체에 대한 액션을 실행할 수 있는지 확인할 수 있습니다. 이렇게 하면 각 후크가 표시되기 전에 검사를 실행할 수 있습니다. 예를 들어 play_in_rv 후크는 로컬에서 사용할 수 있는 미디어가 있는 경우에만 관련될 수 있고 구성에서 설정된 액션 매핑은 지정된 Flow Production Tracking 엔티티에 대해 활성화할 액션을 패널에 알려 주지만 generate_actions() 방식이 지정된 객체에 적합하지 않다고 판단할 수 있으므로 모두 표시되지 않을 수 있습니다.generate_actions() 방식에서 반환되는 액션은 액션 메뉴에 표시되고 사용자가 이를 클릭하면 execute_acton() 후크 방식이 호출되어 액션을 실행합니다.패널이 지원하는 각 응용프로그램에 대해 적절한 액션을 구현하는 액션 후크가 있습니다. 예를 들어 Maya 등을 사용하면 기본 후크가 reference, import 및 texture_node 액션을 구현하고 각각 특정 Maya 명령을 수행하여 현재 Maya 씬으로 게시를 가져옵니다. 모든 후크와 마찬가지로 재정의 및 변경이 완벽히 가능하고, 기본 제공 후크로부터 파생되는 후크를 생성하는 것 역시 가능하기 때문에 많은 코드를 복제할 필요 없이 기본 제공 후크에 다른 액션을 쉽게 추가할 수 있습니다.패널은 툴킷의 2세대 후크 인터페이스를 사용하기 때문에 그 유연성이 뛰어납니다. 이 후크 형식은 향상된 구문을 사용합니다. 기본 구성 설정에서 다음과 같은 형식을 볼 수 있습니다.actions_hook: '{self}/tk-maya_actions.py'{self} 키워드를 통해 툴킷은 앱의 hooks 폴더에서 후크를 찾을 수 있습니다. 이 후크를 사용자 구현으로 재지정하려면 값을 {config}/panel/maya_actions.py로 변경합니다. 이렇게 하면 툴킷이 구성 폴더에 있는 hooks/panel/maya_actions.py라는 후크를 사용하게 됩니다.자세한 정보는 앱과 함께 제공되는 후크 파일을 참조하십시오. 후크는 또한 상속을 이용합니다. 즉, 후크의 모든 사항을 재지정할 필요는 없지만 다양한 방식으로 기본 후크를 좀 더 쉽게 확장하거나 확대하여 보다 쉽게 후크를 관리할 수 있습니다.2세대 후크 형식에 대한 자세한 정보는 여기를 참조하십시오.후크에서 상속을 사용하면 다음과 같은 기본 후크에 액션을 추가할 수 있습니다.import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_data, actions, ui_area):        &quot;&quot;&quot; Returns a list of action instances for a particular object. The data returned from this hook will be used to populate the  actions menu. The mapping between Flow Production Tracking objects and actions are kept in a different place (in the configuration) so at the point when this hook is called, the app has already established *which* actions are appropriate for this object. This method needs to return detailed data for those actions, in the form of a list of dictionaries, each with name, params, caption and description keys. Because you are operating on a particular object, you may tailor the output  (caption, tooltip etc) to contain custom information suitable for this publish. The ui_area parameter is a string and indicates where the publish is to be shown.  - If it will be shown in the main browsing area, &quot;main&quot; is passed.  - If it will be shown in the details area, &quot;details&quot; is passed. :param sg_data: Flow Production Tracking data dictionary with all the standard publish fields. :param actions: List of action strings which have been defined in the app configuration. :param ui_area: String denoting the UI Area (see above). :returns List of dictionaries, each with keys name, params, caption and description &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_data):        &quot;&quot;&quot; Execute a given action. The data sent to this be method will represent one of the actions enumerated by the generate_actions method. :param name: Action name string representing one of the items returned by generate_actions. :param params: Params data, as specified by generate_actions. :param sg_data: Flow Production Tracking data dictionary with all the standard publish fields. :returns: No return value expected. &quot;&quot;&quot;        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_data)그런 다음 이 새 액션을 구성의 게시 유형 세트에 바인딩할 수 있습니다.action_mappings:  PublishedFile:  - actions: [reference, import, my_new_action]    filters: {published_file_type: Maya Scene}  Version:  - actions: [play_in_rv]    filters: {}위의 그림과 같이 후크에서 파생된 커스텀 후크 코드는 유지 관리 및 업데이트가 보다 쉽도록 실제 추가된 비즈니스 로직만 포함하면 됩니다.PublisherPublish 앱은 퍼블리싱을 위해 항목이 아티스트에게 제공되는 방식과 해당 항목이 그 이후 처리되는 방식을 제어하는 후크를 통해 커스터마이즈할 수 있는 범위가 매우 넓습니다.Publisher 앱의 전체 개발자 문서를 이제 툴킷 개발자 사이트에서 살펴볼 수 있습니다.Publish 앱을 사용하는 자세한 방법은 사용자 안내서를 참조하십시오.Loader로드 액션 예는 https://github.com/shotgunsoftware/tk-multi-loader2/tree/master/hooks를 참조하십시오.고급 기능도구를 쉽게 개발할 수 있도록 해 주는 Flow Production Tracking 툴킷앱을 직접 작성할 수 있다는 것을 알려 드렸나요? 각 엔진이 Python 및 PySide 기반의 일관된 인터페이스를 표시하기 때문에 Nuke, Photoshop 및 3dsmax에서 모두 작동하는 단일 앱을 작성할 수 있습니다. Core API 기능을 이용하면 스튜디오용 대규모 파이프라인 스택을 빌드할 필요가 없고, 대신 프로덕션 문제 해결에 dev 리소스를 집중할 수 있습니다. 이 툴킷 덕분에 프로젝트마다 도구를 재사용하는 것도 쉽습니다. 파일 명명 규칙이나 기타 요구 사항이 바뀌는 경우에는 앱을 재구성하기만 하면 됩니다. 툴킷의 기본 제공 Git 및 Github 지원을 통해 도구를 안전하게 롤아웃하고, 개발 시에는 빠르게 코드를 핫로드하십시오. 자체 Dev Sandbox에서 작업하고, 코드를 프로젝트 구성원 모두에게 롤아웃할 필요 없이 TD 및 얼리 어답터를 초대해 코드를 테스트할 수 있습니다.",
    "url": "/93c6e555/",
    "relUrl": "/93c6e555/"
  },
  "126": {
    "id": "126",
    "title": "통합 수정 사항을 제출하는 방법",
    "content": "통합 수정 사항을 제출하는 방법툴킷 커뮤니티의 아낌 없는 참여를 환영합니다! 버그의 잠재적 픽스를 발견했거나 툴킷에 포함되어야 한다고 생각하는 기능을 구현했다면 아래 가이드라인에 따라 적절한 채널을 통해 전송해 주시기 바랍니다.연락 주십시오개발하거나 해결하고 싶은 사항이 있다면 알려 주십시오. 여러분이 올바른 방향으로 나아가고 불필요한 작업에 얽매이지 않도록 필요한 정보를 제공해 드릴 수 있습니다. 무엇보다 사용자 여러분이 빌드하고 싶은 것이 무엇인지, 툴킷을 어떻게 사용하고 있는지, 툴킷을 어떻게 하면 더 멋지게 만들 수 있을지 이야기를 나누고 싶습니다.Github에서 리포지토리 포크(fork)대부분의 툴킷 엔진, 앱, 프레임워크 코드는 Github에서 공개적으로 개발됩니다. 수정 중인 리포지토리를 Github에서 로컬 환경으로 포크(fork)하십시오.변경 작업개발 작업을 분기에서 로컬로 진행하고, 자체 환경에서 제출 준비가 되었다는 확신이 들 때까지 테스트하십시오. 기존 코드 베이스의 스타일과 맞추고 목적에 맞게 변경하십시오. 예를 들어, 코드 행 3개에서 버그를 수정하는 중이라면 파일 전체에서 공백 문제를 수정하려고 하지 마십시오. 그렇게 하면 툴킷 그렘린들이 화를 냅니다.코멘트!어떤 작업을 하는 중인지, 왜 하는지 자세한 코멘트를 추가하십시오. 나중에 여러분 같은 누군가가 이 리포지토리를 포크(fork)할 수 있고, 그 사람도 여러분의 코드의 목적과 그 이유를 이해해야 한다는 사실을 기억해 두시기 바랍니다. 그렇다고 해서 과한 코멘트를 남기지는 마십시오. :)테스트다른 사용자들은 매우 다양한 환경과 변수를 가지고 있고, 그 환경과 변수가 여러분이 스튜디오에 보유하고 있는 것과 일치하지 않을 수 있다는 점을 기억해 두십시오. 툴킷은 이러한 일들이 사용자에게 미치는 영향을 최소화하려고 하지만 언제나 그렇듯 다른 사용자들의 환경에는 서로 다른 점이 존재할 수 있습니다. 예:  코드가 OS X, Windows, Linux에서 동일하게 작동합니까?  지원되는 모든 소프트웨어 버전에서 작동합니까?  사용자가 터미널, SG 데스크톱, Flow Production Tracking 또는 자체 커스텀 앱 중 어디에서 실행하든 항상 동일하게 작동합니까?사용자 요청 생성 준비가 되면 변경 사항을 Github로 다시 푸시하고 사용자 요청을 생성하십시오. 사용자 요청은 코드가 무슨 기능을 하는지, 왜 변경이 필요한지 등에 관해 자세한 내용을 담고 있어야 합니다. 풀 리퀘스트를 작성할 때에는 이 영역의 코드에 관해 지식이 거의 없는 사용자를 염두에 두고 작성해야 합니다. 사용자 요청은 누구든 공개적으로 볼 수 있기 때문에 다른 사용자들도 쉽게 이해할 수 있도록 설명을 자세하게 잘 써놓으면 좋습니다!그 다음은?시간 여유가 되면 여러분들의 요청을 검토합니다. 코드 또는 사용 사례에 관해 의견을 남기고, 궁금한 점에 답변도 달아 드립니다. 요청을 반송해 변경을 요청할 수도 있습니다. 기분 나쁘게 해드릴 의도는 전혀 없습니다! 여러분의 참여와 헌신에 항상 감사하며 일이 진행되는 방식도 잘 이해하고 있습니다. 매일 코드를 접하다 보니 모든 사람이 완벽한 코드를 제출할 수 없다는 점도 잘 알고 있습니다.검토를 마친 후에 사용자 요청을 수락하는 경우에는 QA 대기열에 올리고, 그러면 리포지토리에 병합되어 적절한 시점에 릴리즈됩니다. 타임라인은 여러 요인에 따라 달라질 수 있으니 이해해 주시기 바랍니다.사용자 요청을 정중히 거절할 수도 있습니다. 역시 기분 나쁘게 생각하지 않으셨으면 좋겠습니다. 여러분의 노고와 기여에 항상 감사하고 있습니다. 거절 요인은 여러 가지일 수 있습니다. 하지만 위의 가이드라인을 잘 지킨다면 거절될 가능성도 거의 없습니다.",
    "url": "/924c14e8/",
    "relUrl": "/924c14e8/"
  },
  "127": {
    "id": "127",
    "title": "커스텀 스크립트에서 인증 및 로그인 자격 증명 관련 작업은 어떻게 진행합니까?",
    "content": "커스텀 스크립트에서 인증 및 로그인 자격 증명 관련 작업은 어떻게 진행합니까?오류 메시지스크립트에서 아래와 같은 오류가 표시되는 경우 Flow Production Tracking 사이트에 액세스할 권한이 없음을 의미합니다.tank.errors.TankError: Missing required script user in config '/path/to/your/project/config/core/shotgun.yml'사용자 인증 또는 스크립트 인증이 사전에 제공되지 않은 경우 툴킷은 구성의 shotgun.yml 파일에 정의된 자격 증명을 확인하기 위해 폴백합니다.shotgun.yml 파일에서 자격 증명을 정의하는 것은 과거에 인증을 처리하던 방식입니다.shotgun.yml 파일에서 자격 증명을 정의하는 대신 아래에 설명된 방법 중 하나를 사용하십시오.사용자 대상 스크립트사용자 대상 스크립트의 경우 Sgtk 인스턴스를 생성하기 전에 다음을 시작 부분에 추가할 수 있습니다.# Import the Toolkit API so we can access Toolkit specific features.import sgtk# Import the ShotgunAuthenticator from the tank_vendor.shotgun_authentication# module. This class allows you to authenticate either programmatically or, in this# case, interactively.from tank_vendor.shotgun_authentication import ShotgunAuthenticator# Instantiate the CoreDefaultsManager. This allows the ShotgunAuthenticator to# retrieve the site, proxy and optional script_user credentials from shotgun.ymlcdm = sgtk.util.CoreDefaultsManager()# Instantiate the authenticator object, passing in the defaults manager.authenticator = ShotgunAuthenticator(cdm)# Optionally clear the current user if you've already logged in before.authenticator.clear_default_user()# Get an authenticated user. In this scenario, since we've passed in the# CoreDefaultsManager, the code will first look to see if there is a script_user inside# shotgun.yml. If there isn't, the user will be prompted for their username,# password and optional 2-factor authentication code. If a QApplication is# available, a UI will pop-up. If not, the credentials will be prompted# on the command line. The user object returned encapsulates the login# information.user = authenticator.get_user()# print &quot;User is '%s'&quot; % user# Tells Toolkit which user to use for connecting to Flow Production Tracking. Note that this should# always take place before creating a Sgtk instance.sgtk.set_authenticated_user(user)## Add your app code here...## When you are done, you could optionally clear the current user. Doing so# however, means that the next time the script is run, the user will be prompted# for their credentials again. You should probably avoid doing this in# order to provide a user experience that is as frictionless as possible.authenticator.clear_default_user()QApplication을 사용할 수 있다면 다음과 유사한 항목을 볼 수 있습니다.                    참고: 구성과 연관되지 않은 툴킷 API(sgtk 패키지)를 가져오는 경우(예: 다른 구성으로 부트스트랩(Bootstrapping)하는 데 사용하기 위해 다운로드한 패키지) CoreDefaultsManager를 만들면 안 됩니다. 대신 기본값 관리자를 전달하지 말고 ShotgunAuthenticator() 인스턴스를 생성하십시오.authenticator = ShotgunAuthenticator()    비-사용자 대상 스크립트스크립트가 렌더 팜 또는 이벤트 처리기처럼 사용자 대상 유형이 아닌 경우에는 Sgtk/Tank 인스턴스를 생성하기 전에 다음을 시작 부분에 추가할 수 있습니다.# Import Toolkit so we can access to Toolkit specific features.import sgtk# Import the ShotgunAuthenticator from the tank_vendor.shotgun_authentication# module. This class allows you to authenticate either interactively or, in this# case, programmatically.from tank_vendor.shotgun_authentication import ShotgunAuthenticator# Instantiate the CoreDefaultsManager. This allows the ShotgunAuthenticator to# retrieve the site, proxy and optional script_user credentials from shotgun.ymlcdm = sgtk.util.CoreDefaultsManager()# Instantiate the authenticator object, passing in the defaults manager.authenticator = ShotgunAuthenticator(cdm)# Create a user programmatically using the script's key.user = authenticator.create_script_user(    api_script=&quot;Toolkit&quot;,    api_key=&quot;4e48f....&amp;lt;use the key from your Flow Production Tracking site&amp;gt;&quot;)# print &quot;User is '%s'&quot; % user# Tells Toolkit which user to use for connecting to Flow Production Tracking.sgtk.set_authenticated_user(user)                    참고: 사용자 대상 스크립트 패키지가 독립 실행형이거나 구성에서 가져온 패키지가 아닌 경우 기본값 관리자를 생성하지 마십시오. 또한 create_script_user() 방식에 host를 제공해야 합니다.user = authenticator.create_script_user(    host=&quot;https://yoursite.shotgunstudio.com&quot;,    api_script=&quot;Toolkit&quot;,    api_key=&quot;4e48f....&amp;lt;use the key from your Shotgun site&amp;gt;&quot;)    ",
    "url": "/724152ce/",
    "relUrl": "/724152ce/"
  },
  "128": {
    "id": "128",
    "title": "프로젝트 간에 에셋을 어떻게 공유합니까?",
    "content": "프로젝트 간에 에셋을 어떻게 공유합니까?한 프로젝트가 다른 프로젝트의 샷에 로드할 수 있는 에셋을 포함하는 에셋 라이브러리로 사용되는 경우를 흔히 볼 수 있습니다.이제 에셋 엔티티에 링크된 프로젝트(Linked Projects) 필드가 도입되어, Loader 앱에 링크된 프로젝트를 모두 포함하는 단일 탭을 추가할 수 있습니다. 이렇게 하려면 작업 중인 엔진 및 환경에 대한 로더 설정에서 이를 정의해야 합니다. 아마도 이 설정을 여러 위치에서 업데이트해야 할 것입니다.- caption: Assets - Linked    entity_type: Asset    filters:      - [linked_projects, is, &quot;{context.project}&quot;]    hierarchy: [project.Project.name, sg_asset_type, code]tk-config-default2에 포함된 tk-multi-loader2.yml 구성 파일에서 Alias 엔진 설정을 참조하십시오. 이것이 기본 동작입니다.에셋에 링크된 프로젝트(Linked Projects) 필드를 도입하기 전에 프로젝트 간에 공유를 수행하려면 특정 에셋 라이브러리 프로젝트의 에셋이 나열된 탭을 Loader 앱에 추가해야 했습니다.예를 들어, 샷 단계 환경의 Maya 엔진에 이를 추가하려면 다음 조각을 추가하면 됩니다.- caption: Asset Library    hierarchy: [project, sg_asset_type, code]    entity_type: Asset    filters:      - [project, is, {'type': 'Project', 'id': 207}]207을 라이브러리 프로젝트의 ID로 바꿉니다.현재 Maya의 샷 단계 환경에서 작업 중인 경우 이렇게 하면 해당 프로젝트에서 사용할 수 있는 모든 게시를 보여 주는 새 탭이 추가됩니다. 이 탭을 다른 엔진(Nuke, 3dsmax 등)의 로더에 추가하려면 해당하는 각 엔진에 대한 tk-multi-loader2 설정도 수정해야 합니다. 다른 환경에서 이를 활성화하려면 에셋 단계 환경, 그리고 해당 탭을 추가할 모든 다른 환경에서도 같은 단계를 수행해야 합니다. 조금 지루하겠지만 이렇게 해야 좀 더 미세하게 조정할 수 있습니다.이렇게 설정하면 Loader 앱이 식별된 프로젝트의 게시가 나열된 탭을 표시해야 합니다.                    참고: 초기에 사용된 이 방방식은 Loader 내에서 식별된 프로젝트별로 다른 탭을 가질 수 있게 해 주므로 여전히 포함됩니다.    웹 기반의 프로젝트 간 에셋 링크에 대해 자세히 알아보려면 프로젝트 간 에셋 링크 설명서를 참조하십시오.",
    "url": "/2088a677/",
    "relUrl": "/2088a677/"
  },
  "129": {
    "id": "129",
    "title": "개요",
    "content": "Flow Production Tracking 개발프로덕션을 관리하려면 시시각각으로 변동되는 모든 요소를 동기화 상태로 유지하기 위해 많은 작업을 수행해야 합니다.Flow Production Tracking REST API 또는 Python API를 이용해 데이터에 직접 연결하고 이벤트 트리거 프레임워크를 이용해 반복적인 작업을 자동화하고 액션 메뉴 항목을 이용해 Flow Production Tracking의 웹 인터페이스에서 직접 앱을 실행하십시오.귀하 또는 귀하가 권한을 제공한 사용자가 사용하는 서비스에서 작동하거나 해당 서비스와 함께 작동하는 자체 서비스, 응용프로그램, 모듈 및 구성요소를 개발할 때 Flow Production Tracking API를 사용할 수 있습니다.                    인증 키: 사용자가 로그온하지 않고 서비스 또는 해당 기능에 액세스할 수 있는 인증 키 또는 기타 수단을 포함하는 API 정보를 공개하지 마십시오. 또한 귀하가 권한을 제공한 사용자가 공개하는 것도 허용하지 마십시오. 또는 귀하가 직접 API를 사용하여 액세스하거나 사용자들이 로그온하지 않고 서비스 또는 해당 기능에 액세스할 수 있도록 허용하십시오.    ",
    "url": "/6dfa5d53/",
    "relUrl": "/6dfa5d53/"
  },
  "130": {
    "id": "130",
    "title": "Migration Test Site",
    "content": "Flow Production Tracking Migration Test SiteActivating the isolation feature set is an intrusive procedure that can have an impact on the usability of your site. To prevent a production stopping event, we require clients to follow an approach where the configuration is first validated on a test site, before being applied to the production site.The Flow Production Tracking team will create a temporary site to be used as a Proof of Concept for your Flow Production Tracking Isolation deployment. Upon the successful completion of the setup process, your existing Flow Production Tracking site can be migrated to your Flow Production Tracking Isolation environment.If your Migration Test Site has not been created yet, please reach out to our Support team through your Zendesk ticket or your dedicated on-boarding Slack Channel.Next StepsOnce you have your test site, you can the implementation of the feature you need.See Media Isolation for activating the Media Isolation feature.See Web Traffic Isolation for activating the Web Traffic Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/0bbe0010/",
    "relUrl": "/0bbe0010/"
  },
  "131": {
    "id": "131",
    "title": "SSLHandshakeError CERTIFICATE_VERIFY_FAILED 인증서 확인 실패",
    "content": "SSLHandshakeError: [SSL: CERTIFICATE_VERIFY_FAILED] 인증서 확인 실패활용 사례로컬 패킷 검사를 수행하는 방화벽이 설정된 로컬 네트워크에서 다음 오류 메시지가 표시될 수 있습니다.SSLHandshakeError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)이 오류는 이러한 방화벽이 네트워크 관리자가 직접 생성했으며 Python이 액세스할 수 없는 자체 서명된 인증서로 구성된 경우가 많기 때문에 발생합니다. 다른 응용프로그램과 달리 Python은 OS의 인증서 키체인 내부를 들여다보지 않으므로 직접 제공해야 합니다.해결 방법Python API 및 Shotgun 데스크톱이 신뢰할 수 있는 인증 기관의 전체 목록이 포함된 파일이 디스크에 저장되도록 SHOTGUN_API_CACERTS 환경 변수를 설정해야 합니다.이러한 사본은 Github의 certifi 패키지 최신 사본에서 다운로드할 수 있습니다. 이 작업을 수행한 후에는 해당 파일의 맨 아래에 기업 방화벽의 공용 키를 추가하고 저장해야 합니다.이 작업이 완료되면 SHOTGUN_API_CACERTS 환경 변수를 경로 위치(예: /opt/certs/cacert.pem)로 설정하고 Shotgun 데스크톱을 시작하면 됩니다.관련 링크커뮤니티에서 전체 스레드 보기",
    "url": "/4528ba21/",
    "relUrl": "/4528ba21/"
  },
  "132": {
    "id": "132",
    "title": "경고 기본 루트 저장소를 SG 로컬 저장소에 매핑할 수 없습니다.",
    "content": "경고: 기본 루트 저장소를 SG 로컬 저장소에 매핑할 수 없습니다.활용 사례드라이브 파일 스트림을 사용하여 프로젝트를 설정하고 Google Drive를 기본 저장소로 사용하려고 하면 프로젝트 마법사가 저장소 구성에 액세스할 때 콘솔에 다음 경고가 표시됩니다.[WARNING] Storage root primary could not be mapped to a SG local storage계속(continue)을 눌러도 작동하지 않습니다.해결 방법이 문제는 저장소 이름에 오타가 있을 때 발생할 수 있습니다. Google Drive의 이름과 정확히 일치하는지 확인하십시오.또한 Google Drive를 사용할 때 중복 프로젝트가 나타나지 않도록 파일을 항상 로컬로 유지하도록 설정되어 있는지 확인하십시오.관련 링크커뮤니티에서 전체 스레드 참조",
    "url": "/a59c77b9/",
    "relUrl": "/a59c77b9/"
  },
  "133": {
    "id": "133",
    "title": "컨텍스트에 대한 템플릿 데이터를 확인할 수 없습니다.",
    "content": "TankError: 컨텍스트에 대한 템플릿 데이터를 확인할 수 없습니다.활용 사례새 프로젝트에서 고급 프로젝트 설정을 수행하고 Flow Production Tracking 데스크톱의 독립 실행형 Publisher 앱을 사용하여 작성한 새 에셋 태스크에 대한 일부 이미지를 게시할 때 게시를 확인할 컨텍스트를 선택하면 다음과 같은 오류가 표시됩니다.creation for %s and try again!&quot; % (self, self.shotgun_url))TankError: Cannot resolve template data for context ‘concept, Asset door-01’ - this context does not have any associated folders created on disk yet and therefore no template data can be extracted. Please run the folder creation for and try again!터미널에서 tank.bat Asset door-01 folders를 실행하여 이 문제를 해결했습니다. 하지만 이전 프로젝트에서는 이런 오류가 발생한 적이 없습니다.해결 방법이 오류는 DCC를 먼저 수행하지 않고 새 엔티티/태스크에 대해 독립 실행형 게시를 처음으로 시도하는 것이 그 원인일 수 있습니다.이전에는 이러한 문제가 발생하지 않았을 수 있는 이유는 독립 실행형 Publisher를 사용하기 전에 소프트웨어에서 에셋에 대한 작업을 시작했기 때문에 폴더가 이미 생성/동기화되었기 때문입니다. (툴킷을 통해) 소프트웨어를 실행하면 실행하는 컨텍스트에 대한 폴더가 생성되고, 열린 앱은 새 파일을 시작하는 컨텍스트에 대한 폴더를 만듭니다. 따라서 일반적으로 폴더를 특별히 만들 필요가 없습니다.일반적으로 스튜디오는 Flow Production Tracking에 샷/에셋이 추가된 후 수동으로 폴더를 생성하는 것이 일반적입니다.또한 “폴더 스키마”의 영향을 받으므로 템플릿과 완전히 일치하지 않는 경우 이상한 문제가 발생할 수 있습니다.관련 링크커뮤니티에서 전체 스레드 참조",
    "url": "/5cdbc2a3/",
    "relUrl": "/5cdbc2a3/"
  },
  "134": {
    "id": "134",
    "title": "TankError 템플릿에서 경로를 확인하려고 시도했습니다.",
    "content": "TankError: 템플릿에서 경로를 확인하려고 시도했습니다.활용 사례 1SGTK에 대한 새 구성을 설정하고 파일 열기(File Open) 대화상자(tk-multi-workfiles2에서)를 통해 새 파일을 작성하려고 하면 다음 오류가 발생합니다.TankError: Tried to resolve a path from the template &amp;lt;Sgtk TemplatePath asset_work_area_maya:활용 사례 2특정 작업에서 저장하려고 하면 다음 오류가 발생합니다.TankError: Tried to resolve a path from the template &amp;lt;Sgtk TemplatePath nuke_shot_work:해결 방법사례 1의 경우: asset.yml 파일을 확인합니다. 필터가 누락되었을 수 있습니다. - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }사례 2의 경우: 시퀀스의 이름이 바뀌고 몇 개의 FilesystemLocations 뒤에 숨겨져 있어 툴킷에 혼동이 있을 수 있습니다.해결 방법:  Shotgun에서 오래된 FilesystemLocations를 삭제합니다.  툴킷에서 오래된 FilesystemLocations와 관련된 폴더의 등록을 해제합니다.  툴킷에서 폴더를 다시 등록합니다.관련 링크여기에서 커뮤니티의 전체 스레드를 확인하고 여기에서 이 커뮤니티 스레드를 참조하십시오.",
    "url": "/ea55eac2/",
    "relUrl": "/ea55eac2/"
  },
  "135": {
    "id": "135",
    "title": "툴킷이 있는 파이프라인 구성에서 툴킷 플랫폼을 로드하는 중입니다.",
    "content": "TankInitError: 파이프라인 구성에서 툴킷 플랫폼을 로드하는 중입니다.활용 사례앱에서 파일을 게시하기 위해 일부 코드를 실행할 때 파일이 다른 프로젝트에 속한 경우가 있습니다.TankInitError: You are loading the Toolkit platform from the pipeline configuration located in 오류를 해결할 수 있습니까?이상적으로, 이러한 파일이 다른 프로젝트에 속해 있더라도 경로에서 컨텍스트를 찾아 적절히 등록할 수 있습니다.해결 방법다음 함수를 사용합니다.def get_sgtk(proj_name, script_name):    &quot;&quot;&quot; Load sgtk path and import module    If sgtk was previously loaded, replace include paths and reimport    &quot;&quot;&quot;    project_path = get_proj_tank_dir(proj_name)    sys.path.insert(1, project_path)    sys.path.insert(1, os.path.join(        project_path,        &quot;install&quot;, &quot;core&quot;, &quot;python&quot;    ))    # unload old core    for mod in filter(lambda m: m.startswith(&quot;sgtk&quot;) or m.startswith(&quot;tank&quot;), sys.modules):        sys.modules.pop(mod)        del mod    if &quot;TANK_CURRENT_PC&quot; in os.environ:        del os.environ[&quot;TANK_CURRENT_PC&quot;]    import sgtk    setup_sgtk_auth(sgtk, script_name)    return sgtk핵심은 sys.modules에서 모든 sgtk 관련 모듈을 삭제하고 환경에서 TANK_CURRENT_PC를 제거하는 것입니다. 자세한 내용은 다음 문서를 참조하십시오. 어떻게 하면 shotgunEvents 데몬을 사용하여 다른 Toolkit Core 모듈을 로드할 수 있습니까?관련 링크커뮤니티에서 전체 스레드 참조",
    "url": "/a2befe6a/",
    "relUrl": "/a2befe6a/"
  },
  "136": {
    "id": "136",
    "title": "Isolation Features",
    "content": "Isolation Feature SetThe isolation feature set is an hybrid solution that satisfies strict security and legal requirements, while minimizing Flow Production Tracking System Admin specific required knowledge and maintenance. These features enable creative studios to confidently meet their supplier’s and studio’s highly stringent security, privacy, and performance requirements—from the cloud.Continue to About the isolation feature set for more details.Go to Setup if you are ready to activate the Isolation features.In This SectionGetting Started  About Isolation  Client Responsibilities  Onboarding Process  Planning your SetupFeatures Description  Media Isolation  Media Traffic Isolation  Media ReplicationSetup  Setup Overview  Media Isolation  Media Traffic Isolation  Media Replication  Isolation Fine Tuning  ActivationAWS Knowledge  Connecting Your Studio With Your AWS VPC  Flow Production Tracking AWS Direct Connect Onboarding  S3  VPC / IAM / Security Group  Direct Connect  Private Link  VPC Endpoints  AWS Knowledge",
    "url": "/f378a164/",
    "relUrl": "/f378a164/"
  },
  "137": {
    "id": "137",
    "title": "3ds Max Plus",
    "content": "3dsMax Plus3ds Max Plus용 Flow Production Tracking 엔진은 3ds Max 응용프로그램과 Flow Production Tracking Toolkit을 연결합니다. 이 엔진은 PySide 및 모든 다중 앱을 지원합니다. 즉, 3ds Max 내부에서 표준 앱(Maya, Nuke 등에서도 작동하는 동일한 앱)을 실행할 수 있습니다. 이 엔진은 3ds Max Plus Python API를 사용합니다.지원되는 응용프로그램 버전이 항목은 테스트를 거쳐 다음 응용프로그램 버전에서 작동하는 것으로 알려져 있습니다.2020 - 2023문서화이 엔진은 Max Plus의 Python 지원을 통해 Flow Production Tracking Toolkit(Sgtk)과 3ds Max를 연결합니다.설치 및 업데이트Flow Production Tracking Toolkit에 이 엔진 추가asset 환경의 XYZ 프로젝트에 이 엔진을 추가하려면 다음 명령을 실행합니다.&amp;gt; tank Project XYZ install_engine asset tk-3dsmaxplus최신 버전으로 업데이트프로젝트에 이 항목이 이미 설치되어 있는 경우 최신 버전을 얻으려면 update 명령을 실행할 수 있습니다. 특정 프로젝트와 함께 제공되는 tank 명령을 탐색하여 다음과 같이 실행할 수 있습니다.&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updates또는 스튜디오 tank 명령을 실행하고 업데이트 확인을 실행할 프로젝트 이름을 지정할 수 있습니다.&amp;gt; tank Project XYZ updates협업 및 개선Flow Production Tracking Toolkit에 액세스할 수 있다면 모든 앱, 엔진 및 프레임워크가 저장 및 관리되는 Github에서 그 소스 코드에도 액세스할 수 있습니다. 이러한 항목을 자유롭게 개선하여 향후 독립적인 개발을 위한 기반으로 사용하고 변경 후 다시 사용자 요청을 제출하거나, 아니면 그냥 조금만 손을 보고 어떻게 빌드되었는지, 툴킷이 어떻게 작동하는지 확인해 보십시오. https://github.com/shotgunsoftware/tk-3dsmaxplus에서 이 코드 리포지토리에 액세스할 수 있습니다.특별 요구 사항이 기능을 이용하려면 Flow Production Tracking Toolkit Core API 버전 v0.19.18 이상이 필요합니다.",
    "url": "/7112d6a1/",
    "relUrl": "/7112d6a1/"
  },
  "138": {
    "id": "138",
    "title": "3ds Max",
    "content": "3dsMax3dsMax용 Flow Production Tracking 엔진에는 3dsMax에 Flow Production Tracking Toolkit(Sgtk) 앱을 통합하기 위한 표준 플랫폼이 포함되어 있습니다. 간단하고 직접적인 이 플랫폼은 기본 메뉴에 Flow Production Tracking 메뉴를 추가합니다.지원되는 응용프로그램 버전이 항목은 테스트를 거쳐 다음 응용프로그램 버전에서 작동하는 것으로 알려져 있습니다.2020 - 2023문서화3dsMax용 Flow Production Tracking 엔진에는 3dsMax에 Flow Production Tracking Toolkit(Sgtk) 앱을 통합하기 위한 표준 플랫폼이 포함되어 있습니다. 간단하고 직접적인 이 플랫폼은 기본 메뉴에 Flow Production Tracking 메뉴를 추가합니다.설치 및 업데이트Flow Production Tracking Toolkit에 이 엔진 추가asset 환경의 XYZ 프로젝트에 이 엔진을 추가하려면 다음 명령을 실행합니다.&amp;gt; tank Project XYZ install_engine asset tk-3dsmax최신 버전으로 업데이트프로젝트에 이 항목이 이미 설치되어 있는 경우 최신 버전을 얻으려면 update 명령을 실행할 수 있습니다. 특정 프로젝트와 함께 제공되는 tank 명령을 탐색하여 다음과 같이 실행할 수 있습니다.&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updates또는 스튜디오 tank 명령을 실행하고 업데이트 확인을 실행할 프로젝트 이름을 지정할 수 있습니다.&amp;gt; tank Project XYZ updates협업 및 개선Flow Production Tracking Toolkit에 액세스할 수 있다면 모든 앱, 엔진 및 프레임워크가 저장 및 관리되는 Github에서 그 소스 코드에도 액세스할 수 있습니다. 이러한 항목을 자유롭게 개선하여 향후 독립적인 개발을 위한 기반으로 사용하고 변경 후 다시 사용자 요청을 제출하거나, 아니면 그냥 조금만 손을 보고 어떻게 빌드되었는지, 툴킷이 어떻게 작동하는지 확인해 보십시오. https://github.com/shotgunsoftware/tk-3dsmax에서 이 코드 리포지토리에 액세스할 수 있습니다.특별 요구 사항이 기능을 이용하려면 Flow Production Tracking Toolkit Core API 버전 v0.19.18 이상이 필요합니다.",
    "url": "/bb1266cb/",
    "relUrl": "/bb1266cb/"
  },
  "139": {
    "id": "139",
    "title": "After Effects",
    "content": "After EffectsAfter Effects용 Flow Production Tracking 엔진은 After Effects 워크플로우에 Flow Production Tracking를 통합하기 위한 플랫폼을 제공합니다. 표준 Flow Production Tracking Toolkit 엔진으로 구성되며, tk-framework-adobe(CEP)를 사용합니다.일단 활성화되면 After Effects에서 Flow Production Tracking Adobe 패널을 이용할 수 있게 됩니다. Flow Production Tracking 컨텍스트에 대한 정보와 현재 해당 컨텍스트에 설치된 앱에 등록된 명령을 표시합니다.지원되는 응용프로그램 버전이 항목은 테스트를 거쳐 다음 응용프로그램 버전에서 작동하는 것으로 알려져 있습니다.2020 (v17.0) - 2023 (v23.6)최신 릴리즈에서는 더 완벽하게 작동할 수 있지만 이러한 버전에서 아직 공식적으로 테스트되지는 않았습니다.인터페이스 개요Flow Production Tracking 익스텐션 패널은 기본 After Effects 패널과 동일한 색상 팔레트 및 기본 레이아웃을 사용합니다. 익스텐션 패널은 다음 다섯 가지 구성요소로 이루어져 있습니다.  컨텍스트 헤더 - 현재 컨텍스트에 대한 썸네일 및 필드입니다.  즐겨찾기 쉘프 - 현재 컨텍스트에서 가장 많이 사용되는 앱을 표시하도록 디자인되었습니다.  명령 목록 - 현재 컨텍스트에서 자주 사용되지 않는 모든 명령입니다.  상황에 맞는 메뉴 - 추가 컨텍스트 관련 명령 및 디버깅 도구입니다.  로깅 콘솔 - 디버깅용 로깅 출력을 표시하는 콘솔 오버레이입니다.설치After Effects용 Flow Production Tracking 엔진의 설치는 다른 Flow Production Tracking 통합과 동일한 방식을 따릅니다. 엔진 및 앱 설치에 대한 자세한 내용은 툴킷 관리 문서를 참조하십시오. 또한 통합을 구성하는 방법의 예로 기본 툴킷 구성을 참조할 수 있습니다.익스텐션 활성화익스텐션이 설치되면 After Effects의 익스텐션 메뉴를 통해 익스텐션을 실행해야 합니다.이 작업은 한 번만 수행하면 되고 Flow Production Tracking 익스텐션 패널은 이후에는 시작할 때 활성화하지 않아도 After Effects 레이아웃에 표시됩니다.활성화하고 이후에 시작하면 Flow Production Tracking 통합이 부트스트랩(Bootstrapping)되는 동안 익스텐션 패널에 로딩 화면이 표시됩니다.이 화면은 일반적으로 현재 컨텍스트가 결정되고 명령이 표시되기까지 몇 초 동안 표시됩니다.인터페이스 구성요소다음 섹션에서는 Flow Production Tracking After Effects 통합의 구성요소를 간략하게 설명합니다.컨텍스트 헤더컨텍스트 헤더는 현재 Flow Production Tracking 컨텍스트에 대한 정보를 표시할 수 있는 커스터마이즈 가능 영역입니다.컨텍스트는 현재 활성 문서에 의해 결정됩니다. 엔진에서 컨텍스트가 결정되면 헤더가 업데이트되어 컨텍스트의 썸네일 필드 상세 정보가 표시됩니다. 필드 정보는 후크로 제어됩니다. 필드 표시를 커스터마이즈하는 방법에 대한 자세한 정보는 아래의 컨텍스트 필드 표시 후크 섹션을 참조하십시오.또한 Flow Production Tracking 열기가 사용된 경우에만 컨텍스트 전환이 인식된다는 것도 유의해야 합니다.즐겨찾기 쉘프즐겨찾기 쉘프는 Maya 및 Houdini와 같은 다른 Flow Production Tracking DCC 통합에서 사용할 수 있는 메뉴 즐겨찾기와 유사합니다. 이 인터페이스 섹션에서는 가장 일반적으로 사용되는 툴킷 앱을 컨텍스트 헤더 바로 아래에서 쉽게 사용할 수 있고 쉽게 찾습니다.쉘프는 즐겨찾는 명령을 버튼으로 표시하며, 버튼 위에 마우스 커서를 놓으면 회색 음영에서 색상으로 전환되고 상단의 레이블에 이름이 표시됩니다. 버튼 위에 마우스 커서를 놓으면 버튼에 대한 툴팁이 표시됩니다.버튼 중 하나를 클릭하면 실행하도록 등록된 명령에 대한 콜백이 트리거됩니다.명령 즐겨찾기를 지정하는 방법에 대한 자세한 정보는 아래의 쉘프 즐겨찾기 섹션을 참조하십시오.명령 목록명령 목록에는 현재 컨텍스트에 대해 등록된 다른 “일반” 명령이 표시됩니다.일반적으로 파이프라인 구성 내에 설치된 앱은 여기에 표시되는 하나 이상의 명령을 등록합니다. 명령이 즐겨찾기로 식별되지 않고 상황에 맞는 메뉴 명령으로도 식별되지 않는 경우 여기에 표시됩니다.명령 목록 버튼은 즐겨찾기 쉘프의 버튼과 비슷한 방식으로 동작합니다. 유일한 차이점은 아이콘의 오른쪽에 전체 이름이 있는 목록으로 표시된다는 점입니다.상황에 맞는 메뉴상황에 맞는 메뉴 명령으로 등록된 모든 명령은 Flow Production Tracking 익스텐션 패널의 상황에 맞는 메뉴에 표시됩니다.다른 명령 영역과 마찬가지로 이러한 명령은 컨텍스트와 함께 변경됩니다. Flow Production Tracking(으)로 이동(Jump to Flow Production Tracking) 및 파일 시스템으로 이동(Jump to Filesystem)과 같은 명령은 항상 여기에서 사용할 수 있습니다.로깅 콘솔로깅 콘솔에는 CEP Javascript 인터프리터 및 툴킷의 Python 프로세스의 모든 로깅 출력이 표시됩니다.익스텐션에 문제가 있어 지원이 필요한 경우 로깅 콘솔 출력은 Flow Production Tracking 지원 팀이 문제를 디버깅하는 데 매우 유용합니다.구성 및 기술 상세 정보다음 섹션에서는 스튜디오 파이프라인의 특정 요구 사항으로 통합을 구성할 수 있는 통합의 보다 기술적인 측면에 대해 설명합니다.PySideAfter Effects용 Flow Production Tracking 엔진은 PySide를 사용합니다. Pyside 설치에 대한 공식 지침을 참조하십시오.CEP 익스텐션익스텐션 자체는 엔진과 함께 번들로 제공되며 엔진은 After Effects를 처음 시작할 때 자동으로 설치를 처리합니다. 익스텐션은 아티스트의 로컬 컴퓨터에 OS별 CEP 익스텐션 표준 디렉토리에 설치됩니다.# Windows&amp;gt; C: Users [user name] AppData Roaming Adobe CEP extensions # OS X&amp;gt; ~/Library/Application Support/Adobe/CEP/extensions/After Effects를 시작할 때마다 엔진 부트스트랩(Bootstrap) 코드는 엔진과 함께 번들로 제공되는 익스텐션 버전을 컴퓨터에 설치된 버전과 비교하여 검사합니다. 즉, 엔진 업데이트 후 새 익스텐션 버전이 함께 제공된 경우 설치된 익스텐션이 번들로 제공되는 새 버전으로 자동 업데이트됩니다.즐겨찾기 구성즐겨찾기 쉘프는 설치된 앱에 등록된 모든 명령을 표시하도록 구성할 수 있습니다. 이렇게 하려면 환경 설정의 tk-aftereffects 섹션에 shelf_favorites 구성을 추가하면 됩니다. 다음은 예입니다.shelf_favorites:    - {app_instance: tk-multi-workfiles2, name: File Save...}    - {app_instance: tk-multi-workfiles2, name: File Open...}    - {app_instance: tk-multi-publish, name: Publish...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}설정의 값은 구성에 설치된 앱 중 하나에서 제공하는 등록된 명령을 식별하는 사전 목록입니다. app_instance 키는 설치된 특정 앱을 식별하고 name 키는 해당 앱에서 등록된 명령의 표시 이름과 일치합니다. 위의 예에서 즐겨찾는 네 가지 명령, tk-multi-workfiles2 앱의 파일 열기 및 저장 대화상자와 표준 툴킷 게시 및 스냅샷 대화상자를 볼 수 있습니다. 이제 이 네 가지 명령이 즐겨찾기 쉘프에 표시됩니다.환경 변수디버깅을 돕기 위해 엔진의 일부 기본값을 변경하는 일련의 환경 변수가 있습니다.  SHOTGUN_ADOBE_HEARTBEAT_INTERVAL - Python heartbeat 간격(초)입니다(기본값: 1초).  SHOTGUN_ADOBE_HEARTBEAT_TOLERANCE - 종료하기 전 heartbeat 오류 수입니다(기본값: 2). 기존 환경 변수  또한 설정된 경우 SGTK_PHOTOSHOP_HEARTBEAT_TOLERANCE도 적용됩니다.  SHOTGUN_ADOBE_NETWORK_DEBUG - 출력 로깅 시 추가 네트워킹 디버그 메시지를 포함합니다. 기존 환경 변수  또한 설정된 경우 SGTK_PHOTOSHOP_NETWORK_DEBUG도 적용됩니다.  SHOTGUN_ADOBE_PYTHON - 엔진을 시작할 때 사용할 Python 실행 파일의 경로입니다. 설정되지 않은 경우 시스템 Python이 사용됩니다. Photoshop이 Flow Production Tracking 데스크톱과 같은 Python 프로세스에서 또는 tk-shell 엔진을 통해 시작되면 해당 프로세스에서 사용되는 Python이 Photoshop 통합에서 사용됩니다.참고: Adobe 프레임워크에 추가 환경 변수가 존재합니다. 자세한 내용은 개발자 문서를 참조하십시오.컨텍스트 필드 표시 후크엔진에는 패널의 컨텍스트 헤더 섹션에 표시되는 필드를 제어하는 후크가 제공됩니다. 후크에서 표시되는 항목을 커스터마이즈하기 위해 재지정할 수 있는 두 가지 방식이 있습니다.첫 번째는 get_entity_fields() 방식입니다. 이 방식은 현재 Flow Production Tracking 컨텍스트를 나타내는 엔티티 유형을 적용합니다. 예상되는 반환값은 표시를 위해 쿼리해야 하는 해당 엔티티의 필드 목록입니다. 엔진 자체는 비동기적으로 데이터 쿼리를 처리합니다.ShotGrid에서 데이터를 쿼리하면 후크의 두 번째 방식이 호출됩니다. 이 get_context_html() 방식은 get_entity_fields() 방식에서 지정된 쿼리된 필드로 채워진 컨텍스트 엔티티 사전을 수신합니다. 예상되는 반환값은 쿼리된 엔티티 필드를 표시하도록 형식이 지정된 HTML을 포함하는 문자열입니다.기본 후크 구현은 이러한 방식에 필요한 사항에 대한 좋은 참조입니다.엔진은 엔티티 썸네일을 사용할 수 있는 경우 항상 이를 표시합니다.Footage 후크 가져오기엔진은 특정 파일 유형의 가져오기 동작을 제어할 수 있는 후크와 함께 제공됩니다. psd 파일을 구성 대신 단일 레이어로 가져오려는 경우가 있을 수 있습니다. 이 경우 이 후크는 이 동작을 재정의하는 데 사용될 수 있습니다.기본 후크 구현After Effects APIAfter Effects API에 대한 자세한 내용은 개발자 문서를 참조하십시오.",
    "url": "/1eca509c/",
    "relUrl": "/1eca509c/"
  },
  "140": {
    "id": "140",
    "title": "Alias",
    "content": "AliasAlias용 Flow Production Tracking 엔진에는 Flow Production Tracking 앱을 Alias에 통합하기 위한 표준 플랫폼이 포함되어 있습니다. 직접적으로 실행되는 경량의 플랫폼으로, Alias 메뉴에 Flow Production Tracking 메뉴를 추가합니다.지원되는 응용프로그램 버전이 항목은 테스트를 거쳐 다음 응용프로그램 버전에서 작동하는 것으로 알려져 있습니다.2020 - 2023최신 릴리즈에서는 더 완벽하게 작동할 수 있지만 이러한 버전에서 아직 공식적으로 테스트되지는 않았습니다.Python 버전 지원  중요: Alias Flow Production Tracking 툴킷 엔진의 v2.1.5 릴리즈부터 Python v2.7.x에 대한 지원이 중단되었습니다. Python 3이 기본 버전으로 사용되도록 하려면 Flow Production Tracking 데스크톱 v1.7.3 이상을 다운로드하십시오.이전 버전이전 버전에 대한 Python 버전 지원에 대한 자세한 내용은 여기를 참조하십시오.참고로컬로 설치된 인터프리터는 예기치 않은 동작을 초래할 수 있습니다. 스튜디오 환경에서 이 기능을 사용하려면 지원 팀에 문의하십시오.앱 개발자를 위한 정보PySideAlias용 Flow Production Tracking 엔진은 Flow Production Tracking 데스크톱과 함께 제공되는 PySide 설치를 사용하며 필요할 때마다 활성화됩니다.Alias 프로젝트 관리Alias용 Flow Production Tracking 엔진이 시작되면 Alias 프로젝트가 이 엔진 설정에서 정의된 위치를 가리키도록 설정됩니다. 즉, 새 파일을 열면 프로젝트가 변경될 수도 있습니다. 파일을 기반으로 Alias 프로젝트가 설정되는 방법과 관련된 상세 정보는 템플릿 시스템을 사용하여 구성 파일에서 구성할 수 있습니다.tk-alias 작업이 Flow Production Tracking 통합은 Alias 응용프로그램 제품군(Concept, Surface 및 AutoStudio)을 지원합니다.Alias가 열리면 Flow Production Tracking 메뉴(Alias 엔진)가 메뉴 막대에 추가됩니다.파일 열기 및 저장내 태스크(My Tasks) 및 에셋(Assets) 탭을 사용하여 할당된 모든 태스크를 보고 에셋을 찾을 수 있습니다. 오른쪽에서 이 탭을 사용하여 왼쪽에 선택된 항목과 연관된 모든 파일, 작업 파일 또는 게시된 파일을 볼 수 있습니다.게시파일을 Flow Production Tracking에 게시하기 위한 게시(Publish) 대화상자를 엽니다. 게시하면 아티스트 다운스트림에서 사용할 수 있습니다. 자세한 내용은 Alias에서 게시를 참조하십시오. LoaderAlias로 데이터를 로드할 수 있는 Content Loader 앱을 엽니다. 자세한 내용은 Alias에서 로드를 참조하십시오.씬 분할기한이 만료된 씬의 항목과 함께 또는 PublishedFile의 대체 버전을 사용하여 참조된 (WREF 참조) 컨텐츠 목록을 표시하는 분할(Breakdown) 대화상자를 엽니다. 자세한 내용은 Alias에서 씬 분할을 참조하십시오.",
    "url": "/8229b689/",
    "relUrl": "/8229b689/"
  },
  "141": {
    "id": "141",
    "title": "Create",
    "content": "Flow Production Tracking Create데스크톱2 엔진은 Flow Production Tracking Create 응용프로그램 내부에서 실행되는 엔진입니다. 브라우저 통합을 통해 Flow Production Tracking 웹 응용프로그램에서뿐만 아니라 Flow Production Tracking Create에서도 DCC 시작을 처리합니다.tk-desktop2 엔진은 Flow Production Tracking Create와 툴킷을 통합할 수 있도록 합니다. Flow Production Tracking Create는 DCC 시작을 포함하여 툴킷 사용자에게 익숙한 기능을 지원합니다.설치 및 업데이트Flow Production Tracking Toolkit에 이 엔진 추가asset 환경의 XYZ 프로젝트에 이 엔진을 추가하려면 다음 명령을 실행합니다.&amp;gt; tank Project XYZ install_engine asset tk-desktop2Updating to the latest version프로젝트에 이 항목이 이미 설치되어 있는 경우 최신 버전을 얻으려면 update 명령을 실행할 수 있습니다. 특정 프로젝트와 함께 제공되는 tank 명령을 탐색하여 다음과 같이 실행할 수 있습니다.&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updates또는 스튜디오 tank 명령을 실행하고 업데이트 확인을 실행할 프로젝트 이름을 지정할 수 있습니다.&amp;gt; tank Project XYZ updates협업 및 개선Flow Production Tracking Toolkit에 액세스할 수 있다면 모든 앱, 엔진 및 프레임워크가 저장 및 관리되는 Github에서 그 소스 코드에도 액세스할 수 있습니다. 이러한 항목을 자유롭게 개선하여 향후 독립적인 개발을 위한 기반으로 사용하고 변경 후 다시 사용자 요청을 제출하거나, 아니면 그냥 조금만 손을 보고 어떻게 빌드되었는지, 툴킷이 어떻게 작동하는지 확인해 보십시오. 이 코드 리포지토리는 https://github.com/shotgunsoftware/tk-desktop2에서 액세스할 수 있습니다.특별 요구 사항이 기능을 이용하려면 Flow Production Tracking Toolkit Core API 버전 v0.19.1 이상이 필요합니다.Flow Production Tracking 통합 오류 수정사용자에게 다음과 같은 오류 메시지가 표시됩니다. 통합을 초기화하지 못했습니다. ValueError - Flow Production Tracking의 localhost 인증서 데이터가 잘못되었습니다. 지원 팀에 문의하십시오. 이 오류 메시지는 Flow Production Tracking Toolkit 통합을 사용하도록 Flow Production Tracking 인스턴스가 구성되지 않은 상태에서 Flow Production Tracking 툴킷 기능에 액세스하려는 경우를 나타냅니다.사용자가 Flow Production Tracking 툴킷에 액세스하지 못하도록 하고 오류 메시지가 표시되지 않도록 하려면 환경 변수 SHOTGUN_CREATE_DISABLE_TOOLKIT_INTEGRATION을 활성화합니다. 이 환경 변수는 Create에서 Flow Production Tracking 툴킷 통합을 완전히 비활성화합니다.실수로 이 환경 변수를 활성화한 경우 다시 비활성화하면 Flow Production Tracking 툴킷 통합이 복원됩니다.",
    "url": "/969c1d7f/",
    "relUrl": "/969c1d7f/"
  },
  "142": {
    "id": "142",
    "title": "Tk-desktop 콘솔에서 자동으로 오류 무시",
    "content": "Tk-desktop 콘솔에서 자동으로 오류 무시활용 사례툴킷 앱을 개발할 때 “디버그 로깅 토글(Toggle debug logging)” 체크박스가 선택되어 있더라도 tk-desktop은 초기화 중에 앱에서 발생하는 모든 예외를 자동으로 무시합니다. 문제가 있다는 것을 아는 유일한 방법은 프로젝트의 구성을 로드한 후에 등록된 명령이 표시되지 않는다는 것입니다.해결 방법데스크톱이 프로젝트용 앱을 로드하는 경우 해당 로깅이 SG 데스크톱 기본 UI 프로세스로 전달되지 않습니다. 하지만 tk-desktop.log로 계속 출력되어야 합니다. 파일에서 예외를 확인합니다.관련 링크커뮤니티에서 전체 스레드 참조",
    "url": "/228e7940/",
    "relUrl": "/228e7940/"
  },
  "143": {
    "id": "143",
    "title": "데스크톱",
    "content": "데스크톱tk-desktop 엔진은 툴킷 앱을 쉽게 실행할 수 있게 해 주는 응용프로그램입니다. 툴킷을 시작하고 툴킷용 프로젝트를 설정하고 프로젝트의 파이프라인에 액세스하는 작업을 쉽게 수행할 수 있도록 하는 시스템 트레이 기반 창입니다.사이트 구성 및 프로젝트 구성데스크톱 응용프로그램을 시작하면 사이트 구성을 위한 tk-desktop 엔진이 시작됩니다. 이 구성은 대개 자동으로 관리되지만 해당 동작을 비활성화하고 해당 환경을 제어할 수 있습니다.툴킷의 기본 원칙 중 하나는 프로젝트가 서로 완전히 격리될 수 있다는 것입니다. 이는 일반적으로 한 프로젝트의 변경 사항이 다른 프로젝트(곧 전달 가능)에 악영향을 미치지 않도록 하기 위해 수행됩니다. 이 프로젝트 격리 기능을 제공하기 위해 데스크톱 엔진은 사용자가 특정 프로젝트에 대한 명령을 볼 때마다 해당 프로젝트의 초기화된 별도의 python 인터프리터에서 명령을 실행할 수 있도록 합니다.프로젝트를 클릭하면 백그라운드에서 python 인터프리터가 시작됩니다. 프로젝트가 이 python 인터프리터를 사용하도록 구성되어 있으면 시작 시 해당 프로젝트의 tk-desktop을 초기화합니다. 해당 엔진 인스턴스는 실행할 수 있는 GUI 명령에 다시 연결합니다.명령을 클릭하면 해당 백그라운드 python 프로세스가 명령을 실행합니다.커스텀 패널 등록패널 기반 UI가 있는 툴킷 앱은 실행 시 데스크톱 내부의 탭에 자동으로 고정됩니다.Flow Production Tracking Panel과 같은 패널 기반 앱이 있고 Flow Production Tracking 데스크톱에 탭으로 표시하려면 시작 시 실행되도록 구성하면 됩니다. 데스크톱이 사이트 컨텍스트 모드(모든 프로젝트 표시)에서 시작되면 자동 시작으로 등록된 모든 항목이 시작됩니다. 이러한 항목 중 하나가 패널이면 패널이 고정됩니다. 항목은 구성에서 정의된 순서대로 처리되며 탭 순서도 지정됩니다.예를 들어 Flow Production Tracking Panel을 Flow Production Tracking 데스크톱의 탭으로 표시하려면 사이트 레벨 환경에 다음 구성을 추가합니다.tk-desktop:  apps:    tk-multi-shotgunpanel:      actions_hook: ...      action_mappings: ...      location: ...  location: ...  run_at_startup:  - {app_instance: '', name: Apps}  - {app_instance: tk-multi-shotgunpanel, name: ''}Apps 항목은 탭 순서대로 기본 Apps 탭이 표시되는 위치를 제어합니다.",
    "url": "/75097ed0/",
    "relUrl": "/75097ed0/"
  },
  "144": {
    "id": "144",
    "title": "Flame 내보내기",
    "content": "Flame 내보내기Flow Production Tracking Flame 내보내기 앱은 프로젝트를 시작하는 데 도움이 됩니다.Flame에서 초기 컨폼을 만든 경우 샷 내보내기를 사용하여 Flow Production Tracking에서 컨텐츠를 신속하게 생성하고, 디스크에 플레이트를 렌더링하고, 리뷰할 컨텐츠를 전송할 수 있습니다.실행하면 내보내기 앱은 Flare 또는 Flame 배치 모드(batch mode)에서 발생하는 모든 렌더를 트래킹하므로 워크플로우의 일부로 리뷰할 컨텐츠를 쉽게 전송할 수 있습니다.ShotGrid로 컨폼 푸시Flame에서 시퀀스에 대한 컨폼 설정이 있고 타임라인의 모든 세그먼트에 할당된 샷 이름이 있는 경우 시퀀스를 선택하고 마우스 오른쪽 버튼으로 클릭하고 Flow Production Tracking Shot Export 옵션을 선택합니다.그러면 게시에 대한 일부 초기 코멘트를 입력할 수 있는 Flow Production Tracking UI가 나타납니다. 이러한 코멘트는 리뷰를 위해 전송되며 게시 및 기타 컨텐츠에 설명을 추가할 때도 사용됩니다.설명 외에도 내보낸 플레이트에 사용할 출력 데이터 형식도 선택할 수 있습니다. 이러한 사전 설정은 툴킷 앱 구성의 일부이며 스튜디오의 필요에 맞게 구성할 수 있습니다.Submit 버튼을 클릭하면 다음과 같이 여러 작업이 즉시 수행됩니다.      Flow Production Tracking에 샷 및 태스크가 만들어집니다. 태스크 템플릿 설정을 통해 만들어지는 각각의 새 샷과 연결할 태스크 목록을 구성할 수 있어 일관된 구조를 쉽고 빠르게 만들 수 있습니다. 샷은 기본적으로 시퀀스에 따라 상위로 지정되지만 구성 가능하며 씬 또는 에피소드에 대한 작업을 수행하는 경우 이러한 설정을 대신 사용하여 내보내기를 다시 구성할 수 있습니다.        Flow Production Tracking에 올바른 데이터가 포함되면 표준 폴더 생성 메커니즘을 사용하여 디스크에 폴더가 생성됩니다. 따라서 생성되는 모든 샷에 대해 일관된 일련의 폴더를 사용하여 프로젝트를 시작할 수 있습니다.  위의 두 단계가 수행되고 나면 추가 단계를 진행하기 위한 기본 구조를 갖게 됩니다. 이러한 작업은 백그라운드에서 수행됩니다.      구성에 정의된 사전 설정에 따라 각 샷에 대한 플레이트가 디스크에 내보내집니다. 파일 위치는 툴킷 템플릿 시스템을 사용하여 정의됩니다. 즉, 이러한 플레이트의 위치는 파이프라인의 다른 도구 다운스트림에 의해 잘 정의되고 파악됩니다.        배치(Batch) 파일과 클립 xml 파일이 내보내집니다. Flame에서는 이러한 파일을 사용하여 나중에 Flame의 기본 컨폼으로 가져오는 새 버전을 빠르게 렌더링할 수 있는 반복 워크플로우를 지원합니다.        Quicktime이 생성되고 리뷰를 위해 Flow Production Tracking에 업로드됩니다.  Review로 배치(Batch) 렌더 보내기샷에 대한 Flame 배치(Batch) 파일을 게시하면 해당 샷에서 직접 Flare를 시작하여 렌더 및 출력 설정이 미리 입력된 상태로 배치(Batch) 파일을 열 수 있습니다. 새 버전을 렌더링하려면 Render Range 버튼을 클릭하기만 하면 됩니다.이때 툴킷은 Flow Production Tracking Review로 렌더를 보낼지 선택할 수 있는 대화상자를 표시합니다.파일이 Flow Production Tracking에 의해 게시되고 트래킹되며 선택적으로 리뷰를 위해 전송됩니다.자세한 정보자세한 정보를 보고 이 워크플로우가 작동하는지 확인하려면 Flame 엔진 문서로 이동합니다. 여기에는 다양한 워크플로우의 작동 상태를 보여 주는 몇 가지 동영상 컨텐츠도 있습니다.LINKBOX_ENGINE:ShotGridsoftware/tk-flame: Flame 엔진통합 또는 커스터마이즈에 관한 질문이 있으면 언제든지 지원 사이트를 방문해 주십시오.고급 항목아래에 구성 및 커스터마이즈와 관련된 고급 상세 정보가 나와 있습니다.내보내기 사전 설정 사용내보내기는 해당 구성의 내보내기 사전 설정 개요를 사용합니다. Flame 내에서 내보내기 UI를 시작하면 사용 가능한 내보내기 사전 설정이 있는 드롭다운이 표시됩니다. 각 사전 설정은 파일을 디스크에 기록하고 Flow Production Tracking에 업로드하는 방법을 구성할 수 있는 구성 옵션입니다. 디스크의 파일 위치와 같은 높은 수준의 설정은 환경 구성에서 직접 제어되므로 파이프라인에서 작동하도록 기본 구성 옵션을 쉽게 조정할 수 있습니다.Flame을 제어하기 위해 Flame에 전달되는 실제 내보내기 xml 컨텐츠에 대한 고급 설정 및 제어는 각 사전 설정에 대해 동작이 정의된 후크에 의해 처리됩니다. 후크에서, 내보내기로 미디어를 생성하는 방법을 완벽하게 제어할 수 있습니다.Flow Production Tracking 서버 측 트랜스코딩 건너뛰기기본적으로 Quicktime은 Version.sg_uploaded_movie 필드를 설정하는 방법으로 Flow Production Tracking Review에 업로드됩니다. 그러면 Flow Production Tracking 서버 측 트랜스코딩이 트리거되고 업로드된 Quicktime은 브라우저 및 모바일에서 재생하기에 적합한 mp4 및 webm 표현으로 변환됩니다. 경우에 따라 이 서버 측 트랜스코딩을 건너뛰는 것이 유익할 수 있습니다. bypass_shotgun_transcoding 구성 설정을 설정하면 건너뛸 수 있습니다. true로 설정하면 통합에서 Flow Production Tracking의 Version.sg_uploaded_movie_mp4 필드로 직접 업로드하여 서버 측 트랜스코딩을 건너뜁니다. 이 경우 webm 버전이 생성되지 않으므로 Firefox에서 리뷰를 재생할 수 없습니다.자세한 정보는 https://help.autodesk.com/view/SGSUB/KOR/?guid=SG_Supervisor_Artist_sa_review_approval_sa_transcoding_html을 참조하십시오.ffmpeg 커스터마이즈내보내기는 Quicktime을 생성할 때 Flame과 함께 배포되는 ffmpeg 버전을 사용합니다. 내보내기에서 설정 후크를 수정하여 기본 제공 버전 대신 사용할 ffmpeg 추가 버전을 지정할 수 있습니다. Flame과 함께 배포되는 ffmpeg의 버전은 ffmpeg 트랜스코딩 및 성능에 대한 향상된 최신 기능을 트래킹하므로 최신 버전을 사용하면 성능이 향상될 수 있습니다.h264 매개변수가 ffmpeg로 전달되는 방식이 기본적으로 사용되는 버전과 최신 버전 간에 변경되었습니다. 최신 ffmpeg로 전환하면 Flow Production Tracking 측에서 최적의 업로드 및 성능을 제공하는 권장 트랜스코딩 지침을 정확히 구현할 수 있습니다. 이러한 지침은 다음을 참조하십시오.https://help.autodesk.com/view/SGSUB/KOR/?guid=SG_Supervisor_Artist_sa_review_approval_sa_transcoding_html고급 사용자인 경우 ffmpeg 버전만 변경하는 것이 좋습니다. 이 경우 다음 단계를 수행합니다.설정 후크 복사수정할 필요가 있는 모든 설정은 Flame 내보내기 앱과 함께 제공되는 설정 후크에서 찾을 수 있습니다. 이 후크를 수정하려면 먼저 이 후크 파일을 앱 위치 내의 기본 위치에서 현재 구성으로 복사해야 합니다. 프로젝트 구성 내에서 후크 파일은 일반적으로 install/apps/app_store/tk-flame-export/va.b.c/hooks/settings.py와 비슷한 위치에 있습니다. 이 파일을 구성 내의 hooks 위치(예: config/hooks)에 복사합니다. 그냥 settings.py보다는 무슨 파일인지 명확하게 알 수 있도록 좀 더 긴 이름으로 바꾸는 것이 좋습니다.install/apps/app_store/tk-flame-export/va.b.c/hooks/settings.py -&amp;gt; config/hooks/flame_export_settings.py이제 Flame 환경 구성 파일을 편집합니다. 이 파일은 일반적으로 config/env/includes/flame.yml입니다. tk-flame-export 제목 아래, 후크에 대한 경로가 settings_hook: '{self}/settings.py'로 정의되어 있음을 알 수 있습니다. 이는 기본적으로 구성이 앱 위치(예: {self}) 내의 후크 파일을 검색한다는 것을 의미합니다. 대신 이 경로를 settings_hook: '{config}/flame_export_settings.py'로 변경하면 툴킷이 구성 내의 후크 파일을 찾게 됩니다. 요약하면 다음과 같습니다.settings_hook: '{self}/settings.py' -&amp;gt; '{config}/flame_export_settings.py'후크 수정이제 config/hooks/flame_export_settings.py 후크를 수정할 준비가 되었습니다. 텍스트 편집기에서 후크를 엽니다. ffmpeg 및 ffmpeg 설정과 관련된 몇 가지 방식이 있습니다. 수정할 첫 번째 항목은 다음과 같습니다.def get_external_ffmpeg_location(self):    &quot;&quot;&quot;    Control which version of ffmpeg you want to use when doing transcoding.    By default, this hook returns None, indicating that the app should use    the built-in version of ffmpeg that comes with Flame.    If you want to use a different version of ffmpeg, simply return the path    to the ffmpeg binary here.    :returns: path to ffmpeg as str, or None if the default should be used.    &quot;&quot;&quot;    return None기본적으로 None을 반환하면 내보내기는 Flame의 기본 제공 ffmpeg를 사용합니다. ffmpeg에 대한 전체 경로를 반환하도록 이 값을 변경합니다. Backburner 클러스터를 실행하는 경우 ffmpeg는 클러스터 내 어떤 시스템에서든 호출될 수 있으므로 실행 파일이 모든 위치에 설치되어 있는지 확인해야 합니다.이제 ffmpeg 위치가 업데이트되면 ffmpeg에 전달된 매개변수를 조정해야 할 수 있습니다. 다음 두 가지 방식으로 변경해야 합니다.      get_ffmpeg_quicktime_encode_parameters는 Flow Production Tracking에 업로드할 Quicktime을 생성할 때 사용되는 매개변수를 반환합니다.        get_local_quicktime_ffmpeg_encode_parameters는 Quicktime을 디스크에 작성할 때 사용되는 매개변수를 반환합니다.  Flow Production Tracking 업로드의 경우 시작점으로 기본 Flow Production Tracking 인코딩 설정을 사용하는 것이 좋습니다.def get_ffmpeg_quicktime_encode_parameters(self):    return &quot;-vcodec libx264 -pix_fmt yuv420p -vf 'scale=trunc((a*oh)/2)*2:720' -g 30 -b:v 2000k -vprofile high -bf 0&quot;로컬 Flow Production Tracking 트랜스코드의 경우 Flow Production Tracking 트랜스코드 설정에서의 설정을 기반으로 하되 해상도 제약 조건을 제거하고 비트 전송률을 높이는 것이 좋습니다.def get_local_quicktime_ffmpeg_encode_parameters(self):    return &quot;-vcodec libx264 -pix_fmt yuv420p -g 30 -b:v 6000k -vprofile high -bf 0&quot;",
    "url": "/04a6342b/",
    "relUrl": "/04a6342b/"
  },
  "145": {
    "id": "145",
    "title": "Flame Review",
    "content": "Flame ReviewFlow Production Tracking Flame Review 앱을 사용하면 Flame에서 하나 이상의 시퀀스를 Flow Production Tracking Review로 쉽게 푸시할 수 있습니다.리뷰할 하나 이상의 시퀀스를 선택하고 마우스 오른쪽 버튼으로 클릭하기만 하면 됩니다.Flow Production Tracking Review 옵션을 선택합니다.리뷰 노트를 추가할 수 있는 툴킷 UI가 나타납니다.OK를 클릭하면 백그라운드 작업이 생성되고 모든 작업이 씬 뒤에서 수행됩니다.다음 단계가 수행됩니다.      시퀀스가 Quicktime으로 디스크에 내보내집니다. 이 내보내기는 Flame Quicktime 내보내기로 처리되며 구성 후크를 통해 다양한 설정을 완벽하게 제어할 수 있습니다.        시퀀스 완료 후 툴킷이 Flow Production Tracking에 일치하는 시퀀스가 있는지 확인합니다. 없으면 시퀀스가 자동으로 생성됩니다.        리뷰 버전이 생성되고 시퀀스와 연결됩니다.        마지막으로 Quicktime이 리뷰 버전으로 업로드됩니다.  프로세스는 오디오 트랙, 전환 등을 지원하며 “WYSIWYG”여야 합니다. 이제 Flow Production Tracking에서 Client Review Site 및 Flow Production Tracking iPhone 앱을 비롯한 여러 가지 방법으로 미디어를 리뷰할 수 있습니다.커스터마이즈 및 설정Flame Review 앱은 여러 가지 방법으로 커스터마이즈할 수 있습니다.      Flame의 시퀀스를 나타내도록 Flow Production Tracking에서 사용해야 하는 엔티티 유형을 제어할 수 있습니다. 예를 들어 에피소드 컨텐츠에서 작업하는 경우 시퀀스가 아닌 Flow Production Tracking의 에피소드에 리뷰 버전을 링크하는 것이 더 효과적일 수 있습니다.        Flow Production Tracking에서 만든 새 항목에 앱을 자동으로 추가해야 하는 태스크를 커스터마이즈할 수 있습니다. 이 작업은 태스크 템플릿 설정을 통해 수행되며 만들어지는 구조를 표준화할 수 있습니다.        후크를 통해 앱이 Flame 외부에서 Quicktime을 생성하는 데 사용하는 XML 사전 설정을 완벽하게 제어할 수 있습니다.  ",
    "url": "/b38dc286/",
    "relUrl": "/b38dc286/"
  },
  "146": {
    "id": "146",
    "title": "Flame",
    "content": "Flame설치Flame용 Flow Production Tracking 엔진은 Flame 2015 Extension 2에 추가된 새 통합 후크를 사용합니다. 엔진이 작동하려면 반드시 이 Flame 버전을 사용해야 합니다. Flame 2015 Extension 2에 대한 자세한 정보(얻는 방법 포함)는 Flame 지원 팀에 문의하십시오.Flame용 Flow Production Tracking 엔진을 시작하는 가장 간단한 방법은 예제 파이프라인 구성을 사용하여 새 테스트 프로젝트를 설정하는 것입니다. Flow Production Tracking 데스크톱을 시작하고 새 프로젝트에 대한 프로젝트 설정을 실행하여 기본 구성 섹션에서 기본 Flame 구성을 선택하면 이 작업을 수행할 수 있습니다.지원되는 응용프로그램 버전이 항목은 테스트를 거쳐 다음 응용프로그램 버전에서 작동하는 것으로 알려져 있습니다.2020+Flame 프로젝트 설정Flame용 Flow Production Tracking 엔진은 Flow Production Tracking 프로젝트를 Flame 프로젝트와 연결하는 데 도움을 주며 필요한 경우 Flame 프로젝트를 생성합니다. Flame의 데이터가 Flow Production Tracking의 올바른 데이터와 연결되도록 하므로 이 설정이 통합의 핵심입니다. 추가 기능으로 엔진은 Flame 프로젝트의 명명 규칙 및 프로젝트의 다른 여러 설정을 관리하는 기능을 제공합니다.ShotGrid를 통해 Flame이 처음 시작되면 아티스트가 표준 Flame 프로젝트 생성 화면에서 일반적인 설정을 편집할 수 있는 Flame 프로젝트 생성 UI가 나타납니다.그러나 Flow Production Tracking 통합을 통해 파이프라인 관련 값으로 설정에 미리 입력할 수 있으므로 아티스트는 고민할 필요 없이 신속하게 올바른 결과를 얻을 수 있습니다. 기본값은 project_setup_hook를 통해 커스터마이즈할 수 있으며 다음 옵션을 지원합니다.use_project_settings_ui True로 설정된 경우 프로젝트 생성 UI가 나타납니다. False로 설정된 경우 Flame 프로젝트는 후크의 나머지 기본값을 기반으로 자동으로 생성됩니다.get_server_hostname 기본적으로 ‘localhost’로 설정되어 있지만 원하는 경우 재지정할 수 있습니다.get_project_name 기본적으로 Flow Production Tracking 프로젝트와 동일한 값으로 설정되지만 원하는 경우 재지정할 수 있습니다.get_volume 기본적으로 사용 가능한 첫 번째 저장소로 설정되지만 원하는 경우 재지정할 수 있습니다.get_workspace 기본적으로 Flame은 표준 작업공간 생성 로직에 따라 기본 작업공간을 만들지만 원하는 경우 재지정할 수 있습니다.get_user 이 설정은 Flame 컴퓨터에 로그인한 사용자와 Flow Production Tracking의 사용자의 연결을 시도합니다.get_project_settings 이 설정을 통해 기본 Flame 설정이 구성되고 후크가 Flame 프로젝트 XML 스트림을 빌드합니다. 다음 매개변수를 반드시 제공해야 합니다.  FrameWidth(예: 1280)  FrameHeight(예: 1080)  FrameDepth(16-bit fp, 12-bit, 12-bit u, 10-bit, 8-bit)  FieldDominance(PROGRESSIVE, FIELD_1, FIELD_2)  AspectRatio(4:3, 16:9 또는 문자열 부동 소수점 값)프록시 설정을 제공할 수도 있습니다. 자세한 내용은 Autodesk Wiretap SDK 문서를 참조하십시오.project_setup 후크에 대한 전체 코드베이스를 보려면 엔진에 대한 Github 리포지토리를 참조하십시오.",
    "url": "/d5d7b724/",
    "relUrl": "/d5d7b724/"
  },
  "147": {
    "id": "147",
    "title": "관리자 UI",
    "content": "툴킷 관리자 UI 프레임워크관리자 UI 프레임워크는 툴킷 관리 명령을 래핑하는 표준 사용자 인터페이스의 위치를 구현합니다.현재 유일한 인터페이스는 setup_project 명령에 대한 인터페이스입니다.SetupProjectWizard API 참조이 API는 툴킷용 Flow Production Tracking 인스턴스를 통해 프로젝트를 설정하는 단계를 보여 주는 QWizard 구현입니다.  이 마법사를 사용하려면 (표준 Flow Production Tracking API 엔티티 사전으로) 설정할 프로젝트와 부모로 지정할 창을 전달하는 클래스 인스턴스를 생성하기만 하면 됩니다.adminui = sgtk.platform.import_framework(&quot;tk-framework-adminui&quot;, &quot;setup_project&quot;)setup = adminui.SetupProjectWizard(project, parent)dialog_result = setup.exec_()이렇게 하면 마법사가 실행되고, 표준 QDialog Accepted 또는 Rejected 값이 반환됩니다.SetupProjectWizard 생성자SetupProjectWizard를 초기화합니다. 다음은 QtGui.QWizard의 하위 클래스입니다.SetupProjectWizard()",
    "url": "/02fa2cba/",
    "relUrl": "/02fa2cba/"
  },
  "148": {
    "id": "148",
    "title": "Desktop Server Framework",
    "content": "툴킷 데스크톱 서버 프레임워크desktopserver 프레임워크는 Flow Production Tracking의 로컬 파일 링크 및 툴킷 통합 기능을 제공합니다. 이를 통해 데스크톱 액세스가 필요한 동작에 대한 Flow Production Tracking 웹 사이트의 요청을 안전하게 수신하는 로컬 웹 소켓 서버를 사용할 수 있습니다.로컬 파일 링크의 경우, 이러한 요청을 통해 웹 인터페이스에서 로컬 파일 경로에 대한 Flow Production Tracking 액세스를 허용하며 요청 시 Flow Production Tracking 페이지에서 해당 파일을 직접 열 수 있습니다. 툴킷의 경우 Flow Production Tracking를 통해 지정된 엔티티에 대해 등록된 파이프라인 액션을 확인하고 이를 실행할 수 있습니다.데스크톱 통합을 실행하는 방법이러한 Flow Production Tracking 기능이 작동하려면 일부 지원되는 데스크톱 통합이 실행 중이어야 합니다. 이 페이지에서는 Flow Production Tracking가 데스크톱과 통합하는 방법에 대한 다양한 옵션을 다룹니다. Websocket 서버 섹션에서는 이 프레임워크가 제공하는 기능에 대해 설명합니다.Flow Production Tracking 데스크톱이 프레임워크는 Flow Production Tracking 데스크톱과 함께 번들로 제공되며, 다음 단계에 따라 다운로드할 수 있습니다. Flow Production Tracking 데스크톱을 실행하면 자동으로 Websocket 서버를 시작합니다. Flow Production Tracking 데스크톱을 이미 실행 중인 경우 설정 프로세스가 완료된 것입니다.서버 구성브라우저 통합 설정은 구성 파일에 저장할 수 있습니다. 이 구성 파일은 SGTK_BROWSER_INTEGRATION_CONFIG_LOCATION 환경 변수를 설정하여 지정할 수 있습니다. 로컬 서버를 구성하는 방법에 대한 자세한 내용은 샘플 파일에서 확인할 수 있습니다.인증서 제거생성한 인증서를 제거하려는 경우 python certificates.py --remove 명령을 실행할 수 있습니다.래퍼를 통해 시작기본적으로 서버에서는 운영 체제 기본값을 사용하여 명령을 실행합니다(Linux에서는 “xdg-open”과 동등한 값, OS X에서는 “열기”, Windows에서 “실행”). 파일 실행을 위해 자체 래퍼를 제공하려는 경우 커스텀 래퍼를 가리키도록 SHOTGUN_PLUGIN_LAUNCHER 환경 변수를 설정할 수 있습니다. 이를 설정하면 래퍼는 유일한 인자로서 경로를 통해 호출됩니다.인증서서버를 처음 실행하면 보안 연결 설정에 필요한 인증서가 생성됩니다. 이러한 인증서는 컴퓨터에 로컬로 저장되며 공개적으로 공유되지 않습니다. 이를 이용하면 웹 소켓에 필요한 암호화된 연결이 가능하며 이는 로컬에 남아 있는 모든 트래픽(브라우저에서 서버로)에도 불구하고 필요합니다. Flow Production Tracking의 웹 소켓 트래픽은 인터넷을 통해 제공되지 않습니다.인증서가 시스템에 등록된 경우 다음과 같이 대화상자가 표시됩니다. “확인(OK)”을 클릭하여 등록을 계속 진행합니다.  Flow Production Tracking 데스크톱을 사용하면 생성된 인증서가 다음 위치에 저장됩니다.OS X: ~/Library/Caches/Shotgun/desktop/config/certificatesWindows: %AppData% Flow Production Tracking Toolkit config certificatesLinux: ~/.shotgun/desktop/config/certificates보안 설정 - 로컬 Flow Production Tracking 설치기본적으로 websocket 서버는 포트 9000에서 호스트되는 Flow Production Tracking 사이트를 수신하도록 설정되어 있습니다. 로컬 Flow Production Tracking 서버를 실행하는 경우 websocket 서버에서의 연결을 허용하도록 Flow Production Tracking 서버에 대한 구성을 업데이트해야 합니다.Flow Production Tracking 데스크톱을 실행할 때 Flow Production Tracking 바이너리와 함께 존재하는 config.ini 파일을 설정해야 합니다.해당 파일에는 Websocket 서버의 기능을 제어하는 섹션이 있습니다. 일반적인 구성은 다음과 같습니다.[BrowserIntegration]low_level_debug=0port=9000enabled=1whitelist=*.shotgunstudio.com문제 해결Linux에서 서버는 libffi에 대한 종속성을 도입합니다. 시작 시 데스크톱에서 충돌이 발생하고 로그에서 libffi를 찾을 수 없다는 메시지가 표시되는 경우 이 패키지를 설치해야 합니다.설치 중에 문제나 질문이 있는 경우 지원 사이트를 방문하십시오. 서버 실행에 문제가 있는 경우 config.ini 파일에서 debug를 1로 설정하고 데스크톱의 로그 파일을 포함시키십시오.로그 파일은 다음 위치에 있습니다.OS X: ~/Library/Logs/Shotgun/tk-desktop.logWindows: ~%APPDATA% Shotgun tk-desktop.logLinux: ~/.shotgun/tk-desktop.log",
    "url": "/c79f1656/",
    "relUrl": "/c79f1656/"
  },
  "149": {
    "id": "149",
    "title": "데스크톱 시작",
    "content": "툴킷 Desktop Startup FrameworkDesktop Startup Framework는 Flow Production Tracking 데스크톱의 시작 로직을 구현합니다. 주요 기능은 다음과 같습니다.  브라우저 통합 초기화  사용자 로그인  툴킷 다운로드  사이트 구성 설정  필요 시 자신과 사이트 구성 자동 업데이트  tk-desktop 엔진 실행  내부 툴킷 프레임워크이므로 이 프레임워크가 구현하는 인터페이스는 변경될 수 있습니다. 이 프레임워크를 프로젝트에서는 사용하지 않는 것이 좋습니다.시작 로직 잠금  이 경우 Flow Production Tracking 데스크톱 앱 버전 1.3.4가 필요합니다. 응용프로그램 버전이 확실하지 않으면 Flow Production Tracking 데스크톱을 실행하십시오. 로그인하고 나면 오른쪽 아래의 사용자 아이콘을 클릭하고, About...을 클릭합니다. App Version이 1.3.4 이상이어야 합니다.기본적으로 Flow Production Tracking 데스크톱은 tk-framework-desktopstartup 업데이트를 사용자 컴퓨터에 로컬로 다운로드하고, 응용프로그램 실행 시퀀스 중에 이를 사용합니다. 응용프로그램을 실행하면 툴킷이 프레임워크 업데이트를 자동으로 확인합니다. 또한 업데이트가 있으면 자동으로 다운로드하여 설치합니다.아니면, Flow Production Tracking 데스크톱이 로컬 사본 대신 특정 프레임워크 사본을 사용하도록 구성해도 됩니다. 이렇게 하면 자동 업데이트가 비활성화되기 때문에 시작 로직 업데이트는 여러분이 직접 책임져야 합니다.GitHub에서 특정 릴리즈 다운로드GitHub에서는 수동으로 업데이트를 다운로드해야 합니다. 번들은 출시 페이지에서 쉽게 다운로드할 수 있고, 각각의 공식 출시에 대한 자세한 정보는 여기에서 참조할 수 있습니다.특정 사본을 사용하도록 Flow Production Tracking 데스크톱 구성시작 로직을 잠그는 유일한 방법은 환경 변수를 사용하는 것입니다. SGTK_DESKTOP_STARTUP_LOCATION을 프레임워크 사본의 루트 폴더로 설정하면 Flow Production Tracking 데스크톱으로 하여금 시작 시 이 코드 사본을 사용하도록 할 수 있습니다. 이 변수를 설정하면 Flow Production Tracking 데스크톱을 실행할 수 있고, 그러면 이 특정한 시작 로직 사본을 사용하게 됩니다.  현재는 기술적 한계로 인해 시작 로직을 잠글 때 About... 상자의 Startup Version 필드는 Undefined 상태로 유지된다는 점에 유의해 주십시오.이전 동작으로 되돌리기변경 사항을 되돌리려면 환경 변수 설정을 해제하고 Flow Production Tracking 데스크톱을 실행하면 됩니다.",
    "url": "/3414fbb3/",
    "relUrl": "/3414fbb3/"
  },
  "150": {
    "id": "150",
    "title": "Hiero/Nuke Studio 내보내기",
    "content": "Hiero/Nuke Studio 내보내기소개이 앱은 Hiero의 시퀀스에 대한 내보내기 대화상자에 Flow Production Tracking 인식 기능을 추가합니다.개요 동영상 및 데모Flow Production Tracking 툴킷 또는 Hiero 통합을 처음 사용하는 경우 Flow Production Tracking 툴킷 Hiero 통합을 통해 파이프라인에서 수행할 수 있는 작업의 개요를 빠르게 진행하는 다음 동영상을 확인합니다.툴킷 및 Hiero에 이미 익숙하다면 언제든지 아래의 문서를 계속 진행합니다.Flow Production Tracking 샷 프로세서이 앱 자체가 활성화되면 Hiero 내보내기 대화상자에 여러 변경 사항이 등록됩니다.가장 먼저 주목해야 할 항목은 등록된 새 프로세서입니다.이 프로세서를 클릭할 때 주의해야 할 새로운 사항이 있습니다.대화상자 상단에는 시퀀스를 내보낸 결과로 Flow Production Tracking에서 샷이 생성/업데이트되는 방식을 제어할 수 있는 추가 UI가 있습니다.태그드롭다운을 조정하여 다양한 Hiero 태그를 Flow Production Tracking 샷 상태 및 샷 태스크 템플릿에 매핑할 수 있습니다.  따라서 Hiero의 태그 지정 워크플로우를 통해 Flow Production Tracking 샷을 진행 중으로 설정하거나 그린 스크린, cg 추가 또는 구성에 맞는 샷의 태스크를 설정할 수 있습니다.  이 UI는 후크를 통해 입력되며 추가 기능을 구성하기 쉽습니다.결합또한 Hiero의 기본 제공 로직을 미러링하여 함께 트랙 항목을 결합할 수 있는 옵션이 있습니다. 샷을 구성하는 항목이 여러 개일 경우(서로 다른 트랙에서 겹치거나 여러 트랙에 동일한 샷 이름이 있는 경우) 이 옵션을 켜야 합니다. 그러면 Flow Production Tracking 툴킷 샷 업데이트 프로그램이 일치하는 결합된 항목을 단일 샷으로 처리합니다.예를 들어 샷 010과 020을 나타내는 두 개의 트랙 항목이 있다고 가정합니다. 010이 먼저 나오고 020은 다른 트랙의 010 끝에 겹칩니다. 010이 먼저 나오므로 Hiero이며 결합이 활성화된 상태에서 Flow Production Tracking는 두 항목을 단일 샷 010으로 처리합니다. 즉, Flow Production Tracking에 샷 010이 생성되거나 업데이트됨을 의미합니다. 컷 인은 트랙 항목 010의 시작 부분과 일치하고 컷 아웃은 트랙 항목 020의 끝 부분과 일치합니다. 각 항목에 대해 Screening Room에서 바로 사용할 수 있는 버전이 생성되지만 둘 다 샷 010에 링크됩니다. 각 항목에 대해 게시된 파일로 플레이트가 생성되지만 둘 다 샷 010에 링크됩니다. 2개의 읽기 노드를 포함하는 샷 010에 링크된 단일 Nuke 스크립트가 각 항목에 하나씩 게시됩니다. 이 상황에서는 샷 010에 결합되었기 때문에 Flow Production Tracking에서 샷 020에 대한 생성이나 업데이트가 없습니다.경로아래 Flow Production Tracking UI는 표준 경로 대화상자입니다.  기본적으로 Hiero를 통해 샷에 추가되는 세 가지 항목이 있으며 이는 기본 Nuke 스크립트, 기본 Nuke 쓰기 위치 및 플레이트 트랜스코드의 기본 위치입니다. 이러한 항목의 위치는 앱 구성에 따라 결정되며 템플릿 시스템을 최대한 활용할 수 있습니다.이 앱은 Flow Production Tracking 툴킷용으로 올바르게 형식이 지정되고 버전 문자열로 대체될 {tk_version} 토큰을 Hiero에 추가합니다.커스텀 템플릿 필드resolve_custom_strings 후크로 확인되는 custom_template_fields 설정에서 정의하는 모든 토큰은 Hiero의 유효한 대체 토큰 목록에 자동으로 추가되며 툴킷 템플릿 경로에서 유효한 대체 토큰으로 간주됩니다.예를 들어 툴킷 templates.yml 파일에서 다음과 같이 키를 정의한다고 가정합니다.    resolution:        type: str        filter_by: alphanumeric  project.yml 설정에서 tk-hiero-export는 다음과 같이 정의합니다.  ...  ...  tk-hiero:    apps:      tk-hiero-export:        custom_template_fields:        - {description: Shot Resolution, keyword: resolution}  ...  ...그런 후 다음과 같이 resolve_custom_strings 후크를 수정합니다.# Copyright (c) 2014 Flow Production Tracking Software Inc.## CONFIDENTIAL AND PROPRIETARY## This work is provided &quot;AS IS&quot; and subject to the Flow Production Tracking Toolkit# Source Code License included in this distribution package. See LICENSE.# By accessing, using, copying or modifying this work you indicate your# agreement to the Flow Production Tracking Toolkit Source Code License. All rights# not expressly granted therein are reserved by Flow Production Tracking Software Inc.from tank import Hookclass HieroResolveCustomStrings(Hook):    &quot;&quot;&quot;Translates a keyword string into its resolved value for a given task.&quot;&quot;&quot;    RESOLUTION_TOKEN_NAME = &quot;{resolution}&quot;    def execute(self, task, keyword, **kwargs):        &quot;&quot;&quot;        &quot;&quot;&quot;        self.parent.log_debug(&quot;attempting to resolve custom keyword: %s&quot; % keyword)        if keyword == self.RESOLUTION_TOKEN_NAME:            translated_value = self._clip_resolution_string(task)        else:            raise RuntimeError(&quot;No translation handler found for custom_template_field: %s&quot; % keyword)        self.parent.log_debug(&quot;Custom resolver: %s -&amp;gt; %s&quot; % (keyword, translated_value))        return translated_value    # Handle the {resolution_fs} token    def _clip_resolution_string(self, task):        &quot;&quot;&quot; returns sequence resolution or task format override&quot;&quot;&quot;        width = &quot;&quot;        height = &quot;&quot;        sequence_format = task._sequence.format()        width = sequence_format.width()        height = sequence_format.height()        if &quot;reformat&quot; in task._preset.properties():            task_reformat_settings = task._preset.properties()[&quot;reformat&quot;]            if task_reformat_settings['to_type'] != &quot;None&quot;:                width = task_reformat_settings['width']                height = task_reformat_settings['height']        return &quot;%sx%s&quot; % (width, height)이제 Hiero에서 resolution 토큰을 사용할 수 있을 뿐만 아니라 툴킷에서 정의한 모든 템플릿 경로에 대해 유효성을 검사하므로 다음과 같은 위치로 내보낼 수 있습니다.    hiero_plate_path: &quot;sequences/{Sequence}/{Shot}/hiero_plates/{resolution}/v{version}/{project}_{Shot}.mov&quot;Flow Production Tracking 태스크두 개의 새로운 태스크 유형이 등록되었습니다.Flow Production Tracking 트랜스코드 이미지이 유형은 표준 Hiero 트랜스코딩 태스크의 하위 클래스로, Flow Production Tracking에서 트랜스코드 결과를 게시로 등록합니다.  선택적으로 버전도 Flow Production Tracking에 생성됩니다.  버전이 생성되면 Quicktime도 생성되어 Screening Room 미디어로 업로드됩니다.Flow Production Tracking Nuke 프로젝트 파일이 유형은 표준 Hiero Nuke 스크립트 내보내기의 하위 클래스로, Flow Production Tracking에서 샷에 링크된 결과 Nuke 스크립트를 게시된 파일로 등록합니다. 이 설정을 통해 내보낼 때 파일에 포함할 툴킷 사용 쓰기 노드를 지정할 수 있습니다.앱 설정 plate_published_file_type 및 nuke_script_published_file_type을 사용하여 게시된 파일이 등록되는 파일 유형을 제어할 수 있습니다. 또한 nuke_script_toolkit_write_nodes를 사용하여 내보내기 대화상자에서 사용 가능한 쓰기 노드 설정을 제어할 수 있습니다.내보내기 프로세스내보내기가 실행되면 내보내기 대기열에 몇 가지 추가 태스크가 표시됩니다.각 샷은 Flow Production Tracking에 샷을 생성하고 스키마 구성에 지정된 전체 샷 구조를 생성하는 Flow Production TrackingShotUpdater 태스크를 실행합니다.ShotGrid의 시퀀스 및 샷 업데이트Hiero 시퀀스의 이름이 시퀀스 이름으로 사용되며 샷의 컷 정보(컷 순서, 헤드 인, 컷 인, 컷 아웃, 테일 아웃, 컷 기간 및 작업 시간)가 입력됩니다. 또한 샷을 구성하는 항목 또는 시퀀스의 포스터 프레임이 선택되면 샷의 썸네일로 업로드됩니다.워크플로우에서 시퀀스 외의 엔티티를 샷 상위(예: 에피소드)로 사용하는 경우 hook_get_shot 후크에서 get_shot_parent 방식을 재지정할 수 있습니다. 기본 구현은 필요한 경우 시퀀스를 만들고 반환합니다.컷 스키마 지원Flow Production Tracking 사이트가 컷 스키마(v7.0.0 이상)를 지원하는 경우 이 앱은 Flow Production Tracking에 해당 컷 항목이 있는 컷을 자동으로 생성합니다.  컷 엔티티는 Hiero 시퀀스에 해당하며 컷 항목은 시퀀스의 항목에 해당합니다. 컷은 hook_get_shot 후크의 get_shot_parent 방식에 의해 반환될 때 상위 엔티티(기본적으로 시퀀스)에 링크됩니다. 컷 항목은 샷 엔티티와 연결되고 내보내기 중에 생성된 리뷰 가능한 버전에 링크됩니다. 내보내기 후 컷은 Flow Production Tracking의 미디어 탭 및 RV에서 재생할 수 있습니다.컷 및 컷 항목 엔티티와 관련된 모든 메타데이터는 내보내기 UI에서 지정할 수 있는 컷 유형(Cut Type) 필드를 제외하고 Hiero에서 추정됩니다.해당 값은 컷의 유형 필드에 표시됩니다.결합 옵션 중 하나가 선택된 경우 컷 스키마가 지원되지 않으며 컷 및 컷 항목 항목 생성을 건너뜁니다.또한 컷 스키마는 리타임된 클립을 처리하지 않습니다. 리타임된 클립을 내보낼 때 디버그 경고가 기록됩니다.대체 샷 계층표준 시퀀스 &amp;gt; 샷 계층에서 작업하지 않지만 에피소드 및/또는 씬을 사용하는 스튜디오의 경우에는 hiero_get_shot 후크를 통해 스튜디오에서 사용 중인 모든 샷 계층에서 작동하도록 앱을 구성할 수 있습니다.",
    "url": "/523d3720/",
    "relUrl": "/523d3720/"
  },
  "151": {
    "id": "151",
    "title": "ShotGrid에서 Hiero/Nuke Studio 열기",
    "content": "ShotGrid에서 Hiero/Nuke Studio 열기이 앱은 Hiero 스프레드시트 및 타임라인에 상황에 맞는 메뉴를 추가합니다. 사용자는 이 메뉴를 사용하여 해당 항목의 샷이 있는 경우 Flow Production Tracking에서 지정된 트랙 항목을 열 수 있습니다.일반적으로 Nuke용 Flow Production Tracking 엔진 구성에 다음을 추가함으로써 Hiero의 타임라인 및 스프레드시트 메뉴에 추가하여 이 앱을 구성합니다.    timeline_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: &quot;Open in Flow Production Tracking&quot;, requires_selection: true}    spreadsheet_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: &quot;Open in Flow Production Tracking&quot;, requires_selection: true}",
    "url": "/88ae1c1d/",
    "relUrl": "/88ae1c1d/"
  },
  "152": {
    "id": "152",
    "title": "Houdini Alembic Node",
    "content": "Houdini Alembic NodeHoudini Alembic Node 앱은 alembic 파일이 출력되는 위치를 쉽게 표준화할 수 있는 커스텀 Flow Production Tracking Alembic Output 노드를 제공합니다.  각 환경에 맞게 구성할 수 있습니다.일반적인 사용Flow Production Tracking Alembic 출력을 사용하려면 먼저 스크립트를 툴킷 작업 파일로 저장한 다음 Houdini의 TAB 메뉴를 통해 새 노드를 만듭니다. 이렇게 하면 일반적인 Alembic 출력 노드와 비슷한 노드가 생성됩니다.노드는 여러 출력 프로파일로 구성될 수 있으며, 각 출력 프로파일은 alembic 캐시를 디스크에 기록해야 하는 위치에 대해 서로 다른 템플릿 경로를 사용합니다.직접 경로를 입력하는 대신 사용할 출력 프로파일을 지정하면 노드가 나머지 경로를 자동으로 계산합니다. UI에서 계산된 경로를 볼 수 있습니다.출력 alembic 파일의 버전이 지정되고 버전 번호의 경우 항상 Multi Publish를 사용하여 게시할 때 자동으로 증가되는 현재 Houdini 씬 파일 버전을 따릅니다.구성툴킷 alembic 노드는 환경 구성에 대해 여러 출력 프로파일을 지정할 수 있는 기능을 제공합니다. 다음은 여러 프로파일을 사용하여 노드를 구성하는 예입니다.  tk-houdini:    apps:      tk-houdini-alembicnode:        location:          name: tk-houdini-alembicnode          type: app_store          version: v0.2.2        work_file_template: houdini_shot_work        default_node_name: tk_alembic_out        output_profiles:          - name: For Publishing            settings: {}            color: [1.0, 0.5, 0.0]            output_cache_template: houdini_shot_work_alembic_cache          - name: Local Testing            settings: {}            color: [0.0, 0.5, 1.0]            output_cache_template: houdini_shot_local_alembic_cache출력 프로파일을 사용하여 color 필드를 통해 노드 모양을 변경하고 settings 필드에 해당 매개변수와 일치하는 키/값 쌍을 제공하여 기본 Alembic 노드에서 개별 매개변수를 조정할 수 있습니다. 마지막으로, output_cache_template 필드는 디스크에 기록된 alembic 캐시의 출력 경로를 구동합니다.",
    "url": "/55f75584/",
    "relUrl": "/55f75584/"
  },
  "153": {
    "id": "153",
    "title": "Houdini Mantra Node",
    "content": "Houdini Mantra NodeHoudini Mantra Node 앱은 렌더 파일이 출력되는 위치를 쉽게 표준화할 수 있는 커스텀 Flow Production Tracking Mantra 출력 노드를 제공합니다.  각 환경에 맞게 구성할 수 있습니다.일반적인 사용Flow Production Tracking Mantra 노드를 사용하려면 먼저 스크립트를 툴킷 작업 파일로 저장한 다음 Houdini의 TAB 메뉴를 통해 새 노드를 만듭니다. 이렇게 하면 일반적인 Mantra 출력 노드와 비슷한 노드가 만들어집니다.이 노드는 여러 출력 프로파일로 구성될 수 있으며, 각 출력 프로파일은 렌더 출력(이미지, ifd, dcm, aov 등)을 디스크에 기록해야 하는 위치에 대해 서로 다른 템플릿 경로 세트를 사용합니다.직접 경로를 입력하는 대신 사용할 구성을 지정하면 노드가 나머지 경로를 자동으로 계산합니다. UI에서 계산된 경로를 볼 수 있습니다.렌더링된 파일의 버전이 지정되고 버전 번호의 경우 항상 Multi Publish를 사용하여 게시할 때 자동으로 증가되는 현재 Houdini 씬 파일 버전을 따릅니다.구성툴킷 mantra 노드는 환경 구성에 대해 여러 출력 프로파일을 지정할 수 있는 기능을 제공합니다. 다음은 여러 프로파일을 사용하여 노드를 구성하는 예입니다.  tk-houdini:    apps:      tk-houdini-mantranode:        location:          name: tk-houdini-mantranode          type: dev          version: v0.2.2        default_node_name: tk_mantra_out        work_file_template: houdini_shot_work        output_profiles:          - name: Primary Render            settings: {}            color: [1.0, 0.5, 0.0]            output_render_template: houdini_shot_render            output_ifd_template: houdini_shot_ifd            output_dcm_template: houdini_shot_dcm            output_extra_plane_template: houdini_shot_extra_plane          - name: Local Render            settings: {}            color: [0.0, 0.5, 1.0]            output_render_template: houdini_shot_local_render            output_ifd_template: houdini_shot_local_ifd            output_dcm_template: houdini_shot_local_dcm            output_extra_plane_template: houdini_shot_local_extra_plane출력 프로파일을 사용하여 color 필드를 통해 노드 모양을 변경하고 settings 필드에 해당 매개변수와 일치하는 키/값 쌍을 제공하여 기본 Alembic 노드에서 개별 매개변수를 조정할 수 있습니다. 마지막으로, output_*_template 필드는 Mantra 렌더러에 의해 디스크에 기록된 파일의 출력 경로를 구동합니다.",
    "url": "/2c47f879/",
    "relUrl": "/2c47f879/"
  },
  "154": {
    "id": "154",
    "title": "Houdini",
    "content": "HoudiniHoudini용 Flow Production Tracking 엔진에는 Flow Production Tracking 앱을 Houdini에 통합하기 위한 표준 플랫폼이 포함되어 있습니다.앱 개발자를 위한 정보지원되는 플랫폼Houdini용 Flow Production Tracking 엔진은 현재 Windows, Linux 및 OSX에서 지원됩니다.지원되는 응용프로그램 버전이 항목은 테스트를 거쳐 다음 응용프로그램 버전에서 작동하는 것으로 알려져 있습니다.17.5 - 19.5 Note: Running on Apple Silicon (M1/M2), Houdini is supported for both Native mode and Rosetta mode.PySideHoudini의 이전 버전(13 이하)은 PySide의 외부 빌드가 필요합니다. Windows에서는 Houdini가 실행되는 Python에서 작동하는 호환 가능한 PySide 빌드가 번들로 제공됩니다. Linux에서 Houdini는 PySide 또는 PyQt를 지원해야 하는 시스템 Python(https://www.sidefx.com/docs/houdini12.0/hom/)을 사용합니다.메뉴 로드Houdini 15의 파생 효과로 동적 메뉴 시스템이 도입되어 이제 엔진은 컨텍스트 스위치에서 Flow Production Tracking 메뉴를 다시 작성할 수 있습니다.Houdini 14 이하에서는 Houdini의 Flow Production Tracking 메뉴가 Houdini가 시작되기 전에 생성되며 세션 전체에서 정적입니다. 이로 인해 메뉴에 등록된 툴킷 명령은 컨텍스트 변경 시 업데이트되지 않습니다.Flow Production Tracking 쉘프v0.2.4 릴리즈는 엔진에 동적 Flow Production Tracking 쉘프를 도입했습니다. 쉘프에는 등록된 모든 앱 명령이 도구 버튼으로 표시됩니다. 버튼은 메뉴 명령과 거의 동일한 순서로 표시됩니다.enable_sg_shelf 설정을 사용하여 환경 내에서 쉘프를 켭니다. 동적 메뉴를 지원하지 않는 Houdini 버전(14 이하)을 사용하는 경우 쉘프 사용 시 Flow Production Tracking 메뉴를 끌 수도 있습니다. 이 작업은 enable_sg_menu 설정을 false로 설정하여 수행할 수 있습니다.쉘프를 통해 컨텍스트 전환을 활성화하려면 엔진 구성에서 tk-multi-workfiles 앱의 sg_entity_types 설정에 엔티티 유형도 추가해야 합니다.Flow Production Tracking 쉘프와 관련된 설정을 살펴보겠습니다.tk-houdini:  apps:    # ... other app definitions    tk-multi-workfiles:       # ... other app settings       sg_entity_types: [Shot, Asset] # allow context switching to Shots or Assets       # ... other app settings  enable_sg_shelf: true  enable_sg_menu: false  # ... other engine settingsFlow Production Tracking 쉘프를 활성화한 후에는 수동으로 houdini 내부의 쉘프 세트에 추가해야 합니다.쉘프 세트에 추가되면 Flow Production Tracking 쉘프는 houdini 세션 간에 유지되며 Flow Production Tracking 컨텍스트가 변경되면 동적으로 업데이트됩니다.패널v0.2.8부터 엔진은 포함된 툴킷 패널에 대한 지원을 추가합니다.적절한 내장 패널을 지원하려면 현재 Houdini 버전 15.0.272 이상이 필요합니다. 등록된 패널은 지원되는 Houdini 버전의 창 메뉴에 창으로 표시됩니다.Houdini의 이전 버전은 등록된 패널을 대화상자로 표시합니다. SESI는 몇 가지 버그 수정을 Houdini 14의 최신 빌드로 백포팅할 수 있습니다. 그러면 해당 버전에도 내장 패널을 사용할 수 있습니다.OTL을 사용하는 앱Houdini용 Flow Production Tracking 엔진을 사용하면 응용프로그램에서 제공하는 OTL을 쉽게 로드할 수 있습니다. OTL을 사용하는 앱을 작성하는 경우 otls라는 폴더에 OTL을 배치하기만 하면 엔진에서 자동으로 세션에 로드합니다.그런 다음 일반적인 Houdini 방법을 통해 노드에 쉽게 액세스할 수 있습니다.경고!! OTL을 사용하는 것이 편리할 수 있지만 씬에 지속되는 노드를 만들려는 경우에는 일반적으로 적절한 솔루션이 아닙니다. 그 이유는 씬에 OTL을 추가하면 씬과 OTL 코드 간에 종속성이 발생하기 때문입니다. 씬을 로드할 때마다 Flow Production Tracking 툴킷을 로드해야 할 뿐만 아니라 코드를 업데이트해도 씬에서 사용 중인 이전 OTL이 손상되지 않도록 신중하게 코드를 관리해야 합니다.OSX에서 터미널을 통한 디버깅 시작OS X에서 tk-houdini 엔진의 debug_logging을 켜면 모든 디버그 메시지를 터미널로 전송하지 않습니다. 이는 기본적으로 tk-multi-launchapp 앱에서 open 명령을 사용하여 실행 파일을 시작하기 때문입니다. 이는 터미널에서 새로운 하위 프로세스를 생성하지 않지만 OS X의 시작 서비스를 사용하여 다른 곳에서 새 프로세스를 만듭니다. 결과적으로 로그 문은 표시되지 않습니다. Houdini에서 사용자의 기본 데스크톱에 python 셸이 저장되어 있어도 시작 중에 디버깅 문을 표시하지 않는 것처럼 보입니다. 시작 후 내장 python 셸은 디버그 로깅 문을 표시하지만 시작 중에 사용 가능한 출력과 차이가 있습니다. 엔진 시작 중에 디버그 로깅 문에 액세스해야 하는 경우 두 가지를 변경할 수 있습니다.먼저 테스트 구성에서 houdini_mac 경로를 Houdini 앱 번들 내부의 실행 파일을 가리키도록 임시로 변경합니다. 예를 들면 다음과 같습니다.#houdini_mac: /Applications/Houdini 15.0.272/Houdini Apprentice.apphoudini_mac: /Applications/Houdini  15.0.272/Houdini  Apprentice.app/Contents/MacOS/happrentice다음으로 테스트 구성의 config/hooks 디렉토리에서 tk-multi-launchapp 앱의 app_launch 후크 복사본을 만들어 config/env/includes/app_launchers.yml 파일에서 이를 지정할 수 있습니다.launch_houdini:  defer_keyword: ''  engine: tk-houdini  extra: {}  hook_app_launch: app_launch    # &amp;lt;----- use a custom app_launch hook  hook_before_app_launch: default  icon: '{target_engine}/icon_256.png'  linux_args: ''  linux_path: '@houdini_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.6.6}  mac_args: ''  mac_path: '@houdini_mac'  menu_name: Launch Houdini  versions: []  windows_args: ''  windows_path: '@houdini_windows'그런 다음 실행 파일을 직접 시작하도록 시작 로직을 수정하기만 하면 됩니다. 예를 들어 디렉토리(응용프로그램 번들)에 대한 이전 동작을 유지하고 명령을 직접 실행할 수 있습니다. 다음은 예입니다.        elif system == &quot;darwin&quot;:            # on the mac, the executable paths are normally pointing            # to the application bundle and not to the binary file            # embedded in the bundle, meaning that we should use the            # built-in mac open command to execute it            if os.path.isdir(app_path):                cmd = &quot;open -n  &quot;%s &quot;&quot; % (app_path)                if app_args:                    cmd += &quot; --args  &quot;%s &quot;&quot; % app_args.replace(&quot; &quot;&quot;, &quot;   &quot;&quot;)            # not a directory, execute directly            else:                cmd = &quot;%s %s&quot; % (app_path, app_args.replace(&quot; &quot;&quot;, &quot;   &quot;&quot;))다음에 터미널에서 tank를 통해 launch_houdini를 실행하면 모든 디버그 출력이 표시됩니다. 테스트가 끝나면 경로를 되돌리고 앱 시작 변경 사항을 취소해야 합니다. 디버깅이 완료되었습니다.",
    "url": "/797202da/",
    "relUrl": "/797202da/"
  },
  "155": {
    "id": "155",
    "title": "Mari Project Manager",
    "content": "Mari Project ManagerMari Project Manager는 Mari에서 새 프로젝트를 생성하는 프로세스를 간소화하여 아티스트가 Flow Production Tracking Loader를 사용하여 로드할 게시된 지오메트리를 신속하게 선택할 수 있게 해 줍니다. 이 앱으로 생성한 프로젝트는 Flow Production Tracking를 인식하므로, 아티스트가 내보내기 옵션 및 파일 위치에 대해 염려할 필요 없이 파이프라인의 다른 부분에 텍스처를 게시할 수 있습니다.",
    "url": "/82aaf735/",
    "relUrl": "/82aaf735/"
  },
  "156": {
    "id": "156",
    "title": "Mari",
    "content": "MariMari용 Flow Production Tracking 엔진에는 Flow Production Tracking 툴킷 앱을 Mari에 통합하기 위한 표준 플랫폼이 포함되어 있습니다. 간단하고 직접적인 이 플랫폼은 기본 메뉴에 Flow Production Tracking 메뉴를 추가합니다.지원되는 응용프로그램 버전이 항목은 테스트를 거쳐 다음 응용프로그램 버전에서 작동하는 것으로 알려져 있습니다.4.0 - 6.0v2최신 릴리즈에서는 더 완벽하게 작동할 수 있지만 이러한 버전에서 아직 공식적으로 테스트되지는 않았습니다.개요 동영상여기에서 개요 동영상을 참조하십시오.설치 및 업데이트Flow Production Tracking Toolkit에 이 엔진 추가asset 환경의 XYZ 프로젝트에 이 엔진을 추가하려면 다음 명령을 실행합니다.&amp;gt; tank Project XYZ install_engine asset tk-mari최신 버전으로 업데이트프로젝트에 이 항목이 이미 설치되어 있는 경우 최신 버전을 얻으려면 update 명령을 실행할 수 있습니다. 특정 프로젝트와 함께 제공되는 tank 명령을 탐색하여 다음과 같이 실행할 수 있습니다.&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updates또는 스튜디오 tank 명령을 실행하고 업데이트 확인을 실행할 프로젝트 이름을 지정할 수 있습니다.&amp;gt; tank Project XYZ updates협업 및 개선Flow Production Tracking Toolkit에 액세스할 수 있다면 모든 앱, 엔진 및 Flow Production Tracking가 저장 및 관리되는 Github에서 그 소스 코드에도 액세스할 수 있습니다. 이러한 항목을 자유롭게 개선하여 향후 독립적인 개발을 위한 기반으로 사용하고 변경 후 다시 사용자 요청을 제출하거나, 아니면 그냥 조금만 손을 보고 어떻게 빌드되었는지, 툴킷이 어떻게 작동하는지 확인해 보십시오. https://github.com/shotgunsoftware/tk-mari에서 이 코드 리포지토리에 액세스할 수 있습니다.",
    "url": "/301f5e66/",
    "relUrl": "/301f5e66/"
  },
  "157": {
    "id": "157",
    "title": "오류 {% include product %} tk-maya 툴킷에서 예외가 발생했습니다.",
    "content": "오류: Flow Production Tracking tk-maya: 툴킷에서 예외가 발생했습니다.활용 사례툴킷 앱이 실행을 트리거할 때 커스텀 인자를 수신하도록 설정할 수 있습니다.예를 들어, 앱을 실행할 때 상태에 따라 앱이 다르게 시작되도록 하는 상태 플래그를 제공할 수 있습니다.다음은 이미 사용되고 있는 몇 가지 예입니다.  tk-shotgun-folders 앱(Shotgun 웹 앱에서 선택한 엔티티를 기반으로 폴더 생성)은 사용자가 Shotgun 웹 앱에서 선택하고 다음에서 액션을 실행한 Shotgun 엔티티 및 엔티티 유형을 전달합니다. https://github.com/shotgunsoftware/tk-shotgun-folders/blob/v0.1.7/app.py#L86  tk-multi-launchapp(Shotgun 통합을 통해 소프트웨어 시작을 담당)은 file_to_open 인자를 전달할 수 있습니다. 이 인자는 소프트웨어를 시작한 후 파일을 여는 데 사용됩니다. https://github.com/shotgunsoftware/tk-multi-launchapp/blob/v0.11.2/python/tk_multi_launchapp/base_launcher.py#L157 일반적으로 Flow Production Tracking 데스크톱을 통해 소프트웨어를 시작하면 file_to_open 인자가 제공되지 않지만, 중앙 집중식 구성(tank maya_2019 /path/to/maya/file.mb)을 사용하는 경우 tank 명령을 통해 앱을 호출할 수 있습니다. 또한 tk-shotgun-launchpublish 앱도 tk-multi-launchapp을 시작하고 게시된 파일을 file_to_open 인자로 제공합니다. https://github.com/shotgunsoftware/tk-shotgun-launchpublish/blob/v0.3.2/hooks/shotgun_launch_publish.py#L126-L133인자를 허용하도록 앱 프로그래밍커스텀 앱을 작성하는 경우 필요한 인자를 허용하도록 엔진에 등록되는 콜백 메서드만 설정하면 됩니다.다음은 두 개의 인자가 필요하고 추가 인자를 허용하고 출력하도록 설정된 간단한 앱입니다.from sgtk.platform import Applicationclass AnimalApp(Application):    def init_app(self):        self.engine.register_command(&quot;print_animal&quot;, self.run_method)    def run_method(self, animal, age, *args):        print (&quot;&quot;,animal)        print (&quot;age&quot;,age)        print (&quot;args&quot;, args)tank 명령에서 실행이제 셸에서 다음 tank 명령을 실행하면 ./tank print_animal cat 7 Tortoiseshell large다음과 같은 결과가 출력됩니다....----------------------------------------------------------------------Command: Print animal----------------------------------------------------------------------libpng warning: iCCP: known incorrect sRGB profile('animal', 'cat')('age', '7')('args', ('Tortoiseshell', 'large'))스크립트에서 실행tk-shell 엔진의 스크립트에서 앱을 호출하려면 다음을 수행할 수 있습니다.# This assumes you have a reference to the `tk-shell` engine.engine.execute_command(&quot;print_animal&quot;, [&quot;dog&quot;, &quot;3&quot;, &quot;needs a bath&quot;])&amp;gt;&amp;gt;# ('animal', 'dog')# ('age', '3')# ('args', ('needs a bath',))Maya를 사용 중이면 다음과 같은 작업을 수행할 수 있습니다.import sgtk# get the engine we are currently running in.engine = sgtk.platform.current_engine()# Run the app.engine.commands['print_animal']['callback'](&quot;unicorn&quot;,4,&quot;it's soooo fluffy!!!!&quot;)&amp;gt;&amp;gt;# ('animal', 'unicorn')# ('age', 4)# ('args', (&quot;it's soooo fluffy!!!!&quot;,))오류 메시지Maya의 메뉴에서 앱을 시작하려고 하면 다음과 같은 오류가 발생합니다.// Error: Shotgun tk-maya: An exception was raised from ToolkitTraceback (most recent call last):  File &quot;/Users/philips1/Library/Caches/Shotgun/bundle_cache/app_store/tk-maya/v0.10.1/python/tk_maya/menu_generation.py&quot;, line 234, in _execute_within_exception_trap    self.callback()  File &quot;/Users/philips1/Library/Caches/Shotgun/mysite/p89c1.basic.maya/cfg/install/core/python/tank/platform/engine.py&quot;, line 1082, in callback_wrapper    return callback(*args, **kwargs)TypeError: run_method() takes at least 3 arguments (1 given) //이는 앱이 인자를 요구하도록 설정되어 있고 메뉴 버튼은 인자를 제공하도록 설정되어 있지 않기 때문입니다.해결 방법다음과 같은 키워드 인자를 사용하도록 앱의 run_method를 작성하는 것이 좋습니다.    def run_method(self, animal=None, age=None, *args):        print (&quot;&quot;,animal)        print (&quot;age&quot;,age)        print (&quot;args&quot;, args)그러면 인자가 제공되지 않을 경우 발생하는 문제를 처리하고 폴백 동작을 구현할 수 있습니다.커뮤니티에서 전체 스레드를 참조하십시오.",
    "url": "/0c5e6ac8/",
    "relUrl": "/0c5e6ac8/"
  },
  "158": {
    "id": "158",
    "title": "Maya",
    "content": "MayaMaya용 Flow Production Tracking 엔진에는 Flow Production Tracking 앱을 Maya에 통합하기 위한 표준 플랫폼이 포함되어 있습니다. 직접적으로 실행되는 경량의 플랫폼으로, Maya 메뉴 막대에 Flow Production Tracking 메뉴를 추가합니다.지원되는 응용프로그램 버전이 항목은 테스트를 거쳐 다음 응용프로그램 버전에서 작동하는 것으로 알려져 있습니다.2020 - 2024 Note: Apple Silicon (M1/M2) native is supported starting with Maya 2024.최신 릴리즈에서는 더 완벽하게 작동할 수 있지만 이러한 버전에서 아직 공식적으로 테스트되지는 않았습니다.PysideMaya용 Flow Production Tracking 엔진에는 PySide 설치가 포함되어 있으며 필요할 때마다 활성화됩니다.Maya 프로젝트 관리Maya용 Flow Production Tracking 엔진이 시작되면 Maya 프로젝트가 이 엔진 설정에서 정의된 위치를 가리키도록 설정됩니다. 즉, 새 파일을 열면 프로젝트가 변경될 수도 있습니다. 파일을 기반으로 Maya 프로젝트가 설정되는 방법과 관련된 상세 정보는 템플릿 시스템을 사용하여 구성 파일에서 구성할 수 있습니다.설치 및 업데이트Flow Production Tracking Toolkit에 이 엔진 추가asset 환경의 XYZ 프로젝트에 이 엔진을 추가하려면 다음 명령을 실행합니다.&amp;gt; tank Project XYZ install_engine asset tk-maya최신 버전으로 업데이트프로젝트에 이 항목이 이미 설치되어 있는 경우 최신 버전을 얻으려면 update 명령을 실행할 수 있습니다. 특정 프로젝트와 함께 제공되는 tank 명령을 탐색하여 다음과 같이 실행할 수 있습니다.&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updates또는 스튜디오 tank 명령을 실행하고 업데이트 확인을 실행할 프로젝트 이름을 지정할 수 있습니다.&amp;gt; tank Project XYZ updates협업 및 개선Flow Production Tracking Toolkit에 액세스할 수 있다면 모든 앱, 엔진 및 프레임워크가 저장 및 관리되는 Github에서 그 소스 코드에도 액세스할 수 있습니다. 이러한 항목을 자유롭게 개선하여 향후 독립적인 개발을 위한 기반으로 사용하고 변경 후 다시 사용자 요청을 제출하거나, 아니면 그냥 조금만 손을 보고 어떻게 빌드되었는지, 툴킷이 어떻게 작동하는지 확인해 보십시오. https://github.com/shotgunsoftware/tk-maya에서 이 코드 리포지토리에 액세스할 수 있습니다.",
    "url": "/9e62da4a/",
    "relUrl": "/9e62da4a/"
  },
  "159": {
    "id": "159",
    "title": "Motion Builder",
    "content": "Motion BuilderMotion Builder용 Flow Production Tracking 엔진에는 Flow Production Tracking 툴킷 앱을 Motion Builder에 통합하기 위한 표준 플랫폼이 포함되어 있습니다. 간단하고 직접적인 이 플랫폼은 기본 메뉴에 Flow Production Tracking 메뉴를 추가합니다.지원되는 응용프로그램 버전이 항목은 테스트를 거쳐 다음 응용프로그램 버전에서 작동하는 것으로 알려져 있습니다.2020 - 2024최신 릴리즈에서는 더 완벽하게 작동할 수 있지만 이러한 버전에서 아직 공식적으로 테스트되지는 않았습니다.설치 및 업데이트Flow Production Tracking Toolkit에 이 엔진 추가asset 환경의 XYZ 프로젝트에 이 엔진을 추가하려면 다음 명령을 실행합니다.&amp;gt; tank Project XYZ install_engine asset tk-motionbuilder최신 버전으로 업데이트프로젝트에 이 항목이 이미 설치되어 있는 경우 최신 버전을 얻으려면 update 명령을 실행할 수 있습니다. 특정 프로젝트와 함께 제공되는 tank 명령을 탐색하여 다음과 같이 실행할 수 있습니다.&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updates또는 스튜디오 tank 명령을 실행하고 업데이트 확인을 실행할 프로젝트 이름을 지정할 수 있습니다.&amp;gt; tank Project XYZ updates협업 및 개선Flow Production Tracking Toolkit에 액세스할 수 있다면 모든 앱, 엔진 및 프레임워크가 저장 및 관리되는 Github에서 그 소스 코드에도 액세스할 수 있습니다. 이러한 항목을 자유롭게 개선하여 향후 독립적인 개발을 위한 기반으로 사용하고 변경 후 다시 사용자 요청을 제출하거나, 아니면 그냥 조금만 손을 보고 어떻게 빌드되었는지, 툴킷이 어떻게 작동하는지 확인해 보십시오. https://github.com/shotgunsoftware/tk-motionbuilder에서 이 코드 리포지토리에 액세스할 수 있습니다.",
    "url": "/54009c12/",
    "relUrl": "/54009c12/"
  },
  "160": {
    "id": "160",
    "title": "정보",
    "content": "정보이 앱은 현재 작업 영역과 현재 환경에서 실행 중인 모든 앱을 그래픽으로 분할합니다. 상황에 맞는 메뉴에서 찾을 수 있습니다.모든 앱 다시 로드전체 환경을 다시 로드하는 편리한 버튼이 있습니다. 이 버튼은 개발을 수행하고 일부 코드를 변경할 때 유용합니다. Maya나 Nuke를 다시 시작할 필요 없이 다시 로드 버튼만 누르면 됩니다.다시 로드 기능 외에도 이 앱은 현재 작업 영역과 현재 로드된 모든 앱의 분할 정보를 표시합니다.다음과 같이 세 개의 별도 뷰가 있습니다.현재 작업 영역현재 샷 또는 에셋, 현재 태스크 등을 보여 줍니다. 목록의 항목 중 하나를 두 번 클릭하면 해당 항목에 대한 Flow Production Tracking 상세 정보 페이지가 열립니다.실행 중인 앱현재 실행 중인 모든 앱에 대한 뷰로, 해당 버전 및 설명이 함께 표시됩니다. 앱을 두 번 클릭하면 해당 앱에 대한 문서 페이지가 열립니다.현재 환경현재 로드된 환경 파일 및 엔진 뷰입니다. 이 뷰는 디버깅 목적에 유용할 수 있습니다.",
    "url": "/c542e4dd/",
    "relUrl": "/c542e4dd/"
  },
  "161": {
    "id": "161",
    "title": "Breakdown",
    "content": "BreakdownScene Breakdown 앱은 참조된 컨텐츠 목록을 표시하여 어떤 항목이 오래되었는지 알려 줍니다. Flow Production Tracking 메뉴에서 액세스합니다.하나 이상의 항목을 선택하고 선택 항목 업데이트(Update Selected)를 누릅니다. 이렇게 하면 최신 버전의 컨텐츠를 사용하도록 항목이 전환됩니다.씬 스캔Breakdown 앱이 참조용 씬을 스캔할 때 특수 스캔 후크를 호출합니다. 스캔 후크는 파일 해당 경로가 포함된 노드 목록을 반환합니다. 찾은 각각의 참조에 대해 파일 경로를 반환하고 탱크는 파일 경로를 보고 파일 경로를 게시로 인식하는지 먼저 확인한 후 게시로 인식할 경우 사용 가능한 최신 버전이 있는지 확인합니다.사용자가 오래된 버전에 대해 업데이트(Update) 버튼을 클릭하면 앱이 다른 후크를 호출하여 실제 업데이트 작업을 수행합니다. 즉, 이러한 후크를 커스터마이즈하면 새 커스텀 노드를 분할에 추가하는 것이 비교적 간단해집니다.Flow Production Tracking 데이터에 액세스후크에서 업데이트 예정인 게시의 Flow Production Tracking 데이터에 액세스해야 하는 경우 간단하게 처리됩니다. 다음과 같이 find_publish 단일 호출로 앱에서 전달되는 모든 항목의 메타데이터를 검색합니다.class BreakdownHook(Hook):    def update(self, items):        &quot;&quot;&quot;        Perform replacements given a number of scene items passed from the app.        Once a selection has been performed in the main UI and the user clicks        the update button, this method is called.        The items parameter is a list of dictionaries on the same form as was        generated by the scan_scene hook above. The path key now holds        the that each node should be updated *to* rather than the current path.        &quot;&quot;&quot;        engine = self.parent.engine        # resolve Flow Production Tracking data for all paths passed via the items dictionary        sg_data = tank.util.find_publish(engine.sgtk,                                         [i[&quot;path&quot;] for i in items],                                         fields=[&quot;id&quot;, &quot;code&quot;, &quot;version_number&quot;])        for i in items:            node_name = i[&quot;node&quot;]            node_type = i[&quot;type&quot;]            new_path = i[&quot;path&quot;]            # now that each item is processed, it is easy to access the            # Flow Production Tracking data via a dictionary lookup:            sg_data = sg_data.get(i[&quot;path&quot;])            # once we have all our desired info and metadata, we can go ahead            # and apply the update business logic.            # [-business logic here-]API 액세스해당 API를 사용하여 프로그래밍 방식으로 Breakdown 앱에 액세스할 수 있습니다. 다음 방식을 사용할 수 있습니다.Breakdown UI 표시app_object.show_breakdown_dialog()Breakdown UI를 표시하려면 show_breakdown_dialog() 방식을 실행합니다. 앱이 현재 실행 중인 환경의 tk-multi-breakdown 섹션에 포함되어 있을 경우 다음과 같이 수행할 수 있습니다.&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; e = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; e.apps[&quot;tk-multi-breakdown&quot;].show_breakdown_dialog()씬 분석 실행items = app_object.analyze_scene()analyze_scene() 방식을 실행하여 프로그래밍 방식으로 씬 분석 로직을 실행할 수 있습니다. 이 방식은 Breakdown UI가 씬 항목의 목록을 빌드할 때 사용하는 것과 정확히 동일한 로직을 실행합니다.방식은 분할 항목의 목록을 반환합니다. 각 항목은 항목을 설명하는 여러 개의 키가 있는 사전으로 표시됩니다. 툴킷 템플릿 파일의 템플릿에 해당하는 경로의 파일만 탐지됩니다. 파일이 게시로 Flow Production Tracking에 있어야 할 필요는 없지만 만약 있다면 이 방식은 기본 Flow Production Tracking 게시 메타데이터를 반환합니다.두 개의 키 node_name 및 node_type은 DCC 중심의 “주소”를 반환하거나 DCC 내의 경로를 식별할 수 있도록 하는 표현을 반환하는 데 사용됩니다. 예를 들어 Maya 및 Nuke에서는 노드 이름과 유형을 반환합니다. 이 로직은 후크에서 구현되며 DCC 간에 달라집니다. 이 방식은 Flow Production Tracking에 연결을 시도하지만 호출 횟수가 일정하고 씬 복잡성과 무관합니다.다음은 반환 데이터의 사전에 대한 일반적인 예입니다.{'fields': {'Sequence': 'aaa',            'Shot': 'aaa_00010',            'Step': 'Comp',            'eye': '%V',            'height': 1556,            'name': 'test',            'output': 'output',            'version': 1,            'width': 2048}, 'template': &amp;lt;Sgtk TemplatePath nuke_shot_render_pub_mono_dpx&amp;gt;, 'node_name': 'Read2', 'node_type': 'Read', 'sg_data': {'code': 'aaa_00010_test_output_v001.%04d.dpx',             'entity': {'id': 1660, 'name': 'aaa_00010', 'type': 'Shot'},             'id': 1424,             'name': 'test',             'published_file_type': {'id': 3,                                     'name': 'Rendered Image',                                     'type': 'PublishedFileType'},             'task': {'id': 4714, 'name': 'Comp', 'type': 'Task'},             'type': 'PublishedFile',             'project': {'id': 234, 'name': 'Climp', 'type': 'Project'},             'version_number': 1}, }편리한 팁: 위에서 볼 수 있듯이 각 항목은 template 객체와 fields 사전을 반환하여 경로를 나타냅니다. 항목의 실제 로우 경로를 보려면 간단히 template_obj.apply_fields(fields_dict)를 실행하면 됩니다. 이 방식에서 반환된 항목 사전 중 하나의 컨텍스트에서 코드는 다음과 같습니다.breakdown_items = analyze_scene()for item in breakdown_items:   path = item[&quot;template&quot;].apply_fields(item[&quot;fields&quot;])항목의 가장 높은 버전 계산highest_version = app_object.compute_highest_version(template, fields)항목의 가장 높은 버전을 찾으려면 compute_highest_version(template, fields) 방식을 사용합니다. 분석해야 할 경로를 나타내는 template 및 fields 매개변수는 analyze_scene() 방식의 출력에서 찾을 수 있습니다. Breakdown 앱에서는 버전 번호가 포함된 템플릿 키의 이름을 항상 {version}으로 지정해야 합니다.이렇게 하면 디스크에서 스캔을 수행하여 가장 높은 버전을 확인합니다. 방식은 디스크에서 발견된 가장 높은 버전 번호를 반환합니다. 자세한 정보는 아래의 사용 예를 참조하십시오.씬 항목 업데이트app_object.update_item(node_type, node_name, template, fields)항목을 업데이트하려면 update_item(node_type, node_name, template, fields) 방식을 사용하면 됩니다. template 및 fields 매개변수는 업데이트해야 할 경로를 나타냅니다. node_name 및 node_type 매개변수는 수정해야 할 씬의 노드를 식별하는 데 사용됩니다. 일반적으로 이러한 값은 analyze_scene() 방식의 출력에서 찾을 수 있습니다.이 방식은 Breakdown UI에서 업데이트를 실행하는 것과 비슷합니다. 실제 업데이트 호출은 DCC 특정 로직을 처리하는 후크에 디스패치됩니다. 자세한 정보는 아래의 사용 예를 참조하십시오.Breakdown API 예다음은 씬 분할을 검색하여 최신 버전을 사용하지 않는 모든 항목을 업데이트하는 방법을 보여 주는 예입니다.# find the breakdown app instanceimport sgtkengine = sgtk.platform.current_engine()breakdown_app = engine.apps[&quot;tk-multi-breakdown&quot;]# get list of breakdown itemsitems = breakdown_app.analyze_scene()# now loop over all itemsfor item in items:    # get the latest version on disk    latest_version = breakdown_app.compute_highest_version(item[&quot;template&quot;], item[&quot;fields&quot;])    # if our current version is out of date, update it!    current_version = item[&quot;fields&quot;][&quot;version&quot;]    if latest_version &amp;gt; current_version:        # make a fields dictionary representing the latest version        latest_fields = copy.copy(item[&quot;fields&quot;])        latest_fields[&quot;version&quot;] = latest_version        # request that the breakdown updates to the latest version        breakdown_app.update_item(item[&quot;node_type&quot;], item[&quot;node_name&quot;], item[&quot;template&quot;], latest_fields)",
    "url": "/3c0c0ab6/",
    "relUrl": "/3c0c0ab6/"
  },
  "162": {
    "id": "162",
    "title": "Demo",
    "content": "DemoDemo 앱은 Flow Production Tracking 유틸리티 프레임워크, Qt Widgets 프레임워크, Toolkit Core 등 Flow Production Tracking의 기본 개발자 플랫폼 구성 요소의 라이브 시연 모습을 제공합니다.앱에 표시되는 각 데모에는 하나 이상의 기본 플랫폼 구성요소를 사용하는 방법을 보여 주는 실제 인터랙티브 UI가 포함됩니다. 또한 구동 중인 코드를 사용자의 앱에 쉽게 복사해 붙여넣을 수 있습니다.앱은 사용이 간단합니다. 왼쪽 목록에서 데모를 선택한 다음 오른쪽에서 구성요소와 상호 작용하면 됩니다. Qt Widgets 프레임워크에서 위젯 하나를 표시해 주는 정도로 간단한 데모도 있고, Flow Production Tracking 플랫폼 구성요소들이 프로덕션 앱에서 사용할 수 있도록 함께 연결되는 방식을 예로 보여 주는 데모도 있습니다.새 구성요소가 플랫폼에 추가되고, 시간이 허락한다면 새 데모도 추가할 예정입니다. 보고 싶은 공통된 구성요소 사용 패턴이나 데모가 있다면 티켓을 제출하여 알려 주십시오.설치Demo 앱을 설치하려면 다음 명령을 실행하십시오.tank install_app project tk-shell tk-multi-demo설치하고 나면 다음 명령을 실행하여 앱을 구동할 수 있습니다../tank demos",
    "url": "/42395ae7/",
    "relUrl": "/42395ae7/"
  },
  "163": {
    "id": "163",
    "title": "시작 앱",
    "content": "시작 앱이 앱은 Flow Production Tracking에서 지원되는 응용프로그램으로 쉽게 이동할 수 있는 단축키를 제공합니다. 구성 선택 사항에 따라 Flow Production Tracking의 다양한 엔티티에 대해 호출되는 Flow Production Tracking 액션 항목을 등록합니다.작동 방식구성 옵션에 따라 엔티티를 마우스 오른쪽 버튼으로 클릭하거나 Flow Production Tracking Actions 메뉴 또는 톱니바퀴 메뉴를 사용하면 메뉴 항목이 Flow Production Tracking에 표시됩니다.예를 들어 이 스크린샷은 Maya, Nuke 및 Photoshop용 메뉴를 구현하기 위해 이 앱을 세 번 사용하는 구성 사이트에서 가져온 것입니다.현재 지원되는 응용프로그램 및 엔진은 다음과 같습니다.  3DSMax  Hiero  Maya  MotionBuilder  Nuke  Photoshop  Mari  Houdini  Flame시작 시 명령행 인수 사용많은 응용프로그램에는 응용프로그램의 다른 버전(예: Nuke와 NukeX)을 선택하거나 기타 다양한 사용 측면을 지정하기 위해 호출할 수 있는 명령행 옵션이 있습니다. 시작 관리자 앱에는 이 목적으로 구성할 수 있는 각 OS에 대한 ‘args’ 설정이 있습니다. 예를 들어 여기에 ‘–nukex’를 넣으면 명령줄 실행에 추가되어 일반 Nuke 대신 NukeX가 실행됩니다.NukeX 시작 예launch_nuke:  engine: tk-nuke  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: '--nukex'  linux_path: '@nuke_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.15}  mac_args: '--nukex'  mac_path: '@nuke_mac'  menu_name: Launch Nuke  windows_args: '--nukex'  windows_path: '@nuke_windows'시작 시 환경 변수 설정 및 동작 자동화응용프로그램이 스튜디오 파이프라인에서 제대로 작동하려면 특정 환경 변수, 플러그인 경로 등을 설정해야 하는 경우가 많습니다. 시작 앱은 ‘before_app_launch’ 후크를 통해 이 경우를 해결할 수 있습니다. 이 후크를 사용하면 응용프로그램을 시작할 때마다 실행할 코드 조각을 정의할 수 있습니다. 기본적으로 ‘before_app_launch’ 후크는 아무런 동작도 수행하지 않는 단순한 통과지만 이 문서의 지침에 따라 재정의할 수 있습니다.예를 들어 Zync 렌더를 사용하는 경우 Zync Maya 플러그인 디렉토리는 $PYTHONPATH 및 $XBMLANGPATH의 일부여야 합니다. 시작 앱이 이러한 환경 변수를 설정하게 하려면 before_app_launch 후크를 다음과 같이 몇 줄의 코드로 업데이트합니다.환경 변수 설정 예def execute(self, **kwargs):    &quot;&quot;&quot;    The execute functon of the hook will be called to start the required application            &quot;&quot;&quot;    # Example to show how to set env vars on Maya launch    # Append the desired path to the existing $PYTHONPATH to ensure    # everything upstream still works    os.environ[&quot;PYTHONPATH&quot;] = os.environ[&quot;PYTHONPATH&quot;] + os.pathsep + &quot;~/Library/zync/zync-maya&quot;    # Set $XBMLANGPATH to the desired path, may need to append it as    # with $PYTHONPATH if already defined in your pipeline    os.environ[&quot;XBMLANGPATH&quot;] = &quot;~/Library/zync/zync-maya&quot;‘before_app_launch’를 사용하여 Flow Production Tracking 업데이트를 비롯한 다른 동작을 자동화할 수도 있습니다. 예를 들어 다음과 같이 시작 앱이 실행될 때마다 태스크 상태를 업데이트하도록(이 경우 “진행 중”으로) 구성할 수 있습니다(태스크에서 시작하는 경우).태스크 상태 업데이트 자동화 예def execute(self, **kwargs):    &quot;&quot;&quot;    The execute functon of the hook will be called to start the required application            &quot;&quot;&quot;    # If there is a Task in the context, set its status to 'ip'    if self.parent.context.task:        task_id = self.parent.context.task['id']        data = {            'sg_status_list':'ip'        }        self.parent.shotgun.update(&quot;Task&quot;, task_id, data)상상할 수 있듯이 여기에는 많은 가능성이 있으며, 시작 앱은 파이프라인에 필요한 유연성을 제공하는 것을 목표로 합니다.아직 엔진이 없는 응용프로그램 시작또한 시작 앱을 사용하여 아직 툴킷 엔진이 없는 응용프로그램을 시작할 수 있습니다. 이 경우 시작 중인 샷, 태스크 또는 에셋에 대한 폴더가 디스크에 만들어지고 응용프로그램이 시작되지만 응용프로그램 시작 후 코드가 실행되지 않으며 응용프로그램 내에 Flow Production Tracking 메뉴가 나타나지 않습니다. 즉, 아직 툴킷에서 지원하지 않는 응용프로그램을 Flow Production Tracking 내에서 시작할 수 있습니다.이렇게 하려면 시작할 응용프로그램에 대한 경로를 사용하여 앱을 구성하고 엔진 옵션은 빈 문자열로 남겨 둡니다.기술적 상세 정보3DSMax이 앱은 3DSMax가 부트 프로세스의 일부로 실행될 3DSMax 명령행에 자동으로 MaxScript, init_tank.ms를 추가합니다.3DSMax 부팅 과정은 다음과 같습니다.  3DSMax 시작 시 init_tank.ms를 실행합니다.  init_tank.ms는 Python 인터프리터를 사용하고 tank_startup.py를 실행할 수 있도록 합니다.  Flow Production Tracking 툴킷 컨텍스트 API를 사용하면 Flow Production Tracking에서 전달된 엔티티 ID가 툴킷 컨텍스트로 변환됩니다.  tank.system.start_engine()을 통해 적절한 엔진을 시작하고 컨텍스트에 전달합니다. 엔진이 나머지 부분을 처리합니다.Maya이 앱은 Maya가 부트 프로세스의 일부로 호출할 userSetup.py 자동 시작 스크립트를 Maya에 등록합니다.Maya 부팅 과정은 다음과 같습니다.  Maya가 userSetup.py 시작 스크립트를 실행합니다.  Flow Production Tracking 툴킷 컨텍스트 API를 사용하면 Flow Production Tracking에서 전달된 엔티티 ID가 툴킷 컨텍스트로 변환됩니다.  tank.system.start_engine()을 통해 적절한 엔진을 시작하고 컨텍스트에 전달합니다. 엔진이 나머지 부분을 처리합니다.MotionBuilder이 앱은 MotionBuilder가 부트 프로세스의 일부로 호출할 init_tank.py 자동 시작 스크립트를 MotionBuilder에 등록합니다.MotionBuilder 부팅 과정은 다음과 같습니다.  MotionBuilder가 init_tank.py 시작 스크립트를 실행합니다.  Flow Production Tracking 툴킷 컨텍스트 API를 사용하면 Flow Production Tracking에서 전달된 엔티티 ID가 툴킷 컨텍스트로 변환됩니다.  tank.system.start_engine()을 통해 적절한 엔진을 시작하고 컨텍스트에 전달합니다. 엔진이 나머지 부분을 처리합니다.Nuke이 앱은 Nuke가 부트 프로세스의 일부로 호출할 menu.py 자동 시작 스크립트를 Nuke에 등록합니다.Nuke 부팅 과정은 다음과 같습니다.  Nuke가 menu.py 시작 스크립트를 실행합니다.  Flow Production Tracking 툴킷 컨텍스트 API를 사용하면 Flow Production Tracking에서 전달된 엔티티 ID가 툴킷 컨텍스트로 변환됩니다.  tank.system.start_engine()을 통해 적절한 엔진을 시작하고 컨텍스트에 전달합니다. 엔진이 나머지 부분을 처리합니다.Photoshop이 앱은 Adobe 익스텐션 관리자를 사용하여 탱크 플러그인을 설치하거나 설치되었는지 확인합니다.Photoshop 부팅 과정은 다음과 같습니다.  Photoshop이 탱크 플러그인을 실행합니다.  Flow Production Tracking 툴킷 컨텍스트 API를 사용하면 Flow Production Tracking에서 전달된 엔티티 ID가 툴킷 컨텍스트로 변환됩니다.  tank.system.start_engine()을 통해 적절한 엔진을 시작하고 컨텍스트에 전달합니다. 엔진이 나머지 부분을 처리합니다.추가 구성이 앱을 사용하여 Photoshop을 시작하려면 추가 섹션에 4개의 구성 값을 제공해야 합니다. 다음은 조정해야 하는 시스템 및 설치 위치에 대한 구성 및 올바른 기본값입니다.mac_python_path: &quot;/usr/bin/python&quot;windows_python_path: &quot;C:  Python27  python.exe&quot;mac_extension_manager_path: &quot;/Applications/Adobe Extension Manager CS6/Adobe Extension Manager CS6.app&quot;windows_extension_manager_path: &quot;C:  Program Files (x86)  Adobe  Adobe Extension Manager CS6  XManCommand.exe&quot;",
    "url": "/1b9c259a/",
    "relUrl": "/1b9c259a/"
  },
  "164": {
    "id": "164",
    "title": "Loader",
    "content": "Loader이 문서에서는 툴킷 구성에 대한 제어 권한이 있는 경우에만 사용할 수 있는 기능에 대해 설명합니다. 자세한 내용은 Flow Production Tracking 통합 사용자 안내서를 참조하십시오.구성Loader는 상세하게 구성할 수 있으며 여러 가지 방법으로 설정할 수 있습니다. 다음 두 가지 주요 구성 영역이 있습니다.  왼쪽 트리 뷰에 표시할 탭과 컨텐츠를 설정하는 영역  다른 게시에 표시할 액션을 제어하고 실제로 수행할 액션을 제어하는 영역다음 섹션에서는 Loader를 구성할 수 있는 방법을 개괄적으로 설명합니다. 구성과 관련된 기술적 세부 사항은 이 문서에서 자세히 설명하는 별도 섹션을 참조하십시오.트리 뷰트리 뷰는 상세하게 구성할 수 있으며 표준 Flow Production Tracking 필터 구문을 사용하여 다양한 탭의 컨텐츠를 제어할 수 있습니다. 각 탭은 계층으로 그룹 지정된 단일 Flow Production Tracking API 쿼리로 구성됩니다. 임의의 필터를 추가하여 표시할 항목을 제어할 수 있으며 특수 키워드 {context.entity}, {context.project}, {context.project.id}, {context.step}, {context.task} 및 {context.user}를 사용하여 현재 컨텍스트를 기반으로 쿼리의 범위를 지정할 수 있습니다. 이러한 각 키워드는 관련 컨텍스트 정보로 대체되거나 컨텍스트의 해당 부분이 입력되지 않은 경우 또는 id, type 및 name 키가 포함된 표준 Flow Production Tracking 링크 사전인 경우에는 None으로 대체됩니다.기본적으로 Loader는 현재 프로젝트에 속한 에셋 및 샷을 표시합니다. 다시 구성하면 다른 프로젝트 또는 특정 에셋 라이브러리 프로젝트 등의 항목을 표시하는 등 쉽게 확장할 수 있습니다. 예를 들어 필터를 사용하여 특정 승인 상태의 항목만 표시하거나 상태별 또는 다른 Flow Production Tracking 필드별로 그룹 항목을 표시할 수도 있습니다. 다음은 트리 뷰 탭을 설정할 수 있는 방법을 보여 주는 몇 가지 샘플 구성 설정입니다.# An asset library tab which shows assets from a specific# Flow Production Tracking projectcaption: Asset Libraryentity_type: Assethierarchy: [sg_asset_type, code]filters:- [project, is, {type: Project, id: 123}]# Approved shots from the current projectcaption: Shotshierarchy: [project, sg_sequence, code]entity_type: Shotfilters:- [project, is, '{context.project}']- [sg_status_list, is, fin]# All assets for which the current user has tasks assignedcaption: Assetsentity_type: Taskhierarchy: [entity.Asset.sg_asset_type, entity, content]filters:- [entity, is_not, null]- [entity, type_is, Asset]- [task_assignees, is, '{context.user}']- [project, is, '{context.project}']게시 필터링ShotGrid에서 게시 데이터를 로드할 때 Loader가 수행하는 게시 쿼리에 Flow Production Tracking 필터를 적용할 수 있습니다. 이 필터는 publish_filters 매개변수를 통해 제어되며 승인되지 않은 게시 또는 연결된 리뷰 버전이 승인되지 않은 게시를 숨기는 작업 등에 사용할 수 있습니다.액션이 표시되지 않을 경우Loader는 각 엔진별로 다양한 액션이 제공됩니다. 예를 들어 Nuke의 경우 “스크립트 가져오기”와 “읽기 노드 만들기”의 두 가지 액션이 있습니다. 액션은 후크에 정의됩니다. 즉, 원하는 경우 동작을 수정하거나 액션을 추가할 수 있습니다. 그런 다음 Loader의 구성에서 이러한 액션을 특정 게시 유형에 바인딩합니다. 액션을 게시 유형에 바인딩하는 것은 기본적으로 액션이 Loader 내부의 모든 해당 유형의 항목에 대한 액션 메뉴에 표시됨을 의미합니다.예를 들어 기본적으로 Nuke의 매핑은 다음과 같이 설정됩니다.action_mappings:  Nuke Script: [script_import]  Rendered Image: [read_node]액션 메뉴가 표시되지 않을 경우 사용 중인 게시 유형에 다른 이름을 선택했기 때문일 수 있습니다. 이 경우 구성으로 이동하고 해당 유형이 Loader 내부에 표시되도록 추가합니다.액션 관리Loader가 지원하는 각 응용프로그램에는 해당 응용프로그램에 대해 지원되는 액션을 구현하는 액션 후크가 있습니다. 예를 들어 Maya를 사용하면 기본 후크는 각각 특정 Maya 명령을 수행하는 reference, import 및 texture_node 액션을 구현하여 현재 Maya 씬으로 컨텐츠를 가져옵니다. 모든 후크와 마찬가지로 재정의 및 변경이 완벽히 가능하고, 기본 제공 후크로부터 파생되는 후크를 생성하는 것 역시 가능하기 때문에 많은 코드를 복제할 필요 없이 기본 제공 후크에 다른 액션을 쉽게 추가할 수 있습니다.액션 후크에서 액션 목록을 정의한 후에는 이러한 액션을 게시 파일 유형에 바인딩할 수 있습니다. 예를 들어 이름이 “Maya Scene”인 파이프라인에 게시 파일 유형이 있는 경우 구성에서 이 유형을 후크에 정의된 reference 및 import 액션에 바인딩할 수 있습니다. 이를 통해 툴킷은 표시되는 각 Maya Scene 게시에 참조 및 가져오기 액션을 추가합니다. 이렇게 게시 유형을 실제 후크에서 분리하면 기본 구성과 함께 제공되는 설정이 아닌 다른 게시 유형 설정을 사용할 수 있도록 Loader를 쉽게 재구성할 수 있습니다.Loader는 툴킷의 2세대 후크 인터페이스를 사용하기 때문에 그 유연성이 뛰어납니다. 이 후크 형식은 향상된 구문을 사용합니다. Loader용으로 설치된 기본 구성 설정에서 다음과 같은 후크를 볼 수 있습니다.actions_hook: '{self}/tk-maya_actions.py'{self} 키워드를 통해 툴킷은 앱 hooks 폴더에서 후크를 찾을 수 있습니다. 이 후크를 사용자 구현으로 재지정하려면 값을 {config}/loader/my_hook.py로 변경합니다. 이렇게 하면 툴킷이 구성 폴더에 있는 hooks/loader/my_hook.py라는 후크를 사용하게 됩니다.Loader가 사용하고 있는 또 다른 2세대 후크 기능은 더 이상 execute() 방식을 필요로 하지 않습니다. 대신, 후크는 일반 클래스와 더 비슷하며 함께 그룹으로 지정하는 데 유용한 방식 컬렉션을 포함할 수 있습니다. Loader의 경우 액션 후크는 다음 두 가지 방식을 구현해야 합니다.def generate_actions(self, sg_publish_data, actions, ui_area)def execute_multiple_actions(self, actions)자세한 정보는 앱과 함께 제공되는 후크 파일을 참조하십시오. 후크는 또한 상속을 이용합니다. 즉, 후크의 모든 사항을 재지정할 필요는 없지만 다양한 방식으로 기본 후크를 좀 더 쉽게 확장하거나 확대하여 보다 쉽게 후크를 관리할 수 있습니다.v1.12.0 이전 버전에서는 응용프로그램이 execute_action 후크를 호출하여 액션을 실행했습니다. 최신 버전에서는 execute_multiple_actions 후크를 호출합니다. 기존 후크와의 호환성을 제공하기 위해 execute_multiple_actions 후크는 실제로 제공된 각각의 액션에 대해 execute_action을 호출합니다. 응용프로그램이 v1.12.0 이상으로 업그레이드 후 execute_multiple_actions 후크가 정의되지 않았다고 보고하는 경우 환경의 actions_hook 설정이 기본 제공 후크 {self}/{engine_name}_actions.py에서 올바르게 상속받는지 확인합니다. 기본 제공 후크에서 커스텀 후크를 파생하는 방법에 대한 자세한 내용은 툴킷 참조 문서를 참조하십시오.2세대 후크 형식에 대한 자세한 정보는 여기를 참조하십시오.후크에서 상속을 사용하면 다음과 같은 기본 후크에 액션을 추가할 수 있습니다.import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_publish_data, actions, ui_area):        &quot;&quot;&quot;        Returns a list of action instances for a particular publish.        This method is called each time a user clicks a publish somewhere in the UI.        The data returned from this hook will be used to populate the actions menu for a publish.        The mapping between Publish types and actions are kept in a different place        (in the configuration) so at the point when this hook is called, the loader app        has already established *which* actions are appropriate for this object.        The hook should return at least one action for each item passed in via the        actions parameter.        This method needs to return detailed data for those actions, in the form of a list        of dictionaries, each with name, params, caption and description keys.        Because you are operating on a particular publish, you may tailor the output        (caption, tooltip etc) to contain custom information suitable for this publish.        The ui_area parameter is a string and indicates where the publish is to be shown.        - If it will be shown in the main browsing area, &quot;main&quot; is passed.        - If it will be shown in the details area, &quot;details&quot; is passed.        - If it will be shown in the history area, &quot;history&quot; is passed.        Please note that it is perfectly possible to create more than one action &quot;instance&quot; for        an action! You can for example do scene introspection - if the action passed in        is &quot;character_attachment&quot; you may for example scan the scene, figure out all the nodes        where this object can be attached and return a list of action instances:        &quot;attach to left hand&quot;, &quot;attach to right hand&quot; etc. In this case, when more than        one object is returned for an action, use the params key to pass additional        data into the run_action hook.        :param sg_publish_data: Flow Production Tracking data dictionary with all the standard publish fields.        :param actions: List of action strings which have been defined in the app configuration.        :param ui_area: String denoting the UI Area (see above).        :returns List of dictionaries, each with keys name, params, caption and description        &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_publish_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_publish_data):        &quot;&quot;&quot;        Execute a given action. The data sent to this be method will        represent one of the actions enumerated by the generate_actions method.        :param name: Action name string representing one of the items returned by generate_actions.        :param params: Params data, as specified by generate_actions.        :param sg_publish_data: Flow Production Tracking data dictionary with all the standard publish fields.        :returns: No return value expected.        &quot;&quot;&quot;        # resolve local path to publish via central method        path = self.get_publish_path(sg_publish_data)        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_publish_data)그런 다음 이 새 액션을 구성의 게시 유형 세트에 바인딩할 수 있습니다.action_mappings:  Maya Scene: [import, reference, my_new_action]  Maya Rig: [reference, my_new_action]  Rendered Image: [texture_node]위의 그림과 같이 후크에서 파생된 커스텀 후크 코드는 유지 관리 및 업데이트가 보다 쉽도록 실제 추가된 비즈니스 로직만 포함하면 됩니다.참조다음 방식은 앱 인스턴스에서 사용할 수 있습니다.open_publish()‘파일 열기’ 스타일 버전의 Loader를 제공하여 사용자가 게시를 선택할 수 있습니다. 그러면 선택한 게시가 반환됩니다. 이 모드에서 실행할 때 앱에 구성된 일반 액션은 허용되지 않습니다.app.open_publish( str title, str action, list publish_types )매개변수 및 반환값  str title - 게시 열기 대화상자에 표시할 제목입니다.  str action - ‘열기’ 버튼에 사용할 액션 이름입니다.  list publish_types - 사용 가능한 게시 목록을 필터링하는 데 사용할 게시 유형 목록입니다. 이 값이 비어 있거나 None인 경우 모든 게시가 표시됩니다.  반환값: 사용자가 선택한 Flow Production Tracking 엔티티 사전 목록을 반환합니다.예&amp;gt;&amp;gt;&amp;gt; engine = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; loader_app = engine.apps.get[&quot;tk-multi-loader2&quot;]&amp;gt;&amp;gt;&amp;gt; selected = loader_app.open_publish(&quot;Select Geometry Cache&quot;, &quot;Select&quot;, [&quot;Alembic Cache&quot;])&amp;gt;&amp;gt;&amp;gt; print selected",
    "url": "/a4c0a4f1/",
    "relUrl": "/a4c0a4f1/"
  },
  "165": {
    "id": "165",
    "title": "Publish",
    "content": "Publish개요아티스트는 Publish 앱을 통해 아티스트 다운스트림에서 사용할 수 있도록 작업물을 게시할 수 있습니다. 아티스트의 컨텐츠 생성 소프트웨어 내에서 기존 게시 워크플로우를 지원하고 디스크상의 파일을 독립 실행형으로 게시할 수 있습니다. 컨텐츠 생성 소프트웨어에서 작업하거나 기본 Flow Production Tracking 통합을 사용하여 작업할 때 이 앱은 아티스트가 게시할 수 있는 항목을 자동으로 검색해 표시해 줍니다. 보다 정교한 프로덕션이 필요한 경우 스튜디오는 커스텀 게시 플러그인을 작성하여 아티스트 워크플로우를 진행할 수 있습니다.설명서Publisher에 대한 전체 설명서는 여기에서 찾아볼 수 있습니다!",
    "url": "/bc718491/",
    "relUrl": "/bc718491/"
  },
  "166": {
    "id": "166",
    "title": "Python 콘솔",
    "content": "Python 콘솔다음은 Python 인터프리터에 액세스할 수 있는 DCC에서 사용하는 Python 콘솔 패널로 해당 인터프리터와의 상호 작용은 제한되어 있거나 지원되지 않습니다.Panel콘솔을 설치하고 나면 DCC에 패널로 등록되고, Flow Production Tracking 메뉴에서 사용할 수 있습니다. 포함된 툴킷 패널(Maya, Nuke, Houdini)을 지원하는 앱에서는 콘솔이 고정 패널에 표시됩니다. 이전 버전의 DCC 또는 패널을 지원하지 않는 DCC와 사용하는 경우 콘솔은 일반 툴킷 대화상자로 표시됩니다.탭Python 콘솔은 각각 편집기 및 출력 창을 포함하고 있는 탭을 하나 이상 표시합니다. 오른쪽 아래에 있는 + 버튼을 클릭해서 새 탭을 생성할 수 있습니다. 탭 이름 옆에는 x 버튼이 있어 탭을 삭제할 수 있습니다. 탭 자체를 두 번 클릭하면 탭의 새 이름을 입력하라는 메시지가 표시됩니다. 탭은 드래그 앤 드롭으로 재정렬할 수 있습니다. 탭의 상태는 DCC를 닫을 때 저장되었다가 다음에 실행할 때 복원됩니다.편집기콘솔에는 Python 편집을 위한 입력 영역이 있습니다. 편집기에는 행 번호가 포함되며, 현재 커서가 가리키는 행이 강조 표시되고, 기본적인 구문 강조 표시도 지원됩니다. 콘솔은 DCC의 팔레트를 사용하여 통합된 모양과 느낌을 주려고 합니다.블록 들여쓰기 또는 내어쓰기가 지원됩니다. 하나 이상의 행을 선택하고 tab 키를 눌러 4칸 들여쓰기를 지정하거나 shift + tab을 눌러 4칸 내어쓰기를 지정합니다. 4칸 블록으로 들여쓰기를 유지하려고 시도하므로 가장 인접한 4칸 전체 블록으로 들여쓰거나 내어쓰게 됩니다.블록 주석 지정 및 주석 해제 기능도 지원됩니다. 하나 이상의 행을 선택하고 Mac에서는 cmd + /, Windows 및 Linux에서는 ctrl + /를 누릅니다. 선택한 행 중에 시작 부분에 #이 없는 행이 있는 경우 선택한 모든 행에 추가됩니다. 모든 행에 #이 있는 경우 제거됩니다.출력출력 영역에는 실행한 Python의 결과가 표시됩니다. 소스 Python 명령 에코는 기본적으로 켜져 있고, 해당 출력은 &amp;gt;&amp;gt;&amp;gt; 접두사가 추가되어 구별됩니다. 각 실행에는 타임스탬프도 표시됩니다. 에코를 끌 수 있는 토글도 있습니다. 구문 및 런타임 오류는 디버깅을 위한 전체 스택 트래킹과 함께 빨간색으로 표시됩니다.버튼출력  지우기(Clear) - 출력 브라우저의 컨텐츠를 지웁니다.  에코(Echo) - 출력 브라우저에서 실행된 명령의 에코를 토글합니다.편집기  실행(Execute) - 편집기의 컨텐츠를 실행합니다.  저장(Save) - 편집기의 현재 컨텐츠를 파일에 저장합니다.  열기(Open) - 파일을 편집기에서 엽니다.  지우기(Clear) - 편집기의 컨텐츠를 지웁니다.  행(Lines) - 현재 탭의 행 번호를 토글합니다.전역일부 Flow Production Tracking/툴킷 전역은 셸용 Flow Production Tracking 엔진에서 사용할 수 있는 항목과 유사하게 콘솔에 사전 정의되어 있습니다.  Tk API 핸들은 tk 변수를 통해 사용할 수 있습니다.  Flow Production Tracking API 핸들은 shotgun 변수를 통해 사용할 수 있습니다.  현재 컨텍스트는 context 변수에 저장됩니다.  셸 엔진은 engine 변수를 통해 액세스할 수 있습니다.외부 소스앱에는 외부 위치에서 Python 소스를 로드하기 위해 구현할 수 있는 후크가 함께 제공됩니다. 이 후크는 external_sources_hook라고 부르며, 사용하려면 get_external_source_actions라는 방식을 구현해야 합니다. 이 방식은 트리거 시 콘솔에 (컨텐츠와 함께) 새 탭을 추가하는 QActions 목록을 반환해야 합니다. 사전 정의된 사용자 목록을 위해 github에서 gist를 로드하는 구현 예시가 제공됩니다. 후크에 의해 반환되는 액션은 열기(Open) 버튼을 오래 누르면 나타나는 팝업 메뉴에 표시됩니다.핫키  선택 항목 실행은 Ctrl + Enter  새 탭 생성은 Ctrl + T  탭 탐색은 Ctrl + Shift + [ 또는 Ctrl + Shift + ]  입력/출력 글꼴 크기 조정은 Ctrl + Wheel참고: 일부 DCC에서는 핫키를 사용하지 못할 수도 있습니다.기타 참고 사항  일부 이전 버전의 DCC에서는 세션을 닫을 때 Python 콘솔을 연 채로 두면 충돌이 발생할 수도 있습니다. 이는 일부 이전 버전의 PySide에서 발생하는 버그일 수 있습니다. 최신 버전의 PySide와 번들로 제공되는 보다 최신 버전의 DCC에서는 종료 시 충돌이 나타나지 않습니다. 최신 DCC 릴리즈 버전에서 이 문제가 발생하면 자세히 조사할 수 있도록 티켓을 제출해 주십시오.",
    "url": "/770a748a/",
    "relUrl": "/770a748a/"
  },
  "167": {
    "id": "167",
    "title": "Review Submission",
    "content": "Review Submission앱 사용 방법API로 사용이 앱에는 Multi Publish 앱과 같은 다른 앱 내에서 호출되는 모드가 있습니다.이 모드는 이미지 시퀀스에서 Quicktime을 만들고 리뷰를 용이하게 하기 위해 Flow Production Tracking에 버전으로 제출합니다. 생성된 Quicktime에는 슬레이트 및 번인이 있습니다. 글꼴, 로고 위치, 영상 압축 옵션 및 번인/슬레이트 정보 등은 현재 기본 후크에서 하드코딩되어 있으므로 후크 함수를 다시 구현하여 동작을 조정하는 것이 좋습니다.슬레이트 및 번인의 현재 기본 형식은 다음과 같습니다.자체 앱 또는 후크에서 이 앱을 활용하고 싶다면 간단한 다음 방법을 참조하십시오.  현재 엔진에서 tk-multi-reviewsubmission 앱을 가져옵니다. 이 작업은 self.parent.engine.apps.get('tk-multi-reviewsubmission') 호출을 사용하여 후크 내에서 수행할 수 있습니다.  앱을 사용할 수 있는 경우 render_and_submit_version() 방식을 호출합니다.후크 코드의 내용은 다음 예와 같습니다.review_submission_app = self.parent.engine.apps.get(&quot;tk-multi-reviewsubmission&quot;)if review_submission_app:    review_submission_app.render_and_submit_version(        template,        fields,        first_frame,        last_frame,        sg_publishes,        sg_task,        comment,        thumbnail_path,        progress_cb,        color_space    )render_and_submit_version에 전달해야 하는 인수는 다음과 같습니다.  template: 게시할 파일의 위치를 정의하는 템플릿  fields: 템플릿을 입력하는 데 사용할 필드  first_frame: 처리할 이미지 시퀀스의 첫 번째 프레임  last_frame: 처리할 이미지 시퀀스의 마지막 프레임  sg_publishes: 버전을 링크할 Flow Production Tracking 게시된 파일 객체의 목록  sg_task: 버전을 링크할 Flow Production Tracking 태스크 링크 사전  comment: 버전 설명에 추가할 텍스트  thumbnail_path: 영상이 Flow Production Tracking에 업로드되지 않을 경우 버전에 사용할 썸네일 경로(구성에서 설정)  progress_cb: 진행률을 보고하기 위한 콜백. callback(percent, message) 형식이어야 합니다.  color_space: 입력 프레임이 있는 색상 공간. Nuke에서 쓰기 노드의 색상 영역 노브에 있는 열거 값 중 하나입니다.메뉴 항목으로 사용이 모드는 DCC 내부의 Flow Production Tracking 메뉴에 메뉴 항목을 추가합니다. 이 모드는 현재 뷰포트의 빠른 스냅샷을 만들고 이를 버전 초안으로 Flow Production Tracking Create에 보냅니다. 그런 다음 사용자는 주석, 텍스트 또는 비교 노트를 추가해 Flow Production Tracking Create 내에서 리뷰 제출물을 확장할 수 있습니다.이 기능을 컨텍스트에 추가하려면 다음을 수행해야 합니다.  display_name 필드가 메뉴 항목에 포함되도록 설정합니다.  DCC에서 미디어를 렌더링하는 방법을 알려주는 render_media_hook 필드를 후크로 설정합니다(tk-photoshopcc 및 tk-maya에는 기본 구현이 있음).  submitter_hook 필드를 {self}/submitter_create.py로 설정합니다.다음과 같습니다.tk-multi-reviewsubmission:  display_name: Send for review  render_media_hook: '{self}/render_media.py:{self}/{engine_name}/render_media.py'  submitter_hook: '{self}/submitter_create.py'  location:    type: app_store    name: tk-multi-reviewsubmission    version: v1.0.1",
    "url": "/4badd856/",
    "relUrl": "/4badd856/"
  },
  "168": {
    "id": "168",
    "title": "Screening Room",
    "content": "Screening Room이 앱은 현재 Maya 세션을 Screening Room과 후크하는 작은 앱입니다. Flow Production Tracking 메뉴에 Screening Room으로 이동(Jump to Screening Room)이라는 항목을 추가합니다. 이 버튼을 클릭하면 Screening Room이 시작되고 현재 Flow Production Tracking 툴킷 컨텍스트(예: 샷, 에셋 또는 태스크)에서 이를 가리킵니다. 그러면 Screening Room을 사용하여 제출된 모든 컨텐츠를 검색할 수 있습니다.",
    "url": "/f3e452a2/",
    "relUrl": "/f3e452a2/"
  },
  "169": {
    "id": "169",
    "title": "Set Frame Range",
    "content": "Set Frame Range이 앱은 현재 열려 있는 씬에서 프레임 범위를 관리하는 데 도움을 줍니다. 프레임 범위 동기화(Sync Frame Range with Flow Production Tracking) 메뉴 옵션을 클릭하면 Flow Production Tracking 메뉴에서 앱에 액세스할 수 있습니다.이 버튼을 클릭하면 Flow Production Tracking 툴킷은 현재 작업 영역(일반적으로 샷)과 관련된 Flow Production Tracking 엔티티를 보고 입력 및 출력 프레임 정보가 있는 입력 및 출력 필드를 찾습니다. 일반적으로 샷과 함께 사용되며 이 경우 앱은 Flow Production Tracking의 기본 구성에 정의된 표준 샷 입력 및 출력 필드를 사용합니다. 그러나 다른 필드에서 프레임 범위를 가져오도록 앱을 구성할 수도 있습니다.앱을 실행하면 현재 씬을 해당 입출력으로 업데이트하고 마지막으로 요약 메시지를 표시합니다.여러 Flow Production Tracking 필드 동기화 옵션Flow Production Tracking 메뉴에서 menu_name 속성을 설정하여 이 앱의 인스턴스를 여러 개 정의할 수 있습니다. 이렇게 하면 서로 다른 Flow Production Tracking 필드의 동기화를 위해 여러 가지 메뉴 액션을 정의할 수 있게 됩니다.이를 위해 각 인스턴스에 대해 다른 앱 인스턴스 이름, menu_name 및 입력/출력 프레임 필드를 설정하십시오.tk-multi-setframerange_cuts:  menu_name: Sync frame range using cut fields  sg_in_frame_field: sg_cut_in  sg_out_frame_field: sg_cut_out  location: &quot;@apps.tk-multi-setframerange.location&quot;tk-multi-setframerange_handles:  menu_name: Sync frame range using handle fields  sg_in_frame_field: sg_handle_in  sg_out_frame_field: sg_handle_out  location: &quot;@apps.tk-multi-setframerange.location&quot;그러면 각 항목이 Flow Production Tracking 메뉴에 별도의 옵션으로 표시됩니다.참고: 이는 앱 v0.4.0 버전의 새로운 기능입니다.작업 후크현재 씬 프레임 범위를 가져오거나 프레임 범위를 설정하기 위한 소프트웨어별 로직은 프레임 작업 후크에서 처리됩니다. 새 엔진에 대한 지원을 추가하거나 해당 동작의 구현 방법을 변경하려는 경우 hook_frame_operation 앱 속성을 설정하고 고유의 가져오기(get) 및 설정(set) 로직을 구현하여 프레임 작업 후크를 인수할 수 있습니다.참고: 이는 앱 v0.4.0 버전의 새로운 기능입니다.",
    "url": "/8ac43263/",
    "relUrl": "/8ac43263/"
  },
  "170": {
    "id": "170",
    "title": "Flow Production Tracking Panel",
    "content": "Flow Production Tracking 패널이 문서에서는 툴킷 구성에 대한 제어 권한이 있는 경우에만 사용할 수 있는 기능에 대해 설명합니다. 자세한 정보는 Flow Production Tracking 통합 사용자 안내서를 참조하십시오.Flow Production Tracking Panel 구성Flow Production Tracking Panel에서 광범위하게 구성할 수 있는 두 가지 주요 영역은 UI의 텍스트 모양과 데이터와 연결할 액션입니다. 아래 섹션에서는 두 시스템의 구성을 제어하는 방법에 대해 간략히 설명합니다.표시 내용 구성상세 정보 영역의 값과 목록은 둘 다 Flow Production Tracking_fields 후크를 통해 구성할 수 있습니다. 이 후크를 분류하고 구현을 변경하여 원하는 정확한 값을 표시할 수 있습니다.템플릿 시스템후크는 간단한 템플릿 언어를 지원하므로 유연성이 뛰어납니다. 또한 Qt에서 지원하는 HTML 하위 세트를 지원하므로 표시되는 값의 색상, 글꼴 크기, 두께 등을 제어할 수 있습니다. 템플릿 언어는 다음과 같은 방식으로 작동합니다.      Flow Production Tracking 값은 {brackets}로 묶여 있습니다(예: &amp;lt;b&amp;gt;Description:&amp;lt;/b&amp;gt; {description}). 이 템플릿이 렌더링되면 {description} 부분은 설명 필드 값으로 대체됩니다.        값의 선택적 접두사 또는 접미사(값이 비어 있지 않은 경우에만 표시)를 원한다면 {[Prefix]sg_field[suffix]} 구문을 사용하면 됩니다. 템플릿 {[Start: ]start_date} {[End: ]end_date}는 두 값이 모두 입력될 경우 Start: 12 July 2009 End: 14 July 2012를 렌더링하지만 종료 날짜가 설정되지 않은 경우 Start: 12 July 2009를 렌더링합니다.        일부 값이 설정되지 않은 경우에는 폴백을 정의할 수 있습니다. Flow Production Tracking 버전의 경우 제작자가 아티스트 대신 버전을 제출하는 워크플로우를 지원하기 위해 artist 필드가 created_by 필드보다 우선권을 가집니다. 이 경우, 버전은 제작자에 의해 생성되지만 artist 필드는 아티스트로 설정됩니다. 그러나 항상 그렇지는 않습니다. 아티스트가 자신의 작업을 제출하는 파이프라인에 아티스트를 비워 두는 경우도 있습니다. 따라서 버전을 표시할 때에는 artist 필드를 먼저 확인하고, 이 필드가 설정되어 있지 않은 경우에는 created_by 필드로 폴백할 수 있도록 하는 것이 좋습니다. 이 작업은 {field1|field2} 구문을 사용하여 수행할 수 있습니다(예: Created By: {artist|created_by}). 이 구문을 선택적 필드(예: {[Created By: ]artist|created_by})와 결합할 수도 있습니다.  이 후크에는 다음 방식이 포함됩니다.목록에 표시되는 항목 제어get_list_item_definition() 방식은 Flow Production Tracking 엔티티 유형이 지정된 다양한 목록의 항목 모양을 제어하는 사전을 반환합니다. top_left, top_right 및 body 키가 포함된 사전을 반환합니다. 예를 들면 다음과 같습니다.{ &quot;top_left&quot;: &quot;&amp;lt;big&amp;gt;{code}&amp;lt;/big&amp;gt;&quot;, &quot;top_right&quot;: &quot;{updated_at}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}상단 상세 정보 영역 제어get_main_view_definition() 방식은 Flow Production Tracking 엔티티 유형에 따라 키 title 및 body를 사용하여 사전을 반환합니다. 이 값은 상세 정보 영역의 객체 모양을 제어합니다. 예를 들면 다음과 같습니다.{ &quot;title&quot;: &quot;{type} {code}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}정보(Info) 탭에 표시되는 필드 제어get_all_fields() 방식은 정보(Info) 탭에 렌더링될 때 해당하는 엔티티에 따라 표시할 필드의 목록을 반환합니다.액션 구성액션은 Flow Production Tracking 데이터에서 작동하는 작은 코드 조각입니다. 다음과 같은 예를 들 수 있습니다.  지정된 Flow Production Tracking 버전에 대해 RV를 시작하는 액션  사용자가 지정된 태스크에 자신을 할당할 수 있는 액션  Maya에 Flow Production Tracking 게시를 Maya 참조로 로드하는 액션액션의 실제 페이로드는 액션 후크 에 정의됩니다. 액션 로직을 정의한 후에는 앱 구성에서 해당 액션을 Flow Production Tracking 객체에 매핑할 수 있습니다. 이 액션 매핑은 다음 예와 같은 모습입니다.action_mappings:  PublishedFile:  - actions: [reference, import]    filters: {published_file_type: Maya Scene}  - actions: [texture_node]    filters: {published_file_type: Rendered Image}  Task:  - actions: [assign_task]    filters: {}  Version:  - actions: [play_in_rv]    filters: {}위의 예에서는 reference, import, texture_node, assign_task 및 play_in_rv 액션을 사용합니다. 다음으로 다양한 Flow Production Tracking 객체 및 조건에 액션을 매핑합니다. 예를 들어 모든 Maya 씬 게시 유형에 import 액션을 표시하려고 합니다.객체가 패널에 로드되면 위의 액션 구성을 확인하고 분석합니다. 현재 객체에 대한 적절한 액션 목록이 판별되고 generate_actions() 후크 방식이 실행됩니다. 이때 지정된 엔티티의 Flow Production Tracking 데이터가 후크로 전달되므로 후크 코드가 이 특정 Flow Production Tracking 객체에 대한 액션을 실행할 수 있는지 확인할 수 있습니다. 이렇게 하면 각 후크가 표시되기 전에 검사를 실행할 수 있습니다. 예를 들어 play_in_rv 후크는 로컬에서 사용할 수 있는 미디어가 있는 경우에만 관련될 수 있고 구성에서 설정된 액션 매핑은 지정된 Flow Production Tracking 엔티티에 대해 활성화할 액션을 패널에 알려 주지만 generate_actions() 방식이 지정된 객체에 적합하지 않다고 판단할 수 있으므로 모두 표시되지 않을 수 있습니다.generate_actions() 방식에서 반환되는 액션은 액션 메뉴에 표시되고 사용자가 이를 클릭하면 execute_action() 후크 방식이 호출되어 액션을 실행합니다.패널이 지원하는 각 응용프로그램에 대해 적절한 액션을 구현하는 액션 후크가 있습니다. 예를 들어 Maya 등을 사용하면 기본 후크가 reference, import 및 texture_node 액션을 구현하고 각각 특정 Maya 명령을 수행하여 현재 Maya 씬으로 게시를 가져옵니다. 모든 후크와 마찬가지로 재정의 및 변경이 완벽히 가능하고, 기본 제공 후크로부터 파생되는 후크를 생성하는 것 역시 가능하기 때문에 많은 코드를 복제할 필요 없이 기본 제공 후크에 다른 액션을 쉽게 추가할 수 있습니다.패널은 툴킷의 2세대 후크 인터페이스를 사용하기 때문에 그 유연성이 뛰어납니다. 이 후크 형식은 향상된 구문을 사용합니다. 기본 구성 설정에서 다음과 같은 형식을 볼 수 있습니다.actions_hook: '{self}/tk-maya_actions.py'{self} 키워드를 통해 툴킷은 앱의 hooks 폴더에서 후크를 찾을 수 있습니다. 이 후크를 사용자 구현으로 재지정하려면 값을 {config}/panel/maya_actions.py로 변경합니다. 이렇게 하면 툴킷이 구성 폴더에 있는 hooks/panel/maya_actions.py라는 후크를 사용하게 됩니다.자세한 정보는 앱과 함께 제공되는 후크 파일을 참조하십시오. 후크는 또한 상속을 이용합니다. 즉, 후크의 모든 사항을 재지정할 필요는 없지만 다양한 방식으로 기본 후크를 좀 더 쉽게 확장하거나 확대하여 보다 쉽게 후크를 관리할 수 있습니다.LINKBOX_DOC:5#The%20hook%20data%20type: 2세대 후크 형식에 대한 자세한 정보는 여기에서 확인하십시오.후크에서 상속을 사용하면 다음과 같은 기본 후크에 액션을 추가할 수 있습니다.import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_data, actions, ui_area):        &quot;&quot;&quot;        Returns a list of action instances for a particular object.        The data returned from this hook will be used to populate the        actions menu.        The mapping between Flow Production Tracking objects and actions are kept in a different place        (in the configuration) so at the point when this hook is called, the app        has already established *which* actions are appropriate for this object.        This method needs to return detailed data for those actions, in the form of a list        of dictionaries, each with name, params, caption and description keys.        Because you are operating on a particular object, you may tailor the output        (caption, tooltip etc) to contain custom information suitable for this publish.        The ui_area parameter is a string and indicates where the publish is to be shown.        - If it will be shown in the main browsing area, &quot;main&quot; is passed.        - If it will be shown in the details area, &quot;details&quot; is passed.        :param sg_data: Flow Production Tracking data dictionary with all the standard publish fields.        :param actions: List of action strings which have been defined in the app configuration.        :param ui_area: String denoting the UI Area (see above).        :returns List of dictionaries, each with keys name, params, caption, group and description        &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;group&quot;: &quot;Pipeline Utils&quot;,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_data):        &quot;&quot;&quot;        Execute a given action. The data sent to this be method will        represent one of the actions enumerated by the generate_actions method.        :param name: Action name string representing one of the items returned by generate_actions.        :param params: Params data, as specified by generate_actions.        :param sg_data: Flow Production Tracking data dictionary with all the standard publish fields.        :returns: No return value expected.        &quot;&quot;&quot;        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_data)그런 다음 이 새 액션을 구성의 게시 유형 세트에 바인딩할 수 있습니다.action_mappings:  PublishedFile:  - actions: [reference, import, my_new_action]    filters: {published_file_type: Maya Scene}  Version:  - actions: [play_in_rv]    filters: {}위의 그림과 같이 후크에서 파생된 커스텀 후크 코드는 유지 관리 및 업데이트가 보다 쉽도록 실제 추가된 비즈니스 로직만 포함하면 됩니다.",
    "url": "/c0b0ce05/",
    "relUrl": "/c0b0ce05/"
  },
  "171": {
    "id": "171",
    "title": "Snapshot",
    "content": "SnapshotFlow Production Tracking Snapshot은 다른 사람과 공유하지 않고 작업의 버전을 만들고 증분을 관리할 수 있는 빠른 증분 백업입니다. 스냅샷을 만들고 설명과 썸네일을 추가하여 나중에 언제든지 다시 돌아가서 복원할 수 있도록 특정 시점 이미지를 생성합니다. 씬을 많이 변경할 때와 이전 버전의 씬을 확실히 백업해 두려는 경우 유용합니다.",
    "url": "/233f8961/",
    "relUrl": "/233f8961/"
  },
  "172": {
    "id": "172",
    "title": "Workfiles",
    "content": "Workfiles파일 열기 대화상자작업 영역 탐색기본 대화상자는 두 부분으로 나뉩니다. 왼쪽에는 일련의 탭이 있습니다. 첫 번째 탭은 “내 태스크(My Tasks)”이며 현재 사용자에게 할당된 모든 태스크를 표시합니다. Flow Production Tracking 웹 사이트의 “내 태스크(My Tasks)” 페이지를 연상케 합니다.또는 엔티티 탭을 사용하여 Flow Production Tracking 엔티티를 탐색할 수도 있습니다. 기본적으로 작업 파일 응용프로그램은 해당 탭을 확인하여 샷 또는 에셋과 관련된 모든 태스크를 검색할 수 있습니다.탭 세트는 환경 파일의 entities 설정을 통해 완전히 구성할 수 있습니다.앱 설정에서 show_file_open: true/false를 설정하여 이 대화상자를 비활성화/활성화할 수 있습니다.파일 찾기오른쪽에는 왼쪽의 선택 항목과 관련된 작업 파일 및 게시가 표시됩니다. 작업 파일 및 게시는 “전체(All)”, “작업(Working)” 및 “게시(Publishes)” 탭을 사용하여 함께 또는 각각 볼 수 있습니다.이전 버전에 액세스이전 버전에 액세스하는 방법에는 두 가지가 있습니다. 먼저 브라우저 상단에 있는 “모든 버전(All versions)” 상자를 클릭하면 버전을 확장하여 브라우저에 개별적으로 모두 나열할 수 있습니다. 또 다른 옵션으로는, 파일을 마우스 오른쪽 버튼으로 클릭하여 마지막 10개 버전에 액세스할 수 있습니다.사용자 샌드박스파이프라인 구성에서 사용자 샌드박스를 사용하는 경우 기본적으로 현재 사용자의 파일만 표시됩니다. 사용자가 다른 사용자 샌드박스의 파일을 보려면 맨 위에 있는 버튼을 사용하여 파일을 표시할 샌드박스를 선택할 수 있습니다.결과 좁히기텍스트를 입력하여 모든 뷰의 결과를 좁힐 수 있습니다. 검색은 항목의 이름과 일치합니다.파일 저장 대화상자기본적으로 “파일 저장(File Save)” 대화상자를 통해 사용자는 현재 컨텍스트에 파일을 저장할 수 있습니다. 씬 이름, 버전 번호 및 선택적 파일 확장자(사용 가능한 경우)를 묻는 메시지가 표시되고 “저장(Save)” 버튼이 회색으로 표시됩니다. 응용프로그램이 씬 이름에 대한 사용 가능한 다음 버전 번호를 확인한 후에야 오른쪽 하단에 있는 저장(Save) 버튼이 활성화됩니다.앱 설정에서 show_file_save: true/false를 설정하여 이 대화상자를 비활성화/활성화할 수 있습니다.다른 컨텍스트에 저장다른 컨텍스트에 파일을 저장하려면, 대화상자의 왼쪽 상단에 있는 확장 버튼을 클릭하면 “파일 저장(File Save)” 대화상자가 확장되고 저장할 다른 컨텍스트를 선택할 수 있습니다.파일 확장자 드롭다운 추가새로운 파일 저장 대화상자를 사용하여 저장할 파일의 확장자를 선택할 수 있습니다. 이를 활성화하려면 파이프라인 구성의 templates.yml 파일을 조정해야 합니다. 먼저 토큰이 templates.yml 내의 토큰 목록에 정의되어야 합니다.maya_extension:    type: str    choices:        ma: Maya Ascii (.ma)        mb: Maya Binary (.mb)    default: ma    alias: extensionmaya_extension은 토큰의 이름입니다. choices는 드롭다운에 표시될 파일 형식 사전입니다. 키(ma 및 mb)는 이 템플릿 토큰이 가질 수 있는 가능한 값입니다. 값(Maya Ascii (.ma) 및 Maya Binary (.mb))은 툴킷 응용프로그램에서 사용할 수 있는 UI 설명입니다. alias는 작업 파일 응용프로그램에 필요한 힌트입니다. 응용프로그램에 이 토큰은 확장자이며 드롭다운 위젯에 표시되어야 함을 알려 줍니다.그런 다음 이 토큰을 Maya 특정 템플릿에 추가할 수 있습니다.maya_shot_work:    definition: '@shot_root/work/maya/{name}.v{version}.{maya_extension}'    root_name: 'primary'컨텍스트 변경 대화상자컨텍스트 변경 대화상자는 오른쪽에 파일 찾아보기 부분이 없다는 점을 제외하고 열기 대화상자와 비슷합니다. 태스크 또는 엔티티를 선택하고 컨텍스트 변경 버튼을 눌러 현재 엔진 컨텍스트를 변경할 수 있습니다.앱 설정에서 show_change_context: true/false를 설정하여 이 대화상자를 비활성화/활성화할 수 있습니다.단계 필터링태스크를 검색할 때 step이 계층에 포함되어 있는 경우 파이프라인 단계 필터링을 사용하면 선택한 단계 목록에 링크된 태스크만 검색되므로 Flow Production Tracking에서 검색되는 데이터의 양을 줄일 수 있습니다.탭에 표시되는 단계 목록은 step_filter_on 설정으로 제어됩니다. 설정하지 않을 경우 기존의 모든 파이프라인 단계가 표시됩니다.아래 예는 에셋 및 샷에 대한 태스크를 각각 표시하는 두 개의 탭을 정의합니다.  - caption: Assets Tasks    entity_type: Task    step_filter_on: Asset    filters:    - [entity, type_is, Asset]    hierarchy: [entity.Asset.sg_asset_type, entity, step, content]  - caption: Shots Tasks    entity_type: Task    step_filter_on: Shot    filters:    - [entity, type_is, Shot]    hierarchy: [entity.Shot.sg_sequence, entity, step, content]유예 쿼리성능 향상을 위해 엔티티 트리를 빌드하는 과정을 두 단계의 쿼리로 나눌 수 있습니다.  첫 번째 쿼리는 Flow Production Tracking에서 레코드를 검색하여 트리 상단을 채우는 데 사용됩니다.  두 번째 쿼리를 사용하여 사용자가 트리를 확장할 때 하위를 검색합니다.다음 설정을 사용하면 앱이 시작될 때 Flow Production Tracking에서 에셋 및 샷이 검색됩니다. 특정 에셋 또는 샷에 링크된 태스크는 트리 뷰에서 이 에셋 또는 샷을 선택하거나 확장한 경우에만 검색됩니다.  entities:  - caption: Assets    entity_type: Asset    hierarchy: [sg_asset_type, code]    filters:    sub_hierarchy:      entity_type: Task      filters:      link_field: entity      hierarchy: [step]  - caption: Shots    entity_type: Shot    filters:    hierarchy: [sg_sequence, code]    sub_hierarchy:      entity_type: Task      filters:      link_field: entity      hierarchy: [step]",
    "url": "/9a736ee3/",
    "relUrl": "/9a736ee3/"
  },
  "173": {
    "id": "173",
    "title": "Nuke Quickreview",
    "content": "Nuke QuickreviewQuickreview 앱을 사용하면 Flow Production Tracking에서 리뷰를 위해 Nuke 렌더를 간편하게 제출할 수 있습니다. 각 Quickreview를 제출할 때마다 Flow Production Tracking에 버전이 생성되어 Flow Production Tracking Node 메뉴에 있는 Nuke의 노드로 나타납니다. 새 노드를 만들고 Nuke 네트워크에 연결하여 두 번 클릭한 후 Upload 버튼을 클릭하면 됩니다.ShotGrid에서 버전이 생성되는 방법을 제어할 수 있도록 다음 UI가 제공됩니다.다음 항목을 제어할 수 있습니다.  버전 이름은 현재 로드된 Nuke 스크립트를 기반으로 미리 입력되며 필요한 경우 조정할 수 있습니다.  버전과 관련된 엔티티 링크 및 태스크는 현재 컨텍스트를 기반으로 하며 조정할 수 있습니다.  제출할 프레임 범위를 조정할 수 있습니다.  생성된 버전을 재생 목록에 추가할 수 있습니다. 최근 재생 목록이 포함된 드롭다운이 표시됩니다.업로드(Upload) 버튼을 누르면 Nuke에 Quicktime이 생성된 다음 Flow Production Tracking에 업로드됩니다. 업로드되고 나면 다음 화면이 표시되며 Nuke의 기본 제공 Flow Production Tracking Panel 또는 웹 오버레이 플레이어에 버전을 표시할 수 있습니다.번인 및 슬레이트기본적으로 앱은 슬레이트 및 번인 기능이 있는 Quicktime을 생성합니다. 커스터마이즈대부분의 리뷰 제출 특성은 후크를 사용하여 조정할 수 있습니다. 설명서는 여기에서 찾을 수 있습니다.",
    "url": "/40da6878/",
    "relUrl": "/40da6878/"
  },
  "174": {
    "id": "174",
    "title": "Nuke Write Node",
    "content": "Nuke Write NodeNuke Write Node 앱은 이미지를 렌더링할 위치를 쉽게 표준화할 수 있는 커스텀 Flow Production Tracking Write node를 제공합니다. 각 환경에 맞게 구성할 수 있습니다. 경로 외에도 구성에 따라 사용할 렌더 형식이 결정됩니다.일반적인 사용Flow Production Tracking Write Node를 사용하려면 먼저 스크립트를 툴킷 작업 파일로 저장한 다음 Nuke 메뉴를 통해 새 노드를 만듭니다. 이렇게 하면 일반적인 쓰기 노드와 비슷한 노드가 생성됩니다.직접 경로를 입력하는 대신 출력 이름을 지정하면 툴킷이 나머지 경로를 자동으로 계산합니다. UI에서 계산된 경로를 보고 파일 시스템에 표시(Show in File System) 버튼을 클릭하여 디스크의 위치를 열 수 있습니다. 렌더가 작성되는 위치는 툴킷 구성에 따라 다릅니다.렌더 버전이 지정되고 버전 번호의 경우 항상 Multi Publish를 사용하여 게시할 때 자동으로 증가되는 현재 Nuke 스크립트 버전을 따릅니다.렌더 경로 재설정Write Node는 현재 경로를 캐시하므로 파일이 툴킷 작업 영역 외부에서 열리는 경우에도 유효합니다. 경우에 따라 경로가 동기화되지 않고 ‘잠김’ 상태가 될 수 있습니다. 렌더 경로가 잠겨 있으면 이 Write Node로 만든 렌더를 게시할 수 없습니다.렌더 경로를 재설정하려면 Work-files 앱의 ‘씬 버전 올림(Version Up Scene)’ 명령을 사용하여 씬의 버전을 증가시키거나 개별적으로 쓰기 노드를 선택하고 특성에서 경로 재설정(Reset Path)을 클릭합니다.다른 Write Node 프로파일 추가Flow Production Tracking Write Node는 Nuke의 기본 제공 쓰기 노드를 래핑하므로 Nuke에서 지원하는 모든 형식을 앱에서 사용할 수 있으며 구성을 통해 노드를 더 추가할 수 있습니다. 가장 간단한 시작 방법은 원하는 매개변수로 간단한 Nuke Write node를 설정하는 것입니다. 예를 들어 LZW 압축을 사용하는 16비트 tif를 작성한다고 가정해 보겠습니다. 텍스트 편집기에서 Nuke 스크립트를 보면 쓰기 노드는 다음과 같습니다.Write {    file /Users/ryanmayeda/Desktop/test.%04d.tif    file_type tiff    datatype &quot;16 bit&quot;    compression LZW    checkHashOnRead false    name Write1    xpos -145    ypos -61}이 텍스트는 필요한 매개변수 이름과 값이 무엇인지 알려 줍니다. 이 경우에는 datatype과 compression입니다. 다음으로 환경 구성(예: /path/to/pipeline/config/env/shot_step.yml)으로 이동하여 tk-nuke-writenode 앱이 구성된 영역을 찾습니다. settings에서 다음 두 개의 매개변수를 사용하여 다른 Write Node를 추가합니다.tk-nuke-writenode:  location: {name: tk-nuke-writenode, type: app_store, version: v0.1.6}  template_script_work: nuke_shot_work  ...  write_nodes:  - file_type: exr    ...  - file_type: dpx    ...  - file_type: tiff    name: Mono Tif    publish_template: nuke_shot_render_pub_mono_tif    render_template: nuke_shot_render_mono_tif    proxy_publish_template: null    proxy_render_template: null    settings: {datatype: 16 bit, compression: LZW}    tank_type: Rendered Image    tile_color: []    promote_write_knobs: []업데이트된 구성으로 인해 다음과 같이 Nuke에 추가 Flow Production Tracking Write Node가 나타납니다.참고: 프로젝트 구성에서 찾을 수 있는 templates.yml 파일(&amp;lt;configuration root&amp;gt;/config/core/templates.yml)에 새 템플릿(예: nuke_shot_render_mono_tif)을 추가해야 합니다.0.5 압축 및 4:2:2 하위 샘플링을 사용하여 JPEG로 출력하는 Flow Production Tracking Write Node를 추가하는 방법을 보여 주는 또 다른 예가 아래에 나와 있습니다. 이 프로파일은 또한 “promote_write_knobs” 옵션을 사용하여 jpeg 품질 노브를 기즈모의 사용자 인터페이스로 승격합니다. 이렇게 하면 프로파일이 품질의 기본값을 설정할 수 있지만 사용자에게 직접 설정을 변경할 수 있는 슬라이더도 제공합니다.tk-nuke-writenode:  write_nodes:    - file_type: jpeg      name: Compressed JPEG      publish_template: nuke_shot_render_pub_jpeg      render_template: nuke_shot_render_jpeg      proxy_publish_template: null      proxy_render_template: null      settings: {_jpeg_quality: 0.5, _jpeg_sub_sampling: &quot;4:2:2&quot;}      tank_type: Rendered Image      tile_color: []      promote_write_knobs: [_jpeg_quality]쓰기 노브 승격위의 프로파일 예에서 볼 수 있듯이 캡슐화된 쓰기 노드의 노브는 Flow Production Tracking Write Node의 특성 패널에 표시되도록 승격될 수 있습니다. 승격된 쓰기 노브는 프로파일의 일부로 정의되며 노브 이름으로 식별됩니다. 여러 개의 노브를 승격할 수 있습니다.렌더 팜 통합스튜디오에서는 Deadline과 같이 작업 관리 도구를 실행하는 렌더 팜을 사용하는 것이 일반적이며, 렌더링할 때 일반적으로 Nuke를 직접 시작합니다. 이러한 도구는 Flow Production Tracking 인식 방식(예: 데스크톱 또는 tank 명령을 통해)으로 Nuke를 시작하지 않기 때문에 Flow Production Tracking Write node에는 실행에 필요한 정보가 없습니다. 이 제한을 해결하기 위한 몇 가지 옵션을 제공합니다.Flow Production Tracking Write node를 표준 Nuke Write node로 변환간단한 솔루션은 렌더링할 스크립트를 보내기 전에 Flow Production Tracking Write node를 일반 Nuke Write node로 변환하는 것입니다. 두 가지 옵션이 있습니다. 1. 변환 메뉴 옵션을 활성화하고 사용할 수 있습니다. 2. 앱에서 API 변환 방식을 사용할 수 있습니다.변환 메뉴 옵션 활성화환경 yml 파일에는 앱 설정에 추가할 수 있는 show_convert_actions라는 구성 옵션이 있습니다. show_convert_actions: True 설정을 추가할 경우 SG Write Node를 Write Node로 변환..(Convert SG Write Nodes to Write Nodes…) 및 Write Node를 다시 SG 형식으로 변환…(Convert Write Nodes back to SG format…) 메뉴 옵션을 사용할 수 있습니다.그러나 쓰기 노브를 승격하는 것으로 정의된 Flow Production Tracking Write node 프로파일이 있는 경우에는 show_convert_actions가 True로 설정된 경우에도 이러한 메뉴 옵션이 숨겨집니다. 이는 현재 다시 변환 기능이 승격된 노브를 지원하지 않기 때문입니다.API를 사용하여 변환tk-nuke-writenode 앱에서 convert_to_write_nodes() 방식을 사용하여 이 변환을 수행할 수 있습니다.스크립트의 모든 Flow Production Tracking Write node를 일반 Nuke Write node로 변환하려면 Nuke 내부에서 다음 코드를 실행합니다.import sgtkeng = sgtk.platform.current_engine()app = eng.apps[&quot;tk-nuke-writenode&quot;]if app:    app.convert_to_write_nodes() 이렇게 하면 씬에서 Flow Production Tracking Write node가 제거되므로 렌더링할 스크립트의 복사본을 만들어 복사본에 대한 변환을 수행하고 복사본을 팜에 제출하는 것이 좋습니다. 씬에는 더 이상 툴킷 참조가 없으므로 렌더 팜에서 Nuke 스크립트가 열린 경우 툴킷이 필요하지 않습니다.참고: 해당 convert_from_write_nodes() 방식을 사용할 수 있지만 데이터 무결성을 보장하기 위해 파이프라인의 일부가 아닌 디버깅용으로만 사용하는 것이 좋습니다.init.py를 사용하여 Flow Production Tracking Toolkit 엔진 부트스트랩(Bootstrap)Nuke는 플러그인 경로에 있는 init.py 스크립트를 실행합니다. 이 옵션은 init.py에 코드를 추가하는 것으로 구성되어 tk-nuke 엔진의 최소 부트스트랩(Bootstrap)을 수행하므로 Flow Production Tracking Write node가 렌더 팜에서 예상대로 작동합니다.이 워크플로우에는 몇 가지 단계가 있습니다. 첫째, Flow Production Tracking 인식 Nuke 세션에서 실행되는 “사전” 제출 스크립트는 팜 작업 환경을 설정하는 데 사용되는 데이터를 가져옵니다. 다음으로 렌더 팜에서 Flow Production Tracking 세션을 인증하는 데 사용되는 추가 환경 변수는 렌더 팜 관리자가 설정합니다. 마지막으로, Flow Production Tracking 부트스트랩(Bootstrap) 코드가 있는 init.py는 렌더 팜의 Nuke 세션이 탐지하고 실행하는 위치에 배치되어 세션 내에서 tk-nuke 엔진을 부트스트랩하고 Flow Production Tracking Write node가 제대로 작동하도록 할 수 있습니다.1. 사전 제출 스크립트이 접근법은 아티스트가 Nuke의 Flow Production Tracking 인식 세션에서 팜 작업을 제출한다고 가정합니다. 제출 시간에 다음 코드를 실행해야 합니다. 현재 Nuke 세션에서 툴킷 컨텍스트, 파이프라인 구성 URI, Toolkit Core API 위치 등과 같은 환경 정보를 가져와 렌더 작업에 전달될 사전에 입력되며 환경 변수를 설정하는 데 사용됩니다.# Populating environment variables from running Nuke:# https://developer.shotgridsoftware.com/tk-core/platform.html#sgtk.platform.create_engine_launchercurrent_engine = sgtk.platform.current_engine()launcher = sgtk.platform.create_engine_launcher(     current_engine.sgtk,     current_engine.context,     current_engine.name)# Get a dictionary with the following keys:# SHOTGUN_SITE: The Flow Production Tracking site url# SHOTGUN_ENTITY_TYPE: The Flow Production Tracking Entity type, e.g. Shot# SHOTGUN_ENTITY_ID: The Flow Production Tracking Entity id, e.g. 1234environment = launcher.get_standard_plugin_environment()# Get the current pipeline config descriptorenvironment[&quot;SHOTGUN_CONFIG_URI&quot;] = os.path.join(current_engine.sgtk.configuration_descriptor.get_uri(),&quot;config&quot;)# Get the current tk-core installation pathenvironment[&quot;SHOTGUN_SGTK_MODULE_PATH&quot;] = sgtk.get_sgtk_module_path()이 정보를 수집하면 렌더 제출 도구로 전달할 수 있습니다. 이 프로세스는 사용 중인 렌더 팜 관리 시스템에 따라 다릅니다. 렌더 제출 스크립트를 작성하는 방법에 대한 자세한 정보는 팜 관리 시스템 문서를 참조하십시오.2. Flow Production Tracking 인증초기화하려면 부트스트랩(Bootstrap) API의 툴킷 관리자에게 스크립트 사용자가 필요합니다. 이 예에서는 사이트 이름, 스크립트 사용자 및 스크립트 키가 팜 컴퓨터에 환경 변수로 존재한다고 가정합니다. 일반적으로 렌더 팜 관리자가 관리합니다. 다음은 코드에서 예상하는 환경 변수 이름과 샘플 값입니다.SHOTGUN_SITE = “https://mysitename.shotgunstudio.com”SHOTGUN_FARM_SCRIPT_USER = “sg_api_user”SHOTGUN_FARM_SCRIPT_KEY = “xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx”인증에 대한 자세한 정보는 개발자 문서를 참조하십시오.스크립트 사용자 보안에 대한 참고 사항: 관리자(Admin) 레벨의 권한을 갖지 않도록 팜에서 사용하는 스크립트 사용자를 잠그는 것이 좋습니다. API 사용자 권한에 대한 자세한 정보는 여기를 참조하십시오.3. init.py 스크립트이 시점에서 툴킷 환경 데이터는 렌더 제출 도구에서 전달되고 인증 데이터는 렌더 팜 컴퓨터에서 환경 변수에 있습니다. 렌더 작업 내에서 툴킷을 부트스트랩(Bootstrapping)하는 마지막 단계는 Nuke의 플러그인 경로에 다음 예제 init.py 코드를 배치하여 Nuke가 시작될 때 이를 시작하도록 하는 것입니다. (자세한 내용은 시작 스크립트에 대한 Foundry의 문서를 참조하십시오.)# This script shows how a Toolkit as a plugin approach could be used to bootstrap# Toolkit in Nuke on the render farm.# https://developer.shotgridsoftware.com/tk-core/bootstrap.html#bootstrapping-toolkitimport sysimport os# If your render nodes can access the same tk-core install location as# artist workstations, retrieve its path from the environment and ensure# it is in the PYTHONPATHTK_CORE_PATH = os.environ[&quot;SHOTGUN_SGTK_MODULE_PATH&quot;]if TK_CORE_PATH not in sys.path:    sys.path.append(TK_CORE_PATH)# If your render nodes don’t have access to the Toolkit Core API in the same filesystem location as artist workstations, you have to make sure that it is available in the PYTHONPATH, so that render nodes can import it. An easy way # to install tk-core in a centralized location is with pip. You can read more # about it here:# https://developer.shotgridsoftware.com/tk-core/bootstrap.html#installing-the-sgtk-module-using-pipimport sgtk# Authenticate using a pre-defined script user.sa = sgtk.authentication.ShotgunAuthenticator()# Here we retrieve credentials from environment variables, assuming a script user# will be used when rendering. This should be typically be handled by your render# farm administrators.SG_SITE_URL = os.environ[&quot;SHOTGUN_SITE&quot;]SG_SCRIPT_USER = os.environ[&quot;SHOTGUN_FARM_SCRIPT_USER&quot;]SG_SCRIPT_KEY = os.environ[&quot;SHOTGUN_FARM_SCRIPT_KEY&quot;]user = sa.create_script_user(    api_script=SG_SCRIPT_USER,    api_key=SG_SCRIPT_KEY,    host=SG_SITE_URL)# Start up a Toolkit Manager with our script usermgr = sgtk.bootstrap.ToolkitManager(sg_user=user)# Set the base pipeline configuration from the environment variable:mgr.base_configuration = os.environ[&quot;SHOTGUN_CONFIG_URI&quot;]# Disable Flow Production Tracking lookup to ensure that we are getting the Pipeline # Configuration defined in SHOTGUN_CONFIG_URI, and not a dev or override# Pipeline Configuration defined in Flow Production Tracking.mgr.do_shotgun_config_lookup = False# Set a plugin id to indicate to the bootstrap that we are starting# up a standard Nuke integrationmgr.plugin_id = &quot;basic.nuke&quot;# Retrieve the Toolkit context from environment variables:# SHOTGUN_SITE: The Flow Production Tracking site url# SHOTGUN_ENTITY_TYPE: The Flow Production Tracking Entity type, e.g. Shot# SHOTGUN_ENTITY_ID: The Flow Production Tracking Entity id, e.g. 1234sg_entity = mgr.get_entity_from_environment()# Now start up the Nuke engine for a given Flow Production Tracking Entitynuke_engine = mgr.bootstrap_engine(&quot;tk-nuke&quot;, entity=sg_entity)구성이 이 예제보다 복잡하거나 Nuke(.nk) 스크립트 대신 -t 플래그를 사용하여 명령행에 Python 스크립트를 전달하는 경우 이를 확장해야 할 수도 있습니다.Deadline 관련 단계Deadline은 렌더링 시 Nuke 스크립트를 임시 위치에 복사할 수 있습니다. 이렇게 하면 파일이 더 이상 인식할 수 있는 디스크 위치에 있지 않으므로 툴킷에 문제가 발생합니다. 이 동작을 비활성화하고 원본 위치에서 스크립트를 로드하려면 다음을 수행합니다.  Deadline에서 도구(Tools) &amp;gt; 플러그인 구성(Configure Plugin)으로 이동합니다(수퍼 유저 모드에서).  ‘경로 매핑 활성화(Enable Path Mapping)’ 옵션을 비활성화합니다.기술적 상세 정보다음은 앱에서 사용할 수 있는 API 방식입니다.get_write_nodes()현재 씬의 모든 Flow Production Tracking Write node 목록을 반환합니다.list app.get_write_nodes()매개변수 및 반환값  반환값: list - 씬에서 발견되는 툴킷 쓰기 노드 목록입니다.예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()get_node_name()지정된 쓰기 노드의 이름을 반환합니다.string get_node_name(node 노드)매개변수 및 반환값  node 노드 - 쿼리할 쓰기 노드입니다.  반환값: string - 노드의 이름입니다.예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_name(nodes[0])get_node_profile_name()지정된 쓰기 노드에서 사용하는 구성 프로파일의 이름을 가져옵니다.string get_node_profile_name(node 노드)매개변수 및 반환값  node 노드 - 쿼리할 쓰기 노드입니다.  반환값: string - 구성에 정의된 대로 이 쓰기 노드에 대한 프로파일 이름입니다.예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_profile_name(nodes[0])get_node_render_path()지정된 쓰기 노드가 이미지를 렌더링할 경로를 가져옵니다.string get_node_render_path(node 노드)매개변수 및 반환값  node 노드 - 쿼리할 쓰기 노드입니다.  반환값: string - 이 노드의 렌더 경로입니다.예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_path(nodes[0]) get_node_render_files()지정된 쓰기 노드에 대해 렌더링된 모든 이미지 파일 목록을 가져옵니다.list get_node_render_files(node 노드)매개변수 및 반환값  node 노드 - 쿼리할 쓰기 노드입니다.  반환값: list - 이 쓰기 노드에 의해 렌더링된 이미지 파일의 목록입니다.예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_files(nodes[0])get_node_render_template()구성에 정의된 대로 지정된 쓰기 노드에 대해 렌더링된 이미지를 기록할 위치를 결정하는 템플릿을 가져옵니다.template get_node_render_template(node 노드)매개변수 및 반환값  node 노드 - 쿼리할 쓰기 노드입니다.  반환값: template - 이 노드를 사용하도록 구성된 렌더 템플릿입니다.예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_template(nodes[0]) get_node_publish_template()구성에 정의된 대로 지정된 쓰기 노드에 대해 렌더링된 이미지를 게시할 위치를 결정하는 템플릿을 가져옵니다.template get_node_publish_template(node 노드)매개변수 및 반환값  node 노드 - 쿼리할 쓰기 노드입니다.  반환값: template - 이 노드를 사용하도록 구성된 게시 템플릿입니다.예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_publish_template(nodes[0]) get_node_proxy_render_path()지정된 쓰기 노드가 프록시 이미지를 렌더링할 경로를 가져옵니다.string get_node_proxy_render_path(node 노드)매개변수 및 반환값  node 노드 - 쿼리할 쓰기 노드입니다.  반환값: string - 이 노드의 프록시 렌더 경로입니다.예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_path(nodes[0]) get_node_proxy_render_files()지정된 쓰기 노드에 대해 렌더링된 모든 프록시 이미지 파일 목록을 가져옵니다.list get_node_proxy_render_files(node 노드)매개변수 및 반환값  node 노드 - 쿼리할 쓰기 노드입니다.  반환값: list - 이 쓰기 노드에 의해 렌더링된 프록시 이미지 파일의 목록입니다.예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_files(nodes[0])get_node_proxy_render_template()구성에 정의된 대로 지정된 쓰기 노드에 대해 렌더링된 프록시 이미지를 기록할 위치를 결정하는 템플릿을 가져옵니다.지정된 노드에 대해 프록시 렌더 템플릿이 구성되어 있지 않으면 대신 일반 렌더 템플릿이 반환됩니다.template get_node_proxy_render_template(node 노드)매개변수 및 반환값  node 노드 - 쿼리할 쓰기 노드입니다.  반환값: template - 이 노드를 사용하도록 구성된 프록시 렌더 템플릿입니다.예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_template(nodes[0]) get_node_proxy_publish_template()구성에 정의된 대로 지정된 쓰기 노드에 대해 렌더링된 프록시 이미지를 게시할 위치를 결정하는 템플릿을 가져옵니다.지정된 노드에 대해 프록시 게시 템플릿이 구성되어 있지 않으면 대신 일반 게시 템플릿이 반환됩니다.template get_node_proxy_publish_template(node 노드)매개변수 및 반환값  node 노드 - 쿼리할 쓰기 노드입니다.  반환값: template - 이 노드를 사용하도록 구성된 프록시 게시 템플릿입니다.예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_publish_template(nodes[0]) get_node_published_file_type()구성에 정의된 대로 지정된 쓰기 노드에 의해 렌더링된 이미지에 대해 게시된 파일을 만들 때 사용할 게시된 파일 형식을 가져옵니다.string get_node_published_file_type(node 노드)매개변수 및 반환값  node 노드 - 쿼리할 쓰기 노드입니다.  반환값: string - 이 노드를 사용하도록 구성된 게시된 파일 형식입니다.예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_published_file_type(nodes[0]) generate_node_thumbnail()지정된 쓰기 노드에 대한 썸네일을 생성합니다. 그러면 최대 크기 800x800px의 시퀀스 중간에서 임시 파일(.png)로 프레임이 렌더링됩니다. 이 파일이 더 이상 필요하지 않을 경우 호출자가 정리해야 합니다.string generate_node_thumbnail(node 노드)매개변수 및 반환값  node 노드 - 쿼리할 쓰기 노드입니다.  반환값: string - 디스크상의 렌더링된 썸네일 이미지에 대한 경로입니다.예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.generate_node_thumbnail(nodes[0]) reset_node_render_path()지정된 쓰기 노드의 렌더 경로를 현재 스크립트와 일치하도록 재설정합니다.None reset_node_render_path(node 노드)매개변수 및 반환값  node 노드 - 쿼리할 쓰기 노드입니다.  반환값: None - 값이 반환되지 않습니다.예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.reset_node_render_path(nodes[0]) is_node_render_path_locked()지정된 쓰기 노드의 렌더 경로가 잠겨 있는지 여부를 결정합니다.bool is_node_render_path_locked(node 노드)매개변수 및 반환값  node 노드 - 쿼리할 쓰기 노드입니다.  반환값: bool - 렌더 경로가 잠겨 있으면 True이고, 그렇지 않으면 False입니다.예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.is_node_render_path_locked(nodes[0]) convert_to_write_nodes()현재 스크립트에 있는 모든 Flow Production Tracking Write node를 일반 Nuke Write node로 변환합니다. 추가 툴킷 정보는 ‘tk_*‘라는 사용자 노브에 저장됩니다.None convert_to_write_nodes()예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.convert_to_write_nodes() convert_from_write_nodes()이전에 Flow Production Tracking Write node에서 변환된 모든 일반 Nuke Write node를 다시 Flow Production Tracking Write node로 변환합니다.None convert_from_write_nodes()예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.convert_from_write_nodes() process_placeholder_nodes()모든 자리 표시자 노드를 전체 Flow Production Tracking Write node로 변환합니다. 이 방식은 주로 Nuke에서 스크립트를 처음 열 때 Hiero 툴킷 스크립트 내보내기로 만든 자리 표시자 노드를 변환하는 데 사용됩니다.None process_placeholder_nodes()예&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.process_placeholder_nodes() ",
    "url": "/09168e73/",
    "relUrl": "/09168e73/"
  },
  "175": {
    "id": "175",
    "title": "Nuke",
    "content": "NukeNuke용 Flow Production Tracking 엔진에는 Flow Production Tracking 앱을 Nuke, Nuke Studio 및 Hiero에 통합하기 위한 표준 플랫폼이 포함되어 있습니다. 간단하고 직접적인 이 플랫폼은 Nuke에 여러 새 항목을 추가합니다.Nuke에 다양한 항목이 표시되는 Flow Production Tracking 메뉴를 생성합니다.Nuke에 다양한 항목이 표시되는 Flow Production Tracking 노드 메뉴를 만듭니다.Flow Production Tracking 단축키를 파일 대화상자에 추가하여 다양한 파일 시스템 위치로 쉽게 이동할 수 있습니다.favourite_directories 설정을 사용하여 현재 환경에 템플릿 경로를 기반으로 하는 고유의 단축키를 추가할 수 있습니다. 이 설정에는 목록의 각 항목이 새로운 즐겨찾기 디렉토리를 나타내는 사전 목록이 필요합니다. 다음은 사용할 형식의 예입니다(아이콘 값으로 ““를 입력하여 지정하지 않을 수도 있음).  favourite_directories:  - display_name: &quot;Shot Publish Path&quot;    template_directory: &quot;shot_publish_area_nuke&quot;    icon: &quot;icons/custom_publish_icon.png&quot;  - display_name: &quot;Shot Work Path&quot;    template_directory: &quot;shot_work_area_nuke&quot;    icon: &quot;icons/custom_work_icon.png&quot;“Flow Production Tracking 현재 프로젝트(Current Project)” 즐겨찾기가 정의된 각 루트에 자동으로 추가됩니다. project_favourite_name 설정을 사용하여 이름을 커스터마이즈하거나 값을 빈 문자열 ''로 설정하여 이러한 즐겨찾기를 비활성화할 수 있습니다.지원되는 응용프로그램 버전이 항목은 테스트를 거쳐 다음 응용프로그램 버전에서 작동하는 것으로 알려져 있습니다.12.0 - 14.0v5최신 릴리즈에서는 더 완벽하게 작동할 수 있지만 이러한 버전에서 아직 공식적으로 테스트되지는 않았습니다.참고: 현재 CentOS 6.5에서 실행되는 Nuke 8.0의 버그로 인해 툴킷을 실행할 때 Nuke가 중단됩니다. CentOS의 다른 버전은 영향을 받지 않습니다. 당사는 이 문제를 인식하고 있습니다(버그 43766). 이 버전을 실행 중인 경우 Nuke의 향후 업데이트에서 이 문제가 해결될 때까지 조치를 취할 수 있도록 당사에 문의해 주십시오.앱 개발자를 위한 정보컨텍스트 트래킹Nuke용 Flow Production Tracking 엔진은 파일 로드 시 컨텍스트를 자동으로 전환합니다. 파일이 로드될 때마다 엔진에서 파일을 확인하고 컨텍스트를 분석합니다.커스텀 기즈모를 사용하는 앱Nuke용 Flow Production Tracking 엔진을 사용하면 커스텀 기즈모를 쉽게 처리할 수 있습니다. 커스텀 기즈모를 사용하는 앱을 작성하는 경우 gizmos라는 폴더에 기즈모를 배치하기만 하면 엔진이 자동으로 해당 위치를 nuke 경로에 추가합니다.그러면 노드 생성 기능을 통해 기즈모에 쉽게 액세스할 수 있습니다.  nuke.createNode(&quot;WriteTank&quot;)                    경고: 기즈모를 사용하는 것이 편리할 수 있지만 씬에 지속되는 노드를 만들려는 경우에는 일반적으로 적절한 솔루션이 아닙니다. 씬에 기즈모를 추가하면 씬과 기즈모 코드 간에 종속성이 발생하기 때문입니다. 씬을 로드할 때마다 Flow Production Tracking 툴킷을 로드해야 할 뿐만 아니라 코드를 업데이트해도 씬에서 사용 중인 이전 기즈모가 손상되지 않도록 신중하게 코드를 관리해야 합니다.    노드 생성 앱커스텀 nuke 노드를 만드는 앱은 신중하게 제작해야 합니다. 이러한 앱에는 씬과 기즈모 코드 간의 종속성이 필요하므로 기즈모를 사용하지 않는 것이 좋습니다. 대신, 커스텀 노드를 nuke 파일로 저장하여 씬으로 가져옵니다.    group_node_script = os.path.join(self.disk_location, &quot;resources&quot;, &quot;my_group_node.nk&quot;)    group_node = nuke.nodePaste(group_node_script)앱 내에서 노드를 호출하는 모든 코드는 반환된 인스턴스를 사용할 수 있습니다.그룹 내에서 앱을 호출해야 하는 모든 코드는 코드가 이전 버전과 호환되도록 신중하게 작성해야 합니다. 다음과 같은 접근 방식을 권장합니다.앱을 시작할 때 nuke 네임스페이스의 일부로 앱 핸들을 등록합니다.    def init_app(self):        nuke.tk_nuke_nameofmyapp = self예를 들어 그룹 노드에 버튼이 있고 일부 Flow Production Tracking 앱 코드를 호출하려는 경우 Flow Production Tracking 툴킷을 찾을 수 없으면 정상적으로 종료합니다. 아래 코드는 앱이 만들 수 있는 그룹 노드에 속한 python 버튼 노브와 연결된 코드입니다.# have to gracefully support the case when# sgtk is not in the system at all!import nuketry:  app = nuke.tk_nuke_nameofmyapp  app.do_something_v1(nuke.thisNode())except:  nuke.warning(&quot;Could not do XYZ! Most likely Sgtk is not currently active.&quot;)앱 동작을 변경하는 경우 앱 콜백의 버전 번호를 증가시켜 계속해서 관리하면 앱 코드가 새로운 동작과 이전 동작을 모두 지원할 수 있습니다.Hiero 내에서 Nuke용 Flow Production Tracking 엔진 사용Nuke용 Flow Production Tracking 엔진은 Hiero 내에서 실행되는 Flow Production Tracking 인식 통합에도 사용됩니다.Flow Production Tracking 앱 액션을 응용프로그램의 여러 위치, 기본 메뉴 막대의 특정 Flow Production Tracking 메뉴 및 다른 Hiero 패널에서 마우스 오른쪽 버튼을 클릭하면 표시되는 다양한 상황별 메뉴에 배치할 수 있습니다.Hiero 메뉴 구성 방법Hiero에는 여러 메뉴가 있기 때문에 Maya나 Nuke 등보다 메뉴 항목의 위치를 구성하는 옵션이 더 많습니다. Nuke용 Flow Production Tracking 엔진의 Hiero 워크플로우 구성은 다음과 같은 모양입니다.  tk-hiero:    location: {name: tk-nuke, type: app_store, version: v0.6.9}    debug_logging: false    timeline_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: Open in Shotgun, requires_selection: true}    spreadsheet_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: Open in Shotgun, requires_selection: true}    bin_context_menu:    - {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;Flow Production Tracking Save As...&quot;, requires_selection: true}    - {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;Version up Current Scene...&quot;, requires_selection: true}    - {app_instance: tk-multi-snapshot, keep_in_menu: false, name: &quot;Snapshot...&quot;, requires_selection: true}    - {app_instance: tk-multi-snapshot, keep_in_menu: false, name: &quot;Snapshot History...&quot;, requires_selection: true}    - {app_instance: tk-multi-publish, keep_in_menu: false, name: &quot;Publish Project...&quot;, requires_selection: true}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: Shotgun File Manager...}대부분의 엔진에는 기본 Flow Production Tracking 메뉴에 배치되는 “단축키”를 지정할 수 있는 목록인 menu_favourites 옵션이 있습니다. 이 외에도 Hiero 전용 구성에는 세 개의 특수 섹션이 있습니다.  timeline_context_menu는 타임라인 편집기에서 클립을 마우스 오른쪽 버튼으로 클릭할 때 표시되는 메뉴를 나타냅니다.  spreadsheet_context_menu는 스프레드시트 편집기에서 항목을 선택하여 마우스 오른쪽 버튼으로 클릭할 때 표시되는 메뉴를 나타냅니다.  bin_context_menu는 모든 프로젝트와 미디어를 볼 수 있는 bin 편집기에서 항목을 선택하여 마우스 오른쪽 버튼으로 클릭할 때 표시되는 메뉴를 나타냅니다.이러한 메뉴에 항목을 추가하려면 구성에 정의된 name 필드가 앱 메뉴에 표시되는 항목과 일치해야 합니다.현재 씬의 개념이 필요한 앱일부 툴킷 앱에는 기본 씬이나 기본 프로젝트의 개념이 필요합니다. 예를 들어 스냅샷 앱은 현재 씬을 스냅샷으로 찍는 방법을 압니다. 그러나 Maya나 Nuke와는 달리 Hiero에는 현재 씬의 개념이 없습니다. 동시에 여러 프로젝트를 Hiero에서 열 수 있습니다. 따라서 앱(예: 스냅샷 앱)이 어떤 프로젝트를 클릭했는지 확인할 수 있도록 후크에 특수 로직을 추가해야 하는 경우가 종종 있습니다. 다음 문서 섹션에서 이 작동 방식을 보여 줍니다.앱 개발자를 위한 정보Hiero에는 현재 프로젝트의 개념이 없으므로 앱이 Hiero 내부에서 클릭되는 내용을 쉽게 찾을 수 있도록 보다 강력한 도구를 추가했습니다. 이에 따라 Hiero용 Flow Production Tracking 엔진에 두 가지 방식이 추가되었습니다.get_menu_selection()가장 최근의 메뉴 클릭에서 선택된 Hiero 객체 목록을 반환합니다.이 목록에는 다양한 유형의 항목이 포함될 수 있습니다. 어떤 방식으로 무엇이 반환되는지 정확하게 보기 위해 디버그 로깅을 켭니다. 그러면 진행 중인 작업의 상세 정보가 표시됩니다.다음은 반환되는 객체의 예입니다.  bin 뷰에서 프로젝트 선택: hiero.core.Bin  bin 뷰에서 항목 선택: hiero.core.BinItem  트랙 선택: hiero.core.TrackItemlist engine_object.get_menu_selection()매개변수 및 반환값  반환값: Hiero 객체 목록예가장 최근 클릭에서 선택된 객체를 가져와서 단일 객체가 선택되고 이 객체가 유효한 Hiero 프로젝트인지 확인합니다. 예를 들어 Hiero에서 프로젝트의 저장, 로드 또는 게시 작업을 트리거하려는 경우에 이 방식이 유용할 수 있습니다.# get the menu selection from the engineselection = engine_obj.get_menu_selection()if len(selection) != 1:    raise TankError(&quot;Please select a single Project!&quot;)if not isinstance(selection[0] , hiero.core.Bin):    raise TankError(&quot;Please select a Hiero Project!&quot;)project = selection[0].project()if project is None:    # apparently bins can be without projects (child bins I think)    raise TankError(&quot;Please select a Hiero Project!&quot;)HieroEngine.get_menu_category()마지막 메뉴 클릭이 발생한 UI 영역을 반환합니다. 이 명령은 거의 사용되지 않으며 호출된 메뉴에 따라 다르게 동작하려는 앱 명령이 있는 경우에 필요할 수 있습니다.area_enum engine_object.get_menu_category()매개변수 및 반환값다음 상수 중 하나를 반환합니다.  HieroEngine.HIERO_BIN_AREA  HieroEngine.HIERO_SPREADSHEET_AREA  HieroEngine.HIERO_TIMELINE_AREA  알 수 없는 경우 또는 정의되지 않은 경우 NoneHiero 작동을 위한 후크 구성 방법Hiero용으로 구성된 다중 앱은 일반적으로 어떤 프로젝트가 클릭되었는지 찾아야 합니다. 예를 들어 tk-multi-workfiles 앱은 프로젝트에 대해 “Flow Production Tracking 다른 이름으로 저장(Save As)”을 수행해야 합니다. 따라서 Hiero의 bin 메뉴에 탱크 다른 이름으로 저장(Tank Save As) 명령을 추가하여 사용자가 bin 뷰에서 프로젝트를 마우스 오른쪽 버튼으로 클릭하고 다른 이름으로 저장(Save As) 옵션을 선택합니다.엔진 구성은 다음과 같습니다.bin_context_menu:- {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;Flow Production Tracking Save As...&quot;, requires_selection: true}이제 앱 자체에서 각 엔진은 저장 및 로드와 같은 씬 이벤트를 처리하는 후크를 구성해야 합니다. Maya나 Nuke와 같은 응용프로그램의 경우 이는 일반적으로 저장, 로드 등을 수행합니다.그러나 Hiero의 경우 실제로 클릭된 프로젝트를 찾는 것으로 시작해야 합니다. 위의 예에서 후크 코드는 다음과 같습니다.class SceneOperation(Hook):    &quot;&quot;&quot;    Hook called to perform an operation with the    current scene    &quot;&quot;&quot;    def execute(self, operation, file_path, context, **kwargs):        &quot;&quot;&quot;        Main hook entry point        :operation: String                    Scene operation to perform        :file_path: String                    File path to use if the operation                    requires it (e.g. open)        :context:   Context                    The context the file operation is being                    performed in.        :returns:   Depends on operation:                    'current_path' - Return the current scene                                     file path as a String                    'reset'        - True if scene was reset to an empty                                     state, otherwise False                    all others     - None        &quot;&quot;&quot;        if operation == &quot;current_path&quot;:            # return the current script path            project = self._get_current_project()            curr_path = project.path().replace(&quot;/&quot;, os.path.sep)            return curr_path        elif operation == &quot;open&quot;:            # open the specified script            hiero.core.openProject(file_path.replace(os.path.sep, &quot;/&quot;))        elif operation == &quot;save&quot;:            # save the current script:            project = self._get_current_project()            project.save()        elif operation == &quot;save_as&quot;:            project = self._get_current_project()            project.saveAs(file_path.replace(os.path.sep, &quot;/&quot;))        elif operation == &quot;reset&quot;:            # do nothing and indicate scene was reset to empty            return True        elif operation == &quot;prepare_new&quot;:            # add a new project to hiero            hiero.core.newProject()    def _get_current_project(self):        &quot;&quot;&quot;        Returns the current project based on where in the UI the user clicked        &quot;&quot;&quot;        # get the menu selection from the engine        selection = self.parent.engine.get_menu_selection()        if len(selection) != 1:            raise TankError(&quot;Please select a single Project!&quot;)        if not isinstance(selection[0] , hiero.core.Bin):            raise TankError(&quot;Please select a Hiero Project!&quot;)        project = selection[0].project()        if project is None:            # apparently bins can be without projects (child bins I think)            raise TankError(&quot;Please select a Hiero Project!&quot;)        return project디버그 로깅을 사용하여 메뉴 이벤트 보기특정 선택 항목을 클릭했을 때 Hiero가 반환하는 객체를 보려면 엔진 디버그 모드를 켜면 됩니다. 스크립트 편집기에서 각 클릭으로 선택한 객체의 요약을 볼 수 있습니다.",
    "url": "/4dc252e5/",
    "relUrl": "/4dc252e5/"
  },
  "176": {
    "id": "176",
    "title": "Photoshop",
    "content": "PhotoshopPhotoshop CC용 Flow Production Tracking 엔진은 Photoshop CC 워크플로우에 Flow Production Tracking를 통합하기 위한 플랫폼을 제공합니다. 표준 Flow Production Tracking Toolkit 엔진으로 구성되며, tk-framework-adobe(CEP)를 사용합니다.활성화되면 Photoshop CC에서 Flow Production Tracking Adobe 패널을 사용할 수 있게 됩니다. Flow Production Tracking 컨텍스트에 대한 정보와 현재 해당 컨텍스트에 설치된 앱에 등록된 명령을 표시합니다.지원되는 응용프로그램 버전이 항목은 테스트를 거쳐 다음 응용프로그램 버전에서 작동하는 것으로 알려져 있습니다.2020 (v21.0) - 2023 (v24.7) Note: Apple Silicon (M1/M2) native is not supported, Apple Silicon with Rosetta is supported, learn more here.최신 릴리즈에서는 더 완벽하게 작동할 수 있지만 이러한 버전에서 아직 공식적으로 테스트되지는 않았습니다.인터페이스 개요Flow Production Tracking 익스텐션 패널은 기본 Photoshop CC 패널과 동일한 색상 팔레트 및 기본 레이아웃을 사용합니다. 익스텐션 패널은 다음 다섯 가지 구성요소로 이루어져 있습니다.  컨텍스트 헤더 - 현재 컨텍스트에 대한 썸네일 및 필드입니다.  즐겨찾기 쉘프 - 현재 컨텍스트에서 가장 많이 사용되는 앱을 표시하도록 디자인되었습니다.  명령 목록 - 현재 컨텍스트에서 자주 사용되지 않는 모든 명령입니다.  상황에 맞는 메뉴 - 추가 컨텍스트 관련 명령 및 디버깅 도구입니다.  로깅 콘솔 - 디버깅용 로깅 출력을 표시하는 콘솔 오버레이입니다.설치Photoshop CC용 Flow Production Tracking 엔진의 설치는 다른 Flow Production Tracking 통합과 동일한 프로토콜을 수행합니다. 엔진 및 앱 설치에 대한 자세한 내용은 툴킷 관리 문서를 참조하십시오. 또한 통합을 구성하는 방법의 예로 기본 툴킷 구성을 참조할 수 있습니다.익스텐션 활성화익스텐션이 설치되면 Photoshop CC의 익스텐션 메뉴를 통해 익스텐션을 실행해야 합니다.이 작업은 한 번만 수행하면 되고 Flow Production Tracking 익스텐션 패널은 이후 시작 시 활성화할 필요 없이 Photoshop CC 레이아웃에 유지될 수 있습니다.활성화하고 이후에 시작하면 Flow Production Tracking 통합이 부트스트랩(Bootstrapping)되는 동안 익스텐션 패널에 로딩 화면이 표시됩니다.이 화면은 일반적으로 현재 컨텍스트가 결정되고 명령이 표시되기까지 몇 초 동안 표시됩니다.인터페이스 구성요소다음 섹션에서는 Flow Production Tracking Photoshop CC 통합의 구성요소를 간략하게 설명합니다.컨텍스트 헤더컨텍스트 헤더는 현재 Flow Production Tracking 컨텍스트에 대한 정보를 표시할 수 있는 커스터마이즈 가능 영역입니다.컨텍스트는 현재 활성 문서에 의해 결정됩니다. 엔진에서 컨텍스트가 결정되면 헤더가 업데이트되어 컨텍스트의 썸네일 필드 상세 정보가 표시됩니다. 필드 정보는 후크로 제어됩니다. 필드 표시를 커스터마이즈하는 방법에 대한 자세한 정보는 아래의 컨텍스트 필드 표시 후크 섹션을 참조하십시오.또한 Photoshop CC는 다중 문서 인터페이스이므로 활성 문서를 변경하면 컨텍스트가 업데이트되고 따라서 Flow Production Tracking 익스텐션도 업데이트됩니다. 특히 여러 Flow Production Tracking 컨텍스트에서 동시에 작업할 때 아티스트가 이 동작을 이해하는 것이 중요합니다.즐겨찾기 쉘프즐겨찾기 쉘프는 Maya 및 Houdini와 같은 다른 Flow Production Tracking DCC 통합에서 사용할 수 있는 메뉴 즐겨찾기와 유사합니다. 이 인터페이스 섹션에서는 가장 일반적으로 사용되는 툴킷 앱을 컨텍스트 헤더 바로 아래에서 쉽게 사용할 수 있고 쉽게 찾습니다.쉘프는 즐겨찾는 명령을 버튼으로 표시하며, 버튼 위에 마우스 커서를 놓으면 회색 음영에서 색상으로 전환되고 상단의 레이블에 이름이 표시됩니다. 버튼 위에 마우스 커서를 놓으면 버튼에 대한 툴팁이 표시됩니다.버튼 중 하나를 클릭하면 실행하도록 등록된 명령에 대한 콜백이 트리거됩니다.명령 즐겨찾기를 지정하는 방법에 대한 자세한 정보는 아래의 쉘프 즐겨찾기 섹션을 참조하십시오.명령 목록명령 목록에는 현재 컨텍스트에 대해 등록된 다른 “일반” 명령이 표시됩니다.일반적으로 파이프라인 구성 내에 설치된 앱은 여기에 표시되는 하나 이상의 명령을 등록합니다. 명령이 즐겨찾기로 식별되지 않고 상황에 맞는 메뉴 명령으로도 식별되지 않는 경우 여기에 표시됩니다.명령 목록 버튼은 즐겨찾기 쉘프의 버튼과 비슷한 방식으로 동작합니다. 유일한 차이점은 아이콘의 오른쪽에 전체 이름이 있는 목록으로 표시된다는 점입니다.상황에 맞는 메뉴상황에 맞는 메뉴 명령으로 등록된 모든 명령은 Flow Production Tracking 익스텐션 패널의 상황에 맞는 메뉴에 표시됩니다.다른 명령 영역과 마찬가지로 이러한 명령은 컨텍스트와 함께 변경됩니다. Flow Production Tracking(으)로 이동(Jump to Flow Production Tracking) 및 파일 시스템으로 이동(Jump to Filesystem)과 같은 명령은 항상 여기에서 사용할 수 있습니다.로깅 콘솔로깅 콘솔에는 CEP Javascript 인터프리터 및 툴킷의 Python 프로세스의 모든 로깅 출력이 표시됩니다.익스텐션에 문제가 있어 지원이 필요한 경우 로깅 콘솔 출력은 Flow Production Tracking 지원 팀이 문제를 디버깅하는 데 매우 유용합니다.구성 및 기술 상세 정보다음 섹션에서는 스튜디오 파이프라인의 특정 요구 사항으로 통합을 구성할 수 있는 통합의 보다 기술적인 측면에 대해 설명합니다.PySidePhotoshop CC용 Flow Production Tracking 엔진은 PySide를 사용합니다. Pyside 설치에 대한 공식 지침을 참조하십시오.CEP 익스텐션익스텐션 자체는 엔진과 함께 번들로 제공되며 엔진은 Photoshop CC를 처음 시작할 때 자동으로 설치를 처리합니다. 익스텐션은 아티스트의 로컬 컴퓨터에 OS별 CEP 익스텐션 표준 디렉토리에 설치됩니다.# Windows&amp;gt; C: Users [user name] AppData Roaming Adobe CEP extensions # OS X&amp;gt; ~/Library/Application Support/Adobe/CEP/extensions/Photoshop CC를 시작할 때마다 엔진 부트스트랩(Bootstrapping) 코드는 엔진과 함께 번들로 제공되는 익스텐션 버전을 컴퓨터에 설치된 버전과 비교하여 검사합니다. 즉, 엔진 업데이트 후 새 익스텐션 버전이 함께 제공된 경우 설치된 익스텐션이 번들로 제공되는 새 버전으로 자동 업데이트됩니다.즐겨찾기 구성즐겨찾기 쉘프는 설치된 앱에 등록된 모든 명령을 표시하도록 구성할 수 있습니다. 이렇게 하려면 환경 설정의 tk-photoshopcc 섹션에 shelf_favorites 구성을 추가하면 됩니다. 다음은 예입니다.shelf_favorites:    - {app_instance: tk-multi-workfiles2, name: File Save...}    - {app_instance: tk-multi-workfiles2, name: File Open...}    - {app_instance: tk-multi-publish, name: Publish...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}설정의 값은 구성에 설치된 앱 중 하나에서 제공하는 등록된 명령을 식별하는 사전 목록입니다. app_instance 키는 설치된 특정 앱을 식별하고 name 키는 해당 앱에서 등록된 명령의 표시 이름과 일치합니다. 위의 예에서 즐겨찾는 네 가지 명령, tk-multi-workfiles2 앱의 파일 열기 및 저장 대화상자와 표준 툴킷 게시 및 스냅샷 대화상자를 볼 수 있습니다. 이제 이 네 가지 명령이 즐겨찾기 쉘프에 표시됩니다.컨텍스트 필드 표시 후크엔진에는 패널의 컨텍스트 헤더 섹션에 표시되는 필드를 제어하는 후크가 제공됩니다. 후크에서 표시되는 항목을 커스터마이즈하기 위해 재지정할 수 있는 두 가지 방식이 있습니다.첫 번째는 get_entity_fields() 방식입니다. 이 방식은 현재 Flow Production Tracking 컨텍스트를 나타내는 엔티티 유형을 적용합니다. 예상되는 반환값은 표시를 위해 쿼리해야 하는 해당 엔티티의 필드 목록입니다. 엔진 자체는 비동기적으로 데이터 쿼리를 처리합니다.ShotGrid에서 데이터를 쿼리하면 후크의 두 번째 방식이 호출됩니다. 이 get_context_html() 방식은 get_entity_fields() 방식에서 지정된 쿼리된 필드로 채워진 컨텍스트 엔티티 사전을 수신합니다. 예상되는 반환값은 쿼리된 엔티티 필드를 표시하도록 형식이 지정된 HTML을 포함하는 문자열입니다.기본 후크 구현은 이러한 방식에 필요한 사항에 대한 좋은 참조입니다.엔진은 엔티티 썸네일을 사용할 수 있는 경우 항상 이를 표시합니다.Photoshop API이 엔진은 Photoshop CC용 Javascript API를 Python에 노출합니다.Photoshop API 객체는 engine.adobe로 노출됩니다. 아래 예는 툴킷 앱과 후크 내에서 Photoshop DOM을 직접 조작하는 방법을 보여 줍니다. 표준 툴킷 앱에는 Photoshop 문서와 상호 작용하는 방법에 대한 작업 예가 포함되어 있습니다.예파일 로드:f = adobe.File('/Path/To/File.jpeg')adobe.app.load(f)눈금자 단위를 픽셀로 설정:pixels = adobe.Units.PIXELSadobe.app.preferences.rulerUnits = pixels기본 옵션을 사용하여 현재 웹 문서 내보내기:temp_thumb_file = adobe.File(out_path)save_for_web = adobe.ExportType.SAVEFORWEBexport_options = adobe.ExportOptionsSaveForWeb()adobe.app.activeDocument.exportDocument(temp_thumb_file, save_for_web, export_options)각 레이어를 별도의 파일로 내보내기:doc = adobe.app.activeDocumentlayers = doc.artLayerslayers = [layers[i] for i in xrange(layers.length)]original_visibility = [layer.visible for layer in layers]save_for_web = adobe.ExportType.SAVEFORWEBexport_options = adobe.ExportOptionsSaveForWeb()for layer in layers:    layer.visible = Falsefor layer in layers:    layer.visible = True    out_file = adobe.File(&quot;c:/layer.%s.jpg&quot; % str(layer.name))    doc.exportDocument(        out_file,        save_for_web,        export_options,    )    layer.visible = Falsefor (i, layer) in enumerate(layers):    layer.visible = original_visibility[i]환경 변수디버깅을 돕기 위해 엔진의 일부 기본값을 변경하는 일련의 환경 변수가 있습니다.SHOTGUN_ADOBE_HEARTBEAT_INTERVAL - Python heartbeat 간격(초)입니다(기본값: 1초). 레거시 환경 변수 SGTK_PHOTOSHOP_HEARTBEAT_INTERVAL 역시 설정된 경우 적용됩니다.SHOTGUN_ADOBE_HEARTBEAT_TOLERANCE - 종료하기 전 heartbeat 오류 수입니다(기본값: 2). 레거시 환경 변수 SGTK_PHOTOSHOP_HEARTBEAT_TOLERANCE 역시 설정된 경우 적용됩니다.SHOTGUN_ADOBE_NETWORK_DEBUG - 출력 로깅 시 추가 네트워킹 디버그 메시지를 포함합니다. 레거시 환경 변수 SGTK_PHOTOSHOP_NETWORK_DEBUG 역시 설정된 경우 적용됩니다.SHOTGUN_ADOBE_PYTHON - 엔진을 시작할 때 사용할 Python 실행 파일의 경로입니다. 설정되지 않은 경우 시스템 Python이 사용됩니다. Photoshop이 Flow Production Tracking 데스크톱과 같은 Python 프로세스에서 또는 tk-shell 엔진을 통해 시작되면 해당 프로세스에서 사용되는 Python이 Photoshop 통합에서 사용됩니다.참고: Adobe 프레임워크에 추가 환경 변수가 존재합니다. 자세한 내용은 개발자 문서를 참조하십시오.앱 개발자 노트  Python 프로세스는 Photoshop CC 프로세스와 별개이므로 가능한 깔끔한 방식으로 Photoshop 창 위에 표시되는 앱 창을 만들기 위해 엔진 내에서 일부 작업이 수행됩니다. 이 설정의 한 가지 문제는 QFileDialog의 경우 기본 OS 창을 사용하도록 하는 기본 옵션입니다. 이 엔진과 함께 사용할 앱을 개발하는 경우 기본 대화상자를 사용하지 않도록 옵션을 설정해야 합니다. tk-multi-pythonconsole 앱에서 이에 대한 예를 참조하십시오.",
    "url": "/8d461cbe/",
    "relUrl": "/8d461cbe/"
  },
  "177": {
    "id": "177",
    "title": "쉘",
    "content": "쉘쉘용 Flow Production Tracking 엔진은 명령행 상호 작용을 처리하며 Core API의 일부로 배포되는 tank 명령과 완전히 통합됩니다. 터미널에서 tank 명령을 실행하면 툴킷은 엔진을 시작하여 앱 실행을 처리합니다.tank 명령에 대한 자세한 내용은 고급 툴킷 관리 설명서를 참조하십시오.설치 및 업데이트Flow Production Tracking Toolkit에 이 엔진 추가asset 환경의 XYZ 프로젝트에 이 엔진을 추가하려면 다음 명령을 실행합니다.&amp;gt; tank Project XYZ install_engine asset tk-shell최신 버전으로 업데이트프로젝트에 이 항목이 이미 설치되어 있는 경우 최신 버전을 얻으려면 update 명령을 실행할 수 있습니다. 특정 프로젝트와 함께 제공되는 tank 명령을 탐색하여 다음과 같이 실행할 수 있습니다.&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updates또는 스튜디오 tank 명령을 실행하고 업데이트 확인을 실행할 프로젝트 이름을 지정할 수 있습니다.&amp;gt; tank Project XYZ updates협업 및 개선Flow Production Tracking Toolkit에 액세스할 수 있다면 모든 앱, 엔진 및 프레임워크가 저장 및 관리되는 Github에서 그 소스 코드에도 액세스할 수 있습니다. 이러한 항목을 자유롭게 개선하여 향후 독립적인 개발을 위한 기반으로 사용하고 변경 후 다시 사용자 요청을 제출하거나, 아니면 그냥 조금만 손을 보고 어떻게 빌드되었는지, 툴킷이 어떻게 작동하는지 확인해 보십시오. https://github.com/shotgunsoftware/tk-shell에서 이 코드 리포지토리에 액세스할 수 있습니다.",
    "url": "/2ad59ee8/",
    "relUrl": "/2ad59ee8/"
  },
  "178": {
    "id": "178",
    "title": "Flow Production Tracking Folders",
    "content": "Flow Production Tracking FoldersFlow Production Tracking Toolkit에는 구성을 기반으로 표준화된 디렉토리 구조를 만드는 시스템이 내장되어 있습니다. 따라서 여러 샷에 대해 일관된 파일 시스템 레이아웃을 쉽고 빠르게 생성할 수 있습니다.이 앱은 Flow Production Tracking를 사용하여 Sgtk Core API의 파일 시스템 생성 API 방식을 후크합니다. 덕분에 폴더 생성이 쉬워집니다. 샷 또는 에셋 집합을 선택하고 폴더 만들기(Create Folders) 액션을 클릭하기만 하면 됩니다.작동 방식구성에 따라 하나 이상의 태스크, 샷 또는 다른 엔티티를 선택하기만 하면 됩니다. 이제 액션(Actions) 메뉴에서 폴더 만들기(Create Folders)를 선택합니다. 프로세스가 완료되면 생성된 폴더 수에 대한 보고서가 제공됩니다.",
    "url": "/134adb0e/",
    "relUrl": "/134adb0e/"
  },
  "179": {
    "id": "179",
    "title": "Flow Production Tracking Launch Folder",
    "content": "Flow Production Tracking Launch FolderLaunch Folder 앱은 Flow Production Tracking에서 파일 시스템으로 이동할 수 있는 Flow Production Tracking 유틸리티입니다.작동 방식Launch Folder 앱을 사용하면 Flow Production Tracking에서 파일 시스템으로 이동할 수 있습니다. 샷, 에셋 및 시퀀스와 같은 Flow Production Tracking 엔티티 유형에 등록할 수 있습니다. 활성화되면 액션(Action) 메뉴에 표시됩니다.ShotGrid에서 하나 또는 여러 항목을 선택할 수 있으며 메뉴 액션을 클릭하면 표준 파일 브라우저가 시작됩니다(Windows의 탐색기, Mac의 Finder 등).",
    "url": "/0c3049eb/",
    "relUrl": "/0c3049eb/"
  },
  "180": {
    "id": "180",
    "title": "Flow Production Tracking Launch Publish",
    "content": "Flow Production Tracking Launch Publish이 앱은 Flow Production Tracking의 게시된 파일 엔티티에 “연결된 응용프로그램에서 열기(Open in Associated Application)” 액션을 추가합니다. 이렇게 하면 이미 게시된 파일을 쉽게 열 수 있습니다. 해당 파일을 찾아 마우스 오른쪽 버튼으로 클릭한 다음 액션을 선택하면 됩니다.이 앱을 사용하면 여러 파일에 대해 다양한 앱 실행 시퀀스를 간편하게 구성할 수 있으며 이 모든 작업은 후크 내에서 수행됩니다. 또한 뷰어(예: RV)에 이미지 시퀀스를 디스패치합니다. 후크에서 인식되지 않는 파일은 OS 수준의 앱으로 디스패치됩니다.",
    "url": "/a01dbeb7/",
    "relUrl": "/a01dbeb7/"
  },
  "181": {
    "id": "181",
    "title": "ShotGrid",
    "content": "ShotGridFlow Production Tracking 엔진은 Flow Production Tracking 내에서 시작할 수 있는 앱을 관리합니다. 이러한 툴킷 앱을 액션으로 간주하는 경우가 있습니다. 일반적으로 이러한 앱은 Flow Production Tracking 내부의 메뉴에 항목으로 표시됩니다.Flow Production Tracking Toolkit 액션 사용액션은 Flow Production Tracking 홈페이지에 표시됩니다.객체 또는 선택 항목을 마우스 오른쪽 버튼으로 클릭하면 표시되는 표준 Flow Production Tracking 상황에 맞는 메뉴에서도 찾을 수 있습니다.액션을 클릭하면 즉시 처리가 시작됩니다. 앱이 완료되면 일반적으로 일부 상태 정보가 포함된 메시지가 표시되고 정상적으로 작동하지 않을 경우 오류 메시지가 표시됩니다.ShotGrid용 앱 개발Flow Production Tracking 내부에서 실행되는 앱을 개발하는 것은 쉽습니다. 일반적인 앱 개발 작업 방식을 잘 모르는 경우 플랫폼 문서로 이동하여 소개 자료를 확인하십시오. 이 섹션에서는 앱 개발 프로세스의 Flow Production Tracking 측면에 대해 설명합니다.Core v0.13부터는 Flow Production Tracking 엔진에서 모든 다중 앱을 사용할 수 있습니다. 기술적으로 Flow Production Tracking 엔진과 다른 엔진 사이에는 차이가 거의 없습니다. 그러나 다음과 같이 약간의 미묘한 차이가 있습니다.  Flow Production Tracking 엔진에서 QT 기반 앱을 실행하려면 PySide 또는 PyQt를 표준 Python 환경에 수동으로 설치해야 합니다.  Flow Production Tracking 엔진에서는 사용자가 속한 권한 그룹에 따라 사용자에게 액션을 표시할 수 있습니다. Flow Production Tracking 액션(Action) 메뉴에 명령을 추가하고 관리자(Admin)만 볼 수 있게 하려는 경우에 유용합니다.관리자(Admin)에게만 표시되는 hello-world 스타일의 Flow Production Tracking 앱은 다음과 같습니다.from tank.platform import Applicationclass LaunchPublish(Application):    def init_app(self):        &quot;&quot;&quot;        Register menu items with Flow Production Tracking        &quot;&quot;&quot;                params = {            &quot;title&quot;: &quot;Hello, World!&quot;,            &quot;deny_permissions&quot;: [&quot;Artist&quot;],        }        self.engine.register_command(&quot;hello_world_cmd&quot;, self.do_stuff, params)    def do_stuff(self, entity_type, entity_ids):        # this message will be displayed to the user        self.engine.log_info(&quot;Hello, World!&quot;)    설치 및 업데이트Flow Production Tracking Toolkit에 이 엔진 추가asset 환경의 XYZ 프로젝트에 이 엔진을 추가하려면 다음 명령을 실행합니다.&amp;gt; tank Project XYZ install_engine asset tk-shotgun최신 버전으로 업데이트프로젝트에 이 항목이 이미 설치되어 있는 경우 최신 버전을 얻으려면 update 명령을 실행할 수 있습니다. 특정 프로젝트와 함께 제공되는 tank 명령을 탐색하여 다음과 같이 실행할 수 있습니다.&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updates또는 스튜디오 tank 명령을 실행하고 업데이트 확인을 실행할 프로젝트 이름을 지정할 수 있습니다.&amp;gt; tank Project XYZ updates협업 및 개선Flow Production Tracking Toolkit에 액세스할 수 있다면 모든 앱, 엔진 및 프레임워크가 저장 및 관리되는 Github에서 그 소스 코드에도 액세스할 수 있습니다. 이러한 항목을 자유롭게 개선하여 향후 독립적인 개발을 위한 기반으로 사용하고 변경 후 다시 사용자 요청을 제출하거나, 아니면 그냥 조금만 손을 보고 어떻게 빌드되었는지, 툴킷이 어떻게 작동하는지 확인해 보십시오. https://github.com/shotgunsoftware/tk-shotgun에서 이 코드 리포지토리에 액세스할 수 있습니다.특별 요구 사항이 기능을 이용하려면 Flow Production Tracking Toolkit Core API 버전 v0.19.5 이상이 필요합니다.",
    "url": "/02c2d8aa/",
    "relUrl": "/02c2d8aa/"
  },
  "182": {
    "id": "182",
    "title": "VRED",
    "content": "VREDVRED용 Flow Production Tracking 엔진에는 Flow Production Tracking 앱을 VRED에 통합하기 위한 표준 플랫폼이 포함되어 있습니다. 직접적으로 실행되는 경량의 플랫폼으로, VRED 메뉴에 Flow Production Tracking 메뉴를 추가합니다.지원되는 응용프로그램 버전이 항목은 테스트를 거쳐 다음 응용프로그램 버전에서 작동하는 것으로 알려져 있습니다.2020.3 - 2023최신 릴리즈에서는 더 완벽하게 작동할 수 있지만 이러한 버전에서 아직 공식적으로 테스트되지는 않았습니다.앱 개발자를 위한 정보VRED 프로젝트 관리VRED용 Flow Production Tracking 엔진이 시작되면 VRED 프로젝트가 이 엔진 설정에서 정의된 위치를 가리키도록 설정됩니다. 즉, 새 파일을 열면 프로젝트가 변경될 수도 있습니다. 파일을 기반으로 VRED 프로젝트가 설정되는 방법과 관련된 상세 정보는 템플릿 시스템을 사용하여 구성 파일에서 구성할 수 있습니다.tk-vred 작업이 Flow Production Tracking 통합은 VRED 제품군(Pro 및 Design)을 지원합니다.VRED가 열리면 Flow Production Tracking 메뉴(VRED 엔진)가 메뉴 막대에 추가됩니다. 파일 열기 및 저장내 태스크(My Tasks) 및 에셋(Assets) 탭을 사용하여 할당된 모든 태스크를 보고 에셋을 찾을 수 있습니다. 오른쪽에서 이 탭을 사용하여 왼쪽에 선택된 항목과 연관된 모든 파일, 작업 파일 또는 게시된 파일을 볼 수 있습니다. 게시게시: 파일을 Flow Production Tracking에 게시하기 위한 게시(Publish) 대화상자를 엽니다. 게시하면 아티스트 다운스트림에서 사용할 수 있습니다. VRED 게시에 대한 자세한 내용은 여기를 참조하십시오. LoaderLoader: 앱 작동 방법을 설명하는 지침 슬라이드와 함께 컨텐츠 Loader 앱을 엽니다. VRED 로드에 대한 자세한 내용은 여기를 참조하십시오. 씬 분할씬 분할: 기한이 만료된 씬의 항목과 함께 또는 PublishedFile의 대체 버전을 사용하여 “참조된” 파일(및 해당 링크) 목록을 표시하는 분할(Breakdown) 대화상자를 엽니다. ",
    "url": "/9d824e0b/",
    "relUrl": "/9d824e0b/"
  },
  "183": {
    "id": "183",
    "title": "API",
    "content": "툴킷 API여기에서는 툴킷 플랫폼이 제공하는 API에 대한 참조 문서를 찾을 수 있습니다.",
    "url": "/6c5b0b61/",
    "relUrl": "/6c5b0b61/"
  },
  "184": {
    "id": "184",
    "title": "앱",
    "content": "툴킷 앱여기에서는 툴킷 플랫폼에 사용할 수 있는 앱에 대한 참조 문서를 찾을 수 있습니다.",
    "url": "/f8596e35/",
    "relUrl": "/f8596e35/"
  },
  "185": {
    "id": "185",
    "title": "환경 구성",
    "content": "환경 구성 참조소개툴킷 파이프라인의 핵심에는 환경 구성이 있습니다. 툴킷 파이프라인 구성 내에서 환경 구성 파일은 다양한 DCC 내에서 사용할 수 있는 툴킷 앱을 정의하고 각 설정을 커스터마이즈할 수 있는 곳입니다. 이 문서는 환경 구성 파일의 구조 및 기능을 전체적으로 소개하는 완전한 참조 자료입니다. 이 문서에서는 프로젝트 내에서 다양한 워크플로우를 구성할 수 있게 해 주는 툴킷 환경의 개념과 커스터마이즈할 수 있는 항목을 찾는 방법에 대해 설명합니다.                    참고: 이 문서는 환경 구성 파일에 대한 참조 자료로 사용될 수 있으며 툴킷 기본 사항 안내서의 파이프라인 구성 편집에서는 구성 설정 편집에 대한 단계별 예제를 확인할 수 있습니다.    환경이란?Flow Production Tracking 툴킷 플랫폼은 스튜디오 파이프라인을 구축하는 데 일반적으로 사용되는 컨텐츠 작성 소프트웨어를 위해 완전히 커스터마이즈 가능한 통합 세트를 제공합니다. 프로젝트 구성 내에서 통합이 있는 소프트웨어 패키지, 각각 사용 가능한 툴킷 앱, 각 앱에 대한 옵션을 지정하여 스튜디오의 요구 사항에 맞게 아티스트 워크플로우를 구축할 수 있습니다.하지만 대부분의 스튜디오 파이프라인에서는 아티스트 유형별로 다른 워크플로우를 사용하는 것이 일반적입니다. 간단한 예로, 에셋 작업 중인 아티스트의 경우 텍스처 페인팅 소프트웨어(예: Mari)를 사용하게 하고 샷 작업 중인 아티스트의 경우에는 컴포지팅 소프트웨어(예: Nuke)를 사용하게 할 수 있습니다.소프트웨어 패키지뿐 아니라 동일한 툴킷 앱에 대한 설정도 아티스트별로 다르게 지정할 수 있습니다. 예를 들어 샷 아티스트와 에셋 아티스트 둘 다 Workfiles 앱을 사용할 수 있지만 샷 아티스트는 샷 엔티티, 에셋 아티스트는 에셋 엔티티와 관련된 파일로만 파일 네비게이션을 제한할 수 있습니다.프로젝트 내에서 이렇게 서로 다른 워크플로우를 지원하기 위해 툴킷은 환경에서 앱과 엔진 구성을 분리합니다. 각 환경에는 소프트웨어 패키지 셋트의 통합과 설정이 모두 공통적으로 포함되어 있습니다.위의 예에서 에셋 작업 중인 아티스트는 에셋 단계 환경에서 작업하고 샷 작업 중인 아티스트는 샷 단계 환경에서 작업합니다. 각 환경은 서로 독립적으로 구성되므로 한 프로젝트 내에서 각기 다른 워크플로우를 사용할 수 있습니다.툴킷의 기본 구성에 대한 참고 사항툴킷은 환경을 구성하는 방식에 있어 매우 자유롭습니다. 이 문서에서는 사용 가능한 모든 옵션을 모두 소개하므로 파이프라인 요구 사항에 가장 적합한 선택을 하는 데 필요한 지식을 얻을 수 있습니다.또한 이 문서에서는 기본 구성이라는 시작점으로 제공되는 파이프라인 구성의 선택 사항에 대해서도 설명합니다. 파이프라인을 커스터마이즈할 준비가 된 경우 첫 번째 단계는 프로젝트에 대해 편집 가능한 파이프라인 구성을 생성하는 것입니다.이러한 선택 사항은 일반적인 규칙일 뿐이고 툴킷 워크플로우에 하드코딩되지 않으므로, 기본 구성은 파이프라인을 커스터마이즈한 후 사용할 수 있는 기능을 학습하기 위한 예제로 참조하거나 고유의 구성을 설정하기 위한 모범 사례로 사용하는 것이 좋습니다. 또한 새로운 툴킷 사용자를 위한 시작점으로도 좋으며 몇 가지 규칙을 알아 두면 유용합니다. 이 문서에서는 툴킷 환경 구성의 일반적인 기능과 기본 구성에 특정한 선택 사항을 구분해 두었습니다. 기본 구성의 환경 구조에 대한 자세한 내용은 읽어보기 파일을 참조하십시오.파일 위치파이프라인 구성에서 config/ 디렉토리에는 커스터마이즈할 수 있는 모든 파일 및 폴더가 포함됩니다. config/에는 세 개의 하위 디렉토리(cache, core 및 env)가 있습니다. env 디렉토리에 환경 구성 파일이 있으므로 이 문서에서는 config/env의 파일을 참조합니다.기본 구성의 config/env/에는 다음 파일이 있습니다.asset.ymlasset_step.ymlproject.ymlsequence.ymlshot.ymlshot_step.yml이러한 각 파일이 환경에 해당하며 별도 파일을 사용하면 각 환경을 별도로 구성할 수 있습니다.툴킷이 현재 환경을 결정하는 방식툴킷은 pick_environment라는 코어 후크를 사용하여 현재 컨텍스트를 기반으로 지정된 시간에 사용할 환경 파일을 결정합니다. pick_environment 후크의 반환 값은 환경 구성 파일에 해당합니다. 예를 들어 pick_environment가 shot_step을 반환하는 경우 툴킷은 config/env/shot_step.yml을 사용하여 툴킷 환경을 구성합니다.커스텀 환경위에 나열된 환경 구성 파일은 기본 구성에서 제공하는 파일입니다. 그러나 일부 스튜디오에서는 다른 환경 또는 추가 환경을 필요로 할 수 있습니다. 예를 들어 스튜디오에서 파이프라인 단계(asset_step_rig, asset_step_model, shot_step_anim, shot_step_light 등)마다 다른 구성 설정을 사용해야 할 수 있습니다. 다행히도 사용 가능한 환경을 완전히 커스터마이즈할 수 있습니다.이렇게 하려면 원하는 환경 구성 파일을 config/env 디렉토리에 추가해야 합니다. 그런 다음 pick_environment 코어 후크를 재지정하여 새 환경을 사용할 때 정의하는 로직에 추가합니다.기본 구조툴킷의 구성 파일은 YAML로 작성됩니다. 모든 번들(앱, 엔진 또는 프레임워크)의 일반적인 구성은 다음과 같은 구조로 되어 있습니다.bundle_name:  setting1: value  setting2: value  complex_setting:    sub_setting1: value      Sub_setting2: value  location:    type: descriptor_type    descriptor_setting1: value    descriptor_setting2: value이 구조를 보여 주는 간단한 예제가 아래에 있습니다(단일 엔진이 있고 엔진 내에 단일 앱이 정의된 환경). 다음은 이 구성에서 project.yml의 내용이 될 수 있습니다.engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4엔진 블록모든 환경 구성 파일은 engines 블록으로 시작합니다. 해당 환경에 대해 정의된 모든 엔진이 이 블록 내에 중첩됩니다.이 예에서는 하나의 엔진, tk-maya만 정의되어 있습니다. 여기에는 두 개의 설정(apps 및 location)이 나열되어 있습니다.location은 모든 번들에 필요한 특수한 설정입니다. apps 설정은 엔진에 대해 정의된 모든 앱의 목록으로, 각 앱에는 자체 설정이 있습니다. 이 예에서는 엔진에 대해 하나의 앱, tk-multi-workfiles2만 정의되어 있습니다.위치 디스크립터모든 툴킷 번들에는 번들의 디스크립터라고 불리는 location 설정이 있습니다. 디스크립터를 통해 툴킷은 지정된 번들의 위치를 파악하고 해당 유형에 따라 직접 액세스할지 아니면 로컬로 캐시할지 여부를 파악합니다. 툴킷 번들을 가져올 수 있는 위치는 Flow Production Tracking 앱 스토어, git 리포지토리, 디스크의 경로 또는 Flow Production Tracking 사이트에 업로드된 ZIP 파일 등입니다. 이러한 각 위치에 해당하는 디스크립터 유형이 있으며 여기에는 해당 유형과 관련된 설정이 포함됩니다. 위 예제의 tk-maya 엔진에 대한 디스크립터는 다음과 같습니다.    location:        type: app_store        name: tk-maya        version: v0.9.4이 예는 app_store 유형의 디스크립터로, 툴킷이 Flow Production Tracking 앱 스토어에서 지정된 번들을 가져오도록 합니다. app_store 유형의 디스크립터에는 name 및 version 설정이 있습니다.한편, 커스텀 번들을 개발 중이고 스튜디오의 특정 워크플로우에 대한 툴킷 앱을 작성 중인 경우 디스크의 경로에서 직접 가져오고 싶을 수 있습니다. 이 경우 다음과 같이 dev 유형의 디스크립터를 사용합니다.    location:        type: dev        path: /path/to/appdev 디스크립터에는 app_store 디스크립터와 다른 설정이 있습니다. 다른 설정을 가져올 수 있지만 디스크에 있는 앱 위치를 가리키는 path 설정으로 간단하게 설정할 수 있습니다.사용 가능한 모든 디스크립터 유형 및 해당 설정에 대한 자세한 내용은 Toolkit Core API 문서의 디스크립터 섹션을 참조하십시오.앱 블록앱은 툴킷의 사용자 도구로, 각 앱은 서로 독립적으로 실행할 수 있습니다. 파이프라인 요구 사항에 맞게 사용할 앱을 선택할 수 있으며 엔진 블록 내의 apps 설정은 지정된 엔진에서 사용할 수 있는 앱을 정의하는 곳입니다.위 예제에서 apps 설정은 다음과 같습니다.engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8단일 앱인 tk-multi-workfiles2 앱이 정의되어 있는 것을 확인할 수 있습니다. 현재는 하나의 설정(디스크립터)만 정의되어 있습니다.project 환경의 tk-maya 엔진에서 다른 앱을 사용할 수 있도록 하려면 여기에 추가합니다. 엔진에 Panel, tk-multi-shotgunpanel 및 앱 정보 tk-multi-about을 추가해 보겠습니다. project.yml 예제 파일은 이제 다음과 같이 표시됩니다.engines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4이때 다음과 같은 몇 가지 중요 사항에 유의해야 합니다.  기본 구성에는 번들이 알파벳순으로 나열되며 이 예에서는 해당 규칙을 따릅니다.  파일이 길어지기 시작하고 있지만 아직 어떤 구성 설정도 추가하지 않은 상태입니다.  다른 엔진 및 다른 환경에서도 이와 동일한 앱을 사용할 수 있습니다. 예를 들어 다른 엔진(예: Houdini, Nuke 또는 Photoshop) 및 다른 환경(예: asset_step 또는 shot_step)에도 이 세 개의 앱(Panel 앱, About 앱, Workfiles 앱)이 모두 있을 수 있습니다. 구성에서 여러 곳에 공통 앱 설정을 정의하면 변경 시에도 여러 곳에서 수정해야 합니다.마지막 두 가지 문제점을 해결하기 위해 툴킷 구성은 includes를 지원합니다.Includesincludes는 구성에서 한 파일의 섹션을 다른 파일에서 참조할 수 있게 해 줍니다. includes를 사용하면 한 곳에서 구성 설정을 설정한 후 여러 환경에서 사용할 수 있습니다.includes는 두 부분으로 구성됩니다.  includes 목록: 키가 includes인 YAML 사전이며 값은 포함할 모든 파일의 목록입니다.  구성 설정 내의 참조: 앞에 @ 기호가 붙고, 포함된 파일에서 참조할 섹션의 이름을 가리키도록 명명됩니다.위의 예제를 구체화하기 위해 모든 엔진에 대한 위치 디스크립터가 있는 단일 파일이 있다고 가정합니다. 이 파일을 includes 하위 폴더에 넣고 engine_locations.yml로 지정하겠습니다.engine_locations.yml의 내용은 다음과 같습니다.config/env/includes/engine_locations.yml:engines.tk-maya.location:  type: app_store  name: tk-maya  version: v0.9.4engines.tk-nuke.location:  type: app_store  name: tk-nuke  version: v0.11.5...이 파일은 모든 엔진 위치에 대한 단일 소스 역할을 하며 모든 환경 구성에서 참조할 수 있습니다. 이 포함 파일을 사용할 경우 예제는 이제 다음과 같이 표시됩니다.config/env/project.yml:includes:- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location: @engines.tk-maya.locationtk-maya 엔진에 대한 location 설정 값이 이제 포함된 YAML 파일의 키에 대한 참조임을 확인할 수 있습니다.                    참고: 이 예제에서와 같이 config/env/includes/engine_locations.yml 파일에 모든 엔진 위치가 있는 기본 구성의 규칙을 따릅니다.    앱 위치에 대한 두 번째 포함 파일을 추가할 수 있으며 사실 기본 구성은 이 작업을 수행합니다. 예제를 확장해 보겠습니다.config/env/includes/app_locations.yml:apps.tk-multi-about.location:  type: app_store  name: tk-multi-about  version: v0.2.8apps.tk-multi-shotgunpanel.location:  type: app_store  name: tk-multi-shotgunpanel  version: v1.6.3apps.tk-multi-workfiles2.location:  type: app_store  name: tk-multi-workfiles2  version: v0.11.8config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.location이제 포함된 engine_locations.yml 파일에서 tk-maya 엔진의 디스크립터를 가져오고 포함된 app_locations.yml 파일에서 tk-maya 엔진에 대해 정의된 각 앱의 디스크립터를 가져옵니다.                    참고: 기본 구성은 여기에 설명되지 않은 두 번째 중첩 수준을 사용합니다. 디스크립터 외에도 설정이 있는 모든 앱 또는 엔진에 includes/settings의 설정 파일(예: includes/settings/tk-maya.yml, includes/settings/tk-multi-workfiles2.yml)이 있습니다. 엔진 설정 파일에는 앱 설정 파일의 앱 설정이 포함되고 환경 구성 파일에는 엔진 설정 파일의 설정이 포함됩니다. 기본 구성의 구조에 대한 자세한 내용은 읽어보기 파일을 참조하십시오. 구성 설정 수정에 대한 자세한 내용은 툴킷 기본 사항 안내서의 파이프라인 구성 편집을 참조하십시오.    스파스 구성모든 툴킷 번들에는 각 기본값이 포함된 일련의 구성 설정이 있습니다. 툴킷은 스파스 구성을 허용하므로 환경 구성 파일(및/또는 포함 파일)에 구성 설정이 명시적으로 지정되지 않은 경우에는 번들의 기본값이 사용됩니다.이 예에서는 location을 제외하고 앱에 대한 어떤 설정도 지정하지 않았습니다. 따라서 구성의 현재 상태에서 세 개의 앱은 모든 설정에 대해 기본값을 사용합니다. 그렇다면 어떤 구성 설정을 사용할 수 있는지 어떻게 알 수 있을까요?                    참고: 툴킷 구성이 스파스일 필요는 없지만 기본 구성은 스파스 구성입니다.    사용 가능한 구성 설정 확인스파스 구성의 경우 단순히 구성 파일을 보는 것만으로는 앱에 대해 사용할 수 있는 구성 설정을 바로 확인할 수 없습니다. 사용 가능한 앱 구성 설정을 확인하려면 두 가지 방법이 있습니다.  앱 설명서: 각 앱에는 고유의 설명서 페이지가 있으며 이 각 페이지마다 “구성 옵션” 섹션이 있습니다. 이 섹션에는 각각의 설명 및 기본값을 포함하여 사용 가능한 모든 앱 구성 설정이 나와 있습니다. 예를 들어 Workfiles 설명서 페이지를 참조할 수 있습니다. 앱 및 엔진 페이지에는 모든 앱 및 엔진에 대한 문서 페이지가 나열되어 있습니다.  매니페스트: 모든 툴킷 번들에는 루트 디렉토리에 info.yml 파일이 포함되어 있습니다. 이 파일을 번들의 매니페스트라고 하며 각각의 설명 및 기본값을 포함하여 번들에 대해 사용 가능한 모든 구성 설정을 정의합니다. 매니페스트는 번들의 자체 캐시(예: 파이프라인 구성 내의 install/app_store/tk-multi-workfiles2/v0.11.8/info.yml) 또는 GitHub(Workfiles용)에서 찾을 수 있습니다.구성 설정 수정기본값에서 구성을 수정하려면 파이프라인의 구성에서 적절한 환경의 적절한 블록에 추가하고 값을 설정하면 됩니다.예제로 돌아가 프로젝트 환경에서 Maya를 시작할 때 tk-multi-workfiles2가 자동으로 시작되도록 구성한다고 가정해 보겠습니다. 앱의 매니페스트에서 응용프로그램 시작 시 Workfiles UI 시작 여부를 제어하는 launch_at_startup 설정이 있고 기본값은 False임을 확인할 수 있습니다. 따라서 launch_at_startup 옵션을 추가하고 해당 옵션을 True로 설정합니다. project.yml 파일은 이제 다음과 같이 표시됩니다.config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        launch_at_startup: True        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.locationtk-multi-workfiles2에 대한 설정을 포함 파일에서 가져온 경우 해당 파일에서 설정을 변경해야 합니다.추가 리소스  툴킷 기본 사항 안내서: 파이프라인 구성 편집  툴킷 기본 사항 안내서: 앱 추가  애니메이션 파이프라인 튜토리얼  디스크립터 참조 설명서  웨비나: 툴킷 관리  파일 시스템 구성 참조  기본 구성 환경 구조 읽어보기",
    "url": "/c73fcb84/",
    "relUrl": "/c73fcb84/"
  },
  "186": {
    "id": "186",
    "title": "구성",
    "content": "툴킷 구성여기에서는 툴킷 플랫폼 구성에 대한 참조 문서를 찾을 수 있습니다.",
    "url": "/10e8ee51/",
    "relUrl": "/10e8ee51/"
  },
  "187": {
    "id": "187",
    "title": "어떻게 하면 Flow Production Tracking 이벤트 데몬을 사용하여 다른 Toolkit Core 모듈을 로드할 수 있습니까?",
    "content": "어떻게 하면 shotgunEvents 데몬을 사용하여 다른 Toolkit Core 모듈을 로드할 수 있습니까?이 정보를 공유해 준 Benoit Leveau @ Milk VFX에게 깊이 감사드립니다.문제툴킷의 sgtk API는 프로젝트 중심입니다. 즉, 사용할 프로젝트에서 특별히 가져와야 합니다. 이는 단일 Python 세션에서 다중 프로젝트에 대해 sgtk API 작업을 사용하는 경우 Python은 이름이 동일한 모듈을 한 번만 가져올 수 있기 때문에 문제가 발생할 수 있음을 의미합니다.Flow Production Tracking 이벤트 데몬을 사용 중인 경우 특정 이벤트에 대해서는 플러그인 내에서 툴킷 액션을 수행하고 싶을 수 있습니다. 하지만 Python은 모듈을 한 번만 가져오기 때문에 이렇게 하는 것은 위험할 수 있습니다. 따라서 프로젝트 A용 Toolkit Core API를 플러그인을 처음 실행할 때 가져오면 그 버전이 데몬의 사용 기간 동안 가져온 채로 유지되는 버전이 됩니다. 즉, 플러그인으로 발송된 다음 이벤트가 프로젝트 B의 이벤트인 경우 프로젝트 A용 Core API를 사용하여 프로젝트 B를 위한 새 툴킷 객체의 인스턴스화를 시도하면 툴킷에서 오류가 발생할 수 있습니다.중앙 집중식 구성을 사용하는 경우의 문제 예시:  이벤트 123은 프로젝트 A의 이벤트입니다.  프로젝트 A에 대한 Core API는 /mnt/toolkit/projectA/install/core/python에 있습니다.  이 디렉토리를 sys.path에 접두사로 붙입니다.  import sgtk가 이 위치에서 이 API를 가져옵니다.  이 Core API로 툴킷 인스턴스를 인스턴스화하고 일부 액션을 수행합니다.  Core API 디렉토리를 sys.path에서 분리합니다.  이벤트 234는 프로젝트 B의 이벤트입니다.  프로젝트 B에 대한 Core API는 /mnt/toolkit/projectB/install/core/python에 있습니다.  이 디렉토리를 sys.path에 접두사로 붙입니다.  Python은 이를 이미 가져온 sgtk로 인식하기 때문에 import sgtk는 아무 동작도 하지 않습니다.  이 Core API로 툴킷 인스턴스를 인스턴스화하고 일부 액션을 수행합니다.  툴킷 코어가 작업을 수행하려는 프로젝트 (B)가 아닌 프로젝트 (A)를 위한 것이기 때문에 오류가 발생합니다.솔루션아래 예는 다른 버전의 모듈을 이미 가져왔을 수도 있는 경우에 스크립트 또는 플러그인에서 올바른 버전의 sgtk 코어를 가져올 수 있는 방법을 보여 줍니다. 원래 가져온 항목은 언로드되어 Python 메모리에서 제거되기 때문에 새로운 모듈 인스턴스를 성공적으로 가져와 사용할 수 있습니다.&quot;&quot;&quot;Example of how to import the correct sgtk core code in a script wherea different instance of the module may have already been imported. Theoriginal import is unloaded and removed from memory in Python so the newinstance of the module can be imported and used successfully.Thanks to Benoit Leveau @ Milk VFX for sharing this.&quot;&quot;&quot;import osimport sysdef import_sgtk(project):    &quot;&quot;&quot;    Import and return the sgtk module related to a Project.    This will check where the Core API is located on disk (in case it's localized or shared).    It shouldn't be used to get several instances of the sgtk module at different places.    This should be seen as a kind of 'reload(sgtk)' command.    :param project: (str) project name on disk for to import the Toolkit Core API for.    &quot;&quot;&quot;    # where all our pipeline configurations are located    shotgun_base = os.getenv(&quot;SHOTGUN_BASE&quot;, &quot;/mnt/sgtk/configs&quot;)    # delete existing core modules in the environment    for mod in filter(lambda mod: mod.startswith(&quot;tank&quot;) or mod.startswith(&quot;sgtk&quot;), sys.modules):        sys.modules.pop(mod)        del mod    # check which location to use to import the core    python_subfolder = os.path.join(&quot;install&quot;, &quot;core&quot;, &quot;python&quot;)    is_core_localized = os.path.exists(os.path.join(shotgun_base, project, &quot;install&quot;, &quot;core&quot;, &quot;_core_upgrader.py&quot;))    if is_core_localized:        # the core API is located inside the configuration        core_python_path = os.path.join(shotgun_base, project, python_subfolder)    else:        # the core API can still be localized through the share_core/attach_to_core commands        # so look in the core_Linux.cfg file which will give us the proper location (modify this        # to match your primary platform)        core_cfg = os.path.join(shotgun_base, project, &quot;install&quot;, &quot;core&quot;, &quot;core_Linux.cfg&quot;)        if os.path.exists(core_cfg):            core_python_path = os.path.join(open(core_cfg).read(), python_subfolder)        else:            # use the studio default one            # this assumes you have a shared studio core installed.            # See https://developer.shotgridsoftware.com/b12f2510/#how-do-i-share-the-toolkit-core-between-projects            core_python_path = os.path.join(shotgun_base, &quot;studio&quot;, python_subfolder)    # tweak sys.path to add the core API to the beginning so it will be picked up    if sys.path[0] != &quot;&quot;:        sys.path.pop(0)    sys.path = [core_python_path] + sys.path    # Remove the TANK_CURRENT_PC env variable so that it can be populated by the new import    if &quot;TANK_CURRENT_PC&quot; in os.environ:        del os.environ[&quot;TANK_CURRENT_PC&quot;]    # now import the sgtk module, it should be found at the 'core_python_path' location above    import sgtk    return sgtk분산 구성위 예에서는 중앙 집중식 구성을 사용한다고 가정하고 있지만 분산 구성을 사용할 경우에는 상황이 약간 다릅니다. 분산 구성의 경우 sgtk API를 가져오려면 부트스트랩(Bootstrap) API를 사용해야 합니다. 부트스트랩(Bootstrap) API를 사용하는 경우 일반적으로 비 프로젝트 중심 sgtk API를 가져온 다음 이를 사용하여 지정된 프로젝트에 대한 엔진을 부트스트랩합니다.이 부트스트랩(Bootstrap) 프로세스는 sgtk 모듈 교환을 처리하여 부트스트랩 프로세스 마지막에 엔진 오브젝트를 사용할 수 있도록 합니다. 부트스트랩(Bootstrap) 후 sgtk를 가져오면 프로젝트에 적합한 관련 sgtk 모듈을 가져옵니다. 위의 예에서 다중 프로젝트에 대해 sgtk를 로드해야 하는 대신 다중 프로젝트에 대해 부트스트랩(Bootstrapping)해야 합니다. 여기 작은 캐시는 한 번에 하나의 엔진만 실행할 수 있으므로 다른 엔진을 로드하기 전에 먼저 삭제해야 합니다.                    경고: 구성을 부트스트랩(Bootstrapping)하면 프로세스가 구성을 로컬로 캐시하고 모든 종속성을 다운로드해야 하므로 속도가 느려질 수 있습니다. 이벤트 데몬 플러그인에서 부트스트랩(Bootstrapping)하면 성능에 심각한 영향을 미칠 수 있습니다. 한 가지 가능한 접근 방식은 각 프로젝트 부트스트랩(Bootstrap)에 대해 별도의 Python 인스턴스를 생성하여 플러그인에서 명령을 전달하는 것입니다. 이렇게 하면 필요할 때마다 프로젝트를 다시 부트스트랩(Bootstrapping)하지 않아도 됩니다.    예는 다음과 같습니다.# insert the path to the non project centric sgtk APIsys.path.insert(0,&quot;/path/to/non/project/centric/sgtk&quot;)import sgtksa = sgtk.authentication.ShotgunAuthenticator()# Use the authenticator to create a user object.user = sa.create_script_user(api_script=&quot;SCRIPTNAME&quot;,                            api_key=&quot;SCRIPTKEY&quot;,                            host=&quot;https://SITENAME.shotgunstudio.com&quot;)sgtk.set_authenticated_user(user)mgr = sgtk.bootstrap.ToolkitManager(sg_user=user)mgr.plugin_id = &quot;basic.&quot;engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity={&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176})# import sgtk again for the newly bootstrapped project, (we don't need to handle setting sys paths)import sgtk# perform any required operations on Project 176 ...# Destroy the engine to allow us to bootstrap into another project/engine.engine.destroy()# now repeat the process for the next project, although we don't need to do the initial non-project centric sgtk import this time.# We can reuse the already import sgtk API to bootstrap the next...                    참고: 중앙 집중식 구성도 부트스트랩(Bootstrapping)할 수 있으므로 혼합하여 사용할 경우 다른 방식이 필요하지 않습니다.    ",
    "url": "/3520ad2e/",
    "relUrl": "/3520ad2e/"
  },
  "188": {
    "id": "188",
    "title": "툴킷 엔진에 지원되는 OS 버전",
    "content": "툴킷 엔진에 지원되는 OS 버전다음은 툴킷 엔진 지원 운영 체제 목록입니다.            Windows      MacOS      Linux                  10      10.14+ 참고: M1 기본은 지원되지 않으며, Rosetta가 포함된 M1이 지원됩니다. 자세한 내용은 여기에서 확인하십시오.      CentOS 7.4, Rocky 8.5      ",
    "url": "/918daccf/",
    "relUrl": "/918daccf/"
  },
  "189": {
    "id": "189",
    "title": "엔진 지원 버전",
    "content": "툴킷 엔진 지원 버전다음은 툴킷 플랫폼에 사용할 수 있는 엔진에서 지원되는 최소 응용프로그램 버전 목록입니다.            통합      엔진      지원되는 버전                        tk-3dsmax      2020 - 2023                    tk-aftereffects      2020 (v17.0) - 2023 (v23.6)                    tk-alias      2020 - 2023                    tk-flame      2020+                    tk-houdini      17.5 - 19.5 Note: Running on Apple Silicon (M1/M2), Houdini is supported for both Native mode and Rosetta mode.                    tk-mari      4.0 - 6.0v2                    tk-maya      2020 - 2024 Note: Apple Silicon (M1/M2) native is supported starting with Maya 2024.                    tk-motionbuilder      2020 - 2024                    tk-nuke      12.0 - 14.0v5                    tk-photoshopcc      2020 (v21.0) - 2023 (v24.7) Note: Apple Silicon (M1/M2) native is not supported, Apple Silicon with Rosetta is supported, learn more here.                    tk-vred      2020.3 - 2023      ",
    "url": "/cc3d2160/",
    "relUrl": "/cc3d2160/"
  },
  "190": {
    "id": "190",
    "title": "엔진",
    "content": "툴킷 엔진여기에서는 툴킷 플랫폼에 사용할 수 있는 엔진에 대한 참조 문서를 찾을 수 있습니다.",
    "url": "/3a69db47/",
    "relUrl": "/3a69db47/"
  },
  "191": {
    "id": "191",
    "title": "프레임워크",
    "content": "툴킷 프레임워크여기에서는 툴킷 플랫폼에 사용할 수 있는 프레임워크에 대한 참조 문서를 찾을 수 있습니다.",
    "url": "/c6db88dd/",
    "relUrl": "/c6db88dd/"
  },
  "192": {
    "id": "192",
    "title": "툴킷 개요",
    "content": "툴킷 개요Flow Production Tracking Toolkit의 다양한 개념에 대한 개요입니다.여기에서는 앱 및 엔진의 작동 방식, 툴킷의 시작 방법 및 현재 컨텍스트(작업 영역) 관리, 디스크에서 폴더를 만드는 방법 등의 주요 개념에 대해 자세히 설명합니다. 구성 또는 개발에 관련된 사람은 여기에서 시작하는 것이 좋습니다.이 문서에서는 툴킷 구성에 대한 제어 권한을 갖고 있는 경우에만 사용할 수 있는 기능에 대해 설명합니다. 자세한 내용은 Flow Production Tracking 통합 관리자 안내서를 참조하십시오.소개이 문서에서는 몇 가지 핵심 기능에 대해 자세히 설명합니다. 설명, 예제 및 간단한 데모를 통해 툴킷에 대한 모든 것을 보여 줍니다. 이 문서는 툴킷을 익히거나 툴킷을 통해 스튜디오의 가치를 높일 수 있는 방법을 알고 싶은 경우에 좋은 시작점입니다. 이 문서를 읽고 나면 주요 개념과 실제로 어떻게 작동하는지 이해할 수 있게 됩니다.아래는 툴킷(SGTK)에 대한 간단한 설명입니다.  툴킷은 Flow Production Tracking 플랫폼 기반의 Pipeline Toolkit 입니다. 이 툴킷을 사용하면 스튜디오용 도구를 쉽게 작성하고 설치할 수 있습니다.  툴킷은 파일 시스템을 기반으로 합니다. 디스크에서 항목의 저장 위치를 정리하여 디스크에 있는 항목을 깔끔하게 구성할 수 있습니다.  툴킷은 보조적인 역할을 합니다. 파이프라인에서 데이터를 인수하거나 추상화하지는 않지만, 아티스트에게 정보를 쉽게 찾고 오류를 방지할 수 있는 강력한 도구를 제공합니다.  툴킷을 통해 Flow Production Tracking에 모든 게시를 저장하여 작업을 공유할 수 있습니다. 툴킷을 사용하면 프로덕션 전반에 걸쳐 발생하는 업데이트 및 작업을 쉽게 공유할 수 있습니다.다음 섹션에서는 툴킷과 그 작동 방식을 자세히 살펴보겠습니다.프로젝트 및 구성툴킷에서는 모든 항목이 프로젝트 중심입니다. 일반적으로 프로젝트는 Flow Production Tracking 내부에서 수명 주기를 시작하고 입찰 및 사전 프로덕션 단계를 거쳐 컨텐츠 생성 단계에 대해 준비되면 툴킷을 해당 프로젝트에 맞게 설정할 수 있습니다.새 프로젝트를 설정할 때 템플릿 구성 을 사용합니다. 이는 엔진 및 앱, 파일 시스템 구성, 기타 설정이 포함된 사전 정의된 구성입니다. 툴킷으로 시작하는 경우 예제 구성을 탐색의 시작점으로 사용할 수 있습니다. 다른 프로젝트에서 툴킷을 사용하고 있는 경우, 해당 구성을 새 프로젝트의 시작점으로 사용하는 것이 좋습니다. 그렇게 하면 스튜디오 구성을 개선시켜 각각의 새로운 프로젝트에 맞게 조정할 수 있습니다. 물론 스튜디오 구성을 개별적으로 유지 관리하고 이를 모든 새 프로젝트의 템플릿으로 사용할 수도 있습니다.각 구성은 여러 저장 지점 을 정의합니다. 표준 샘플 구성인 tk-config-default의 경우 기본 이라는 단일 저장소 지점을 정의합니다. 즉, 모든 프로덕션 데이터가 단일 파일 시스템 프로젝트 루트 아래에 있음을 의미합니다. 두 개 이상의 파일 시스템 루트를 사용하여 구성을 설정할 수도 있습니다. 이를 다중 루트 구성 이라고 합니다. 다중 루트 구성이 필요한 경우를 예로 들면, 렌더링과 편집을 위해 별도의 저장소가 있어야 하는 경우 등이 있습니다. 이러한 저장 지점은 각각 Flow Production Tracking의 로컬 파일 저장소 여야 하며 사이트 기본 설정(Site Preferences)의 파일 관리 (File Management) 탭 아래에서 설정할 수 있습니다.툴킷은 원하는 위치에 실제 프로젝트 구성을 설치합니다. 일반적으로 프로젝트 데이터 영역 자체가 아니라 디스크의 소프트웨어 설치 영역으로 이동됩니다.스튜디오 구성 개선새 프로젝트를 설정할 때 기존 프로젝트를 기반으로 시작할 수 있습니다. 툴킷은 해당 프로젝트의 구성 폴더를 새 프로젝트로 복사합니다. 즉, 새 프로젝트는 기반이 되는 프로젝트와 동일한 버전의 앱과 엔진, 동일한 설정 및 동일한 커스터마이제이션을 가져옵니다. 이 기능은 파이프라인을 개선 시키고 기존 프로덕션의 개선 및 조정 사항을 활용하려는 경우 유용할 수 있습니다.또는 해당 프로젝트 설정에 만족하는 경우 프로젝트의 구성 폴더를 가져와서 중앙 위치에 저장할 수 있습니다. 그러면 이 구성을 스튜디오 템플릿으로 사용할 수 있으며 새 프로젝트를 만들 때마다 이 구성을 기반으로 설정할 수 있습니다. 원하는 경우, git 또는 이와 유사한 리비전 제어 시스템을 사용하여 이 스튜디오 템플릿 구성을 소스 제어할 수도 있으며, 파이프라인 구성 템플릿이 시간이 지남에 따라 어떻게 개선되는지를 간단하고 투명하게 트래킹할 수 있습니다. 업데이트할 때마다 프로젝트 중 하나에서 구성을 복사하고 변경 사항을 커밋합니다.구성 관리에 대한 자세한 정보는 다음 상세 문서를 확인하십시오.프로젝트 구성 관리각 프로젝트의 파이프라인 구성프로젝트에 대한 툴킷을 설정할 때마다 파이프라인 구성이 만들어집니다. 이 구성에는 프로젝트에 필요한 모든 설정과 파일이 포함됩니다. 구성에는 프로젝트를 직접 지정하려는 경우 셸에서 실행할 수 있는 전용 tank 명령이 있습니다(모든 프로젝트에서 작동하는 전역 tank 명령도 있음). Flow Production Tracking에서는 프로젝트 구성이 디스크에 상주하는 위치를 쉽게 트래킹할 수 있도록 파이프라인 구성이 특수 파이프라인 구성 엔티티로 등록되었습니다.프로젝트가 설정될 때 생성되는 마스터 구성 외에도 프로젝트에 대한 추가 구성을 만들 수 있습니다. 이 기능은 프로젝트의 다른 사람들에게 영향을 주지 않고 구성을 변경하려는 경우에 유용합니다. 이 작업을 수행하려면 Flow Production Tracking의 파이프라인 구성으로 이동하고 이를 마우스 오른쪽 버튼으로 클릭하여 복제하도록 선택할 수 있습니다. 이렇게 하면 다른 프로젝트를 기반으로 한 프로젝트의 새로운 파이프라인 구성이 만들어지며 새로운 구성을 사용하여 다른 사용자에게 영향을 주지 않고 새로운 앱을 안전하게 테스트할 수 있습니다.프로젝트의 기본 구성의 이름을 Primary로 지정해야 합니다. 이름을 바꾸거나 수정하거나 삭제하면 예상대로 작동하지 않을 수 있습니다. Flow Production Tracking에 저장된 파이프라인 구성은 수동이 아니라 다양한 tank 관리 명령을 통해 조작되도록 고안되었습니다.예제:구성을 복제하는 방법업데이트 확인다른 App Store와 마찬가지로, 툴킷 App Store는 앱과 엔진을 위한 새로운 버전을 지속적으로 제공합니다. 이러한 새 버전에는 중요한 버그 수정이나 흥미로운 새 기능이 포함될 수 있습니다. 앱과 엔진을 업그레이드하는 것은 전적으로 선택 사항입니다. 일반적으로 빠른 프로세스이며 업그레이드 스크립트는 변경하기 전에 항상 메시지를 표시합니다. 마찬가지로, 실수로 설치한 버전이 만족스럽지 않은 경우 간단히 롤백할 수 있습니다.단일 명령으로 업그레이드 프로세스를 처리합니다. 프로젝트 구성 폴더에 있는 tank 명령을 실행하고 updates 매개변수를 추가하기만 하면 됩니다./software/shotgun/bug_buck_bunny/tank updates매개변수 없이 이 명령을 실행하면 모든 환경, 엔진 및 앱이 검사되므로 이 작업에는 시간이 오래 걸릴 수 있지만 설치된 앱 및 엔진의 하위 세트에 대해 업데이트 프로그램을 실행할 수도 있습니다.일반 구문:tank updates [environment_name] [engine_name] [app_name]특수 키워드 ALL을 사용하여 한 범주의 모든 항목을 나타낼 수 있습니다.예:  모든 항목 검사: tank updates  샷 환경 검사: tank updates Shot  모든 환경의 모든 Maya 앱 검사: tank updates ALL tk-maya  샷 환경의 모든 Maya 앱 검사: tank updates Shot tk-maya  모든 위치에서 Loader 앱이 최신 버전인지 확인: tank updates ALL ALL tk-multi-loader  Maya에서 Loader 앱이 최신 버전인지 확인: tank updates ALL tk-maya tk-multi-loader이 스크립트는 App Store를 확인하는 것 외에도 등록된 다른 위치를 모두 확인하므로 앱을 배포한 위치에 따라 로컬 git, Github 리포지토리, 디스크의 파일 및 App Store를 쿼리할 수 있습니다.새 버전의 앱이 앱 구성을 변경할 수 있습니다. 예를 들어 새 기능에 새로운 구성 매개변수가 필요할 수 있습니다. 이 경우 tank 업그레이드 스크립트는 이러한 매개변수의 값을 입력하라는 메시지를 표시합니다.Core API에 대한 업데이트 확인Toolkit Core API의 새 버전이 릴리즈될 때가 있습니다. Core API를 업데이트하는 데는 별도의 명령이 사용됩니다. 이 경우 명령은 tank core입니다.디스크에 폴더 만들기프로젝트에 툴킷이 설정되면 이를 사용하여 일관된 폴더 구조를 만들 수 있습니다. 이 폴더 구조는 디스크에 있는 파이프라인 구성의 일부로 파일 시스템 템플릿을 작성하여 구성됩니다. 이 폴더 구조에서 일부 경로는 동적입니다. 예를 들어 Flow Production Tracking 에셋을 나타내는 asset이라는 폴더가 있을 수 있습니다. 이러한 동적 폴더는 Flow Production Tracking 쿼리 및 기타 여러 항목에 연결할 수 있습니다.툴킷은 다양한 설정과 시나리오를 처리하는 다양한 동적 폴더 유형을 제공합니다. 폴더 생성을 설정할 때 표준 Flow Production Tracking API 쿼리 구문을 사용할 수 있습니다. 따라서 파일 시스템을 구성하여 자산 유형이 다른 에셋이 파일 시스템의 다른 폴더에 저장되도록 할 수 있습니다.이러한 작업 방법에 대한 자세한 정보는 관리자 안내서를 참조하십시오.Flow Production Tracking Toolkit 관리툴킷 폴더 생성은 두 가지 패스로 진행됩니다. 즉, 언제든지 다른 사람이 실행할 수 있는 직접 패스와 일반적으로 응용프로그램 시작 직전에 아티스트가 실행하는 유예 패스입니다. 이 유예 패스는 완전히 자동으로 이루어지며 응용프로그램별 폴더 및 사용자 샌드박스를 설정하는 데 사용할 수 있습니다.현재 컨텍스트파일 시스템 구조가 만들어지면 툴킷은 디스크상의 폴더와 폴더를 가져온 Flow Production Tracking 객체 사이의 관계를 인식합니다. 이는 경로를 게시, 로드 또는 확인할 때 툴킷이 Flow Production Tracking의 객체를 폴더, 디스크 또는 파일과 쉽게 연관시킬 수 있기 때문에 중요합니다. 또한 컨텍스트 또는 현재 작업 영역 과도 연관됩니다. 컨텍스트 객체는 Toolkit Core의 일부이며 작업 중인 현재 항목을 트래킹합니다. 이는 툴킷이 파일 시스템 경로를 확인할 때의 중앙 메커니즘입니다.컨텍스트는 태스크, 에셋 또는 샷과 같은 Flow Production Tracking 객체 또는 디스크의 경로에서 만들 수 있습니다. 앱이 실행 중일 때 항상 컨텍스트에 액세스할 수 있으므로 파일 시스템 명명 규칙이나 앱이 에셋 또는 샷 파이프라인에서 사용되는지 여부를 몰라도 앱을 쉽게 만들 수 있습니다. 이러한 사항은 모두 Toolkit Core API와 컨텍스트에 의해 처리됩니다.파일 시스템 템플릿Toolkit Core에는 파일 경로를 처리하는 시스템이 있습니다. 이를 템플릿 시스템 이라고 합니다. 툴킷은 파일 시스템 기반이므로, 앱에서 디스크의 데이터를 읽거나 쓸 필요가 있을 때마다 파일 경로를 확인해야 합니다. 앱은 파일 시스템 구조로부터 독립적입니다. 즉, 파일 시스템이 어떻게 구성되어 있는지 모릅니다. 이러한 사항은 템플릿 시스템에서 처리합니다.템플릿 시스템의 핵심에는 템플릿 구성 파일 이 있습니다. 이 파일에는 프로젝트의 중요한 파일 시스템 위치가 모두 들어 있습니다. 템플릿 의 모양은 다음과 같습니다.maya_shot_publish: 'shots/{Shot}/{Step}/pub/{name}.v{version}.ma'특정 동적 필드를 포함하는 경로를 정의합니다. 각 필드는 유효성 확인 및 입력을 통해 구성될 수 있습니다. 예를 들어 위 템플릿의 {version} 필드를 3개의 0으로 채워진 정수(예: 001, 012, 132)로 정의할 수 있습니다. 앱이 디스크에서 쓰거나 읽을 필요가 있을 때마다 해당 위치를 설명하기 위해 템플릿 파일에 템플릿이 추가됩니다. 앱은 종종 파이프라인을 형성하도록 설정되기 때문에 한 앱(예: 게시 앱)의 출력 템플릿은 종종 다른 앱(예: 로딩 앱)의 입력 템플릿이 됩니다. 이것이 모든 파일 시스템 위치가 단일 파일에 보관되는 이유입니다.템플릿 API를 사용하면 경로와 필드 값 목록 사이를 이동할 수 있습니다.# get a template object from the API&amp;gt;&amp;gt;&amp;gt; template_obj = sgtk.templates[&quot;maya_shot_publish&quot;]&amp;lt;SGTK Template maya_asset_project: shots/{Shot}/{Step}/pub/{name}.v{version}.ma&amp;gt;# we can use the template object to turn a path into a set of fields...&amp;gt;&amp;gt;&amp;gt; path = '/projects/bbb/shots/001_002/comp/pub/main_scene.v003.ma'&amp;gt;&amp;gt;&amp;gt; fields = template_obj.get_fields(path){'Shot': '001_002', 'Step': 'comp', 'name': 'main_scene', 'version': 3}# alternatively, we can take a fields dictionary and make a path&amp;gt;&amp;gt;&amp;gt; template_obj.apply_fields(fields)'/projects/bbb/shots/001_002/comp/pub/main_scene.v003.ma'위의 경로와 템플릿에는 두 가지 유형의 필드가 있음에 유의하십시오. Shot 및 Step 필드는 Flow Production Tracking에서 동일한 오브젝트(샷 및 파이프라인 단계)를 가진 상위 수준 필드이며 여기서 name 및 version 필드는 이 특정 유형의 템플릿에 대해 매우 구체적입니다. 샷이 아닌 에셋의 게시 경로를 설명하려면 name과 version 필드가 있어야 합니다. 이는 데이터 유형에 상관없이 모든 게시에 필요하기 때문입니다. 그러나 Shot 및 Step 필드는 없습니다. 대신 Asset과 Step 필드가 있을 수 있습니다. Asset 필드는 Flow Production Tracking의 에셋과 연결됩니다.게시를 수행하는 앱을 개발하는 경우 샷 게시 앱과 에셋 게시 앱을 별도로 개발하는 것보다 단일 게시 앱에서 시퀀스, 샷, 에셋 중 무엇인지와 상관없이 모든 항목에 대한 게시 시나리오를 처리하는 것이 좋습니다.이를 위해 툴킷 컨텍스트 가 개입됩니다. 툴킷 컨텍스트를 사용하면 템플릿 필드를 두 개의 개별 그룹으로 나눌 수 있습니다. 컨텍스트 필드(Shot, Step, Asset 등)는 앱 로직이 샷 및 에셋과 같은 개념을 특별히 처리하는 코드를 가질 필요가 없도록 앱 밖에서 확인되는 필드입니다. 대신 앱은 앱의 특정 비즈니스 로직 과 직접 연관된 필드에 정보를 입력해야 합니다. Publish 앱의 이 예에서는 비즈니스 로직이 name 및 version 필드로 구성됩니다. 위의 그림에서 알 수 있듯이 툴킷은 필드 확인을 두 개의 진행단계로 나눕니다. 일부 필드는 컨텍스트에 의해 입력되고 일부 필드는 앱 내부의 비즈니스 로직에 의해 입력됩니다. 이렇게 하면 특정 파일 시스템 레이아웃에 연결되지 않은 앱을 설계할 수 있습니다. 이는 좋은 파이프라인 도구를 만드는 중요한 요소입니다.경로 확인을 처리하는 앱 코드는 일반적으로 다음과 같습니다.# start with an empty fields dictionaryfields = {}# first let the context populate all its fieldsfields.update( self.context.as_template_fields( publish_template_obj ) )# fields is now {'Shot': '001_002', 'Step': 'comp' }# now the app can add its business logicfields[&quot;name&quot;] = &quot;main_scene&quot;fields[&quot;version&quot;] = 234# and finally the app can produce the path it needs in# order to save out the filepath = publish_template_obj.apply_fields(fields)템플릿 API를 구성하고 사용하는 방법에 대한 자세한 정보는 다음을 참조하십시오.파일 시스템 구성 참조Core API 참조실행할 엔진 및 앱 선택Toolkit Core의 또 다른 중요한 역할은 사용자에게 어떤 앱을 제공할지 결정하는 것입니다. 캐릭터 리깅 작업을 하고 Maya를 시작하는 경우 한 샷에 집중할 때보다 다른 앱 컬렉션을 원할 것입니다. 또한 앱 작동 방법에 따라 앱을 다르게 구성할 수 있습니다. 즉, 리깅을 위한 리뷰 앱은 턴테이블을 생성하고 동일한 리뷰 앱을 애니메이터가 실행할 경우 해당 앱이 샷 카메라를 사용하여 playblast를 만들 수 있습니다.이러한 유연성을 고려하여 툴킷 프로젝트 구성에는 여러 환경 컬렉션이 포함되어 있습니다. 환경은 앱 및 엔진 컬렉션과 모든 구성 매개변수를 정의하는 구성 파일입니다.툴킷이 시작되면 어떤 환경을 초기화할지 결정해야 합니다. 이 과정은 고유한 비즈니스 로직을 추가할 수 있는 Python 코드 조각, 즉 후크 를 통해 수행됩니다. 컨텍스트 객체가 이 코드 조각으로 전달되며 이는 종종 사용할 환경을 결정하는 데 사용됩니다.이렇게 하면 파이프라인의 다른 부분에 대해 별도의 앱 컬렉션을 구성할 수 있습니다. 또한 이들을 독립적으로 업데이트할 수 있으며 각기 다른 감독이 별도로 관리할 수도 있습니다.기본 구성의 환경환경의 작동 방법과 구조에 대한 실질적 예제를 제공하기 위해 기본 구성과 함께 제공되는 환경을 살펴보겠습니다.  project.yml - 컨텍스트에 프로젝트만 포함된 경우 실행할 앱 및 엔진  shot_and_asset.yml - 컨텍스트에 샷 또는 에셋이 포함된 경우 실행할 앱 및 엔진  shot_step.yml - 컨텍스트에 샷 및 파이프라인 단계가 포함된 경우 실행할 앱 및 엔진  asset_step.yml - 컨텍스트에 에셋 및 파이프라인 단계가 포함된 경우 실행할 앱 및 엔진기본 구성은 파이프라인 단계를 기반으로 해당 파일 시스템을 구성했습니다. 즉, 샷 위치에서 Modeling, Rigging 등의 폴더를 찾을 수 있습니다. 기본적으로 작업 중인 각 파이프라인 단계마다 하나의 폴더가 있습니다. 디스크의 이러한 각 폴더에는 자체 작업 및 게시 영역이 있습니다. 게시 템플릿은 다음과 같이 표시될 수 있습니다.maya_shot_publish: 'sequences/{Sequence}/{Shot}/{Step}/pub/{name}.v{version}.ma'이 템플릿을 사용하려면 컨텍스트에 엔티티와 파이프라인 단계가 모두 포함되어야 합니다. 시퀀스 ABC의 하위인 샷 1122와 파이프라인 단계 Modeling의 경우 위의 템플릿은 sequences/ABC/1122/Modeling/...로 해석됩니다. 즉, 샷은 있지만 파이프라인 단계는 포함하지 않은 컨텍스트는 위의 템플릿을 채우기에 충분하지 않습니다. 샷만 있는 컨텍스트에서 위의 템플릿을 사용하여 Maya를 시작할 수는 없습니다. 작동시키기 위해서는 단계를 수행해야 합니다.그 결과 위와 같이 환경이 분할됩니다. 기본 구성에 정의된 파일 시스템 구조는 단계를 중심으로 하므로 모든 기본 앱은 단계가 정의된 컨텍스트에서 실행해야 합니다. 이러한 두 환경은 기본 구성인 asset_step.yml 파일과 shot_step.yml 파일에서 정의합니다. 이러한 각 파일에는 Maya, Nuke, 3dsmax, Motionbuilder, Photoshop 등 여러 DCC 엔진이 포함되어 있습니다. Flow Production Tracking 내부의 태스크에서 Maya를 시작하면 환경 선택 후크는 shot_step 환경을 선택하고 Maya를 시작한 다음 Maya 앱 구성을 로드합니다.Flow Production Tracking 내부의 샷 객체에서 직접 Maya를 시작하는 것도 유용할 수 있습니다. 특히 콘솔 tank Shot 1122 launch_maya에 입력할 수 있는 것이 매우 유용합니다. 여기에서 shot 및 asset 환경이 개입됩니다. 샷 또는 에셋은 있지만 파이프라인 단계가 없는 컨텍스트로 Maya를 로드하면 이러한 환경 중 하나가 로드됩니다. 파일 시스템 구조는 모두 파이프라인 단계별로 구성되기 때문에 컨텍스트에 해당 정보가 누락된 경우 로드 또는 게시를 수행할 수 없습니다. Maya는 대신 Workfiles 앱만 포함하는 기본 구성으로 시작됩니다. 이 앱을 사용하면 작업할 태스크를 선택할 수 있습니다. 일단 태스크를 선택하면 툴킷이 컨텍스트를 전환하고 엔진을 다시 시작하며 모든 범위의 앱으로 shot_step 환경을 로드합니다.마찬가지로, project 환경은 다목적 폴백이며 Workfiles 앱만 포함합니다. 이렇게 하면 프로젝트 내부의 거의 모든 곳에서 Maya를 시작할 수 있으며 툴킷이 최소 상태로 초기화되므로 Workfiles 앱을 사용하여 유효한 작업 영역으로 바로 이동할 수 있습니다.앱 구성각 앱에는 지정해야 하는 여러 구성 매개변수가 있습니다. 앱을 설치하거나 업그레이드할 때 툴킷은 필요한 모든 설정을 지정했는지 확인합니다.문자열 또는 정수 등의 간단한 설정 값은 환경 구성에서 직접 지정됩니다. 템플릿은 서로 다르고 툴킷에서는 모든 템플릿을 한 곳에 보관하려고 하므로 환경 파일은 템플릿 파일에 정의된 템플릿을 가리키기만 하면 됩니다. 각 앱은 해당 구성에서 사용하는 템플릿에 각기 다른 필드가 있어야 합니다. 앞의 예제의 Publish 앱에서는 디스크에 출력 파일을 만들 때 name 및 version 필드가 있는 템플릿을 사용했습니다. 따라서 이 앱에는 name 및 version 필드가 포함된 템플릿을 요구하는 구성 설정이 필요합니다.컨텍스트 필드(name 및 version) 외의 필드가 있는 템플릿을 사용하여 앱을 구성하려는 경우 앱이 이러한 추가 필드를 채우는 방법을 모르기 때문에 해당 템플릿에서 경로를 생성할 수 없습니다. 마찬가지로, 필드 중 하나가 누락된 템플릿을 제공한 경우 혼란스러운 결과가 발생할 수 있습니다. 이 경우 앱에서 버전 번호가 작성되지 않습니다. 따라서 툴킷은 시작할 때 구성을 확인하여 모든 템플릿에 필요한 필드가 제공되었는지 확인합니다. 또한 툴킷은 기본값과 선택적 필드를 사용하는 몇 가지 방법을 지원합니다.전체 참조를 보려면 다음 링크를 확인하십시오.앱 및 엔진 구성 참조파일 시스템 구성 참조후크툴킷은 템플릿을 사용하는 앱 설정 외에도 후크 라는 개념을 지원합니다. 후크는 Python 코드의 작은 조각이므로 구성의 일부로 앱 일부를 커스터마이즈할 수 있습니다.다음은 작동 방식과 유용성에 대한 설명입니다.앱은 여러 엔진과 프로젝트에서 재사용할 수 있기 때문에 강력합니다. 그러나 앱에 작은 조각의 일부 엔진별 로직이 필요할 수 있습니다. 예를 들어 Nuke와 Maya에서 모두 작동하는 Loader 앱을 빌드하는 경우 실제 파일 로드 를 처리하는 코드가 있어야 합니다. 이 코드는 Nuke 및 Maya에서 달라야 합니다. 모든 엔진과 함께 이 앱을 사용할 수 있다면 더욱 좋을 것입니다. 또한 스튜디오마다 씬에 항목을 로드하는 방법이 다를 수 있습니다. 어떤 스튜디오에서는 커스텀 Maya 참조 노드를 지원해야 하고 어떤 스튜디오에서는 가져오기만 수행할 수도 있습니다.이 상황은 툴킷에서 후크 를 사용하여 처리됩니다. 후크는 커스터마이즈 가능한 코드 조각입니다. 앱은 기본 레벨의 구현을 포함하는 기본 후크와 함께 제공됩니다. 즉, 앱은 즉시 사용이 가능합니다. 그러나 동작을 커스터마이즈하려는 경우 해당 후크 파일을 구성에 복사하면 툴킷이 해당 코드를 대신 사용합니다.관리자 안내서에서 후크 작업 방법에 대해 읽기.Flow Production Tracking 및 셸에서 실행툴킷이 설치되면 몇 가지 기본 진입점에서 액세스할 수 있습니다.  Flow Production Tracking 액션은 Flow Production Tracking의 마우스 오른쪽 버튼 클릭 메뉴에 나타납니다.  시작 아이콘은 Flow Production Tracking 데스크톱 앱의 프로젝트에 대해 나타납니다.  콘솔에서 tank 명령을 사용할 수 있습니다.  툴킷 Python API는 응용프로그램과 셸 모두에서 사용할 수 있습니다.Flow Production Tracking 내에서 툴킷을 실행하는 것은 응용프로그램을 시작하고 태스크를 수행하는 일반적인 방법입니다. Flow Production Tracking는 Flow Production Tracking 데스크톱을 사용하여 컴퓨터에 로컬인 툴킷 설치와 통신하고 로컬 Python을 사용하여 툴킷 명령을 실행합니다. 즉, Flow Production Tracking 내부에서 바로 폴더 생성과 같은 로컬 작업을 실행할 수 있습니다.셸에서 툴킷에 액세스할 수도 있습니다. 각 프로젝트 구성은 자체 tank 명령과 함께 제공됩니다. 프로젝트 구성 루트로 이동하여 ./tank 명령을 실행하기만 하면 됩니다.마지막으로 PYTHONPATH 환경 변수에 툴킷 API를 추가하고 가져올 수 있습니다. API 사용은 간단합니다. 예를 들어 Maya 내부에서 툴킷을 수동으로 시작하거나, Flow Production Tracking 데스크톱을 사용하지 않고 기존 스튜디오 시작 시스템의 일부로 시작하려면 몇 가지 간단한 명령을 실행하기만 하면 됩니다.게시다른 사람들과 작업 중인 파일을 공유하려면 해당 파일을 게시하면 됩니다. 이는 다른 사용자가 툴킷의 Loader 앱을 사용하여 가져올 수 있는 PublishedFile 엔티티가 Flow Production Tracking에서 생성된다는 의미입니다.데이터 관리 측면에서 이러한 의미에 대한 자세한 내용(디스크 항목이 저장된 위치, 파일에 포함된 내용 등)은 실제 작업을 수행하는 앱에 따라 달라집니다. 툴킷 API는 개발자가 Flow Production Tracking 내부에 쉽게 게시를 생성하고 이러한 게시를 올바른 객체에 링크할 수 있도록 함으로써 Flow Production Tracking이 모든 올바른 작업자에게 알림을 전달할 수 있도록 합니다. 다용도로 구성할 수 있는 기본 Publish 앱도 제공하지만 이 앱이 툴킷을 사용하여 버전 제어를 구현하는 유일한 방법은 아닙니다. 툴킷은 확장 가능하므로 원하는 경우 툴킷을 사용하여 자체 커스텀 버전 제어 및 게시 시스템을 빌드할 수 있습니다.그러나 시작점으로 아래 Publish 앱을 권장합니다.기본 다중 Publish 앱.재사용 가능한 앱 빌드툴킷은 단순히 앱 및 엔진의 컬렉션이 아닙니다. 자체 도구 및 기술을 개발하는 데 사용할 수 있는 프레임워크이기도 합니다. 툴킷에는 유용한 스튜디오 개발 플랫폼으로 사용할 수 있도록 많은 기능이 포함되었습니다. 스스로 기본 파이프라인을 빌드하는 대신 툴킷을 기반으로 당면한 문제에 집중할 수 있습니다. 개발자는 아티스트의 파이프라인에 영향을 주지 않고 소프트웨어를 빌드, 평가 및 릴리즈할 수 있습니다.  엔진을 사용하면 기본 기반에 관계없이 Python 및 Qt(PySide/PySide2)로 앱을 작성할 수 있습니다. 이는 일부 엔진은 매우 간단하지만 일부 엔진은 제공된 API에 따라 더 복잡하다는 의미입니다. 즉, 간단하고 일관된 방법으로 스튜디오용 도구를 개발할 수 있습니다. 경험에 따르면 Python과 Qt는 개발 환경 스튜디오에서 사용되는 경우가 많으며 많은 TD가 이에 익숙합니다.  엔진 레이어는 또한 앱을 한 번 작성한 다음 여러 환경에 배포할 수 있음을 의미합니다. 당사는 표준 앱 제품군을 다중 앱 으로 개발했습니다. 이는 동일한 앱이 모든 엔진에서 사용된다는 것을 의미합니다. 특정 코드는 반드시 각 DCC 응용프로그램이 노출하는 특정 API로 작업하도록 작성되어야 하지만 일반적으로 하나 이상의 후크에 포함되어 있기 때문에 앱을 쉽게 재활용할 수 있습니다. 이와 같은 다중 앱을 만들 수 있기 때문에 생기는 또 다른 결과는 새로운 엔진이 개발될 때 모든 표준 앱이 새로운 엔진과 작동하도록 쉽게 구성할 수 있다는 것입니다.  파이프라인 구성 및 복제를 통해 개발 샌드박스를 쉽게 만들 수 있기 때문에 개발자는 일상적인 프로덕션 액티비티를 방해하지 않고 프로덕션에서 작업을 수행할 수 있습니다. 도구를 배포할 준비가 되면 기본 프로젝트 구성을 쉽게 업데이트하고 도구를 모든 아티스트에게 롤아웃할 수 있습니다.  앱은 엔진 내부에서 실행되므로 쉽게 다시 로드할 수 있습니다. 새 코드 변경을 테스트할 때마다 Nuke 또는 Maya를 다시 시작하지 않고 툴킷에서 다시 로드 버튼을 누르기만 하면 최신 코드가 로드됩니다.앱 개발에 대한 더 자세한 소개는 다음 문서를 참조하십시오.툴킷 앱 개발 소개.툴킷 API 참조앱 및 엔진 구성 참조",
    "url": "/e95205a8/",
    "relUrl": "/e95205a8/"
  },
  "193": {
    "id": "193",
    "title": "파이프라인 통합",
    "content": "파이프라인 통합ShotGrid에는 아티스트들이 일상적으로 사용하는 크리에이티브 도구에 Flow Production Tracking 환경을 가져올 수 있는 통합이 포함됩니다. 기본 게시 파이프라인의 토대를 제공하는 아티스트 도구 내에서 기본적으로 제공되는 플러그인을 사용할 수 있습니다.이러한 통합은 스튜디오에 커스텀 워크플로우를 빌드할 수 있는 도구를 제공하는 구성, 툴킷 플랫폼, 일련의 API, UI를 기반으로 구축됩니다.",
    "url": "/3d1cd26d/",
    "relUrl": "/3d1cd26d/"
  },
  "194": {
    "id": "194",
    "title": "Web Traffic Isolation",
    "content": "Web Traffic IsolationThe goal is to set up an AWS PrivateLink to privately access your Flow Production Tracking site.Set up PrivateLink to Flow Production Tracking      Ask Flow Production Tracking support to provide you with the Flow Production Tracking PrivateLink service name for your AWS region.        Update the private VPC CloudFormation stack you created earlier and set Flow Production TrackingPrivateServiceName parameter.  Manual steps if needed      Add a new VPC Endpoint in your VPC        For the security group, Flow Production Tracking service only requires the inbound port tcp/443 to be open.  DNS ConfigurationProvide your PrivateLink DNS name to Flow Production Tracking support. We will setup a new private URL for your site that will look like mystudio-staging.priv.shotgunstudio.com.ValidationVerify that your site private URL resolves to IPs in your AWS VPC block.nslookup mystudio-staging.priv.shotgunstudio.comTry to access your test site from inside your office ie https://mystudio-staging.priv.shotgunstudio.comNext StepsSee Fine Tuning to finalize your setup and optimize costs and security.Go to Setup for an overview of the possible next steps.",
    "url": "/d9ef03ce/",
    "relUrl": "/d9ef03ce/"
  },
  "195": {
    "id": "195",
    "title": "문제 해결 가이드",
    "content": "문제 해결 가이드문제 해결을 위한 빠른 답변 모음입니다.일반적인 문제 해결 도움말  성능 문제 해결  디버그 로깅을 어떻게 켭니까?  원격 디버깅  로그 파일은 어디에 있습니까?  툴킷 로그는 어떻게 작동하며 확인해야 할 사항을 어떻게 알 수 있습니까?  내 구성은 어디에 있습니까?  메뉴, Flow Production Tracking 데스크톱 또는 AMI에서 로드되지 않거나 누락되는 툴킷 앱을 디버그하는 방법  내 컨텍스트에 태스크/단계가 누락되어 있는데 파일 이름의 일부로 존재하는 이유는 무엇입니까?  폴더의 등록을 해제하는 이유와 방법은 무엇입니까?  폴더의 등록을 해제하는 대신 사이트에서 FilesystemLocations를 삭제할 수 있습니까?  분산 구성을 사용할 때 폴더의 등록을 취소하려면 어떻게 해야 합니까?오류 메시지 지침  오류: ‘tank’ 모듈에 ‘support_url’ 특성이 없음  ASCII 코덱이 위치 10의 바이트 0x97을 디코딩할 수 없음: 서수가 범위에 없음  구성이 디스크의 유효한 번들을 가리키지 않습니다!  “MTsetToggleMenuItem” 프로시저를 찾을 수 없음  경로에 대한 행 ID를 확인할 수 없습니다!  data_handler_cache 오류 메시지: 오류 sgtk.env.project.tk-nuke.tk-multi-workfiles2 파일 열기(File Open) 대화상자를 만들지 못했습니다!  데이터베이스 동시성 문제: &amp;lt;PATH&amp;gt; 경로가 Flow Production Tracking 엔티티 &amp;lt;ENTITY&amp;gt;와 이미 연결되어 있습니다.  오류: App Store에 my-app이라는 항목이 포함되어 있지 않음  [오류] 암호화 핸드쉐이크를 완료하지 않고 통신을 시도함  오류 잘못된 LUT 선택: Gamma2.2  [오류] [프록시] __commands::unreal_engine을 호출하는 동안 오류가 발생함  [publish_creation 오류] &amp;lt;urlopen 오류 [SSL: CERTIFICATE_VERIFY_FAILED] 인증서 확인 실패(_ssl.c:726)&amp;gt;  오류: Flow Production Tracking tk-maya: 툴킷에서 예외가 발생했습니다.  오류 18:13:28.365:Hiero(34236): 오류! 태스크 유형  예외: 리뷰 제출에 실패했습니다. 리뷰 관련 시퀀스를 렌더링하고 제출할 수 없습니다.  너무 긴 Windows 경로(256자 초과)로 인한 오류  작업 영역 변경 실패 - MEL 스크립트를 실행하는 동안 오류 발생  폴더 작성 실패: 폴더를 작성하지 못함  프레임 서버에 오류가 발생했습니다.  ModuleNotFoundError  Maya에서 context.task를 출력하면 비어 있음(“None”)  Python API에서 SSL: CERTIFICATE_VERIFY_FAILED 문제 수정  로컬 Flow Production Tracking 사이트에서 Flow Production Tracking 데스크톱을 사용할 때 CERTIFICATE_VERIFY_FAILED 오류 발생  SSLError: [Errno 8] _ssl.c:504: 프로토콜을 위반하여 EOF 발생  [SSL: CERTIFICATE_VERIFY_FAILED] 인증서 확인 실패: 로컬 발급자 인증서를 가져올 수 없음  TankInitError: 파이프라인 구성에서 툴킷 플랫폼을 로드하는 중입니다.  TankError: 컨텍스트에 대한 템플릿 데이터를 확인할 수 없습니다.  TankError: 템플릿에서 경로를 확인하려고 시도했습니다.  Tk-desktop 콘솔에서 자동으로 오류 무시  SSLHandshakeError: [SSL: CERTIFICATE_VERIFY_FAILED] 인증서 확인 실패(_ssl.c:727)  TankError: 디스크에 폴더를 만들 수 없습니다. 오류 보고: 중요! 폴더 데이터로 Flow Production Tracking를 업데이트할 수 없습니다.  [경고] 기본 루트 저장소를 SG 로컬 저장소에 매핑할 수 없습니다.소프트웨어 통합  프로젝트 간에 파이프라인 구성을 공유/업데이트하는 권장 방법  집에서 작업하는 사용자를 위해 파이프라인 구성을 배포하려면 어떻게 해야 합니까?  일부 사용자를 위해 중앙 집중식 구성을 분산 구성으로 전환하려면 어떻게 해야 합니까?  Windows에서 Qt ui 및 리소스 파일을 컴파일하는 방법  Flow Production Tracking UI에서 툴킷 컨텍스트 메뉴 항목을 추가하려면 어떻게 해야 합니까?  Houdini Flow Production Tracking 통합이 시작되지 않는 이유는 무엇일까요?  Flow Production Tracking 데스크톱에서 Nuke/Maya 등을 시작했지만 Flow Production Tracking 메뉴에 항목이 없습니다.  NUKE_PATH 환경 변수를 설정하면 Nuke 통합이 시작되지 않는 이유가 무엇입니까?  두 개의 익스텐션이 설치된 경우 Photoshop 통합 문제 해결  Flow Production Tracking 툴킷 사용 시 3ds Max를 시작하면 충돌 오류가 발생하는 이유는 무엇입니까?  기본 소프트웨어 버전을 설정하려면 어떻게 해야 합니까?  Loader 앱에 Alembic 게시가 표시되지 않는 이유는 무엇입니까?  툴킷 부트스트랩이 있을 때 올바른 PipelineConfiguration 엔티티를 결정하는 데 사용되는 순서는 무엇입니까?  Photoshop에서 두 개의 서로 다른 SG 패널을 사용하는 이유는 무엇입니까?  Photoshop 통합 패널이 로드되는 동안 중단됩니다. “문제가 발생했습니다.”  데스크톱에 소프트웨어 엔티티가 누락되었습니다. 이 문제를 해결하려면 어떻게 해야 합니까?  Tank.template_from_path()가 여러 템플릿을 반환할 수 없습니다.  아티스트를 위한 작업 파일로 일련의 샷(전체 시퀀스)을 프로시쥬얼 방식으로 채우는 방법은 무엇입니까?  사용자가 tk-maya를 시작할 때 userSetup.py를 어떻게 제어할 수 있습니까?  개발 구성을 위한 Tank 명령  아티스트가 기존 작업 파일을 여는 것이 아니라 기존 게시를 여는 경우에만 액션을 취하려고 합니다. 후크를 사용하여 이 작업을 수행하려면 어떻게 해야 합니까?  폴더 작성 중에 엔티티 이름의 공백을 하이픈이 아닌 밑줄로 변환하려면 어떻게 해야 합니까?브라우저 통합  Chrome에서 로컬 파일 링크를 사용할 수 없으며, 툴킷 응용프로그램도 실행할 수 없습니다  Firefox에서 로컬 파일 링크를 사용할 수 없으며, 툴킷 응용프로그램도 실행할 수 없습니다.  Flow Production Tracking 데스크톱/브라우저 통합을 Linux에서 실행할 수 없습니다.답변을 찾을 수 없습니까?추가 문제 해결을 위해 커뮤니티를 검색하여 답변을 얻을 수 있습니다.",
    "url": "/7ef5be1d/",
    "relUrl": "/7ef5be1d/"
  },
  "196": {
    "id": "196",
    "title": "Fine Tuning",
    "content": "Fine TuningCost Management RecommendationsS3 Infrequent AccessWe recommend enabling S3 Infrequent Access to easily reduce costs without impacting performance. For the Flow Production Tracking Cloud hosted offering, we apply a policy for all objects older than one month.With Infrequent Access, objects are stored at a lower cost. However, if they are accessed, it will involve an additional cost. Flow Production Tracking has observed that one month was the right policy to use globally, but you may want to adapt that policy to your studio workflows as needed.Read more about S3 Infrequent Access and other storage classes here.S3 Bucket policyWe recommend you restrict access to your S3 bucket to only your VPC and Flow Production Tracking transcoding services IPs. There is an example policy, replace your_vpc_id and your_s3_bucket by your values.We strongly recommend you test media access and media transcoding in your site right after applying the bucket policy changes to be sure your S3 bucket is still accessible from your VPC and from Flow Production Tracking transcoders.{    &quot;Version&quot;: &quot;2012-10-17&quot;,    &quot;Id&quot;: &quot;Policy1415115909152&quot;,    &quot;Statement&quot;: [        {            &quot;Sid&quot;: &quot;AllowSSLRequestsOnly&quot;,            &quot;Effect&quot;: &quot;Deny&quot;,            &quot;Principal&quot;: &quot;*&quot;,            &quot;Action&quot;: &quot;s3:*&quot;,            &quot;Resource&quot;: [                &quot;arn:aws:s3:::your_s3_bucket&quot;,                &quot;arn:aws:s3:::your_s3_bucket/*&quot;            ],            &quot;Condition&quot;: {                &quot;Bool&quot;: {                    &quot;aws:SecureTransport&quot;: &quot;false&quot;                }            }        },        {            &quot;Sid&quot;: &quot;Access-to-specific-VPC-only and Shotgun transcoder&quot;,            &quot;Effect&quot;: &quot;Deny&quot;,            &quot;Principal&quot;: &quot;*&quot;,            &quot;Action&quot;: &quot;s3:GetObject*&quot;,            &quot;Resource&quot;: &quot;arn:aws:s3:::your_s3_bucket/shotgun/*&quot;,            &quot;Condition&quot;: {                &quot;NotIpAddress&quot;: {                    &quot;aws:SourceIp&quot;: [                        &quot;34.200.155.69/32&quot;,                        &quot;34.224.232.103/32&quot;,                        &quot;34.202.127.170/32&quot;                    ]                },                &quot;StringNotEquals&quot;: {                    &quot;aws:sourceVpc&quot;: [                        &quot;vpc-2fd62a56&quot;,                        &quot;your_vpc_id&quot;                    ]                }            }        }    ]}S3 endpoint policyWe recommend setting a VPC endpoint policy on your S3 endpoint to allow access to your S3 bucket only. See here for an example.Application Load Balancer  We recommend you enable deletion protection on the S3 proxy load balancer to prevent accidental deletion.  We recommend you enable access logging on the S3 proxy load balancer to aid in traffic analysis and identification of security issues.Next StepsSee Activation to migrate your production site to use the isolation features.Go to Setup for an overview of the possible next steps.",
    "url": "/26190270/",
    "relUrl": "/26190270/"
  },
  "197": {
    "id": "197",
    "title": "디버그 로깅을 어떻게 켭니까?",
    "content": "디버그 로깅을 어떻게 켭니까?기본적으로 툴킷 도구 출력보다 많은 로깅 데이터를 보고 싶을 때가 있습니다. 디버그 로깅을 활성화하면 자세한 로그 출력을 얻을 수 있으며 이를 수행하는 몇 가지 방법이 있습니다.                    참고: 로그 파일을 어디서 찾아야 할지 모르십니까? 로그 파일은 어디에 있습니까? 문서를 참조하십시오.    Flow Production Tracking 데스크톱을 통해 디버깅 활성화디버깅을 활성화하는 가장 쉬운 방법은 Flow Production Tracking 데스크톱 앱을 통해 켜는 것입니다. Flow Production Tracking 데스크톱에 로그인하고 나면 설정할 수 있습니다. 앱 오른쪽 아래에 있는 프로파일 사진을 클릭하고 고급(Advanced) -&amp;gt; 디버그 로깅 토글(Toggle Debug Logging)을 선택합니다. 이 설정은 세션 간에 영속적이기 때문에 작업을 마치면 끄는 것을 잊지 마십시오.이 기능을 켜면 Flow Production Tracking 데스크톱에서 실행한 앱 또는 브라우저 통합을 통한 툴킷 명령도 이 디버그 상태를 상속한다는 점에도 유의하십시오.환경 변수 설정디버그 로깅 영구적으로 켜기먼저 새 환경 변수 TK_DEBUG=1을 설정해야 합니다.                    참고: 플랫폼에 따라 지침이 다르므로 스튜디오의 기술 전문가와 환경 변수를 설정하는 방법을 논의하는 것이 좋습니다. 어쨌든 아래 예에는 Windows 7 컴퓨터에서 환경 변수를 설정하는 방법이 나와 있습니다.    Windows 7 사용 예시  Windows 아이콘 &amp;gt; 제어판 &amp;gt; 시스템 &amp;gt; 고급 시스템 설정 &amp;gt; 환경 변수… &amp;gt; 새로 만들기…로 이동하여 디버그 로깅을 영구적으로 켤 수 있습니다.  변수 이름: TK_DEBUG  변수 값: 1  확인을 선택합니다.이제 환경 변수가 올바로 설정되고, 디버그 로깅이 켜졌습니다.                    참고: 로깅이 진행되도록 하려면 데스크톱을 다시 시작하십시오.    디버그 로깅을 끄고 싶으면 다음을 수행합니다.a. TK_DEBUG 환경 변수 값을 0으로 설정합니다.b. TK_DEBUG 환경 변수를 삭제합니다.이 환경 변수가 이미 설정되어 있는지 확인이 환경 변수가 이미 설정되어 있는지 확인하려면 터미널을 열고 set 명령을 실행합니다.그런 다음, TK_DEBUG=1을 검색합니다.그러면 데스크톱을 실행하고 나면 디버그 로깅이 켜집니다.디버그 로깅 일시적으로 켜기대신 세션 동안에만 일시적으로 디버그 로깅을 사용하고 싶다면 터미널을 열고 set TK_DEBUG=1 명령을 통해 디버그 로깅을 설정하면 됩니다.그런 다음, 터미널을 통해 데스크톱을 실행합니다.                    참고: Flow Production Tracking 데스크톱과 터미널을 닫으면 디버그 로깅이 더 이상 켜진 상태로 유지되지 않습니다.    고급 구성 디버그 로깅 옵션고급 설정을 사용 중인 경우 몇 가지 옵션을 더 사용할 수 있습니다. 이 기능은 툴킷 구성에 대한 제어 권한이 있는 경우에만 사용할 수 있습니다.모든 엔진은 환경 파일에 debug_logging 설정이 있습니다. 이 설정을 켜면 추가 디버그 레벨 로그 메시지가 소프트웨어(예: Nuke 또는 Maya의 스크립트 편집기)의 기본 출력으로 전송됩니다. 엔진에서 실행 중인 모든 앱이 이 디버그 레벨 메시지를 전송하기 때문에 엔진에 대해 이 설정을 켜면 결국 모든 앱에 대해서도 켜는 셈입니다.이렇게 해도 파일로 어떤 로그 메시지를 출력하지는 않습니다. 이를 가능하게 할 추가 표준 로깅 프레임워크를 구현하기 위해 작업 중입니다. 예외는 Flow Production Tracking 데스크톱 및 Photoshop 엔진이며 GUI 콘솔과 파일 모두에 출력을 로깅합니다.소프트웨어의 엔진에 대해 디버그 로깅 켜기예를 들어, 샷 단계 환경의 Nuke 엔진에 대해 디버깅 출력을 켜려면 환경 파일에서 Nuke 엔진(tk-nuke) 섹션을 찾아 설정을 debug_logging: true로 업데이트합니다.config/env/shot_step.yml을 편집합니다.engines:  ...  ...  tk-nuke:    apps:      ...      ...    compatibility_dialog_min_version: 9    debug_logging: true    favourite_directories: []    location: {name: tk-nuke, type: app_store, version: v0.2.23}    ...   ...파일을 저장하고 샷 단계 환경에서 Nuke를 다시 실행합니다. 이제 스크립트 편집기 창에서 디버그 출력을 볼 수 있을 것입니다.                    참고: 디버그 로깅이 Flow Production Tracking 데스크톱 체크박스, 환경 변수 또는 엔진 구성 설정 중 하나를 통해 활성화된 경우 디버그 로깅이 출력됩니다. 또한 이러한 세 가지 각각의 설정은 서로 독립적으로 수정됩니다. 체크박스 값은 엔진 설정이나 환경 변수에 전혀 관계없이 영구적인 앱 설정입니다. 즉, 데스크톱 체크박스를 선택 취소해도 다른 방법 중 하나를 통해 디버그 로깅이 계속 활성화되어 있을 수 있다는 의미입니다.    tank 명령에 대해 디버그 로깅 켜기tank 명령을 실행 중인데 터미널에서 디버그 출력을 보고 싶다면 실행 중인 명령과 함께 --debug 옵션을 사용하면 됩니다. 그러면 해당 명령에 대해 디버그 로깅이 켜집니다..	/tank --debug core DEBUG [10:11:38 617.835998535]: DEBUG [10:11:38 618.768930435]: Running with debug output enabled.DEBUG [10:11:38 618.921995163]: DEBUG [10:11:38 619.092941284]: Core API resides inside a (localized) pipeline configuration.DEBUG [10:11:38 619.235992432]: Full command line passed: ['/sgtk/software/shotgun/scarlet/install/core/scripts/tank_cmd.py', '/sgtk/software/shotgun/scarlet', '--debug', 'core'] DEBUG [10:11:38 619.364023209]: DEBUG [10:11:38 619.463920593]: DEBUG [10:11:38 619.575977325]: Code install root: /sgtk/software/shotgun/scarlet DEBUG [10:11:38 619.678020477]: Pipeline Config Root: /sgtk/software/shotgun/scarlet DEBUG [10:11:38 619.756937027]: DEBUG [10:11:38 619.826078415]: DEBUG [10:11:38 619.905948639]: DEBUG [10:11:38 619.978904724]: Context items: ['/sgtk/software/shotgun/scarlet'] DEBUG [10:11:38 620.06688118]: Command: core DEBUG [10:11:38 620.129108429]: Command Arguments: [] DEBUG [10:11:38 620.193004608]: Sgtk Pipeline Config Location: /sgtk/software/shotgun/scarlet DEBUG [10:11:38 620.270967484]: Location of this script (__file__): /sgtk/software/shotgun/scarlet/install/core/scripts/tank_cmd.py Welcome to the Flow Production Tracking Toolkit!For documentation, see https://developer.shotgridsoftware.com/d587be80/?title=Integrations+User+GuideStarting Toolkit for your current path '/sgtk/software/shotgun/scarlet'- The path is not associated with any Shotgun object.- Falling back on default project settings.DEBUG [10:11:39 125.463962555]: Sgtk API and Context resolve complete.	DEBUG [10:11:39 126.449108124]: Sgtk API: Sgtk Core v0.15.18, config /sgtk/software/shotgun/scarlet DEBUG [10:11:39 126.588106155]: Context: scarlet - Using configuration 'Primary' and Core v0.15.18 - Setting the Context to scarlet.DEBUG [10:11:39 129.276990891]: 이 명령의 경우 엔진을 로드할 필요가 없습니다.- Running command core... ---------------------------------------------------------------------- Command: Core ---------------------------------------------------------------------- Welcome to the Flow Production Tracking Toolkit update checker!This script will check if the Toolkit Core API installed in /sgtk/software/shotgun/scarlet is up to date.Please note that when you upgrade the core API, you typically affect more than one project. If you want to test a Core API upgrade in isolation prior to rolling it out to multiple projects, we recommend creating a special *localized* pipeline configuration. For more information about this, please see the Toolkit documentation.	You are currently running version v0.15.18 of the Flow Production Tracking Toolkit No need to update the Toolkit Core API at this time!DEBUG [10:11:39 981.74405098]: Exiting with exit code None",
    "url": "/143e0a94/",
    "relUrl": "/143e0a94/"
  },
  "198": {
    "id": "198",
    "title": "두 개의 익스텐션이 설치된 경우 Photoshop 통합 문제 해결",
    "content": "두 개의 익스텐션이 설치된 경우 Photoshop 통합 문제 해결어떤 문제가 있습니까?After Effects 통합 릴리즈에는 Flow Production Tracking와 통합되는 모든 Adobe 앱에서 사용할 수 있는 공통 플러그인이 있습니다. 이를 구현하는 과정에서, 이전 Photoshop 통합과의 호환성을 유지하고 스튜디오에서 확실하게 해당 업데이트로 전환할 수 있도록 하기 위해 익스텐션의 이름을 변경해야 했습니다.하지만 이로 인해 업그레이드할 때 두 개의 Flow Production Tracking 익스텐션이 설치될 수 있습니다.Flow Production Tracking Adobe Panel은 새로운 익스텐션으로, v1.7.0 이상의 Photoshop 통합을 사용하는 경우에 사용해야 합니다.문제를 어떻게 해결할 수 있습니까?이전 익스텐션을 제거하려면 홈 디렉토리의 Adobe 설치 위치에서 제거할 수 있습니다. 해당 폴더는 Photoshop 시작 시 디버그 출력에서 볼 수 있으며 다음과 같습니다.  OSX: ~/Library/Application Support/Adobe/CEP/extensions/com.sg.basic.ps  Windows: %AppData% Adobe CEP extensions com.sg.basic.psPhotoshop을 종료하고 해당 디렉토리를 제거하고 난 후 다시 시작하면 하나의 익스텐션만 확인됩니다.                    참고: 여러 환경 또는 여러 구성에 Photoshop 통합이 있고 이전 플러그인과 새 플러그인이 혼합된 경우 사용자가 이전 통합을 사용하여 Photoshop을 시작하면 이전 플러그인이 반환됩니다. 한 번에 정리할 수 있도록 전체적으로 Photoshop을 업데이트하는 것이 좋습니다.    ",
    "url": "/3fd1f835/",
    "relUrl": "/3fd1f835/"
  },
  "199": {
    "id": "199",
    "title": "로컬 발급자 인증서를 가져올 수 없음",
    "content": "[SSL: CERTIFICATE_VERIFY_FAILED] 인증서 확인 실패: 로컬 발급자 인증서를 가져올 수 없음활용 사례사용자가 Windows의 Python API를 사용하여 Amazon에서 미디어를 업로드 및 다운로드하는 데 문제가 있습니다. 이 문제는 Python API에서 자체적으로 발생하며 다음 오류 메시지가 표시됩니다.shotgun_api3.shotgun.ShotgunFileDownloadError: Failed to open https://xxx.shotgunstudio.com/file_serve/attachment/xyz&amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1108)&amp;gt;Amazon이 백엔드에서 일부 인증서를 업데이트했습니다. Windows는 일반적으로 새 인증서가 필요한 웹 페이지를 찾을 때 인증서 저장소를 새로 고칩니다. 정기적인 검색 작업이 없는 컴퓨터에서 실행되는 독립 실행형 Python 스크립트는 인증서 업데이트를 검색하지 않으므로 컴퓨터에 상당수의 누락이 발생할 수 있습니다.해결 방법문제가 있는 시스템에 GUI 액세스 권한이 있는 경우 현재 S3에 저장된 미디어를 재생하기만 하면 인증서 저장소가 업데이트됩니다. 이 재생 솔루션은 Chrome, Internet Explorer, Edge 또는 기타 Chromium 기반 브라우저에서만 작동합니다. 이 재생 솔루션은 Firefox 또는 Safari에서는 작동하지 않습니다. 이러한 브라우저에서는 인증서 유효성 검사에 Windows의 표준 API를 사용하지 않기 때문입니다.이 솔루션이 작동하지 않는 사용자 또는 Deadline 렌더 팜과 같이 업데이트할 컴퓨터가 많은 경우 누락된 인증서를 컴퓨터에 추가하는 스크립트도 제공하고 있습니다. 공유한 스크립트에 대한 링크를 확인하십시오.Windows 10의 Powershell 또는 Windows 7의 Powershell 3 사용자의 경우 컴퓨터에서 관리자로 다음 스크립트를 실행하여 새 인증서를 가져올 수 있습니다.$cert_url = &quot;https://www.amazontrust.com/repository/AmazonRootCA1.cer&quot;$cert_file = New-TemporaryFileInvoke-WebRequest -Uri $cert_url -UseBasicParsing -OutFile $cert_file.FullNameImport-Certificate -FilePath $cert_file.FullName -CertStoreLocation Cert: LocalMachine Root명령이 작동할 경우 다음 내용이 표시되어야 합니다.   PSParentPath: Microsoft.PowerShell.Security Certificate::LocalMachine RootThumbprint                                Subject----------                                -------8DA7F965EC5EFC37910F1C6E59FDC1CC6A6EDE16  CN=Amazon Root CA 1, O=Amazon, C=US이렇게 하면 실행되는 컴퓨터의 모든 사용자 계정에 대해 인증서를 사용할 수 있게 됩니다. 관리자 액세스 권한이 없는 경우 마지막 행을 다음과 같이 변경할 수 있습니다.Import-Certificate -FilePath $cert_file.FullName -CertStoreLocation Cert: CurrentUser Root그러면 인증서가 현재 사용자에 대해서만 추가됩니다.아직 cmd.exe를 사용하는 경우 certutil을 사용할 수도 있습니다. 먼저 https://www.amazontrust.com/repository/AmazonRootCA1.cer에서 인증서를 다운로드하여 컴퓨터에 저장해야 합니다.그런 다음 관리 모드에서 명령 프롬프트를 시작합니다.다음 행을 실행합니다.certutil -addstore root &amp;lt;path-to-the-cert&amp;gt;이렇게 하면 인증서를 모든 사용자 계정에 사용할 수 있습니다. 관리자 액세스 권한이 없는 경우에는 다음과 같이 -user를 추가하여 현재 사용자에 대해서만 인증서를 설치할 수 있습니다.certutil -user -addstore root &amp;lt;path-to-the-cert&amp;gt;관련 링크커뮤니티에서 전체 스레드 참조",
    "url": "/e9d994eb/",
    "relUrl": "/e9d994eb/"
  },
  "200": {
    "id": "200",
    "title": "앱 또는 엔진을 어떻게 제거합니까?",
    "content": "앱 또는 엔진을 어떻게 제거합니까?앱 또는 엔진이 더 이상 존재하지 않도록 구성의 환경 YAML 파일을 편집하여 앱 또는 엔진을 제거할 수 있습니다.환경 파일을 사용하면 앱을 완전히 제거하는 대신 특정 컨텍스트 또는 엔진에서만 사용할 수 있도록 앱을 구성할 수 있습니다.일반적인 환경 파일 편집에 대한 자세한 내용은 이 안내서를 참조하십시오.예시다음은 기본 구성에서 Publish 앱을 완전히 제거하는 방법을 보여 주는 예입니다.앱은 환경 설정 내부의 엔진에 추가되므로 앱이 추가된 모든 엔진에서 Publish 앱을 제거해야 합니다.엔진에서 앱 제거각 엔진에는 .../env/includes/settings 내에 자체 YAML 파일이 있습니다. Publish 앱은 모든 엔진에 포함되어 있으므로 각 엔진 YAML 파일을 수정해야 합니다. 예를 들어 Maya 엔진을 사용하는 경우 tk-maya.yml을 열고 Publish 앱에 대한 모든 참조를 제거합니다.우선 includes 섹션에 앱에 대한 참조가 있습니다..../env/includes/settings/tk-maya.yml L18에셋 단계 컨텍스트에 있는 경우 Maya 엔진에도 앱이 포함됩니다..../env/includes/settings/tk-maya.yml L47메뉴 즐겨찾기에 이를 추가하는 줄도 있습니다..../env/includes/settings/tk-maya.yml L56다음으로 샷 단계 설정에 다음 줄을 반복합니다..../env/includes/settings/tk-maya.yml L106.../env/includes/settings/tk-maya.yml L115그런 다음 다른 모든 엔진 환경 yml 파일(예: tk-nuke, tk-3dsmaxplus, tk-desktop 등)에서 이 단계를 반복합니다.                    중요: 이제 통합에서 사용자에게 앱이 표시되지 않으므로 이것으로 충분합니다. 그러나 깨끗하게 유지하기 위해 구성에서 앱에 대한 참조를 완전히 제거하려면 나머지 단계를 완료합니다.    앱 설정 제거이러한 모든 엔진 YAML 파일은 tk-multi-publish2.yml 설정 파일을 포함하고 있었습니다. 이제 엔진 YAML 파일에서 해당 참조가 제거되어 이 파일을 완전히 제거할 수 있습니다.                    중요: tk-multi-publish2.yml을 제거해도 이를 가리키는 엔진 파일이 남아 있는 경우 다음과 같은 내용의 오류가 발생합니다.ErrorInclude resolve error in '/configs/my_project/env/./includes/settings/tk-desktop2.yml': './tk-multi-publish2.yml' resolved to '/configs/my_project/env/./includes/settings/./tk-multi-publish2.yml' which does not exist!     앱 위치 제거기본 구성에서 모든 앱은 …/env/includes/app_locations.yml 파일에 해당 위치 디스크립터를 저장합니다. tk-multi-publish2.yml은 이를 참조하므로 디스크립터 줄을 제거해야 합니다.",
    "url": "/86ab39ef/",
    "relUrl": "/86ab39ef/"
  },
  "201": {
    "id": "201",
    "title": "__commands::unreal_engine을 호출하는 동안 오류 발생",
    "content": "[ERROR] [PROXY] __commands::unreal_engine]을 호출하는 동안 오류 발생활용 사례:Flow Production Tracking 데스크톱 앱을 설정하고 Flow Production Tracking 앱에 UE4를 표시할 수 있게 된 후 Unreal을 실행하려고 하면 다음 메시지가 표시됩니다.2020-06-06 03:22:24,246 [ ERROR] [PROXY] Error calling __commands::unreal_engine_4.24.3((), {}):Traceback (most recent call last):File “C: Users USER0 AppData Roaming Shotgun bundle_cache app_store tk-desktop v2.4.12 python tk_desktop desktop_engine_project_implementation.py”, line 164, in _trigger_callbackcallback(*args, **kwargs)File “C: Users USER0 AppData Roaming Shotgun babilgames p91c38.basic.desktop cfg install core python tank platform engine.py”, line 1084, in callback_wrapperreturn callback(*args, **kwargs)File “C: Users USER0 AppData Roaming Shotgun bundle_cache app_store tk-multi-launchapp v0.10.2 python tk_multi_launchapp base_launcher.py”, line 125, in launch_version*args, **kwargsFile “C: Users USER0 AppData Roaming Shotgun bundle_cache app_store tk-multi-launchapp v0.10.2 python tk_multi_launchapp base_launcher.py”, line 343, in _launch_callback“Could not create folders on disk. Error reported: %s” % errTankError: Could not create folders on disk. Error reported: Could not resolve row id for path! Please contact support! trying to resolve path ‘D: UEProjects SON D: UEProjects SON’. Source data set: [{‘path_cache_row_id’: 2, ‘path’: ‘D: UEProjects SON’, ‘metadata’: {‘root_name’: ‘primary’, ‘type’: ‘project’}, ‘primary’: True, ‘entity’: {‘type’: ‘Project’, ‘id’: 91, ‘name’: ‘SON’}}]오류의 원인은 무엇입니까?디스크의 UE4 프로젝트 경로(D: UEProjects PROJECT_NAME )가 잘못되었습니다.해결 방법Flow Production Tracking 설정에 대한 새 폴더를 만들면 문제가 해결됩니다.커뮤니티에서 전체 스레드를 참조하십시오.",
    "url": "/5e456562/",
    "relUrl": "/5e456562/"
  },
  "202": {
    "id": "202",
    "title": "API를 사용하여 툴킷 구성을 프로그래밍 방식으로 업데이트하려면 어떻게 해야 합니까?",
    "content": "API를 사용하여 툴킷 구성을 프로그래밍 방식으로 업데이트하려면 어떻게 해야 합니까?앱, 엔진 및 프레임워크 업데이트프로그래밍 방식으로 엔진, 앱 및 프레임워크를 모두 최신 버전으로 업데이트하려면 다음 코드를 사용하면 됩니다.import syssys.path.append(&quot;&amp;lt;path_to_your_config&amp;gt;/install/core/python&quot;)import sgtk# substitute your Project id here or alternatively use sgtk_from_path()tk = sgtk.sgtk_from_entity('Project', 161)c=tk.get_command(&quot;updates&quot;)# setup authenticationif hasattr(sgtk, &quot;set_authenticated_user&quot;):     from tank_vendor.shotgun_authentication import ShotgunAuthenticator     user = ShotgunAuthenticator(sgtk.util.CoreDefaultsManager()).get_default_user()     sgtk.set_authenticated_user(user)# finally, execute the commandc.execute({})                    주의: 이렇게 하면 추가적인 상호 작용 또는 확인 없이 파이프라인 구성에서 모든 엔진, 앱 및 프레임워크가 최신 버전으로 업데이트됩니다. 계속 진행하기 전에 유념하시기 바랍니다.    코어 업데이트프로젝트의 코어를 상호 작용하지 않는 방식으로 실행하기 위해 스크립트에서 프로젝트 코어 버전을 업데이트하려면 다음 코드를 사용하면 됩니다.import syssys.path.append(&quot;&amp;lt;path_to_your_config&amp;gt;/install/core/python&quot;)import sgtk# substitute your Project id here or alternatively use sgtk_from_path()tk = sgtk.sgtk_from_entity('Project', 161)c=tk.get_command(&quot;core&quot;)# setup authenticationif hasattr(sgtk, &quot;set_authenticated_user&quot;):    from tank_vendor.shotgun_authentication import ShotgunAuthenticator    user = ShotgunAuthenticator(sgtk.util.CoreDefaultsManager()).get_default_user()    sgtk.set_authenticated_user(user)# finally, execute the commandc.execute({})                    주의: 이렇게 하면 추가적인 상호 작용 또는 확인 없이 Toolkit Core가 최신 버전으로 업데이트됩니다. 이 양식을 실행 중인 코어가 공유 코어인 경우 이렇게 하면 이 코어 버전을 공유 중인 모든 프로젝트가 사용하는 코어 버전이 업데이트됩니다! 계속 진행하기 전에 유념하시기 바랍니다.    참고:  커스텀 스크립트의 인증 및 로그인 자격 증명",
    "url": "/4de9c1d6/",
    "relUrl": "/4de9c1d6/"
  },
  "203": {
    "id": "203",
    "title": "파이프라인 구성 코어 위치를 업데이트하려면 어떻게 해야 합니까?",
    "content": "파이프라인 구성 코어 위치를 업데이트하려면 어떻게 해야 합니까?파이프라인 구성이 로컬 코어를 사용하도록 업데이트하려면 어떻게 해야 합니까?파이프라인 구성이 공유 Toolkit Core를 사용하도록 설정되어 있는 경우에는 해당 프로세스를 실행 취소하거나 tank localize 명령을 사용하여 파이프라인 구성 내부에 Toolkit Core API의 사본을 설치함으로써 코어의 “공유를 해제”할 수 있습니다. 이를 가리켜 코어를 “지역화”한다고 합니다.       터미널을 열고 Toolkit Core를 설치하려는 파이프라인 구성으로 이동합니다.     $ cd /sgtk/software/shotgun/scarlet            다음 tank 명령을 실행합니다.     $ ./tank localize ... ... ---------------------------------------------------------------------- Command: Localize ---------------------------------------------------------------------- This will copy the Core API in /sgtk/software/shotgun/studio into the Pipeline configuration /sgtk/software/shotgun/scarlet. Do you want to proceed [yn]        계속 진행하기 전에 툴킷이 모든 사항을 확인합니다. 파이프라인 구성이 현재 가리키고 있는 Toolkit Core 사본이 파이프라인 구성에 로컬로 복사됩니다.        이제 툴킷이 파이프라인 구성에서 사용 중인 모든 앱, 엔진 및 프레임워크를 install 폴더에 로컬로 복사합니다. 그런 후 Toolkit Core를 복사하고 새로 설치된 로컬 Toolkit Core를 사용하도록 파이프라인 구성의 구성 파일을 업데이트합니다.     Copying 59 apps, engines and frameworks... 1/59: Copying tk-multi-workfiles v0.6.15... 2/59: Copying tk-maya v0.4.7... 3/59: Copying tk-nuke-breakdown v0.3.0... 4/59: Copying tk-framework-widget v0.2.2... 5/59: Copying tk-shell v0.4.1... 6/59: Copying tk-multi-launchapp Undefined... 7/59: Copying tk-motionbuilder v0.3.0... 8/59: Copying tk-hiero-openinshotgun v0.1.0... 9/59: Copying tk-multi-workfiles2 v0.7.9... ... ... 59/59: Copying tk-framework-qtwidgets v2.0.1... Localizing Core: /sgtk/software/shotgun/studio/install/core -&amp;gt; /sgtk/software/shotgun/scarlet/install/core Copying Core Configuration Files... The Core API was successfully localized. Localize complete! This pipeline configuration now has an independent API. If you upgrade the API for this configuration (using the 'tank core' command), no other configurations or projects will be affected.                          참고: 설치한 앱, 엔진 및 프레임워크 버전에 따라 출력이 달라집니다.    파이프라인 구성이 기존 공유 코어를 사용하도록 업데이트하려면 어떻게 해야 합니까?기존 공유 Toolkit Core가 있는 경우 tank 명령을 사용하여 공유 코어를 사용하도록 기존의 “지역화된” 파이프라인 구성을 업데이트할 수 있습니다.      터미널을 열고 업데이트하려는 파이프라인 구성으로 이동합니다.     $ cd /sgtk/software/shotgun/scarlet            그리고 tank attach_to_core 명령을 실행하고, 현재 플랫폼에 있는 유효한 공유 코어 경로를 제공합니다.     $ ./tank attach_to_core /sgtk/software/shotgun/studio ... ... ---------------------------------------------------------------------- Command: Attach to core ---------------------------------------------------------------------- After this command has completed, the configuration will not contain an embedded copy of the core but instead it will be picked up from the following locations: - Linux: '/mnt/hgfs/sgtk/software/shotgun/studio' - Windows: 'z: sgtk software shotgun studio' - Mac: '/sgtk/software/shotgun/studio' Note for expert users: Prior to executing this command, please ensure that you have no configurations that are using the core embedded in this configuration. Do you want to proceed [yn]        계속 진행하기 전에 툴킷이 모든 사항을 확인합니다. 이 공유 코어는 이미 여러 플랫폼에 맞게 설정되었기 때문에 각 플랫폼의 위치가 표시됩니다.    새 플랫폼의 위치를 추가해야 한다면 공유 코어 구성에서 config/core/install_location.yml 파일을 업데이트하고 필요한 경로를 추가합니다.        이제 툴킷이 파이프라인 구성에 로컬 Core API를 백업하고, 지역화된 코어를 제거한 후에 공유 코어에 있는 파이프라인 구성을 가리키도록 필요한 구성을 추가합니다.     Backing up local core install... Removing core system files from configuration... Creating core proxy... The Core API was successfully processed.        나중에 파이프라인 구성에서 Toolkit Core를 지역화하기로 결정할 경우(예: 공유 코어에서 파이프라인 구성을 분리하고 로컬로 설치된 버전을 사용) tank localize 명령을 사용하여 그렇게 할 수 있습니다.                      참고: 공유 스튜디오 코어는 현재 파이프라인 구성의 코어 버전 이상이어야 합니다.    프로젝트 간에 Toolkit Core를 어떻게 공유합니까?현재는 SG 데스크톱을 사용하여 프로젝트를 설정하는 경우 Toolkit Core API가 “지역화됩니다”. 즉, 파이프라인 구성 내부에 설치됩니다. 모든 파이프라인 구성이 툴킷 설치를 완벽하게 포함하게 됩니다. 원한다면 Toolkit Core API 버전이 프로젝트 간에 공유되도록 하여 유지 관리 부담을 최소화하고, 모든 프로젝트가 같은 코어 코드를 사용하도록 할 수도 있습니다. 이를 대개 “공유 스튜디오 코어”라고 합니다.여기서는 여러 프로젝트 파이프라인 구성 간에 공유할 수 있는 새 Toolkit Core API 구성을 생성하는 방법을 소개합니다.      터미널을 열고, 공유하려는 Toolkit Core 버전이 포함된 기존의 파이프라인 구성으로 이동합니다. 프로젝트가 완료되면 이 파이프라인 구성은 더 이상 지역화된 상태로 유지되지 않고 새로 생성된 공유 코어를 사용하게 됩니다.     $ cd /sgtk/software/shotgun/pied_piper            다음 tank 명령을 실행하여 Toolkit Core를 디스크의 외부 위치로 복사합니다. 이 경로를 모든 플랫폼에서 찾을 수 있도록 해당 위치를 제공해야 합니다(linux_path, windows_path, mac_path). 각 경로마다 따옴표를 사용하는 것이 좋습니다. 특정 플랫폼에서는 툴킷을 사용하지 않는다면 그냥 빈 문자열(&quot;&quot;)을 지정하면 됩니다.      $ ./tank share_core &quot;/mnt/sgtk/software/shotgun/studio&quot; &quot;Z: sgtk software shotgun studio&quot;   &quot;/sgtk/software/shotgun/studio&quot;            툴킷이 작업을 진행하기 전에 변경될 사항을 요약하여 보여 줍니다.     ---------------------------------------------------------------------- Command: Share core ---------------------------------------------------------------------- This will move the embedded core API in the configuration '/sgtk/software/shotgun/pied_piper'. After this command has completed, the configuration will not contain an embedded copy of the core but instead it will be picked up from the following locations: - Linux: '/mnt/sgtk/software/shotgun/studio' - Windows: 'Z: sgtk software shotgun studio' - Mac: '/sgtk/software/shotgun/studio' Note for expert users: Prior to executing this command, please ensure that you have no configurations that are using the core embedded in this configuration. Do you want to proceed [yn]            툴킷이 새 공유 위치로 코어 설치를 복사하고, 새 공유 위치를 가리키도록 기존 파이프라인 구성을 업데이트합니다.     Setting up base structure... Copying configuration files... Copying core installation... Backing up local core install... Removing core system files from configuration... Creating core proxy... The Core API was successfully processed.      이제 다른 파이프라인 구성에서 이 새로운 공유 코어를 사용할 수 있습니다. (방금 생성한 것과 같은) 기존 공유 코어를 사용하도록 파이프라인 구성을 업데이트하려면 tank attach_to_core 명령을 사용하면 됩니다.",
    "url": "/b12f2510/",
    "relUrl": "/b12f2510/"
  },
  "204": {
    "id": "204",
    "title": "버전과 게시된 파일 간의 차이점은 무엇입니까?",
    "content": "버전과 게시된 파일 간의 차이점은 무엇입니까?“게시”는 디스크에 저장되어 응용프로그램 내에서 사용할 수 있는 파일(또는 이미지 시퀀스)이나 데이터를 의미합니다. exr 시퀀스, abc, Maya 파일 등이 여기에 포함될 수 있습니다. 게시는 Flow Production Tracking 내에서 PublishedFile 엔티티로 표현됩니다.“버전”(Flow Production Tracking 내 Version 엔티티)은 게시의 시각적 표현이며 리뷰 및 노트 작성에 사용됩니다. Version 엔티티에는 게시된 파일이라고 하는 필드가 있습니다. 이 필드에는 서로 연결할 게시 레코드의 수를 입력할 수 있습니다. 이를 통해 어떠한 리뷰 Version이 게시 그룹과 연결되는지 트래킹할 수 있습니다. 게시할 때 이 관계를 입력하는 것이 좋습니다. 버전은 Flow Production Tracking 내에서 Version 엔티티로 표현됩니다.궁극적인 아이디어는 게시할 때 파일 모음, 그러니까 대개 파일 형식은 다르지만 실질적으로 같은 내용을 가진 파일(Maya 파일, obj, alembic 등)을 생성할 수 있도록 하는 것입니다. 그리고 결국 이 파일들은 모두 같은 것을 서로 다르게 표현한 것입니다. 그런 후 이 파일들은 게시 데이터 미리보기 및 노트 작성을 위해 단일 리뷰 Version과 연결됩니다.게시된 데이터가 이미지 시퀀스인 경우에는 이 아이디어가 조금 쓸모없어질 수 있습니다. 사실 이미지 시퀀스는 리뷰하려는 것이기도 하면서 파이프를 따라 전송될 것이기도 합니다. 이 경우 게시와 Version 모두를 “더블 업”하고 생성해야 할 수 있습니다. 그러면 Loader 앱 등을 통해 Version을 표현하는 게시된 데이터를 로드할 수 있습니다.",
    "url": "/b867b4b0/",
    "relUrl": "/b867b4b0/"
  },
  "205": {
    "id": "205",
    "title": "툴킷 웨비나",
    "content": "Flow Production Tracking 툴킷 웨비나업데이트 날짜: 2020/5/8Flow Production Tracking 툴킷 웨비나 재생 목록Flow Production Tracking 툴킷 웨비나 동영상1: Flow Production Tracking 툴킷 웨비나: 기본 제공 통합(60분)새 시리즈 중 첫 번째 툴킷 웨비나에서는 Rob Blau와 Manne Öhrström이 기본 제공 통합에 관련된 질문에 답변합니다.2: Flow Production Tracking 툴킷 웨비나: 새 기본 구성 상세 설명(60분)이 웨비나에서는 Josh Tomlinson과 Rob Blau가 툴킷 프로젝트의 새 기본 구성에 대한 변경 사항과 변경한 이유에 대해 설명합니다.3: Flow Production Tracking 툴킷 웨비나: 게시 워크플로우 커스터마이즈 - 라이브 데모(60분)이 웨비나에서는 Josh Tomlinson이 Maya에서 커스텀 게시 워크플로우를 직접 만들어 볼 수 있도록 단계별 연습 과정을 안내합니다. 게시 앱을 구성하는 방법과 데이터 수집 및 게시를 위한 커스텀 후크를 작성하는 방법을 학습합니다.보충 자료파이프라인 튜토리얼4: Flow Production Tracking 툴킷 웨비나: 클라우드 구성 및 다중 위치 워크플로우(60분)이 웨비나에서는 Manne Ohrstrom이 아티스트가 여러 위치에 분산된 스튜디오의 워크플로우를 탐색합니다.보충 자료툴킷 초기화 및 구성 관리에 대한 개발자 문서동영상에서 Manne이 참조하는 디스크립터 유형 목록5: Flow Production Tracking 에코시스템 웨비나: REST API(60분)이 웨비나에서는 Brandon Ashworth가 여러 가지 유용한 데모, 예제 및 방법을 소개하면서 REST API의 정의, 중요성 및 사용 방법을 설명합니다.보충 자료REST API 참조 문서6: Flow Production Tracking 툴킷 웨비나: 새 Publisher API(35분)최신 통합 릴리즈에 포함된 향상된 게시 API를 사용하면 GUI 앱에서 게시 로직을 분리하고 고유의 도구 또는 렌더 팜에서 게시를 실행할 수 있습니다. 이 웨비나에서는 Jean-Francois Boismenu가 API를 사용하여 게시자 UI에서 렌더 팜 작업으로 게시 항목 트리를 전달하는 방법에 대해 설명합니다.보충 자료구성이 포함된 Github 리포지토리31시에 참조된 풀 요청API 문서 게시7: Flow Production Tracking 툴킷 웨비나: After Effects 통합(38분)Adobe After Effects는 최신 Flow Production Tracking 통합 기능입니다. 이 웨비나에서는 Rob Blau가 기능에 대한 라이브 데모를 사용하여 After Effects 통합에 대해 자세히 설명하고 Photoshop 통합에서 히빙 리프팅을 리팩터링하여 Adobe 통합에 재사용 가능한 프레임워크를 개발하는 방법에 대해 논의합니다.또한 Tannaz Sassooni가 새로운 개발자 설명서 사이트를 둘러보고 어떻게 하면 사용자가 Flow Production Tracking 소프트웨어를 사용하여 보다 쉽게 통합할 수 있는지 설명합니다.보충 자료After Effects 통합 문서개발자 설명서 포털Flow Production Tracking Developer Day 재생 목록Flow Production Tracking Developer Day 동영상SIGGRAPH 2018 및 2019에서 Flow Production Tracking 팀은 개발자들이 태스크 자동화, 커스텀 앱 작성 등에 사용할 수 있는 다양한 리소스를 익힐 수 있도록 교육 과정 시리즈 Flow Production Tracking Developer Day를 발표했습니다. SIGGRAPH가 끝난 후에는 Developer Day의 컨텐츠를 소개하는 일련의 웨비나를 진행했습니다. 이 재생 목록에는 웨비나의 녹화본이 포함되어 있습니다.전체 슬라이드 데크, 코드 예제 및 이 컨텐츠와 관련된 기타 리소스는 2019의 경우 여기, 2018의 경우 여기에서 확인할 수 있습니다.1: SIGGRAPH Developer Day 2019: Flow Production Tracking 개발 소개(83분)이 웨비나에서는 Tannaz Sassooni와 Patrick Boucher가 Flow Production Tracking의 자동화를 위한 진입점, Flow Production Tracking의 Python 및 REST API, Flow Production Tracking의 API로 스튜디오의 태스크 및 데이터 트래킹을 자동화하는 방법에 대한 논의 등 Flow Production Tracking 개발과 관련된 내용을 소개합니다.0:56  환영 인사 및 오리엔테이션3:00 Flow Production Tracking 개발 소개: 공통 파이프라인의 요구 사항을 소개하고, Flow Production Tracking API 및 개발 프레임워크를 사용하여 이러한 요구 사항을 충족하는 방법을 간략하게 설명합니다. [Tannaz Sassooni]25:59  Flow Production Tracking API를 사용한 데이터 관리 소개: 액션 메뉴 항목을 생성하는 프레임워크 및 간단한 Python 및 REST 스크립팅을 사용하여 Flow Production Tracking API에 대해 자세히 설명합니다. [Patrick Boucher]2: SIGGRAPH Developer Day 2019: 고급 Flow Production Tracking 개발(78분)이 웨비나에서는 Brandon Ashworth와 Manne Öhrström이 Flow Production Tracking의 데이터 변경에 반응하는 이벤트 데몬과 새로운 웹후크를 사용하는 Flow Production Tracking에 대해 자세히 설명하고 Flow Production Tracking 툴킷을 사용하여 간단한 파이프라인 도구를 작성하는 방법을 보여 줍니다.0:39  환영 인사 및 오리엔테이션2:33 Flow Production Tracking 이벤트 작업 [Brandon Ashworth]41:25 여러 아티스트 앱에서 실행되는 Flow Production Tracking 도구 개발 [Manne Öhrström]3: SIGGRAPH Developer Day: 툴킷 관리(1시간 15분)이 웨비나에서는 Josh Tomlinson, Tannaz Sassooni와 Phil Scadding이 통합을 인계받고 커스텀 디렉토리 구조 및 후크를 생성하여 스튜디오에서 더 많은 데이터 흐름을 자동화하는 방법에 대해 설명합니다.0:00 환영 인사 및 오리엔테이션1:04 Flow Production Tracking 툴킷 관리: Flow Production Tracking 데스크톱 앱을 통해 일반 컨텐츠 생성 소프트웨어를 시작하는 방법을 배우고 아티스트가 작업 세션을 종료하지 않고도 기본 파이프라인 통합을 사용하여 Flow Production Tracking 소프트웨어와 상호 작용할 수 있는 방법을 알아봅니다. [Phil Scadding]32:41 툴킷 구성 소개: 툴킷 파이프라인 구성을 통한 탐색 및 이를 사용하여 파이프라인 워크플로우를 커스터마이즈하는 방법을 익힙니다. [Tannaz Sassooni]56:20 후크 관리: Flow Production Tracking 툴킷의 광범위한 후크 집합을 사용하여 커스텀 로직을 구성에 추가하고 툴킷 파이프라인을 스튜디오의 요구 사항에 맞게 조정하는 방법을 배웁니다. [Josh Tomlinson]4: SIGGRAPH Developer Day: 고급 Flow Production Tracking 개발(1시간 15분)Manne Ohrstrom, Jeff Beeland, Rob Blau가 소스 제어 및 클라우드 기반 파이프라인 배포에 대한 모범 사례를 시연하고 빠르게 UI를 디자인하고 데이터를 처리할 수 있는 툴킷 표준 프레임워크 사용 및 앱 구축 방법에 대해 자세히 설명합니다.0:00 환영 인사 및 오리엔테이션2:31 툴킷 플랫폼: 개발 및 배포 패턴: 개발용 워크플로우, 버전 제어 모범 사례 및 파이프라인 구성을 Flow Production Tracking 사이트에 업로드하여 원격 사용자에게 배포하는 것을 비롯해 툴킷 파이프라인 구성을 설정하고 배포하는 다양한 방법에 대해 배웁니다. [Manne Ohrstrom]30:23 툴킷 플랫폼: 자체 앱 작성: 간단한 툴킷 앱을 작성하고 제공된 API 및 프레임워크를 활용하여 강력한 UI를 빠르게 만들 수 있는 방법을 살펴봅니다. [Jeff Beeland]1:02:22  Autodesk Forge 소개: Autodesk의 API 기반 클라우드 서비스 시리즈인 Forge를 소개하고 이를 사용하여 Flow Production Tracking 환경을 확장하는 방법을 알아봅니다. [Rob Blau]",
    "url": "/869a6fab/",
    "relUrl": "/869a6fab/"
  },
  "206": {
    "id": "206",
    "title": "VPC / IAM / Security Group",
    "content": "VPC / IAM / Security GroupAmazon Virtual Private Cloud permits users to logically separate virtual networks that host their AWS resources and provides you complete control over access to your AWS network.Within a VPC, security groups act as a basic firewall and control what inbound and outbound connections are permitted to each given resource. For example, a security group can allow inbound HTTPS traffic to a proxy server but block all other inbound traffic.With AWS Identity and Access Management (IAM), access to AWS resources and services can be controlled at a more fine-grained level. For example, IAM can be leveraged to control who or which resources can access S3 buckets used by Flow Production Tracking.All three of the above features are used in the Flow Production Tracking isolation features implementation to ensure that you securely connect your closed VPC to Flow Production Tracking and allow access to the media S3 buckets.",
    "url": "/28430132/",
    "relUrl": "/28430132/"
  },
  "207": {
    "id": "207",
    "title": "Web Traffic Isolation",
    "content": "Web Traffic IsolationCommunication between your client systems and your Flow Production Tracking site will traverse the open Internet by default. Web Traffic Isolation allows you to restrict access to your Flow Production Tracking site from the public Internet entirely and ensure that all traffic transits directly between your AWS VPC and Autodesk’s AWS VPC.ConfigurationA unique VPC endpoint is provided by Autodesk. Access to the endpoint must be configured from your VPC, and the relevant DNS configuration must be completed to allow your client systems to reach the new endpoint.How it worksBy using the provided VPC endpoint, web traffic is isolated from the public Internet completely. All web traffic transits between your AWS VPC and Autodesk’s AWS VPC, rather than the public Internet.CostsThe only cost associated with Web Traffic Isolation are those related to web traffic transiting to/from your AWS VPC. See AWS VPC Pricing for more details.Next StepsSee Web Traffic Isolation for setup instructions.",
    "url": "/57122ae9/",
    "relUrl": "/57122ae9/"
  },
  "208": {
    "id": "208",
    "title": "웹후크",
    "content": "웹후크웹후크를 사용하면 사용자가 제어하는 서비스는 Flow Production Tracking에서 발생하는 이벤트에 대한 알림을 받을 수 있습니다. 웹후크를 만들 때 관심 있는 이벤트 유형을 지정하고 이벤트가 트리거될 때 데이터를 보낼 URL을 Flow Production Tracking에 알려 주십시오. Flow Production Tracking에서 관련 이벤트가 발생하면 이벤트를 정의하는 데이터 페이로드가 웹후크의 URL로 전송됩니다. 이런 방법으로 Flow Production Tracking와의 긴밀한 통합을 구축하고 워크플로우의 일부를 자동화할 수 있습니다.웹후크 사용 방법에는 어떤 것이 있습니까?다양한 웹후크 사용 사례가 있습니다. 설득력 있는 몇 가지 사례가 이 문서에 개략적으로 설명되어 있지만 이러한 몇 가지 예에 국한되지는 않습니다.엔티티 생성 시 디스크에 디렉토리 구조 만들기우리가 여러 번 확인한 워크플로우 중에는 Flow Production Tracking에서 새 엔티티가 생성될 때 디스크에 디렉토리 구조를 생성하는 것이 있습니다. Flow Production Tracking에서 엔티티가 생성되면 자동으로 아티스트 작업을 위한 새 샷이 준비되도록 할 수 있습니다.상태 관리 자동화애니메이션 팀이 작업을 완료하면, 후속 작업을 시작할 준비가 되었음을 나타내도록 동일한 샷의 다운스트림 태스크 상태를 변경할 수 있습니다. 이 방법을 통해 여러 분야에서 할당된 아티스트에게 작업을 시작할 수 있음을 자동으로 통지할 수 있습니다.상태 관리 자동화의 또 다른 좋은 예는 새 Note가 작성될 때 Task 엔티티의 상태 변경을 트리거하는 것입니다. 아티스트 및 프로덕션 팀에게 감독이 리뷰 세션 후에 현재 작업에 대한 변경 또는 수정을 요청했음을 알려 주기에 좋은 방법입니다.언제 Flow Production Tracking 이벤트 데몬 대신 웹후크를 사용해야 합니까?웹후크와 Flow Production Tracking 이벤트 데몬은 비슷한 기능을 제공하지만 몇 가지 중요한 차이점이 있습니다 이벤트 데몬을 사용하려면 사용자 고유의 서비스를 실행, 모니터링 및 유지 관리해야 합니다. 모든 사용자 코드는 Python으로 작성해야 하며 그래야 Flow Production Tracking에 대한 사용자 고유의 연결을 시작할 수 있습니다. 웹후크는 이와 달리 연결에 응답하며 모든 프로그래밍 언어로 작성할 수 있습니다. 웹후크는 AWS Lambda와 같은 서버리스 환경에서 호스트되거나 Zapier 및 IFTTT와 같이 온라인으로 사용 가능한 모든 자동화 플랫폼을 트리거할 수 있습니다. 웹후크를 사용한 경우에는 이 솔루션을 사용하는 것이 좋습니다.웹후크 생성웹후크 생성을 시작하려면 웹후크 페이지로 이동합니다.그런 다음 웹후크 생성(Create Webhook)을 선택합니다.                    참고: 웹후크에 대한 액세스는 고급 권한(Advanced Permissions)의 웹후크 표시(Show Webhooks)를 통해 제어됩니다. 이 기능은 관리자(Admin) 및 매니저 권한 역할에 대해 기본적으로 활성화되어 있습니다. .    그런 다음 새 웹후크를 생성하는 데 필요한 정보를 입력합니다.비밀 토큰웹후크에 비밀 토큰을 할당하는 것은 선택 사항입니다. 비밀 토큰을 제공한 경우 해당 웹후크 URL에 전송된 모든 요청은 해당 토큰을 사용하여 서명됩니다. 토큰 값은 요청과 함께 X-SG-SIGNATURE라는 이름의 헤더로 전송됩니다. 서명은 SHA1과 함께 HMAC를 사용하여 계산되고 서명된 메시지는 요청의 JSON 본문입니다.헤더 형식&amp;lt;algorithm&amp;gt;=&amp;lt;signature&amp;gt;비밀 토큰을 사용하는 이유는 무엇입니까?꼭 필요한 것은 아니지만 비밀 토큰을 제공하면 웹후크 URL로 전송된 페이로드가 서명됩니다. 이를 통해 사용자 서비스는 예상한 소스에서 데이터가 생성되었으며 전송 중에 페이로드가 변경되지 않았음을 확인할 수 있습니다.서명 확인Python을 사용한 페이로드 서명 확인 방법의 예가 아래에 나와 있습니다.&amp;gt;&amp;gt;&amp;gt; import hmac&amp;gt;&amp;gt;&amp;gt; import hashlib&amp;gt;&amp;gt;&amp;gt; body | `&amp;lt;json body&amp;gt;'&amp;gt;&amp;gt;&amp;gt; token | `mytoken'&amp;gt;&amp;gt;&amp;gt; 'sha1=' + hmac.new(token, body, hashlib.sha1).hexdigest()  == 'sha1=32824e0ea4b3f1ae37ba8d67ec40042f3ff02f6c'TrueSSL 인증서 유효성 확인SSL 인증서 유효성 확인은 웹후크의 사용자 URL에 대한 모든 연결의 보안을 유지하는 데 도움이 되는 선택적 기능입니다. 이 옵션이 설정된 경우 웹후크의 URL로 전달이 이루어지면 Flow Production Tracking는 OpenSSL 인증서 유효성 확인 루틴을 사용하여 인증서를 확인합니다.배치 형식으로 전달(Deliver in Batched Format)배치 형식으로 전달하는 방법에 대한 자세한 내용은 여기를 참조하십시오.불안정할 경우 알림(Notify when unstable)불안정할 경우 알림(Notify when unstable)을 선택하면 웹후크가 실패할 때 알림을 보낼 사람 또는 그룹을 선택할 수 있습니다. 이 설정은 선택 사항입니다.프로젝트 및 엔티티별 필터링특정 프로젝트, 엔티티 및 필드를 선택하면 웹후크에 대한 트래픽이 최소화되어 다음과 같은 결과가 나타납니다.  성능 개선  리소스 비용 절감  불필요한 백로그 방지                    참고: 프로젝트를 선택하면 버전과 같이 항상 단일 프로젝트에 속하는 엔티티만 선택할 수 있습니다. 작업자와 같은 비 프로젝트(또는 다중 프로젝트) 엔티티를 선택하려면 프로젝트를 선택하지 마십시오. 이렇게 하면 엔티티 업데이트 시에 웹후크 이벤트 필터링으로 인해 성능 오버헤드가 부가되지 않습니다.    웹후크 상태웹후크의 상태는 여러 가지 중 하나이며 계속해서 전달을 받을 수 있는 기능 및 상태를 나타냅니다.            상태      예시      설명                  활성(Active)            웹후크가 안정적인 방식으로 작동합니다. 지난 24시간 동안 이 웹후크의 사용자 URL에 전달이 없으면 해당 대상에 도달하지 못한 것입니다.              불안정(Unstable)            웹후크가 불안정한 방식으로 작동합니다. 지난 24시간 동안 일부 전달이 대상에 도달하지 못했지만 Flow Production Tracking에서 웹후크가 작동하지 않는 것으로 간주할 정도는 아닙니다.              실패(Failed)            웹후크가 작동하지 않는 것으로 간주되고 더 이상 전달을 시도하지 않습니다. 이는 짧은 기간 동안 너무 많은 전달 실패에 따른 결과이며 시스템은 웹후크가 더 이상 실행 가능하지 않은 것으로 판단합니다. 지난 24시간 동안 100번의 전달에 실패한 경우 웹후크가 실패로 간주됩니다.              비활성화됨(Disabled)            웹후크가 비활성화된 상태이며 다시 활성 상태가 될 때까지 전달이 더 이상 시도되지 않습니다.      전달(Deliveries)웹후크 목록에서 웹후크를 선택하면 7일 전까지 수행된 해당 웹후크의 모든 전달이 표시됩니다.                    참고: 7일보다 오래된 전달 로그는 제거되며 복구할 수 없습니다.    전달 상태(Delivery status)전달 상태는 웹후크의 URL로 성공적으로 전달되었는지 여부를 나타냅니다.전달 상세 정보(Delivery details)전달을 확장하여 웹후크 URL로 전송한 요청과 해당 요청에 대한 응답의 상세 정보를 표시할 수 있습니다.페이로드 요청웹후크 URL로 전송한 페이로드에는 Flow Production Tracking에서 발생한 이벤트 및 이벤트를 트리거한 사용자에 대한 정보가 포함됩니다. JSON 형식으로 제공됩니다.                    페이로드 크기: 전달 페이로드의 최대 크기는 1MB입니다. Flow Production Tracking에서 트리거된 이벤트의 페이로드 크기가 1MB보다 크면 new_value 및 old_value 키가 제거되고 발생 이벤트, 원인 및 Flow Production Tracking에서 전체 이벤트 로그 항목을 검색하는 방법을 설명하는 메시지가 포함된 warning 키가 추가됩니다.    페이로드 예시{  &quot;data&quot;: {    &quot;id&quot;: &quot;11777.3065.0&quot;,    &quot;meta&quot;: {      &quot;type&quot;: &quot;attribute_change&quot;,      &quot;entity_id&quot;: 1246,      &quot;new_value&quot;: &quot;*Add fog and mist with depth&quot;,      &quot;old_value&quot;: &quot;*Add fog and mist.&quot;,      &quot;entity_type&quot;: &quot;Shot&quot;,      &quot;attribute_name&quot;: &quot;description&quot;,      &quot;field_data_type&quot;: &quot;text&quot;    },    &quot;user&quot;: {      &quot;id&quot;: 88,      &quot;type&quot;: &quot;HumanUser&quot;    },    &quot;entity&quot;: {      &quot;id&quot;: 1246,      &quot;type&quot;: &quot;Shot&quot;    },    &quot;project&quot;: {      &quot;id&quot;: 122,      &quot;type&quot;: &quot;Project&quot;    },    &quot;operation&quot;: &quot;update&quot;,    &quot;created_at&quot;: &quot;2022-02-01 20:53:08.523887&quot;,    &quot;event_type&quot;: &quot;Shotgun_Shot_Change&quot;,    &quot;delivery_id&quot;: &quot;3a5de4ee-8f05-4eac-b537-611e845352fc&quot;,    &quot;session_uuid&quot;: &quot;dd6a1d6a-83a0-11ec-8826-0242ac110006&quot;,    &quot;attribute_name&quot;: &quot;description&quot;,    &quot;event_log_entry_id&quot;: 545175  },  &quot;timestamp&quot;: &quot;2022-02-01T20:53:09Z&quot;}세션 UUIDShotGrid에서 이벤트를 트리거한 session_uuid가 이벤트 페이로드의 일부로 제공됩니다. 이 값은 Flow Production Tracking의 Python API에 제공될 수 있으며, 그러면 이 session_uuid를 사용하여 열려 있는 모든 브라우저 세션에 API에서 생성한 이벤트에 대한 업데이트가 표시됩니다.웹후크의 응답응답(Response) 탭에는 전달에 대한 웹후크 응답과 관련한 정보가 표시됩니다.웹후크의 응답 HTTP 헤더, 본문 및 측정된 응답 시간을 확인할 수 있습니다.웹후크 응답 본문은 최대 100자까지 유지됩니다. (위에 설명한 것처럼 전달 정보는 검토를 위해 7일 동안 유지되며 그 이후 삭제됩니다.)                    보안 모범 사례: 웹후크의 응답에 보안 데이터를 포함하지 말고, 응답에서 시스템 오류에 대한 상세 정보를 반환하지 마십시오.    전달에 대한 응답시스템에서 성공적인 전달로 간주되려면 웹후크 사용자 서비스가 전달에 응답해야 합니다.                    응답 시간 초과: 웹후크의 URL로 전달이 전송된 후 6초 내에 응답을 받아야 합니다. 이후에는 연결이 종료됩니다. 시간 내에 응답하지 못하면 전달에 실패하게 됩니다.    각 전달에 대한 처리 시간이 기록되며 응답 세부사항 탭에서 확인할 수 있습니다.스로틀링전달에 대한 사용자 응답 시간은 사이트의 웹후크 처리량에 영향을 미칩니다.각 사이트에서는 분당 1분의 응답 시간이 허용됩니다. 따라서 사이트에 대해 구성된 모든 사용자 엔드포인트가 응답하는 데 총 6초가 걸릴 경우 해당 사이트의 웹후크 전달이 분당 10번으로 제한됩니다.전체 처리량을 높여야 할 경우 다음 모델에 따라 사용자 엔드포인트를 설계해야 합니다.  요청 받기  또 다른 프로세스/스레드를 생성하여 원하는 방식으로 처리  즉시 확인 200에 응답상태 코드            상태      코드      설명                  성공      &amp;lt; 400      전달이 수신되고 성공적으로 처리되었습니다.              오류      &amp;gt;= 400      전달이 수신되었지만 성공적으로 처리되지 않았습니다.              리디렉션      3xx      전달이 수신되었지만 다른 URL로 리디렉션해야 합니다.      확인 응답확인 응답을 포함하도록 전달을 업데이트할 수 있습니다. 전달이 만들어지면 요청의 일부로 헤더가 제공됩니다. 이러한 헤더에는 x-sg-delivery-id 키에 저장된 전달 레코드의 ID가 포함됩니다. 이 ID는 Flow Production Tracking REST API를 사용하여 확인 응답이 포함되도록 전달 레코드를 업데이트하는 데 사용할 수 있습니다.                    확인 응답 크기: 확인 응답에 허용되는 최대 크기는 4KB입니다.    헤더 예시{  &quot;accept&quot;: &quot;application/json&quot;,  &quot;content-type&quot;: &quot;application/json; charset=utf-8&quot;,  &quot;x-sg-webhook-id&quot;: &quot;30f279a0-42a6-4cf2-bb5e-6fc550d187c8&quot;,  &quot;x-sg-delivery-id&quot;: &quot;dea7a71d-4896-482f-b238-b61820df8b65&quot;,  &quot;x-sg-event-batch-id&quot;: &quot;1&quot;,  &quot;x-sg-event-batch-size&quot;: &quot;4&quot;,  &quot;x-sg-webhook-site-url&quot;: &quot;https://yoursite.shotgunstudio.com/&quot;,  &quot;x-sg-event-batch-index&quot;: &quot;3&quot;}확인 응답의 역할은 무엇입니까?확인 응답은 웹후크의 URL에서 성공적으로 수신한 전달 처리의 성공 또는 실패에 대한 대역 외 상세 보고를 허용합니다. 이를 통해 Flow Production Tracking에서 전달 수신 상태를, 해당 전달과 관련된 이벤트 처리의 성공 또는 실패와 구분할 수 있습니다. 결과적으로, 성공적으로 전달된 이벤트에서 디버깅을 위해 유용한 추가 정보를 포함할 수 있습니다.Asset 엔티티 생성 시 트리거되는 웹후크가 좋은 예입니다. 웹후크의 역할이 새로운 각 Asset에 대해 디스크에 디렉토리 구조를 만드는 것인 경우, 웹후크의 URL을 성공적으로 전달받을 수 있지만 디스크 또는 네트워크 문제로 인해 관련 디렉토리를 만들지 못할 수도 있습니다. 이 경우 디렉토리 구조가 생성되지 않은 사실과 그 원인을 나타내는 자세한 오류 메시지와 함께 전달 레코드가 업데이트됩니다.웹후크 테스트자유롭게 사용할 수 있는 온라인 웹후크 URL 생성기 중 하나를 테스트용으로 사용할 수 있습니다. 이러한 서비스는 특별히 웹후크 및 기타 유형의 HTTP 요청 테스트에 사용해야 합니다. 이 방법은 고유의 네트워크에 인프라를 설정할 필요 없이 웹후크를 배우기 시작할 때 좋습니다.webhook.site 사용webhook.site를 사용하는 것이 좋습니다. 이는 웹후크에 복사하여 붙여넣을 수 있는 고유한 URL로, 해당 주소에 대한 전달 현황을 실시간으로 보여 줍니다. 전달에 응답할 때 특정 상태 코드 및 본문을 사용하도록 이 페이지를 사용자 지정하여, 전달 성공 및 실패를 테스트할 수 있습니다.webhook.site의 서비스는 매우 속도에 제한적입니다. 즉, 일부 전달이 거부되거나 불안정해지거나 실패한 웹후크 상황에서 쉽게 종료될 수 있습니다. 테스트할 때는 프로덕션의 라이브 데이터 대신, 알려져 있으며 제어 가능한 프로젝트 환경을 사용하는 것이 좋습니다.                    프로덕션 데이터: 공개적으로 사용할 수 있는 타사 웹 서비스에는 프로덕션 이벤트 데이터를 보내지 않는 것이 좋습니다. webhook.site와 같은 서비스를 사용하여 웹후크를 테스트하는 경우 테스트 데이터만 사용하는 것이 좋습니다.    ",
    "url": "/3d448f5e/",
    "relUrl": "/3d448f5e/"
  },
  "209": {
    "id": "209",
    "title": "경로 캐시가 무엇입니까? 파일 시스템 위치가 무엇입니까?",
    "content": "경로 캐시가 무엇입니까? 파일 시스템 위치가 무엇입니까?경로 캐시는 툴킷이 디스크의 폴더와 Flow Production Tracking의 엔티티 간 연결을 트래킹하는 데 사용합니다. 마스터 캐시는 FilesystemLocation 엔티티 유형을 사용하여 Flow Production Tracking에 저장됩니다. 그러면 각 사용자는 디스크의 툴킷 캐시 디렉토리에 로컬로 저장되는 각자의 경로 캐시 버전을 갖게 되고, 이 경로 캐시는 응용프로그램이 시작되거나 폴더가 생성될 때마다 백그라운드에서 동기화됩니다.보통 경로 캐시는 수동으로 수정하지 않는 것이 좋습니다. 저희의 내부 프로세스를 통해 여러분의 로컬 캐시가 Flow Production Tracking의 파일 시스템 위치 엔티티와 동기화될 뿐 아니라, 모든 사용자의 컴퓨터가 Flow Production Tracking와 동기화 상태를 유지할 수 있도록 이벤트 로그 항목도 생성됩니다.경로 캐시를 수정하는 데 사용할 수 있는 몇 가지 tank 명령이 있습니다.  tank unregister_folders 명령은 경로 캐시 연결을 제거합니다.  tank synchronize_folders 명령은 로컬 경로 캐시와 Flow Production Tracking의 동기화를 실행합니다.보통은 이 명령을 실행할 필요가 없지만 상황에 따라서는 실행하는 것이 유용할 수 있습니다.예를 들어, unregister_folders 명령은 프로젝트 내 엔티티의 이름을 바꾸거나 엔티티를 다시 생성하기 전에 실행해야 합니다.",
    "url": "/cbbf99a4/",
    "relUrl": "/cbbf99a4/"
  },
  "210": {
    "id": "210",
    "title": "로그 파일은 어디에 있습니까?",
    "content": "로그 파일은 어디에 있습니까?기본적으로 Flow Production Tracking 데스크톱 및 통합은 로그 파일을 다음 디렉토리에 저장합니다.Mac~/Library/Logs/Shotgun/Windows%APPDATA% Shotgun logs Linux~/.shotgun/logs/로그 파일 이름의 형식은 tk-&amp;lt;ENGINE&amp;gt;.log입니다. 예를 들면 tk-desktop.log 또는 tk-maya.log입니다.사용자의 캐시 위치를 재지정하도록 Flow Production Tracking_HOME 환경 변수를 설정한 경우 로그 파일은 $SHOTGUN_HOME/logs에 있습니다.                    참고: Flow Production Tracking 데스크톱에서도 이 디렉토리에 액세스할 수 있습니다. 프로젝트를 선택하고, 프로젝트 이름 오른쪽에 있는 아래쪽 화살표 버튼을 클릭하고, 로그 폴더 열기(Open Log Folder)를 선택하면 됩니다.    ",
    "url": "/38c5c024/",
    "relUrl": "/38c5c024/"
  },
  "211": {
    "id": "211",
    "title": "내 캐시는 어디에 있습니까?",
    "content": "내 캐시는 어디에 있습니까?루트 캐시 위치툴킷은 일부 데이터를 로컬 캐시에 저장하여 Flow Production Tracking 서버에 대한 불필요한 호출을 방지합니다. 여기에는 경로 캐시, 번들 캐시 및 썸네일이 포함됩니다. 대부분의 사용자는 기본 위치로도 문제 없지만 이를 변경해야 한다면 cache_location 코어 후크를 사용하여 구성할 수 있습니다.기본 캐시 루트 위치는 다음과 같습니다.Mac OS X~/Library/Caches/ShotgunWindows%APPDATA% ShotgunLinux~/.shotgun경로 캐시경로 캐시 위치는 다음과 같습니다.&amp;lt;site_name&amp;gt;/p&amp;lt;project_id&amp;gt;c&amp;lt;pipeline_configuration_id&amp;gt;/path_cache.db번들 캐시분산 구성번들 캐시는 Flow Production Tracking 사이트의 프로젝트 전반에 사용되는 전체 응용프로그램, 엔진, 프레임워크의 캐시 모음입니다. 분산 구성의 번들 캐시는 다음 위치에 저장됩니다.Mac: ~/Library/Caches/Shotgun/bundle_cacheWindows:%APPDATA% Shotgun bundle_cacheLinux:~/.shotgun/bundle_cache                    참고: SHOTGUN_BUNDLE_CACHE_PATH 환경 변수를 사용하여 이러한 위치를 재정의할 수 있으므로 실제 구현은 다를 수 있습니다.    중앙 집중식 구성중앙 집중식 구성의 번들 캐시는 중앙 집중식 구성 내부에 저장됩니다....{project configuration}/install/구성에서 공유 코어를 사용하는 경우 번들 캐시는 공유 코어의 설치 폴더 내부에 저장됩니다.썸네일툴킷 앱(예: Loader)에서 사용하는 썸네일은 로컬 툴킷 캐시에 저장됩니다. 썸네일은 프로젝트, 파이프라인 구성, 앱(필요 시)별로 저장됩니다. 루트 캐시 디렉토리 아래의 구조는 다음과 같습니다.&amp;lt;site_name&amp;gt;/p&amp;lt;project_id&amp;gt;c&amp;lt;pipeline_configuration_id&amp;gt;/&amp;lt;app_or_framework_name&amp;gt;/thumbs/",
    "url": "/7c9867c0/",
    "relUrl": "/7c9867c0/"
  },
  "212": {
    "id": "212",
    "title": "워크플로우",
    "content": "워크플로우툴킷 워크플로우와 관련된 질문과 대답이 간략하게 정리되어 있습니다.  버전과 게시된 파일 간의 차이점은 무엇입니까?",
    "url": "/8396394b/",
    "relUrl": "/8396394b/"
  },
  "213": {
    "id": "213",
    "title": "워크플로우",
    "content": "워크플로우Flow Production Tracking 파이프라인 통합의 커스터마이제이션을 통해 도구를 사용하여 장편 애니메이션에서 에피소드 워크플로우, 시각 효과, 게임에 이르는 다양한 워크플로우를 생성할 수 있습니다.이 섹션에서는 특정 워크플로우 빌드를 위한 리소스를 소개합니다.",
    "url": "/f5a4341f/",
    "relUrl": "/f5a4341f/"
  }
}
