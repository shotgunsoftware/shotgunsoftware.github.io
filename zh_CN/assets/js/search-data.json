{
  "0": {
    "id": "0",
    "title": "使用 ShotGrid Toolkit 时，为什么启动时 3ds Max 发生崩溃？",
    "content": "使用 ShotGrid Toolkit 时，为什么启动时 3ds Max 发生崩溃？从 ShotGrid Desktop 或 ShotGrid 网站启动 3ds Max 时，3ds Max 可能会冻结，同时出现一个冻结的白色对话框或者显示以下消息：Microsoft Visual C++ Runtime Library (Not Responding) Runtime Error! Program: C: Program Files Autodesk 3ds Max 2016 3dsmax.exe R6034 An Application has made an attempt to load the C runtime library incorrectly.Please contact the application's support team for more information. 这通常是由于路径中的 `msvcr90.dll` 版本与 3ds Max 捆绑的 Python 版本发生冲突。解决方案首先，转到工作流配置的 config/hooks 文件夹并创建文件 before_app_launch.py。在该文件中，粘贴以下内容：&quot;&quot;&quot;Before App Launch HookThis hook is executed prior to application launch and is useful if you needto set environment variables or run scripts as part of the app initialization.&quot;&quot;&quot;import osimport tankclass BeforeAppLaunch(tank.get_hook_baseclass()):    &quot;&quot;&quot;    Hook to set up the system prior to app launch.    &quot;&quot;&quot;    def execute(self, **kwargs):        &quot;&quot;&quot;        The execute functon of the hook will be called to start the required application        &quot;&quot;&quot;        env_path = os.environ[&quot;PATH&quot;]        paths = env_path.split(os.path.pathsep)        # Remove folders which have msvcr90.dll from the PATH        paths = [path for path in paths if &quot;msvcr90.dll&quot; not in map(            str.lower, os.listdir(path))        ]        env_path = os.path.pathsep.join(paths)        os.environ[&quot;PATH&quot;] = env_path现在，保存该文件。然后，打开工作流配置中的 config/env/includes/app_launchers.yml 并查找 launch_3dsmax 条目。您应该将 hook_before_app_launch: default 替换为 hook_before_app_launch: '{config}/before_app_launch.py'。您现在应该能够正常从 ShotGrid 和 ShotGrid Desktop 启动 3ds Max。如果您仍有任何问题，请访问我们的支持站点以获取帮助。",
    "url": "/a7555f37/",
    "relUrl": "/a7555f37/"
  },
  "1": {
    "id": "1",
    "title": "About the Isolation Feature Set",
    "content": "What is the Isolation Feature SetThe isolation feature set combines our Cloud Hosted Platform with client-managed AWS resources to provide a solution that satisfies the most stringent security and privacy requirements. Clients retain control of their sensitive content without having to host ShotGrid on their infrastructure.Leveraging the isolation feature set has the following advantages over the Standard offering:  Media Isolation by hosting of assets and attachments in a client-owned S3 Bucket  Media Traffic Isolation from the public internet  Media Replication allowing you to replicate media in one additional AWS Region  Access to fully managed ShotGrid Cloud Services  Automatic and continuous version upgrades  Ephemeral compute + in-memory segration between clientsIn a nutshell, this means that with the isolation features, your ShotGrid site and the data related to it cannot be reached by anyone outside of your studio network.The isolation feature set is a solution that requires less upkeep, as well as less IT/System Administrator knowledge and skills, than hosting ShotGrid on-premise. The list of advantages compared to on-premise includes, but is not limited to:  No ShotGrid specific knowledge required  No manual ShotGrid updates required  Very low level of maintenance required for the AWS componentsMedia isolation featureMedia Isolation allows your studio to keep the ownership and control of the media and attachments that you upload to ShotGrid. With Media Isolation, all the content that you upload to ShotGrid can be store in your studio private S3 bucket. Access to the media is provided to the ShotGrid service only, using AWS AssumeRole keyless Security Token Service. Your studio remains in control of the assets and the access to the assets, access that you can revoke at will.Traffic isolation featureMedia traffic isolation feature can be enabled to prevent your media traffic from being routed on the public internet, limiting it to the AWS backbone and your studio network. The traffic between ShotGrid Services and your studio stays in closed network, never going outside AWS or your Studio network.With the Media Traffic Isolation feature activated, the media will only leave your studio infrastructure once to get transcoded.Media ReplicationShotGrid is compatible with the S3 Cross-Region replication feature, allowing your users located in different regions to read from the region closer to them in order to reduce latency and increase throughput. Replication to one region is currently supported.EligibilityThe Isolation feature set is available to clients with an active ShotGrid subscription. See Getting Started for more details about how to active the different features. The activation of the isolation feature set is not instantaneous, and requires manual setup involving your AWS account.What the Isolation Feature Set is notThe isolation feature set is not a completely isolated solution. Both the compute services and the database services are shared amongst clients, and managed by ShotGrid. From a hardware standpoint, the isolation features does not guarantee complete physical isolation. However, ShotGrid services are guaranteeing isolation at the memory level. Processes are never reused to answer requests from different clients during their lifetime. Client metadata is stored in different databases. Client media is individually stored on S3.High Level ArchitectureThe ShotGrid cloud service  can be decoupled at a high level in 3 parts:Compute Stack: The part of the ShotGrid Service that handles client requests and serves data to the client.Data Stack: Metadata storage (databases).Media Storage: Where the client’s attachments, media, and assets are stored. ShotGrid uses AWS S3 to store client content.Please read Securing Studio IP in AWS: Cloud-based VFX Project Management with Autodesk ShotGrid for more details about the architecture.Ephemeral compute and memory isolationEven if clients share the same infrastructure, ShotGrid guarantees a complete memory isolation, both in transit and at rest, of client data. This makes ShotGrid less prone to data leaking due to architecture flaws or software vulnerabilities exploiting memory, like buffer overflow.Ephemeral transcodingEverytime media is uploaded to ShotGrid, the transcoding service is invoked to create a web friendly versions of your assets. That process happens only once, after the initial upload. The media is directly uploaded from the client to S3, from where it is fetched by the ShotGrid Transcoding Service. Each transcoding job is handled by a single container, which is killed after that unique job. The only place the media temporarily lives is in the container memory. The ShotGrid Transcoding service doesn’t store permanently a copy of your media.",
    "url": "/84dfd5cc/",
    "relUrl": "/84dfd5cc/"
  },
  "2": {
    "id": "2",
    "title": "自定义动作菜单项",
    "content": "自定义动作菜单项API 开发人员可以通过动作菜单项 (AMI) 按实体自定义上下文菜单项。例如，在“版本”(Versions)页面中，可以选择多个版本，单击鼠标右键，然后选择“Build a PDF Report”。动作菜单项字段1. 标题(Title) (title)：菜单项的显示名称。2. 实体类型(Entity Type) (entity_type)：将菜单项限制为只在某个类型（例如版本）的实体页面上显示。如果忽略此键（nil 值），则会允许在所有启用的实体上显示菜单项。3. URL (url)：将用于创建 PDF 报告的脚本的 URL。4. 顺序(Order) (list_order)：菜单项的顺序位置（相对于其他自定义菜单项）。5. 轻量有效负载(Light Payload) (light_payload)：使用自定义协议时，您的脚本将收到用于保存有效负载信息的事件日志条目记录的 ID，而不是完整的有效负载本身。6. 配置菜单选项：有几个选项可供选择：      包含在实体记录的右键单击菜单中(Include in the right-click menu on an Entity record)：这是默认值，通过在记录上单击鼠标右键将包含 AMI。        包含在实体页面的“添加实体”下拉菜单中(Include in “Add Entity” dropdown menu on Entity pages)：此选项用于在“添加实体”(Add Entity)下拉菜单（例如：“添加资产”(Add Asset)、“添加镜头”(Add Shot)等）中包含此 AMI。        覆盖实体页面上的“添加实体”按钮(Override “Add Entity” button on Entity pages)：此选项允许您使用 AMI 覆盖“添加实体”(Add Entity)按钮。        包含在用户菜单的“内部资源”部分中(Include in Internal Resources section of the User Menu)：此选项允许您使用内部资源自定义用户菜单。在此处了解有关使用内部资源自定义用户菜单的详细信息。  7. 文件夹(Folder) (folder)：允许您在上下文菜单中将 AMI 组织到文件夹中（当前仅支持单个级别的文件夹）。8. 以模态叠加方式打开(Open in Modal Overlay)：允许 AMI 在 iframe 窗口中打开，而不是在新选项卡中打开。请注意，如果 ShotGrid 运行的是 HTTPS，那么所有 iframe 也需要是 HTTPS。9. 轮询数据更新(Poll for Data Updates) (poll_for_data_updates)：开始轮询循环来查询事件日志条目。此项适用于以下情况：动作菜单项另一端的代码通过 API 将触发动作菜单项的页面上可见的实体的更改改回到 ShotGrid。10. 限制到权限组(Restrict to Permission Groups) (permissions_groups)：允许您将对 AMI 的访问权限仅限制于指定的权限组。如果保留为空，则 AMI 可供所有用户使用。11. 限制到项目(Restrict to Projects) (projects)：使 AMI 仅在指定的项目中显示。如果保留为空，则 AMI 可在所有项目中使用。12. 秘密令牌(Secret Token)：通过设置秘密令牌来保护您的 AMI。13. 需要选择(Selection Required) (selection_required)：确定在当前没有选择任何行时菜单项是否将处于激活状态。动作菜单项类型可以创建两种类型的菜单项：HTTP URL 示例例如，您可以创建名为“Build PDF Report”的自定义菜单项。 这将允许用户转到任何“版本”(Versions)页面，选择一个或多个版本，单击鼠标右键，然后从 ShotGrid 菜单中选择“Build PDF Report”。执行此操作将启动（您必须创建的）脚本，以获取一个格式完善的报告并发送回其浏览器。工作方式如下：通过 UI 创建菜单项在设置菜单中，选择“动作菜单项”(Action Menu Items)以打开 AMI 管理页面。要创建新 AMI，请单击 。填写“标题”(Title)和任何其他必填字段，然后单击“创建动作菜单项”(Create Action Menu Item)。用户单击 AMI 会发生什么情况？ShotGrid 将在新窗口或模态对话框（如果选择了该选项）中分派 POST 请求，然后将相关数据从当前页面（作为 POST 请求的一部分）发送到接收 URL。下面是一个工作流示例。  用户导航到“版本”(Versions)页面  用户选择一个或多个版本  用户打开上下文菜单（右键单击或单击工具栏中的配置菜单）  用户单击“Build PDF Report”  ShotGrid 在新窗口中将 POST 请求分派到 AMI 的 URL（如果 ShotGrid 服务器使用的是 HTTPS，URL 使用的是 HTTP，将会显示浏览器警告）  您的脚本（位于指定的 URL）处理 POST 数据，并生成一个 PDF 文档  向用户发送回一个格式完善的 PDF 报告以进行查看或下载自定义协议处理程序示例更高级的自定义 AMI 执行涉及设置自定义协议处理程序（例如 ShotGrid://process_version）。这样，您可以通过本地计算机上的脚本将 ShotGrid 与应用程序（如 Maya、RV 或 Cinesync）桥接起来。如果您指定非 HTTP(S) 协议，则将通过 GET 而不是 POST 将数据发送到您的 URL。您可能希望使用此项来启动内部工具以分派不同的请求。有关自定义协议的详细信息，请参见使用自定义浏览器协议启动应用程序。  注意：我们还通过 ShotGrid 集成内置了与 Maya 和其他软件包的集成。  轻量化负载使用自定义协议时，查询信息作为 GET 请求发送。某些操作系统和浏览器组合对允许的 GET 请求的大小限制有所不同。我们建议在自定义协议 AMI 上选中轻量化负载复选框。在选中轻量化负载复选框的情况下，您的脚本将收到一个事件日志条目 ID，它可以提取该 ID 以通过读取记录的 meta 字段的 ami_payload 键来从其获取完整的有效负载。示例下面是一些相关的示例脚本，可帮助您快速入门：  处理动作菜单项调用  版本打包程序有效负载内容用户数据  user_id：当前登录用户的用户 ID（例如 34）  user_login：当前登录用户的登录名（例如 joe）实体数据  entity_type：当前页面或视图的实体类型（例如版本）  selected_ids：选定实体 ID 的逗号分隔列表（例如 931, 900）  ids：当前页面查询所返回实体的所有 ID 的逗号分隔列表。这会返回所有 ID，包括那些由于分页而不可见的 ID（例如 931, 900, 904, 907）。如果在 AMI 上选中了“需要选择”(Selection required)，则此值将与 selected_ids 相同。页面数据  title：页面标题（例如“所有版本”(All Versions)）。  page_id：单击其中的动作菜单项的页面的 ID（例如 1353）。  server_hostname：在其中触发 AMI 的系统的主机名。如果您有多个调用相同 AMI 的服务器（例如开发服务器和生产服务器），这可能很有用。  referrer_path：在其中调用 AMI 的 URL 的规范路径。  session_uuid：在其中调用此 AMI 的窗口的唯一标识符。这可以与“轮询数据更新”(Poll for Data Updates)复选框和 Python API 的 set_session_uuid 方法一起使用，以将信息传回调用 AMI 的页面。注意：此功能的更新轮询呈指数级衰减并最终停止，因此如果您的 AMI 在轮询停止前未更新，您可能无法在源页面中看到任何更新。  cols：页面上所有可见列的系统字段名称的逗号分隔列表（例如 code, sg_status_list, description）。  column_display_names：页面上所有可见列的显示名称的逗号分隔列表（例如：版本(Version), 状态(Status), 说明(Description)）。  view：调用 AMI 时选择的视图。可以通过设计页面模式为任何给定页面创建多个视图。  sort_column：作为排序依据的列的系统名称（例如 code）。如果有多个排序键，仅发送第一个，请参见 sort_columns。  sort_direction：（例如 asc 或 desc）如果有多个排序方向，仅发送第一个，请参见 sort_directions。  sort_columns：作为页面或视图排序依据的列的系统名称的逗号分隔列表（例如 code, created_at）。仅当有多个排序键时才发送。  sort_directions：作为页面或视图排序依据的列的系统名称的逗号分隔列表（例如 code, created_at）。仅当有多个排序键时才发送。  grouping_column：作为分组依据的列的系统名称（例如 code）。如果有多个分组列，仅发送第一个，请参见 grouping_columns。  grouping_method：分组方法（例如，对实体字段按 entitytype 分组，对日期字段按 month 分组）。如果有多个分组方法，仅发送第一个，请参见 grouping_columns。  grouping_direction：分组方向（例如 asc 或 desc）。如果有多个分组方向，仅发送第一个，请参见 grouping_directions  grouping_columns：作为数据分组依据的列的系统名称的逗号分隔列表（例如 code, created_at）。仅当有多个分组列时才发送。  grouping_methods：分组方法的逗号分隔列表（例如 entity_type, month）。仅当有多个分组列时才发送。  grouping_directions：分组方向的逗号分隔列表（例如 asc, desc）。仅当有多个分组列时才发送。项目数据（仅当当前页面上的所有实体共享同一项目时才发送）  project_name：项目的名称（例如 Gunslinger）  project_id：项目的 ID（例如 81）“内部资源”(Internal Resources)菜单要了解有关将“动作菜单项”(Action Menu Items)用于“用户”(User)菜单中的“内部资源”(Internal Resources)的详细信息，请访问此处的管理员手册。",
    "url": "/67695b40/",
    "relUrl": "/67695b40/"
  },
  "3": {
    "id": "3",
    "title": "动作菜单项",
    "content": "动作菜单项本节包含有关创建自定义动作菜单项 (AMI) 和使用自定义浏览器协议启动应用程序的信息。  自定义动作菜单项  使用自定义浏览器协议启动应用程序要了解有关将“动作菜单项”(Action Menu Items)用于“用户”(User)菜单中的“内部资源”(Internal Resources)的详细信息，请访问此处的管理员手册。",
    "url": "/581648bb/",
    "relUrl": "/581648bb/"
  },
  "4": {
    "id": "4",
    "title": "Activation",
    "content": "ActivationOnce everything is configured and properly tested, it’s now time to migrate your production site to use the isolation features.TestNavigate to the /admin/speedtest route of your ShotGrid site. Select the new S3_CONFIG_NAME that was just set up previously and start the test to confirm that all the upload/download tests work as intended.Switch to your own Isolation S3 BucketNavigate to the Advanced section of Site Preferences page and set the storage location to your own S3 bucket.",
    "url": "/47ecbf94/",
    "relUrl": "/47ecbf94/"
  },
  "5": {
    "id": "5",
    "title": "管理",
    "content": "管理一组与管理和配置 Toolkit 设置相关的快速解答。ShotGrid Desktop：  如何使用 ShotGrid Desktop 来重新设置 Toolkit 项目？  如何在 Windows 上静默安装 ShotGrid Desktop？  如何在 Linux 上为 ShotGrid Desktop 设置桌面/启动程序图标？  如何禁用 ShotGrid Desktop 的浏览器集成？管理您的配置：  如何将我的配置修改为使用多个存储根目录？  如何将我的工作流配置移动到新位置？  如何将我的项目目录移动到新的本地存储根目录？  如何更新我的工作流配置核心位置？  如何在项目之间共享资产？  如何卸载应用或插件？基于缓存的问题：  什么是缓存路径？ 什么是文件系统位置？  我的缓存位于何处？",
    "url": "/ba09d04c/",
    "relUrl": "/ba09d04c/"
  },
  "6": {
    "id": "6",
    "title": "管理",
    "content": "管理ShotGrid 的工作流集成提供了大量自定义选项。要启动并运行您的工作室所需的工作流，可能需要配置、运行命令行工具并确保 ShotGrid 工具可在您的工作室环境中运行。本部分提供有关管理您工作室的 ShotGrid Toolkit 工作流的信息。",
    "url": "/a944bb05/",
    "relUrl": "/a944bb05/"
  },
  "7": {
    "id": "7",
    "title": "高级 Toolkit 管理",
    "content": "高级 Toolkit 管理本文介绍了如何管理和配置 Toolkit 以实现高级配置。在本主题中，请执行以下操作：  简介  使用 tank 命令          在调试模式下运行      通过 Tookit API 运行 tank 命令      实用的 tank 命令                  setup_project          core          configurations          updates          install_app、install_engine          app_info          folders、preview_folders          shell          dump_config 高级 tank 命令                      Toolkit Python API  工作流配置和沙盒          为沙盒运行 tank 命令      在沙盒中使用核心 API      访问沙盒      本地化工作流配置      删除克隆配置        检查更新          创建临时沙盒        配置应用的启动方式  在磁盘上创建文件夹          文件系统位置      重命名 Toolkit 文件夹      延迟创建和用户沙盒        配置模板          模板文件中的 @include 语法      在模板文件中包含外部文件      文件夹创建和模板        挂钩          应用级挂钩      核心级挂钩      工作室级挂钩      项目名称挂钩      连接挂钩        配置应用和插件          每个应用各有一个 location 设置      包含文件      配置模板设置 - 文件路径      使用挂钩自定义应用的行为      介绍欢迎您阅读《ShotGrid Toolkit 管理员手册》！本文档从管理的角度介绍如何使用 ShotGrid Pipeline Toolkit - 安装和更新应用、设置新项目以及管理工作室配置。Toolkit 仍然相对偏技术性，因此我们假设负责配置和管理的人员是系统管理员、工作流/工具开发者或技术主管。在开始了解细节之前，如果您还未阅读以下文档，我们建议您先阅读它！此文档讲解了一些基本概念，并简要介绍了配置管理和更新方面的知识：ShotGrid Pipeline Toolkit 基本概念简介。如果您尚未设置 ShotGrid Toolkit，则可能需要阅读集成用户手册。使用 tank 命令管理 ShotGrid Toolkit 以及常规使用 Toolkit 时，tank 命令是您的好帮手！使用 tank 命令，您可以快速轻松地从命令行同时运行管理命令和实际的应用。默认情况下，您创建的每个新项目都有自己独立的核心 API 和自己的 tank 命令。只需导航到项目配置位置并执行 tank 命令，即可查看所有适用于该项目的命令：cd /mnt/software/ShotGrid/big_buck_bunny./tanktank 命令有很多不同的用法。基本的思路是首先告诉 tank 命令要在何处执行操作，然后再告诉它要执行什么操作。 如果不告诉 tank 命令要执行什么操作，它将显示一个包含所有可用命令的列表。 如果不告诉 tank 命令在何处执行操作，它会尝试使用您当前所在的目录。 您还可以使用 tank 命令列出 ShotGrid 中的内容。有关如何使用 tank 命令的基本概述：# Show all tank commands for an asset named 'piano'&amp;gt; tank Asset piano# We can also list all assets containing the phrase 'pi'&amp;gt; tank Asset pi# We can execute the built-in folder creation command for# the piano&amp;gt; tank Asset piano folders# If the application launcher app is installed, we can launch maya# and set the work area to the piano&amp;gt; tank Asset piano launch_maya# Alternatively, we can specify a path on disk instead of a ShotGrid entity&amp;gt; tank /mnt/projects/hero/assets/piano launch_maya# Or we can change our work directory and run tank like this&amp;gt; cd /mnt/projects/hero/assets/piano launch_maya&amp;gt; tank launch_maya运行调试模式有时，了解底层运行情况可能会给您带来帮助。您可以向 tank 命令传递一个 --debug 标志，它会启用详细输出和计时功能，这有时能让您更容易跟踪查找问题或了解出现异常情况的原因。通过 Tookit API 运行 tank 命令大多数 tank 命令也完全支持通过 API 运行。这让您可以轻松在更庞杂的脚本化工作流中执行与 Toolkit 相关的维护操作。有关如何进行此操作的详细信息，请参见核心 API 参考实用的 tank 命令下面是您在管理 ShotGrid Toolkit 时可以使用的实用 tank 命令的简要列表。setup_projectShotGrid Desktop 中的设置项目向导的命令行版本。使用 ShotGrid Toolkit 设置新项目。当您在 ShotGrid 中有一个项目，并想扩展此项目以使用 Toolkit 时，可以由此命令开始。此命令将引导您完成整个过程，并提示您输入各种信息，比如要使用哪个配置以及要设置哪个项目。对同一个项目重新运行 setup_project默认情况下，setup_project 只会列出尚未设置的项目。但是，有时（特别是测试时）我们常常需要对同一个项目重新运行 setup_project。我们可以通过传递 –force 标志做到这一点，该标志将列出所有项目，并通过备注标识出之前已设置的项目：&amp;gt; tank setup_project --forceWelcome to SGTK!For documentation, see https://developer.shotgridsoftware.com- Running setup_project...force mode: Projects already set up with Toolkit can be set up again.Welcome to SGTK Project Setup!Connecting to ShotGrid...Connecting to the App Store...------------------------------------------------------------------Which configuration would you like to associate with this project?You can use the configuration from an existing project as a template for thisnew project. All settings, apps and folder configuration settings will becopied over to your new project. The following configurations were found:   big_buck_bunny: '/mnt/software/sgtk/big_buck_bunny'   ghosts: '/mnt/software/sgtk/ghosts'   chasing_perfection: '/mnt/software/sgtk/chasing_perfection'If you want to use any of the configs listed about for your new project, justtype in its path when prompted below.You can use the Default Configuration for your new project.  The defaultconfiguration is a good sample config, demonstrating a typical basic setup ofthe ShotGrid Pipeline Toolkit using the latest apps and engines. This will beused by default if you just hit enter below.If you have a configuration stored somewhere on disk, you can just enter thepath to this config it will be used for the new project.[tk-config-default]:Downloading Config tk-config-default v0.4.15 from the App Store...This is the 'Default Config' config.Below are all active projects, including ones that have been set up:--------------------------------------------------------------------[ 4] Demo Project     Fubar is an epic story of an on-going political wa...[ 5] Big Buck BunnyNote: This project has already been set up.     A killer bunny movie[ 6] The Ghosts of Pere LachaiseNote: This project has already been set up.     De Films en Aiguille and ChezEddy present this year...[ 7] Chasing PerfectionNote: This project has already been set up.     You've seen the car commercials, the car races, and...[ 8] What Happened to My Headphones?     The Ryan Mayeda storyPlease type in the id of the project to connect to or ENTER to exit:Toolkit 在项目设置过程中会提供项目名称建议。如果您对提供的名称满意，可以直接按 Enter 继续，否则也可以手动键入另外的名称。如果您的工作室对于项目命名有特殊约定，也可以对设置项目过程中建议的默认值加以控制。这可以通过一个高级的工作室级挂钩实现 - 请阅读下文中有关工作室级挂钩的部分了解更多信息。core此命令检查核心 API 更新。此命令将连接应用商店，查看是否有更新版本的核心 API 可用。如果有，命令会询问您是否要更新。此命令的输出示例：&amp;gt; tank coreWelcome to Sgtk!Starting Sgtk for your current directory '/private/tmp'- Running core...WARNING: You are potentially about to update the Core API for multipleprojects.Welcome to the Sgtk update checker!This script will check if the Sgtk Core APIinstalled in /mnt/software/sgtk/studiois up to date.You are currently running version v0.13.22 of the Sgtk PlatformNo need to update the Sgtk Core API at this time!configurations此命令可概览项目的所有配置。当您想知道某个项目当前活动的明细时，此命令非常方便。此命令的输出示例：&amp;gt; tank Project Bunny configurationsWelcome to Sgtk!Will search across all ShotGrid Projects.- Found Project Big Buck Bunny- Starting Sgtk v0.13.22 using configuration/mnt/software/sgtk/big_buck_bunny.- Setting the Context to Big Buck Bunny.- Running configurations...Fetching data from ShotGrid...======================================================================Available Configurations for Project 'Big Buck Bunny'======================================================================Configuration 'Primary' (Public)-------------------------------------------------------This is the Project Master Configuration. It will be used whenever thisproject is accessed from a studio level sgtk command or API constructor.Linux Location:  /mnt/software/sgtk/big_buck_bunnyWinows Location: z: mnt software sgtk big_buck_bunnyMac Location:    /mnt/software/sgtk/big_buck_bunnyThis configuration is using a shared version of the Core API.If you want it torun its own independent version of the Toolkit Core API, you can run:&amp;gt; /mnt/software/sgtk/big_buck_bunny/tank localizeIf you want to check for app or engine updates, you can run:&amp;gt; /mnt/software/sgtk/big_buck_bunny/tank updatesIf you want to change the location of this configuration, you can run:&amp;gt; /mnt/software/sgtk/big_buck_bunny/tank move_configurationThis is a public configuration. In ShotGrid, the actions defined in thisconfiguration will be on all users' menus.Configuration 'Dev Area' (Private)-------------------------------------------------------Linux Location:  /Users/manne/sgtk_devWinows Location: z: Users manne sgtk_devMac Location:    /Users/manne/sgtk_devThis configuration is using a shared version of the Core API.If you want it torun its own independent version of the Toolkit Core API, you can run:&amp;gt; /Users/manne/sgtk_dev/tank localizeIf you want to check for app or engine updates, you can run:&amp;gt; /Users/manne/sgtk_dev/tank updatesIf you want to change the location of this configuration, you can run:&amp;gt; /Users/manne/sgtk_dev/tank move_configurationThis is a private configuration. In ShotGrid, only Admin 3 will see the actionsdefined in this config. If you want to add additional members to thisconfiguration, navigate to the SG Pipeline Configuration Page and addthem to the Users field.updates此命令将查看与项目关联的所有环境，检查是否有更新版本的应用或插件可用。此更新程序可能会对照本地 Git 库、GitHub 或 ShotGrid Toolkit 应用商店检查更新，具体取决于应用和插件的安装方式。如果检测到更新的版本，命令会询问您是否要更新设置。如果应用的新版本中引入了任何新的配置参数，会提示您输入参数的值。一般语法：&amp;gt; tank updates [environment_name] [engine_name] [app_name]可以使用特殊关键词 ALL 表示一个类别中的所有项。示例：  检查所有内容：tank updates  检查镜头环境：tank updates Shot  检查所有环境中的所有 Maya 应用：tank updates ALL tk-maya  检查镜头环境中的所有 Maya 应用：tank updates Shot tk-maya  确保所有地方的加载器应用保持更新：tank updates ALL ALL tk-multi-loader  确保 Maya 中的加载器应用保持更新：tank updates ALL tk-maya tk-multi-loaderinstall_app、install_engine此命令在其中一个与项目关联的环境中安装新插件或应用。您可以使用此命令从 Toolkit 应用商店或 Git 安装应用或插件。app_info此命令可查看所有应用及其主要配置设置的明细。folders、preview_folders此命令在磁盘上为内容项创建文件夹。此命令的输出示例Welcome to Sgtk!Will search across all ShotGrid Projects.- Found Asset Squirrel (Project 'Big Buck Bunny')- Starting Sgtk v0.13.22 using configuration/mnt/software/sgtk/big_buck_bunny.- Setting the Context to Asset Squirrel.- Running folders...Creating folders, stand by...The following items were processed: - /mnt/projects/big_buck_bunny - /mnt/projects/big_buck_bunny/reference - /mnt/projects/big_buck_bunny/reference/artwork - /mnt/projects/big_buck_bunny/reference/footage - /mnt/projects/big_buck_bunny/sequences - /mnt/projects/big_buck_bunny/assets - /mnt/projects/big_buck_bunny/assets/Character - /mnt/projects/big_buck_bunny/assets/Character/Squirrel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/sgtk_overrides.yml - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/elements - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/photoshop/jpg - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/photoshop/psd - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/reference - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/reference/artwork - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/reference/footage - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/review - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/images - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/maya/workspace.mel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/maya/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/nuke/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/photoshop/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/elements - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/photoshop/jpg - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/photoshop/psd - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/reference - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/reference/artwork - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/reference/footage - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/review - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/images - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/maya/workspace.mel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/maya/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/nuke/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/photoshop/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/elements - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/photoshop/jpg - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/photoshop/psd - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/reference - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/reference/artwork - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/reference/footage - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/review - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/images - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/maya/workspace.mel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/maya/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/nuke/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/photoshop/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/elements - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/photoshop/jpg - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/photoshop/psd - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/reference - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/reference/artwork - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/reference/footage - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/review - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/images - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/maya/workspace.mel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/maya/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/nuke/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/photoshop/snapshotsIn total, 93 folders were processed.shell此命令在当前选择的上下文中启动一个互动式 Python Shell。针对预先初始化的 API、上下文和插件对象设置方便的引用。您可以使用 ./tank shell 尝试 Toolkit 和 ShotGrid API 代码示例。tank 可执行文件位于您本地计算机的 工作流配置根目录，看起来如下所示：&amp;gt; cd /my_tank_configs/project_foobar此命令的输出示例：Welcome to SGTK!For documentation, see https://developer.shotgridsoftware.comYou are running a tank command associated with ShotGrid Project 'Chasing theLight'. Only items associated with this project will be considered.- Found Shot moo87 (Project 'Chasing the Light')- Starting the SG pipeline toolkit v0.15.14.- Setting the Context to Shot moo87.- Started Shell Engine version v0.3.3- Environment: /mnt/software/tank/chasing_the_light/config/env/shot.yml.- Running shell...Welcome to SG Pipeline Toolkit Python!2.7.1 (r271:86832, Jul 31 2011, 19:30:53)[GCC 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2335.15.00)]Running on darwin- A tk API handle is available via the tk variable- A Shotgun API handle is available via the Shotgun variable- Your current context is stored in the context variable- The shell engine can be accessed via the engine variable&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; tk&amp;lt;Sgtk Core vHEAD@0x105f66990 Config /mnt/software/tank/chasing_the_light&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; context&amp;lt;Sgtk Context:   Project: {'type': 'Project', 'id': 88, 'name': 'Chasing the Light'}  Entity: {'type': 'Shot', 'id': 1184, 'name': 'moo87'}  Step: None  Task: None  User: {'type': 'HumanUser', 'id': 42, 'name': 'Manne  xc3 x96hrstr xc3 xb6m'}  Additional Entities: []&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Shotgun&amp;lt;tank_vendor.Shotgun_api3.Shotgun.Shotgun object at 0x105fb2990&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; engine&amp;lt;Sgtk Engine 0x105feead0: tk-shell, env: shot&amp;gt;&amp;gt;&amp;gt;&amp;gt;在上面的示例中，./tank 为您启动一个 Python Shell，并设置一些您需要的变量。通过在上面的变量中提供以下句柄和上下文，这就省去了一些基础工作，例如设置身份认证和用户会话，以及启动与 ShotGrid 站点的连接：  tk 变量有一个句柄，可让您访问 Toolkit API。  ShotGrid 变量有一个指向 ShotGrid API 的句柄，它已连接至您的站点，并准备好查询您的 [ShotGrid 站点]中的数据库和其他内容。  context 变量读取您当前的上下文（项目、镜头、资产、工作流工序、用户等）。下面是一个活动上下文的示例。这个示例中使用了一个上下文实例来收集一组描述当前上下文的主要字段。我们有时称上下文为当前工作区。通常，这将是用户当前正在处理的镜头或资产。在此示例中，可以看到项目为“Chasing the Light”，ID 为 1184，镜头为“moo87”。没有分配工作流工序或任务，但是用户为 Manne。在为 Toolkit API 编写脚本时，您可能需要知道这些信息，而这个方便的上下文变量可提供您所需要的一切：&amp;lt;Sgtk Context:   Project: {'type': 'Project', 'id': 88, 'name': 'Chasing the Light'}     Entity: {'type': 'Shot', 'id': 1184, 'name': 'moo87'}     Step: None     Task: None     User: {'type': 'HumanUser', 'id': 42, 'name': 'Manne  xc3 x96hrstr xc3 xb6m'}     Additional Entities: []&amp;gt;engine 变量指向当前运行的 Shell 插件 实例。dump_config核心 v0.18 中提供此命令。此命令将现有环境配置转存到 STDOUT 或另一个文件。它能够转存配置的完整表达法或稀疏表达法。完整表达法包括所有设置的默认值，稀疏表达法只包括与设置的默认值不同的值。默认情况下，该命令的输出包括每项设置的注释，这些注释指示清单文件可以在哪里找到默认值，如果默认值与配置中的值不同，还会指示默认值是什么。该命令不允许作为一项安全预防措施将环境配置转存到现有文件。用法：./tank dump_config env_name [--sparse | --full] [--no_debug-comments] [--file=/path/to/output/file.yml]此命令的输出示例：&amp;gt; ./tank dump_config shot_step --sparse --file=/tmp/shot_step.ymlWelcome to SGTK!For documentation, see https://developer.shotgridsoftware.comStarting toolkit for path '/Shotgun/configs/sparse34913'- The path is not associated with any SG object.- Falling back on default project settings.- Running as user 'Toolkit'- Using configuration 'Primary' and Core HEAD- Setting the Context to sparse34913.- Running command dump_config...----------------------------------------------------------------------Command: Dump config----------------------------------------------------------------------Dumping config...运行上面的命令会将当前项目的 shot_step 环境文件的一个稀疏副本写入 /tmp/shot_step.yml。要想不包括附加的调试注释，请使用 --no_debug_comments 标志。高级 tank 命令下面是您在管理 ShotGrid Toolkit 时可以使用的高级 tank 命令的简要列表。      tank share_core - 新项目创建后，它们的状态常常是每个项目都自己保留一份核心 API 的独立副本。此命令让您可选取这类项目的核心，并将核心移出到磁盘上的一个单独位置。这样就可以创建一个共享核心，几个项目共享核心 API 的一个副本。        tank attach_to_core - 新项目创建后，它们的状态常常是每个项目都自己保留一份核心 API 的独立副本。使用此命令，您可以将配置附加至现有的核心 API 安装，而不是让它保留属于自己的嵌入式版本的核心 API。        tank localize - 此命令会将核心 API 下载到特定的工作流配置位置。当您想在 Toolkit 暂存区内测试新版本的核心 API 时，此命令非常有用。本文档的下文详细介绍此过程。        tank clear_cache - 清除 Toolkit 的部分缓存。如果菜单项由于某种原因没有显示在 ShotGrid 中，此命令可能很有用。        tank validate - 验证项目配置。        tank cache_apps - 确保所有必需的应用、插件和框架版本在磁盘上存在。        tank switch_app - 此命令对开发非常有用。它可在应用商店模式与本地或 Git 模式之间来回切换应用。        tank push_configuration - 将当前工作流配置中包含的配置推送至另一个工作流配置。  Toolkit Python API如果您使用 ShotGrid Desktop、tank 命令或 ShotGrid 启动应用程序，则 Toolkit 会自动添加到 PYTHONPATH 并进行初始化。有时，手动添加 Toolkit API 的源并运行它是很有用的。我们可以通过将 Toolkit 核心 API 添加到 pythonpath 并导入它来做到这一点。在每个项目配置中，project_config_root/install/core/python 内都有一个 python 文件夹。只要将该位置添加到您的 Python 路径，便可导入 sgtk API：import sgtk# create a Sgtk API object for a ShotGrid entitytk = sgtk.sgtk_from_entity(&quot;Shot&quot;, 123)# Create a Sgtk API object based on a file system locationtk = sgtk.sgtk_from_path(&quot;/mnt/projects/hero/assets/chair&quot;)工作流配置和沙盒工作流配置具有与工作室安装相同的基本结构。最重要的是，它在 install/core/python 内同时包含一个 tank 命令和一个 Toolkit API。每个配置之所以具有相同的 API 和 tank 命令，是因为这样易于开发，并且便于在生产配置之外工作。当您在 ShotGrid Toolkit 中设置一个新项目后，项目设置会为该项目创建一个主工作流配置。此配置始终称为“主”(Primary)，代表项目的主配置。您可以看到该配置以项目的工作流配置实体形式显示在 ShotGrid 内。当您进行开发或更改配置时，通常不要在主配置中工作 - 如果不小心弄错了什么，所有参加项目的人都会受到影响。相反，您可以克隆 ShotGrid 内的配置。这样，不仅有属于自己的相同配置，而且可以在更改配置时不影响其他任何人。为沙盒运行 tank 命令如果您使用工作室级的 tank 命令运行应用，它将始终为项目使用主配置。因此，如果您只是键入 tank Shot ABC123 launch_maya，ShotGrid Toolkit 将查找镜头 ABC123 所属的项目，找到它的主工作流配置，并在启动 Maya 时使用这些配置设置。如果您想在开发沙盒中改用试验配置，则需要在开发沙盒内使用特定的 tank 命令启动 Maya：~/sgtk_dev_sandbox/tank Shot ABC123 launch_maya。这时 Toolkit 将使用开发沙盒中的配置，而不使用项目的主配置。在沙盒中使用核心 API同样，如果您想从工作流配置内（而不是工作室安装位置）运行 Toolkit API，可以将开发沙盒添加到 PYTHONPATH，而不是工作室的 Python API。访问沙盒在 ShotGrid 内，事情要简单得多。项目的每个工作流配置各有一组可以查看该配置的用户。如果将字段留空，每个人都将能够查看配置。当您克隆一个配置时（在 ShotGrid 中的配置上单击鼠标右键即可进行克隆），将会自动与该配置关联，这实际上授予了您对配置的独占查看权。如果您是在 Maya 中开发新工具，想让一位美工人员测试这些工具，只需将该美工人员添加到您的工作流配置开发沙盒中，他们便可从您的沙盒中启动 Maya，然后将可以访问正在开发中的工具。本地化工作流配置默认情况下，工作流配置将从 ShotGrid Toolkit 的工作室安装中提取其代码。Toolkit 的工作室安装会包含 ShotGrid Toolkit 使用的所有应用和插件代码的缓存，以及 Toolkit 核心 API 安装。每个工作流配置将共享位于工作室位置的核心 API 和应用缓存。这种做法通常比较有用，因为您可以将核心 API 更新同时部署到所有项目。只要更新工作室位置，所有项目都会随之更新。但是，有时我们需要能够隔离某个工作流配置，让它变得独立。例如，在下列情况有必要这样做：  您有一个即将封装的项目，您想冻结更新并确保所有内容都不再变化。  您有一个工作流配置，想在其中测试 Toolkit 核心 API 的某个新版本。  您要打包一个最精简的 Toolkit 数据包，供在家工作时使用。我们将这个使工作流配置完全独立于工作室位置的过程称为对配置进行本地化，根本上讲是将核心 API 复制到工作流配置中。您可以运行 tank localize 命令来执行此操作。注意，一旦将某个配置本地化，就无法再运行工作室 tank 命令 - 一般来说，一旦项目本地化，您就需要使用它的本地 tank 命令和 Python API。删除克隆配置如果您不再需要克隆的配置或开发环境，只要删除记录，然后从磁盘上删除配置即可。检查更新检查应用或插件是否有更新非常简单！只要为项目运行 tank updates 命令即可。ShotGrid Toolkit 会检查是否有更新，并询问您是否要进行更新。如果有任何新参数没有默认值，更新脚本会提示您输入这些值。每个更新会显示一个指向发行说明页面的 URL 链接，如果您想查看更改内容的详细信息，可访问此链接。您可以随时退出该过程。更新 Toolkit 核心 API 也同样简单。运行 tank core 命令即可！创建临时沙盒尽管只对主配置运行 tank updates 命令通常是万无一失的，但有时最好还是先进行测试，然后再部署到生产环境。在这种情况下，您只需克隆主工作流配置，然后在其中运行更新命令。升级核心 API 时，请确保在运行 core 命令前，先对沙盒进行本地化（参见上文了解有关本地化的详细信息）。验证更新可以正常进行后，再对主配置运行更新。有关如何执行此操作的详细信息，请参见管理您的配置。配置应用的启动方式在 Toolkit 配置中，常常需要在安装 Toolkit 之后立即进行的一项配置是应用启动配置。我们已尽量让这项任务变得灵活又可配置，因为我们知道工作室在这方面通常已经做了自定义，有了自己的工具。当您从 ShotGrid 内或使用 tank 命令启动应用程序（例如 Maya 或 Nuke）时，将会调用一个应用来负责启动应用程序并初始化 Toolkit。此应用称为 tk-multi-launchapp。当您使用其中一个 Toolkit 入门配置设置新项目时，它会显示如何更改启动器应用所用的应用程序路径。如果您有可以达到相同效果的替代系统，则无需使用此应用。启动器应用程序通常会执行以下操作步骤：      确定要使用的上下文。上下文表示当前的工作区。如果您在 ShotGrid 内的某个任务、资产或镜头上单击鼠标右键，将基于该对象创建上下文。如果您使用 tank 命令，上下文将是您在命令行中指定的内容，或者选取自您的当前目录。        然后，根据应用配置中的设置启动应用程序。您可以对启动器应用进行几种配置 - 应用程序的路径、要传递的命令行参数、实际执行应用程序的代码和启动应用程序前需要设置的环境变量。        设置 Pythonpath 以确保稍后可以初始化 Toolkit API。        一旦应用程序启动，将导入并初始化 Toolkit API。        最后，启动插件。  示例：一个说明 ShotGrid Toolkit 如何启动的更具实操性的示例。典型的 Toolkit 引导过程分为几个阶段：      启动主宿主应用程序。这是任何具有 Python 解释器的应用程序。它最简单的形式只是一个在标准 Shell 中运行的 CPython 解释器。另外，也可以是 Maya 或 Nuke 或其他任何具有内嵌 Python 解释器的应用程序。        Toolkit 核心 API 将添加到 PYTHONPATH 并导入：import sgtk        接下来需要确定上下文。该上下文可以是磁盘上的路径，也可以是 ShotGrid 对象。我们可以使用工厂方法创建一个 Toolkit API 实例：tk = sgtk.sgtk_from_path(&quot;/mnt/projects/hero/assets/chair01/lighting&quot;)。或者，也可以使用 ShotGrid 实体：tk = sgtk.sgtk_from_entity(&quot;Shot&quot;, 123)。当使用实体时，上面的代码将连接到 ShotGrid，解析该镜头的工作流配置，在磁盘上找到该工作流配置，加载 Sgtk 的基本设置（例如文件系统模板）。此时不会加载应用或插件。当需要查找路径时，它会使用文件系统来定位工作流配置。        接下来我们创建一个上下文对象来表示当前工作区。此操作也可通过实体或路径来完成：ctx = tk.context_from_entity(&quot;Shot&quot;, 123) 或 ctx = tk.context_from_path(&quot;/mnt/projects/hero/assets/chair01/lighting&quot;)        最后，我们启动插件。假设我们在 Maya 内使用 Maya 的 Python 解释器运行这些命令，我们会这样做：sgtk.platform.start_engine('tk-maya', tk, ctx)。这将执行以下操作：                  为上下文运行选取环境挂钩。选取环境挂钩将返回要使用的环境。环境包含要加载的所有应用及其配置的列表。                    确定环境文件后，将插件加载到内存中。这将动态地加载插件基础对象，并执行其 init 方法。插件加载后，所有应用以相同方式加载。通常，在这个过程中，插件将在应用程序中的某处注册一个“ShotGrid”菜单，每个应用将向插件注册一系列命令。这些命令稍后将成为执行命令的切入点：用户单击 ShotGrid 菜单上的某项，从而触发应用执行。            按照这样的思路，一个完整的示例将如下所示：# starting up sgtk when your context is based on a pathimport sgtkpath = &quot;/mnt/projects/hero/assets/chair01/lighting&quot;# create a sgtk api handletk = sgtk.sgtk_from_path(path)# create a context objectctx = tk.context_from_path(path)# start the tank enginesgtk.platform.start_engine('tk-maya', tk, ctx)# starting up sgtk when your context is based on a ShotGrid objectimport sgtkentity_type = &quot;Shot&quot;entity_id = 123# create a sgtk api handletk = sgtk.sgtk_from_entity(entity_type, entity_id)# create a context objectctx = tk.context_from_entity(entity_type, entity_id)# start the sgtk enginesgtk.platform.start_engine('tk-maya', tk, ctx)在磁盘上创建文件夹Toolkit 配置的一个关键部分是文件系统配置。ShotGrid Toolkit 可以帮助您以一致的方式在磁盘上创建文件夹，创建过程由 ShotGrid 驱动。下面是一个配置内的 core 文件夹的概览：设置一个文件夹配置相对简单。配置本质上是您创建的一个模板文件夹结构，其中有一些配置文件，指示文件夹应代表资产还是镜头。在配置文件系统结构时，您随时可以使用文件夹预览功能列出将要创建的文件夹。此命令在 ShotGrid 和 tank 命令中均可使用。首先使用普通文件夹概括您的“脚手架”。如果您的“脚手架”中有一级动态文件夹（例如用来代表资产、镜头或工作流工序的文件夹），请先暂时忽略它们。待获得满意的结果后，再逐步为每个动态文件夹添加动态功能。这通过添加与文件夹同名的 yml 文件来实现。在该 yml 文件内，使用特殊语法定义文件夹的创建方式。ShotGrid Toolkit 支持多种不同的动态行为，但常见的一种是代表 ShotGrid 实体的动态节点。在本例中，配置文件可以如下所示：# the type of dynamic contenttype: &quot;Shotgun_entity&quot;# the Shotgun field to use for the folder namename: &quot;{code}_{sg_prefix}&quot;# the Shotgun entity type to connect toentity_type: &quot;Asset&quot;# Shotgun filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std Shotgun API syntax)# any values starting with $ are resolved into path objectsfilters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }这将告诉 Toolkit，动态文件夹应创建使用资产实体上的两个 ShotGrid 字段命名的文件夹。使用标准 ShotGrid API 查询语法，我们还可基于父文件夹定义约束条件；只考虑当前项目和资产类型的资产。有关支持哪些类型的节点的完整参考，请参见参考文档。文件系统位置通过 Toolkit 文件夹创建系统在磁盘上创建文件夹时，这些文件夹也会在 ShotGrid 中存储和跟踪。在 ShotGrid 中，文件夹以文件系统位置实体的形式表示，可以在管理员菜单中找到。通常，Toolkit 会在后台跟踪这些数据，用户什么都不用管。这些文件系统位置实体供 Toolkit 用来同步和跟踪磁盘上的文件夹，另外也可像初次运行文件夹创建系统创建文件夹结构那样，用于在磁盘上重新创建文件夹结构。文件系统位置实体数据进而主要用于尝试找出哪个 ShotGrid 实体与磁盘上的特定路径关联。出于性能原因，Shotgun 管理的文件系统位置表的内容缓存在用户的本地计算机上。这样做是为了加快文件夹/实体查找速度。对于专家级用户，可通过修改 cache_location 核心挂钩来自定义此缓存的位置。每当磁盘上创建了文件夹和应用程序启动时，都会同步缓存的本地文件夹表示。重命名 Toolkit 文件夹当您执行 Toolkit 文件夹创建操作时，会在 ShotGrid 中的实体与磁盘上的文件夹之间建立联系。Toolkit 使用其文件夹数据结构配置在磁盘上生成一系列文件夹，而每个文件夹在 ShotGrid 中都注册为一个 Filesystem Location 实体。我们可以将这看成是 ShotGrid 数据（例如镜头和资产名称）和配置被“转化”成磁盘上和 ShotGrid 中的实际文件夹。文件夹一经创建，您便无法再随意更改 ShotGrid 中实体的名称。如果您尝试重命名实体并启动 Toolkit，将显示错误消息。 这是为了避免无法再跟踪与特定实体关联的文件夹。要重命名 Toolkit 文件夹，请执行以下操作：  首先，在 ShotGrid 中重命名实体（资产或镜头）。  通过运行 tank unregister_folders 命令，取消注册任何已注册的文件夹。这将移除 ShotGrid 中用来跟踪实体与磁盘位置之间关系的所有文件系统位置实体。请注意，此命令不会影响磁盘上的任何内容，只会影响 ShotGrid 中指向磁盘位置的 Filesystem Location 实体。例如，如果您想取消注册名为 Plant 的资产的文件夹，请执行 tank Asset Plant unregister_folders 命令。此命令会显示将要取消注册的文件夹的概要，并要求您确认操作。  取消注册文件夹之后，您实际上相当于“重置”了资产。此时资产不再与任何文件夹关联，通过在 ShotGrid 中使用新名称运行文件夹创建过程，将会在磁盘上创建新文件夹。  最后，将所有数据从先前的磁盘位置移至新位置。注意确保文件之间的任何链接也得到更新，指向新的位置。延迟创建和用户沙盒我们可以将 Toolkit 的文件夹创建过程设置为分两个阶段运行：一个阶段是每当有人运行文件夹创建命令时，另一个阶段是在应用程序临启动前。这是 Toolkit 应用程序启动器内置的一种行为（启动器只是调用标准 API 方法来执行文件夹创建操作）。延迟文件夹创建功能可以用来处理以下情况：  当您的工作流有多个不同的内容创作应用程序，但您不想在实际需要前就为每个应用程序包含一套完整的支持文件夹时，可以设置文件夹创建过程，让每个内容创作应用在配置中建立属于自己的延迟子树。当制作人员或管理员为镜头创建文件夹时，创建操作将在开始为 Maya、Nuke、Mari 等创建工作区前停止。然后，当用户启动某个应用程序时，会在该应用程序开始运行前创建这些文件夹。  当您想在文件系统中创建基于用户的沙盒时，需要等到工作开始前再创建它们。利用延迟文件夹创建功能，您可以添加一个特殊的用户节点来简化这一过程。在模板配置中，您将该用户节点称为 HumanUser，因为这是它在 ShotGrid API 中的表示方式。有关延迟创建的详细信息，请参见参考文档。配置模板创建文件系统结构后，接下来要基于上面的文件夹结构配置一组文件系统位置。这些位置称为模板，它们是 ShotGrid Toolkit 不可或缺的一部分。模板文件包含三个部分：keys 部分定义每个字段的含义，paths 部分可定义模板路径，strings 部分可定义字符串表达式。 模板文件中可以使用两种语法，一种是简单语法，适用于只有一个存储根目录的配置；另一种是高级语法，适用于多存储配置。示例：单根目录模板格式# The keys section contains the definitions for all the different keys that are being# used in the Toolkit. A key is a magic token that is replaced by a value at runtime, for example# {Shot}. The section below tells the Toolkit which data types and formats to expect for each key.keys:    Sequence:        type: str    Shot:        type: str    Step:        type: str    sg_asset_type:        type: str    Asset:        type: str    name:        type: str        filter_by: alphanumeric    iteration:        type: int    version:        type: int        format_spec: '03'    version_four:       type: int       format_spec: '04'       alias: version    timestamp:        type: str    width:        type: int    height:        type: int    channel:        type: str        filter_by: alphanumeric    SEQ:        type: sequence        format_spec: '04'    eye:        type: str# The paths section contains all the the key locations where files are to be stored# by the Toolkit Apps. Each path is made up of several keys (like {version} or {shot}) and# these are defined in the keys section above.## Toolkit apps use these paths as part of their configuration to define where on disk# different files should go.paths:    ##########################################################################################    # Shot pipeline / maya    shot_root: 'sequences/{Sequence}/{Shot}/{Step}'    # define the location of a work area    shot_work_area_maya: '@shot_root/work/maya'    # define the location of a publish area    shot_publish_area_maya: '@shot_root/publish/maya'    # The location of WIP files    maya_shot_work: '@shot_root/work/maya/{name}.v{version}.ma'    # The location of backups of WIP files    maya_shot_snapshot: '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'    # The location of published maya files    maya_shot_publish: '@shot_root/publish/maya/{name}.v{version}.ma'    ##########################################################################################    # Asset pipeline / maya    asset_root: 'assets/{sg_asset_type}/{Asset}/{Step}'    # define the location of a work area    asset_work_area_maya: '@asset_root/work/maya'    # define the location of a publish area    asset_publish_area_maya: '@asset_root/publish/maya'    # The location of WIP files    maya_asset_work: '@asset_root/work/maya/{name}.v{version}.ma'    # The location of backups of WIP files    maya_asset_snapshot: '@asset_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'    # The location of published maya files    maya_asset_publish: '@asset_root/publish/maya/{name}.v{version}.ma'# The strings section is similar to the paths section - but rather than defining paths# on disk, it contains a list of strings. Strings are typically used when you want to be# able to configure the way data is written to ShotGrid - it may be the name field for a# review version or the formatting of a publish.strings:    nuke_shot_version_name: '{Shot}_{name}_{channel}_v{version}.{iteration}'    nuke_asset_version_name: '{Asset}_{name}_{channel}_v{version}.{iteration}'示例：多根目录模板格式## The keys section contains the definitions for all the different keys that are being# used in the Toolkit. A key is a magic token that is replaced by a value at runtime, for example# {Shot}. The section below tells the Toolkit which data types and formats to expect for each key.#keys:    Sequence:        type: str    Shot:        type: str    Step:        type: str    sg_asset_type:        type: str    Asset:        type: str    name:        type: str        filter_by: alphanumeric    iteration:        type: int    version:        type: int        format_spec: '03'    version_four:       type: int       format_spec: '04'       alias: version    timestamp:        type: str    width:        type: int    height:        type: int    channel:        type: str        filter_by: alphanumeric    SEQ:        type: sequence        format_spec: '04'    eye:        type: str# The paths section contains all the the key locations where files are to be stored# by the Toolkit Apps. Each path is made up of several keys (like {version} or {shot}) and# these are defined in the keys section above.# Toolkit apps use these paths as part of their configuration to define where on disk# different files should go.paths:    ##########################################################################################    # Shot pipeline / Maya    shot_root: 'sequences/{Sequence}/{Shot}/{Step}'    # define the location of a work area    shot_work_area_maya:      definition: '@shot_root/work/maya'      root_name: primary    # define the location of a publish area    shot_publish_area_maya:      definition: '@shot_root/publish/maya'      root_name: primary    # The location of WIP files    maya_shot_work:      definition: '@shot_root/work/maya/{name}.v{version}.ma'      root_name: primary    # The location of backups of WIP files    maya_shot_snapshot:      definition: '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'      root_name: primary    # The location of published maya files    maya_shot_publish:      definition: '@shot_root/publish/maya/{name}.v{version}.ma'      root_name: primary    ##########################################################################################    # Asset pipeline / Maya    asset_root: 'assets/{sg_asset_type}/{Asset}/{Step}'    # define the location of a work area    asset_work_area_maya:      definition: '@asset_root/work/maya'      root_name: secondary    # define the location of a publish area    asset_publish_area_maya:      definition: '@asset_root/publish/maya'      root_name: secondary    # The location of WIP files    maya_asset_work:      definition: '@asset_root/work/maya/{name}.v{version}.ma'      root_name: secondary    # The location of backups of WIP files    maya_asset_snapshot:      definition: '@asset_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'      root_name: secondary    # The location of published maya files    maya_asset_publish:      definition: '@asset_root/publish/maya/{name}.v{version}.ma'      root_name: secondary# The strings section is similar to the paths section - but rather than defining paths# on disk, it contains a list of strings. Strings are typically used when you want to be# able to configure the way data is written to ShotGrid - it may be the name field for a# review version or the formatting of a publish.strings:    # when a review version in ShotGrid is created inside of nuke, this is the    # name that is being given to it (the code field)    nuke_shot_version_name: '{Shot}_{name}_{channel}_v{version}.{iteration}'    nuke_asset_version_name: '{Asset}_{name}_{channel}_v{version}.{iteration}'模板文件有多个配置选项，您可以在此处找到完整的参考。模板文件中的 @include 语法为了减少模板文件中的重复内容，您可以重复使用字段：paths:    asset_root: 'assets/{sg_asset_type}/{Asset}/{Step}'    maya_asset_work: '@asset_root/work/maya/@maya_asset_file'strings:    maya_asset_file: '{name}.v{version}.ma'您还可以将模板拆分到多个文件，在文件中包含其他文件。有关完整详情，请参见参考文档。在模板文件中包含外部文件在管理环境配置时，您可以将环境配置拆分成多个文件，然后将一些文件包含在另一些文件中。对于模板文件，您也可以采用这种方式。这种做法有时很有用，例如当您要设置一个全局配置供多个项目共享时。您可以使用以下 include 语法之一，在 templates.yml 文件中包含其他文件：# single include using a path local to the location of the current fileinclude: './include_file.yml'# multiple incudes, processed in orderincludes: ['./include_file_1.yml', './include_file_2.yml']# you can also use absolute paths when including things:include:# files that are not recognized are skipped, so you can put paths for# windows and linux next to each other for multi platform support:includes: ['/foo/bar/hello.yml', 'z: foo bar hello.yml']# you can use environment variables inside of full paths tooincludes: ['$STUDIO_ROOT/foo/bar/hello.yml', '%STUDIO_ROOT% foo bar hello.yml']包含的文件需要与主 templates.yml 文件结构相同，也就是说它需要包含 paths、keys 和 strings 部分。Toolkit 处理包含的文件时，会按照从上到下、深度优先的顺序以递归方式读取它们，分别向 paths、keys 和 paths 这三个“区块”添加数据。在这个过程中，如果某个值在某个区块中已存在，该值将被覆盖。处理完所有包含的文件后，将对整个配置进行验证。下面是一个简短的示例。这是主 templates.yml 文件：include: ./global_defs.ymlkeys:    name:        type: str        filter_by: alphanumeric    version:        type: int        format_spec: &quot;03&quot;paths:    maya_shot_work: '@shot_root/work/maya/{name}.v{version}.ma'这是包含的文件 global_defs.yml 的内容：keys:    Sequence:        type: str    Shot:        type: str    Step:        type: strpaths:    shot_root: sequences/{Sequence}/{Shot}/{Step}建议将 keys 和 paths 部分放在一起（但并不总是适合如此），以便每个文件都包含各自需要的所有内容。这样通常可以让维护工作更简单。文件夹创建和模板创建模板时，如果模板引用了文件夹创建系统创建的文件夹，您需要使用 ShotGrid API 风格的表示法指定字段！这个细节很容易被忽视。上面的示例很好地说明了这一点。在文件夹创建过程中，我们已设置了一个配置，先后按资产类型和资产名称对项进行分组。例如：/mnt/projects/my_project/assets/character/Hero然后，我们要在 Toolkit 中创建一个与此路径一致的模板。为了让 ShotGrid Toolkit 能够保持模板与路径和上下文一致，字段的命名方式需要与使用 ShotGrid API 时相同 - 资产类型一级的文件夹需要称为 sg_asset_type，因为这是此字段在 ShotGrid 中的字段名称，资产一级的文件夹需要称为 Asset（首字母 A 大写），因为使用 ShotGrid API 时，会这样称呼资产实体类型。挂钩挂钩是灵活的 Toolkit 配置片段。通常，在配置应用、插件或核心 API 时，您会指定一组参数来定义某些功能的行为。但是，这种做法有时不够强大，这种情况下就要用到挂钩。 挂钩是小段的 Python 代码，可用来自定义应用、插件或核心的某个方面。挂钩的设计已尽量做到轻量化和原子化。在 Toolkit 中，挂钩分为三个不同的级别。请阅读下面的小节了解有关每个级别的详细信息。应用级挂钩每个 Toolkit 应用（包括插件）都附带一组设置，其中一些可以是挂钩。每个应用都有一组默认挂钩，除非特别进行改写，否则将自动使用这些挂钩。挂钩通常用来进行一些特别针对应用程序的自定义。例如，对于一个向 Maya 加载图像的 Toolkit 应用来说，用户界面代码和所有交互逻辑都位于应用中，实际向 Maya 加载图像的小块业务逻辑则位于一个挂钩中。这让工作室可以自定义应用的行为；默认挂钩可在 Maya 中创建标准纹理节点，而想要使用不同节点类型的工作室则可改写该挂钩，轻松改变整个应用的行为，而且不必重新编写任何代码！自定义应用挂钩时，通常的做法是将默认挂钩从应用的 hooks 文件夹复制到您项目的 hooks 文件夹中。接下来，需要在环境文件内更新应用设置，让它读取您的新挂钩，而不是默认挂钩。您的自定义挂钩将自动继承应用随附的默认挂钩的设置，这样可轻松进行细微的参数更改和调整，同时仍保留默认挂钩中的大部分业务逻辑。有关挂钩继承性的详细信息，请参见环境配置参考。核心级挂钩使用核心挂钩可更改 Toolkit 中的系统级行为。核心级挂钩全部以项目为单位进行改写，因此每个项目需要单独设置改写 （如果您在设置新项目时总是重用相同的配置，这种方式通常比较直观）。核心配置区包含一个特殊的 hooks 文件夹。您可以将某些核心挂钩的自定义执行放在这里。核心挂钩与应用级挂钩类似，通过它可从 Toolkit 提取代码片段并对其进行自定义。核心 API 允许您改写许多不同的核心行为，包括文件系统 I/O、文件夹创建和文件系统结构的验证。默认情况下，Toolkit 将直接从 API 文件夹中选取需要的核心挂钩。如果您要自定义此行为，可将挂钩文件复制到您的配置中的 config/core/hooks 区域。然后修改代码。有关可用核心挂钩的列表，请查看核心 API 内的 hooks 文件夹。每个挂钩都包含大量介绍其用途和修改方法的文档。工作室级挂钩除了上面的挂钩以外，还有几个非常特殊的挂钩，我们称之为“工作室级挂钩”。 这些挂钩是可影响所有内容的全局挂钩。这些挂钩控制 Toolkit 中不属于任何特定项目的方面。项目名称挂钩项目设置过程将提示您为项目输入一个“磁盘名称”，并会根据 ShotGrid 中的项目名称建议一个名称，但空格及其他与文件系统不兼容的字符会被替换为下划线。该磁盘名称将是存储项目数据和配置的文件夹的名称。指定磁盘名称时，可以使用斜杠。这将生成一个项目根点，该根点在深度上横跨若干个文件夹。当工作室按领域（商业广告、视觉特效等）组织项目时，或者工作室项目量很大，导致在文件系统中使用单层结构难以概览全貌时，根点会很有帮助。请注意，您应该始终使用正斜杠（“/”）。在 Windows 上，Toolkit 会做出必要的调整。配合使用上面介绍的多级文件夹，还可以自定义 Toolkit 在设置过程中建议的名称。此操作在一个特殊的工作室级挂钩中进行。如果您想自定义此行为，可在工作室 API 所在位置内的 config/core 文件夹中创建一个名为 project_name.py 的文件。此文件夹应该已包含 install_location.yml、app_store.yml 和 shotgun.yml 等文件。project_name.py 挂钩文件可以如下所示：from tank import Hookimport osclass ProjectName(Hook):    def execute(self, sg, project_id, **kwargs):        &quot;&quot;&quot;        Gets executed when the setup_project command needs a disk name preview.        &quot;&quot;&quot;        # example: create a name based on both the sg_type field and the name field        sg_data = sg.find_one(&quot;Project&quot;, [[&quot;id&quot;, &quot;is&quot;, project_id]], [&quot;name&quot;, &quot;sg_type&quot;])        # create a name, for example vfx/project_x or commercials/project_y        name = &quot;%s/%s&quot; % ( sg_data[&quot;sg_type&quot;], sg_data[&quot;name&quot;] )        # perform basic replacements        return name.replace(&quot;_&quot;, &quot;/&quot;).replace(&quot; &quot;, &quot;/&quot;)连接挂钩Toolkit 会存储连接设置，以便可以连接到其关联的 ShotGrid 实例。有时候，能够动态地控制这些连接设置可能会有所帮助。这种情况下，可在工作室 API 所在位置内的 config/core 文件夹中创建一个名为 sg_connection.py 的挂钩文件。此文件夹应该已包含 install_location.yml、app_store.yml 和 shotgun.yml 等文件。从 shotgun.yml 和 app_store.yml 配置文件读入 ShotGrid 连接设置后，会调用此挂钩。使用此挂钩，可以轻松对连接设置进行程序化修改，例如根据某些外部环境变量设置代理服务器。下面三个参数将传递给该挂钩：      config_data 是一个词典，其中包含已读入的 ShotGrid 配置文件中的设置。它通常包含 host、api_script、api_key 和 http_proxy 键。        user 是与连接信息关联的用户档案。这是一项高级设置，几乎总是设置为 defualt。        cfg_path 是从中加载 config_data 的配置文件的路径。  挂钩需要返回一个与 config_data 相同形式的词典。如果您要自定义代理设置，请注意返回的代理字符串格式应该与 ShotGrid API 构造函数需要的格式相同，例如 123.123.123.123、123.123.123.123:8888 或 username:pass@123.123.123.123:8888。下面这个示例执行可以作为您的设置基础：from tank import Hookimport osclass CustomShotunConnection(Hook):    &quot;&quot;&quot;    Allows for post processing of ShotGrid connection data prior to connection    &quot;&quot;&quot;    def execute(self, config_data, user, cfg_path, **kwargs):        # explicitly set the proxy server setting        config_data[&quot;http_proxy&quot;] = &quot;123.123.123.123&quot;        return config_data配置应用和插件现在，我们有了一个设置好的模板文件，其中定义了所有关键的磁盘位置。接下来，可以开始决定要在配置中包括哪些应用和插件。正如介绍性文档的其他部分所述，应用和插件的配置细分为若干个系列环境。本质上讲，环境是可供选择的配置 - 您很可能会需要提供不同的应用套件，并且这些应用需要针对不同工作（例如镜头工作和资产工作）进行不同配置，因此环境是一项非常实用的功能。对于更复杂的工作流，您可能需要按部门进一步细分它，让建模工作使用与装配工作不同的设置。这些全部通过环境来实现。环境文件定义了一些可能用到的插件，并将根据您正在运行的应用程序，使用其中一个部分。例如，如果您运行的是 Maya，将指示 Toolkit 启动“tk-maya”插件。ShotGrid Toolkit 会首先确定要使用的环境（基于当前工作区），然后在这个环境中查找 tk-maya 插件。如果能找到该插件，Toolkit 将加载为此部分定义的所有应用。每个应用都有一些可以配置的设置。当您安装或升级应用时，ShotGrid Toolkit 会要求您配置所有无默认值的设置。Toolkit 应用通常采取可重用设计，因此根据设置方式的不同，应用可以有很多不同的用法，并且可用在许多不同的工作流中。您甚至可以在同一环境中多次定义同一应用。例如，您可以在 Maya 菜单上显示两个发布器，一个用来发布装配，另一个用来发布模型。两者都使用同一发布应用，只是配置不同。示例：环境文件include: ./includes/app_launchers.ymlengines:  # 3dsmax engine  tk-3dsmax:    debug_logging: false    location: {name: tk-3dsmax, type: app_store, version: v0.2.6}    # all the registered apps for this engine    apps:      tk-multi-about:        location: {name: tk-multi-about, type: app_store, version: v0.1.8}      tk-multi-loader-texture:        dependency_mode: false        hook_add_file_to_scene: default        location: {name: tk-multi-loader, type: app_store, version: v0.2.6}        menu_name: Load Texture...        publish_filters: []        sg_entity_types:          Asset: []        single_select: true        tank_types: [Diffuse Texture, Specular Texture]      tk-multi-publish:        display_name: Publish        hook_copy_file: default        hook_post_publish: default        hook_primary_pre_publish: default        hook_primary_publish: default        hook_scan_scene: default        hook_secondary_pre_publish: default        hook_secondary_publish: default        hook_thumbnail: default        location: {name: tk-multi-publish, type: app_store, version: v0.2.5}        primary_description: Publish and version up the current 3ds Max scene        primary_display_name: 3ds Max Publish        primary_icon: icons/publish_3dsmax_main.png        primary_publish_template: max_shot_publish        primary_scene_item_type: work_file        primary_tank_type: 3dsmax Scene        secondary_outputs: []        template_work: max_shot_work      tk-multi-screeningroom: '@launch_screeningroom'      tk-multi-snapshot:        hook_copy_file: default        hook_scene_operation: default        hook_thumbnail: default        location: {name: tk-multi-snapshot, type: app_store, version: v0.1.15}        template_snapshot: max_shot_snapshot        template_work: max_shot_work      tk-multi-workfiles:        hook_copy_file: default        hook_scene_operation: default        location: {name: tk-multi-workfiles, type: app_store, version: v0.2.5}        sg_entity_types: [Shot, Asset]        template_publish: max_shot_publish        template_publish_area: shot_publish_area_max        template_work: max_shot_work        template_work_area: shot_work_area_max  # the maya engine  tk-maya:    debug_logging: false    location: {name: tk-maya, type: app_store, version: v0.2.7}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: File Manager...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}    - {app_instance: tk-multi-workfiles, name: Save As...}    - {app_instance: tk-multi-publish, name: Publish...}    template_project: shot_work_area_maya    # all the registered apps for this engine    apps:      tk-maya-breakdown:        hook_multi_update: default        hook_scan_scene: default        location: {name: tk-maya-breakdown, type: app_store, version: v0.2.7}      tk-multi-about:        location: {name: tk-multi-about, type: app_store, version: v0.1.8}      tk-multi-loader-1:        dependency_mode: false        hook_add_file_to_scene: default        location: {name: tk-multi-loader, type: app_store, version: v0.2.6}        menu_name: Load Assets...        publish_filters: []        sg_entity_types:          Asset: []        single_select: true        tank_types: [Maya Model, Maya Rig]      tk-multi-loader-2:        dependency_mode: false        hook_add_file_to_scene: default        location: {name: tk-multi-loader, type: app_store, version: v0.2.6}        menu_name: Load Shots...        publish_filters: []        sg_entity_types:          Shot: []        single_select: true        tank_types: [Maya Anim, Maya Lighting, Maya Scene]      tk-multi-publish:        display_name: Publish        hook_copy_file: default        hook_post_publish: default        hook_primary_pre_publish: default        hook_primary_publish: default        hook_scan_scene: default        hook_secondary_pre_publish: default        hook_secondary_publish: default        hook_thumbnail: default        location: {name: tk-multi-publish, type: app_store, version: v0.2.5}        primary_description: Publish and version up the current Maya scene        primary_display_name: Maya Publish        primary_icon: icons/publish_maya_main.png        primary_publish_template: maya_shot_publish        primary_scene_item_type: work_file        primary_tank_type: Maya Scene        secondary_outputs: []        template_work: maya_shot_work      tk-multi-screeningroom: '@launch_screeningroom'      tk-multi-setframerange:        location: {name: tk-multi-setframerange, type: app_store, version: v0.1.2}        sg_in_frame_field: sg_cut_in        sg_out_frame_field: sg_cut_out      tk-multi-snapshot:        hook_copy_file: default        hook_scene_operation: default        hook_thumbnail: default        location: {name: tk-multi-snapshot, type: app_store, version: v0.1.15}        template_snapshot: maya_shot_snapshot        template_work: maya_shot_work      tk-multi-workfiles:        hook_copy_file: default        hook_scene_operation: default        location: {name: tk-multi-workfiles, type: app_store, version: v0.2.5}        sg_entity_types: [Shot, Asset]        template_publish: maya_shot_publish        template_publish_area: shot_publish_area_maya        template_work: maya_shot_work        template_work_area: shot_work_area_maya每个应用各有一个 location 设置环境文件中的每一项都有一个特殊的 location 令牌。此令牌定义 Toolkit 应从哪里提取应用代码，以及如何检查应用是否有新版本。例如，我们可以像下面这样定义 location 令牌：location: {name: tk-multi-setframerange, type: app_store, version: v0.1.2}type 指示此应用来自应用商店，正在使用某个特定版本。当您运行更新检查时，ShotGrid Toolkit 会连接到应用商店，检查是否有比 v0.1.2 更新的版本，如果有的话，将询问您是否要升级。Toolkit 支持几种不同的 location 类型，包括 Git 和 GitHub，因此您可以构建自己的应用，使用 Git 跟踪它们，并且当您在 Git 中创建了新标记时，更新程序会检测到它，并在升级检查中正确处理它。有关详细信息，请参见参考文档。包含文件您可以在环境文件中包含外部文件。这对于集中处理设置或管理改写来说，往往非常有用：      您可以对配置进行组织，使得即使从多个环境启动 Maya，也能在一处管理应用程序（Maya、Nuke）的所有文件路径。        对于在许多环境中都采用相同设置的应用，可以在一处定义它们。        您可以维护一个“中央”工作流配置，让多个项目共享这个配置。每次更新它时，所有项目都将随之更新。如果今后项目需要特殊的行为，每个项目都可以改写或扩展包含的这个中央配置。        您可以包含来自您的上下文的文件，将它们作为改写项。也就是说，您可以逐个镜头或逐个资产地重新配置设置参数。如我们的默认配置中所示，您可以在其中逐个镜头或逐个资产地设置改写 Maya、Nuke 等应用程序的路径。        如果您在完整路径中使用环境变量，这些路径将会自动展开。请注意，在 Linux 上，它们的形式必须为 $ENV_VAR 而不是 ${ENV_VAR}，因为这会对 include 解析器造成混淆。示例：includes: ['$STUDIO_ROOT/foo/bar/hello.yml', '%STUDIO_ROOT% foo bar hello.yml']。  示例：为应用启动进行的特定于镜头的改写假设您的 Shell 插件具有以下环境文件：include: ./includes/app_launchers.ymlengines:  tk-shell:    debug_logging: false    location: {name: tk-shell, type: app_store, version: v0.3.0}    apps:        tk-multi-launch3dsmax: '@launch_3dsmax'        tk-multi-launchmaya: '@launch_maya'        tk-multi-launchmotionbuilder: '@launch_motionbuilder'        tk-multi-launchnuke: '@launch_nuke'        tk-multi-launchphotoshop: '@launch_photoshop'其中每个应用都是参考，在 app_launchers 包含文件中进行定义。此文件包含每个应用的实际应用配置，内容如下所示：includes:    # first include the configuration's global settings for application paths    - ./paths.yml    # now include overrides - these will be loaded if they are found    - sequences/{Sequence}/{Shot}/sgtk_overrides.yml    - assets/{sg_asset_type}/{Asset}/sgtk_overrides.ymllaunch_3dsmax:  engine: tk-3dsmax  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: ''  linux_path: ''  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.4}  mac_args: ''  mac_path: ''  menu_name: Launch 3DSMax  windows_args: ''  windows_path: '@3dsmax_windows'launch_maya:  engine: tk-maya  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: ''  linux_path: '@maya_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.4}  mac_args: ''  mac_path: '@maya_mac'  menu_name: Launch Maya  windows_args: ''  windows_path: '@maya_windows'上面的文件不包含 Maya、Nuke 等应用程序的任何实际路径。这些路径在单独的 paths.yml 文件中定义：# mayamaya_windows: 'C: Program Files Autodesk Maya2012 bin maya.exe'maya_mac: /Applications/Autodesk/maya2012/Maya.appmaya_linux: maya# nukenuke_mac: /Applications/Nuke6.3v8/Nuke6.3v8.appnuke_windows: 'C: Program Files Nuke6.3v8 Nuke6.3.exe'nuke_linux: Nuke6.3注意 app_launchers 文件是如何先包含上面的文件，然后又包含了 sequences/{Sequence}/{Shot}/sgtk_overrides.yml。这是一个特定于上下文的文件路径，就像模板一样，因此它会尝试对照当前上下文解析该路径。如果解析成功，它会查找并载入该路径。这意味着您可以在镜头位置创建一个 sgtk_overrides.yml，然后只改写特定镜头的应用程序路径：# mayamaya_windows: 'C: Program Files Autodesk Maya2012 bin special_maya.exe'这里我们使用的是 Windows 上的一个特别的 Maya 版本。其余的路径将是 paths.yml 文件中定义的原始路径。有关 include 如何工作的更多详细信息，请参见参考文档。配置模板设置 - 文件路径很多应用都会用到的一个重要设置类型是 template 设置。需要指定文件系统位置的应用将会使用这些设置。应用的开发要具有通用性或灵活性，设计上要能够用于任何文件系统结构或命名约定。而模板就是让应用能够独立于底层文件系统的关键所在。有关这方面的详细信息，请参见概念简介。在配置应用和遇到模板设置时，您需要指定包含正确字段的模板。字段可分为必需和可选两种类型，必需字段是模板中必须包含的字段，可选字段则是模板中可以包含、但即使模板中未定义也不会影响应用正常运行的字段。应用运行时，会根据您在配置中指定的模板来创建路径。创建的这些路径将以当前上下文和应用逻辑提供的一组字段为依据。这意味着，如果您的模板中有任何字段既不属于上下文，也不属于应用的可选字段或必需字段，应用将不知道如何为该字段设置值，因此将无法正常工作。Toolkit 会通过在启动时验证配置来避免发生这种情况。验证模板设置时，Toolkit 会首先检查上下文，将上下文给定的字段与模板中的字段进行比较。如果比较上下文后发现字段列表与应用的必需/可选参数定义不一致，将弹出验证错误。实际示例：快照应用下面这个实际示例说明了此验证是如何进行的。我们来看一下 Toolkit 众多应用中的 快照应用：此应用使用许多模板设置。下面是应用的设置明细部分定义的一项设置：  设置名称：template_snapshot  类型：template  必需模板键：version  可选模板键：name、timestamp、increment  说明：引用一个模板，该模板将定义快照备份在磁盘上的存储位置。除了运行时上下文提供的字段以外，此模板设置还需要一个包含 version 字段的模板。另外，它还可包含可选的 name、timestamp 或 increment 字段，但不能再包含其他任何字段。例如：假设您为一个镜头的某个任务启动 Maya。上下文随后会包含以下字段：  当前项目已设置。  当前实体（例如镜头）已设置。  当前步骤已设置。  当前任务已设置。插件启动时，会验证配置。下面这些例子说明了为上面的 template_snapshot 字段使用不同设置将会怎样：      模板 sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{version}.ma 将是快照应用的 template_snapshot 设置可以使用的有效模板：          Sequence、Shot 和 Step 由上下文填充。注意，因为上下文知道当前镜头是什么，所以它可以自动得知当前镜头序列是什么（因为这是文件系统中的一个父文件夹）。      模板中有一个应用设置所需要的 version 字段。      模板中有一个可选的 name 字段。      除此以外没有其他字段。            模板 assets/{Asset}/work/maya/{name}.v{version}.ma 将是无效模板，因为（镜头）上下文不知道如何解析 Asset 字段。        模板 sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.ma 将是无效模板，因为它缺少必需的 version 字段。        模板 sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{version}.{extension} 将是无效模板，因为字段 extension 是未知字段，应用不知道如何填充它。  使用挂钩自定义应用的行为应用经常使用的另一个设置类型是 hook 设置类型。挂钩是一段代码，应用将在正常执行过程中执行它。使用挂钩可以对应用进行非常灵活的自定义，并且意味着可将应用的某些业务逻辑与实际的应用代码相分离。例如，假设我们有一个明细应用，它需要扫描场景中的各种参考和文件输入。对于 Maya，我们可以提供一个默认行为来处理 Maya 提供的标准参考节点，但如果工作室使用的是自定义类型的参考节点，该怎么办？当然，工作室总是可以选择在 GitHub 中 Fork 这个应用，但是鉴于他们其实只是想将自定义的节点类型添加到用来在场景中扫描参考节点的代码中，这样做就显得有些小题大作。其实，细分应用可以将场景扫描代码片段执行成一个挂钩。这样，该挂钩实际上就是一个设置，是应用配置的一部分。它将附带一个默认值，用来处理一般的 Maya 情况，因此这个挂钩是开箱即用的。但是，如果用户需要，也可以轻松配置 ShotGrid Toolkit 来完全更改此行为。应用安装后，配置中的挂钩设置将全部显示为默认值 (default)。 这表示应用将使用应用随附的内置挂钩执行。我们以下面的启动器应用配置为例：launch_maya:  engine: tk-maya  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: ''  linux_path: '@maya_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.4}  mac_args: ''  mac_path: '@maya_mac'  menu_name: Launch Maya  windows_args: ''  windows_path: '@maya_windows'可以看到，这里有两个挂钩，分别是 hook_app_launch 和 hook_before_app_launch，二者都使用默认的应用执行。这两个挂钩的作用是让工作室可以自定义启动过程、设置环境变量等。要自定义这些挂钩，首先需要找到它们的原始执行。每个应用都有一个 hooks 文件夹，所有挂钩都注册在此文件夹中。接下来，选择想要自定义的挂钩，然后将该挂钩复制到您的配置中的 hooks 文件夹。进行必要的代码更改。此时，环境配置的挂钩设置仍然是 default，只要是这样，配置就会选取应用随附的默认挂钩，而不是其他挂钩。要让配置选取您的新设置，请将 default 更改为配置 hooks 文件夹中 Python 挂钩文件的名称。示例：如何自定义挂钩下面我们来简单介绍一下如何自定义应用启动器的 hook_before_app_launch 挂钩。      复制默认的挂钩执行。参见上图可找到应用随附的默认挂钩的位置。将此文件复制到您的配置区的 hooks 文件夹中。例如，如果您的工作流配置位于 /mnt/software/sgtk/big_buck_bunny，将该文件复制到 /mnt/software/sgtk/big_buck_bunny/config/hooks/before_app_launch.py。        对 Python 代码进行必要的更改。        最后，更新环境配置以使用您的新代码：  yaml launch_maya: engine: tk-maya extra: {} hook_app_launch: default hook_before_app_launch: before_app_launch # &amp;lt;-- uses custom hook! linux_args: '' linux_path: '@maya_linux' location: {name: tk-multi-launchapp, type: app_store, version: v0.2.4} mac_args: '' mac_path: '@maya_mac' menu_name: Launch Maya windows_args: '' windows_path: '@maya_windows'下次运行启动器应用时，将执行您的代码，而不是默认的挂钩代码。",
    "url": "/425b1da4/",
    "relUrl": "/425b1da4/"
  },
  "8": {
    "id": "8",
    "title": "配置设置",
    "content": "配置快速入门完成本手册后，您将获得以下方面的基础知识：将项目信息添加到配置中、将该配置与您的项目关联起来、准备要自定义的工作流配置。关于本手册本手册介绍如何使用 ShotGrid Desktop 中的高级项目设置向导为数字内容制作工作流创建配置。您将很快熟悉配置工具，了解如何使用向导，并有机会了解更多信息。使用向导为项目创建工作流配置，并准备对其进行编辑和扩展，以便支持工作流中的每个工序。配置控制 UI 的各个方面、ShotGrid 应用以及支持制作工作流所需的各种工具。使用向导只是扩展配置的方法之一。除了为工作流中的每个工序添加特定设置外，它还将添加与软件应用程序的集成。在本手册中，我们将根据 Toolkit 默认配置来配置项目。本手册假定用户：  从未使用过高级项目设置向导  对如何使用 ShotGrid 有基本的了解  是 ShotGrid Toolkit 新手使用本文档要使用本手册并为项目创建可自定义的配置，需要以下内容：  有效的 ShotGrid 站点。您可以在此处注册 ShotGrid 并获取 30 天试用版以开始探索。  ShotGrid 桌面。 如果未安装 Desktop，则可以单击此链接开始。  可用于存储项目文件和工作流配置的文件系统的访问权限。在该 Shotgun 管理的文件系统上，创建一个名为 Shotgun 的文件夹，其中包含两个文件夹 projects 和 configs。关于高级项目设置向导ShotGrid Desktop 中的“高级项目设置向导”会根据默认配置生成工作流配置。默认配置可以为构建提供坚实基础，其中带有支持工作流的可自定义设置、应用和 UI 元素。它会创建一个配置，您可以对其进行编辑和扩展来满足项目的工作流需求。默认配置包含：  基本文件系统数据结构和模板，用于确定文件在磁盘上的位置  所有支持的软件集成，允许直接在用户的软件应用程序内与 ShotGrid 和工作流功能进行交互。只要您敢于突破想象，勤于思考，充分运用自己的编程知识，或者善于借用 ShotGrid 社区集思广益，就会发现 Toolkit 自定义的无限可能。创建配置每个项目都需要一个配置。第一次通过 ShotGrid Desktop 访问项目时，将下载并配置基本配置。此基本配置会自动检测用户在其系统上安装的受支持的内容创建软件，并将配置与项目相关联。工作流配置中的设置监管受支持软件应用程序中的集成。面板应用显示 ShotGrid 的项目信息，并使艺术家可以回复注释和查看版本，而无需退出其工作会话。发布器应用允许艺术家将其作品提供给团队中的其他人使用，通过加载器应用，艺术家可以加载其队友发布的文件。基本配置不包括文件系统管理设置，也不支持文件或者目录命名的模板开发。它也不会像配置默认配置那样，需要添加大量的应用工具。它是一个简单的配置，允许在不对配置文件进行任何手动编辑的情况下运行 Toolkit。向导将基本配置替换为默认配置。它提供了更多的应用和软件集成，以支持您开始工作。虽然也可以编辑基本配置，但只有在您拥有高级设置后，才能设置项目以进行自定义。基本配置和默认配置之间的差异            功能      基本配置      默认配置                  下载      访问项目时自动下载      通过“高级设置”向导创建              可访问性      存储在系统位置      可手动编辑的文件              更新      自动更新      手动更新              文件系统支持      不支持文件系统数据结构      包含用于支持文件夹结构和文件命名标准的工具              软件集成      3ds Max、Houdini、Maya、Nuke、Photoshop、Flame      基本 + Hiero、Motionbulder、Mari              Toolkit 应用      ShotGrid 面板、发布器、加载器      基本 + 工作文件、快照、场景细分、Nuke 写入节点、Houdini Mantra 节点等      在本手册中，您将使用 ShotGrid Desktop 中的向导，根据默认配置为项目生成工作流配置。生成此配置将使您能够进行支持专用制作工作流所需的自定义。开始练习准备使用默认配置步骤 1：在 ShotGrid 中创建一个名为“the_other_side”的新项目。步骤 2：启动 ShotGrid Desktop 应用，并使用 ShotGrid 站点的用户名和密码登录。步骤 3：选择项目缩略图，点击跳转到需要运行“高级项目设置向导”的项目页面。                    提示: 如果在 Desktop 打开时创建了新项目，则可能需要刷新“项目”(Projects)窗口才能看到新项目。在桌面右下角选择您的个人资料头像，然后选择“Refresh Projects”。    访问默认配置Desktop 在加载项目页面时，自动下载和配置基本配置，并自动检测和添加 Publish 应用，以及系统中已安装的受支持的软件包。基本配置完成后，Publish 应用和已安装软件会被自动添加到 ShotGrid Desktop 的“应用”(Apps)窗格中。步骤 4：加载项目后，在屏幕右下角选择您的个人资料头像。在弹出菜单中，选择“Advanced project setup…”以启动向导。此时将显示一个对话框，其中包含四个选项，“ShotGrid Default”处于选中状态。此时，除了默认选择的“Shotgun Default”，您还可以选择根据现有其他项目的配置、Git 库配置或从磁盘路径选择配置文件来配置该项目的工作流。对于本练习，我们将选择“ShotGrid Default”。此选项将根据 ShotGrid 默认配置为您的项目创建工作流配置。步骤 5：选择“继续”(Continue)。此时将显示一个对话框，其中包含两个选项，“默认”(Default)处于选中状态。此时，有一个用于选择旧版默认配置设置的选项。此配置设置来自旧版 ShotGrid，适用于仍使用相应版本的工作室。我们将在本练习中使用“默认”(Default)。步骤 6：选择“继续”(Continue)。定义项目文件的存储位置此时将显示一个对话框，在 Storage: 一词旁边将显示一个下拉菜单步骤 7：标识此项目的项目数据的存储位置。从对话框顶部的下拉列表中选择“+ 新建”(+ New)，并在字段中键入 projects。ShotGrid Toolkit 支持三种操作系统：Linux、Mac 和 Windows。步骤 8：选择用于存储项目数据的操作系统旁边的字段。选择文件夹图标，并导航到在本练习之前在 Shotgun 管理的文件系统上创建的项目文件夹。此设置使 ShotGrid 只能访问您标识用于存储制作数据的文件夹。在准备本练习时，您在 ShotGrid 根目录中添加了一个 projects/ 目录。projects/ 目录是 Toolkit 用于存储任何本地项目相关信息的位置。步骤 9：选择“保存”(Save)以将项目文件夹标识为项目数据的存储位置。操作系统路径会自动更新，以标识项目数据的存储路径。步骤 10：选择“继续”(Continue)。命名项目文件夹将显示一个对话框，其中包含填充文本字段的项目名称。该名称是使用项目信息自动填充的，路径将自动更新。Toolkit 既适用于分布式设置，又适用于集中式设置。在分布式设置中，工作流配置上传到 ShotGrid 并在本地为每个用户缓存；在集中式设置中，用户可以在磁盘上的共享位置访问单个配置。对于本练习，我们将使用集中式设置。您可以在此处了解有关分布式设置的详细信息。最后一步生成创建特定于项目的配置所需的相应文件夹、文件和数据。步骤 11：在相应的操作系统下，选择“浏览…”(Browse…)并导航到您在准备本练习时创建的配置文件夹 configs，然后输入项目名称 the_other_side。这将创建存储项目配置的文件夹。选择“Run Setup”并等待设置完成。步骤 12：选择“完成”(Done)以显示填充项目窗口的新图标。提示：将应用固定到菜单栏以便快速访问 ShotGrid Desktop：选择您的头像并选择“Pin to Menu”。完成上述任务；项目设置已完成。现在，根据默认配置，在指定的位置为您的项目提供了 Toolkit 工作流配置，您可以开始进行自定义。查看 configs 文件夹，您会发现几个文件夹和文件。可以看一看里面的内容。现在，真正有趣的事情开始了：了解通过配置可以执行的所有任务。下面是一些要探索的高级主题。高级主题ShotGrid Toolkit 提供了许多便利的方法来编辑、克隆或接管配置。扩展现有配置可以节省时间，并使您可以访问网络中其他人创建的所有炫酷素材。您可以利用内容丰富的 ShotGrid 社区，其中可能包含您需要的精确配置。ShotGrid 社区是一个共享社区，应该与人为善，心怀感恩，赞赏创建了配置并帮助您完成工作的用户。对了，别忘了提供反馈，这就是我们帮助其他 ShotGrid 用户并成为此社区一员的亮点！下面是一些与配置相关的操作。使用命令行创建默认配置在任何项目配置中，tank 命令允许您从终端运行管理命令。每个项目都有自己的专用 tank 命令。tank setup_project 命令的功能类似于“高级设置向导”：它根据现有项目的配置或默认配置在磁盘上为您的项目创建一个可编辑的配置。您可以在此处了解有关运行 tank setup_project 的详细信息，并在此处了解有关 tank 命令的详细信息。编辑制作活动中的配置有时，您想要修改当前处于制作活动中的配置，但是不想在艺术家使用该配置时编辑它。只需几个命令，ShotGrid 就能提供一种复制现有配置的方法，从而可以安全地测试您的修改，然后再将这些修改推送到制作活动中。此过程将制作配置替换为新配置，并自动备份旧配置。您希望处理配置副本的原因是：  更新配置  在实施之前测试某些修改  升级或添加一些应用  进行开发并在测试后将其推出要了解有关克隆配置的信息以及配置管理的其他基础知识，请参考“配置临时沙盒和推行应用”文档。工作流配置的在线分布本手册将逐步创建一个集中式配置：位于共享网络位置的单个工作流配置副本，供所有用户访问。但是，如果您的员工分布在不同地点和网络，则共享工作流配置的单个副本可能不太可行。Toolkit 允许这种情况，方法是提供分布式配置选项，即工作流配置上传到 ShotGrid，并且每次用户访问项目时，配置都会在本地下载并缓存。您可以在我们的核心 API 开发人员文档中了解有关分布式配置的详细信息。使用多个根文件夹理想情况下，您的设施需要针对特定任务进行优化。您可以使用多个根文件夹来优化事务，例如在一台服务器上进行样片视频播放，在另一台服务器上进行交互式处理。Toolkit 允许您使用多个存储根，以便于实现上述工作流。了解如何从单存储配置转换为多存储配置。现在，已经为您的项目进行了工作流配置，可以开始编辑它了！跳转到下一个手册编辑工作流配置，以了解操作方法。",
    "url": "/5d83a936/",
    "relUrl": "/5d83a936/"
  },
  "9": {
    "id": "9",
    "title": "Alias ShotGrid 工作流",
    "content": "Alias ShotGrid 工作流这些工作流中包含使用 ShotGrid 和 Alias 进行汽车概念设计。有关更多教程，请访问：  汽车概念设计中的艺术家工作流  汽车简介教程",
    "url": "/7584b650/",
    "relUrl": "/7584b650/"
  },
  "10": {
    "id": "10",
    "title": "应用和插件配置参考",
    "content": "应用和插件配置参考本文档概述了在 ShotGrid Pipeline Toolkit 中为应用、插件和框架创建配置时可以包含的所有不同选项。在进行应用的高级配置时这很有用，而且在进行开发并需要向您的应用配置清单添加参数时可以起到很重要的作用。本文档介绍了仅当已控制 Toolkit 配置时可用的功能。有关详细信息，请参见 ShotGrid 集成管理员手册。简介本文档包含 Sgtk 的配置和设置使用的各种文件格式的规范。请注意，这只是一份概括介绍各种可用选项和参数的参考文档。有关如何管理配置的最佳实践，请参见以下文档：配置管理最佳实践ShotGrid Pipeline Toolkit 环境Toolkit 有三个主要组件：  插件 - 在宿主应用程序（如 Maya 或 Nuke）与 Sgtk 应用之间提供转换层或适配器。应用通常使用 Python 和 PySide，而插件负责以标准化方式呈现宿主应用程序，例如如果 Pyside 尚不存在的话，会在宿主应用程序之上添加 Pyside。  应用 - 提供一种业务逻辑，本质上是具有某种用途的工具。我们可以手动编写应用，让它们只在特定的宿主应用程序中工作，也可以将它们设计成可在多个宿主应用程序中运行。  框架 - 一个可供插件、应用或其他框架使用的库。利用框架，可以更轻松地管理多个应用之间共享的代码或行为。环境文件 包含一套插件、应用和框架的配置设置。这样的一套内容称为一个环境。Sgtk 会为不同文件或不同人员启动不同的环境。例如，您可以为镜头制作和装配分别准备一个环境。每个环境各有一个 yaml 文件。环境文件位于：/&amp;lt;sgtk_root&amp;gt;/software/shotgun/&amp;lt;project_name&amp;gt;/config/envyaml 文件的基本格式如下：    engines:        tk-maya:            location            engine settings                apps:                tk-maya-publish:                    location                    app settings                    tk-maya-revolver:                    location                    app settings            tk-nuke:            location            engine settings                apps:                tk-nuke-setframerange:                    location                    app settings                    tk-nuke-nukepub:                    location                    app settings        frameworks:        tk-framework-tools:            location            framework settings每个应用和插件可通过设置进行配置。这些设置与应用/插件在其 info.yml 清单文件中公开的设置列表相对应。从 Sgtk 核心 v0.18.x 开始，只有当设置与清单文件中指定的默认值不同时，才需要指定设置。除了清单文件以外，通常还可在 Toolkit 应用商店的应用/插件页面找到可配置的设置。除了可以为每个项定义的各种设置外，每个应用、插件和框架还需要定义代码的所在位置。我们使用专门的 location 参数来定义代码位置。代码位置环境文件中定义的每个应用、插件或框架各有一个 location 参数，用来定义要运行哪个版本的应用以及从哪里下载它。大多数情况下，这是由 tank updates 和 tank install 命令自动处理的。但是，如果您是手动编辑配置，则可使用各种选项帮助您部署 Toolkit 和设置结构：Toolkit 目前支持使用以下位置 描述符 来安装和管理应用：  app_store 描述符表示 Toolkit 应用商店中的内容  ShotGrid 描述符表示 ShotGrid 中存储的内容  git 描述符表示 Git 库中存储的标记  git_branch 描述符表示 Git 分支中的提交项  path 描述符表示磁盘位置  dev 描述符表示开发者沙盒  manual 描述符用于自定义部署和推行有关各描述符用法的文档，请参见 Toolkit 参考文档。禁用应用和插件有时，临时禁用应用或插件可能会对您有所帮助。建议的做法是，向用来指定应用或插件加载位置的位置词典中添加一个 disabled: true 参数。各种位置类型都支持此语法。该语法的格式如下所示：location: {&quot;type&quot;: &quot;app_store&quot;, &quot;name&quot;: &quot;tk-nukepublish&quot;, &quot;version&quot;: &quot;v0.5.0&quot;, &quot;disabled&quot;: true}另外，如果您想让应用只在某些平台上运行，可以使用特殊设置 deny_platforms 加以指定：location: {&quot;type&quot;: &quot;app_store&quot;, &quot;name&quot;: &quot;tk-nukepublish&quot;, &quot;version&quot;: &quot;v0.5.0&quot;, &quot;deny_platforms&quot;: [windows, linux]}deny_platforms 参数的值可以是 windows、linux 和 mac。设置和参数每个应用、插件或框架都显式地定义了一些设置，您可以在配置文件中改写这些设置。这些设置分为字符串、整数、列表等强类型。有关详细信息，请参见 Toolkit 参考文档。",
    "url": "/6d10dedf/",
    "relUrl": "/6d10dedf/"
  },
  "11": {
    "id": "11",
    "title": "as_template_fields() 缺少我的上下文中的现有值",
    "content": "as_template_fields() 缺少我的上下文中的现有值as_template_fields() 方法使用缓存路径，因此，如果尚未创建与模板中的键相对应的文件夹，系统将不会返回字段。发生这种情况的原因有很多：  模板定义和数据结构需要同步。如果您已经在工作流配置中修改了此模板定义或数据结构，但未同时修改二者，预期字段将不会返回。  还没有为此特定上下文创建文件夹。如果尚未创建这些文件夹，则缓存路径中将不存在匹配的记录，预期字段将不会返回。",
    "url": "/8d9d2658/",
    "relUrl": "/8d9d2658/"
  },
  "12": {
    "id": "12",
    "title": "ascii 编解码器无法解码位置 10 中的字节 0x97",
    "content": "ASCII 编解码器无法解码位置 10 中的字节 0x97: 序号不在范围内相关的错误消息：克隆配置时  TankError: 无法创建文件系统结构: ascii！编解码器无法解码位置 10 中的字节 0x97: 序号不在范围(128)内使用另一个项目设置项目配置时  “ascii 编解码器无法解码位置 10 中的字节 0x97: 序号不在范围(128)内”如何修复：通常，当“config”文件夹中出现 Unicode/特殊字符时，我们会看到这一错误。我们建议您查看一下是否可以找到特殊字符。导致此错误的原因示例：在这种情况下，错误源于 Windows 在文件名末尾添加后缀 –。在移除所有这些文件后，它开始起作用。在社区中查看完整主题。",
    "url": "/483eb2db/",
    "relUrl": "/483eb2db/"
  },
  "13": {
    "id": "13",
    "title": "AWS Knowledge",
    "content": "AWS KnowledgeBelow you can find links to additional reading material from AWS, including documentation on technologies leveraged by the Isolation feature set, as well as compliance information:  [AWS Media Blog] Securing Studio IP in AWS: Cloud-based VFX Project Management with Autodesk Shotgun  [AWS Media Blog] Designing for Studio-Grade Security  [Compliance] MPAA &amp;amp; Studio Security  [AWS Direct Connect] Overview          [AWS Direct Connect] User Guide        [AWS S3] Overview          [AWS S3] User Guide        [AWS EC2] Overview          [AWS EC2] User Guide        [AWS VPC] Overview          [AWS VPC] User Guide        [AWS PrivateLink] Overview",
    "url": "/5528234a/",
    "relUrl": "/5528234a/"
  },
  "14": {
    "id": "14",
    "title": "Webhook 批量交付",
    "content": "批量交付启用批量交付您可以选择将您的 Webhook 配置为使用有效负载批处理格式发出请求，方法是选中“以批处理格式交付”(Deliver in Batched Format)选项。如果启用此选项，则在发出每个请求时，它将 50 个待处理的事件打包到负载当中一同分发。这有助于管理对因在很短时间内生成许多 SG 事件而突然出现的大量交付进行的处理。在典型的系统操作下，当订阅的事件生成频率超过 2 秒一次时，将出现每个有效负载包含多个交付的情况。响应交付如果启用批量交付，建议将您的接收服务设计为保证响应的速度远快于每个事件 1 秒。否则，在一批包含事件较多时，超时和 Webhook 失败的风险将会增大。                    注意: 对于需要大约 1 秒来响应单个事件的接收服务，响应时间是主要性能因素，而不是交付开销。批处理不会有任何显著优势。    非批量交付 Webhook  允许的超时上限为每个交付 6 秒。即 Webhook 端点必须在 6 秒内响应每个请求。批量交付 Webhook  允许的超时上限为每批 6 秒或一批中每个事件 1 秒（以最大值为准）。  仍存在以下限制：所有 Webhook 中每个 ShotGrid 站点 Webhook 端点响应时间为 1 分钟。Webhook 交付格式比较非批量交付 Webhook 消息正文（始终为 1 个事件）：{  &quot;data&quot;:{    &quot;id&quot;:&quot;119.110.0&quot;,    &quot;event_log_entry_id&quot;:479004,    &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,    &quot;operation&quot;:&quot;update&quot;,    &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},    &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1419},    &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:127},    &quot;meta&quot;:{      &quot;type&quot;:&quot;attribute_change&quot;,      &quot;attribute_name&quot;:&quot;code&quot;,      &quot;entity_type&quot;:&quot;Asset&quot;,      &quot;entity_id&quot;:1419,      &quot;field_data_type&quot;:&quot;text&quot;,      &quot;old_value&quot;:&quot;Cypress test asset for Webhooks deliveries&quot;,      &quot;new_value&quot;:&quot;Revised test asset for Webhooks deliveries&quot;    },    &quot;created_at&quot;:&quot;2021-02-22 17:40:23.202136&quot;,    &quot;attribute_name&quot;:&quot;code&quot;,    &quot;session_uuid&quot;:null,  },  &quot;timestamp&quot;:&quot;2021-02-22T17:40:27Z&quot;}批量交付 Webhook 消息正文（可能包含 1 到 50 个事件）启用了批处理时，将始终显示 deliveries 键，即使批中只有 1 个事件也是如此。其值是单个事件交付数据数组，此处为每个交付提供的信息与非批处理模式相同。{  &quot;timestamp&quot;:&quot;2021-02-22T18:04:40.140Z&quot;,  &quot;data&quot;:{    &quot;deliveries&quot;:[      {        &quot;id&quot;:&quot;170.141.0&quot;,        &quot;event_log_entry_id&quot;:480850,        &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,        &quot;operation&quot;:&quot;update&quot;,        &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},        &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1424},        &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:132},        &quot;meta&quot;:{          &quot;type&quot;:&quot;attribute_change&quot;,          &quot;attribute_name&quot;:&quot;code&quot;,          &quot;entity_type&quot;:&quot;Asset&quot;,          &quot;entity_id&quot;:1424,          &quot;field_data_type&quot;:&quot;text&quot;,          &quot;old_value&quot;:&quot;Cypress test asset for Webhooks deliveries&quot;,          &quot;new_value&quot;:&quot;Revised test asset for Webhooks deliveries&quot;        },        &quot;created_at&quot;:&quot;2021-02-22 18:04:39.198641&quot;,        &quot;attribute_name&quot;:&quot;code&quot;,        &quot;session_uuid&quot;:null,      },      {        &quot;id&quot;:&quot;170.141.1&quot;,        &quot;event_log_entry_id&quot;:480851,        &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,        &quot;operation&quot;:&quot;update&quot;,        &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},        &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1424},        &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:132},        &quot;meta&quot;:{          &quot;type&quot;:&quot;attribute_change&quot;,          &quot;attribute_name&quot;:&quot;description&quot;,          &quot;entity_type&quot;:&quot;Asset&quot;,          &quot;entity_id&quot;:1424,          &quot;field_data_type&quot;:&quot;text&quot;,          &quot;old_value&quot;:null,          &quot;new_value&quot;:&quot;Some other *description*&quot;        },        &quot;created_at&quot;:&quot;2021-02-22 18:04:39.212032&quot;,        &quot;attribute_name&quot;:&quot;description&quot;,        &quot;session_uuid&quot;:null,      },    ]  }}",
    "url": "/e7890fc8/",
    "relUrl": "/e7890fc8/"
  },
  "15": {
    "id": "15",
    "title": "在您的第一个项目基础上更进一步",
    "content": "在您的第一个项目基础上更进一步在本文中，我们将介绍使用 ShotGrid Desktop 创建并开始正常运行第一个项目之后该做些什么。其中包含相关的常见问题和主题，并列出了很多有用的文档资源。欢迎使用 Toolkit欢迎您使用 Toolkit！如果您正在阅读本文，说明您或许已经成功使用 ShotGrid Desktop 安装了第一个 ShotGrid Pipeline Toolkit 项目。在这个阶段，我们希望您已经可以正常工作，并且像上面的屏幕截图一样，有一个项目页面和一些应用程序启动器。可以尝试着打开 Maya、Nuke 或其他任何应用程序。您应该会看到一个 ShotGrid 菜单，其中包含更多用于管理文件和资产的功能。那么，接下来该做些什么？Toolkit 在配置和工作方式上具有很大的灵活性。本文档将介绍一些我们建议您在使用 ShotGrid Desktop 创建并开始正常运行第一个项目之后执行的后续步骤。基本配置本节包含一系列参数调整和有用的配置内容。如果您刚刚设置好第一个 Toolkit 项目，很可能需要进行一些细微的调整才能让一切正常运行。本节将介绍这些不同的步骤。请注意，某些步骤需要编辑配置文件和执行一些“底层”操作。如果您对任何方面有任何疑问，请访问我们的支持站点以获取帮助。设置应用程序路径当您设置好第一个项目并单击启动按钮启动 Maya、MotionBuilder 或 Nuke 时，可能会看到类似如下的错误消息：在 Toolkit 项目配置中，我们会存储您可以启动的各种可执行文件的路径。如果出现上面的错误消息，很可能意味着这些路径与您的工作室设置不一致。您可能还会发现启动了错误的应用程序版本；例如，我们的默认配置使用的可能是 Maya 2015 的路径，但您的工作室运行的是 Maya 2014。这种情况下，您还需要更改这些路径。在我们的默认配置中，这些路径全部存储在一个名为 paths.yml 的文件中。 要更改某个路径，需要在磁盘上找到您的项目配置，然后导航进入 config 文件夹，直至找到 paths.yml 文件：打开此文件并对路径进行必要的更改。保存文件后，需要在 ShotGrid Desktop 内退出该项目，然后单击重新进入项目（但是不需要重新启动整个应用程序）。延伸阅读有关应用程序的详细信息，请查看以下主题：  Toolkit 应用程序启动器  传递命令行参数ShotGrid 集成Toolkit 与 ShotGrid 集成，并通过向用户界面不同部分添加特殊的 Toolkit 动作菜单项来扩展传统界面：这提供了一种方法来启动 Toolkit 应用程序或直接从 ShotGrid 处理数据的自定义工具。有关与 ShotGrid 站点集成的更多信息，请参见“管理员手册”的“浏览器集成”部分。向 ShotGrid 用户界面添加发布安装 Toolkit 后，通常有必要对 ShotGrid 用户界面布局做一些细微的调整。在您发布文件时，ShotGrid Pipeline Toolkit 可创建 发布实体 ，以便向关键资产（例如镜头和资产）添加 “发布”(Publishes)选项卡。要执行此操作，请确保您以管理员用户身份登录。首先，导航到一个资产或镜头，然后进入 设计模式：现在单击其中一个选项卡上的小三角形菜单，然后选择 “添加新选项卡”(Add New Tab) 动作。 这将打开一个对话框 UI。将选项卡命名为 “发布”(Publishes)，并确保它与已 发布文件 实体关联：现在单击 “保存”(Save) 保存更改。 这样就全部搞定了！注意：ShotGrid 会选择几个默认字段，供您在创建新选项卡时添加。您可能想要针对发布添加一些额外的字段。为此，可以单击新的“发布”(Publishes)选项卡下电子表格右上角的小加号按钮。我们建议您添加下列字段：  说明(Description) - 保存本发布中的变更说明  创建者(Created By) - 创建发布的用户  创建日期(Date Created) - 创建发布的日期如果更改布局，之后请不要忘记保存页面！多个操作系统在某些情况下，您可能会看到一条弹出消息，提示您找不到 Python，并带有一个指向文档本节的链接。Toolkit 使用一种名为 Python 的语言来执行其脚本和功能。ShotGrid Desktop 附带了一个完整的内置 Python 安装，因此您通常不需要考虑这一点。当您使用 ShotGrid Desktop 设置新的 Toolkit 项目时，项目默认会被设置为使用 ShotGrid Desktop 捆绑的 Python。但是，有时您可能需要明确指示 Toolkit 您想使用哪个 Python。例如，在下列情况下您需要这样做：  使用的是早期版本的 ShotGrid Desktop，不能自动设置所有 Python 默认设置。  您将 ShotGrid Desktop 安装在了磁盘上的非标准位置。  您运行的是手动的或更复杂的 Toolkit 项目设置。Python 的路径存储在配置文件中，您可以手动编辑这些文件：要找到正确的文件，首先导航到您的项目配置。在树视图中，查找以 interpreter_ 开头的文件。 这些文件包含 Linux、Windows 和 Mac（“Darwin”）平台的 Python 解释器的路径。这些文件包含这三种操作系统各自的 Python 位置。您需要进入文件并手动添加要使用的任何操作系统的 Python 位置。如果文件是空白的，表示您使用的是早期版本的 ShotGrid Desktop。如果是这样，只需尝试使用默认的 Python 路径更新这些空白文件即可。这些路径如下所示：  Macosx (Darwin)： /Applications/Shotgun.app/Contents/Frameworks/Python/bin/python  Windows： C: Program Files Shotgun Python python.exe  Linux： /opt/Shotgun/Python/bin/python如果您已将 ShotGrid Desktop 安装在非标准位置，或者打算使用自定义的 Python 位置，请确保文件中的路径指向有效的 Python 安装。此安装需要为 v2.6 或更高版本（但不能是 Python 3！）。如果您想执行基于用户界面的应用程序和工具，请确保您指定的 Python 已安装了 PyQt 或 PySide，并且已链接至 QT v4.6 或更高版本。另外还要注意，为了能在多个操作系统上运行 Toolkit，在运行项目设置向导时，您需要指定所有需要的平台的路径。如果您尚未执行此操作，并且想要将其他操作系统添加到存储路径或配置位置，请访问我们的支持站点以获取帮助。后续步骤至此，默认的 ShotGrid 设置应该可以正常用于一个 ShotGrid 项目（或测试项目）了。应用程序开始启动，ShotGrid 中开始显示上下文菜单动作和发布，您需要的所有操作系统平台一切运行正常。下面这个小节主要介绍接下来要做些什么 – 从默认配置开始，对它进行调整，使它更接近于您工作室工作流的其余环节。Toolkit 的灵活性和可配置程度很高，而且我们还有丰富的文档资源。但是在开始前，为了让您对实际操作一目了然，我们建议您花几分钟时间观看我们的各种介绍视频。这些视频演示了 ShotGrid Pipeline Toolkit 的实际运行，以及它在 Maya 和 Nuke 这类应用程序内部是如何工作的。视频还简要介绍了发布、版本控制、加载等基本概念。Toolkit 项目剖析创建新的 Toolkit 项目时，您最终将得到几个关键位置。  ShotGrid Desktop 及其配置已安装在您的本地计算机上（如果需要，可将应用程序和配置同时移至共享存储）。  数据区域是 Toolkit 项目存储纹理、文件、渲染等内容的地方。这通常是一个共享存储，因为您需要与其他用户共享这些数据，但是此规则也有例外；用户工作区可存储在本地（仅限用户）存储中，集成（例如 Perforce 集成）则使用外部系统帮助分发内容。  Toolkit 配置是一个完全自包含的数据包，包括代码、应用、核心 API 等。这些数据通常存储在共享存储上，方便所有用户轻松访问配置。您在磁盘上的项目配置包含几个不同的项。在下面这些小节中，我们将带您了解项目配置文件夹的不同部分。命令行访问除了使用 ShotGrid Desktop，您还可以通过终端或 Shell 访问 Toolkit。您在磁盘上创建的每个项目都附带一个特殊的 tank 命令，它让您可基于命令行访问许多功能，包括发起 API 会话和启动应用程序。如果您导航到自己的项目配置，可以在配置的根目录看到 tank 和 tank.bat 命令。 运行这些命令时，如果不带任何选项，将生成当前配置支持的所有命令的列表，包括以下实用命令：  tank shell - 启动一个提供 TK API 访问功能的交互式 Python Shell  tank core - 检查此项目是否有任何可用的核心 API 更新  tank updates - 检查此配置中是否有任何应用或插件有任何更新可用有关 tank 命令用途的更多详细信息，请参见以下深入的技术文档：如何管理 Toolkit主要配置文件config 文件夹包含一些主要配置文件。Toolkit 附带一个文件夹创建系统，它会尝试自动在磁盘上创建文件夹，确保当您启动应用程序时，所有必要的结构在磁盘上都存在，并且已事先准备就绪！这方面的配置可在上面所示的 schema 文件夹中找到。另外要与此相提并论的是 Toolkit 的 模板系统 ，它让您可轻松定义各种可配置的文件、发布内容、工作文件、渲染等的路径。 模板存储在上面的 templates.yml 文件中。结合运用项目配置的这两个部分，可以调整 Toolkit 使用的各种应用，让它们将数据写出到您的现有工作流可以识别的磁盘位置。请参阅我们的高级文档了解这方面的更多信息：  文件夹配置  文件系统模板Toolkit 配置本质上由一系列已配置的应用和插件组成。 此配置位于 env 文件夹中。 如果说上面讨论的文件系统配置文件定义了资源在磁盘上应该“位于 何处” ，那么环境配置及其应用和插件则定义了工作流应该执行“ 什么 操作”。核心 API 平台每个项目配置都使用一系列应用和插件。这些应用和插件的配置存储在配置内的 env 文件夹中。 Toolkit 随后会自动下载和管理运行这些应用和插件所需的各种版本的代码。这些代码放在 install 文件夹内。配置、应用和插件都在 Toolkit 核心平台之上运行。对于新项目，这些数据也存储在 install 文件夹内。 本质上讲，项目配置是完全自包含的 - 运行 Toolkit 必需的所有必要组件都位于一处。这也意味着每个项目都是独立的，更新一个项目不会打断另一个项目。技术说明：使用共享的 Toolkit 核心（单击此处展开）延伸阅读我们还有一份技术性更强的文档，从头到尾介绍了 ShotGrid Pipeline Toolkit 中的高级概念，并讲解了一些更宏观的东西。当您能够很好掌握 Toolkit 的常规用法后，我们建议您继续阅读此文档，更深入地了解可以怎样调整 Toolkit 来满足您工作室的特殊需求。ShotGrid Toolkit 高级概念简介Toolkit 社区Toolkit 有一个不可或缺的部分，那就是汇集了众多工作流工程师和技术主管的社区！我们的使命是打造一个充满活力、代码共享的社区。在这里，大家可以群策群力，共同帮助 Toolkit 不断发展成为一个强大并且灵活的工作流环境。如果您有任何疑问，或者想阅读现有的帖子和话题，请访问我们的社区。",
    "url": "/c3b662a6/",
    "relUrl": "/c3b662a6/"
  },
  "16": {
    "id": "16",
    "title": "无法在 Linux 上启动 ShotGrid Desktop/浏览器集成",
    "content": "无法在 Linux 上启动 ShotGrid Desktop/浏览器集成首次在 Linux 上运行 ShotGrid Desktop 时，可能会出现以下错误消息之一。如果出现这些消息，请按照具体错误下方的步骤进行操作，以确定能否解决问题。如果您仍然遇到困难，请访问我们的支持站点以获取帮助。目录  OPENSSL_1.0.1_EC 或 HTTPSConnection 相关问题  libffi.so.5 相关问题  与证书验证失败相关的问题  不兼容的 Qt 版本OPENSSL_1.0.1_EC 或 HTTPSConnection 相关问题错误importing '/opt/Shotgun/Resources/Python/tk-framework-desktopstartup/python/server/resources/python/dist/linux/cryptography/_Cryptography_cffi_36a40ff0x2bad1bae.so': /opt/Shotgun/Resources/Python/tk-framework-desktopstartup/python/server/resources/python/dist/linux/cryptography/_Cryptography_cffi_36a40ff0x2bad1bae.so: symbol ECDSA_OpenSSL, version OPENSSL_1.0.1_EC not defined in file libcrypto.so.10 with link time referenceAttributeError: 'module' object has no attribute 'HTTPSConnection'解决方案您需要安装 OpenSSL。为此，请以管理员身份运行以下命令：$ yum install openssllibffi.so.5 相关问题错误Browser Integration failed to start. It will not be available if you continue.libffi.so.5: cannot open shared object file: No such file or directory解决方案您需要安装 libffi。为此，请以管理员身份运行以下命令：yum install libffi如果您已经安装 libffi 但仍无法运行，请尝试创建以下符号链接，然后重新启动 ShotGrid Desktop：sudo ln -s /usr/lib64/libffi.so.6.0.1 /usr/lib64/libffi.so.5部分用户报告通过上述操作解决了问题。但其他用户仍存在问题。最新版本的 ShotGrid Desktop 添加了与 WebSocket 服务器之间的一些其他依存关系，这是我们目前正在研究的方面。与证书验证失败相关的问题可能的错误Browser Integration failed to start. It will not be available if you continue.Error: There was a problem validating if the certificate was installed.certutil: function failed: SEC_ERROR_BAD_DATABASE: security library: bad database.解决方案如果您的计算机上已经安装 Google Chrome，请启动它，然后重新启动 ShotGrid Desktop。如果仍有此问题，请访问我们的支持站点以获取帮助。如果没有安装 Chrome，请打开终端并运行以下命令：ls -al $HOME/.pki/nssdb如果搜索到此文件夹，请联系支持部门并将以下日志文件的内容附加到您的工单：~/.shotgun/logs/tk-desktop.log否则，请输入以下内容：$ mkdir --parents ~/.pki/nssdb$ certutil -N -d &quot;sql:$HOME/.pki/nssdb&quot;不要输入任何密码。ShotGrid Desktop 现在应该能够正常启动。不兼容的 Qt 版本可能的错误Cannot mix incompatible Qt library (version 0x40805) with this library (version 0x40807)解决方案出现此问题的常见原因是发生了替代，它最终会加载不兼容的 Qt 库。您可以尝试使用以下命令修改您的环境，以避免发生这种情况：unset QT_PLUGIN_PATH",
    "url": "/9207f027/",
    "relUrl": "/9207f027/"
  },
  "17": {
    "id": "17",
    "title": "我无法通过 Chrome 使用本地文件链接和启动 Toolkit 应用程序",
    "content": "我无法通过 Chrome 使用本地文件链接和启动 Toolkit 应用程序概述在 ShotGrid 中，动作菜单有时不显示可用 Toolkit 应用程序的列表，或者在使用本地文件链接时有时会出错，即使 ShotGrid Desktop 正在运行中。这是 Chrome 中的 ShotGrid Desktop 浏览器集成的疑难解答手册，希望对您有所帮助。我们为 Firefox 提供单独手册。  诊断问题  如何快速修复证书问题  修复所有平台上的 ERR_CERT_COMMON_NAME_INVALID 或 ERR_SSL_SERVER_CERT_BAD_FORMAT  修复 Windows 上的 ERR_CERT_AUTHORITY_INVALID诊断问题ShotGrid Desktop 是否正在运行？是的，我们知道。您可能已经检查过了，但我们必须要问一下。:)ShotGrid Desktop 启动后，您是否重新启动了 Chrome？如果在允许 ShotGrid Desktop 注册证书之前便已启动 Chrome（这种情况仅在首次启动 ShotGrid Desktop 时发生，之后将不再出现此问题），Chrome 将会使用过期的证书副本并拒绝连接到 ShotGrid Desktop。关闭所有选项卡不一定会关闭 Chrome，因此建议您在地址栏中键入 chrome://restart 并按 Enter 键。这将确保所有 Chrome 相关进程都会终止，之后 Chrome 便会重新启动。您是否正在使用防火墙软件？确保没有防火墙软件阻止与 localhost 的连接或端口 9000 上的连接。Chrome 是否拒绝证书？您可以浏览到 https://localhost:9000 来确认 Chrome 是否接受证书，这是 ShotGrid 网站为了执行本地文件链接和启动 Toolkit 应用程序而尝试访问的网址。您通常会看到以下消息：另一方面，如果您看到下列消息之一，则表示证书注册过程有问题： 如何快速修复证书问题规避这些问题的最简单方法就是单击“高级”(ADVANCED)和“Proceed to localhost (unsafe)”。 这样，Chrome 便会知道您还是接受了证书，并允许 ShotGrid 网站与 ShotGrid Desktop 通信。                    注意: 这只会启用网络浏览器和 ShotGrid Desktop 之间的连接。信任设置可让这两个应用程序之间的通信流动，并不代表信任 Internet 上的任何其他服务器。遗憾的是，需要在出现问题的每台计算机上重复此过程。如果此方法无法解决问题，或者您认为部署到所有用户过于复杂，建议您采取以下步骤。                        注意: 此修复步骤不适用于 ERR_SSL_SERVER_CERT_BAD_FORMAT 错误，而且您将需要重新生成证书，如下所述。    修复所有平台上的 NET::ERR_CERT_COMMON_NAME_INVALID 和 ERR_SSL_SERVER_CERT_BAD_FORMATChrome 会定期升级其自签名证书的安全性，这些更新有时会破坏我们的浏览器集成。 遗憾的是，这些类型的问题只能通过重新生成证书的 certificate_path 来修复。要重新生成证书，可在 ShotGrid Desktop 用户菜单的“高级”(Advanced)部分下选取“Regenerate Certificates”选项。（如果您未看到此选项，请确保更新 tk-desktop 插件，以解除对此选项的锁定。）确认您要重新生成证书后，将会弹出一系列对话框，就像您首次生成证书一样。在 Windows 和 macOS 上，系统将提示您更新 Windows 证书存储或 macOS 密钥链两次：一次用来删除旧证书，一次用来注册新证书。在 Linux 上，注册以静默方式完成。 完成后，重新启动 ShotGrid Desktop。ShotGrid Desktop 完成启动并处于运行状态后，建议您在地址栏中键入 chrome://restart 来重新启动 Chrome，确保已完全关闭 Chrome 并清空其证书缓存。如果您的计算机未连接到 Internet，无法下载更新，请访问我们的支持站点以获取帮助。修复 Windows 上的 NET::ERR_CERT_AUTHORITY_INVALID在某些情况下，Windows 将报告证书已成功导入，但不会将其用于需要它的应用程序。访问 Windows 上的证书对话框可以验证此情况。要访问该对话框，请点击 Windows 键并键入“Internet 选项”。在“Internet 属性”对话框上，切换到“内容”选项卡，然后单击“证书”按钮。最后，单击“受信任的根证书颁发机构”并查找 localhost。如果没有此条目，则表明您的 Windows 域或本地计算机可能存在组策略问题。如果存在此条目，建议您联系我们的支持团队。此时，建议您与管理贵组织 Windows 计算机的人员沟通，并向其询问是否有可能已设置为指示 Windows 不信任自签名证书的组策略。调查组策略问题如果您的计算机在域中，管理员可以尝试此 StackExchange 帖子中详述的步骤。如果您的计算机不在域中，可能是计算机仍被管理员锁定。执行以下步骤时需要 Windows 管理员帐户。点击 Windows 键，键入 MMC，然后按 Enter 键。此时将启动 Microsoft 管理控制台。在应用程序中，单击“文件”菜单并选择“添加/删除管理单元”。此时将显示“添加或删除管理单元”对话框。在左侧，搜索“组策略对象编辑器”，然后单击“添加 &amp;gt;”。将出现一个新对话框，可单击“完成”将其关闭。最后，单击“添加或删除管理单元”对话框上的“确定”。最后，在主对话框的左侧，导航到“本地计算机策略/计算机配置/Windows 设置/安全设置/公钥策略”。选定后，双击中央窗格中的“证书路径验证设置”。在下一个对话框中，确保“定义这些策略设置”处于未选中状态。如果选中，请确保“允许使用用户受信任根证书颁发机构(CA)验证证书(推荐)”处于选中状态。完成之后，单击“确定”，系统会保存这些设置。此时，需要关闭所有 Chrome 窗口并重新启动 Chrome。建议像前面的操作那样，使用 chrome://restart 执行此操作。必须执行此操作，所做更改才能生效。如果您浏览到证书列表，此时应显示 localhost 证书。如果在上述更改之后使用浏览器集成时仍遇到问题，或者设置在一开始就是正确的，请联系我们的支持团队。其他操作系统的疑难解答如果您在其他操作系统上有关于 ShotGrid Desktop 集成的问题，请联系我们的支持团队，以便我们可以为您提供帮助并更新此文章。",
    "url": "/95518180/",
    "relUrl": "/95518180/"
  },
  "18": {
    "id": "18",
    "title": "我无法通过 Firefox 使用本地文件链接和启动 Toolkit 应用程序",
    "content": "我无法通过 Firefox 使用本地文件链接和启动 Toolkit 应用程序概述在 ShotGrid 中，动作菜单有时不显示可用 Toolkit 应用程序的列表，或者在使用本地文件链接时有时会出错，即使 ShotGrid Desktop 正在运行中。这是 Firefox 中的 ShotGrid Desktop 浏览器集成的疑难解答手册，希望对您有所帮助。我们为 Chrome 提供单独手册。诊断问题ShotGrid Desktop 是否正在运行？是的，我们知道。您可能已经检查过了，但我们必须要问一下。:)您是否正在使用防火墙软件？确保没有防火墙软件阻止与 localhost 的连接或端口 9000 上的连接。Firefox 是否拒绝证书？您可以浏览到 https://localhost:9000 来确认 Firefox 是否接受证书，这是 ShotGrid 网站为了执行本地文件链接和启动 Toolkit 应用程序而尝试访问的网址。您通常会看到以下消息：另一方面，如果您看到下面两条消息之一，则表示证书注册过程有问题：如何修复“您的连接不安全”问题您需要向 Firefox 浏览器添加一个例外，使证书获得接受。如果您刚刚访问了 https://localhost:9000，添加例外的最简单方法就是单击高级，然后单击添加例外按钮。将显示对话框。单击获取证书，然后选择确定安全例外。您可以忽略证书不受信任的消息。这很正常，因为证书是由 ShotGrid Desktop 生成的，而不是由证书颁发机构生成。您现在应该可以从您的 ShotGrid 站点访问本地文件链接和启动 Toolkit 应用程序了。如果在添加例外后仍遇到问题，请访问我们的支持站点以获取帮助。如何修复“安全连接失败”问题您需要单击“打开菜单”按钮并选取“首选项”。然后选取左侧的“高级”，并依次单击“证书”和“查看证书”。在“服务器”部分中，单击任意项并开始键入 localhost，或者只是滚动，直到找到名为 localhost:9000 的条目。将其删除。然后，转到“证书机构”选项卡并再次键入 localhost。您还可以再次滚动，直到到达其下有 localhost 条目的 Autodesk 部分。可以删除 localhost 条目。完成后，单击确定，然后重新启动 Firefox。Firefox 重新启动后，请浏览至 https://localhost:9000。您现在应该看到以下消息：此时，需要按照上面所述的步骤添加一个例外。如果您所看到的屏幕不是这样，请访问我们的支持站点以获取帮助。",
    "url": "/d4936105/",
    "relUrl": "/d4936105/"
  },
  "19": {
    "id": "19",
    "title": "在本地 {% include product %} 站点上使用 {% include product %} Desktop 时显示 CERTIFICATE_VERIFY_FAILED",
    "content": "在本地 ShotGrid 站点上使用 ShotGrid Desktop 时显示 CERTIFICATE_VERIFY_FAILED用例：使用 ShotGrid 的本地安装时，在以下两种情况中可能会出现此错误：  登录 ShotGrid Desktop 时  从 Toolkit 应用商店下载媒体时如何修复：要解决此问题，您需要向 ShotGrid API 提供一个文件，其中包含所有有效 CA 的列表，包括您自己的 CA。我们通常建议用户从 Python 的 certifi 软件包下载此文件的最新副本作为起点，然后在文件末尾添加自己的 CA。然后，将该文件保存到所有用户都可以访问的位置。最后，在每台计算机上，将 SHOTGUN_API_CACERTS 环境变量设置为该文件的完整路径，例如 /path/to/my/ca/file.pem。这样做应该可以解决您在本地站点上遇到的任何 CERTIFICATE_VERIFY_FAILED 错误。请注意，如果您能够连接到 ShotGrid 站点，但仍无法从 Toolkit 应用商店下载更新，则可能是因为您的 .pem 文件中缺少 Amazon CA。如果您从一个空文件开始，而且仅添加了您的自定义 CA，而不是从我们上面链接到的文件开始，通常会发生这种情况。请注意，这些信息仅适用于本地安装。如果您有一个托管站点并遇到此错误，对于 Windows，请查看此论坛帖子。对于其他操作系统，请查看此文档。导致此错误的原因示例：之所以出现此问题，通常是因为您已将本地站点配置为使用 HTTPS，但您尚未配置 Toolkit，因此识别的是您用于签署本地站点证书的证书颁发机构（此后称为 CA）。在社区中查看完整主题。",
    "url": "/413b6be4/",
    "relUrl": "/413b6be4/"
  },
  "20": {
    "id": "20",
    "title": "ShotGrid in the Cloud",
    "content": "ShotGrid in the CloudWhat is ShotGrid in the Cloud?ShotGrid Cloud is our default offering, hosted on AWS and built on top of Autodesk’s Cloud technology platform. ShotGrid Cloud is the latest generation of our hosted service and is completely cloud based.Further ReadingAdministration documentation can be found here.",
    "url": "/af35baf6/",
    "relUrl": "/af35baf6/"
  },
  "21": {
    "id": "21",
    "title": "社区共享集成",
    "content": "社区共享集成下面是 Toolkit 社区人员热心分享的项目。它们不是由 ShotGrid 内部人员编写的，因此我们无法做出保证，但我们一定会回答我们可以回答的任何问题。如果您有要添加到列表的项目，请访问我们的支持站点以获取帮助。插件            集成      插件      信息                        tk-katana      项目 URL：https://github.com/robblau/tk-katana 项目贡献者：Lightchaser Animation 项目维护者：  项目说明：适用于 Foundry Katana 的 ShotGrid 插件                    tk-unreal      项目 URL：https://docs.unrealengine.com/4.26/zh-CN/ProductionPipelines/UsingUnrealEnginewithAutodeskShotgun/ 项目贡献者：Epic Games 项目维护者： 项目说明：适用于 Unreal Engine 的 ShotGrid 插件                    tk-substancepainter      项目 URL：https://github.com/diegogarciahuerta/tk-substancepainter 项目贡献者：Factor64 项目维护者：Diego Garcia Huerta 项目说明：适用于 Adobe Substance Painter 的 ShotGrid 插件                    tk-substancedesigner      项目 URL：https://github.com/diegogarciahuerta/tk-substancedesigner   项目贡献者：Factor64   项目维护者：Diego Garcia Huerta   项目说明：适用于 Adobe Substance Designer 的 ShotGrid 插件    详细信息：ShotGrid 社区论坛                    tk-modo      项目 URL：https://github.com/tremolo/tk-modo   项目贡献者：Lutz Pälike 和 Walking The Dog   项目维护者：   项目说明：适用于 Foundry Modo 的 ShotGrid 插件                    tk-clarisse      项目 URL：https://github.com/diegogarciahuerta/tk-clarisse 项目贡献者：Factor64 项目维护者：Diego Garcia Huerta 项目说明：适用于 Clarisse iFX 的 ShotGrid 插件。Clarisse iFX 是一款完全交互式 CG 工具组合，用于布景、外观开发、照明和渲染。                    tk-natron      项目 URL：https://github.com/diegogarciahuerta/tk-natron 项目贡献者：Factor64 项目维护者：Diego Garcia Huerta 项目说明：适用于 Natron 的 ShotGrid 插件。Natron 是一款基于节点的免费开源软件应用程序。                    tk-harmony      项目 URL：https://github.com/diegogarciahuerta/tk-harmony 项目贡献者：Factor64 项目维护者：Diego Garcia Huerta 项目说明：适用于 Toon Boom Harmony 的 ShotGrid 插件。Toon Boom Harmony 是行业领先的动画制作软件。                    tk-cinema      项目 URL：https://github.com/mikedatsik/tk-cinema 项目贡献者：Mykhailo Datsyk  项目维护者：Mykhailo Datsyk  项目说明：适用于 Maxon Cinema 4D 的 ShotGrid 插件。Maxon Cinema 4D 是一款适合设计师使用的建模、动画和渲染工具组合。 详细信息：ShotGrid 社区论坛                    tk-krita      项目 URL：https://github.com/diegogarciahuerta/tk-krita 项目贡献者：Factor64 项目维护者：Diego Garcia Huerta 项目说明：适用于 Krita 的 ShotGrid 插件。Krita 是一款免费的开源光栅图形编辑器，主要用于数字绘画和二维动画制作。 详细信息：ShotGrid 社区论坛                    tk-blender      项目 URL：https://github.com/diegogarciahuerta/tk-blender 项目贡献者：Factor64 项目维护者：Diego Garcia Huerta 项目说明：适用于 Blender 的 ShotGrid 插件。Blender 是一款免费的开源三维计算机图形软件工具组合，用于创建动画电影、视觉特效、艺术作品、3D 打印模型、运动图形、交互式三维应用程序、虚拟现实和计算机游戏。 详细信息：ShotGrid 社区论坛      应用            集成      插件      信息                        tk-maya-playblast      项目 URL：https://github.com/basestudio/tk-maya-playblast   项目贡献者：BASE Studio   项目维护者：   项目说明：用于从 Maya 发布播放预览的应用。请参见 https://goo.gl/5oJTv0                    tk-multi-renderfarm      项目 URL：https://github.com/baitstudio/tk-multi-renderfarm   项目贡献者：Bait Studio   项目维护者：   项目说明：用于向场提交作品的应用。请参见 https://goo.gl/ew6mkD                    tk-shotgun-publishrenders      项目 URL：https://github.com/janimation/tk-shotgun-publishrenders   项目贡献者：   项目维护者：Dave Sisk   项目说明：此应用用于搜索项目的目录结构，以查找现有的已发布文件或文件序列，然后在 ShotGrid 中将其注册为已发布的文件（如果已发布的文件对象尚不存在）。                    nuke-getShotgunData      项目 URL：https://github.com/RicardoMusch/nuke-getShotgunData   项目贡献者：Ricardo Musch   项目维护者：Ricardo Musch    项目说明：将 ShotGrid 数据导入 NUKE 文本节点可能会有点困难。此节点可用于将此信息通过管道传递到场记板、场景信息覆层或其他任何地方。                    sb-shotgun-schema-introspection      项目 URL：https://github.com/scottb08/sb-shotgun-schema-introspection   项目贡献者：Scott Ballard   项目维护者：Scott Ballard    项目说明：这是一个简单的 Toolkit 应用，支持 ShotGrid 和 Toolkit 开发人员快速导航和检查 ShotGrid 实体、字段和基础模式。                    foto-multi-namingconvention      项目 URL：https://github.com/scottb08/foto-multi-namingconvention   项目贡献者：Griffith Observatory   项目维护者：Scott Ballard   项目说明：这是一个简单的 Toolkit 应用，支持 ShotGrid 和 Toolkit 开发人员快速导航和检查 ShotGrid 实体、字段和基础模式。                    tk-cpenv      项目 URL：https://github.com/cpenv/tk-cpenv   项目贡献者：Dan Bradham   项目维护者：Dan Bradham   项目说明：此应用添加了对 cpenv 的支持，cpenv 工具使用模块来管理软件插件、项目依存关系和环境变量。   详细信息：ShotGrid 社区论坛                    rtm-tk-hiero-shotgunDropper      项目 URL：https://github.com/RicardoMusch/rtm-tk-hiero-shotgunDropper 项目贡献者：Ricardo Musch 项目维护者：Ricardo Musch  项目说明：此应用允许您将版本和播放列表从 ShotGrid 拖放到 Hiero 中。 详细信息：ShotGrid 社区论坛      ",
    "url": "/58a557ee/",
    "relUrl": "/58a557ee/"
  },
  "22": {
    "id": "22",
    "title": "配置临时沙盒和推行应用",
    "content": "配置临时沙盒和推行应用本文档介绍了有关如何安全地将更改应用于您的生产工作流的最佳实践。说明了如何创建临时沙盒（这是您的生产配置的副本）、更新此沙盒及进行测试，最后将更改推送至生产配置。请注意，本文档介绍仅当控制 Toolkit 配置时可用的功能。有关默认设置，请参见 ShotGrid 集成管理员手册。简介本文档概括介绍了如何管理您的 Toolkit 配置。Toolkit 包含几个实用程序和工具，让您可安全地管理配置，并在安全的沙盒环境中测试升级和更改，然后再将它们部署到整个生产环境。在本文档中，我们将介绍如何：  安全地升级 Toolkit 核心 API。  升级应用和插件。  使用各种方法管理多个项目的配置。  使用 Toolkit 的 “克隆” 和 “推送” 功能，在不中断生产的情况下安全地测试升级和更改。  使用 git 源代码管理系统和 Toolkit。配置管理的基础知识每个 Toolkit 项目都关联了一个或多个配置。配置包含项目所需的所有设置，包括文件系统位置（模板）、插件、应用等。在 Toolkit 中，每个项目都可以单独进行配置。也就是说，不同的项目可以和平共处：升级一个项目不会影响另一个项目。如果您有大量项目要处理，这样可能会比较麻烦，因此我们提供了几种方法，让配置过程变得轻松、安全、简单。在 ShotGrid 中，每个项目都有多个工作流配置。首次使用 Toolkit 设置项目时，会创建一个名为 primary 的工作流配置。 ShotGrid 中的工作流配置实体将指向一个磁盘位置，Toolkit 的配置将位于此处。在项目期间，经常需要更改配置。您可能会调整配置，也可能需要添加另外的应用或插件。我们也会经常发布新的应用版本，并建议您尽可能使用最新版本。尽管可以直接升级项目的 主 配置，但这样做可能会有风险：因为参与项目的每个人都使用此配置，一旦出现问题，就会影响所有人。更好的做法是创建一个孤立的配置版本，让指定的一组人员可以访问它。在这个安全的环境中，无论进行升级、配置更改还是开发，都不会影响其余的生产环境。更改通过测试后，便可以安全放心地将它们推送到主配置。我们将这个过程称为 “克隆” ，它相当于为主配置创建一个只有您自己（以及您邀请的其他人）才能访问的个人副本。 在这个副本中，您可以安全地进行更改，直到满意为止，然后可以将这些更改推送回主配置。克隆您的配置设置好 Toolkit 并配置项目后，整个设置看起来将如下所示：设置中有一个工作室安装 (studio)，其中容纳着所有项目的核心 API。 此 studio 位置中还包含一个 tank 命令和一个 Toolkit Python API，您可以使用该 API 访问任何启用了 Toolkit 的 ShotGrid 项目。除此以外，每个项目还有一个配置文件夹。此文件夹包含该项目的所有设置。此外，它还包含一个专门用来操作此配置的 tank 命令（和一个 Python API）。使用此 tank 命令或 API 代码时，只能操作此配置。设置新项目后，会创建一个 主 配置。 这是 Toolkit 默认将为项目使用的配置。除了主配置以外，您还可以为项目创建另外的配置。这些配置可以并存，并且当您想单独测试某些修改、升级某些应用或在不影响整个团队的情况下进行开发时，这些配置会很有用。除主配置以外的其他配置由一个称为 “克隆” 的过程创建，这个过程会将配置复制到一个新位置。克隆完配置后，您的设置看起来可能如下所示：此时，除了工作室级的 tank 命令和项目主配置的 tank 命令以外，您还有了一个新的工作流配置，它也有自己的 tank 命令。 如果您运行此 tank 命令，将对临时沙盒中的配置进行独占操作。 因此，如果您想在 Maya 中测试某些新功能，只要导航到克隆的沙盒，运行 ./tank Shot xyz launch_maya，Maya 中显示的 ShotGrid 菜单便会反映临时沙盒内的配置，而不是主配置。注意，工作室级的 tank 命令始终使用主配置。因此，访问克隆配置的唯一方法是导航到克隆配置所在的位置，然后使用该文件夹中的 tank 命令。 在 ShotGrid 中，您可以向一个工作流配置项分配一组特定的用户，任何与某个配置关联的用户不仅能看到主配置中的菜单项，还能看到该配置的菜单项：创建克隆配置要创建可以安全测试升级的临时沙盒，请在 ShotGrid 中导航到您项目的工作流配置，然后在主配置上单击鼠标右键。此时将显示一个克隆配置的选项：单击此选项后，将显示一个对话框，让您指定新配置在磁盘上的路径。如果您的设置运行多个操作系统，请确保输入所有相关平台的路径。按“确定”(OK)后，Toolkit 将复制配置并设置克隆。它还会将您的 ShotGrid 用户与此配置关联，因此创建克隆后，您立刻就会在 ShotGrid 内看到新的菜单项。将更改从临时沙盒推送到主配置应用相关更新并运行了任何必要的测试之后，您可以执行 tank push_configuration 命令，将更改推送回生产配置。 此操作会将您在临时沙盒中所做的更改全部传输到主配置。请注意，当您运行 push_configuration 命令时，当前配置将被移至一个备份位置。如果您意外地进行了推送或推送出现问题，只需将 backup 文件夹中的内容复制到 config 文件夹，即可轻松回退。默认情况下，此命令会将一系列文件复制到目标工作流配置中的 config 文件夹。 如果您使用的是 Unix 系统，想进行更加原子式的更新，可以向 push_configuration 命令添加一个 --symlink 标志。 这会将目标工作流配置中的 config 文件夹变成一个符号链接，让升级变得更容易，并且不会出现当前运行的会话中配置不匹配的风险。刷新旧的克隆配置如果您有一个旧的开发沙盒或过时的临时沙盒设置，现在需要将它的内容与最新的生产配置同步，可以为主配置运行 push_configuration 命令来进行同步。tank push_configurationWelcome to the ShotGrid Pipeline Toolkit!For documentation, see https://developer.shotgridsoftware.comStarting Toolkit for your current directory '/tmp'- Using configuration 'Primary' and Core v0.14.52- Setting the Context to Empty Context.- Running command push_configuration...----------------------------------------------------------------------Command: Push configuration----------------------------------------------------------------------This command will push the configuration in the current pipeline configuration('Primary') to another pipeline configuration in the project.Your existing configuration will be backed up.The following pipeline configurations are available to push to: - [324] Staging Sandbox (/my/staging/sandbox)Please type in the id of the configuration to push to (ENTER to exit): 324Hold on, pushing config...Checking if there are any apps that need downloading...Push Complete!Your old configuration has been backed up into the following folder:/my/staging/sandbox/config.bak.20140108_093218请注意我们如何从项目主配置向临时沙盒推送内容。我们的做法是运行 主 配置的 tank 命令。 如果您有多个沙盒设置，也可以在这些沙盒之间推送数据。删除克隆配置如果想删除克隆配置，只需在 ShotGrid 中删除条目，然后从磁盘上移除对应的文件夹即可。获取最新的应用和插件在临时沙盒内（或其他任何配置中），您可以运行 tank updates 命令来检查是否有任何可用的应用更新。 此命令提供基本的过滤器，如果您只想检查配置的某些区域，可以使用这些过滤器：----------------------------------------------------------------------Command: Updates----------------------------------------------------------------------This command will go through your current configuration and check if there areany updates available. If there are updates, you will be asked if you want toperform an upgrade. If settings has been added to the new version that you areinstalling, you may be prompted to specified values for these.Running this command with no parameters will check all environments, enginesand app. This may take a long time. You can also run the updater on a subsetof your installed apps and engines.General syntax:&amp;gt; tank updates [environment_name] [engine_name] [app_name]The special keyword ALL can be used to denote all items in a category.Examples:Check everything:&amp;gt; tank updatesCheck the Shot environment:&amp;gt; tank updates ShotCheck all maya apps in all environments:&amp;gt; tank updates ALL tk-mayaCheck all maya apps in the Shot environment:&amp;gt; tank updates Shot tk-mayaMake sure the loader app is up to date everywhere:&amp;gt; tank updates ALL ALL tk-multi-loaderMake sure the loader app is up to date in maya:&amp;gt; tank updates ALL tk-maya tk-multi-loader升级 Toolkit 核心 API本节介绍可以怎样使用克隆临时沙盒配置来安全地升级 Toolkit 核心 API。如果您还没有准备好临时沙盒，只要按照上节的说明操作即可！如果您的临时沙盒克隆自某个使用共享工作室核心 API 的工作流配置，您需要更新沙盒，以使用它自己独有的核心 API 代码。我们将这个过程称为对核心进行“本地化”，您可以导航到您的临时沙盒并运行 tank localize 来执行此操作。 此命令会将工作室安装中的核心 API 复制到您的沙盒，以便稍后可以运行和测试不同版本的核心 API。Toolkit 的默认行为是默认对核心进行本地化。如果您之前未显式创建过共享的工作室核心，可以有把握地认为您的核心已经本地化。cd /my/staging/sandbox./tank localizeWelcome to the ShotGrid Pipeline Toolkit!For documentation, see https://developer.shotgridsoftware.comStarting Toolkit for your current directory '/my/staging/sandbox'- Using configuration 'Staging Sandbox' and Core v0.14.52- Setting the Context to Empty Context.- Running command localize...----------------------------------------------------------------------Command: Localize----------------------------------------------------------------------This will copy the Core API in /mnt/software/shotgun/studio into the Pipelineconfiguration /my/staging/sandbox.Do you want to proceed [yn]yLocalizing Core: /mnt/software/shotgun/studio/install/core -&amp;gt; /my/staging/sandbox/install/coreCopying Core Configuration Files...Localizing Apps: /mnt/software/shotgun/studio/install/apps -&amp;gt; /my/staging/sandbox/install/appsLocalizing Engines: /mnt/software/shotgun/studio/install/engines -&amp;gt; /my/staging/sandbox/install/enginesLocalizing Frameworks: /mnt/software/shotgun/studio/install/frameworks -&amp;gt; /my/staging/sandbox/install/frameworksThe Core API was successfully localized.Localize complete! This pipeline configuration now has an independent API.If you upgrade the API for this configuration (using the 'tank core' command),no other configurations or projects will be affected.此时，我们已不再共享工作室位置的核心 API，而是运行我们自己的独立版本。接下来，我们可以继续再次使用本地 tank 命令执行标准的核心 API 升级：cd /my/staging/sandbox./tank coreToolkit 将检查是否有新版本可用，并让您下载并安装它。更新核心 API 之后，请务必对安装进行测试。使用沙盒中的 tank 命令或使用 ShotGrid 中专门的菜单项启动一些应用。从头至尾对您的工作流进行基本调试，并执行您认为必要的测试。最后，待测试结果满意后，便可继续更新核心 API 的工作室版本。请注意，在典型的 Toolkit 设置中，所有项目共享核心 API，因此从工作室位置的 tank 命令运行 tank core 命令，即可为所有项目更新核心 API。管理项目生命周期每个 Toolkit 项目都包含一个独立的配置，用来容纳该项目的所有设置。如果您管理着大量项目，意味着您需要管理大量配置。为此，Toolkit 包含多种不同的配置处理工具和方法，它们同时适用于单个项目和工作室的生命周期及配置发展。本节概括介绍其中一些最佳实践，并说明有关设置配置的实际步骤。取决于工作室的需要，复杂程度可能会有所不同。Toolkit 提供三种不同的方法，下面我们将逐一详细介绍它们：  最直接的方法是在设置新项目时复制之前项目的配置。这种方法非常适合项目量不大的小型工作室。  如果您的项目处理量更大，并且会同时运行多个项目，我们推荐的更深一层集成是使用 git 版本控制系统。Toolkit 原生支持 Git。当您设置完毕并开始运行基于 Git 的工作流后，工作室只有一个配置，您可以跟踪一段时间内对该配置所做的所有更改。每个项目都可以根据需要导入配置更改。  如果您运营的设施规模较大，或许可以考虑将一个配置直接连接到工作室中当前处于活动状态的所有项目。对这个配置进行的任何更改，都将立即应用于所有项目。在下面的小节中，我们将详细介绍这几种不同的方法。继承之前项目的配置这是最简单的配置管理方法。首次使用 Toolkit 设置项目时，您会下载我们的默认配置。然后，根据自己的工作流设置、文件系统位置等建立第一个项目。项目开始运行后，您会运行诸如 tank updates 等命令，更新正在运行的应用版本。等到建立第二个项目时，您不用再从默认配置重新开始，可以在项目设置阶段选取第一个项目的配置作为新项目的初始配置。也就是说，您对第一个项目所做的所有更改、调整和改进，也将为第二个项目所用。同样，第三个项目可以使用第二个项目的配置等。这是让配置随时间逐步发展的一个非常简单的方法。所做的更改和改进将即时在项目之间传播。第一次运行 setup_project 命令时，只需在设置过程提示您选择要使用的配置时按 Enter 即可。这将下载并安装默认配置。设置第二个项目时，您将看到之前项目的配置路径列表。选择其中一个路径，当设置过程提示输入配置时，输入此路径。这会将相应的配置复制到新项目：Welcome to the ShotGrid Pipeline Toolkit!For documentation, see https://developer.shotgridsoftware.com- Running command setup_project...----------------------------------------------------------------------Command: Setup project----------------------------------------------------------------------Welcome to the ShotGrid Pipeline Toolkit Project Setup!Connecting to ShotGrid...Connecting to the App Store...------------------------------------------------------------------Which configuration would you like to associate with this project?You can use the configuration from an existing project as a template for thisnew project. All settings, apps and folder configuration settings will becopied over to your new project. The following configurations were found:   My very first project: '/mnt/software/shotgun/first_project/config'If you want to use any of the configs listed about for your new project, justtype in its path when prompted below.You can use the Default Configuration for your new project.  The defaultconfiguration is a good sample config, demonstrating a typical basic setup ofthe ShotGrid Pipeline Toolkit using the latest apps and engines. This will beused by default if you just hit enter below.If you have a configuration stored somewhere on disk, you can enter the pathto this config and it will be used for the new project.You can also enter an url pointing to a git repository. Toolkit will thenclone this repository and base the config on its content.[tk-config-default]: /mnt/software/shotgun/first_project/config在 Git 源代码管理系统中创建工作室配置第一种方法有一定的局限性，其中一点是项目实际上不是彼此相连。假设您有 10 个项目，当发布了某个重大错误修复时，您需要更新所有项目，这时必须手动操作每个项目并运行 tank updates 命令。解决此问题的一个办法是创建一个主配置，并将它存储在 Git 源代码管理系统中。每当您创建新项目时，只需在设置项目对话框中键入此 Git 库的路径，Toolkit 便会克隆相应内容。这样，所有项目便会连接至同一个工作室主配置。如果您对某个项目配置做了一些不错的更改，可以提交这些更改，并将它们推送至工作室主配置。其他项目随后便可轻松 Pull 这些更改。另外，您还会得到通过 Git 进行的所有更改的历史记录。Git 是什么？基本思路是建立一个用来容纳 Git 配置的 Git 库。每次运行 tank setup_project 时，您指定此库的 Git URL（例如 username@someserver.com:/studio_config.git），设置过程便会克隆该库，这样新项目就成为一个与主工作室库相连的库。它们相连后，您可以使用 Push 和 Pull 命令推送和调取更改，并可使用分支进行更精细的控制。设置工作室配置库在执行其他操作前，您需要先创建一个工作室配置库。本节介绍如何利用现有的 Toolkit 配置创建一个 Git 库。首先，您需要转至您的 Git 服务器并创建一个库。此过程可能会因您的设置而异。如果您使用的是类似 GitHub 的站点，需要启动 Web 浏览器并导航至 github.com。如果您有权访问服务器，可以执行类似 git init --bare 这样的操作。 在我们的示例中，假设您创建的 Git 库称为 username@someserver.com:/studio_config.git。接下来，将用来为库提供种子的项目的 config 文件夹复制到一个 config.bak 位置：cd /project_configs/studio_configmv config config.bak将经过初始化的 Git 库克隆到工作室配置要基于的项目的 config 位置。 运行克隆命令后，将得到一个同样是 Git 库的空白 config folder：cd /project_configs/studio_configgit clone username@someserver.com:/studio_config.git config将 config.bak 位置的所有文件复制到 config 文件夹。复制完毕后，可以删除空的 config.bak 文件夹。这时，您的配置文件已位于 Git 库内，我们需要添加、提交并将它们推送至服务器。但是在执行这些操作前，我们还要做些扫尾工作，正确处理一些 Toolkit 系统文件。在 config 文件夹中，创建一个 .gitignore 文件，并向其中添加以下几行内容：install_location.ymlpipeline_configuration.yml这样，Git 将忽略这两个系统文件。我们可以继续在配置中添加其余文件，提交它们，然后将它们推送到工作室库。git add --allgit commit -am &quot;initial commit of our studio config!&quot;git push从 Git 创建新项目当您创建新项目时，只需在设置过程提示您输入要使用的配置的路径时，指定一个有效的 Git URL 即可。按照上面的示例，我们将输入 username@someserver.com:/studio_config.git。作为项目设置过程的一部分，Toolkit 会将此库克隆到您的新项目配置的 config 文件夹。这意味着，稍后您可以转到此 config 文件夹运行 Git 命令。请注意，任何克隆的工作流配置也会克隆该 Git 库，并将无缝工作。对项目进行更改每次更改主配置后，您可以直接转到 config 文件夹，然后运行 git diff、git commit 和 git push。这会将您的更改推送到克隆您的项目配置所依据的工作室配置。更新项目以获取最新版本另外，如果您使用一些更改更新过您的工作室级配置，现在想将这些更改下载到项目中，只需转到 config 文件夹并运行 git pull 即可。  重要提示：请注意，完成此操作后务必运行 tank cache_apps，以确保系统中存在您更改的配置所需的所有应用版本！Git 高级用法：分支创建新项目时，Toolkit 的默认行为是完成一次简单的克隆操作。项目将使用 Git 的 master 分支。要进行更高级的设置，例如当您想将项目的某些配置更改保密、不想与其他项目共享这些更改时，可以在创建项目后建立一个 Git 分支。然后，将更改提交到此分支。您要推送到工作室配置的更改可以与项目的本地 master 分支合并，然后再进行推送。Git 高级用法：批量部署Toolkit 通过工作流配置实体保留了 ShotGrid 站点所有不同配置的列表，因此我们可以迭代处理此列表，为每个列表项执行 git pull 命令，这实际上相当于对所有项目运行批量更新。此功能目前并未纳入到 Toolkit 中，但可以使用 Python 和 ShotGrid Python API 编写相应的脚本。使用包含文件的全局配置上面基于 Git 的方法处理的是通过 Git 相连的独立项目配置：更新不会自动体现在所有项目中，用户必须执行 Pull 和 Push 操作来提取和推送更新。而对于完全集中式的配置，配置真正位于一处，一个更改会立即反映到一组项目。这种情况下，您需要使用 Toolkit 配置中的 @include 功能。 此功能让您可以创建引用，将每个项目配置指向一个存储实际配置的中央位置。使用 @include 语法可将多个文件串联在一起。 例如，如果您有一个 /tmp/stuff.yml 文件，其中包含以下内容：# paths to mayamaya_windows: 'C: Program  Files Autodesk Maya2012 bin maya.exe'maya_mac: '/Applications/Autodesk/maya2012/Maya.app'maya_linux: 'maya'# a configured toolkit appfile_manager:  allow_task_creation: true  file_extensions: []  hook_copy_file: default  hook_filter_publishes: default  hook_filter_work_files: default  hook_scene_operation: default  launch_at_startup: false  launch_change_work_area_at_startup: false  location: {name: tk-multi-workfiles, type: app_store, version: v0.4.8}  saveas_default_name: scene  saveas_prefer_version_up: false  sg_entity_type_filters: {}  sg_entity_types: [Shot, Asset]  task_extra_display_fields: []  template_publish: null  template_publish_area: null  template_work: null  template_work_area: null如上所述，您可以在几个不同级别创建包含定义 - 在上面的例子中，我们有一个应用定义和三个字符串值。接下来，我们可以从一个环境文件引用这些对象：includes: ['/tmp/stuff.yml']engines:  tk-maya:    # First all our app definitions    apps:        # normally, we would have the entire set of configuration parameters at this point.        # because we are using an include, we can reference an entire sub-section of configuration        # using the @ keyword:        tk-multi-workfiles: '@file_manager'        # alternatively, for simple values, we can use them as parameter values for apps:        tk-maya-launcher:          mac_path: '@maya_mac'          linux_path: '@maya_linux'          windows_path: '@maya_windows'          location: {name: tk-multi-launchapp, type: app_store, version: v0.2.19}    # and after the apps section follows specific configuration options for the engine    location: {name: tk-maya, type: app_store, version: v0.4.1}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: ShotGrid File Manager...}    template_project: null    use_sgtk_as_menu_name: false此外，您可以逐个读入几个包含文件。如果两个不同的文件中存在相同的包含定义，将优先使用最新读取的文件。我们可以扩展上面的示例环境：includes:    # first include a global config file which contains all the studio level app definitions    - '/studio/configurations/studio_apps.yml'    # now we can include an include containing overrides, for example based on project type.    # if the global config contains an entry named file_manager and the vfx_apps.yml contains    # the same, the vfx_apps definition will be used.    - '/studio/configurations/vfx_apps.yml'engines:  tk-maya:        apps:        tk-multi-workfiles: '@file_manager'    location: {name: tk-maya, type: app_store, version: v0.4.1}    use_sgtk_as_menu_name: false使用刚刚介绍的方法，可以得到一组工作室默认值，这些默认值可被项目类型默认值改写，而后者又可以被特定的项目设置改写。您既可以如上面示例中所示，在应用一级使用此功能，也可以如下节中所示，在插件一级使用此功能。设置全局配置的最佳实践设置全局配置的方法有多种。我们建议的最佳做法是按插件对配置进行细分。每个环境文件完全空白，并引用在单独的文件中定义的插件（和应用）。这样便于逐个插件地调整和重新配置设置。每个包含文件均采用标准形式，以插件的名称命名。例如，如果您有一个 Maya 插件，包含文件将只包含该插件和它的应用。其顶层项直接命名为 maya：maya:    apps:      tk-maya-breakdown:        hook_multi_update: default        hook_scan_scene: default        location: {name: tk-maya-breakdown, type: app_store, version: v0.2.13}      tk-multi-loader2:        action_mappings:          Maya Scene: [reference, import]          Photoshop Image: [texture_node]          Rendered Image: [texture_node]        actions_hook: '{self}/tk-maya_actions.py'        entities:        - caption: Assets          entity_type: Asset          filters:          - [project, is, '{context.project}']          hierarchy: [sg_asset_type, code]        filter_publishes_hook: '{self}/filter_publishes.py'        location: {name: tk-multi-loader2, type: app_store, version: v1.0.6}        menu_name: Load        publish_filters: []        title_name: Loader      [... additional app entries here ...]    debug_logging: true    location: {name: tk-maya, type: app_store, version: v0.3.10}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: ShotGrid File Manager...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}    - {app_instance: tk-multi-workfiles, name: ShotGrid Save As...}    - {app_instance: tk-multi-publish, name: Publish...}    template_project: shot_work_area_maya    use_sgtk_as_menu_name: false# each include file has a framworks section containing all the frameworks needed for# all apps in the fileframeworks:  tk-framework-shotgunutils_v1.x.x:    location: {name: tk-framework-shotgunutils, type: app_store, version: v1.0.8}在您的工作室中，您很可能并不只有一套 Maya 设置，而是会为不同部门和不同类型的工作准备多套不同的设置。我们建议您为每套设置分别建立一个 maya 包含文件，并按文件层次结构进行组织。这其中的每个文件都像上面的文件一样，在顶层具有一个 maya 项。现在，每个项目都将包含一些环境。每个环境文件都将是一个插件包含文件的列表，将这个特定环境链接到一组插件和应用设置。您可以为自己的工作室设置一个（或几个）默认的项目配置，都包含这样的包含文件，以确保实际的应用和插件负载完全包含在包含文件内，从而实现全局性。如果您更改全局包含文件，所有项目都将受到影响。使用这种设置，您的环境文件看起来将如下所示：includes:         - '/studio/configurations/maya/asset.yml'    - '/studio/configurations/nuke/asset.yml'    - '/studio/configurations/houdini/generic.yml'engines:  tk-maya: '@maya'  tk-nuke: '@nuke'  tk-houdini: '@houdini'# we don't need any frameworks here because there are no apps or engines definedframeworks: null如果您想打破上面的设置，定义一些特定于项目的条目，可以在环境文件本身中直接将 @maya 替换为一系列应用和插件定义。管理全局配置管理全局配置比管理普通配置更加复杂。因为您实际上已将多个项目合并为一个文件结构，无论是从任意项目运行 tank updates 命令还是选择更新某个应用版本，都将影响其他所有项目，因此操作时要谨慎行事。另外要注意的是，标准的克隆工作流不能直接使用，因为您克隆的是项目配置，而它现在只含有一些包含文件。出于安全测试和维护的考虑，我们建议将全局配置存储在源代码管理系统中（例如 git），然后在单独的测试区对专门的测试项目进行更新。 待通过质量控制检查后，再提交更改并将它们导入实际的全局配置中。",
    "url": "/60762324/",
    "relUrl": "/60762324/"
  },
  "23": {
    "id": "23",
    "title": "配置未指向磁盘上的有效包！",
    "content": "配置未指向磁盘上的有效包！用例首次安装 ShotGrid Desktop 时，打开项目后，文件路径后可能会出现此错误。如何修复在 Windows 上，项目的工作流配置实体指向配置的 ... ShotGrid Configurations 路径。这可能不是正确的路径，因此，第一步是确保路径存在或对其进行更正。还有一种可能，您可以尝试从您无权访问该路径位置的集中式安装进行访问。在这种情况下，切换到分布式安装将会有所帮助。相关链接在社区中查看完整主题",
    "url": "/84bb455b/",
    "relUrl": "/84bb455b/"
  },
  "24": {
    "id": "24",
    "title": "Connecting Your Studio With Your AWS VPC",
    "content": "Connecting Your Studio With Your AWS VPCYou can connect your studio networks with AWS using one of many options, described in detail in this Amazon Virtual Private Cloud Connectivity Options whitepaper.Some of the common options our clients have used include:VPN ConnectionUsing a VPN appliance - AWS-managed or client-managed - your studio can establish a secure connection between your data center (or offices) to your AWS private VPC.AWS Direct ConnectAWS Direct Connect creates a dedicated link between your studio and your AWS VPC. This will help segregate your studio’s network traffic to your private AWS VPC from general internet traffic.",
    "url": "/de0ef1a3/",
    "relUrl": "/de0ef1a3/"
  },
  "25": {
    "id": "25",
    "title": "为什么我的上下文缺少任务/工序，但它是文件名的一部分？",
    "content": "为什么我的上下文缺少任务/工序，但它是文件名的一部分？通过 Toolkit 创建文件夹时，它会根据实体注册路径，以便执行查找。这意味着如果指定了路径，就可以确定正确的上下文。Toolkit 将仅为从数据结构生成的文件夹创建注册表，因此不考虑仅在 templates.yml 文件中定义的文件名或文件夹等因素。如果您的数据结构中没有 Task 文件夹，则可能会遇到 Toolkit 需要了解文件的任务，但无法仅从路径中读取任务的情况。示例以下面的默认数据结构为例，在文件夹创建过程中将注册 Asset 和 Step 文件夹：如果使用模板生成如下所示的文件路径：assets/{sg_asset_type}/{Asset}/{Step}/work/maya/{task_name}_{name}.v{version}.{maya_extension}`然后尝试从生成的路径确定上下文，这仅可以构建 Asset 和 Step，而不是 Task，不论文件路径中的任务名称是什么。解决方案对于大多数工作流，数据结构中可以具有 Step 文件夹，也可以没有 Task 文件夹。通常，您会通过选择要处理的任务，然后选择文件，以使用 Workfiles 应用打开场景文件。然后使用您在 UI 中选择的任务来驱动上下文，而不是尝试从打开的文件的路径确定上下文。但是，在某些情况下，能够从路径获得上下文这一点可能很重要，例如：  使用我们的自动上下文切换功能；该功能允许 Toolkit 检测您何时在软件的本地打开对话框中打开文件（而不是通过 Workfiles 应用）并相应地切换当前上下文。  在需要为给定文件确定上下文的独立过程中使用 API。针对这些情况的解决方案是将 Task 文件夹引入到您的数据结构中，或者不使用自动上下文切换，对于 API 脚本，请确保您的过程已具有所需的上下文信息，而无需执行此查找操作。",
    "url": "/a10dadb2/",
    "relUrl": "/a10dadb2/"
  },
  "26": {
    "id": "26",
    "title": "贡献手册",
    "content": "贡献手册为了尽量使我们的工作公开化，我们决定基于 Creative Commons 许可在一个公共库中构建开发人员文档。如果您有改进此文档的办法，欢迎您发出库的 Pull 请求并提供改进办法。要让我们接受 Pull 请求，您需跟我们签订下列贡献者协议之一：  个人贡献协议  公司贡献协议提交上面一种协议后，您可以按照自述文件中有关如何提交变更的说明进行操作。",
    "url": "/92b042bd/",
    "relUrl": "/92b042bd/"
  },
  "27": {
    "id": "27",
    "title": "如何将我的配置修改为使用多个存储根目录？",
    "content": "如何将我的配置修改为使用多个存储根目录？我们提供的默认配置设置为使用单个本地存储根目录（即，所有项目文件都存储在单个根目录点下，如 /sgtk/projects）。您可能需要添加新的存储根来存储您的部分项目文件。例如，磁盘空间不足或者某些媒体需要位于更快的存储上时，经常会出现这种情况。假设您想要添加另一个名为“secondary”的根。以下是您需要执行的步骤：在 ShotGrid 中添加本地存储  在 ShotGrid 中，导航到“管理 &amp;gt; 站点偏好设置”(Admin &amp;gt; Site Preferences)页面  打开“文件管理”(File Management)部分  单击“[+] 添加本地文件存储”([+] Add Local File Storage)  填写名称（“secondary”）以及存储根在所有相关平台上的路径。如果您使用的不是特定平台，只需将其留空。  单击页面顶部或底部的“保存页面”(Save Page)按钮将新存储根添加到工作流配置中Toolkit 在 config/core/roots.yml 文件中缓存工作流配置中使用的本地存储相关信息。编辑此文件以添加刚刚在 ShotGrid 中创建的新 secondary 存储根：primary: {    linux_path: /mnt/hgfs/sgtk/projects,    mac_path: /sgtk/projects,    windows_path: 'z: sgtk projects'}secondary: {    linux_path: /mnt/hgfs/sgtk/secondaries,    mac_path: /sgtk/secondaries,    windows_path: 'z: sgtk secondaries'}                    注意: 自 tk-core v0.18.141 起，roots.yml 中定义的根名称不需要与 SG 中定义的本地存储名称一致。您可以通过在 roots.yml 定义中添加 shotgun_storage_id: &amp;lt;id&amp;gt; 键/值对来明确定义连接。示例：secondary: {    linux_path: /mnt/hgfs/sgtk/secondaries,    mac_path: /sgtk/secondaries,    windows_path: 'z: sgtk secondaries'    shotgun_storage_id: 123}当前，存储 ID 仅可通过 API 调用查询。    修改数据结构以使用新的本地存储根您已定义新存储根并且 Toolkit 基本上了解了该存储根，现在，您需要决定如何在您的目录结构中使用该存储根。本例中，假设您希望将所有资产工作转到 secondary 存储中，而所有镜头工作转到 primary 存储中。您可能会在 config/core/schema 中将您的数据结构设置为如下所示：config/core/schema/project.yml# the type of dynamic contenttype: &quot;project&quot;# name of project root as defined in roots.ymlroot_name: &quot;primary&quot;config/core/schema/secondary.yml# the type of dynamic contenttype: &quot;project&quot;# name of project root as defined in roots.ymlroot_name: &quot;secondary&quot;您还需要修改其过滤器中引用根的任何 YAML 文件。例如，如果您的 secondary 文件夹下某处存在 asset.yml，则需要更新过滤器，以使其根据 secondary 文件夹值过滤项目。filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$secondary&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }更新模板路径以指定要使用的存储根最后，您将更新1在 config/core/templates.yml 文件中定义的路径以指定要使用的存储根，同时根据需要更新任意路径。请记住，您的模板路径与数据结构形影不离，它们需要匹配。如果定义的模板路径与数据结构中定义的路径未正确匹配，将会出现错误。例如，由于我们希望所有资产工作保存在 secondary 存储上，因此为了更新 maya_asset_work 模板路径，我们需要将其修改为如下所示：maya_asset_work:    definition: '@asset_root/work/maya/{name}.v{version}.ma'    root_name: 'secondary'您应该对 config/core/templates.yml 文件中的每个模板路径采用与此相同的模式。为每个路径指定正确的 root_name（primary 或 secondary）。                    注意: 不需要为使用默认存储根的模板指定 root_name。可通过在 roots.yml 文件中指定 default: true 来指示默认根。如果 roots.yml 中未明确定义默认根，名为 primary 的根将被视为默认根。    1 值得注意的是，更新路径可能并不理想，因为一旦设置新值，Toolkit 将无法访问使用先前值创建的旧文件（例如，更改旧工作文件的模板路径后，Toolkit 将找不到这些文件）。如果您担心这一点，可以使用新位置创建新模板（例如，houdini_shot_publish_v2）并升级您的应用以使用该新版本。并非所有应用都会处理诸如此类的回退概念，但这将支持某些应用识别旧文件。这不会影响发布，因为它们始终链接到其在 ShotGrid 中的发布。",
    "url": "/9ea9dd4e/",
    "relUrl": "/9ea9dd4e/"
  },
  "28": {
    "id": "28",
    "title": "严重！无法使用文件夹数据更新 ShotGrid。",
    "content": "TankError: 无法在磁盘上创建文件夹。报告错误: 严重！无法使用文件夹数据更新 ShotGrid。用例我们正在使用集中式配置，并为现有项目添加 Linux 支持，但文件系统配置存在问题。我们已经  将相应的根添加到 roots.yml  在工作流配置、install_location.yml 等中添加了 Linux 路径  为软件实体添加了 Linux 路径现在，ShotGrid Desktop 会成功启动，但尝试启动程序时，会出现：TankError: Could not create folders on disk. Error reported: Critical! Could not update Shotgun with folder data. Please contact support. Error details: API batch() request with index 0 failed.  All requests rolled back.API create() CRUD ERROR #6: Create failed for [Attachment]: Path /mnt/cache/btltest3 doesn't match any defined Local Storage.同样，当尝试运行 tank 文件夹和其他命令时，也会出现相同的错误。我相信我们已经在所有必要的位置添加了 Linux 路径。这是同步数据库的问题吗？tank synchronize_folders 会输出消息和其他内容。  路径未与任何 ShotGrid 对象相关联。如何修复在“站点偏好设置 &amp;gt; 文件管理”(Site Preferences &amp;gt; File Management)下，将 Linux 路径添加到 ShotGrid 中的本地存储。相关链接在社区中查看完整主题",
    "url": "/904fdaf9/",
    "relUrl": "/904fdaf9/"
  },
  "29": {
    "id": "29",
    "title": "如何通过 API 创建发布？",
    "content": "如何通过 API 创建发布？我们的 sgtk API 提供了一种在 ShotGrid 中注册 PublishedFiles 实体的便捷方法。此外，我们还提供 Publish 应用（附带自己的 API）。发布 API 最终使用核心 sgtk API 方法来注册 PublishedFile，但它还会围绕集合、验证和发布提供一个可自定义的框架。除了发布 API 文档外，我们还在工作流教程中举例说明了如何编写自己的发布插件。使用 register_publish() API 方法虽然可以使用原始 ShotGrid API 调用在 ShotGrid 中创建发布记录，但是我们强烈建议使用 Toolkit 的便捷方法。创建发布的所有 Toolkit 应用都使用称为 sgtk.util.register_publish() 的 API 实用程序方法。基本上来说，此方法会在 ShotGrid 中创建一个新的 PublishedFile 实体，并尝试使用 Toolkit 概念简化操作过程。您的代码应该与下面类似：# Get access to the Toolkit APIimport sgtk# this is the file we want to publish.file_to_publish = &quot;/mnt/projects/proj/seq_abc/shot_123/comp/foreground.v034.nk&quot;# alternatively, for file sequences, we can just use# a standard sequence token# file_to_publish = &quot;/mnt/projects/proj/seq_abc/shot_123/comp/renders/v034/foreground.%04d.exr&quot;# The name for the publish should be the filename# without any version number or extensionname = &quot;foreground&quot;# initialize an API object. If you have used the Toolkit folder creation# to create the folders where the published file resides, you can use this path# to construct the API object. Alternatively you can create it from any ShotGrid# entity using the sgtk_from_entity() method.tk = sgtk.sgtk_from_path(file_to_publish)# use the file to extract the context. The context denotes the current work area in Toolkit# and will control which entity and task the publish will be linked up to. If you have used the Toolkit# folder creation to create the folders where the published file resides, you can use this path# to construct the context.ctx = tk.context_from_path(file_to_publish)# alternatively, if the file you are trying to publish is not in a location that is# recognized by toolkit, you could create a context directly from a ShotGrid entity instead:ctx = tk.context_from_entity(&quot;Shot&quot;, 123)ctx = tk.context_from_entity(&quot;Task&quot;, 123)# Finally, run the publish command.# the third parameter (file.nk) is typically the file name, without a version number.# this makes grouping inside of ShotGrid easy. The last parameter is the version number.sgtk.util.register_publish(  tk,  ctx,  file_to_publish,  name,  published_file_type=&quot;Nuke Script&quot;,  version_number=34)除了如上所示的基本选项外，还有几个其他选项可以填充。有关参数的完整列表及其功能，请参见核心 API 文档。                    提示: 如果您的代码从 Toolkit 应用内运行，您可以通过 self.sgtk 获取 sgtk 实例，通过 self.context 获取上下文。如果它不在应用中，但将在存在 Toolkit 集成的软件内运行，您可以使用以下代码访问当前上下文和 sgtk 实例：import sgtkcurrentEngine = sgtk.platform.current_engine()tk = currentEngine.sgtkctx = currentEngine.context    ",
    "url": "/ed4bcc20/",
    "relUrl": "/ed4bcc20/"
  },
  "30": {
    "id": "30",
    "title": "如何在 Linux 上为 ShotGrid Desktop 设置桌面/启动程序图标？",
    "content": "如何在 Linux 上为 ShotGrid Desktop 设置桌面/启动程序图标？当前 ShotGrid Desktop 安装程序不会自动创建快捷方式和启动条目，因此，您之后必须手动执行此操作。此操作很简单，但可能因您使用的 Linux 版本不同而有所不同。运行 ShotGrid Desktop 安装程序后，ShotGrid Desktop 可执行文件将位于 /opt/Shotgun folder 中。可执行文件的名称是 ShotGrid。图标不会随安装程序一起分发。请从 ShotGrid Desktop 插件 github 库 进行下载。下载完图标并获得可执行文件的路径 (/opt/Shotgun/Shotgun) 后，请手动创建您可能需要的所有桌面或菜单启动程序。执行此操作的过程因 Linux 版本而异，但通常情况下，您可以在桌面上单击鼠标右键，并在其中寻找合适的菜单选项，从而创建桌面启动程序。",
    "url": "/d82ab5ce/",
    "relUrl": "/d82ab5ce/"
  },
  "31": {
    "id": "31",
    "title": "跨项目工作流",
    "content": "跨项目工作流最佳设计体验通过 ShotGrid 中的跨项目工作流，您可以跨多个项目重用、共享和处理资产。最常见的重用资产方法是将单个“资产库”项目用作源项目。尽管我们仍建议使用单个“库”项目来保持其简捷性，但 ShotGrid 也允许您跨任意活动项目链接资产。有两种主要方法来重用资产。较为灵活的方法是“按原样”重用源资产（直接引用）。但是，因项目和工作流的不同，可能会存在一些制约或局限，因此也可以选择将源资产复制到项目中（“复制”或“派生”）。  直接引用 - 按原样重用源资产。如果该资产发生更改，可以保留您的版本或更新到最新版本。  复制或派生 - 从另一项目导入源资产（断开与源资产的所有连接），以在其上构建或控制资产并保存到您的当前项目中。跨项目/库项目工作流本教程将介绍如何使用 ShotGrid Toolkit 跨多个项目重用资产，并构建一个便于工作室艺术家访问的资产库。我们来介绍三个主要步骤，以便快速入门。  跨项目链接 ShotGrid 资产 - 使用“链接的项目”(Linked Projects)字段在资产和项目之间进行链接  将资产加载/引用到场景中 - 使用加载器中的一个动态选项卡  保持资产为最新 - 使用场景细分应用第 1 步 - 链接资产重用资产的第一步是让 ShotGrid 了解您还想要在哪些项目中使用源资产。在源项目（包含您要重用的原始资产）中，导航到“资产”(Assets)页面。将“链接的项目”(Linked Projects)字段添加到“资产”(Assets)页面（如果尚未显示）。然后，指定要重用资产的项目。有关详细文档，请单击此处。第 2 步 - 加载资产通过“链接的项目”(Linked Projects)字段正确链接资产后，您便可以在加载器中使用便捷的动态选项卡来显示您工作室链接的可重用资产。这有助于艺术家和创意团队轻松地跨多个项目重用资产。正确链接资产后：  启动您选择的内容创建软件（Maya、Houdini、Alias 等）  通过打开或保存工作场景来设置上下文  设置场景上下文后，从 ShotGrid 菜单启动加载器  现在，您将看到“资产链接”(Assets - Linked)选项卡，通过该选项卡可以跨项目访问资产的已发布文件。有关将此选项卡添加到加载器配置中的详细说明，请单击此处。在这里，您可以利用内容创建软件加载器动作来执行诸多操作，例如导入（如果您计划复制或派生资产，则会断开与其源资源的所有连接），或者引用资产（持续连接到当前版本和该资产的所有后续版本）。第 3 步 - 更新资产如果选择通过保持与源资产的连接来引用资产，您可能想要查看对源资产所做的更新和更改。在这种情况下，通常会有另一个团队继续迭代源资产，而您则需要最新版本。在配置中使用场景细分 2 应用将使您能够查看场景中当前引用的所有项。当这些引用中的任何内容更新时，场景细分将显示冲突，共享有关更改内容的已发布文件注释，并允许您更新到已发布文件的最新版本或任何其他版本。注意：仅当使用高级配置时，才会应用资产更新。如果您的工作室使用的是基本配置，您将无权访问此场景细分应用。",
    "url": "/0d2b28cd/",
    "relUrl": "/0d2b28cd/"
  },
  "32": {
    "id": "32",
    "title": "使用自定义浏览器协议启动应用程序",
    "content": "使用自定义浏览器协议启动应用程序目录  注册协议          在 Windows 上注册协议      在 macOS 上注册协议      在 Linux 上注册协议      动作菜单项 (AMI) 有一个非常实用的版本，即可在本地计算机上运行应用程序或脚本的版本。要实现这一点，需要在浏览器与要运行的脚本或应用程序之间建立连接。此链接称为自定义浏览器协议。您可能想要设置一种类型的链接，用户单击它时将启动 [foo] 应用程序。不是将“http”作为前缀，而是需要指定自定义协议，例如“foo”。理想情况下，链接类似如下：foo://some/info/here操作系统必须知道如何处理协议。默认情况下，所有当前操作系统都知道“http”应由默认 Web 浏览器处理，“mailto”应由默认邮件客户端处理。有时，安装应用程序时，它们会向操作系统注册并告诉它针对特定协议启动应用程序。例如，如果您安装 RV，则该应用程序向操作系统注册 rvlink://，并告知它 RV 将处理所有 rvlink:// 协议请求以在 RV 中显示图像或镜头序列。因此，当用户单击以 rvlink:// 开头的链接时（正如您可以在 ShotGrid 中执行的操作），操作系统将知道对该链接启动 RV，而该应用程序将解析链接并知道如何处理它。有关 RV 如何充当 URL 和“rvlink”协议的协议处理程序的详细信息，请参见 RV 用户手册。注册协议在 Windows 上注册协议在 Windows 上，注册协议处理程序涉及修改 Windows 注册表。下面是您所需的注册表项的常规示例：HKEY_CLASSES_ROOTfoo(Default) = &quot;URL:foo Protocol&quot;URL Protocol = &quot;&quot;shellopencommand (Default) = &quot;foo_path&quot; &quot;%1&quot;目标 URL 如下所示：foo://host/path...                    注意: 有关详细信息，请参见 http://msdn.microsoft.com/en-us/library/aa767914(VS.85).aspx。    Windows QT/QSetting 示例如果您开发的应用程序是使用 QT（或 PyQT/PySide）框架编写的，可以利用 QSetting 对象来为您管理注册表项的创建。自动让应用程序设置注册表项的代码如下所示：// cmdLine points to the foo path.//Add foo to the Os protocols and set foobar to handle the protocolQSettings fooKey(&quot;HKEY_CLASSES_ROOT  foo&quot;, QSettings::NativeFormat);mxKey.setValue(&quot;.&quot;, &quot;URL:foo Protocol&quot;);mxKey.setValue(&quot;URL Protocol&quot;, &quot;&quot;);QSettings fooOpenKey(&quot;HKEY_CLASSES_ROOT  foo  shell  open  command&quot;, QSettings::NativeFormat);mxOpenKey.setValue(&quot;.&quot;, cmdLine);通过 ShotGrid AMI 启动 Python 脚本的 Windows 示例在本地运行的许多 AMI 可能选择通过 Python 解释器启动简单的 Python 脚本。这样，您可以使用 GUI（PyQT、PySide 或您选择的 GUI 框架）运行简单脚本甚至应用。让我们看一个实际示例来帮您入门。步骤 1：设置自定义“ShotGrid”协议使用 Windows 注册表编辑器：[HKEY_CLASSES_ROOT ShotGrid]@=&quot;URL:ShotGrid Protocol&quot;&quot;URL Protocol&quot;=&quot;&quot;[HKEY_CLASSES_ROOT ShotGrid shell][HKEY_CLASSES_ROOT ShotGrid shell open][HKEY_CLASSES_ROOT ShotGrid shell open command]@=&quot;python&quot;&quot;sgTriggerScript.py&quot;&quot;%1&quot;此设置将注册 ShotGrid:// 协议以启动 python 解释器，第一个参数为脚本 sgTriggerScript.py，第二个参数为 %1。请务必了解，%1 将替换为在浏览器中单击的 URL 或调用的 AMI 的 URL。这将成为您的 Python 脚本的第一个参数。                    提示: 您可能需要提供您的 Python 解释器和您的 Python 脚本的完整路径。请进行相应的调整。    步骤 2：在您的 Python 脚本中解析传入 URL在您的脚本中，您将获取提供的第一个参数 (URL)，然后向下解析到其各个组成部分以了解调用 AMI 的上下文。我们在以下代码中提供了一些简单的基架，显示如何执行此操作。Python 脚本import sysimport pprinttry:    from urlparse import parse_qsexcept ImportError:    from urllib.parse import parse_qsdef main(args):    # Make sure we have only one arg, the URL    if len(args) != 1:        sys.exit(&quot;This script requires exactly one argument&quot;)    # Make sure the argument have a : symbol    if args[0].find(&quot;:&quot;) &amp;lt; 0:        sys.exit(&quot;The argument is a url and requires the symbol ':'&quot;)    # Parse the URL    protocol, fullPath = args[0].split(&quot;:&quot;, 1)    # If there is a querystring, parse it    if fullPath.find(&quot;?&quot;) &amp;gt;= 0:        path, fullArgs = fullPath.split(&quot;?&quot;, 1)        action = path.strip(&quot;/&quot;)        params = parse_qs(fullArgs)    else:        action = fullPath.strip(&quot;/&quot;)        params = &quot;&quot;    # This is where you can do something productive based on the params and the    # action value in the URL. For now we'll just print out the contents of the    # parsed URL.    fh = open('output.txt', 'w')    fh.write(pprint.pformat((protocol, action, params)))    fh.close()if __name__ == '__main__':    sys.exit(main(sys.argv[1:])) 注意：此脚本与 Python 3 和 Python 2 兼容。步骤 3：使用您的自定义协议连接 ShotGrid 界面，并最终连接您的脚本最后，在 ShotGrid 中创建其 URL 值为 shotgrid://processVersion 的 AMI。您可以将此 AMI 指定到您希望的任何实体类型，但此示例使用版本实体。转到某个版本页面，右键单击一个版本并从菜单中选择您的 AMI。这应使您的浏览器打开 shotgrid:// URL，此 URL 将通过注册的自定义协议重定向到您的脚本。在您的脚本所在目录中的 output.txt 文件中，您现在应该会看到类似如下的内容：('processVersion', {'cols': ['code',           'image',           'entity',           'sg_status_list',           'user',           'description',           'created_at'],  'column_display_names': ['Version Name',                           'Thumbnail',                           'Link',                           'Status',                           'Artist',                           'Description',                           'Date Created'],  'entity_type': ['Version'],  'ids': ['6933,6934,6935'],  'page_id': ['4606'],  'project_id': ['86'],  'project_name': ['Test'],  'referrer_path': ['/detail/HumanUser/24'],  'selected_ids': ['6934'],  'server_hostname': ['my-site.shotgrid.autodesk.com'],  'session_uuid': ['9676a296-7e16-11e7-8758-0242ac110004'],  'sort_column': ['created_at'],  'sort_direction': ['asc'],  'user_id': ['24'],  'user_login': ['shotgrid_admin'],  'view': ['Default']})可能的变量通过变换您的 AMI 中 URL 的 // 部分后面的关键字，可以更改您的脚本中 action 变量的内容，同时保持相同的 shotgrid:// 协议并且仅注册一个自定义协议。然后，根据 action 变量的内容和参数的内容，您的脚本可以获知预期行为应是什么。通过使用此方法，您可以打开应用程序、通过 FTP 等服务上传内容、归档数据、发送电子邮件或生成 PDF 报告。在 macOS 上注册协议要在 macOS BigSur 和 Monterey 上注册协议，需要创建配置为运行应用程序或脚本的 .app 包。步骤 1：AppleScript 脚本编辑器首先，在 AppleScript 脚本编辑器中编写以下脚本：on open location this_URL    do shell script &quot;sgTriggerScript.py '&quot; &amp;amp; this_URL &amp;amp; &quot;'&quot;end open location 调试提示：捕获错误，然后将其显示在弹出窗口中，这样您便可以查看在执行 Python 脚本时是否存在任何问题，避免系统悄然执行错误。以下是可添加到 AppleScript 中以用于试错的示例代码段：on open location this_URL	try		do shell script &quot;/path/to/script.py '&quot; &amp;amp; this_URL &amp;amp; &quot;'&quot;	on error errStr		display dialog &quot;error&quot; &amp;amp; errStr	end tryend open location   注意：为了确保从特定 Shell（如 tcsh）运行 Python，您可以更改 do shell script，如下所示：do shell script tcsh -c  &quot;sgTriggerScript.py '&quot; &amp;amp; this_URL &amp;amp; &quot;' &quot;。在脚本编辑器中，将您的简短脚本保存为 应用程序包。步骤 2：编辑 info.plist 文件找到保存的应用程序包，并打开内容。然后打开 info.plist 文件，并将以下内容添加到 plist dict：&amp;lt;key&amp;gt;CFBundleIdentifier&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;com.mycompany.AppleScript.ShotGrid&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;CFBundleURLTypes&amp;lt;/key&amp;gt;&amp;lt;array&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;CFBundleURLName&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;ShotGrid&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;CFBundleURLSchemes&amp;lt;/key&amp;gt;&amp;lt;array&amp;gt;&amp;lt;string&amp;gt;ShotGrid&amp;lt;/string&amp;gt;&amp;lt;/array&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/array&amp;gt;您也可以更改以下三个字符串（可选）：com.mycompany.AppleScript.ShotGridShotGridShotGrid第三个字符串是协议处理程序；因此 URL 为：shotgrid://something如果使用 BigSur，您需要 删除 info.plist 文件中位于 NSAppleEventsUsageDescription 和 NSSystemAdministrationUsageDescription 之间的以下行。如果您使用的版本早于 BigSur，请跳过此步骤，然后继续执行下面的步骤 3。	&amp;lt;key&amp;gt;NSAppleMusicUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your music to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSCalendarsUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your calendars to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSCameraUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your camera to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSContactsUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your contacts to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSHomeKitUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your HomeKit Home to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSMicrophoneUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your microphone to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSPhotoLibraryUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your photos to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSRemindersUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your reminders to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSSiriUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to Siri to run.&amp;lt;/string&amp;gt; 步骤 3：将 .app 包移动到“应用”(Applications)文件夹最后，将您的 .app 包移到您的 Mac 上的 Applications 文件夹中。然后双击它，这将向操作系统注册您的协议。数据流如下：在 ShotGrid 中单击 AMI 后，或单击以 shotgrid:// 开头的 URL 后，.app 包将响应它，并将 URL 传递到您的 Python 脚本。此时，可以使用在 Windows 示例中所用的同一脚本，且所有相同的可能情况均适用。                    提示: 有关 Monterey 疑难解答的其他信息，请访问此社区帖子。    在 Linux 上注册协议使用以下代码：gconftool-2 -t string -s /desktop/gnome/url-handlers/foo/command 'foo &quot;%s&quot;'gconftool-2 -s /desktop/gnome/url-handlers/foo/needs_terminal false -t boolgconftool-2 -s /desktop/gnome/url-handlers/foo/enabled true -t bool然后将您本地 GConf 文件中的设置用于以下文件中的全局默认设置：/etc/gconf/gconf.xml.defaults/%gconf-tree.xml尽管仅在 GNOME 设置中进行更改，但对 KDE 也有效。Firefox 和 GNU IceCat 在遇到无法识别的前缀（例如 foo://）时会采用 gnome-open，无论运行的窗口管理器是什么。因此，在这种情况下，其他浏览器（例如 KDE 中的 Konqueror）无法运行。有关如何在 Ubuntu 中为动作菜单项设置协议处理程序的详细信息，请参见 https://askubuntu.com/questions/527166/how-to-set-subl-protocol-handler-with-unity。",
    "url": "/af0c94ce/",
    "relUrl": "/af0c94ce/"
  },
  "33": {
    "id": "33",
    "title": "sgtk.env.project.tk-nuke.tk-multi-workfiles2 无法创建“文件打开”(File Open)对话框！",
    "content": "data_handler_cache 错误消息: 错误 sgtk.env.project.tk-nuke.tk-multi-workfiles2 无法创建“文件打开”(File Open)对话框！用例：它发生在启动 Nuke 等应用时，tk-multi-workfiles2“文件打开”(File Open)对话框失败，在堆栈跟踪的末尾出现错误，指出 data_handler_cache 的 get_children 方法无法迭代，因为在应该传递词典时向它传递了字符串值。完整的堆栈如下所示：2020-12-07 09:42:03,571 [7192 ERROR sgtk.env.project.tk-nuke.tk-multi-workfiles2] Failed to create File Open dialog!Traceback (most recent call last):  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles work_files.py&quot;, line 115, in _show_file_dlg    self._dialog_launcher(dlg_name, app, form)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install core python tank platform engine.py&quot;, line 1822, in show_dialog    dialog, widget = self._create_dialog_with_widget(title, bundle, widget_class, *args, **kwargs)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install core python tank platform engine.py&quot;, line 1684, in _create_dialog_with_widget    widget = self._create_widget(widget_class, *args, **kwargs)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install core python tank platform engine.py&quot;, line 1658, in _create_widget    widget = derived_widget_class(*args, **kwargs)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles file_open_form.py&quot;, line 46, in __init__    FileFormBase.__init__(self, parent)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles file_form_base.py&quot;, line 64, in __init__    self._my_tasks_model = self._build_my_tasks_model()  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles file_form_base.py&quot;, line 134, in _build_my_tasks_model    bg_task_manager=self._bg_task_manager)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles my_tasks my_tasks_model.py&quot;, line 57, in __init__    bg_task_manager=bg_task_manager  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles entity_models extended_model.py&quot;, line 74, in __init__    **kwargs  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-framework-shotgunutils v5.5.0 python shotgun_model shotgun_entity_model.py&quot;, line 70, in __init__    self._load_data(entity_type, filters, hierarchy, fields)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-framework-shotgunutils v5.5.0 python shotgun_model shotgun_model.py&quot;, line 367, in _load_data    self._create_item  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install core python tank log.py&quot;, line 503, in wrapper    response = func(*args, **kwargs)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-framework-shotgunutils v5.5.0 python shotgun_model data_handler.py&quot;, line 266, in generate_child_nodes    for data_item in self._cache.get_children(unique_id):  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-framework-shotgunutils v5.5.0 python shotgun_model data_handler_cache.py&quot;, line 129, in get_children    for item in cache_node[self.CACHE_CHILDREN].itervalues():AttributeError: 'str' object has no attribute 'itervalues'导致错误的原因是什么？缓存中出现问题，您应该能够通过移除缓存来修复它（请参见下一部分）。如何修复请按照以下说明了解在何处查找缓存并将其移除。您可以擦除所有内容，但是当下次重新启动 Desktop 时，会在下载所有内容时导致延迟。建议您擦除以位于缓存根目录文件夹内的 ShotGrid 站点命名的文件夹，该文件夹仍需要进行一些重建，但不会太多。在社区中查看完整主题。",
    "url": "/aaac055f/",
    "relUrl": "/aaac055f/"
  },
  "34": {
    "id": "34",
    "title": "开发人员概述",
    "content": "开发人员概述Python APIShotGrid 软件提供基于 Python 的 API，用于访问 ShotGrid 以及与其他工具相集成。API 遵循 CRUD 模式，允许在 ShotGrid 服务器上执行创建、读取、更新和删除动作。每个请求作用于单个实体类型，根据特定动作，可以定义过滤器、返回的列、排序信息以及一些其他选项。  代码库  文档  论坛事件触发器框架如果要访问 ShotGrid 事件流，首选方法是监视事件表、获取任何新事件并对其进行处理，然后重复上述动作。需要执行许多工作才可顺利完成此流程，这些工作可能与需要应用的业务规则并无任何直接关系。框架的作用是使业务逻辑实施者摆脱任何繁琐的监视任务。该框架是一个守护进程，可在服务器上运行并监视 ShotGrid 事件流。找到事件时，守护进程会将事件分发给一系列注册的插件。每个插件均可根据情况处理事件。  代码库  文档动作菜单项框架API 开发人员可以按实体自定义上下文菜单项。例如，在“版本”(Versions)页面中，可以选择多个版本，单击鼠标右键，然后…。生成 PDF 报告（例如）。我们将其称为动作菜单项 (AMI)。  文档  代码库示例",
    "url": "/1e047003/",
    "relUrl": "/1e047003/"
  },
  "35": {
    "id": "35",
    "title": "开发",
    "content": "开发一组与使用 Toolkit 进行开发有关的快速解答。  如何在启动软件之前设置环境变量？  如何在自定义脚本中处理身份认证和登录凭据？  as_template_fields() 缺少我的上下文中的现有值  如何在 Maya 中添加用于启动 Toolki 应用的工具架按钮？  如何使用 shotgunEvent 进程加载不同的 Toolkit 核心模块？  如何使用 API 以编程方式更新我的 Toolkit 配置？  如何通过 API 创建发布？",
    "url": "/16654f1f/",
    "relUrl": "/16654f1f/"
  },
  "36": {
    "id": "36",
    "title": "开发",
    "content": "开发什么是 Toolkit？Toolkit 是用于支持我们的工作流集成的平台。例如，如果您在 Maya 中使用 ShotGrid 面板应用或从 ShotGrid Create 启动发布应用，您就是在使用基于 Toolkit 平台构建的工具。如何使用 Toolkit 进行开发？使用 Toolkit 进行开发的方式有很多。  编写自定义代码（我们称之为挂钩）来扩展现有应用、插件或框架行为。  编写自己的应用、插件或框架。  或编写自己的独立脚本，在脚本中利用 API。无论采用哪种方式，了解如何使用 Toolkit API 都非常重要。ShotGrid 整体包含三个主要 API  ShotGrid Python API  ShotGrid REST API  ShotGrid Toolkit APIToolkit API 是一种 Python API，它设计为与 ShotGrid Python API 或 REST API 一起使用，并不是用于替代它们。尽管 Toolkit API 确实有一些封装器方法，但通常情况下，只要您需要从 ShotGrid 站点访问数据，就要改用 ShotGrid Python 或 REST API。Toolkit API 主要用于文件路径的集成和管理。一些 Toolkit 应用和框架还有自己的 API。这些文章将指导您使用 Toolkit 进行开发。",
    "url": "/a1cfe87c/",
    "relUrl": "/a1cfe87c/"
  },
  "37": {
    "id": "37",
    "title": "Direct Connect",
    "content": "Direct ConnectAWS Direct Connect is a service from AWS that allows you to establish a dedicated connection from your on-premise data center (or offices) to AWS. Direct Connect will allow you to create a dedicated link between your network and one of the AWS Direct Connect locations.Leveraging AWS Direct Connect ensure that you will benefit from the best experience possible when using the isolation feature set, optimizing reliability and performance for all your access points across the globe.",
    "url": "/0de47d40/",
    "relUrl": "/0de47d40/"
  },
  "38": {
    "id": "38",
    "title": "ShotGrid AWS Direct Connect Onboarding",
    "content": "ShotGrid AWS Direct Connect OnboardingIntroductionAWS Direct Connect (DX) is used to establish private connectivity between AWS and an on-prem facility. DX provides a private, high bandwidth network connection between your network and AWS Virtual Private Cloud (VPC) and bypasses the public internet. AWS has established 100 Direct Connect locations globally and leverages the AWS Partner Network to extend the footprint.Review of Shogun Configuration in AWSCustomer Types  Customer already has AWS Direct Connect dedicated connection  Customer has equipment and network presence in an AWS Direct Connect location  Customer does not have equipment or presence in an AWS Direct Connect locationSetup Options  Request a dedicated Direct Connect connection through AWS Console          Provision the required connectivity yourself      Work with Direct Connect Partner to help establish a dedicated connection to AWS equipment        Request a hosted Direct Connect connection through AWS Direct Connect PartnerCriteria to Determine Setup PathIf you answer “yes” to the following, then request a dedicated Direct Connect connection through the AWS Console (Option 1a):  Do you already have equipment and presence in an AWS Direct Connect location?  Do you know the process for requesting a cross-connect within the Direct Connect location facility?  Are you looking for any one of the following - 1Gbps, 10Gbps port, or a dedicated connection?If you answer “yes” to the following, then request a dedicated Direct Connect connection through the AWS Console and select a Partner to assist (Option 1b):  Are you planning to use AWS Direct Connect to connect to other AWS resources outside of ShotGrid?  Do you have the time and resources to complete the setup?  Are you looking for any one of the following - 1Gbps, 10Gbps port, or a dedicated connection?If you answer “yes” to the following, then you should work with an AWS Direct Connect Partner to request a hosted Direct Connect connection (Option 2):  Are you already working with an AWS Direct Connect Partner?  Do you want a Partner to facilitate the setup?  Are you looking for a port less than 1Gbps or a hosted connection?Disclaimer:  All options are valid and the criteria are just a guide to help simplify the selection process. You can still pick any option based on more specific criteria.Setup DirectionsRequest through AWS Console - Option 1 (a and b)  Create a Connection in the AWS Console  Download the LOA-CFA. The LOA is the authorization to connect to AWS and is required to establish the cross-network connection.  (Option 1a only) Request cross-connects at AWS Direct Connect locations. Find contact information here.  (Option 1b only) Reach out to an AWS Partner and share the LOA with them.  Once the dedicated connection is provisioned into your account, set up logical connectivity (Virtual Interfaces).Request through AWS Direct Connect Partner - Option 2  Reach out to an AWS Partner. The criteria for choosing an AWS Partner are:          AWS Region      Providers      If you are already working with an AWS Direct Connect Partner        If hosted connection, accept a hosted connection. More information can be found here.  Once the hosted connection is provisioned into your account, set up logical connectivity (Virtual Interfaces).FAQHow long should it take to set up AWS Direct Connect?Short Answer - It depends. A lot of factors go into the time it takes to set up AWS Direct Connect. The timeline can vary from a few days to a few months. Some of the factors include current infrastructure, location of equipment, providers, partners, and more. If you are looking to expedite the process, consider using an AWS Direct Connect Partner who is geographically nearby.Further questions about AWS Direct Connect?AWS Direct Connect FAQsVPNA site-to-site VPN can be used as an alternative to AWS Direct Connect. Learn more about AWS VPN here.AWS Documentation &amp;amp; Resources  What is AWS Direct Connect?  Direct Connect User Guide  re:Invent 2018 - 400 level Deep Dive on Direct Connect  AWS Direct Connect Locations  AWS Direct Connect Partners",
    "url": "/8233001e/",
    "relUrl": "/8233001e/"
  },
  "39": {
    "id": "39",
    "title": "如何禁用 ShotGrid Desktop 的浏览器集成？",
    "content": "如何禁用 ShotGrid Desktop 的浏览器集成？要禁用浏览器集成，请执行以下两个简单的步骤。      在如下位置创建或打开文本文件：     Windows：%APPDATA% ShotGrid preferences toolkit.ini Macosx：~/Library/Preferences/ShotGrid/toolkit.ini Linux：~/.ShotGrid/preferences/toolkit.ini            添加以下部分：     [BrowserIntegration] enabled=0      有关如何配置浏览器集成的完整说明，请参见我们的管理员手册。替代方法如果您已接管 Toolkit 工作流配置，替代方法是从环境中删除 tk-ShotGrid 插件，使其无法加载任何动作。",
    "url": "/1bb3f6ad/",
    "relUrl": "/1bb3f6ad/"
  },
  "40": {
    "id": "40",
    "title": "文件系统配置",
    "content": "动态文件系统配置在本手册中，您将学习如何修改 Toolkit 工作流配置来自定义您的制作文件夹结构和文件命名。关于本手册管理工作流的难点之一是跟踪将要创建的众多文件。Toolkit 工作流可通过以下方法实现文件系统管理自动化：基于 ShotGrid 中的数据和配置的文件夹结构创建文件夹，然后将文件自动写入到正确的位置并使用标准化的命名，艺术家可以专注于内容创建。工作流配置带有一组默认文件夹和文件命名约定，但制作人员通常会对其进行自定义。本手册将提供进行这些自定义设置所需的知识。在默认配置中，资产按照某种文件夹结构进行管理，如 asset_type/asset/pipeline_step。在本手册中，我们将使用名为“Set”的自定义实体，按使用每个资产的制作集进行进一步组织。我们将首先在 ShotGrid 中设置自定义实体，然后使用它来管理为任意指定集创建的资产，使文件夹结构类似于 set/asset_type/asset/pipeline_step。我们可以举例演示按集组织资产背后的理念：假设您有一个项目，其中某些场景发生在车库中，其他场景发生在餐厅中。借助我们的设置，资产文件（如“wrench”、“oilcan”或“workbench”）在“garage”文件夹中组织，而“plate”、“winebottle”或“tablecloth”在“dining_room”文件夹中组织。在我们的示例中，我们将要确保鲜美多汁的“filet”资产已正确放置在餐厅。在示例中，我们还将编辑项目的文件命名模板，以使资产的 Maya 工作文件在其名称中包含集。动态生成的文件名可区分餐厅的文件与其他集中使用的文件。本手册分三个部分  在 ShotGrid 中创建一个名为“Set”的自定义实体，您将使用它来关联艺术家正在创建的餐厅元素。  编辑文件夹数据结构，使 Toolkit 包含一个基于文件夹结构中的当前集来动态命名的文件夹。  编辑用于命名资产工作文件的模板，使 Toolkit 在文件名中包含关联集的名称。先决条件要使用本手册，需要满足以下条件：  活动的 ShotGrid 站点。您应该拥有至少已创建一个资产的项目。资产应具有模型任务。  对如何使用 ShotGrid 站点管理资产具有基本了解  在系统上安装了 ShotGrid Desktop。  用于已标识项目的克隆工作流配置，或完成配置快速入门手册，并克隆在该练习中创建的配置。  基本熟悉 YAML。  为存储工作流配置的 Shotgun 管理的文件系统设置适当的读取和写入权限。  已设置适当的读取和写入权限，以允许 Toolkit 读取和写入到制作文件系统。  Maya 的有效固定期限的使用许可。获取 Maya 的 30 天试用版本手册基于 tk-config-default2 工作流配置。如果您的配置文件已修改，则文件和文件夹的位置、YAML 设置的区块可能就与此处描述的不同。关于文件数据结构和模板Toolkit 工作流配置中的数据结构和模板使您能够充分利用您的 ShotGrid 数据来管理磁盘上的制作文件。默认配置中的数据结构包括镜头、镜头序列、资产、资产类型等实体。可以添加其他实体，例如关卡、剧集、季，在我们的示例中，添加的是集这样的自定义实体。Toolkit 平台允许您使用数据结构来动态构建您的文件夹结构，数据结构是在构建实际制作文件系统时用作模板的制作文件夹结构的微型版本。数据结构是动态创建文件夹的明确指导，它使用 YAML 文件为动态创建的文件夹定义规则。默认配置包含预配置的数据结构，它支持资产和镜头工作流的文件夹创建。您将修改数据结构的一部分，它支持创建资产文件夹结构 /assets/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt;，以增加对您正在创建的新 Set 实体的支持。模板允许您使用数据结构中的 ShotGrid 数据和信息，在创建文件时对其进行动态命名和保存。默认配置提供一组入门模板，您可以对其进行编辑以符合您的工作流需求。ShotGrid 集成的基本设置不包括文件系统管理。为了为您的项目配置文件系统管理，您的项目需要高级设置。第一个手册配置快速入门介绍了高级设置流程。开始练习通过自定义数据结构和模板，您可以动态管理在创建餐厅集时生成的文件：地点设置、热气腾腾的菲力牛排、一瓶 1951 年的奔富葛兰许、千层焗薯茸、柠檬蒜芦笋等。餐厅集中使用的资产将与“餐厅”集实体相关联，使您能够更轻松地管理它们。集不是默认配置中的标准实体类型，因此您需要启用自定义实体并将其命名为 Set，然后再扩展数据结构和模板才能使用它。启用自定义实体步骤 1：在浏览器中打开 ShotGrid 站点。单击您的头像并转至“管理 &amp;gt; 站点偏好设置”(ADMIN &amp;gt; Site Preferences)。在出现的页面上，展开“实体”(Entities)部分。显示的是 ShotGrid 中可用的实体类型列表。下图中列表的顶部是为当前 ShotGrid 站点配置的某些实体类型。这些实体类型下方是尚未配置或启用的几个自定义实体。选择其中一个自定义实体类型，对其进行配置，然后将其启用。步骤 2：选择箭头以打开显示为灰色的已禁用自定义实体上的设置。选择“是，使用自定义实体…”(Yes, use Custom Entity…)旁边的单选按钮，将“显示名称”(Display name)更改为 Set，然后滚动到窗口顶部并选择“保存更改”(Save Changes)。这样做可以使此自定义实体在 ShotGrid 中处于活动状态，并将显示名称设置为 Set。实际上，您正在创建自定义实体的别名，因为实体的应用插件名称仍为 CustomEntity01。在此示例中，我们将使用 CustomEntity01；您可能会使用不同的自定义实体。请记住您选择的自定义实体的系统名称。添加数据字段以将资产与集关联通过将数据字段添加到资产实体，我们可以将资产链接到新实体。艺术家为餐厅创建的资产将与餐厅集实体关联。步骤 3：选择页面顶部的“项目”(Projects)下拉列表，打开将用于该练习的项目。步骤 4：在项目菜单栏中选择“资产”(Assets)以转到“资产”(Assets)页面。在“资产”(Assets)菜单中，选择“字段 &amp;gt; 管理资产字段…”(Fields &amp;gt; Manage Asset Fields…)此动作将显示资产字段管理器。选择“+ 添加新的字段”(+ Add a new field)。为新字段选择参数。在“新建字段名称”(New Field Name)中，键入“Set”。在“常规”(GENERAL)菜单的“字段类型”(Field Type)下，选择“实体”(Entity)，然后向下滚动以将类型限制为“集”(Set)。选择“下一步”(Next)。在本手册中，将其应用到“仅当前项目”(Only the current project)并选择“创建字段”(Create Field)。ShotGrid 将配置新字段。已应用您的更改，您可以选择“完成”(Done)。创建餐厅集实体步骤 5：选择资产的新“集”(Set)字段并开始键入“Dining Room”。将显示一个对话框，指出“未找到匹配项。创建‘Dining Room’”(No matches found. Create “Dining Room”)选择“创建‘Dining Room’”(Create “Dining Room”)。选择“创建集”(Create Set)。在资产的“集”(Set)字段中添加“Dining Room”将会创建与餐厅集实体的关联。步骤 6：将 filet 资产上的模型任务分配给您自己，以便您能够轻松找到它以进行测试。设置数据结构现在，您已启用“集”自定义实体，已创建一个名为“Dining Room”的集实体，并且已将“资产”实体链接到“Dining Room”集。您已获得 ShotGrid 站点中的所有要素，现在可以修改您的文件夹结构。艺术家开始处理某个任务时，Toolkit 会使用关联的 ShotGrid 数据来确定要在文件系统中创建的文件夹。将根据工作流配置的数据结构自动创建并命名新文件夹。现在，您需要定义随着艺术家逐步完成制作工作流，您希望 Toolkit 动态生成的文件夹结构。可以通过编辑数据结构来完成此操作。建议在克隆的配置中测试配置，以免影响活动的制作配置。克隆过程将创建配置的副本，您可以在将更改推送到活动配置之前安全地编辑该副本。您可以在配置临时沙盒和推行应用文档中找到有关克隆配置的详细信息。步骤 7：导航至您的工作流配置。向下导航到 schema 文件夹 &amp;lt;pipeline_configuration_root&amp;gt;/config/core/schema，然后打开 project 文件夹。当前数据结构，如下所示：&amp;lt;project&amp;gt;/assets/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt;支持动态创建此文件夹结构：the_other_side/assets/prop/filet/model而我们需要以下结构：the_other_side/assets/Dining-Room/Prop/filet/model要实现此目的，您需要设置如下所示的数据结构：&amp;lt;project&amp;gt;/assets/&amp;lt;CustomEntity01&amp;gt;/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt;“集”实体表示为 CustomEntity01。我们已在 ShotGrid 中为 CustomEntity01 指定显示名称 Set，但在我们的配置中，我们将始终按其应用插件名称 CustomEntity01 对其进行引用。数据结构如何使用 YAML 文件数据结构中可能包含静态和动态文件夹。如果您的数据结构中有一个名为“assets”的静态文件夹，它将对应于制作文件系统中名为“assets”的单个文件夹。另一方面，您的数据结构中可能有一个名为“asset”的动态文件夹，这表示项目中每个资产均有一个文件夹。每个动态文件夹的旁边均具有一个对应的 YAML 文件，且其名称与文件夹相同（例如 asset/ 和 asset.yml），用于定义如何根据数据结构文件夹生成制作文件夹的规则。为“集”实体创建新的文件夹和 YAML 文件数据结构的 project 文件夹中包含与 ShotGrid 跟踪的不同实体相关的文件夹。您正在添加新的资产实体 CustomEntity01，使 ShotGrid 能够跟踪集中的项。这些项是资产，因此您将编辑资产下的文件夹和 YAML 文件。同样，我们的目标是从 asset_type/asset/step 文件夹结构转入 set/asset_type/asset/step。因此，我们要添加一个文件夹来表示数据结构中的集，还有一个对应的 YAML 文件。由于我们需要对自定义实体使用应用插件名称，因此我们将创建 CustomEntity01/ 文件夹和 CustomEntity01.yml。步骤 8：在数据结构的 project/assets 文件夹中添加 CustomEntity01 文件夹。步骤 9：在 CustomEntity01 文件夹旁边创建一个名为 CustomEntity01.yml 的文件，该文件内容如下：type: &quot;shotgun_entity&quot;name: &quot;code&quot;entity_type: &quot;CustomEntity01&quot;filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }YAML 文件将向 Toolkit 提供有关如何为 CustomEntity01 文件夹命名的说明。在这种情况下，我们将创建一个 ShotGrid_entity 类型的文件夹，这意味着它对应于 ShotGrid 查询。entity_type 字段告诉我们查询 ShotGrid 中的 CustomEntity01 实体，name 字段告诉我们查询实体上的哪个字段 – 在本例中，我们将从 CustomEntity01 获取 code 字段。filters 字段限制了应该创建此动态文件夹的情况。步骤 10：将 asset_type/ 和 asset_type.yml 移到 CustomEntity01 文件夹中我们希望我们的文件夹结构类似于 Dining-Room/Prop/filet，因此 asset_type 文件夹在层次结构中应位于 CustomEntity01 文件夹下方。将 asset_type/ 和 asset_type.yml 移到 CustomEntity01 文件夹中。编辑 asset.yml 文件filters 字段限制了在指定时间为哪些实体创建了文件夹。在当前状态下，asset.yml 中的过滤器字段如下所示：filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }当我们决定为资产创建文件夹时，我们需要确保我们位于正确的 project 文件夹和正确的 asset_type 文件夹中。现在，我们已经添加了一个集文件夹，我们还将添加第三个过滤器。如果没有它，我们最后将得到如下所示的文件夹，当然这可能不正确：assets/Dining-Room/Prop/spoonassets/Garage/Prop/spoonassets/Classroom/Prop/spoon为避免这种情况，我们将添加第三个过滤器，这将确保仅在正确集的文件夹中创建资产的文件夹。步骤 11：修改 asset.yml 中的 filters 字段，使其如下所示：filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }    - { &quot;path&quot;: &quot;sg_set&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$CustomEntity01&quot; ] }测试文件夹创建现在，您已成功修改了数据结构，使其按集自定义实体组织资产。现在，我们来对其进行测试。将在 Toolkit 工作流中的几个时间点创建文件夹：  应用程序启动程序：每次用户为任务启动 DCC 时，Toolkit 都将为该任务创建目录（如果尚未创建）。由于启动 DCC 往往是用户通过 Toolkit 执行的第一个操作，因此这是创建目录的常规方式。这可以通过 ShotGrid 中的右键单击菜单执行，也可从 ShotGrid Desktop 或 Create 应用执行。  ShotGrid 菜单：为任务创建文件夹最直接的方法是在 ShotGrid 中，在其上单击鼠标右键，然后选择“创建文件夹”(Create Folders)菜单项。  Toolkit API：您可以通过 Toolkit API 直接触发目录创建逻辑。这可以用于将 Toolkit 插入到自定义启动程序中，也可用于工作流的事件触发器，您希望在其中为镜头自动创建目录，就像在 ShotGrid 中创建一样。  tank 命令：与 ShotGrid 中的菜单项类似，tank folders 终端命令也可以为任务创建文件夹。我们将使用 tank 命令进行测试。步骤 12：在 filet 资产上运行 tank folders。从终端运行以下命令：&amp;gt; cd &amp;lt;pipeline_configuration_root_folder&amp;gt;&amp;gt;  ./tank Asset Filet folders输出摘要：----------------------------------------------------------------------Command: Folders----------------------------------------------------------------------Creating folders, stand by...The following items were processed: - /Users/michelle/Documents/Shotgun/projects/the_other_side. . . - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/ - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/model - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/model/publish. . .In total, 23 folders were processed.最终的结构与预期相符，Toolkit 非常智能，它甚至在 Dining 与 Room 之间添加了一个短横线。/the_other_side/assets/Dining-Room/Prop/Filet/model用于读取和写入文件的 Toolkit 模板现在，我们已经设置了文件夹结构，下一步是编辑模板，以便在创建制作文件后对其进行恰当命名并放入正确的文件夹。Toolkit 应用如何使用模板您首先创建了一种在 ShotGrid 中将资产与集关联的方法，即启用 CustomEntity01 来表示集，然后向资产实体添加一个链接字段，以表示资产与集之间的链接。在资产与集之间建立关系后，您可设置文件夹数据结构以使用此关联，将所有资产文件夹放置在关联集的文件夹中。现在，您将创建一种方法，以动态命名文件并允许 Toolkit 应用自动管理文件。随着艺术家开始处理项目中的任务，将生成必要的文件夹结构。然后，当他们启动 Workfiles 应用的“File Save”动作时，文件将自动命名。使用通过 Toolkit 的 Workfiles 应用访问的模板对该文件命名。渲染应用（如 Nuke Write 节点和 Houdini Mantra 节点）使用模板来命名和保存渲染的文件，与已发布文件的 Publisher 应用一样。使用 Workfiles 的“File Open”动作访问文件时，它将使用模板来查找要加载的相应文件。Publisher、Loader 和 Nuke Studio Export 应用也会使用模板来查找和管理文件。美工人员不必担心文件名或位置；Toolkit 完全根据模板和正在执行的任务对其进行管理。模板通过配置文件 /&amp;lt;pipeline_configuration_root&amp;gt;/config/core/templates.yml 进行管理。在前面的两个手册中，您管理和创建了工作环境特定的设置。数据结构和模板设置存储在 config/core 文件夹中，并非特定于环境。由于所有模板均存储在单个文件中，因此在不同环境配置文件的应用设置中，都将从该文件对其进行引用。例如，template_work 是 Workfiles 应用的设置，指定要将 templates.yml 中的哪个模板用于工作文件。根据配置 Workfiles 的环境和插件，您可能会使用此配置设置，指向 templates.yml 中的 maya_shot_work 模板或 houdini_asset_work 模板。步骤 13：在工作流配置中打开 config/core/templates.yml。此文件分为三个部分：  Keys：用于构建模板的一组令牌（如 {version}、{Asset} 等）。在实际使用模板时，它们将替换为实际值。每个键都有必需的名称和类型及其他可选参数。  Paths：使用键表示磁盘上的文件夹和文件路径的命名字符串。请注意，paths 部分中的模板已经过验证，必须实际存在于磁盘上。  Strings：与 paths 部分相似，但这些是任意文本的模板。paths 部分中的项已经过验证，必须与磁盘上的实际路径对应，而字符串可用于存储您希望在 Toolkit 工作流中引用的任何文本数据。为集实体添加模板键首先要做的就是使用实体的应用插件名称，为集实体定义一个新的键。步骤 14：将以下行添加到 templates.yml 的 keys 部分，注意正确缩进：       CustomEntity01:           type: str修改模板由于模板定义了 Toolkit 读取和写入文件的位置，因此我们在此处定义的路径必须与数据结构中定义的文件夹结构保持一致，这一点至关重要。毕竟，制作文件应该进入我们正在创建的 Shotgun 管理的文件系统。因此，我们将要修改所有资产相关模板，以匹配我们在数据结构中定义的新文件夹结构。然后，我们将修改 Maya 中资产步骤上工作文件的模板，使其在文件名中也包含集。在默认配置中，相关模板是 maya_asset_work，我们将从此处开始。在 Maya 中对基于资产的 Workfiles 使用名为 maya_asset_work 的模板是默认配置的约定。要确认这是否是正确的模板，请检查 asset_step 环境的 tk-maya 插件中 tk-multi-workfiles2 的 template_work 设置值（此处为 Github 中）。步骤 15：打开 templates.yml 并搜索 maya_asset_work。   maya_asset_work:        definition: '@asset_root/work/maya/{name}.v{version}.{maya_extension}'maya_asset_work 的 definition 值以 @asset_root 开头。@ 符号表示 @asset_root 的值在其他位置定义。与在环境配置文件中不同，先导 @ 符号在 templates.yml 中不表示包含。由于每个集成、应用和环境可能使用不同设置，您可以想象路径的第一部分可能用于 templates.yml 内的多个不同位置。对配置进行设置，使其可以使用单个变量来存储常用根路径，然后在模板中引用该变量。当您可以引用公共根时，不必更改路径生成设置的每个实例。默认配置有三个常用根变量：@shot_root、@sequence_root 和 @asset_root。我们将修改 @asset_root，这一单个更改将影响与资产相关的每个模板。编辑模板使其匹配 Shotgun 管理的文件系统数据结构中的路径步骤 16：在 templates.yml 的 paths 部分顶部搜索 asset_root。在默认配置中，它类似如下：asset_root: assets/{sg_asset_type}/{Asset}/{Step}将 CustomEntity01 添加到 asset_root 路径中以匹配数据结构修改：asset_root: assets/{CustomEntity01}/{sg_asset_type}/{Asset}/{Step}将集添加到文件名中我们已更改文件的文件夹结构，以反映我们的数据结构更改，现在文件将读取和写入到合适的位置。现在，我们来修改 Maya 资产工作文件模板的文件名，使其也包括集。再次查找 maya_asset_work 模板定义。在当前状态下，文件名为{name}.v{version}.{maya_extension}{name} 模板键是表示 Workfiles 应用的“File Save”动作中的用户输入的特殊键。我们来修改模板，使其不包含任何用户输入，而是仅包含当前集和资产。步骤 17：修改 maya_asset_work 模板定义，使其类似如下：    maya_asset_work:        definition: '@asset_root/work/maya/{CustomEntity01}_{Asset}.v{version}.{maya_extension}'此动作允许您在文件名中使用 Dining-Room 实体的专有名称。结果将类似于 Dining-Room_Filet.v1.mb。现在，您已经修改 templates.yml 以反映制作文件夹结构中的新集文件夹，并且在 Maya 中资产任务的工作文件中包含集名称。让我们来检验所做的更改。测试步骤 18：从 ShotGrid Desktop 启动 Maya。在 Maya 中，转到“ShotGrid &amp;gt; File Open”，然后在出现的对话框中，选择您已在 ShotGrid 中为其指定集的资产的任务。选择“+New File”您可以创建简单的三维对象，也可以使用“ShotGrid &amp;gt; File Save”保存文件。成功！请注意，“File Save”对话框使用模板中的新设置显示“Preview: Dining-Room_scene.v001.ma”。“工作区”(Work Area)显示 …/ShotGrid/projects/the_other_side/assets/Dining-Room/Prop/Filet/model/work/maya 作为 Workfiles 保存文件的位置的路径。高级主题扩展示例在此示例中，我们修改了一个模板，但对于文件系统配置还有更多工作可以做。在真实的示例中，您可能会更改所有与资产相关的文件，使其采用相同的文件命名约定。您可以根据其他实体（季、剧集、关卡等）进行修改、创建用户文件夹、根据使用正则表达式操纵的 ShotGrid 数据对文件夹命名，等等。您可以在文件系统配置参考中了解有关所有 Toolkit 文件夹和数据结构选项的信息。缓存路径在创建文件夹时，将在磁盘上的文件夹与 ShotGrid 实体之间创建映射。这些映射将存储为 ShotGrid 中的 FilesystemLocation 实体，并缓存在用户计算机上的 SQLite 数据库中。要详细了解缓存路径的工作方式及其使用方式，请参见此文档。其他资源  文件系统配置参考  Toolkit 配置简介网络讲座视频",
    "url": "/56b441c6/",
    "relUrl": "/56b441c6/"
  },
  "41": {
    "id": "41",
    "title": "编辑配置",
    "content": "编辑工作流配置完成本手册后，您将掌握以下基础知识：  查找特定 Toolkit 应用的配置设置  编辑设置  探索配置设置可以扩展的其他功能。关于本手册本手册介绍如何编辑现有工作流配置中的设置，以满足项目工作流的需求。第一个手册配置快速入门介绍了如何准备工作流配置以进行编辑。如果您不熟悉如何为项目创建可编辑的配置，请先完成配置快速入门，然后再继续。通过扩展默认配置，ShotGrid Toolkit 允许自定义工作流中的任务。在一个或多个软件包内的 Toolkit 应用中启用或禁用按钮就是简单的自定义示例，它可以更改用户与 Toolkit 功能进行交互的方式。Toolkit 允许使用专用配置，通过创建自定义工作流、自动执行重复和单调的任务、修改挂钩甚至添加基于 Toolkit 平台的自定义工具，让您可以更智能和更快速地工作。遗憾的是，它只能通过 ShotGrid 软件集成进行访问，还不能用于像洗衣服这样的日常任务。本手册中的练习将向您讲解如何查找哪些配置设置控制应用软件中 ShotGrid 应用的动作，设置所在的位置以及如何对其进行编辑。举个具体的例子，我们可以通过编辑“Workfiles”应用下的设置，禁止艺术家用 Maya 的“+New Task”按钮创建新任务。使用本文档要使用本手册并对工作流配置执行编辑，需要以下内容：  活动的 ShotGrid 站点。  包含至少一个资产的项目。您可以将资产添加到在第一个手册中创建的 the_other_side 项目。您可以在配置快速入门手册中查看如何为项目创建资产。  用于已标识项目的工作流配置，或完成配置快速入门手册，并使用在该练习中创建的配置。  为存储工作流配置的 Shotgun 管理的文件系统设置适当的读取和写入权限。  在系统上安装 ShotGrid Desktop。  Maya 的有效固定期限的使用许可。在此处获取 Maya 的 30 天试用版                    注意: 本手册基于 tk-config-default2 工作流配置。如果您的配置文件已修改，则文件和文件夹的位置、YAML 设置的区块可能就与此处描述的不同。    关于工作文件应用Workfiles 应用监管 ShotGrid 软件集成中的文件管理，并控制对浏览、打开和保存工作文件功能的访问。“+New Task”按钮是 Workfiles 应用的一个动作，允许用户添加任务，而无需转到 ShotGrid 执行此操作。配置分解为每个环境的文件。这样，您可以管理相对于工作流中不同阶段的功能，从而控制用户何时可以创建、命名和保存文件、执行任务或执行某些功能。这与工作文件应用中的所有功能相关，也适用于修改任何应用或插件的设置。有关更多详细信息，请参见本文档末尾的高级主题。熟悉配置文件使用 ShotGrid 中的“工作流配置列表”(Pipeline Configuration List)查找为您正在处理的项目存储工作流配置的位置。如果您知道其存储位置，可以跳到步骤 5。查找工作流配置步骤 1：打开管理您将用于此练习的项目的 ShotGrid 站点。步骤 2：通过从“项目”(Projects)页面中选择项目，从 ShotGrid 站点访问该项目。步骤 3：选择右上角的头像以显示“管理”(ADMIN)菜单，并向下滚动以选择“默认布局 &amp;gt; 工作流配置 &amp;gt; 工作流配置列表”(Default Layouts &amp;gt; Pipeline Configuration &amp;gt; Pipeline Configuration List)。步骤 4：显示“工作流配置列表”(Pipeline Configuration List)后，选择列标题最右侧的 + 号以添加另一列。在下拉列表中，为您的操作系统选择适当的路径。路径将显示在新字段中。步骤 5：在终端或文件管理器中，浏览到存储项目工作流配置的文件夹，并打开该文件夹。Toolkit 配置根文件夹中有三个子文件夹：cache、config 和 install。打开 config 文件夹，在其中您会发现几个子文件夹和一些文件。env 文件夹存储支持艺术家的工作环境的集成设置。环境文件允许工作流中的不同阶段具有自定义配置。默认配置带有一组预定义的环境文件，但如果工作流需要一组更精细的环境文件，则可以对这些环境文件进行修改。步骤 6：打开 env 文件夹。Toolkit 使用 YAML 文件来配置功能。之所以选择 YAML 作为配置的语言，是因为它允许 Toolkit 中的文件以易于读取和自定义的轻量级方式设置格式。您可以在此处 了解有关 YAML 的更多信息。配置由嵌套的 YAML 文件组成，这些文件提供标识符插件、应用和框架。它是一个路线图，指导您对一组特定的代码包进行编辑，以便控制您需要自定义的动作。编辑配置文件ShotGrid Toolkit 允许对集成在各种软件包中的应用进行更改。工作文件应用的一个功能是“+New Task”按钮，该按钮允许用户在“File Open”对话框中添加新任务。默认情况下，在项目的每个阶段为每个用户启用此功能。但是工作室可能希望限制此功能，例如，如果他们拥有特定的命名约定，或者想要将任务创建限制到项目的生产管理团队。在这种情况下，他们会为艺术家在 Maya 中工作时使用的工作流中的所有点禁用“+New Task”按钮。为 Maya 中的项目禁用“+New Task”按钮步骤 7：打开 ShotGrid Desktop。步骤 8：选择您要编辑其配置的项目。步骤 9：从 ShotGrid Desktop 启动 Maya。等待 ShotGrid 菜单完全加载。如果您的 Internet 连接速度较慢，可以利用运行配置的时间来享用表面带有适量棕红色泡沫的浓缩咖啡。一旦完全加载 Maya 和 ShotGrid，就会自动打开“File Open”对话框。当从 ShotGrid Desktop 启动 Maya 时，您将在项目环境中进入 Maya；Toolkit 工作流的配置将由 config/env/project.yml 文件驱动。默认配置中标识的环境包括 project、sequence、shot、shot_step、asset、asset_step。步骤 10：在“File Open”对话框的左窗格中选择“资产”(Assets)选项卡。在搜索结果中显示的文件夹内选择任何资产。此时将启用“+New Task”按钮。查找控制“+New Task”按钮的设置Toolkit 工作流配置用于自定义环境以满足您的工作流需求。工作流配置可以覆盖默认 ShotGrid 集成设置，根据需要或多或少会有所不同，以满足项目工作流的需求。这种结构允许采用轻量级配置，从而仅添加与 ShotGrid 核心代码中的默认值不同的设置。在本练习中，我们希望关闭工作文件应用的“+New Task”按钮，但在这样做之前，我们需要确定哪个配置设置控制它。步骤 11：选择“File Open”窗口右上角“Project (项目名称)”旁边的 &amp;gt;。此参考框显示有关控制“File Open”窗口功能的配置设置的详细信息。Toolkit 中的某些应用具有参考框，以显示该应用使用的设置以及默认设置。请注意，“Location:”标识符是 tk-multi-workfiles2。这是创建 Workfiles 应用的代码包的标识符。在搜索工作流配置时，此名称将标识应用的设置所在位置。有一个“应用和插件”页面，其中列出了 ShotGrid 集成中可用的工作流的所有配置设置、应用和插件。在“Configuration”标题下查看以查找此特定环境的设置。                    注意: 在设置 my_tasks_filters 之后是设置 launch_at_startup。这一点很重要，因为它是项目环境中“File Open”设置的默认设置。这告诉您，当从 ShotGrid Desktop 启动 Maya 时，会自动打开“File Open”对话框。    向下滚动到 Setting allow_task_creation。此设置的默认值为 True，使用户能够在处于 Maya 项目环境中时创建新任务。当搜索设置时，要考虑以下几点：  您正在运行的软件应用程序。  您正在处理的文件以及使用的工作环境。可以在应用的参考框中找到这些信息。  特定设置的名称。可以在应用的参考框或“应用和插件”页面上找到这些信息。  要扩展的 YAML 文件。YAML 文件中详细说明了标识符和路线图，以将您指引到设置所在的位置。  YAML 文件中要扩展的特定块。这在路线图中进行标识。  YAML 文件中使用的标识符和符号。  最重要的是，当前项目的配置存储位置。可以在工作流配置内的多个位置使用一个设置。决定在哪个位置使用该设置的因素是：您希望影响的软件集成，以及您希望在工作流中的哪个阶段影响更改。查找设置 allow_task_creation 的值的位置步骤 12：显示 Maya 主窗口。步骤 13：在 Maya 窗口的右上角找到“ShotGrid”菜单项。提示：如果此菜单不可见，则会显示 » 以表明某些菜单项处于隐藏状态。选择 » 以显示“ShotGrid”菜单，或者您可以加宽 Maya 窗口。步骤 14：在菜单右上角选择“ShotGrid &amp;gt; 项目 the_other_side &amp;gt; 工作区信息…”(ShotGrid &amp;gt; Project the_other_side &amp;gt; Work Area Info…)。“Work Area Info”对话框显示后台内容，以及有关当前工作区的详细信息。这包括您当前的工作环境，以及指向设置所在的环境配置文件的路径。步骤 15：在“Your Current Work Area”对话框中，选择底部的“环境”(Environment)选项卡。第一项标识正在使用的插件。插件推动了将 ShotGrid 工具集成在特定软件应用程序中的能力。它包含特定于每个软件集成的逻辑。窗口中显示的第二项显示当前项目环境所在的路径。最后两个文件夹是 config/env/ 后跟 project.yml。project.yml 文件是路线图的开头，它将您指引到当前环境的设置所在的位置。步骤 16：通过您喜欢的文本编辑器打开 project.yml。description: Apps and Engines when launching with a project only context.################################################################################includes:- ./includes/frameworks.yml- ./includes/settings/tk-3dsmaxplus.yml- ./includes/settings/tk-desktop.yml- ./includes/settings/tk-flame.yml- ./includes/settings/tk-houdini.yml- ./includes/settings/tk-mari.yml- ./includes/settings/tk-maya.yml- ./includes/settings/tk-motionbuilder.yml- ./includes/settings/tk-nuke.yml- ./includes/settings/tk-photoshopcc.yml- ./includes/settings/tk-shell.yml- ./includes/settings/tk-shotgun.yml################################################################################# configuration for all engines to load in a project contextengines:  tk-3dsmaxplus: &quot;@settings.tk-3dsmaxplus.project&quot;  tk-desktop: &quot;@settings.tk-desktop.project&quot;  tk-flame: &quot;@settings.tk-flame.project&quot;  tk-hiero: &quot;@settings.tk-nuke.hiero.project&quot;  tk-houdini: &quot;@settings.tk-houdini.project&quot;  tk-mari: &quot;@settings.tk-mari.project&quot;  tk-maya: &quot;@settings.tk-maya.project&quot;  tk-motionbuilder: &quot;@settings.tk-motionbuilder.project&quot;  tk-nuke: &quot;@settings.tk-nuke.project&quot;  tk-nukestudio: &quot;@settings.tk-nuke.nukestudio.project&quot;  tk-photoshopcc: &quot;@settings.tk-photoshopcc.project&quot;  tk-shell: &quot;@settings.tk-shell.project&quot;  tk-shotgun: &quot;@settings.tk-shotgun.project&quot;################################################################################# reference all of the common frameworksframeworks: &quot;@frameworks&quot;在 project.yml 中，description 下面有三个部分：includes、engines 和 frameworks。includes 部分是引用配置中其他 YAML 文件的文件指针的列表。默认配置的架构利用嵌套文件，并使用指针作为保持文件轻量级的另一种方法。在 includes 之后，您将逐个浏览文件，直到找到要查找的配置设置。这有点儿像俄罗斯套娃：您打开一个娃娃，里面嵌套着另一个娃娃，直到您找到合适的配置设置。每个插件标识为 tk-&amp;lt;name of software application&amp;gt;。您知道您想要影响 Maya 中的设置，因此我们要查找的标识符是 tk-maya。在 project.yml 文件的 includes: 部分下查看，并找到 ./includes/settings/tk-maya.yml 这一行。这一行表示，控制 Maya 插件 tk-maya 的设置的配置嵌套在 settings 文件夹内的 includes 文件夹中。在 engines: 部分中，找到 tk-maya 值。tk-maya: &quot;@settings.tk-maya.project&quot;@ 表明值源自一个包含文件。settings 和 project 引用表明它是项目的设置。它们是默认配置中的命名约定，有助于为您提供指导。这一整行告诉我们在包含文件中查找 settings.tk-maya.project 块，以找到 Maya 插件 tk-maya 的配置设置。ShotGrid Toolkit 会在 YAML 文件中使用简单的术语，来指示设置的名称以及引导您找到它们的路径。通过在 Maya“File Open”参考框中查看，我们已经知道，控制“+New Task”按钮执行方式的代码包是由 tk-multi-workfiles2 标识的。在 YAML 文件中使用这些标识符引用 Toolkit 包。“tk-multi-workfiles2”是 Workfiles 应用代码包的标识符，“+New Task”按钮是 Workfiles 应用的一个功能。在 tk-maya.yml 中查找 Workfiles 应用设置步骤 17：在文件浏览器中，浏览到 env/includes/settings 文件夹并打开 tk-maya.yml。步骤 18：在 project.yml 中的 include 之后，在 tk-maya.yml 文件中搜索 settings.tk-maya.project。您明确希望在特定项目的项目环境中禁用“+New Task”按钮。您处于该项目的配置中，并在项目环境中时获得了位置信息。# projectsettings.tk-maya.project:  apps:    tk-multi-about:      location: &quot;@apps.tk-multi-about.location&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-multi-shotgunpanel: &quot;@settings.tk-multi-shotgunpanel&quot;    tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;  menu_favourites:  - {app_instance: tk-multi-workfiles2, name: File Open...}  location: &quot;@engines.tk-maya.location&quot;在 settings.tk-maya.projects 下，tk-multi-workfiles2 应用设置列为tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;@ 符号告诉我们，tk-multi-workfiles2 的值来自一个包含文件。在 includes 部分 tk-maya.yml 的顶部，我们看到以下内容：includes:...- ./tk-multi-workfiles2.yml我们应该在 tk-multi-workfiles2.yml 文件（位于与当前文件 config/env/includes/settings 的同一目录下）中查找 settings.tk-multi-workfiles2.launch_at_startup。步骤 19：打开 tk-multi-workfiles2.yml 文件并搜索 settings.tk-multi-workfiles2.launch_at_startup。# launches at startup.settings.tk-multi-workfiles2.launch_at_startup:  launch_at_startup: true  entities:Maya 参考框指示 allow_task_creation 设置的默认值为 true。最佳实践是，工作流配置中不反映默认设置。这允许使用稀疏格式，从而仅将与默认代码不同的设置添加到配置中。如果未明确提供设置，则访问该设置的任何调用都将收到默认值。当 Toolkit 读取配置并构建环境时，在该环境中运行的应用、插件和框架将使用该项目的工作流配置设置，并根据配置中的内容覆盖任何默认设置。步骤 20：在 tk-multi-workfiles2.yml 中，在 settings.tk-multi-workfiles2.launch_at_startup: 下添加 allow_task_creation 并将值设置为 false# launches at startup.settings.tk-multi-workfiles2.launch_at_startup:  allow_task_creation: false  launch_at_startup: true  entities:注意：Toolkit 默认配置设置按字母顺序排列，是查找特定设置的简单方法。如果保持这种约定，由于配置变得更重量级，因此让您的工作轻松很多。步骤 21：保存文件。重新加载配置步骤 22：在 Maya 的“File Open”对话框中，打开参考框，然后选择“Reload Engines and Apps”。这将重新加载配置设置。查看您所做的更改步骤 23：导航到“File Open”对话框，然后选择资产。请注意，“+New Task”按钮不可见。您已修改 Workfiles 应用的配置设置，更改了项目环境中按钮的行为。由于您只在项目环境中修改了该设置，因此，如果您开始在其他环境中工作，则“+New Task”按钮的设置仍将处于活动状态。在实际制作示例中，我们可能会对所有环境进行在此处所做的更改。更改环境步骤 24：在资产搜索结果下，打开一个文件夹并选择要处理的资产。步骤 25：选择“+New File”通过选择“+New File”，您开始处理新资产，并在 Maya 中加载 asset_step 环境。当美工人员选择资产任务并创建新文件或打开现有文件时，将会自动加载 asset_step 环境，从而显示为工作流中的该阶段配置的工具和功能。了解您的工作环境步骤 26：在 Maya 菜单的右上角，选择“ShotGrid”。“Art, Asset Text Overlay”告知您正在处理资产以及您所在的环境。步骤 27：选择“Art, Asset Text Overlay &amp;gt; Work Area Info…”以显示当前工作区中的参数。步骤 28：选择底部的“环境”(Environment)选项卡。每个环境都会显示确定设置在工作流配置中所在位置所需的信息。要禁止美工人员添加新任务，必须为美工人员的每个工作环境禁用“+New Task”按钮。对于每个环境，请使用上面概述的相同步骤来适当地编辑配置。注意：每个环境都是独立的，一个项目具有专用的配置，加载项目时软件集成仅从工作流配置中读取其特定软件的设置。您现在已经编辑了工作流配置，对应用的设置进行了更改。现在，真正有趣的事情开始了：学习使用 ShotGrid Toolkit 环境可以执行的所有任务。下面是一些要探索的高级主题。高级主题在本手册中，我们在单个插件 tk-maya 和单个环境 project 中对应用的配置设置进行了简单的更改。您了解到，Toolkit 按环境进行组织，每个环境对于每个软件执行都是唯一的，项目和任务专注于环境，允许您在工作流的已定义点为艺术家提供特定功能。您可以概括我们的简单更改，以便对 Toolkit 工作流配置进行丰富的自定义。其他插件Workfiles 应用的应用插件名称是 tk-multi-workfiles2，名称中的 multi 表明它是一个多应用。多应用与软件无关，即，无论您是在 Maya、Nuke、Houdini 还是其他任何受支持的应用中运行它们，它们的特性和功能都是相同的。如果要在所有软件包中禁用 Workfiles 中的任务创建，则应按照本手册中针对每个插件（tk-nuke、tk-houdini 等）的步骤进行操作。其他环境我们在项目环境中禁用了任务创建，但在实际的工作室环境中，您可能希望在艺术家的所有工作环境中禁用它。要执行此操作，您应该按照本手册中的步骤进行操作，但不是从 project.yml 开始，而是从 asset_step.yml、shot_step.yml 等开始。创建自定义环境默认配置附带了一组预定义的工作流工序：project、sequence、shot、shot_step、asset 和 asset_step。但是，工作室可能需要为工作流的每个阶段（即 asset_step_rig、asset_step_model、shot_step_anim、shot_step_light 等）使用不同的配置设置。Toolkit 支持自定义环境。有关详细信息，请参见“环境配置参考”的“自定义环境”部分。视频资源  Toolkit 配置简介（来源：SIGGRAPH 2018 Developer Day）  揭秘默认配置网络讲座现在您已了解如何修改应用配置设置，请尝试将应用添加到 Toolkit 配置。",
    "url": "/37f575b8/",
    "relUrl": "/37f575b8/"
  },
  "42": {
    "id": "42",
    "title": "尝试在未完成加密握手的情况下进行通信",
    "content": "[ERROR] 尝试在未完成加密握手的情况下进行通信用例：无法启动和运行 ShotGrid Desktop 的浏览器集成。启动 Shotgun Desktop 会指示 Web 服务器正在运行：[    INFO] WebSocketServerFactory (TLS) starting on 9000[    INFO] Starting factory…后跟大量没有显示任何错误的调试记录。登录 ShotGrid 站点时，会出现：[ INFO] Connection accepted.在项目上单击鼠标右键会指示 ShotGrid 正在检索动作，并提供以下日志输出：[    INFO] Connection accepted.[   ERROR] Attempted to communicate without completing encryption handshake.[   ERROR] Attempted to communicate without completing encryption handshake.[    INFO] Connection closed.[   DEBUG] Reason received for connection loss: [Failure instance: Traceback (failure with no frames): : Connection to the other side was lost in a non-clean fashion: Connection lost.在 ShotGrid 中打开项目会生成以下日志输出：[    INFO] Connection accepted.[   ERROR] Attempted to communicate without completing encryption handshake.[   ERROR] Attempted to communicate without completing encryption handshake.[   ERROR] Attempted to communicate without completing encryption handshake.[   ERROR] Attempted to communicate without completing encryption handshake.[ WARNING] dropping connection to peer tcp4:127.0.0.1:52451 with abort=True: WebSocket closing handshake timeout (peer did not finish the opening handshake in time)[    INFO] Connection closed.[   DEBUG] Reason received for connection loss: [Failure instance: Traceback (failure with no frames): : Connection to the other side was lost in a non-clean fashion: Connection lost.如何修复：将 shotgunlocalhost.com 添加到代理绕过列表。导致此错误的原因示例：代理配置。在社区中查看完整主题。",
    "url": "/2fa5964e/",
    "relUrl": "/2fa5964e/"
  },
  "43": {
    "id": "43",
    "title": "VPC Endpoints",
    "content": "VPC EndpointsComing soon.",
    "url": "/8a9c5baf/",
    "relUrl": "/8a9c5baf/"
  },
  "44": {
    "id": "44",
    "title": "环境配置参考",
    "content": "环境配置参考简介Toolkit 工作流的核心是环境配置。在 Toolkit 工作流配置中，环境配置文件用于定义在不同的 DCC 中哪些 Toolkit 应用可用，以及为每个应用自定义相应设置。本文档提供了有关环境配置文件的结构和功能的完整参考，并涵盖了用于在一个项目中配置不同工作流的 Toolkit 环境**概念、配置结构、文件引用以及可用自定义项确定方式。                    注意: 本文档提供了有关环境配置文件的参考，而有关“编辑工作流配置”的 Toolkit 基础知识手册提供了有关编辑配置设置的分步示例。    什么是环境？ShotGrid Toolkit 平台为常用内容创建软件提供了一组完全可自定义的集成，您可以通过其构建工作室工作流。在项目的配置中，您可以指定哪些软件包具有集成，在每个软件包中哪些特定 Toolkit 应用可用，以及针对每个应用所做的选择 - 构建符合工作室需求的美工人员工作流。但在工作室工作流中，通常情况下，不同类型的美工人员一般会采用不同的工作流。举一个简单的示例，对于处理资产的美工人员，您可能希望提供纹理绘制软件（如 Mari），而对于处理镜头的美工人员，您可能希望提供合成软件（如 Nuke）。除了软件包之外，对于不同的美工人员，同一 Toolkit 应用也可能需要使用不同的设置。例如，镜头美工人员和资产美工人员都可能使用 Workfiles 应用，但您可能希望对文件导航进行限制：对于前者，只能导航到与镜头实体关联的文件；对于后者，只能导航到与资产实体关联的文件。为了在一个项目中支持不同的工作流，Toolkit 跨环境分隔其应用和插件配置。一个环境中包含一组软件包的集成及其设置，所有这些都共用一个特定上下文。在上述示例中，处理资产的美工人员将在资产工序环境中工作，而处理镜头的美工人员将在镜头工序环境中工作。每个环境的配置操作都独立于任何其他环境，从而可以在一个项目中支持不同的工作流。Toolkit 的默认配置注意事项使用 Toolkit 时，您可以相当自由地构建环境配置。本文档提供了您可用的所有选项的参考，以便您掌握必要的知识来选择更适合特定工作流需求的选项。本文档也穿插提供了一些我们在作为起点提供的工作流配置（称为默认配置）中所做的特定选择。如果您已准备好自定义工作流，第一步是为您的项目创建一个可编辑的工作流配置。虽然这些选择只是惯例，并没有硬编码到 Toolkit 工作流中，但将默认配置作为示例进行参考很有用，可以了解在自定义工作流时可用的功能，并了解在构建自己的配置时可以应用的最佳实践。此外，由于这是面向 Toolkit 新用户的建议起点，因此有助于了解其中一些惯例。本文档中自始至终区分介绍 Toolkit 环境配置的常规功能和默认配置中的特定选择。有关默认配置的环境结构的特定详细信息，请参见其自述文件。文件位置在工作流配置中，config/ 目录包含要自定义的所有文件和文件夹。在 config/ 中，包含三个子目录：cache、core 和 env。env 目录包含环境配置文件，因此本文档将涉及 config/env 中的文件。在默认配置中，config/env/ 中包含以下文件：asset.ymlasset_step.ymlproject.ymlsequence.ymlshot.ymlshot_step.yml其中每个文件都对应于一个环境；通过采用单独的文件，可以单独配置每个环境。Toolkit 确定当前环境的方式Toolkit 使用称为 pick_environment 的核心挂钩来根据当前上下文确定要在给定时间使用的环境文件。pick_environment 挂钩的返回值对应于环境配置文件。例如，如果 pick_environment 返回 shot_step，则 Toolkit 将使用 config/env/shot_step.yml 配置 Toolkit 环境。自定义环境上面列出的环境配置文件是默认配置附带的文件。但是，一些工作室可能需要使用其他环境或额外的环境。例如，工作室可能需要为工作流的每个阶段（asset_step_rig、asset_step_model、shot_step_anim、shot_step_light 等）使用不同的配置设置。幸运的是，您可以完全自定义可用环境。为此，请将所需的环境配置文件添加到 config/env 目录中。然后，覆盖 pick_environment 核心挂钩，将定义何时使用新环境的逻辑添加到其中。基本结构Toolkit 的配置文件采用 YAML 编写。任何包（应用、插件或框架）的常规配置结构如下：bundle_name:  setting1: value  setting2: value  complex_setting:    sub_setting1: value      Sub_setting2: value  location:    type: descriptor_type    descriptor_setting1: value    descriptor_setting2: value为了说明此结构，此处提供一个非常简单的示例：在一个环境中有一个插件，此插件中定义一个应用。在此配置中 project.yml 的内容可能如下所示：engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4插件块每个环境配置文件都以 engines 块开头。其中嵌套了为相应环境定义的所有插件。在我们的示例中，只定义了一个插件：tk-maya。它有两个列出的设置：apps 和 location。location 是每个包都需要的特殊设置。apps 设置是为插件定义的所有应用列表，每个应用都有自己的设置。在此示例中，只为插件定义了一个应用：tk-multi-workfiles2。位置描述符每个 Toolkit 包都有一个 location 设置，我们将其称为包的描述符**。描述符告知 Toolkit 在何处查找给定包，以及根据其类型，是直接访问它还是在本地缓存它。Toolkit 包可以来自多个位置，例如，ShotGrid App Store、git 库、磁盘上的路径或上传到 ShotGrid 站点的 zip 文件。其中每个位置都有一个对应的描述符类型，相应类型具有特定设置。下面是上述示例中 tk-maya 插件的描述符：    location:        type: app_store        name: tk-maya        version: v0.9.4这是类型为 app_store 的描 符，此描述符告知 Toolkit 从 ShotGrid App Store 获取给定包。类型为 app_store 的描述符具有设置 name 和 version。相反，如果您正在开发自定义包 - 即您正在为工作室中的一个特定工作流编写一个 Toolkit 应用，您可能希望直接从磁盘上的路径获取它。在此示例中，将使用类型为 dev 的描述符，它可能如下所示：    location:        type: dev        path: /path/to/appdev 描述符的设置与 app_store 描述符的设置不同。虽然它可以采用其他设置，但可以直接为其设置指向应用所在磁盘位置的 path 设置。有关所有可用描述符类型及其设置的详细信息，请参见 Toolkit 核心 API 文档的“描述符”部分。应用块应用是 Toolkit 的用户工具，每个应用都可以独立于任何其他应用运行。您可以根据工作流需求选择要使用的应用，而插件块内的 apps 设置用于定义在给定插件中哪些应用可用。下面是上述示例中的 apps 设置：engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8您可以看到我们定义了一个应用：tk-multi-workfiles2 应用。当前它只定义了一个设置：其描述符。如果您要在 project 环境的 tk-maya 插件中提供其他应用，可以在此处添加它们。现在将 Panel tk-multi-shotgunpanel 和 About 应用 tk-multi-about 添加到插件中。示例 project.yml 文件现在如下所示：engines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4现在要注意几个重要事项：  默认配置按字母顺序列出包，此示例遵循此惯例。  文件会开始变长，即使尚未添加任何配置设置也是如此。  您可以设想将在其他插件和其他环境中使用这些应用。例如，您可能将在不同的插件（如 Houdini、Nuke 或 Photoshop）和不同的环境（如 asset_step 或 shot_step）中使用所有这三个应用（Panel、About 应用以及 Workfiles 应用）。在配置中的多个位置定义常用应用设置，这意味着进行更改时，必须在多个位置进行修改。为了解决最后两个问题，Toolkit 支持 includes**。includes通过 includes，可以在配置中的一个文件中引用其他文件的一部分。通过使用 includes，可以在一个位置设置一个配置设置，但在多个环境中使用它。includes 包括两个部分：  includes 列表：YAML 词典，其键为 includes，其值为我们要从其包含的所有文件列表。  配置设置中的引用，带有 @ 符号前缀，并命名为指向要从包含的文件引用的部分的名称。为了充实上述示例，可以使用一个文件存放所有插件的位置描述符。我们将该文件放在 includes 子文件夹中，并将其命名为 engine_locations.yml。engine_locations.yml 的内容如下所示：config/env/includes/engine_locations.yml:engines.tk-maya.location:  type: app_store  name: tk-maya  version: v0.9.4engines.tk-nuke.location:  type: app_store  name: tk-nuke  version: v0.11.5...此文件可以用作所有插件位置的单个源，而且所有环境配置都可以引用它。使用此包含文件后，我们的示例现在如下所示：config/env/project.yml:includes:- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location: @engines.tk-maya.location在此处可以看到，tk-maya 插件的 location 设置的值现在是对包含的 YAML 文件中的一个键的引用。                    注意: 将所有插件位置放在 config/env/includes/engine_locations.yml 文件中（如在此示例中所做）时遵循默认配置的惯例。    可以添加另一个包含文件用于存放应用位置，实际上，默认配置就是这么做的。我们来扩展一下示例：config/env/includes/app_locations.yml:apps.tk-multi-about.location:  type: app_store  name: tk-multi-about  version: v0.2.8apps.tk-multi-shotgunpanel.location:  type: app_store  name: tk-multi-shotgunpanel  version: v1.6.3apps.tk-multi-workfiles2.location:  type: app_store  name: tk-multi-workfiles2  version: v0.11.8config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.location现在，我们从包含的 engine_locations.yml 文件中获取 tk-maya 插件的描述符，从包含的 app_locations.yml 文件获取为 tk-maya 插件定义的每个应用的描述符。                    注意: 默认配置使用一个第二层嵌套（未在此处说明）。还具有描述符以外的设置的每个应用或插件在 includes/settings 中都有一个设置文件（如 includes/settings/tk-maya.yml 和 includes/settings/tk-multi-workfiles2.yml）。插件设置文件包含应用设置文件中的应用设置，环境配置文件包含插件设置文件中的插件设置。有关默认配置结构的详细信息，请参见其自述文件。有关修改配置设置的详细介绍，请参见有关“编辑配置设置”的 Toolkit 基础知识手册。    稀疏配置每个 Toolkit 包都有一组可用的配置设置，每个设置都有默认值。Toolkit 允许使用稀疏**配置：如果未在环境配置文件（和/或其包含的文件）中明确指定配置设置，则将使用包中的默认值。在我们的示例中，除了 location 外，我们没有为应用指定任何设置。因此，在配置的当前状态中，三个应用的所有设置都将使用默认值。那么，我们如何知道哪些配置设置可用？                    注意: 虽然不要求 Toolkit 配置是稀疏配置，但默认配置是稀疏配置。    确定可用配置设置使用稀疏配置时，难以直接通过查看配置文件确定哪些配置设置可用于应用。要确定应用有哪些配置设置可用，可以采用两种方式：  应用文档：每个应用都有其自己的文档页面，每个页面都有“配置选项”部分。此部分列出相应应用的所有可用配置设置，每个设置都有说明和默认值。例如，您可以查看 Workfiles 文档页面。应用和插件页面列出了所有应用和插件的文档页面。  清单文件：每个 Toolkit 包的根目录中都包含一个名为 info.yml 的文件。我们将此文件称为包的清单文件**，此文件定义相应包的所有可用配置设置，每个设置都有说明和默认值。您可以在自己的包缓存中查找清单文件（例如工作流配置中的 install/app_store/tk-multi-workfiles2/v0.11.8/info.yml），也可以在 Github 中查找清单文件（例如，此处是 Workfiles 的清单文件）。修改配置设置要修改某个配置的默认值，只需在工作流配置中的适当环境中将其添加到相应块中，并设置其值。回到我们的示例，假设我们要配置 tk-multi-workfiles2，以便在项目环境中启动 Maya 时它会自动启动。我们可以在应用的清单文件中看到有一个 launch_at_startup 设置（用于控制是否在应用程序启动时启动 Workfiles UI），其默认值为 False。因此，我们只需添加 launch_at_startup 选项，并将其设置为 True。project.yml 文件现在如下所示：config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        launch_at_startup: True        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.location请注意，如果 tk-multi-workfiles2 的设置来自一个包含的文件，我们将在该文件中进行此更改。其他资源  Toolkit 基础知识手册：编辑工作流配置  Toolkit 基础知识手册：添加应用  动画工作流教程  描述符参考文档  网络讲座：Toolkit 管理  文件系统配置参考  默认配置环境结构自述文件",
    "url": "/487a9f2c/",
    "relUrl": "/487a9f2c/"
  },
  "45": {
    "id": "45",
    "title": "违反协议时发生 EOF",
    "content": "SSLError: [Errno 8] _ssl.c:504: 违反协议时发生 EOF用例从 Desktop 打开 Nuke 10.5 时，会出现以下 SSL 错误：[13:57.14] ERROR: Shotgun Error: [ERROR tk-nuke] App /media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2 failed to initialize. It will not be loaded.Traceback (most recent call last):File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank/platform/engine.py”, line 2792, in __load_appsapp.init_app()File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/app.py”, line 26, in init_appself._tk_multi_workfiles = self.import_module(“tk_multi_workfiles”)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank/platform/bundle.py”, line 462, in import_moduleself.__module_uid, None, python_folder, (&quot;&quot;, “”, imp.PKG_DIRECTORY)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/init.py”, line 11, infrom . import tk_multi_workfilesFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/init.py”, line 14, infrom .file_open_form import FileOpenFormFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/file_open_form.py”, line 19, infrom .actions.file_action_factory import FileActionFactoryFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/actions/file_action_factory.py”, line 19, infrom .interactive_open_action import InteractiveOpenActionFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/actions/interactive_open_action.py”, line 17, infrom .open_file_action import OpenFileActionFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/actions/open_file_action.py”, line 22, infrom …work_area import WorkAreaFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/work_area.py”, line 19, infrom .user_cache import g_user_cacheFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/user_cache.py”, line 203, ing_user_cache = UserCache()File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/user_cache.py”, line 32, in initself._current_user = sgtk.util.get_current_user(self._app.sgtk)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank/util/login.py”, line 125, in get_current_user“HumanUser”, filters=[[“login”, “is”, current_login]], fields=fieldsFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 882, in find_oneadditional_filter_presets=additional_filter_presets)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 1003, in findadditional_filter_presets)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 1072, in _construct_read_parametersparams[“paging”] = {“entities_per_page”: self.config.records_per_page,File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 471, in records_per_pageself._records_per_page = self._sg.server_info.get(“api_max_entities_per_page”) or 500File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 763, in server_inforeturn self.server_caps.server_infoFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 778, in server_capsself._server_caps = ServerCapabilities(self.config.server, self.info())File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 833, in inforeturn self._call_rpc(“info”, None, include_auth_params=False)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank/authentication/shotgun_wrapper.py”, line 63, in _call_rpcreturn super(ShotgunWrapper, self)._call_rpc(*args, **kwargs)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 3302, in _call_rpcencoded_payload, req_headers)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 3442, in _make_callreturn self._http_request(verb, path, body, req_headers)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 3496, in _http_requestresp, content = conn.request(url, method=verb, body=body, headers=headers)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 2192, in requestcachekey,File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 1845, in _requestconn, request_uri, method, body, headersFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 1750, in _conn_requestconn.connect()File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 1399, in connectself.key_password,File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 109, in _ssl_wrap_socketssl_version=ssl_version,File “/usr/local/Nuke10.5v7/lib/python2.7/ssl.py”, line 381, in wrap_socketciphers=ciphers)File “/usr/local/Nuke10.5v7/lib/python2.7/ssl.py”, line 143, in initself.do_handshake()File “/usr/local/Nuke10.5v7/lib/python2.7/ssl.py”, line 305, in do_handshakeself._sslobj.do_handshake()SSLError: [Errno 8] _ssl.c:504: EOF occurred in violation of protocolNuke 版本 11 或 12 不会发生这种情况。如何修复您之所以看到此问题，是因为 Nuke 10.x 与 TLS 1.2 不兼容。该软件需要与 TLS 兼容。相关链接在社区中查看完整主题",
    "url": "/4947c1f4/",
    "relUrl": "/4947c1f4/"
  },
  "46": {
    "id": "46",
    "title": "Nuke Studio 中的剧集工作流",
    "content": "Nuke Studio 中的剧集工作流简介和准备工作本文介绍如何在 Nuke Studio 或 Hiero 中通过我们的 tk-hiero-export 应用设置并运行您的剧集工作流。请注意，这并没有一个精准方法，根据您所需的工作流，方法会略有不同。对于本文示例，我们将做以下假设：  您的目标是设置一个三层的层次结构：Episode &amp;gt; Sequence &amp;gt; Shot  您将阅读并完成文件系统配置手册中的步骤。  您将使用 Episode 实体类型（而不是 CustomEntity02，这两者的使用方式相同，只是名称不同。）  Sequence 实体具有一个名为 episode 的实体字段。  您将使用 Nuke Studio，但过程与 Hiero 相同。  您将从 Toolkit 项目的默认配置开始。在开始之前，您还要做出一个决定，即如何解析 Episode。现有的 ShotGrid Hiero/Nuke Studio 导出流程会根据 Nuke Studio 项目内容在 ShotGrid 站点上创建 Sequence 和 Shot 实体。因此，与在 Maya 中使用 Toolkit 时的情况（要求您已创建资产和任务）不同，在 Nuke Studio 中，不要求您已创建 Episodes、Sequences 或 Shots。虽然如此，您仍需决定如何在 Nuke Studio 中定义 Episode。下面是几种可能的方式：  提前在 ShotGrid 中创建剧集，并配置 Nuke Studio Toolkit 集成以在剧集上下文中使用，以便在导出时您可以从当前场景上下文中获得 Episode 实体。  假定尚未创建 Episode 实体，并要利用 Nuke Studio 的标记功能以剧集名称标记场，以及在导出时使用相应信息来解析 Episode。可能有更适合您的工作流的其他方法，例如，从 Nuke Studio 场或镜头名称中提取剧集名称（例如，从名为 ep1_s01 的场中提取 ep1 部分）。或者，您可以使用导出应用的 hiero_customize_export_ui.py 挂钩添加 GUI，以便将导出与剧集链接。对于此示例，我们采用第二种方式：场标记解决方案。请注意，此方式用于实施三层层次结构 (Episode &amp;gt; Sequence &amp;gt; Shot)。如果直接将 Sequence 实体类型替换为 Episodes 实体类型 (Episode &amp;gt; Shot)，过程更简单。在本手册结束前，我们将简要介绍此情况，但您仍有必要阅读其余部分以便深入了解相关信息。数据结构和模板如前所述，此示例假定您已更新数据结构和模板。请确保您还在 templates.yml 中更新了 hiero_plate_path 和 hiero_render_path 路径值，以在正确的位置包含剧集项。挂钩和设置为了使 ShotGrid 导出流程正确处理 Episode，需要修改其中一些导出挂钩。本文假定您了解挂钩的含义，并知晓如何覆盖基本实施。有两个导出挂钩可帮助您启用剧集。  hiero_get_shot.py  hiero_resolve_custom_strings.py注意：另外有一个名为 hiero_translate_template.py 的挂钩。此示例中不使用该挂钩，但如果您希望将场替换为剧集并维持一个两层的层次结构，则需要使用该挂钩。在本文结尾处，我们将稍微介绍此内容。修改 hiero_get_shot.py，以便查找剧集，并在 ShotGrid 中为其创建一个实体，同时修改 hiero_resolve_custom_strings.py，以便 Nuke Studio 了解向路径中的 {Episode} 项提供何值。下面是更加详细的步骤：1. 添加剧集字段现在，模板中有一个名为 Episode 的新项，您需要告诉 tk-hiero-export 应用如何解析此项。在 &amp;lt;pipeline_configuration&amp;gt;/config/env/includes/settings/tk-hiero-export.yml 文件中修改 custom_template_fields，使其如下所示： settings.tk-hiero-export:      custom_template_fields: [{keyword: Episode, description: The episode name}]   ... 这将向 Hiero 导出器中添加一个名为 {Episode} 的有效导出令牌。2. hiero_get_shot 挂钩现在，需要使用 hiero_get_shot.py 挂钩告诉导出流程如何查找剧集名称并在 ShotGrid 中创建 Episode。挂钩的默认版本 (hiero_get_shot.py) 将从 ShotGrid 返回与 TrackItem 同名的 Shot。还必须将 Shot 链接到名称与 Nuke Studio 场项相同的 Sequence。如果 ShotGrid 中不存在 Sequence 或 Shot，该挂钩将创建它们。您将为该层次结构添加另一层，因此您需要告诉挂钩，如果 Episode 不存在，还要创建它。由于 Sequence 已链接到 Episode，您应将其关联到查找 Sequence 的代码（get_shot_parent() 方法）。在配置的 hooks 文件夹中创建 hiero_get_shot.py 文件，并将 hook_get_shot: '{config}/hiero_get_shot.py' 添加到 tk-hiero-export.yml 设置中，即如下所示： settings.tk-hiero-export:      custom_template_fields: [{keyword: Episode, description: The episode name}]      hook_get_shot: '{config}/hiero_get_shot.py' 下面是 hiero_get_shot.py 挂钩的完整代码。将此代码添加到您创建的挂钩中：from sgtk import Hookclass HieroGetShot(Hook):    &quot;&quot;&quot;    Return a  ShotGrid  Shot dictionary for the given Hiero items    &quot;&quot;&quot;    def execute(self, task, item, data, **kwargs):        &quot;&quot;&quot;        Takes a hiero.core.TrackItem as input and returns a data dictionary for        the shot to update the cut info for.        &quot;&quot;&quot;       # get the parent entity for the Shot       parent = self.get_shot_parent(item.parentSequence(), data, item=item)       # shot parent field       parent_field = &quot;sg_sequence&quot;       # grab shot from  ShotGrid        sg = self.parent.shotgun       filter = [           [&quot;project&quot;, &quot;is&quot;, self.parent.context.project],           [parent_field, &quot;is&quot;, parent],           [&quot;code&quot;, &quot;is&quot;, item.name()],        ]       # default the return fields to None to use the python-api default       fields = kwargs.get(&quot;fields&quot;, None)       shots = sg.find(&quot;Shot&quot;, filter, fields=fields)       if len(shots) &amp;gt; 1:           # can not handle multiple shots with the same name           raise StandardError(&quot;Multiple shots named '%s' found&quot;, item.name())       if len(shots) == 0:           # create shot in            shot_data = {               &quot;code&quot;: item.name(),               parent_field: parent,               &quot;project&quot;: self.parent.context.project,           }           shot = sg.create(&quot;Shot&quot;, shot_data, return_fields=fields)           self.parent.log_info(&quot;Created Shot in  ShotGrid : %s&quot; % shot_data)       else:           shot = shots[0]       # update the thumbnail for the shot       upload_thumbnail = kwargs.get(&quot;upload_thumbnail&quot;, True)       if upload_thumbnail:           self.parent.execute_hook(               &quot;hook_upload_thumbnail&quot;,               entity=shot,               source=item.source(),               item=item,               task=kwargs.get(&quot;task&quot;)           )       return shot    def get_episode(self, data=None, hiero_sequence=None):        &quot;&quot;&quot;        Return the  episode for the given Nuke Studio items.        We define this as any tag linked to the sequence that starts        with 'Ep'.        &quot;&quot;&quot;       # If we had setup Nuke Studio to work in an episode context, then we could       # grab the episode directly from the current context. However in this example we are not doing this but here       # would be the code.       # return self.parent.context.entity       # stick a lookup cache on the data object.       if &quot;epi_cache&quot; not in data:           data[&quot;epi_cache&quot;] = {}       # find episode name from the tags on the sequence       nuke_studio_episode = None       for t in hiero_sequence.tags():           if t.name().startswith('Ep'):               nuke_studio_episode = t               break       if not nuke_studio_episode:           raise StandardError(&quot;No episode has been assigned to the sequence: %s&quot; % hiero_sequence.name())       # For performance reasons, lets check if we've already added the episode to the cache and reuse it       # Its not a necessary step, but it speeds things up if we don't have to check  for the episode again       # this session.       if nuke_studio_episode.guid() in data[&quot;epi_cache&quot;]:           return data[&quot;epi_cache&quot;][nuke_studio_episode.guid()]       # episode not found in cache, grab it from  ShotGrid        sg = self.parent.shotgun       filters = [           [&quot;project&quot;, &quot;is&quot;, self.parent.context.project],           [&quot;code&quot;, &quot;is&quot;, nuke_studio_episode.name()],       ]       episodes = sg.find(&quot;Episode&quot;, filters, [&quot;code&quot;])       if len(episodes) &amp;gt; 1:           # can not handle multiple episodes with the same name           raise StandardError(&quot;Multiple episodes named '%s' found&quot; % nuke_studio_episode.name())       if len(episodes) == 0:           # no episode has previously been created with this name           # so we must create it in            epi_data = {               &quot;code&quot;: nuke_studio_episode.name(),               &quot;project&quot;: self.parent.context.project,           }           episode = sg.create(&quot;Episode&quot;, epi_data)           self.parent.log_info(&quot;Created Episode in  ShotGrid : %s&quot; % epi_data)       else:           # we found one episode matching this name in , so we will resuse it, instead of creating a new one           episode = episodes[0]       # update the cache with the results       data[&quot;epi_cache&quot;][nuke_studio_episode.guid()] = episode       return episode    def get_shot_parent(self, hiero_sequence, data, **kwargs):        &quot;&quot;&quot;        Given a Hiero sequence and data cache, return the corresponding entity        in  ShotGrid  to serve as the parent for contained Shots.        :param hiero_sequence: A Hiero sequence object        :param data: A dictionary with cached parent data.        .. note:: The data dict is typically the app's `preprocess_data` which maintains the cache across invocations of this hook.                        &quot;&quot;&quot;         # stick a lookup cache on the data object.         if &quot;parent_cache&quot; not in data:             data[&quot;parent_cache&quot;] = {}                 if hiero_sequence.guid() in data[&quot;parent_cache&quot;]:             return data[&quot;parent_cache&quot;][hiero_sequence.guid()]                 episode = self.get_episode(data, hiero_sequence)                 # parent not found in cache, grab it from  ShotGrid                  sg = self.parent.shotgun filter = [             [&quot;project&quot;, &quot;is&quot;, self.parent.context.project],             [&quot;code&quot;, &quot;is&quot;, hiero_sequence.name()],             [&quot;episode&quot;, &quot;is&quot;, episode],             ]                 # the entity type of the parent.         par_entity_type = &quot;Sequence&quot;                 parents = sg.find(par_entity_type, filter)         if len(parents) &amp;gt; 1:             # can not handle multiple parents with the same name             raise StandardError(                 &quot;Multiple %s entities named '%s' found&quot; % (par_entity_type, hiero_sequence.name())                 )                     if len(parents) == 0:             # create the parent in              par_data = {                 &quot;code&quot;: hiero_sequence.name(),                 &quot;project&quot;: self.parent.context.project,                 &quot;episode&quot;: episode,                 }                         parent = sg.create(par_entity_type, par_data)             self.parent.log_info(                 &quot;Created %s in  ShotGrid : %s&quot; % (par_entity_type, par_data)                )        else:             parent = parents[0]                         # update the thumbnail for the parent         upload_thumbnail = kwargs.get(&quot;upload_thumbnail&quot;, True)                 if upload_thumbnail:             self.parent.execute_hook(                 &quot;hook_upload_thumbnail&quot;, entity=parent, source=hiero_sequence, item=None             )                     # cache the results         data[&quot;parent_cache&quot;][hiero_sequence.guid()] = parent         return parent 获取场在上面的代码中，我们修改了 get_shot_parent() 方法。现在，在查找和创建 Sequence 时，它使用新 get_episode() 方法返回的 Episode。现在，在 ShotGrid 数据库中检查是否存在 Sequence 时，它会按 episode&amp;lt;/code&amp;lt; field 进行过滤、创建 Sequence 以及使用 get_episode() 返回的 Episode 填充场的 episode 字段。获取剧集如何获取剧集？get_episode() 方法代码与 get_shot_parent() 方法非常相似，但已修改为检索 Episode 而不是 Sequence。在本手册中，您将使用标记在 Nuke Studio 中分配剧集。例如，您可以在 Nuke Studio 中创建一个名为 Ep01 的标记。然后，在 Nuke Studio 中将该标记应用于场。get_episode() 方法在较高级别查找在 Nuke Studio 中应用于场项的所有标记，如果找到以字符串 Ep 开头的标记，则假定它就是定义剧集名称的标记。随后，该方法将从 ShotGrid 查找并返回匹配的 Episode，如果尚不存在，则会创建它。该方法还将缓存此信息，因此，无需再次执行成本高昂的查找调用。如果您希望以其他方式获取剧集（例如，从上下文中获取，或通过提取场或镜头名称的第一个部分来获取），请使用此方法中的相应逻辑。获取镜头hiero_get_shot 挂钩的主要用途是从 ShotGrid 返回镜头数据。实际上，您不需要设置用于获取镜头的逻辑，只需修改 Sequence 获取父对象的方式。如果您还希望通过一个自定义字段将 Shot 与 Episode 链接，则还需要在执行方法中修改相应代码。从 Sequence（如 parent[“episode”]）访问 Episode，然后将其链接到创建调用中的镜头。3.Hiero_resolve_custom_strings.py您需要利用的第二个挂钩是 hiero_resolve_custom_strings.py。它用于为 Nuke Studio 导出解析路径。同样，您需要在 hooks 文件夹中创建该挂钩，并将设置 hook_resolve_custom_strings: {config}/hiero_resolve_custom_strings.py 添加到您的 tk-hiero-export.yml 文件中。在步骤 1 中添加的自定义项 {Episode} 将传递给此挂钩，导出应用要求返回已解析的文件夹名称。该挂钩需要检查传递的项是否为 {Episode}，如果是，它将在 hiero_get_shot.py 挂钩中重复使用 get_episode() 方法以获取 Episode 实体。获取 Episode 后，相应代码可以提取剧集的名称以生成相应的文件夹。下面是该挂钩的完整代码：from sgtk import Hookclass HieroResolveCustomStrings(Hook):    &quot;&quot;&quot;Translates a keyword string into its resolved value for a given task.&quot;&quot;&quot;    # cache of shots that have already been pulled from     _sg_lookup_cache = {}    def execute(self, task, keyword, **kwargs):        &quot;&quot;&quot;        The default implementation of the custom resolver simply looks up        the keyword from the  shot dictionary.        For example, to pull the shot code, you would simply specify 'code'.        To pull the sequence code you would use 'sg_sequence.Sequence.code'.        &quot;&quot;&quot;        if keyword == &quot;{Episode}&quot;:            episode_entity = self.parent.execute_hook_method(                &quot;hook_get_shot&quot;,                &quot;get_episode&quot;,                data=self.parent.preprocess_data,                hiero_sequence=task._item.parentSequence(),            )            # hard coded to return the name of the episode            # if however your folder for the episode in the schema, is not just made up from the code field            # you need to get it to return what ever string value the folder would normally be created with.            return episode_entity['code']        shot_code = task._item.name()        # grab the shot from the cache, or the get_shot hook if not cached        sg_shot = self._sg_lookup_cache.get(shot_code)        if sg_shot is None:            fields = [ctf['keyword'] for ctf in self.parent.get_setting('custom_template_fields')]            sg_shot = self.parent.execute_hook(                &quot;hook_get_shot&quot;,                task=task,                item=task._item,                data=self.parent.preprocess_data,                fields=fields,                upload_thumbnail=False,            )            self._sg_lookup_cache[shot_code] = sg_shot        self.parent.log_info(&quot;_sg_lookup_cache: %s&quot; % (self._sg_lookup_cache))        if sg_shot is None:            raise RuntimeError(&quot;Could not find shot for custom resolver: %s&quot; % keyword)        # strip off the leading and trailing curly brackets        keyword = keyword[1:-1]        result = sg_shot.get(keyword, &quot;&quot;)        self.parent.log_debug(&quot;Custom resolver: %s[%s] -&amp;gt; %s&quot; % (shot_code, keyword, result))        return result 请注意，如果您的数据结构剧集文件夹名称是基于 code 字段以外的内容生成的，您需要将该名称复制到此处。更准确但更复杂的方法是在 templates.yml 中添加 episode_root 模板，然后从该模板获取字段。这意味着返回的文件夹名称始终匹配数据结构，即使在数据结构中更改了剧集文件夹名称也是如此。此方法如下所示：ctx = tk.context_from_entity(&quot;Episode&quot;, episode_entity[id])my_template = tk.templates[&quot;episode_root&quot;]fields = my_template.get_fields(ctx.filesystem_locations[0])return fields[&quot;Episode&quot;] 总结现已完成设置！接下来就是测试所做更改是否可以正常使用。在启动 Nuke Studio、创建项目并为其填充场和序列后，现在可以测试导出流程。首先，创建剧集标记。请注意，您之前将挂钩编码为在场上查找以 Ep 开头的标记，因此必须将标记命名为 Ep…现在向场添加标记。完成该操作后，从标记的场导出镜头。检查导出结构的层次结构是否匹配我们的数据结构的层次结构。如果不匹配，您可能需要刷新结构。单击“导出”(Export)后，应该会在您的 ShotGrid 站点上创建剧集、场和镜头，以及在磁盘上创建文件夹结构。如果在此过程中遇到问题，请记得检查 Nuke Studio 脚本编辑器或ShotGrid日志 (tk-nukestudio.log) 中是否存在您可能遇到的任何错误。上文就是本手册介绍的方法。当然，这只是用于处理剧集的多种方法之一，您可以自行找到最适合您的工作室的方法和结构。用场交换剧集如上文简要介绍的那样，如果您希望直接将默认的场/镜头层次结构交换为剧集/镜头层次结构，可以将 Nuke Studio 场项用作剧集名称的来源。      设置数据结构和模板以处理剧集/镜头结构。        利用默认的 hiero_get_shot.py 挂钩，如上所示。但此时将 parent_field 变量值更改为 sg_episode（确保您的镜头实体上有剧集字段），将 par_entity_type 变量值更改为 variable value toEpisode。        利用 hiero_translate_template.py 挂钩，并在挂钩文件中更改映射：   mapping = {   &quot;{Episode}&quot;: &quot;{sequence}&quot;,   &quot;{Shot}&quot;: &quot;{shot}&quot;,   &quot;{name}&quot;: &quot;{clip}&quot;,   &quot;{version}&quot;: &quot;{tk_version}&quot;,} 将使用 Nuke Studio 场项的值解析剧集项。  提示：如果您在进行这些更改之前打开了 Hiero/Nuke Studio 项目，或者您在测试的同时进行了更改，则可能需要重置导出路径。当您打开“导出”(Export)对话框时，Nuke Studio 会缓存导出树，因此，如果您希望重新加载对数据结构所做的更改，您需要按刷新按钮以重新构建导出树。",
    "url": "/459f67b7/",
    "relUrl": "/459f67b7/"
  },
  "47": {
    "id": "47",
    "title": "无法更改工作区 - 执行 MEL 脚本期间出错",
    "content": "无法更改工作区 - 执行 MEL 脚本期间出错用例当为无权访问网络的自由职业者创建新的特殊工作流配置时，我们创建了新的根名称并将其指向另一个路径。制作工作流配置将根路径指向我们的文件服务器。但是，在 Maya 上使用 tk-multi-workfiles 创建新文件时，出现以下错误：Failed to change work area - Error during execution of MEL script: file: C:/Program files/Autodesk/Maya2019/scripts/others/setProject.mel line 332: New project location C: VetorZero work Shotgun-workflow_completo sequences Seq_001 SH_010 ANIM maya is not a valid directory, project not created.Calling Procedure: setProject, in file “C: Program Files Shotgun c” set project(“C: Vetorzero work SHOTGUN-workflow_completo sequences Seq_001 SH_010 ANIM maya”)它创建了文件夹，但没有创建文件夹“maya”。如何修复检查以确保文件夹“maya”没有被错误地删除。如果存在此情况，则会出现此错误。相关链接在社区中查看完整主题",
    "url": "/4f00a298/",
    "relUrl": "/4f00a298/"
  },
  "48": {
    "id": "48",
    "title": "API",
    "content": "APIregisterCallbacks所有插件中的全局级别函数，用于告知框架有关插件中事件处理入口点的信息。registerCallbacks(reg)  reg：您将与之进行交互，以告知框架要调用哪些函数的 Registrar。RegistrarRegistrar 是用于告知框架如何与插件交互的对象。它将传递到 registerCallbacks 函数。属性logger请参见 getLogger。方法getLogger获取用于从插件中记录消息的 Python Logger 对象。setEmails(*emails)设置当此插件或其任何回调中发生错误时应接收错误和重要通知的电子邮件。将电子邮件发送到配置文件中指定的默认地址（默认）reg.setEmails(True)禁用电子邮件（不建议执行此操作，因为您不会收到错误消息）reg.setEmails(False)向特定地址发送电子邮件，使用reg.setEmails('user1@domain.com')或reg.setEmails('user1@domain.com', 'user2@domain.com')registerCallback(sgScriptName, sgScriptKey, callback, matchEvents=None, args=None, stopOnError=True)将回调注册到此插件的插件。  sgScriptName：从 ShotGrid 脚本页面获取的脚本的名称。  sgScriptKey：从 ShotGrid 脚本页面获取的脚本的应用程序密钥。  callback：具有 __call__ 方法的函数或对象。请参见 exampleCallback。  matchEvents：要传递到回调的事件的过滤器。  args：希望框架重新传递到回调的任何对象。  stopOnError：布尔值，此回调中出现异常会导致此插件中的所有回调停止处理事件。默认值为 True。sgScriptName 用于标识 ShotGrid 的插件。任何名称都可以在任意数量的回调之间共享，也可以是单个回调的唯一名称。sgScriptKey 用于标识 ShotGrid 的插件，且应该是指定 sgScriptName 的相应键。当与过滤器匹配的事件需要处理时，将调用指定的回调对象。虽然任何可调用类都应该能够运行，但不建议使用此处的类。使用具有 __call__ 方法的函数或实例更为合适。matchEvent 参数是一个过滤器，用于指定将要注册的回调感兴趣的事件。如果未指定 matchEvents 或指定“无”，则所有事件都将传递到回调。否则，matchEvents 过滤器中的每个键都是一个事件类型，而每个值是可能的属性名称的列表。matchEvents = {    'Shotgun_Task_Change': ['sg_status_list'],}可以有多个事件类型或属性名称matchEvents = {    'Shotgun_Task_Change': ['sg_status_list'],    'Shotgun_Version_Change': ['description', 'sg_status_list']}可以对具有给定属性名称的任何事件类型进行过滤matchEvents = {    '*': ['sg_status_list'],}还可以针对给定事件类型的任何属性名称进行过滤matchEvents = {    'Shotgun_Version_Change': ['*']}尽管以下内容是有效的且功能相当于不指定任何内容，但它实际上毫无用处matchEvents = {    '*': ['*']}与非特定于字段的事件类型（如“_New”或“_Retirement”）进行匹配时，不提供列表，而是将 None 作为值进行传递。matchEvents = {    'Shotgun_Version_New': None}事件框架本身不会使用 args 参数，而只是将其重新传递到回调，不进行任何修改。                    注意: 使用 args 参数，您可以在 registerCallbacks 函数中处理耗时的内容，并在处理事件时将其重新传递给您。    args 参数的另一个用途是在公用的可变参数（例如 dict）中传递给多个回调，使其共享数据。stopOnError 参数会告知系统此回调中的异常是否会导致插件中所有回调的事件处理停止。默认情况下，此参数为 True，但可以切换为 False。如果存在任何错误但事件处理不停止，您仍会收到错误通知邮件。根据回调设置，您可以具有一些关键回调，对于这些回调，此参数为 True，对于其他回调则为 False。回调Registrar.registerCallback 注册的任何插件入口点通常为如下所示的全局级别函数：exampleCallback(sg, logger, event, args)  sg：ShotGrid 连接实例。  logger：为您预先配置的 Python logging.Logger 对象。  event：要处理的 ShotGrid 事件。  args：在回调注册时指定的 args 参数。                    注意: 可以在对象实例上将回调作为 __call__ 方法实施，我们将此留给用户做练习。    ",
    "url": "/b04a53ae/",
    "relUrl": "/b04a53ae/"
  },
  "49": {
    "id": "49",
    "title": "配置",
    "content": "配置以下手册将帮助您为您的工作室配置 ShotGridEvents。ShotGridEvents 的大部分配置由 shotgunEventDaemon.conf 文件控制。在此文件中，您将发现多个可以根据自己的需求进行修改的设置。大多数设置都具有适用于大多数工作室的默认值，但是，有些设置必须进行配置（特别是 ShotGrid 服务器 URL、脚本名称和应用程序密钥，以便 ShotGridEventDaemon 可以连接到 ShotGrid 服务器）。                    注意: 对于 Windows：Windows 用户需要将配置文件中的所有路径更改为等效的 Windows 路径。为了简化起见，我们建议将所有路径（包括日志记录）保留在一个位置。在提及 Windows 路径时，本文档往往是指 C: shotgun shotgunEvents。    编辑 shotgunEventDaemon.conf安装 ShotGridEvents 后，下一步是在文本编辑器中打开 shotgunEventDaemon.conf 文件，然后修改设置以符合您工作室的需求。默认值适用于大多数工作室，但某些设置没有默认值，您需要提供值才能运行进程。您必须提供的项包括：  ShotGrid 服务器 URL  用于连接到 ShotGrid 的脚本名称和应用程序密钥  用于运行 ShotGridEventDaemon 的插件的完整路径（可选）您还可以指定 SMTP 服务器和特定于电子邮件的设置，以设置有关错误的电子邮件通知。这是可选的，但如果您选择进行此设置，则必须提供电子邮件部分中的所有配置值。还有一个可选的计时日志部分，如果进程遇到性能问题，该日志有助于进行疑难解答。启用计时日志记录将使用计时信息填充自己单独的日志文件。ShotGrid 设置在 [ShotGrid] 部分下，将默认令牌替换为 server、name 和 key 的正确值。这些值应与您为连接到 ShotGrid 的标准 API 脚本提供的值相同。示例server: https://awesome.shotgunstudio.comname: ShotGridEventDaemonkey: e37d855e4824216573472846e0cb3e49c7f6f7b1插件设置您需要告知 ShotGridEventDaemon 在何处查找要运行的插件。在 [plugins] 部分下，将默认令牌替换为 paths 的正确值。您可以指定多个位置（如果您有多个部门或库使用进程，这可能会很有用）。此处的值必须是指向可读取的现有目录的完整路径。示例paths: /usr/local/shotgun/ShotGridEvents/plugins首次启动时，一个很好的测试插件是位于 /usr/local/shotgun/ShotGridEvents/src/examplePlugins 目录中的 logArgs.py 插件。将其复制到您指定的插件文件夹，然后我们将使用它进行测试。shotgunEventDaemon.conf 的位置默认情况下，进程将在 ShotGridEventDaemon.py 所在的目录和 /etc 目录中查找 shotgunEventDaemon.conf 文件。如果需要将 conf 文件放置在其他目录中，建议您从当前目录创建它的符号链接。                    注意: 如果出于某种原因，上述内容对您不适用，配置文件的搜索路径将位于 shotgunEventDaemon.py 脚本底部的 _getConfigPath() 函数中                        注意: 对于 Windows：/etc 在 Windows 上不存在，因此配置文件应放在与 Python 文件相同的目录中。    测试进程进程可能很难测试，因为它们在后台运行。并非始终有明显的方法来查看它们正在执行的操作。幸运的是，对于我们而言，ShotGridEventDaemon 有一个选项可以将其作为前台进程运行。现在我们已完成最低要求的设置，接下来我们来测试进程并查看具体情况。                    注意: 此处使用的默认值可能需要根访问权限（例如，写入到 /var/log 目录）。所提供的示例使用 sudo 来适应这一情况。    $ sudo ./ShotGridEventDaemon.py foregroundINFO:engine:Using ShotGrid version 3.0.8INFO:engine:Loading plugin at /usr/local/shotgun/ShotGridEvents/src/examplePlugins/logArgs.pyINFO:engine:Last event id (248429) from the ShotGrid database.您应该会在启动脚本时看到上面的行（一些详细信息可能明显不同）。如果您收到任何错误，脚本将终止，因为我们选择在前台运行它，可以看到该情况发生。下面显示了遇到困难时的一些常见错误。logArgs.py 插件仅提取 ShotGrid 中发生的事件并将其传递到日志记录程序。这并不是一件令人兴奋的事，但它是确保脚本正常运行且插件正常工作的简单方法。如果您所在的工作室很忙碌，您可能已经注意到消息流的快速流动。如果没有，请在 Web 浏览器中登录到 ShotGrid 服务器并更改某些值或创建内容。您应该看到已输出到终端窗口的日志语句，对应于您使用更改生成的事件类型。                    注意: logArgs.py 文件中包含需要用适当值填充的变量。必须对“$DEMO_SCRIPT_NAMES$”和“$DEMO_API_KEY$”进行编辑，以包含在 shotgunEventDaemon.conf 文件中使用的相同值，以便日志记录能够正常运行。    如果没有任何内容记录到日志文件中，请在 ShotGridEventDaemon.conf 中检查与日志相关的设置，确保将 logging 值设置为记录 INFO 级别的消息，logging: 20logArgs 插件也配置为显示 INFO 级别的消息。在 registerCallbacks() 方法的末尾应该有如下一行reg.logger.setLevel(logging.INFO)假设所有内容看起来都正常，要停止 ShotGridEventDaemon 进程，只需在终端中键入 &amp;lt;ctrl&amp;gt;-c，您应该会看到脚本终止。运行进程假设测试进展顺利，我们现在可以在后台按预期运行进程。$ sudo ./ShotGridEventDaemon.py start您应该看不到任何输出，并且控制应该已经在终端中返还给您。我们可以通过两种方式确保运行正常。第一种是检查正在运行的进程，并查看这是否是其中一个进程。$ ps -aux | grep shotgunEventDaemonkp              4029   0.0  0.0  2435492    192 s001  R+    9:37AM   0:00.00 grep shotgunEventDaemonroot            4020   0.0  0.1  2443824   4876   ??  S     9:36AM   0:00.02 /usr/bin/python ./ShotGridEventDaemon.py start通过返回的第二行可以看到进程正在运行。第一行与我们刚刚运行的命令匹配。我们知道它正在运行，但要确保它正常工作并且插件正在执行预期操作，我们可以在日志文件中查看是否存在任何输出。$ sudo tail -f /var/log/shotgunEventDaemon/shotgunEventDaemon2011-09-09 09:42:44,003 - engine - INFO - Using ShotGrid version 3.0.82011-09-09 09:42:44,006 - engine - INFO - Loading plugin at /usr/local/shotgun/ShotGrid/src/plugins/logArgs.py2011-09-09 09:42:44,199 - engine - DEBUG - Starting the event processing loop.返回到 Web 浏览器并对实体进行一些更改。然后返回到终端并查找输出。您应看到类似以下的内容2011-09-09 09:42:44,003 - engine - INFO - Using ShotGrid version 3.0.82011-09-09 09:42:44,006 - engine - INFO - Loading plugin at /usr/local/shotgun/ShotGrid/src/plugins/logArgs.py2011-09-09 09:42:44,199 - engine - DEBUG - Starting the event processing loop.2011-09-09 09:45:31,228 - plugin.logArgs.logArgs - INFO - {'attribute_name': 'sg_status_list', 'event_type': 'Shotgun_Shot_Change', 'entity': {'type': 'Shot', 'name': 'bunny_010_0010', 'id': 860}, 'project': {'type': 'Project', 'name': 'Big Buck Bunny', 'id': 65}, 'meta': {'entity_id': 860, 'attribute_name': 'sg_status_list', 'entity_type': 'Shot', 'old_value': 'omt', 'new_value': 'ip', 'type': 'attribute_change'}, 'user': {'type': 'HumanUser', 'name': 'Kevin Porterfield', 'id': 35}, 'session_uuid': '450e4da2-dafa-11e0-9ba7-0023dffffeab', 'type': 'EventLogEntry', 'id': 276560}输出的确切详细信息将有所不同，但您应看到插件已执行预期的操作，即，将事件记录到日志文件中。同样，如果未看到任何内容记录到日志文件中，请在 ShotGridEventDaemon.conf 中检查与日志相关的设置，确保 logging 值设置为记录 INFO 级别的消息，且 logArgs 插件也配置为显示 INFO 级别的消息。关于日志记录的注释应该注意的是，日志轮换是 ShotGrid 进程的一项功能。日志每晚在午夜轮换，每个插件保留十个每日文件。常见错误下面介绍可能遇到的一些常见错误以及如何解决这些错误。如果您真的很难找到，请访问我们的支持站点以获取帮助。无效路径：$PLUGIN_PATHS$您需要在 shotgunEventDaemon.conf 文件中指定插件的路径。权限被拒绝：“/var/log/shotgunEventDaemon”进程无法打开日志文件进行写入。您可能需要使用 sudo 运行进程，或者以对 shotgunEventDaemon.conf 中的 logPath 和 logFile 设置所指定的日志文件具有写入权限的用户身份运行进程。（默认位置为 /var/log/shotgunEventDaemon，通常由 root 用户所有。）ImportError：没有名为 shotgun_api3 的模块未安装此 ShotGrid API。确保它位于当前目录或 PYTHONPATH 中的目录中。如果必须以 sudo 身份运行，并且您认为 PYTHONPATH 设置正确，请记住 sudo 会重置环境变量。您可以编辑 sudoers 文件以保留 PYTHONPATH 或运行 sudo -e(?)配置文件设置列表进程设置以下是常规进程操作设置。pidFilepidFile 是进程在运行时存储其进程 ID 的位置。如果在进程运行时移除此文件，则它在下次完成事件处理循环之后将完全关闭。该目录必须已存在且可写。您可以随意命名该文件，但强烈建议您使用默认名称，因为它与正在运行的进程匹配pidFile: /var/log/shotgunEventDaemon.pideventIdFileeventIdFile 指向进程将存储上次处理的 ShotGrid 事件 ID 的位置。这将允许进程在上次关闭时停止的位置继续，因此不会丢失任何事件。如果要忽略自上次进程关闭后的任何事件，请在启动进程之前移除此文件，进程将仅处理在启动后创建的新事件。此文件将记录每个插件的最后一个事件 ID，并以 pickle 格式存储此信息。eventIdFile: /var/log/shotgunEventDaemon.idlogMode日志记录模式可以设置为以下两个值之一：  0 = 所有日志消息位于主日志文件中  1 = 插件 (engine) 一个主文件，每个插件一个文件当使用值 1 时，插件本身生成的日志消息将记录到由 logFile 配置设置指定的主日志文件。任何由插件记录的消息都将放置在名为 plugin.&amp;lt;plugin_name&amp;gt; 的文件中。logMode: 1logPath放置日志文件的路径（主插件和插件日志文件）。主日志文件的名称由下面的 logFile 设置控制。logPath: /var/log/shotgunEventDaemon                    注意: shotgunEventDaemon 必须具有此目录的写入权限。在典型设置中，进程设置为在计算机启动时自动运行并在当时被授予根权限。    logFile主进程日志文件的名称。日志记录配置为最多存储 10 个日志文件，每晚在午夜进行轮换。logFile: shotgunEventDaemon日志记录发送到日志文件的日志消息的阈值级别。此值是主分派插件的默认值，可以基于每个插件覆盖该值。此值将传递到 Python 日志记录模块。最常用的值为：  10：调试  20：信息  30：警告  40：错误  50：关键logging: 20timing_log通过将此值设置为 on 启用计时日志记录将单独生成一个包含计时信息的日志文件，这应该有助于解决与进程相关的性能问题。为每个回调调用提供的计时信息如下所示：  event_id 触发回调的事件的 ID  created_at 在 ShotGrid 中创建事件时的时间戳（采用 ISO 格式）  callback 调用的回调的名称（采用 plugin.callback 格式）  start 回调处理开始时的时间戳（采用 ISO 格式）  end 回调处理结束时的时间戳（采用 ISO 格式）  duration 回调处理的持续时间（采用 DD:HH:MM:SS.micro_second 格式）  error 回调是否失败。该值可以为 False 或 True。  delay 事件创建与回调开始处理之间的延迟的持续时间（采用 DD:HH:MM:SS.micro_second 格式）。conn_retry_sleep如果连接到 ShotGrid 失败，则这是重新尝试连接之前等待的秒数。网络偶尔出现小问题、服务器重新启动、应用程序维护等情况下会用到此设置。conn_retry_sleep = 60max_conn_retries记录错误级别消息之前重试连接的次数（如果在下面配置了电子邮件通知，可能会发送电子邮件）。max_conn_retries = 5fetch_interval在处理完每批事件后请求新事件之前等待的秒数。通常不需要调整此设置。fetch_interval = 5ShotGrid 设置以下是与 ShotGrid 实例相关的设置。server要连接到的 ShotGrid 服务器的 URL。server: %(SG_ED_SITE_URL)s                    注意: 此处没有默认值。将 SG_ED_SITE_URL 环境变量设置为 ShotGrid 服务器的 URL（即 https://awesome.shotgunstudio.com）    nameShotGridEventDaemon 应连接的 ShotGrid 脚本名称。name: %(SG_ED_SCRIPT_NAME)s                    注意: 此处没有默认值。将 SG_ED_SCRIPT_NAME 环境变量设置为 ShotGrid 服务器的脚本名称（即 shotgunEventDaemon)    key上面指定的脚本名称的 ShotGrid 应用程序密钥。key: %(SG_ED_API_KEY)s                    注意: 此处没有默认值。将 SG_ED_API_KEY 环境变量设置为上述脚本名称的应用程序密钥（即：0123456789abcdef0123456789abcdef01234567）    use_session_uuid从 ShotGrid 实例中的每个事件设置 session_uuid，以在插件生成的任何事件中传播。这样，ShotGrid UI 可以显示因插件而导致的更新。use_session_uuid: True  此功能需要 ShotGrid 服务器 v2.3+。  此功能需要 ShotGrid API v3.0.5+。                    注意: ShotGrid UI 将仅显示繁殖原始事件的浏览器会话的实时更新。其他打开相同页面的浏览器窗口不会看到实时更新。    插件设置路径以逗号分隔的完整路径列表，框架应在其中查找要加载的插件。请勿使用相对路径。paths: /usr/local/shotgun/plugins                    注意: 此处没有默认值。您必须将该值设置为插件文件的位置（即：/usr/local/shotgun/shotgunEvents/plugins 或 C: shotgun shotgunEvents plugins（在 Windows 上））    电子邮件设置这些参数用于错误报告，因为我们发现您不会一直在跟踪日志，而是会有一个活动的通知系统。如果下面提供了所有设置，则会通过电子邮件报告级别 40 (ERROR) 以上的任何错误。必须提供所有这些值，才能发出电子邮件警告。server应该用于 SMTP 连接的服务器。可以取消注释用户名和密码值，以便为 SMTP 连接提供凭据。如果服务器不使用身份认证，您应注释掉 username 和 password 的设置server: smtp.yourdomain.com                    注意: 此处没有默认值。必须使用您的 SMTP 服务器的地址替换 smtp.yourdomain.com 令牌（即 smtp.mystudio.com).    username如果 SMTP 服务器需要身份认证，请取消注释此行，并确保已使用连接到 SMTP 服务器所需的用户名配置 SG_ED_EMAIL_USERNAME 环境变量。username: %(SG_ED_EMAIL_USERNAME)spassword如果 SMTP 服务器需要身份认证，请取消注释此行，并确保已使用连接到 SMTP 服务器所需的密码配置 SG_ED_EMAIL_PASSWORD 环境变量。password: %(SG_ED_EMAIL_PASSWORD)sfrom应在电子邮件中使用的发件人地址。from: support@yourdomain.com                    注意: 此处没有默认值。必须将 support@yourdomain.com 替换为有效值（即 noreply@mystudio.com).    to应将这些警告发送到的电子邮件地址的逗号分隔列表。to: you@yourdomain.com                    注意: 此处没有默认值。必须将 you@yourdomain.com 替换为有效值（即 shotgun_admin@mystudio.com).    subject电子邮件主题前缀，可供邮件客户端使用，以帮助排除 ShotGrid 事件框架发送的警告。subject: [SG]",
    "url": "/ed5161c4/",
    "relUrl": "/ed5161c4/"
  },
  "50": {
    "id": "50",
    "title": "示例插件",
    "content": "示例插件源代码中有一个示例插件的文件夹。此页面包含几个简单的示例，可供任何人入门使用。您可以复制/粘贴此代码，它应该可以正常运行（注意：您需要将 script_name 和 script_key 值更新为特定于您的安装的内容）首先，这里有一个模板，所有 SG 事件代码都应基于此模板编写1. 代码模板复制/粘贴此代码以在新插件上使用&quot;&quot;&quot;Necessary Documentation of the codeAuthor: YouTemplate Author: Andrew Britton&quot;&quot;&quot;def registerCallbacks(reg):    # This takes the form of:    #    matchEvents = {'Shotgun_Entity_EventType': ['list', 'of', 'field', 'names', 'you', 'need', 'sg_custom_field']}    # the 'id' is always returned, in addition to any fields specifically requested by your callback    matchEvents = {        'Shotgun_Task_Change': ['content']    }    # script_name and script_key are defined by you whenever you create a SG script    # the entry_function_call refers to the function that performs the work of the event plugin    reg.registerCallback('script_name', 'script_key', entry_function_call, matchEvents, None)# This gives you#    shotgun handle = sg#    a logger object... please use this instead of python print, especially if you respect your time and your fellow developers#    an event object... this is the metadata that describes what's happening with the particular event.#        some very good information comes from the event['meta'] object, below is the example event['meta'] data from the subject renamer plugin#              {#                &quot;type&quot;: &quot;attribute_change&quot;,#                &quot;attribute_name&quot;: &quot;subject&quot;,#                &quot;entity_type&quot;: &quot;Note&quot;,#                &quot;entity_id&quot;: 2,#                &quot;field_data_type&quot;: &quot;text&quot;,#                &quot;old_value&quot;: &quot;My Note Subject&quot;,#                &quot;new_value&quot;: &quot;2017-05 May-09 - My Note Subject&quot;#              }def entry_function_call(sg, logger, event, args):    # Now do stuff    pass   2. 注释主题重命名使用 New 实体事件这是一个很好的起点，因为它很简单，而且还能处理捕捉 Shotgun_Entity_New 事件的棘手方面…import timefrom pprint import pprintdef registerCallbacks(reg):    matchEvents = {        'Shotgun_Note_New': ['*'],    }    reg.registerCallback('script_name', 'script_key', Function_Name, matchEvents, None)def Function_Name(sg, logger, event, args):    # Waiting here should allow the entity to be fully created            #     and all the necessary attributes to be added to the NOTE entity    time.sleep(1)    current_date = time.strftime(&quot;%Y-%m %b-%d&quot;)    asset_id = event['meta']['entity_id']    asset_type = event['meta']['entity_type']    asset = sg.find_one(asset_type, [['id', 'is', asset_id]], ['subject'])    if asset['subject'] is None:        current_name = current_date + ' - ' + event['project']['name'] + ' - ' + event['user']['name']    else:        current_name = current_date + ' - ' + asset['subject']    # Modify ALL notes except those in 'Software Development'    if event['project'] == None:        logger.info('Updated Note ID is #%d, and is being prepended with &quot;%s&quot;', asset_id, current_date)        logger.info(event)        sg.update(asset_type, asset_id, {'subject': current_name})        return    if event['project']['id'] != 116:        logger.info('Updated Note ID is #%d, and is being prepended with &quot;%s&quot;', asset_id, current_date)        logger.info(event)        sg.update(asset_type, asset_id, {'subject': current_name})    else:        logger.info('Dates are not prepended for notes in project id 116 - Software Development')        return请注意函数主体第一行的 sleep 调用。这与 new 事件的处理方式有关。  在 SG 中创建新实体时，它仍然是非成形的 - 这意味着它不具备完全定义该实体所需的所有习惯属性。实际上，在本示例中，我甚至无法保证在 SG 发出 Shotgun_Note_New 事件时，subject 属性将位于注释实体上。  为了添加所有必需的属性，SG 将发布一系列 Shotgun_Note_Change 事件，其中 SG 会将每个属性添加到实体并更新这些属性的值（如果需要）。  这表示将创建多种事件，这意味着如果您需要存在两个不同的属性，而您未在代码中写入 sleep 内容，则必须对所有 Shotgun_Note_Change 事件和内部元数据进行筛选，以便仅查找那些添加了新属性并设置了值的事件。这是一个繁琐的过程，并且将处理许多 Shotgun_Note_Change 事件，从而在创建时有效查找每个注释的一个事件。  我发现的解决方案是依赖 Shotgun_Entity_New，让脚本休眠一小段时间。在休眠结束时，SG 应该已更新实体所需的所有属性，然后您可以针对所需的任何字段重新查询同一实体2. 字段删除警告生成注释、将字段作为实体使用以及实体停用事件&quot;&quot;&quot;Create a Note when a field is deletedAuthor: Andrew Britton&quot;&quot;&quot;def registerCallbacks(reg):    &quot;&quot;&quot;    fn: registerCallbacks    @brief required function. It connects to the event daemon and calls the trashedFieldWarning Function.    It runs every time a field is deleted (retired)    @param[in] reg variable that is required by shotgun event daemon plugins    @return none    &quot;&quot;&quot;    matchEvents = {        'Shotgun_DisplayColumn_Retirement': ['*']    }    reg.registerCallback('script_name', 'script_key',                         trashedFieldWarning, matchEvents, None)def CreateNote(sg, logger, event):    constants = {'note header': ':: FIELD DELETION :: '}    def GetListOfPipelineUsers():        pipeline_users = sg.find('Group', [['code', 'is', 'People_Who_Need_to_Know']], ['code', 'users', 'addressings_to',                                                                         'sg_ticket_type', 'sg_priority'])        return pipeline_users[0]['users']    def CreateToolsNote():        # Note to members of the pipeline group        # Body text = CreateNoteRequestText()        # Date Created = event['event']['created_at']        # Created By = event['user']['id']        # Project = Software Development['id']        # Subject = ':: Field Delete Warning :: ' + event['entity']['name']        note_data = {            'project': {'type': 'Project', 'id': 'ID OF PROJECT WHERE YOU WANT THE NOTE REPORTED TO'},            # ex: 'project': {'type': 'Project', 'id': 2},            'content': CreateNoteRequestText(),            'created_at': event['created_at'],            'created_by': event['user'],            'addressings_to': GetListOfPipelineUsers(),            'subject': constants['note header'] + event['meta']['display_name']        }        sg.create('Note', note_data)    def CreateNoteRequestText():        OUT = ''        # Tool Name = event['entity']['name']        # sg_assigned_to = members of the pipeline group        # Description = linked Ticket decription        # Project = decided in GUI        # sg_sg_request_ticket = event['entity']['id']        # task_template = Software task template        # Software Projects = defined in GUI        OUT = '::FIELD DELETION WARNING:: n'        OUT += ':: A Field was deleted :: n'        OUT += ':: It was called %s :: n'%event['meta']['display_name']        return OUT    logger.info('::WARNING:: A FIELD has been deleted')    CreateToolsNote()def trashedFieldWarning(sg, logger, event, args):    &quot;&quot;&quot;    fn: finalizeTasksFromShot    @brief Function to create and send a warning note, via SG, whenever a field is deleted    event['entity']['id'] yields the id of the current entity that was caught by the plugin as having been changed.    ie. this is the id of the field that was just deleted    @param[in] sg defines the Shotgun handle to access the database    @param[in] logger sets logging messages to the shotgun event daemon    @param[in] event the collection of shots that have changed    @param[in] args useless variable for this particular function    @return none    &quot;&quot;&quot;    if event['meta']['entity_type'] == 'DisplayColumn':        logger.info('This DisplayColumn was deleted %s', event['meta']['display_name'])    if event['event_type'] == 'Shotgun_DisplayColumn_Retirement':        logger.info('The incoming event call is for deleting a field from an entity. Field name: %s', event['meta']['display_name'])    # logger.info(' TEST ')    # logger.info('Deleted Field ID is #%d, and is called: %s', event['entity']['id'], event['entity']['name'])    CreateNote(sg, logger, event)这是一个非常简单的脚本。检查已删除的字段时没有特殊逻辑。如果删除了某个字段，则会创建一个注释并将其发送给需要了解的一组人员。在我的部门，我们将组 ID 设置为“程序员”组，并将注释的项目 ID 设置为“开发”项目。",
    "url": "/34048d1e/",
    "relUrl": "/34048d1e/"
  },
  "51": {
    "id": "51",
    "title": "安装",
    "content": "安装以下手册将帮助您为您的工作室设置 ShotGridEvents。系统要求进程可以在已安装 Python 且对 ShotGrid 服务器具有网络访问权限的任何计算机上运行。它不需要在 ShotGrid 服务器本身上运行。但是，如果您使用的是 ShotGrid 的托管版本，则无法安装。但是，您可以根据需要在 ShotGrid 服务器上运行它。否则，您可以使用任何服务器。  Python v2.6、v2.7 或 3.7  ShotGrid Python API          对于 Python 3.7+，使用 v3.1.0+（注意：不再支持 Python 2）。      无论在哪种情况下，我们都强烈建议使用最新版本的 Python API，并随着时间的推移更新此依存关系。        对 ShotGrid 服务器的网络访问权限安装 ShotGrid API假设您的计算机上已安装 Python，现在需要安装 ShotGrid Python API，以便 ShotGrid Event 进程可以使用它来连接您的 ShotGrid 服务器。您可以通过多种方式完成此操作：  将它与 ShotGrid Event 进程置于同一目录中  将它放在 PYTHONPATH 环境变量指定的某个目录中。要测试 ShotGrid API 是否正确安装，请观察终端窗口：$ python -c &quot;import shotgun_api3&quot;终端窗口不应输出任何内容。如果您看到类似于以下输出的内容，则请检查 PYTHONPATH 的设置是否正确无误，或 ShotGrid API 是否位于当前目录中。$ python -c &quot;import shotgun_api3&quot;Traceback (most recent call last):File &quot;&amp;lt;string&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;ImportError: No module named shotgun_api3安装 ShotGridEventsShotGridEvents 的安装位置完全由您决定。同样，只要计算机上安装了 Python 和 ShotGrid API，并且计算机具有 ShotGrid 服务器的网络访问权限，就可以从任意位置运行。但是，如果安装位置能够为工作室提供方便，那自然是再好不过了，比如说 /usr/local/shotgun/shotgunEvents 就很方便。因此，下面我们就以此为例进行介绍。请访问 GitHub (https://github.com/shotgunsoftware/shotgunEvents) 获取源代码和归档。                    注意: 对于 Windows：如果有 Windows 服务器，那么您可以使用 C: shotgun shotgunEvents，但是，在本文档中，我们使用的是 Linux 路径。    克隆源如果已在计算机上安装 git，那么抓取源时最简单方法就是克隆项目。这样，您还可以轻松获取所有已承诺的更新，以确保您随时获取错误修复和新功能。$ cd /usr/local/shotgun$ git clone git://github.com/shotgunsoftware/shotgunEvents.git                    警告: 请务必确保先备份您的配置、插件和对 shotgunEvents 所做的任何修改，然后再通过 GitHub 引入更新，以免数据丢失。或者，您也可以自己 Fork 项目，以便保留自己的更改存储库 :)    下载归档如果您的计算机上没有 git，或者您只是想下载源的归档，则可以按照以下步骤进行操作。  转到 https://github.com/shotgunsoftware/shotgunEvents/  下载所需格式的源  将其保存到计算机  将文件提取到 /usr/local/shotgun 目录  将 /usr/local/shotgun/shotgunsoftware-shotgunEvents-xxxxxxx 目录重命名为 /usr/local/shotgun/shotgunEvents将归档提取到 /usr/local/shotgun。对于.tar.gz 归档：$ tar -zxvf shotgunsoftware-shotgunEvents-v0.9-12-g1c0c3eb.tar.gz -C /usr/local/shotgun对于.zip 归档：$ unzip shotgunsoftware-shotgunEvents-v0.9-12-g1c0c3eb.zip -d /usr/local/shotgun然后，您可以将 GitHub 指定的目录名称重命名为 shotgunEvents：$ mv shotgunsoftware-shotgunEvents-1c0c3eb shotgunEvents现在，您应该可以看到如下所示的内容：$ ls -l /usr/local/shotgun/shotgunEventstotal 16-rw-r--r--  1 kp  wheel  1127 Sep  1 17:46 LICENSE-rw-r--r--  1 kp  wheel   268 Sep  1 17:46 README.mkddrwxr-xr-x  9 kp  wheel   306 Sep  1 17:46 docsdrwxr-xr-x  6 kp  wheel   204 Sep  1 17:46 src安装要求在库的根目录下提供了一个 requirements.txt 文件。您应使用此文件来安装所需的软件包。$ pip install -r /path/to/requirements.txtWindows 特定注意事项Windows 系统上需要具有以下其中一项：  已安装 PyWin32 的 Python  Active PythonActive Python 附带 PyWin32 模块，在集成 ShotGrid Event 进程和 Windows 服务架构时，需要用到此模块。然后，您可以通过运行以下命令，以服务的形式来安装进程（假设 C: Python27_32 python.exe 是 Python 可执行文件的路径，根据具体情况加以调整）：&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py install或通过以下方式予以移除：&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py remove借助常规服务管理工具或以下命令行，即可启动和停止服务：&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py start&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py stop大多数情况下，您都需要确保以系统管理用户的身份运行列出的每一个命令。为此，您可以右键单击 cmd 应用程序并选择“以管理员身份运行”。                    注意: 如果您已在 Windows 上的网络位置安装了该进程，或者已将该进程配置为从网络位置读取和写入日志及其他资源，则您必须编辑服务的属性，将运行服务的用户从本地计算机帐户更改为能够访问网络资源的域帐户。    ",
    "url": "/7c203655/",
    "relUrl": "/7c203655/"
  },
  "52": {
    "id": "52",
    "title": "插件",
    "content": "插件概述插件文件是配置文件中指定的插件路径中的任何 .py 文件。在您下载的代码中，src/examplePlugins 文件夹中提供了一些示例插件。其中通过简单的示例介绍了如何构建自己的插件来查找所生成的特定事件，并对这些事件执行操作，从而更改 ShotGrid 实例上的其他值。您无需在每次更新插件后重新启动进程，因为进程将检测插件是否已更新并自动重新加载插件。即使插件发生错误，也不会导致进程崩溃。系统会禁用发生错误的插件，直到其再次更新（可能已修复）时才会启用。其他所有插件将继续运行，并继续处理事件。进程将对故障插件成功处理的最后一个事件的 ID 加以跟踪。此插件更新（可能已修复）后，进程将重新加载此插件，并尝试从插件之前停止的位置处理事件。当一切恢复正常之后，进程会促使插件赶上当前事件处理进度，然后继续以正常方式处理所有插件的事件。ShotGrid 事件处理插件有两个主要部分：回调注册函数和任意数量的回调。registerCallbacks 函数要想由框架加载插件，此插件至少应执行以下函数：def registerCallbacks(reg):    pass该函数的作用是，告诉事件处理系统需要调用哪些函数来处理事件。此函数应使用一个参数，即 Registrar 对象。Registrar 拥有一个非常重要的方法：Registrar.registerCallback。对于每个需要处理 ShotGrid 事件的函数，应使用相应的参数调用 Registrar.registerCallback 一次。您可以根据需要注册任意数量的函数，而不需要将文件中的所有函数注册为事件处理回调。回调通过系统注册的回调必须使用四个参数：  一个 ShotGrid 连接实例，用于查询 ShotGrid 以获取更多信息。  一个 Python Logger 对象，用于报告。错误和关键消息将通过电子邮件发送给任何已配置的用户。  要处理的 ShotGrid 事件。  在回调注册时传入的 args 值。（请参见 Registrar.registerCallback）                    警告: 您可以在插件中采取任何操作，但如果导致框架出现任何异常，系统将停用故障回调（及所有内含回调）所在的插件，直至磁盘上的文件发生变化（显示“已修复”）。    日志记录建议不要在事件插件中使用输出语句。而应使用 Python 标准库中的标准日志记录模块。系统会向您的众多函数提供一个日志记录程序对象def registerCallbacks(reg):    reg.setEmails('root@domain.com', 'tech@domain.com') # Optional    reg.logger.info('Info')    reg.logger.error('Error') # ERROR and above will be sent via email in default config并且def exampleCallback(sg, logger, event, args):    logger.info('Info message')如果事件框架作为进程运行，则其会记录到文件，否则，将记录到标准输出。构建强大的插件该进程针对 ShotGrid 运行查询，但进程具有内置功能，可在 find() 命令无法生效时重试此命令，从而为进程本身赋予一定的稳定性。https://github.com/shotgunsoftware/shotgunEvents/blob/master/src/shotgunEventDaemon.py#L456如果插件需要网络资源（即 ShotGrid 或其他资源），则需要自行提供重试机制/稳定性。如果通过 ShotGrid 进行访问，您可以关闭进程中的内容，并生成可向插件提供相应功能的辅助函数或类。ShotGrid Python API 确实能够针对网络问题进行一定程度的重试，但是对于需要运行好几分钟的 ShotGrid 维护窗口，或者临时网络故障，该 API 可能就捉襟见肘了。https://github.com/shotgunsoftware/python-api/blob/master/shotgun_api3/shotgun.py#L1554根据插件的用途，还可以注册该插件，以便在处理事件时遇到问题之际，保持平稳推进。了解 registerCallback 函数的 stopOnError 参数：https://github.com/shotgunsoftware/shotgunEvents/wiki/API#wiki-registerCallback                    注意: 插件不会停止运行，但不会在出现故障时进行重试。    ",
    "url": "/3d05c112/",
    "relUrl": "/3d05c112/"
  },
  "53": {
    "id": "53",
    "title": "技术细节",
    "content": "技术概述事件类型您的触发器可以注册以接收通知的事件类型通常遵循以下形式：Shotgun_[entity_type]_[New|Change|Retirement|Revival]。下面是这种模式的一些示例：Shotgun_Note_NewShotgun_Shot_NewShotgun_Task_ChangeShotgun_CustomEntity06_ChangeShotgun_Playlist_RetirementShotgun_Playlist_Revival对于不涉及实体记录活动但关系到应用程序行为关键节点的事件，其模式可能与上述模式存在明显偏差。CRS_PlaylistShare_CreateCRS_PlaylistShare_RevokeSG_RV_Session_Validate_SuccessShotgun_Attachment_ViewShotgun_Big_QueryShotgun_NotesApp_Summary_EmailShotgun_User_FailedLoginShotgun_User_LoginShotgun_User_LogoutToolkit_App_StartupToolkit_Desktop_ProjectLaunchToolkit_Desktop_AppLaunchToolkit_Folders_CreateToolkit_Folders_Delete    此列表并不完整，但是是一个很好的起点。如果您想要了解有关 ShotGrid 站点上的活动和事件类型的详细信息，请参考事件日志条目页面。在此页面上，您可以像任何其他实体类型的任何其他网格页面一样进行过滤和搜索。缩略图的事件日志条目每次为实体上传新缩略图时，系统都会使用 `Type` == `Shotgun_&amp;lt;Entity_Type&amp;gt;_Change`（例如 Shotgun_Shot_Change）创建事件日志条目。  ‘is_transient’ 字段值设置为 true：    { &quot;type&quot;: &quot;attribute_change&quot;,&quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: null, &quot;new_value&quot;: 11656, &quot;is_transient&quot;: true}        当缩略图可用时，将创建一个新的事件日志条目，此时 ‘is_transient’ 字段值设置为 false：    { &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: null, &quot;new_value&quot;: 11656, &quot;is_transient&quot;: false}        如果我们再次更新缩略图，即可得到这些新事件日志条目：    { &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: 11656, &quot;new_value&quot;: 11657, &quot;is_transient&quot;: true}{ &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: null, &quot;new_value&quot;: 11657, &quot;is_transient&quot;: false}        请注意，当附件的缩略图为占位符缩略图时，‘old_value’ 字段将设置为空。插件处理顺序始终按相同的可预测顺序处理每个事件，如此一来，如果任何插件或回调存在相互依赖关系，即可放心地对其处理工作进行规划。配置文件会指定一个 paths 配置，其中包含一个或多个插件位置。在列表中的位置越靠前，包含的插件就会越早被处理。系统将按字母顺序升序处理插件路径中的每个插件。                    注意: 从内部来说，系统列出文件名列表并对其进行排序。    最后，将按注册顺序调用插件注册的每个回调。先注册，先运行。我们建议将需要在一定程度上共享状态的功能保存在与一个或多个回调相同的插件中。共享状态有许多选项可用于需要共享状态的多个回调。  全局变量。呃，请不要这样做。  一个包含状态信息的已导入模块。这样也不行，但比完全是全局变量好一点。  一个在调用 Registrar.registerCallback 时传入 args 参数的可变要素。一个设计状态对象，或仅仅是一个 dict。首选。  在对象实例上执行回调（如 __call__），并在回调对象初始化时提供一些共享状态对象。最强大但也最复杂的方法。与上述 args 参数方法相比，可能有些不必要。事件积压该框架旨在让每个插件对其感兴趣的每个事件进行一次处理，并且不会出现异常。为确保实现这一目标，框架会存储每个插件积压的未处理事件，并记住为每个插件提供的最后一个事件。下面简单介绍了可能出现积压的一些情况。由于事件日志条目序列不连贯导致的积压对于 ShotGrid 中发生的每个事件（字段更新、实体创建、实体停用等），其事件日志条目都具有唯一的 ID 编号。ID 编号序列有时并不是连贯的。导致这种不连贯的原因有很多，其中一个就是大型数据库事务尚未完成。每次事件日志序列出现不连贯现象时，“空缺”的事件 ID 都会被纳入积压工作，以便日后处理。这样，事件进程便可在结束时处理来自长数据库事务的事件。有时，事件日志序列中的“空缺”永远无法填补，例如当事务失败或还原页面设置更改时。在这种情况下，超过 5 分钟时限后，系统便不再等待相应事件日志条目 ID 编号，并将其从积压工作中移除。此时，系统将显示“积压事件 ID # 已超时”(Timeout elapsed on backlog event id #)消息。如果事件序列首次出现不连贯现象且系统已将其视为超时，此时将显示“事件 # 从未发生 - 忽略”(Event # never happened - ignoring)消息，并且此事件不会在第一时间纳入积压工作。由于插件错误而导致的积压在正常操作期间，框架会持续跟踪各个插件处理的最后一个事件。如果某个插件因任何原因发生故障，该插件将停止处理后续事件。修复插件后，例如修复某个错误后，该框架将从修复的插件所存储的最后一个事件之处开始处理事件。这样做是为了确保新修复的插件能够处理所有事件，包括那些在发生故障到修复错误期间发生的事件。如果故障是在很久以前发生的，这可能意味着需要回访大量事件，如此一来，已修复的插件可能需要一段时间来赶上其他正常运行的插件的进度。在已修复的插件追赶进度时，其他插件会忽略相应事件，确保相同的插件不会对任何一个事件进行两次处理。此时，系统会显示“事件 X 过于久远。最后处理的事件是(Y)”(Event X is too old. Last event processed is (Y))消息。这是调试消息，可以放心地忽略。目前没有正式的方法来跳过这一提示。该框架旨在确保每个插件仅对每个事件进行一次处理。但是，如果您了解 Python 及其 pickle 数据格式，那么您可以停止进程，通过 Python 解释器/交互式 Shell 打开 .id 文件，然后利用 pickle 模块解码文件内容并加以编辑，以便移除存储的ID，这样就可以跳过累积积压工作了。我们不支持这种做法，风险由您自行承担。请在执行此操作之前正确备份 .id 文件。",
    "url": "/af5c969c/",
    "relUrl": "/af5c969c/"
  },
  "54": {
    "id": "54",
    "title": "编写事件驱动的触发器",
    "content": "ShotGrid 事件框架此软件最初由 Patrick Boucher 开发，由 Rodeo Fx 和 Oblique 提供支持。该软件现已加入 ShotGrid Software 的开源计划。该软件根据 MIT 许可提供：如需获取该许可，请访问 LICENSE 文件或开源计划网站。目录：  概述  框架的优点  编写事件驱动的触发器          示例用例      事件驱动的触发器的工作方式      轮询事件日志与触发器      事件类型      事务和可能丢失的事件      概述如果要访问 ShotGrid 事件流，首选方法是监视事件表、获取任何新事件并对其进行处理，然后重复上述动作。需要执行许多工作才可顺利完成此流程，这些工作可能与需要应用的业务规则并无任何直接关系。框架的作用是使业务逻辑实施者摆脱任何繁琐的监视任务。该框架是一个守护进程，可在服务器上运行并监视 ShotGrid 事件流。找到事件时，守护进程会将事件分发给一系列注册的插件。每个插件可以根据情况处理事件。进程负责以下工作：  从一个或多个指定路径注册插件。  取消激活任何崩溃的插件。  当磁盘上的插件出现变化时重新加载插件。  监视 ShotGrid 事件流。  记住最后一次处理的事件 ID 和所有积压工作。  当进程启动后，从最后一次处理的事件 ID 开始作业。  捕捉所有连接错误。  根据需要将信息记录到标准输出、文件或电子邮件。  创建与 ShotGrid 的连接，以供回调使用。  将事件传递到已注册的回调。插件负责以下工作：  将任意数量的回调注册到框架。  每当框架提供一个事件时，便处理该事件。框架的优点  为所有脚本使用一个监视机制，而不是为每个脚本使用一个。  可最大限度地减轻网络和数据库负载（仅使用一个监视器向多个事件处理插件提供事件）。编写事件驱动的触发器注意：有关事件驱动型触发器的详细信息，请参见我们的文档：https://github.com/shotgunsoftware/shotgunEvents。ShotGrid 会为在 ShotGrid 中发生的每个动作创建一个事件日志条目。您可以在您的 ShotGrid 站点中以及通过 ShotGrid API 查看这些事件。除了在 ShotGrid 中查看事件的详细历史记录外，您还可以编写自己的事件侦听器脚本来轮询事件日志并对您关注的某些事件执行操作。您的脚本可以执行您的工作流中的其他内部脚本，也可以使用 ShotGrid API 并更新 ShotGrid 中的其他信息，或同时实现两者。示例用例下面是一些使用事件驱动的触发器的示例：  每当镜头的“布局”(Layout)任务状态标记为“最终”(final)时，自动将“动画”(Animation)任务状态设置为“准备开始”(ready to start)，以便动画设计师知道可以开始处理该镜头。  每当在 ShotGrid 中创建了新镜头时，都会在文件系统上创建合适的镜头目录。  当某个镜头进入“暂停”(on hold)状态时通知分配给该镜头的美工人员。  最终确定了某个资产时将目录设为只读。  在 ShotGrid 中将版本添加到审核时，将相关版本（或镜头）信息复制到样片系统。  场景增加到 25 个镜头时，通过 Twitter 发布一个以与场景的“说明”(Description)字段中第三个词语相同的字母开头的随机引文。事件驱动的触发器的工作方式下面是 ShotGrid 生成的事件日志条目简单图表。您的脚本将使用 API 获取自上次查询以来发生的事件列表。然后，它将查看每个事件类型（例如 ShotGrid_Task_Change），看看其中是否有您关注的事件类型。一旦找到关注的事件，它将更进一步检查事件的详细信息（例如，更改了哪些字段，值更改为什么等。此时，如果需要，您甚至可以使用 API 请求实体的详细信息）。如果事件符合要求，脚本将对该事件执行操作，并执行用于确定是使用 ShotGrid API、您的工作流中的内容还是两者时需要执行的任何代码。没有其他事件要查看时，重复该过程，然后使用 API 获取自上次查询以来发生的事件列表。轮询事件日志与触发器ShotGrid 提供持续的事件信息流，您可以侦听所有事件，并只对您关注的事件执行操作。相比于让 ShotGrid 自己控制触发器，这具有以下优势：  灵活：您的触发器脚本可以独立于 ShotGrid 运行。这样，您的脚本可以按照您所需的任何方式与 ShotGrid 和您的工作流交互。您可以根据需要定义规则和动作，不受任何约束。ShotGrid 不需要了解有关您的事件触发器的任何信息。它只需持续生成事件日志条目。您可以控制后续情况的所有其他方面。  远程：您的脚本可以从能通过网络访问 ShotGrid 服务器的任何位置运行。您的脚本只需要 API 访问权限即可运行。  多重性：您可以同时运行多个脚本。不同部门可能有不同的需求，因此侦听不同的事件。可以从同一脚本运行所有触发器，没有任何限制。您可能希望将触发器分解为单独的逻辑脚本。轮询查询占用资源非常少，对性能不会有任何显著影响。  责任明确：如果您的脚本对 ShotGrid 进行更改，它们也会创建自己的事件，从而允许您准确查看哪些脚本进行了更改。事件类型所有内部事件类型都采用 Shotgun_[entity_type]_[New|Change|Retirement] 格式。例如 Shotgun_Shot_New 和 Shotgun_Asset_Change。有关详细信息，请参见事件类型文档。事务和可能丢失的事件ShotGrid 在事务中执行破坏性数据库查询，且仅当事务完成时向事件日志写入。因此，您在此处使用“最高 ID”方法时可能会丢失事件。但是，GitHub 站点上的事件触发器框架具有应当能处理这些情况的代码。",
    "url": "/0d8a11d9/",
    "relUrl": "/0d8a11d9/"
  },
  "55": {
    "id": "55",
    "title": "Features Description",
    "content": "Isolation Feature SetThis section describes in detail each of the Isolation Features.To get the onboarding process started, go to Onboarding Process.To start the setup for any of the Isolation features, go to the Setup section.In This Section  Media Isolation  Media Traffic Isolation  Media Replication",
    "url": "/82f8da29/",
    "relUrl": "/82f8da29/"
  },
  "56": {
    "id": "56",
    "title": "文件系统配置参考",
    "content": "文件系统配置参考本主题中的内容：  简介  第 1 部分 - 文件夹创建语法          查询文件夹      多个文件夹      随父文件夹一起创建      可选字段      正则表达式代币匹配      示例      列表字段文件夹      工作流工序文件夹                  不同工作流工序的不同文件系统布局                    高级技巧 - 指定父文件夹      任务文件夹                  高级技巧 - 指定父文件夹                    工作空间和延迟文件夹创建      当前用户文件夹      静态文件夹      符号链接      忽略文件和文件夹      自定义 IO 和权限                  传递给挂钩的数据          向挂钩传递您自己的文件夹创建指令          向静态文件夹添加自定义配置                    文件夹创建方式的简单自定义        第 2 部分 - 配置文件系统模板          键部分                  示例 - 字母数字名称          示例 - 版本号          示例 - 立体视点          示例 - 图像序列          示例 - 两个字段通过别名都命名为 version          示例 - 时间戳          示例 - 映射          示例 - 具有两个有效值的字符串字段          示例 - 禁止使用某个值          示例 - 字符串子集                    路径部分      字符串部分      在模板中使用可选的键        高级问题和疑难解答          如何向文件结构中添加新的实体类型？                  “剧集 &amp;gt; 场 &amp;gt; 镜头”(Episode &amp;gt; Sequence &amp;gt; Shot)层次结构需要的字段                          剧集              场              镜头              剧集              Toolkit 模板定义                                          如何在结构中设置分支？      如何创建自定义工作流工序？      本文档全面地介绍了 ShotGrid Pipeline Toolkit 中以文件系统为中心的配置，并概述了模板系统的工作方式以及可用的选项。还列出了在文件夹创建配置中可以包含的所有不同参数。请注意，本文档介绍仅当您控制了 Toolkit 配置时才可用的功能。有关详细信息，请参见 ShotGrid 集成管理员手册。简介本文档介绍如何配置 Toolkit 配置中与您的文件系统相关的部分，包括相关的示例。Toolkit 需要处理大量文件和目录，您可以利用 Toolkit 的配置来表现路径的组合方式和它们代表的意义。通常可以通过两种截然不同且互不相关的方式访问文件系统：创建文件夹：在 ShotGrid 中创建对象后，我们需要先在磁盘上创建文件夹，然后才能开始工作。这个过程可以很简单，比如在磁盘上创建一个文件夹来代表镜头；也可以更复杂，比如设置一个特定于用户的工作沙盒，让每个处理镜头的用户在单独的磁盘区域工作。  Toolkit 会在您启动应用程序（例如为镜头 BECH_0010 启动 Maya）时自动创建文件夹，并确保在启动 Maya 前文件夹已存在。如果文件夹不存在，则会即时创建这些文件夹。也可以使用 API 方法、使用 shell 中的 tank 命令以及通过 ShotGrid 中的“创建文件夹”(Create Folders)菜单来创建文件夹。此文件夹创建过程由一组特殊的配置文件来驱动，以下文档的第 1 部分对此进行了概述。打开和保存工作：在工作时，我们需要在磁盘的标准位置打开和保存文件。这些文件位置通常位于在开始工作之前创建的文件夹结构中。  建立文件夹结构后，我们可以使用该结构来确定关键的磁盘位置。这些位置称为模板。例如，您可以定义一个名为 maya_shot_publish 的模板，来指代为镜头发布的 Maya 文件。然后，Toolkit 应用将使用此模板 - 发布应用可能会使用它来控制应在何处写入其文件，而 Workfiles 应用可能会使用此模板了解从何处打开文件。在 Toolkit 的环境配置内，您可以控制每个应用使用哪些模板。因此，Toolkit 使用的所有关键文件位置都定义在一个模板文件中，并且易于查看。第 1 部分 - 文件夹创建语法文件夹配置将 ShotGrid 中的实体映射到磁盘上的位置。配置不是使用单个配置文件，而是采用“迷你文件系统”的形式，它充当每个所配置单元的模板 - 这称为数据结构配置。当执行 Toolkit 的文件夹创建时，文件夹和文件将从这一“迷你文件系统”复制到它们的目标位置。这样可以实现动态的行为。例如，一个文件夹可以表示 ShotGrid 中的一个镜头，而您可以控制该文件夹的命名。更具体地说，您可以使用几个 ShotGrid 字段来构成该文件夹的名称，然后在创建文件夹前执行字符转换。上图显示了一个数据结构配置。当您执行 Toolkit 文件夹创建操作时，会在 ShotGrid 中的实体与磁盘上的文件夹之间建立联系。Toolkit 使用此文件夹数据结构配置在磁盘上生成一系列文件夹，而每个文件夹在 ShotGrid 中都注册为一个 Filesystem Location 实体。我们可以将这看成是 ShotGrid 数据（例如镜头和资产名称）和配置被“转化”成磁盘上和 ShotGrid 中的实际文件夹。配置总是以一个名为“project”的文件夹开头。此文件夹始终表示 ShotGrid 中连接的项目，并将被替换为项目的 Toolkit 名称。这层下面是静态文件夹。例如，文件夹创建器将自动创建 sequences 文件夹。进一步深入 sequences 文件夹，有一个 sequence 文件夹和一个 sequence.yml 文件。每当 Toolkit 检测到与文件夹同名的 YAML 文件时，它就会读取 YAML 文件的内容，并添加所需的动态行为。在本例中，sequence.yml 文件包含 project 文件夹下的结构，由三种内容组成：  普通文件夹和文件：这些内容将直接被复制到目标位置。  含有 YAML 文件的文件夹（文件与文件夹同名）：这代表动态内容。例如，可能有一个 shot 文件夹和一个 shot.yml，当创建文件夹时，此 shot 文件夹是用于生成一系列文件夹的模板 - 每个镜头一个文件夹。  名为 name.symlink.yml 的文件：它将在处理文件夹时生成符号链接。本文档稍后将对符号链接进行介绍。目前，以 YAML 文件形式表示的动态配置设置支持以下模式：      ShotGrid 查询文件夹：基于 ShotGrid 数据库查询的动态文件夹名称。例如，此模式可用于为项目中的每个镜头创建一个文件夹。        ShotGrid“列表字段”文件夹：基于 ShotGrid 列表字段的动态文件夹名称。例如，此模式可用于为 ShotGrid 的“资产”(Asset)实体上的 ShotGrid 列表字段“资产类型”(Asset Type)中的每个值创建一个文件夹。        延迟文件夹：只有在通过 Toolkit API 的创建文件夹方法请求第二个文件夹创建过程时（通常在启动诸如 Maya 等应用程序时），才会创建该文件夹。通常，Toolkit 的各种应用程序启动器会在启动应用程序前执行此方法。        当前用户文件夹：一个特殊文件夹，表示当前用户。  下面我们来更深入地了解这些模式。查询文件夹要创建一个与 ShotGrid 查询对应的动态文件夹，请在 YAML 文件中使用以下语法：# the type of dynamic contenttype: shotgun_entity# the ShotGrid entity type to connect toentity_type: Asset# the ShotGrid field to use for the folder namename: code# ShotGrid filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std ShotGrid API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]   将动态内容 type 字段的值设置为 shotgun_entity。  entity_type 字段应设置为要从中提取数据的 ShotGrid 实体（例如“资产”(Asset)、“镜头”(Shot)、“场”(Sequence)、“自定义实体 02”(CustomEntity02)等）。      name 字段是根据 ShotGrid 中的数据应指定给每个文件夹的名称。    您可以像上面的示例中那样，只使用一个字段（例如 name: code）。  您可以在花括号中使用多个字段（例如 name: &quot;{asset_type}_{code}&quot;）。  如果想包含来自其他链接实体的字段，可使用标准 ShotGrid 语法（例如 name: &quot;{sg_sequence.Sequence.code}_{code}&quot;）。  filters 字段是一个 ShotGrid 查询。它相对严格地遵循 ShotGrid API 语法。它是一个词典列表，并且每个词典都需要具有 path、relation 和 values 键。$ 语法的有效值是任何包含对应 ShotGrid 实体的根文件夹（例如，对于项目来说是 &quot;$project&quot;，而如果上层目录层次结构存在 sequence.yml，也可以是 &quot;$sequence&quot;）。对于 ShotGrid 实体链接，您可以使用 $ 语法（例如 { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }）指代配置中的父文件夹 - 下面的示例对此进行了更深入的讲解。多个文件夹在名称定义中包含斜杠是为了创建可一次性创建多个文件夹的表达式：# the type of dynamic contenttype: shotgun_entity# the ShotGrid entity type to connect toentity_type: Asset# the ShotGrid field to use for the folder namename: &quot;{sg_asset_type}/{code}&quot;# ShotGrid filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std ShotGrid API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ] 创建适用于这种路径的文件系统模板（有关详细信息，请参见此文档的第 2 部分）时，最后一个文件夹将表示 ShotGrid 实体。例如，可以使用以下模板表示上面的示例asset_step_folder: assets/{asset_type}/{Asset}/{Step}{asset_type} 和 {Asset} 都定义为字符串模板键，{Asset} 令牌将在确定给定路径的上下文时在上下文计算中使用。随父文件夹一起创建在 ShotGrid 中，ShotGrid 的数据结构中存在嵌套。这种嵌套可以称为父子关系。例如，在文件系统中，sequence 通常是 shot 的父文件夹；同样，shot 通常是 sequence 的子文件夹。                    注意: 这种文件系统嵌套关系独立于 ShotGrid 层次结构，两者之间没有任何联系。它们的配置是完全独立的。    shotgun_entity 类型的文件夹支持一个可选标志，该标志可控制文件夹创建过程在创建父文件夹后是否尝试向下递归到该文件夹中，如果是的话，还将创建子文件夹。标志作为一种设置，只能有某些固定值，在本例中为“true”或“false”。要添加此标志，请参考下面这个示例：# recurse down from parent foldercreate_with_parent: true 如前所述，这个设置是可选的，默认值为 False。如果将它设置为 True，Toolkit 将为找到的所有子实体创建文件夹。继续来看我们的示例，如果您想每次创建场父文件夹时都创建镜头子文件夹，可将镜头文件夹的 create_with_parent 设置为 true。                    注意: 默认设置为 false，这意味着，如果您为场创建文件夹，则不会自动创建镜头文件夹。此外，您需要添加此标志，以将其设为 True。shotgun_entity 文件夹中不提供指定 False 的标志，因为 False 本身是默认行为。    可选字段通常，当您定义文件夹名称（例如 {code}_{sg_extra_field}）时，Toolkit 会要求所有字段在 ShotGrid 中都具有值。例如，如果 sg_extra_field 为空，则会生成一条错误消息。如果某个字段并不总是填充有值，可将它标记为可选字段。可选字段的意思是，Toolkit 会在该字段有值时包含它，在该字段为空时不包含它，而不会生成错误。您可以使用方括号定义可选字段，比如：{code}[_{sg_extra_field}]。这会生成以下文件夹名称：  如果 code 为 BECH_0010，sg_extra_field 为 extra，则文件夹名称将为 BECH_0010_extra。  如果 code 为 BECH_0010，sg_extra_field 为空，则文件夹名称将为 BECH_0010。                    注意: 可选字段只能用来定义您数据结构中文件夹名称的一部分。整个文件夹并不能完全可选。    正则表达式代币匹配Toolkit 支持使用正则表达式提取 ShotGrid 字段名称的部分内容。这样，可以创建简单的表达式，从而可使用 ShotGrid 中的值来驱动文件夹的创建。例如，如果 ShotGrid 中的所有资产都以三个字母为前缀，后跟一个下划线命名（例如 AAT_Boulder7），这样就可以拆分为两个文件系统文件夹级别（例如 AAT/Boulder7）：# the type of dynamic contenttype: shotgun_entity# the ShotGrid entity type to connect toentity_type: Asset# Extract parts of the name using regular expressionsname: &quot;{code:^([^_]+)}/{code^[^_]+_(.*)}&quot;# ShotGrid filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std ShotGrid API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]该语法类似于模板系统中的 subset 令牌；只需在 ShotGrid 字段名称后面添加一个冒号，后跟一个正则表达式。正则表达式中定义的任何组（例如，() 括起来的部分）将用于提取值。如果正则表达式中有多个组，它们将会连接在一起。例如，以下表达式将提取创建对象的用户的首字母：{created_by.HumanUser.code:^([A-Z])[a-z]* ([A-Z])[a-z]*}示例下面一组示例说明了如何使用 filters 语法。要查找所有属于当前项目且正在进行的镜头，可使用下面的语法。请注意，ShotGrid 镜头实体有一个称为“项目”(project)的链接字段，用于将镜头连接到项目。我们要确保只为与当前项目关联的镜头创建文件夹。由于配置文件系统中存在上层项目目录，我们可以通过 $ 语法引用它，Toolkit 会自动根据此 ShotGrid 实体链接引用来创建文件夹。请记住，$ 语法的有效值是任何包含对应 ShotGrid 实体的根文件夹（例如，对于项目来说是 &quot;$project&quot;，如果上层目录层次结构存在 sequence.yml，也可以是 &quot;$sequence&quot;）。entity_type: Shotfilters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;status&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;ip&quot; ] }如果树的上层有场文件夹，并想为属于该场的所有镜头创建文件夹，则可以创建以下过滤器：entity_type: Shotfilters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] }要查找所有资产，可使用以下语法：entity_type: Assetfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]列表字段文件夹例如，如果要为 ShotGrid 中的每种资产类型创建一个文件夹，ShotGrid 列表字段文件夹很有用。在 ShotGrid 中，资产类型属于列表字段。使用此文件夹配置类型，可以在文件系统中定义一个层来反映这些资产类型列表。                    注意: 在磁盘上创建文件夹后，强烈建议不要更改关联数据的值（例如资产类型）。    如果需要一个动态文件夹来对应 ShotGrid 列表字段中的所有项，可在 YAML 文件中使用以下语法：# the type of dynamic contenttype: &quot;shotgun_list_field&quot;# the ShotGrid entity type to connect toentity_type: &quot;Asset&quot;# only create for values which are used in this project.# this is optional and will be set to false if not specified.skip_unused: false# by default, list fields are only created if they are needed by a child entity node# by setting the create_with_parent parameter to true you ensure that list field# nodes are always createdcreate_with_parent: false# the ShotGrid field to use for the folder namefield_name: &quot;{sg_asset_type}_type&quot;  将动态内容 type 字段的值设置为 shotgun_list_field。  entity_type 字段应设置为想要从中提取数据的 ShotGrid 实体（例如“资产”(Asset)、“场”(Sequence)、“镜头”(Shot)等）。      field_name 字段应设置为从中提取数据的 ShotGrid 字段，并且必须是列表类型字段。如果想随动态内容一起添加静态文本，则可以使用表达式。field_name: &quot;{sg_asset_type}_type&quot;此示例表达式包含文本和一个模板键。    可选参数 skip_unused 可防止为未使用的列表类型字段值创建目录（如上面的可选字段部分所述）。                    注意: 将此参数设置为 True 可能会对文件夹创建性能产生不利影响。另外，剔除算法目前还很简陋，不支持关联实体应用了复杂过滤器的情况。      可选参数 create_with_parent 可强制创建 list_field 节点，即使当前没有正在处理的子实体级节点（请参见上面的随父文件夹一起创建部分）。工作流工序文件夹工作流工序文件夹表示 ShotGrid 中的工作流工序。工作流工序也称为“工序”。# the type of dynamic contenttype: &quot;shotgun_step&quot;# the ShotGrid field to use for the folder name. This field needs to come from a step entity.name: &quot;short_name&quot;您可以在此处使用名称表达式，就像上面介绍的 ShotGrid 实体一样。节点会查找其父节点、祖父节点等，直至找到 ShotGrid 实体文件夹配置。此实体文件夹将与工序关联，并且实体的类型将用来确定要创建哪些工序。                    注意: 如果您想使用工作流工序创建顶层文件夹，只需使用 ShotGrid 实体节点并将关联的类型设置为“工序”(Step)即可。    默认情况下，Step 文件夹会尝试自动为特定实体创建所有相关工序。例如，如果一个包含 5 个工序（布局、动画、特效、照明、合成）的镜头触发了文件夹创建操作，将自动为这 5 个工序（布局、动画、特效、照明、合成）创建工序文件夹。但是，您可以使用以下语法关闭此功能：# recurse down from parent foldercreate_with_parent: false将此设置添加到配置，意味着创建镜头文件夹时不会创建任何工序文件夹。只有在任务中运行文件夹创建操作时，才会创建工序文件夹。如果您想配置用户沙盒和其他需要在工作开始前才创建的结构，可以使用此功能。为不同工作流工序设置不同的文件系统布局假设您想让照明和合成工序使用一个文件夹结构，其余工序则使用另一个文件夹结构。如果您想为不同的工作流工序使用不同的文件系统布局，可以向配置中添加 filter 子句来实现这一点。使用此过滤器可限定特定工序的配置将会涵盖哪些工作流工序。在我们的示例中，您可以创建两个配置文件：step_lightcomp.yml 和 step.yml。在第一个配置文件中，添加以下过滤器：filters: [ { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;in&quot;, &quot;values&quot;: [ &quot;Light&quot;, &quot;Comp&quot;  ] } ] 上面的语法只有在创建 Light 或 Comp 类型的工序文件夹时才会使用。在第二个配置文件中，为其他工序创建一条规则：filters: [ { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;not_in&quot;, &quot;values&quot;: [ &quot;Light&quot;, &quot;Comp&quot;  ] } ]现在，您可以在每个文件夹中定义单独的子结构。高级技巧 - 指定父文件夹在创建文件夹的过程中，Toolkit 需要将工作流工序与实体（例如“镜头”(Shot)、“资产”(Asset)等）相关联。为实现这一目标，默认情况下，Toolkit 会查找文件夹树，并选取找到的第一个 ShotGrid 实体文件夹。例如，如果您的层次结构为 Sequence &amp;gt; Shot &amp;gt; Step，工序文件夹会自动与镜头关联，这通常正是您想要的。但是，如果您的层次结构在主实体下还有实体，例如 Sequence &amp;gt; Shot &amp;gt; Department &amp;gt; Step，Toolkit 默认会将工序文件夹与部门一级关联，但这并不是您想要的。在这种情况下，我们需要明确指示 Toolkit 要查找哪个位置。通过向工序配置中添加以下内容，可以实现这一点：associated_entity_type: Shot任务文件夹任务文件夹表示 ShotGrid 中的任务。默认情况下，任务文件夹不会随其父文件夹一起创建。例如，如果某个关联了任务节点的镜头触发了文件夹创建操作，将不会自动创建任务文件夹。只有在为任务执行文件夹创建操作时（例如从 ShotGrid 启动某项任务时），才会创建任务文件夹。# the type of dynamic contenttype: &quot;shotgun_task&quot;# the ShotGrid field to use for the folder name. This field needs to come from a task entity.name: &quot;content&quot; 但是，您可以使用以下语法开启创建功能，让任务随其父实体一起创建：# recurse down from parent foldercreate_with_parent: true与工序类似，如果要过滤出文件夹配置应操作哪些任务，您也可以选择提供 filter 参数。同样，您可以使用名称表达式，就像上面介绍的 ShotGrid 实体一样，其中，静态文本可以与动态内容一起使用，以便您可以创建一个兼具动态和静态上下文的名称。name: &quot;task_{content}&quot;节点会查找其父节点、祖父节点等，直至找到 ShotGrid 实体文件夹配置。此实体文件夹将与任务关联，并用来确定要创建哪些任务文件夹。高级技巧 - 指定父文件夹在创建文件夹的过程中，Toolkit 需要将任务与实体（例如“镜头”(Shot)、“资产”(Asset)等）相关联。为实现这一目标，默认情况下，Toolkit 会查找文件夹树，并选取找到的第一个 ShotGrid 实体文件夹。例如，如果您的层次结构为 Sequence &amp;gt; Shot &amp;gt; Task，任务文件夹会自动与镜头关联，这通常正是您想要的。但是，如果您的层次结构在主实体（例如镜头）下还有实体，例如 Sequence &amp;gt; Shot &amp;gt; Department &amp;gt; Task,，Toolkit 默认会将任务与部门级别关联，但这并不是您想要的。在这种情况下，我们需要明确指示 Toolkit 在何处查找，类似于我们在上一部分中使用工序更新它的方式。通过向任务配置中添加以下内容，可以实现这一点：associated_entity_type: Shot工作空间和延迟文件夹创建延迟文件夹创建是指，仅当 Toolkit API 的创建文件夹方法通过可选的 engine 参数请求第二次文件夹创建操作时，才执行创建操作。通常，Toolkit 的各种应用程序启动器会在启动应用程序前执行此方法。大多数文件夹类型都支持延迟标志，其默认值为 false。要将延迟文件夹创建功能设置为 true，可以添加此标志：# only create this folder when tk.create_filesystem_structure is# called with tk-maya, tk-nuke or any-custom-string.defer_creation: [&quot;tk-maya&quot;, &quot;tk-nuke&quot;, &quot;any-custom-string]# create this folder when any application launches, but not when normal folder# creation runsdefer_creation: true使用此标志可将文件夹创建过程一分为二：一次在第一个“全局”阶段进行，另一次在稍后的时间点进行。通常，第二次创建与插件的启动相关（但是因为默认值为 false，所以不会自动进行），并允许用户在插件启动前才创建文件夹。这可以实现两种主要的工作流：  工作空间：这是特定于应用程序的文件夹设置。可以在应用程序启动之前创建文件夹。  这种工作流的一个常见例子是：某个工作流工序可能会根据镜头的需要和艺术家选择的工作方式，决定需要使用 Houdini、Maya 还是其他插件。艺术家可以一开始就为工作流工序创建 maya/、houdini/ 和其他目录，但如果负责给定镜头的艺术家只在 Maya 中工作，那么就没必要为 Houdini 和其他任何插件创建空文件夹。因此，如果您将文件夹创建任务延迟到各个插件启动时再进行，那么如果艺术家从不使用 Houdini，将不会为该镜头创建 houdini/ 文件夹。  用户文件夹：用户文件夹是在应用程序启动前才创建的。默认情况下，用户文件夹配置的结构（如上所述）将延迟创建。  发生这种情况时，您可以不基于 ShotGrid 中指定的用户来创建用户文件夹，而是在用户启动插件时才为当前用户创建文件夹。例如，当您开始处理镜头并启动 Maya 时，会为您创建一个用户名文件夹（基于您在 ShotGrid 中的用户名），让您与其他人的工作不会互相干扰。提示：如果您更喜欢应用程序（例如 Maya）启动时创建普通的静态文件夹，只需创建一个与文件夹同名的 YAML 配置文件，并添加以下内容即可：# type of contenttype: &quot;static&quot;# only create this folder for mayadefer_creation: &quot;tk-maya&quot;# type of contenttype: &quot;static&quot;# only create this folder when tk.create_filesystem_structure is# called with any-custom-string.defer_creation: &quot;any-custom-string&quot; 当前用户文件夹当前用户文件夹是一种特殊构造，通过它可为不同用户设置工作区。例如，我们经常会遇到一个部门的多位艺术家共同处理同一个镜头的情况。可以使用用户文件夹，这样艺术家可以将其工作文件存储在自己的目录中，并且能够在 Workfiles 应用中过滤出他们的文件。这种情况下，配置文件需要包含以下选项：# the type of dynamic contenttype: &quot;user_workspace&quot;name: &quot;login&quot;  将 type 字段的值设置为 user_workspace。  name 字段是应指定给用户文件夹的名称。此名称必须包含从 ShotGrid 人员（ShotGrid 中的 HumanUser）那里提取的字段组合。  您可以像上面的示例中那样，只使用一个字段（例如 name: login）。  您可以在花括号中使用多个字段（例如 name: &quot;{firstname}_{lastname}&quot;）。  如果想包含来自其他链接实体的字段，可使用标准 ShotGrid 语法（例如 name: &quot;{sg_group.Group.code}_{login}&quot;）。默认情况下，当前用户文件夹将创建为延迟文件夹，这意味着，只有在通过 Toolkit API 的创建文件夹方法中的可选 engine 参数再次请求文件夹创建过程时，才会创建该文件夹。静态文件夹静态文件夹（和文件）是最简单的类型。您可以将它们放入配置结构，当执行文件夹创建过程时，会自动复制它们。以下是默认配置中的静态文件夹 (https://github.com/shotgunsoftware/tk-config-default/tree/master/core/schema/project) 的一些示例（请注意，静态文件夹没有相应的 YAML 文件）。通常，静态文件夹的使用不会超出这些示例介绍的范围；但是，Toolkit 确实支持一些更高级的静态文件夹功能。我们可以定义动态条件来决定是否应创建某个静态文件夹。例如，您可能会需要只有剪辑类型的工作流工序才会创建的特殊静态文件夹。在这种情况下，需要在静态文件夹的同一层添加一个 YAML 配置文件，并为它指定相同的名称，文件扩展名为“yml”。然后，使用以下语法：# the type of dynamic contenttype: &quot;static&quot;# pick one of the ShotGrid folders that are above this folder# in the folder hierarchy. In this case it is a parent folder# named step that we want to look at when deciding if this# static folder should be created or not.constrain_by_entity: &quot;$step&quot;# we can now define constraints for this step. Constraints are simple# ShotGrid queries, following the same syntax as the other ShotGrid filters# shown in previous sections.# In our example, if the parent step matches the constraints given# in the filter below, the static folder will be created. If not,# it (and its children) will be ignored by the folder creation process.constraints:    - { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;edit&quot; ] } 默认情况下，静态文件夹会自动随其父文件夹一起创建。但有些时候，我们并不希望如此。这种情况下，可以添加一个特殊标志，指示静态文件夹不要随其父文件夹一起创建。# do not recurse down automaticallycreate_with_parent: false符号链接您可以在创建动态文件夹的过程中创建符号链接。如果要创建名为 artwork 的符号链接，请在数据结构配置中创建一个名为 artwork.symlink.yml 的文件。此文件将被系统识别为符号链接请求，系统将不会复制它，而是会处理它。artwork.symlink.yml 文件必须至少包含一个 target 键：# Example of a .symlink.yml file# A target parameter is required.target: &quot;../Stuff/$Project/$Shot&quot;# Additional parameters will be passed to the hook as metadata# so you can for example include permission hints or other stuff# that you may need for advanced customizationadditional_param1: abcadditional_param2: def 如果 target 参数包含 $EntityType 标记，如 $Asset、$Shot 或 $Project，系统将尝试以代表该实体（资产、镜头、项目等）的文件夹的名称来解析这些标记。Toolkit 将在 Shotgun 管理的文件系统树中查找这些值，如果树的上层未定义这些值，将报告错误。列表字段（如资产的资产类型）采用包含实体类型的某种语法进行表示，例如 $Asset.sg_asset_type。例如：# Example of a .symlink.yml file# A target parameter is required.target: &quot;../renders/$Project/$Asset.sg_asset_type/$Asset&quot;符号链接的创建操作（与所有输入/输出或 I/O 一样）在文件夹处理挂钩内进行。一个特殊的 symlink 动作会从系统传递到挂钩，您会获得符号链接的名称、完全解析的目标、定义文件内包含的所有 YAML 元数据以及此请求。对于上面的 artwork 示例，我们在 Shot 下创建文件夹，如下所示： {'action': 'symlink',  'path': '/mnt/projects/chasing_the_light/Sequences/AA/AA001/artwork'  'target': '../Stuff/chasing_the_light/AA001',  'metadata': {'target': '../Stuff/$Project/$Shot', 'additional_param1': 'abc', 'additional_param2': 'def'}  }忽略文件和文件夹在创建文件夹的过程中，会将位于数据结构脚手架内的文件复制到目标区域。此复制过程由一个核心挂钩来处理，例如，可以为项目或工作室自定义权限处理。                    注意: 有关这种处理的更多详细信息，请参见“简单自定义”下的“自定义 I/O 和权限”部分“自定义 I/O 和权限”部分。我们有一个 process_folder_creation 核心挂钩 (https://github.com/shotgunsoftware/tk-core/blob/master/hooks/process_folder_creation.py#L62-L71)，用于处理大量文件夹设置。您可以向此挂钩中添加 chmod 调用（并且/或者在执行 mkdir 时设置权限），通过这种方法为创建的文件夹设置权限。    在文件夹创建过程中，有时将某些文件和文件夹排除在复制内容之外可能会有所帮助。例如，如果您将文件夹创建配置存储在 Git 或 SVN 中，则会拥有 .git 和 .svn 文件夹，您不想将其复制到每个 Shot 文件夹或 Asset 文件夹中。如果有些文件是您不想复制的，您可以在项目配置内的 config/core/schema 文件夹中放置一个名为 ignore_files 的文件。这个文件应包含 glob 样式的模式，用以定义不复制的文件。每个模式应单独一行：# This is a good example of a standard ignore_files file.svn                # no svn temp files to be copied across at folder creation time.git                # no git temp files to be copied across at folder creation time.DS_Store           # no mac temp files to be copied across at folder creation time您也可以使用通配符。例如，如果需要排除所有带 TMP 扩展名的文件，只需向文件中添加一行 *.tmp 即可。# This is a good example of a standard ignore_files file.svn                # no svn temp files to be copied across at folder creation time.git                # no git temp files to be copied across at folder creation time*.tmp           # no files with tmp extension to be copied across at folder creation time自定义 IO 和权限镜头文件夹和资产文件夹在创建时通常需要带有特殊的权限和参数。简单的时候，只需在创建文件夹过程中设置权限位即可；复杂的时候，则需要向专门的文件夹创建服务器发送远程请求，由服务器创建具有适当凭据、组和权限的文件夹。另外，文件系统中不同层级的文件夹常常也需要不同的权限；工作区文件夹通常对所有人都是可写的，而镜头文件夹的权限则可能严格得多。在 Toolkit 中，我们只通过一个挂钩，便可对文件夹的创建进行自定义。这个挂钩叫做 process_folder_creation.py，是一个核心挂钩。在创建文件夹的 API 调用遍历文件夹配置并决定应创建哪些文件夹的过程中，它会建立一个可创建项的列表。这些列表项既可以是文件，也可以是文件夹。作为文件夹创建的最后一步，此列表将传递到挂钩以处理实际的文件夹处理。您可以在此处检查默认的 process_folder_creation 核心挂钩 (https://github.com/shotgunsoftware/tk-core/blob/master/hooks/process_folder_creation.py#L62-L71)。传递给挂钩的数据文件夹创建挂钩仅为每个文件夹创建请求执行一次。所有文件夹创建数据将放在列表中传递给挂钩，挂钩通常会轮询这个列表，并根据核心 API 传递的参数创建文件夹。列表中的数据始终是深度优先的递归，从顶层文件夹和文件开始，然后遍历更深的层。下面这个示例显示了传递给挂钩的数据的形式：    [         {'action': 'entity_folder',      'entity': {'id': 88, 'name': 'Chasing the Light', 'type': 'Project'},      'metadata': {'root_name': 'primary', 'type': 'project'},      'path': '/mnt/projects/chasing_the_light'},         {'action': 'folder',      'metadata': {'type': 'static'},      'path': '/mnt/projects/chasing_the_light/sequences'},         {'action': 'entity_folder',      'entity': {'id': 32, 'name': 'aa2', 'type': 'Sequence'},      'metadata': {'entity_type': 'Sequence',                   'filters': [{'path': 'project',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04c90&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'path': '/mnt/projects/chasing_the_light/sequences/aa2'},         {'action': 'entity_folder',      'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'},         {'action': 'copy',      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'source_path': '/mnt/software/tank/chasing_the_light/config/core/schema/project/sequences/sequence/shot/sgtk_overrides.yml',      'target_path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87/sgtk_overrides.yml'},         {'action': 'create_file',      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'content': 'foo bar',      'target_path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87/automatic_content.txt'},         {'action': 'symlink',      'path': '/mnt/projects/chasing_the_light/Sequences/AA/AA001/artwork'      'target': '../Stuff/chasing_the_light/AA001',      'metadata': {'target': '../Stuff/$Project/$Shot', 'additional_param1': 'abc', 'additional_param2': 'def'}      },        ]这些数据是一个词典列表。每个词典有一个称为 action 的键。这个键表示请求的 I/O 项的类型。如果您要执行文件夹创建挂钩，需要添加对以下不同动作的支持：  entity_folder：磁盘上与 ShotGrid 实体关联的文件夹。  folder：磁盘上的文件夹。  copy：需要从源位置复制到目标位置的文件。  create_file：需要在磁盘上创建的文件。  symlink：应创建的符号链接。每个动作各有一套不同的词典键。例如，entity_folder 动作有一个 entity key，其中包含它所连接的实体的详细信息。create_file 有一个 source_path 和一个 target_path 键，用来指示挂钩要复制哪个文件，以及要复制到何处。所有的 actions 还有一个名为 metadata 的键。此键表示数据结构设置中关联的配置文件的 YAML 配置数据。在上面的示例中，可以看到 ShotGrid 文件夹的 metadata 键怎样包含数据结构配置内设置的所有过滤器和命名信息。例如，以下是上面示例中镜头文件夹的元数据：    {'action': 'entity_folder',      'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'} …它对应于 shot.yml 数据结构配置文件：# Copyright (c) 2013 ShotGrid Software Inc.## CONFIDENTIAL AND PROPRIETARY## This work is provided &quot;AS IS&quot; and subject to the ShotGrid Pipeline Toolkit# Source Code License included in this distribution package. See LICENSE.# By accessing, using, copying or modifying this work you indicate your# agreement to the ShotGrid Pipeline Toolkit Source Code License. All rights# not expressly granted therein are reserved by ShotGrid Software Inc.# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the ShotGrid field to use for the folder namename: &quot;code&quot;# the ShotGrid entity type to connect toentity_type: &quot;Shot&quot;# ShotGrid filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std ShotGrid API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ] 请注意，动态代币 $sequence 在运行时已解析为实际对象。向挂钩传递您自己的文件夹创建指令除了 Toolkit 要求的各种配置指令，您还可以在数据结构配置中定义自己的配置项。它们将通过上面介绍的 metadata 键传递给挂钩，并可以用来驱动文件夹创建过程。例如，如果您的数据结构设置中有以下结构：# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the ShotGrid field to use for the folder namename: &quot;code&quot;# the ShotGrid entity type to connect toentity_type: &quot;Shot&quot;# ShotGrid filters to apply when getting the list of itemsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ]# user settingsstudio_permissions_level: &quot;admin&quot; …通过文件夹创建挂钩传递的数据将为：    {'action': 'entity_folder',      'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity',                   'studio_permissions_level': 'admin'},      'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'} 这时，特殊参数 studio_permissions_level 将传递给挂钩，您可以使用它来控制文件权限。您还可以使用这种方法传递任意复杂度的数据结构。此方法的一个典型用途是对权限进行非常精细的控制。向静态文件夹添加自定义配置通常，当您在文件夹数据结构配置内创建文件夹时，如果该文件夹没有对应的 YAML 文件，Toolkit 会认为它是静态文件夹，并直接创建它。如果您想为静态文件夹关联自定义的配置元数据，需要创建一个 static 类型的 YAML 配置文件。例如，假设您在项目根目录下有一个 assets 静态文件夹，现在想将各种资产合为成组，并添加自定义配置元数据。要实现这一点，需要创建以下 assets.yml 文件：type: staticstudio_permissions_level: &quot;admin&quot;传递给挂钩的配置数据随后将包含以下内容：{'action': 'folder', 'metadata': {'studio_permissions_level': 'admin', 'type': 'static'}, 'path': '/mnt/projects/chasing_the_light/assets'},同样，可以用这种方式将任意复杂度的数据从 YAML 配置文件传递给挂钩。文件夹创建方式的简单自定义下面是一个简单的文件夹创建挂钩：    class ProcessFolderCreation(Hook):            def execute(self, items, preview_mode, **kwargs):            &quot;&quot;&quot;     The default implementation creates folders recursively using open permissions.         This hook should return a list of created items.         Items is a list of dictionaries. Each dictionary can be of the following type:         Standard Folder     ---------------     This represents a standard folder in the file system which is not associated     with anything in ShotGrid. It contains the following keys:         * &quot;action&quot;: &quot;folder&quot;     * &quot;metadata&quot;: The configuration yaml data for this item     * &quot;path&quot;: path on disk to the item         Entity Folder     -------------     This represents a folder in the file system which is associated with a     ShotGrid entity. It contains the following keys:         * &quot;action&quot;: &quot;entity_folder&quot;     * &quot;metadata&quot;: The configuration yaml data for this item     * &quot;path&quot;: path on disk to the item     * &quot;entity&quot;: ShotGrid entity link dict with keys type, id and name.         File Copy     ---------     This represents a file copy operation which should be carried out.     It contains the following keys:         * &quot;action&quot;: &quot;copy&quot;     * &quot;metadata&quot;: The configuration yaml data associated with the directory level     on which this object exists.     * &quot;source_path&quot;: location of the file that should be copied     * &quot;target_path&quot;: target location to where the file should be copied.         File Creation     -------------     This is similar to the file copy, but instead of a source path, a chunk     of data is specified. It contains the following keys:         * &quot;action&quot;: &quot;create_file&quot;     * &quot;metadata&quot;: The configuration yaml data associated with the directory level     on which this object exists.     * &quot;content&quot;: file content     * &quot;target_path&quot;: target location to where the file should be copied.         &quot;&quot;&quot;                # set the umask so that we get true permissions            old_umask = os.umask(0)            folders = []            try:                    # loop through our list of items                for i in items:                        action = i.get(&quot;action&quot;)                        if action == &quot;entity_folder&quot; or action == &quot;folder&quot;:                        # folder creation                        path = i.get(&quot;path&quot;)                        if not os.path.exists(path):                            if not preview_mode:                                # create the folder using open permissions                                os.makedirs(path, 0777)                            folders.append(path)                        elif action == &quot;copy&quot;:                        # a file copy                        source_path = i.get(&quot;source_path&quot;)                        target_path = i.get(&quot;target_path&quot;)                        if not os.path.exists(target_path):                            if not preview_mode:                                # do a standard file copy                                shutil.copy(source_path, target_path)                                # set permissions to open                                os.chmod(target_path, 0666)                            folders.append(target_path)                        elif action == &quot;create_file&quot;:                        # create a new file based on content                        path = i.get(&quot;path&quot;)                        parent_folder = os.path.dirname(path)                        content = i.get(&quot;content&quot;)                        if not os.path.exists(parent_folder) and not preview_mode:                            os.makedirs(parent_folder, 0777)                        if not os.path.exists(path):                            if not preview_mode:                                # create the file                                fp = open(path, &quot;wb&quot;)                                fp.write(content)                                fp.close()                                # and set permissions to open                                os.chmod(path, 0666)                            folders.append(path)                        else:                        raise Exception(&quot;Unknown folder hook action '%s'&quot; % action)                finally:                # reset umask                os.umask(old_umask)                return folders 第 2 部分 - 配置文件系统模板Toolkit 模板文件是 Toolkit 配置的一个中枢。每个项目总是有一个这样的文件，它位于您的工作流配置的 config/core 文件夹内。此文件包含 模板 及其 键 的定义。键是我们定义的动态字段。它可以是名称、版本号、屏幕分辨率、镜头名称等。我们会为键配置类型，这样便可定义一个键应该是字符串还是整数。键还具有格式，这样便可定义一个字符串应仅包含字母数字字符，还是所有整数都填充八个零。模板是一个动态路径。例如，shots/{shot}/publish/{name}.{version}.ma 就是一个模板。这个模板可表示镜头的 Maya 发布内容 - 括号内的字段就是键。模板文件分为三个部分：键、路径和字符串。键部分键定义了字段可以接受什么值。在模板配置文件中，键定义的格式为：key_name:   type: key_type   option: option_value   option: option_value 键的类型可以是 str、int 或 sequence。Str 键是值为字符串的键，int 键是值为整数的键，sequence 键是值为整数序列的键。除了指定类型以外，您还可以指定其他选项。存在以下选项：      default: default_value - 在未提供值的情况下使用的值。例如，当您使用 Toolkit API 尝试将一组字段值解析为一个路径时，可能会发生这种情况。        choices: [choice1, choice2, etc] - 对此键的各个可能值的枚举。        exclusions: [bad1, bad2, etc] - 对此键的各个禁止值的枚举。如果键的类型为 sequence，使用此设置时，将无法让帧规格值无效。        length: 12 - 此键需要有具体长度。        alias: new_name - 提供一个供使用此键而非 key_name 键的模板使用的名称。例如，如果您有两种关于版本号的设想，一种是按照客户的希望填充四个零，另一种是根据内部处理方式填充三个零 - 在这种情况下，您其实想将两个键都命名为“version”，但实际上这是不可能的，因为键名称需要具有唯一性。这时，您可以创建一个别名。请参见下面的示例了解详细信息。        filter_by: alphanumeric - 仅适用于 string 类型的键。如果指定了此选项，只有包含字母数字值（对于 Ascii 字符串来说通常为 a-z、A-Z 和 0-9，但如果输入数据为 Unicode，也可能包含其他字符）的字符串才会被视为有效值。        filter_by: alpha - 仅适用于 string 类型的键。如果指定了此选项，只有包含字母值（对于 Ascii 字符串来说通常为 a-z 和 A-Z，但如果输入数据为 Unicode，也可能包含其他字符）的字符串才会被视为有效值。        filter_by: '^[0-9]{4}_[a-z]{3}$' - 仅适用于 string 类型的键。您可以定义正则表达式来作为验证掩码。例如，上面的示例需要键有四位数字，后跟一个下划线，最后是三个小写字母。        format_spec: &quot;04&quot; - 对于 int 和 sequence 类型的键，此设置意味着 int 或 sequence 的数字将填充零或空格。像示例中这样指定“04”，将得到一个长度为四位数、填充了零的数字（例如 0003）。指定“03”将得到长度为三位数、填充了零的数字（例如 042），等等。指定“3”将得到长度为三位数、填充了空格的数字（例如“  3”）。对于时间戳类型的键，format_spec 遵循 strftime 和 strptime 约定。        strict_matching: true - 仅适用于 int 类型的键。此设置意味着字段只会匹配格式设置正确的数字。例如，给定值为“003”，strict_matching 设置为 True，我们将匹配“002”、“12345”和“042”，但不匹配“00003”或“2”。如果您需要匹配不那么严格，请将 strict_matching 设置为 False。默认行为是严格匹配。        shotgun_entity_type - 与 shotgun_field_name 选项一起使用时，上下文将直接向 ShotGrid 查询值。这样，将可以在文件名中使用文件夹结构中不可见的字段的值。        shotgun_field_name - 仅与 shotgun_entity_type 一起使用。        abstract - 表示字段是抽象字段。当需要以模式来描述路径时（例如图像序列 (%04d) 或立体声 (%V)），会用到抽象字段。抽象字段需要具有默认值。        subset 和 subset_format - 提取给定输入字符串的一部分并将它设为键值。这样，便可根据完整的用户名创建用户名首字母缩写键，或创建可容纳每个镜头名称前三个字母的键。  有关模板键的技术详细信息，请参见 API 参考。示例 - 字母数字名称一个默认为“comp”的字母数字名称：name:    type: str    default: &quot;comp&quot;    filter_by: alphanumericnuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{name}.v{version}.nk 示例 - 版本号一个将会匹配 002、102、034、12341 这类数字的版本号version:    type: int    format_spec: &quot;03&quot; 一个将会匹配 002、102、034、12341，但同时也能匹配 0002、 2 和 0102 这类数字的版本号version:    type: int    format_spec: &quot;03&quot;    strict_matching: false 示例 - 立体视点一个典型的立体视点设置。视野为 L 或 R，但在软件中使用时，它通常以通用、抽象的方式被称为 %V。由于 %V 实际上并不是指文件名，而是指文件的集合，因此我们设置了 abstract 标志。抽象字段需要有默认值，这个默认值将在用户请求抽象表示时导入。eye:    type: str    choices: [&quot;L&quot;, &quot;R&quot;, &quot;%V&quot;]    default: &quot;%V&quot;    abstract: truenuke_shot_render_stereo: sequences/{Sequence}/{Shot}/{Step}/work/images/{Shot}_{name}_{eye}_v{version}.{SEQ}.exr示例 - 图像序列图像序列从定义上讲是抽象的，因此除非另有指定，否则它们将有一个设为 %0Xd 的默认值。下面的序列规格将指明帧编号，如 0001、1234 和 12345。SEQ:    type: sequence    format_spec: &quot;04&quot;nuke_shot_render_stereo: sequences/{Sequence}/{Shot}/{Step}/work/images/{Shot}_{name}_{channel}_{eye}_v{version}.{SEQ}.exr 示例 - 两个字段通过别名同时命名为 version两个版本号定义可同时供需要“version”键的代码使用。如果您有两个 Toolkit 应用都需要 version 字段，但您希望这两个 version 字段采用不同的格式，那么这个技巧很有帮助。nuke_version:    type: int    format_spec: &quot;03&quot;    alias: versionmaya_version:    type: int    format_spec: &quot;04&quot;    alias: version# nuke versions are using numbers on the form 003, 004, 005# the nuke publish app requires a field called {version}# however {nuke_version} is a valid replacement for {version}# because it has an alias definednuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{name}.v{nuke_version}.nk# maya versions are using numbers on the form 0004, 0005, 0006maya_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{maya_version}.ma 示例 - 时间戳一个默认为当前当地时间、格式为 YYYY-MM-DD-HH-MM-SS 的时间戳。now:    type: timestamp    format_spec: &quot;%Y-%m-%d-%H-%M-%S&quot;    default: now 一个默认为当前 UTC 时间、格式为 YYYY.MM.DD 的时间戳。year_month_day:    type: timestamp    format_spec: &quot;%Y.%m.%d&quot;    default: utc_now 一个默认为 9:00:00、格式为 HH-MM-SS 的时间戳。nine_am_time:    type: timestamp    format_spec: &quot;%H-%M-%S&quot;    default: &quot;09-00-00&quot; 示例 - 映射当您想在文件名中添加 ShotGrid 字段时，此技巧非常有用。假设我们想在一个文件名中包含用户名 - 我们要使用以下定义：current_user_name:    type: str    shotgun_entity_type: HumanUser    shotgun_field_name: loginnuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{current_user_name}_{name}.v{version}.nkToolkit 应用在填充所有上下文字段时（通过 context.as_template_fields() 方法），会自动填充较高一级的 Shot、Sequence 和 Step 字段。另外，它还会扫描所有定义了 shotgun_entity_type 的字段（比如我们上面的 current_user_name 字段）。如果上下文中定义了 ShotGrid 实体，它将能够自动解析该值。当前用户始终记录在上下文中，并且在上面的示例中，我们还可以从“镜头”(Shot)、“镜头序列”(Sequence)和“工序”(Step)字段提取数据，因为它们被定义为较高一级路径的一部分，因此也属于上下文的一部分。但是，在上面的示例中，尝试在字段中引用资产实体将不起作用，因为 Toolkit 没办法知道要从 ShotGrid 中的哪个资产中提取数据。示例 - 具有两个有效值的字符串字段很多时候，工作室会有项目需要向外保存 ASCII 和二进制 Maya 文件。在这种情况下，一个具有两个有效值的字符串值将如下所示：maya_file_extension:    type: str    choices: [&quot;ma&quot;, &quot;mb&quot;]                     注意: 默认应用会根据 templates.yml 中的配置来决定使用 .ma 还是 .mb。因此，假如您想在某个项目中让 Workfiles 应用改为保存 .mb 而不是 .ma，可以更改以下三个模板（针对镜头）：    maya_shot_work:  '@shot_root/work/maya/{name}.v{version}.ma'maya_shot_snapshot:  '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'maya_shot_publish:  '@shot_root/publish/maya/{name}.v{version}.ma'如果您改为以 .mb 结尾，则应用将另存为 Maya 二进制文件：maya_shot_work:  '@shot_root/work/maya/{name}.v{version}.mb'maya_shot_snapshot:  '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.mb'maya_shot_publish:  '@shot_root/publish/maya/{name}.v{version}.mb' 有关更多详细信息，请查看下面的路径部分。示例 - 禁止使用某个值一个不允许使用“assets”值的字符串字段。当您有一个包含项目所有镜头序列的文件夹，另外还有一个存储着所有资产的“assets”文件夹时，此技巧会比较有用：project |--- sequence1 |--- sequence2 |--- sequence3  --- assets 为了让 Toolkit 正确理解 assets 文件夹不是又一个序列，我们可以定义“assets”不是镜头序列模板的一个有效值。sequence:    type: str    exclusions: [&quot;assets&quot;] 利用上面的 exclusions 字段，可以定义两个都能够正确解析的模板：sequence_work_area: {sequence}/{shot}/workasset_work_area: assets/{asset}/work 示例 - 字符串子集下面的示例扩展了前面的一个示例，说明了如何为文件名添加用户名首字母缩写前缀。user_initials:    type: str    shotgun_entity_type: HumanUser    shotgun_field_name: login    subset: '([A-Z])[a-z]*  ([A-Z])[a-z]*'    subset_format: '{0}{1}'nuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{user_initials}_{name}.v{version}.nk 路径部分路径部分指定工作的保存位置。所有路径都至少包含一个名称和一个定义，其中的定义是一组位于花括号中的键名称夹杂着代表路径的非键值。例如，镜头工作文件的定义可能会如下所示：shot_work: sequences/{Sequence}/{Shot}/{Step}/work/{Shot}.v{version}.ma 其中 Sequence、Shot、Step 和 version 是同一模板文件中定义的键。                    注意: 如果一个 string 键的名称与一个关联了 ShotGrid 实体的动态数据结构文件夹的实体类型一致，将使用该文件夹名称来代替令牌。例如，假设您像上面的代码段那样正在使用一个“string”类型的 {Sequence} 模板键，并且在您的数据结构中有一个名为“sequence”的动态文件夹，但在对应的 sequence.yml 文件中，它被定义为 shotgun_entity 类型，并且连接到 ShotGrid 中的“场”(Sequence)实体类型。这种情况下，Toolkit 会认为您的模板键对应于这个动态文件夹的实体类型（示例中二者均为“场”(Sequence)）。因此，Toolkit 会提取生成的文件夹名称（即所涉及的具体镜头序列的名称），并使用它替换模板键。    如果需要定义任何可选属性，必须使用这种格式。目前，只有 root_name 这一个可选属性，在有多个根目录的项目中，可以用它来指定路径的项目根目录。当您想添加新的存储根目录来存储某些项目文件时，会用到多个根目录。root_name: name_of_project_root例如，它可能如下所示：shot_work:  definition: sequences/{Sequence}/{Shot}/{Step}/work/{Shot}.v{version}.ma  root_name: primary 如果您想使用除主根目录以外的其他存储根目录，就需要使用上面的格式。在本示例中，使用这种简单的格式意味着所有条目都使用主根目录。字符串部分字符串与路径有相似之处，那就是它们也必须包含名称和定义，并且这些内容可以采取简单格式：string_name: string_definition字符串定义是由键名称和其他值构成的模板，这些名称和值一起解析成一个字符串，而不是一个文件系统路径。ShotGrid 中的发布所使用的名称就是一个例子：maya_publish_sg_name: &quot;Maya  publish,  {name},  v{version}&quot;其中 name 和 version 是同一文件中定义的键名称。在模板中使用可选的键出于一些原因，在模板中使用可选键有时会很有帮助。一个常见的例子是将 {SEQ} 设为渲染图像的可选键。在本示例中，可以有一系列包含帧编号的 exr，比如 /path/to/render/shot.101.exr（以及 102、103 等），同时您也能够为 QuickTime 影片使用相同的模板，比如 /path/to/render/shot.qt。另一个更常见的例子是渲染立体图像。如果您所在的工作室这样约定：left eye: file.LFT.exr, right eye: file.RGT.exr, stereo image: file.exr?，您可以将 {eye} 设为可选键。我们可以使用方括号来定义可选部分：shot_work: sequences/{Shot}/work/{Shot}.[v{version}.]ma 可选部分必须至少包含一个键。如果路径解析时没有某个可选部分所含键的值，路径将直接解析，就好像该部分在定义中不存在一样。我们可以将上面的示例看成是两个模板合成为一个定义：shot_work: sequences/{Shot}/work/{Shot}.v{version}.mashot_work: sequences/{Shot}/work/{Shot}.ma 当您传入一个字段词典时，Toolkit 会根据值来选择正确版本的模板：&amp;gt;&amp;gt;&amp;gt; template = tk.templates[&quot;shot_work&quot;]&amp;gt;&amp;gt;&amp;gt; template.apply_fields({&quot;Shot&quot;:&quot;ABC_123&quot;, &quot;version&quot;: 12}/project/sequences/ABC_123/work/ABC_123.v12.ma&amp;gt;&amp;gt;&amp;gt; template.apply_fields({&quot;Shot&quot;:&quot;ABC_123&quot;}/project/sequences/ABC_123/work/ABC_123.ma 高级问题和疑难解答如何向文件结构中添加新的实体类型？我们假设您之前一直在 ShotGrid 站点上制作专题动画和短片，而现在您接到了剧集工作。下面我们就来一起了解如何向 Toolkit 加入剧集工作流。首先，按照此处的说明在 ShotGrid 中为剧集工作设置层次结构。                    注意: 请参见上面的“随父文件夹一起创建”部分，回顾 Toolkit 中的嵌套关系（它完全独立于 ShotGrid 中的项目层次结构）。    其他参考：  “剧集”(Episode)实体如何工作？  自定义实体的层次结构“剧集 &amp;gt; 场 &amp;gt; 镜头”(Episode &amp;gt; Sequence &amp;gt; Shot)层次结构需要的字段您可以选择为 Episode 使用任何自定义实体（“站点偏好设置 &amp;gt; 实体”(Site Preferences &amp;gt; Entities)），也可以使用 ShotGrid 7.0.7.0 中提供的官方“剧集”(Episode)实体。如果您注册使用的是 ShotGrid 7.0.7.0 之前的版本（在 2017 年之前），“TV Show”模板会使用 CustomEntity02 作为剧集。如果您决定使用 CustomEntity02 或官方“剧集”(Episode)实体之外的其他实体，没问题，ShotGrid 和 Toolkit 很灵活。下面我们就来介绍这两种情况。就本练习而言，我们将使用“剧集”(Episode)(CustomEntity02) 和官方“剧集”(Episode)实体为例，讲解如何在项目层次结构更新中整合剧集（可以任选其一）。首先，要正确设置项目的剧集 &amp;gt; 场 &amp;gt; 镜头层次结构，需要确保 ShotGrid 中存在以下字段：剧集a) 使用官方“剧集”(Episode)实体：“剧集”(Episode)实体可以是从项目模板创建电视节目类项目时使用的实体。或者b) 使用自定义实体：CustomEntity02 可以是从项目模板创建电视节目类项目时使用的自定义实体。如前所述，您可以再启用一个自定义实体，使用它而不是 CustomEntity02 - 只需确保将所有 CustomEntity02 替换为已启用的具体实体即可。场需要一个名为“剧集”(Episode) (sg_episode) 的实体链接，它将链接到“剧集”(Episode)实体。使用官方 Episode 实体使用 CustomEntity02镜头一个称为“镜头序列”(Sequence)的实体字段 (sg_sequence)，它将链接到“镜头序列”(Sequence)实体。ShotGrid 的“TV Show”项目模板中应该已存在这个字段。使用官方 Episode 实体使用 CustomEntity02Toolkit 数据结构定义我们假设有一个如下所示的层次结构（{} 中的文件夹将根据它们在 ShotGrid 中的名称动态地进行命名）：- {project_name} - shots episode.yml - {episode_name} sequence.yml - {sequence_name} shot.yml - {shot_name} ... …剧集在您的 config/core/schema/project/shots 文件夹中，创建一个名为 episode 的文件夹，并在同一目录创建一个对应的 episode.yml 文件，文件内容如下：使用官方 Episode 实体# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the ShotGrid field to use for the folder namename: &quot;code&quot;# the ShotGrid entity type to connect toentity_type: &quot;Episode&quot;# ShotGrid filters to apply when getting the list of items# this should be a list of dicts, each dict containing # three fields: path, relation and values# (this is std ShotGrid API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]使用 CustomEntity02# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the ShotGrid field to use for the folder namename: &quot;code&quot;# the ShotGrid entity type to connect toentity_type: &quot;CustomEntity02&quot;# ShotGrid filters to apply when getting the list of items# this should be a list of dicts, each dict containing # three fields: path, relation and values# (this is std ShotGrid API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ] 这将指示 Toolkit 为此项目中的每一剧集创建文件夹。镜头序列在您的 config/core/schema/project/shots/episode 文件夹中，创建一个名为 sequence 的文件夹，并在同一目录创建一个对应的 sequence.yml 文件，文件内容如下：# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the ShotGrid field to use for the folder namename: &quot;code&quot;# the ShotGrid entity type to connect toentity_type: &quot;Sequence&quot;# ShotGrid filters to apply when getting the list of items# this should be a list of dicts, each dict containing # three fields: path, relation and values# (this is std ShotGrid API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_episode&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$episode&quot; ] } ]` 这将指示 Toolkit 为链接到目录树中上层剧集的每个镜头序列创建文件夹。镜头在您的 config/core/schema/project/shots/episode/sequence 文件夹中，创建一个名为 shot 的文件夹，并在同一目录创建一个对应的 shot.yml 文件，文件内容如下：# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the ShotGrid field to use for the folder namename: &quot;code&quot;# the ShotGrid entity type to connect toentity_type: &quot;Shot&quot;# ShotGrid filters to apply when getting the list of items# this should be a list of dicts, each dict containing # three fields: path, relation and values# (this is std ShotGrid API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ]` 这将指示 Toolkit 为链接到目录树中上层镜头序列的每个镜头创建文件夹。完成此操作后，您的数据结构应该如下所示：Toolkit 模板定义为了告诉 Toolkit 您要在数据结构中使用剧集，您需要在顶部的键部分中创建一个新键来定义它：使用官方 Episode 实体keys:    ...    Episode:        type: str    ... 然后，在下面的模板路径中，通过在正确位置插入 {Episode} 以在目录结构中指定剧集，来更新 shot_root 模板以及镜头层次结构中的其他任何模板路径，使它们与您的剧集层次结构一致：...    paths:        shot_root: shots/{Episode}/{Sequence}/{Shot}/{Step}        … 使用 CustomEntity02keys:    ...    CustomEntity02:        type: str    ...然后，在下面的模板路径中，通过在正确位置插入 {CustomEntity02} 以在目录结构中指定剧集，来更新 shot_root 模板以及镜头层次结构中的其他任何模板路径，使它们与您的剧集层次结构一致：...    paths:        shot_root: shots/{CustomEntity02}/{Sequence}/{Shot}/{Step}        … 这就是基本的“剧集 &amp;gt; 场 &amp;gt; 镜头”(Episode &amp;gt; Sequence &amp;gt; Shot)工作流所需要的一切！如何在结构中设置分支？这与不同工作流工序的不同文件系统布局相关，更具体地说，如果您希望向结构中添加分支，就会遇到此问题。例如，您可以为“工作流工序 A”设置一个结构，为其他所有工作流工序设置另一个结构。假设您要将另一种资产类型添加到工作流中，并且新的“资产类型”(Asset Type)是“车辆”(Vehicle)。您需要更改 Vehicles 的文件结构，为不同的工作流工序设置不同的文件夹（例如“geoprep”和“lookdev”），而每个工作流工序文件夹内还有其他文件夹。在进行此项更新的同时，创建资产的方式目前应保持不变。下面我们来一起了解如何更新您的工作流以适应此新流。第 1 步：修改数据结构首先，修改您的数据结构，以反映您的文件夹结构加入新的资产类型后的样子。  先在数据结构中为这个新的资产类型创建一个新的分支：vehicle。  在与 asset/ 和 asset.yml 同一级目录中，添加一个 asset_vehicle/ 文件夹和一个 asset_vehicle.yml。  这些 YAML 文件中还有一项过滤器设置。修改 asset.yml 中的过滤器，让它应用于 除 车辆以外的所有资产，然后修改 asset_vehicle.yml 使其 仅 应用于车辆类型的资产。下面是这些过滤器的一个示例。      现在，您已有了两个文件夹来表示 asset 和 asset_vehicles，在 asset_vehicle 下添加您希望为这些资产创建的所有文件夹（例如 geoprep、lookdev 等）。    如果您要为这些资产保存和发布文件，需要在 core/templates.yml 中创建模板，描述保存的和发布的文件的文件路径。例如，除了 maya_asset_work，您还可以创建一个名为 maya_asset_work_vehicle 的模板，其定义将是要保存车辆资产的 Maya 工作文件的模板化路径。第 2 步：创建新的环境文件至此，您已为新的资产类型设置了目录结构，并通过模板描述了要将文件保存和发布在新目录结构中的何处。接下来，您需要指示 Toolkit 何时使用这些新模板。为此，需要创建一个新的环境文件。  创建一个 env/asset_step.yml 文件的副本，并命名为 env/asset_vehicle_step.yml。除了 env/asset_vehicle_step.yml 将使用新模板以外，这两个文件完全相同。将所有 maya_asset_work 替换为 maya_asset_work_vehicle。对已创建的所有其他车辆模板执行同样的操作。  最后，您需要告诉 Toolkit 何时选用新环境。要执行此操作，请修改 pick_environment 核心挂钩以返回 asset_vehicle 或 asset_vehicle_step（当上下文中的资产类型为 vehicle 时）。这时，当您处理这种新类型（“车辆”(vehicle)）的资产时，Toolkit 会知道使用它的环境配置，并因此将文件保存和发布到它备选的文件系统结构。如何创建自定义工作流工序？在 ShotGrid 7.0.6.0 中，引入了通过“管理”(Admin)菜单管理工作流工序的功能。使用此功能，您可以轻松向工作流工序中添加自定义字段。高级技巧：大多数情况下，与创建自定义实体来管理工作流工序相比，在工作流工序中使用自定义字段有助于工作流条理更加清晰。",
    "url": "/82ff76f7/",
    "relUrl": "/82ff76f7/"
  },
  "57": {
    "id": "57",
    "title": "解决与 Python API 相关的 SSL: CERTIFICATE_VERIFY_FAILED 问题",
    "content": "解决与 Python API 相关的 SSL: CERTIFICATE_VERIFY_FAILED 问题Python API 依赖与 API 捆绑在一起且位于计算机上的一组证书才能连接到 ShotGrid 使用的各种 Web 服务。遗憾的是，证书颁发机构可能会颁发新证书，而这些证书可能未与 Python API 或操作系统捆绑在一起。虽然我们的 Python API 附带了截至 2019 年 2 月 21 日的最新证书副本，有一个错误导致 API 无法使用这些证书以向 Amazon S3 执行上传操作，即使您使用的是最新版本的 API 也是如此。有关背景信息，请参见此 AWS 博客文章。要临时解决这种状况，可以尝试以下解决方案。                    注意: 这些是临时解决方法，我们正在研究长期解决方案。    首选解决方案将所需的 CA 证书添加到 Windows 证书存储中。Windows 7 用户可能必须先升级到 PowerShell 3.0 才能使用此解决方案，也可使用 certutil 添加所需的证书。      通过右键单击开始，然后单击 Windows PowerShell (管理员)，启动提升权限的 PowerShell。        将以下命令粘贴到 PowerShell 窗口中，然后按回车键以执行：     $cert_url = &quot;https://www.amazontrust.com/repository/SFSRootCAG2.cer&quot; $cert_file = New-TemporaryFile Invoke-WebRequest -Uri $cert_url -UseBasicParsing -OutFile $cert_file.FullName Import-Certificate -FilePath $cert_file.FullName -CertStoreLocation Cert: LocalMachine Root            如果显示带 Thumbprint 925A8F8D2C6D04E0665F596AFF22D863E8256F3F 的已添加证书详细信息，则表示操作已完成，可以关闭 PowerShell。  替代解决方案如果仅使用 Python API      升级到 Python API v3.0.39        a. 将 SHOTGUN_API_CACERTS 设置为 /path/to/shotgun_api3/lib/httplib2/cacerts.txt    或    b. 在实例化 Shotgun 对象时更新脚本并设置 ca_certs=/path/to/shotgun_api3/lib/httplib2/cacerts.txt。  如果使用 Toolkit      通过 tank core 命令或通过更新工作流配置的 core/core_api.yml 文件升级到最新版本的 Toolkit API，具体取决于您部署 Toolkit 的方式。        从 https://github.com/certifi/python-certifi/blob/master/certifi/cacert.pem 下载最新的证书列表。        将 SHOTGUN_API_CACERTS 设置为该文件的保存位置。与 Python API 类似，Toolkit 不允许您在创建连接时指定 ca_certs 参数。  如果无法更新 Python API 或 Toolkit      从 https://github.com/certifi/python-certifi/blob/master/certifi/cacert.pem 下载最新的证书列表。        将 SSL_CERT_FILE 环境变量设置为该文件的保存位置。  ",
    "url": "/c593f0aa/",
    "relUrl": "/c593f0aa/"
  },
  "58": {
    "id": "58",
    "title": "文件夹创建中止",
    "content": "无法创建文件夹: 文件夹创建中止用例目前，我们在 Web 界面上创建新项目，然后使用 ShotGrid Desktop 将 Toolkit 配置为集中式设置。但是，当尝试编辑资产名称时，它不再起作用（艺术家无法在 Maya 等 CCD 中打开文件进行编辑），并返回错误“无法创建文件夹”。ShotGrid 要求重新运行 tank 命令以取消注册资产并重新注册它以进行修复，但我们不知道在何处运行这些命令。如何修复在项目上运行高级设置向导后，会有意移除用于运行该向导的选项。但是，如果需要，可以重新设置项目。您需要运行错误消息中提及的 tank 命令：tank.bat Asset ch03_rockat_drummer unregister_folderstank.bat 位于您设置的配置的根目录中，如果您不确定它在何处，此主题应该可以帮助您找到它。相关链接在社区中查看完整主题",
    "url": "/25a37fc0/",
    "relUrl": "/25a37fc0/"
  },
  "59": {
    "id": "59",
    "title": "帧服务器遇到错误",
    "content": "帧服务器遇到错误用例从 SG Desktop 启动 Nuke 时，显示错误消息“帧服务器遇到错误。”，您可以继续工作。完整错误：The Frame Server has encountered an error.Nuke 12.1v5, 64 bit, built Sep 30 2020.Copyright (c) 2020 The Foundry Visionmongers Ltd. All Rights Reserved.Loading - init.pyTraceback (most recent call last):File “/Applications/Nuke12.1v5/Nuke12.1v5.app/Contents/Resources/pythonextensions/site-packages/foundry/frameserver/nuke/workerapplication.py”, line 18, infrom util import(asUtf8, asUnicode)ImportError: cannot import name asUtf8cannot import name asUtf8如何修复当配置上仍存在开发路径时，可能会发生此错误。相关链接在社区中查看完整主题",
    "url": "/2f35b796/",
    "relUrl": "/2f35b796/"
  },
  "60": {
    "id": "60",
    "title": "Getting Started",
    "content": "Isolation Feature Set - Getting StartedWant to learn more about the isolation features? See About the Isolation Feature Set for more details about what is in store for you. The Isolation feature set is available to clients with an active ShotGrid subscription. Before starting, please be sure to complete your subscription purchase.To get the onboarding process started, go to Onboarding Process.To start the setup for any of the Isolation features, go to the Setup sectionIn This Section  About the Isolation Feature Set  Client Responsibilities  Onboarding Process  Planning Your Setup",
    "url": "/0f6d8a60/",
    "relUrl": "/0f6d8a60/"
  },
  "61": {
    "id": "61",
    "title": "快速入门",
    "content": "快速入门ShotGrid Toolkit 提供了一组可高度自定义的工具，用于创建工作室工作流，让艺术家可以从 ShotGrid 中访问信息并彼此共享作品，而无需退出其内容创建软件。这些手册旨在帮助您通过实际练习开始设置自定义 Toolkit 工作流：您将使用 ShotGrid Desktop 应用为项目生成可编辑的配置，修改现有应用的设置，甚至将 Toolkit 应用添加到不同的美工人员环境，从而让您设计自定义工作流。每个手册都以之前的手册为基础，但是它们包含从任何位置跳转的说明。",
    "url": "/3c5b69aa/",
    "relUrl": "/3c5b69aa/"
  },
  "62": {
    "id": "62",
    "title": "错误 18:13:28.365:Hiero(34236) 错误！任务类型",
    "content": "错误 18:13:28.365:Hiero(34236): 错误! 任务类型用例：更新到 config_default2 后，nuke_studio 不会初始化。在 Nuke 12.0 Studio 中，脚本编辑器未出现错误，但在 Nuke 11.1v3 中出现错误：ERROR 18:13:28.365:Hiero(34236): Error! Task type tk_hiero_export.sg_shot_processor.ShotgunShotProcessor Not recognised回滚后不会失败，但仍不会初始化 tk-nuke 插件，并且 ShotGrid 无法加载任何内容…社区帖子包含完整日志，以提供更多详细信息。导致错误的原因是什么？它不是将其视为 NukeStudio 启动，而是可能将其视为标准 Nuke 启动。定义的 Nuke Studio 软件实体具有路径，并将参数设置为 -studio。参数必须是 --studio。如何修复软件实体上的参数需要设置为 -studio。在社区中查看完整主题。",
    "url": "/8edc0d13/",
    "relUrl": "/8edc0d13/"
  },
  "63": {
    "id": "63",
    "title": "为什么我的 Houdini ShotGrid 集成没有启动？",
    "content": "为什么我的 Houdini ShotGrid 集成没有启动？本文介绍了 ShotGrid 集成在 Houdini 中无法启动的常见原因。在这种情况下，Houdini 从 ShotGrid Desktop、ShotGrid 网站或 tank 令启动且无错误。但是，Houdini 启动后，ShotGrid 菜单或工具架将不会出现。通常导致这种情况的原因是，HOUDINI_PATH 环境变量已被覆盖，而 ShotGrid 依赖于该变量来传递启动脚本路径。Houdini 从 ShotGrid 启动时，启动应用逻辑会将 ShotGrid 引导脚本路径添加到 HOUDINI_PATH 环境变量。但是，如果 Houdini 具有 houdini.env 文件，可能会出现问题。此文件允许用户设置加载 Houdini 时将显示的环境变量，但是此文件中定义的任何值都将覆盖当前会话中已存在的环境变量。解决此问题的方法是确保在 HOUDINI_PATH 环境变量的新定义中包含先前存在的该变量。例如，如果 houdini.env 文件中已存在如下内容：HOUDINI_PATH = /example/of/an/existing/path;&amp;amp;您应将 $HOUDINI_PATH; 添加到文件中所定义路径的末尾，并加以保存：HOUDINI_PATH = /example/of/an/existing/path;$HOUDINI_PATH;&amp;amp;这允许 ShotGrid 将值设置为在 Houdini 启动时继续存在。                    注意: 我们注意到，$HOUDINI_PATH 在 Windows 上会导致问题。有时会尝试引导 ShotGrid 集成多次，导致生成如下所示的错误：Toolkit bootstrap is missing a required variable : TANK_CONTEXT如果出现这种情况，您应尝试改为使用 %HOUDINI_PATH%。    如果这样做无法解决问题，请联系我们的支持团队，他们将帮助您诊断问题。",
    "url": "/eecfb05b/",
    "relUrl": "/eecfb05b/"
  },
  "64": {
    "id": "64",
    "title": "概述",
    "content": "",
    "url": "/",
    "relUrl": "/"
  },
  "65": {
    "id": "65",
    "title": "如何在 Windows 上静默安装 ShotGrid Desktop？",
    "content": "如何在 Windows 上静默安装 ShotGrid Desktop？要以静默方式运行 ShotGrid Desktop 安装程序，只需按以下方法启动 ShotGrid Desktop 安装程序：ShotgunInstaller_Current.exe /S如果还要指定安装文件夹，请用 /D 参数启动安装程序：ShotgunInstaller_Current.exe /S /D=X: path to install folder.                    注意: /D 参数必须是最后一个参数，路径中不应使用 &quot;，即使其中有空格也是如此。    ",
    "url": "/3a27b3da/",
    "relUrl": "/3a27b3da/"
  },
  "66": {
    "id": "66",
    "title": "添加应用",
    "content": "添加应用通过完成本手册，您将很快熟悉 Toolkit 中的配置管理工具，并学会如何：  安全地创建使用中的工作流配置的副本  将应用添加到配置  添加在特定环境中使用该应用所需的设置  将更改同步回使用中的工作流配置关于本手册本手册将演示如何将 ShotGrid Toolkit 应用添加到现有的工作流配置。您将很快熟悉配置管理工具。我们要添加的应用是 ShotGrid Python 控制台应用。Maya 具有其自己的 Python 控制台，但是 Toolkit 应用中有一些功能在 Maya 控制台中不存在。本手册利用我们在编辑工作流配置手册中创建的工作流配置。如果您尚未完成此手册，则可以使用现有的工作流配置，并在其中添加该应用。使用本文档要使用本手册并安装 Toolkit 应用，需要以下内容：  活动的 ShotGrid 站点。  用于已标识项目的工作流配置，或完成配置快速入门手册，并使用在该练习中创建的配置。  为存储工作流配置的 Shotgun 管理的文件系统设置适当的读取和写入权限。  在系统上安装 ShotGrid Desktop。  Maya 的有效固定期限的使用许可。在此处 获取 Maya 的 30 天试用版。                    注意: 本手册基于 tk-config-default2 工作流配置。如果您的配置文件已修改，则文件和文件夹的位置、YAML 设置的区块可能就与此处描述的不同。    关于 ShotGrid Toolkit 应用Toolkit 应用工作方式工作流配置中引用的应用可以来自不同的位置。默认配置中的标准应用来自 ShotGrid 应用商店。工作流配置中的文件指定 ShotGrid 集成如何访问应用，有点像询问 Toolkit，“您能在小黑本中查找 Python 控制台应用的地址吗？”工作流配置文件告知 Toolkit 在何处可以找到用于特定应用的代码包。Toolkit 应用的“地址”列在默认配置的 config/env/includes/app_locations.yml 文件中，并指定如何查找代码。这些“地址”称为描述符。不仅需要告诉 ShotGrid 集成如何查找应用的代码包，还需要告诉它在哪些环境中使用该应用。下面概念性概述了如何安装应用以及如何告知 ShotGrid 集成在何处使用它。 它概述了扩展配置的步骤，要求 Toolkit 查找描述符，并告知 ShotGrid 在何处使用该应用。 本手册详细介绍了这些步骤：  确定要添加的应用的描述符。  复制要将应用描述符添加到的活动工作流配置。  确定该应用的描述符在配置中是否存在，如果不存在，则添加它。  使用空格而不是制表符进行缩进，从而正确设置 YAML 文件的格式。  确定要在哪些环境中使用该应用。  在这些环境中，添加允许 ShotGrid 使用该应用的设置。  测试新配置。  使扩展配置生效。查找 Python 控制台应用的位置描述符步骤 1：打开应用和插件页面，并在 Maya 下查找 ShotGrid Python 控制台的信息。选择标题。这将显示应用的信息，其中包括小黑本所需的所有内容。应用插件名称是主标识符：tk-multi-pythonconsole。您还需要最新版本：v1.1.2。确认在 Maya 的项目环境中没有 Python 控制台应用步骤 2：启动 Maya 并选择 ShotGrid 菜单“ShotGrid &amp;gt; 项目 the_other_side”(ShotGrid &amp;gt; Project the_other_side)，您会看到可用于项目环境中该项目的应用列表。扩展配置要编辑处于制作阶段的配置，您需要先创建一个副本，然后编辑该副本。这样，您不会影响实时配置，可以先创建一个安全空间进行测试，然后再使其生效。通过创建临时沙盒，您可以使用当前在制作中使用的工作流配置的副本。在沙盒中，您对配置副本进行更改，测试这些更改，然后再使其在制作中生效。克隆工作流配置可自动执行以下过程：创建副本，构建可以在其中使用副本的沙盒，然后再将新配置推送到实时制作中。克隆要将应用添加到的工作流配置转到工作流配置列表。步骤 3：打开 ShotGrid，在右上角选择“管理”(Admin)菜单（您的头像）&amp;gt;“默认布局 &amp;gt; 工作流配置 &amp;gt; 工作流配置列表”(Default Layouts &amp;gt; Pipeline Configuration &amp;gt; Pipeline Configuration List)。此动作将显示 ShotGrid 站点的所有工作流配置的详细列表。步骤 4：显示“工作流配置列表”(Pipeline Configuration List)后，选择列标题最右侧的 + 号，然后添加“项目”(Projects)列。查看项目配置所在的位置步骤 5：此外，针对您的操作系统添加适当的路径字段。这会显示配置文件的路径。步骤 6：在“主要”(Primary)行项旁边的空白区域中单击鼠标右键，然后在上下文菜单中选择“克隆此配置…”(Clone this Configuration…)。步骤 7：在配置列表中命名配置，然后在目录中分别命名文件：“Primary Clone Config 2”和“the_other_side_clone2”。选择“确定”(OK)。等待 ShotGrid 复制配置中的所有文件和文件夹，并为应用创建缓存。 现在就可以使用应用，让您可以一边喝着香浓咖啡，一边享用羊角面包。完成后，将使用有关克隆配置的信息更新配置列表，并且将在本地 config 文件夹中添加新配置。                    注意: 在“用户限制”(User Restrictions)下，添加了您的用户名。ShotGrid 自动将对新配置的访问权限限制为仅创建配置的人员。 您可以添加要编辑、测试并最终使用此配置的人员。另一方面，ShotGrid 可实现灵活性和可控性。    将克隆的配置与项目相关联步骤 8：打开 ShotGrid Desktop，并选择您为其创建克隆配置的项目。 选择右上角的向下箭头以显示与此项目关联的配置，然后选择刚创建的 Primary Clone Config 2。ShotGrid Desktop 现在正在使用此项目的克隆配置。编辑工作流配置步骤 9：在文件系统中，在创建克隆配置时指定的路径中查找克隆配置。查看 config/env/includes/app_locations.yml 文件。app_locations.yml 文件是默认配置的小黑本，应用的描述符列在此文件中。此文件指向应用所在的位置，并允许您为该应用创建设置。如果您要使用的应用未在小黑本中引用，则需要告知 Toolkit 在哪里找到它。告知 Toolkit 在哪里找到应用步骤 10：在此文件中搜索 pythonconsole。如果为项目使用了默认配置，您会发现此文件中列出了 Python 控制台应用的描述符。它应该与我们开始配置时查看的 Maya 应用列表中的描述相匹配。检查以确保版本与我们在 Maya 应用列表中查看的内容相匹配。apps.tk-multi-pythonconsole.location:	type: app_store	name: tk-multi-pythonconsole	version: v1.1.2                    注意: 如果您使用的是其他配置，则可能需要将描述符添加到文件中。    所有应用和插件都有描述符。您可以在核心 API 文档的“描述符”部分中阅读有关描述符工作方式以及如何设置 type: 的内容。告知 Toolkit 使用描述符现在，我们需要告知 Toolkit 使用描述符来查找 Python 控制台应用，并在我们处于 Maya 的项目环境中时使用它。步骤 11：打开克隆配置中的 config/env/project.yml 文件，并找到 tk-maya 插件的设置。# configuration for all engines to load in a project contextengines:  tk-3dsmaxplus: &quot;@settings.tk-3dsmaxplus.project&quot;  tk-desktop: &quot;@settings.tk-desktop.project&quot;  tk-flame: &quot;@settings.tk-flame.project&quot;  tk-hiero: &quot;@settings.tk-nuke.hiero.project&quot;  tk-houdini: &quot;@settings.tk-houdini.project&quot;  tk-mari: &quot;@settings.tk-mari.project&quot;  tk-maya: &quot;@settings.tk-maya.project&quot;  tk-motionbuilder: &quot;@settings.tk-motionbuilder.project&quot;  tk-nuke: &quot;@settings.tk-nuke.project&quot;  tk-nukestudio: &quot;@settings.tk-nuke.nukestudio.project&quot;  tk-photoshopcc: &quot;@settings.tk-photoshopcc.project&quot;  tk-shell: &quot;@settings.tk-shell.project&quot;  tk-shotgun: &quot;@settings.tk-shotgun.project&quot;使用 @settings 的 tk-maya: “@settings.tk-maya.project” 行表明这些设置位于包含文件中。tk-maya 标识 Maya 插件，project 标识环境。YAML 文件ShotGrid Toolkit 工作流配置使用 YAML 文件中的简单术语来标识应用和插件的位置及其设置。对于此特定块：  settings 是为默认配置选择的作为对 settings 文件夹的引用的字符串  project 是为默认配置选择的作为对项目环境的引用的字符串  tk-maya 是 Toolkit 的 Maya 插件的标识符  @ 是 Toolkit 术语，用于表示设置值来自包含文件YAML 文件是 ShotGrid 集成的窗口，可以更轻松地配置满足您的工作流需求的工作环境。配置如何引用 Toolkit 包ShotGrid 集成的代码被组织成应用、插件和框架的包。 在 Toolkit 的 YAML 文件中使用 tk-maya、tk-multi-pythonconsole 等标识符对这些包进行引用。每个包的相应 YAML 块都包含用于控制如何访问和使用所标识包的设置。在何处放置 Python 控制台的设置对于默认配置中的此特定块，“tk-maya.project”是项目环境中 Maya 插件的标识符。我们的目标是将 Python 控制台应用代码包添加到项目环境中的 Maya 插件。根据所使用的术语，可以肯定的是 tk-maya.yml 是项目环境设置所在的 YAML 文件的名称。在 tk-maya.yml 文件中查找 apps 的 settings.tk-maya.project。步骤 13：要查找该文件，在 engines 上方的 includes 部分中查找 tk-maya.yml。./includes/settings/tk-maya.yml步骤 14：在克隆配置中，在文本编辑器中打开 config/env/includes/settings/tk-maya.yml，并搜索 settings.tk-maya.project。步骤 15：在以下部分的下方添加位置描述符settings.tk-maya.project:  apps:使用 about 应用 tk-multi-about:，作为如何添加位置描述符的指南，然后保存该文件。                    注意: 请确保使用空格而不是制表符正确设置 YAML 文件的格式。    # projectsettings.tk-maya.project:  apps:    tk-multi-about:      location: &quot;@apps.tk-multi-about.location&quot;    tk-multi-pythonconsole:      location: &quot;@apps.tk-multi-pythonconsole.location&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-multi-shotgunpanel: &quot;@settings.tk-multi-shotgunpanel&quot;    tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;您会注意到，审片室、ShotGrid 面板和 Workfiles 2 应用的位置标识符列在不同的包含文件中，并且以不同于关于应用的方式进行访问。 为了保持整洁，这些应用被拆分到包含的 settings 文件夹，因为它们具有其他设置。                    注意: Python 控制台应用已经存在于默认配置中，但是如果您添加的应用以前从未添加到配置中，或者您已更改应用的版本，并且使用的是集中式配置，则需要额外执行一个步骤。打开终端，并浏览到存储克隆配置的位置。从克隆配置的根文件夹中，运行以下命令：在 Linux 或 Mac 上：./tank cache_apps在 Windows 上：tank.bat cache_apps这将扫描应用、插件和框架的配置并确保它们均已下载。    查看 Maya 中的更改步骤 16：打开 ShotGrid Desktop，选择正在处理的项目，并确认您使用的是克隆配置。在项目名称下，将出现一个蓝色条，其中包含您创建的克隆的名称。                    注意: 如果您使用的是主要配置，则不会出现蓝色条，并且配置名称将不可见。    步骤 17：从 Desktop 启动 Maya，然后选择菜单“ShotGrid &amp;gt; 项目 &amp;gt; …”(ShotGrid &amp;gt; Project &amp;gt; …)如果：  您使用的是刚编辑的克隆配置  克隆配置已正确扩展  您保存了扩展文件  您选择将项目与克隆配置相关联  您从 ShotGrid Desktop 重新启动了 MayaPython 控制台应用将在 Maya 中可用。将更改推送到制作中在确认正确添加了 Python 控制台应用后，您就可以使更改生效了。步骤 18：打开终端，并浏览到存储克隆配置的位置。从克隆配置的根文件夹中，运行以下命令：在 Linux 或 Mac 上：./tank push_configuration在 Windows 上：tank.bat push_configuration按照提示操作，并键入项目主要配置（您要将更改推送到的配置）的 ID。$ lscache		config		install		tank		tank.bat$ ./tank push_configurationWelcome to the Shotgun Pipeline Toolkit!For documentation, see https://developer.shotgridsoftware.comStarting Toolkit for your current path'/Users/michelle/Documents/Shotgun/configs/the_other_side_clone2'- The path is not associated with any Shotgun object.- Falling back on default project settings.- Running as user 'Michelle'- Using configuration 'Primary Clone Config 2' and Core v0.18.159- Setting the Context to Project the_other_side.- Running command push_configuration...----------------------------------------------------------------------Command: Push configuration----------------------------------------------------------------------This command will push the configuration in the current pipeline configuration('Primary Clone Config 2') to another pipeline configuration in the project.By default, the data will be copied to the target config folder. If pass a--symlink parameter, it will create a symlink instead.Your existing configuration will be backed up.The following pipeline configurations are available to push to: - [1] Primary (/Users/michelle/Documents/Shotgun/configs/the_other_side)Please type in the id of the configuration to push to (ENTER to exit):将出现一个可以将克隆配置推送到的可用工作流配置的列表。输入您要为其更新配置的项目的主要工作流配置的 ID。                    注意: 您也可以在本手册的“步骤 3”中查看的 ShotGrid 中的“工作流配置”(Pipeline Configuration)页面上找到工作流配置的 ID。 要查找项目 ID，请转到“配置列表”(Configuration List)，并添加“ID”列。    输入 ID 后，ShotGrid 将：  备份主要配置  复制克隆配置  将复制的克隆配置与项目相关联，使克隆保持不变  显示保存主要配置的位置  检查是否有任何需要下载和缓存的应用Please type in the id of the configuration to push to (ENTER to exit): 1Hold on, pushing config…Your old configuration has been backed up into the following folder:/Users/michelle/Documents/Shotgun/configs/the_other_side/config.bak.20190118_111627Checking if there are any apps that need downloading…Push Complete!查看在主要配置中所做的更改步骤 19：在 ShotGrid Desktop 中，单击右上角的箭头，并在“配置”(CONFIGURATION)列表中选择“主要”(Primary)。步骤 20：从 Desktop 启动 Maya，并查看菜单“ShotGrid &amp;gt; 项目 &amp;gt; …”(ShotGrid &amp;gt; Project &amp;gt; …)以查找“ShotGrid Python 控制台…”(ShotGrid Python Console…)Python 控制台应用已添加到所选项目的项目环境中。我们在第二个手册编辑配置中讨论过，每个环境都是独立的，每个项目都有专用配置，软件集成在加载项目时从工作流配置中收集设置。为使 Python 控制台在环境中可用，该环境需要使用一些指令以便在 app_locations.yml 文件中查找位置描述符。考虑到这一点，在工作流中您希望使用 Python 控制台应用的任何阶段，都需要“在此处使用 Python 控制台应用”设置。高级主题ShotGrid 开发人员社区Toolkit 的一个奇妙之处在于，任何人都可以创建 Toolkit 应用。应用可以保持专有，也可以在 ShotGrid 社区中分享，并添加到 ShotGrid 库。如果您已经在 ShotGrid 区页面上创建了真正想要共享的主要应用，请访问支持站点以获取帮助。在 ShotGrid-dev Google 组中对标准 Toolkit 应用和由充满爱心的 ShotGrid 社区创建的应用进行了热烈的讨论。随着 ShotGrid 社区内容日益丰富，知识和工具库将不断壮大。研究如何扩展配置您可能已经注意到，当我们选择要用于项目的配置时，ShotGrid Desktop 下拉菜单中提供了 Python 控制台应用。如果有一个环境正在使用您要添加到工作流配置的应用，则可以使用少量检测工作来查找将该应用添加到配置所需的信息。通过在使用该应用的环境中查看配置文件，您可以确定如何添加应用位置描述符和设置。Desktop 应用会在项目环境中打开，因此在 project.yml 文件中查找 tk-desktop。打开 config/env/project.yml。在插件块中，tk-desktop 指向包含的内容：includes:  - ./includes/settings/tk-desktop.ymlengines:  tk-desktop: &quot;@settings.tk-desktop.project&quot;在包含内容之后，打开 config/env/includes/settings/tk-desktop.yml 并查找 settings.tk-desktop.project 块。在该块中，您会看到以下内容：apps:  tk-multi-pythonconsole:  location: &quot;@apps.tk-multi-pythonconsole.location&quot;在项目工序中，这些块将 Python 控制台应用添加到 Desktop 插件。在此之后，进一步包含 ../includes/app_locations.yml，并搜索 apps.tk-multi-pythonconsole.location 以查找以下内容：# pythonconsoleapps.tk-multi-pythonconsole.location:  type: app_store  name: tk-multi-pythonconsole  version: v1.1.2每个应用、插件和框架都有位置描述符，用于告知 Toolkit 在何处访问特定的包。许多应用描述符都位于 app_locations.yml 文件中，但可能无法在所需的位置引用它们，正如我们在 Python 控制台应用中看到的那样。所有标准应用和插件都列在应用和插件页面 中。您可以将任何应用添加到 ShotGrid 支持的任何适当的软件集成中，也可以将您自己的专有应用添加到 Toolkit 库中。所有受支持的软件应用程序也列在集成应用和插件页面中。如果找不到您要查找的确切应用，则可以创建一个。其他 ShotGrid 用户很有可能需要同样的功能，因此分享新应用是回馈 ShotGrid 社区的一种方式。在下一个手册中，您将了解如何自定义 production 文件夹结构，以呈现您的设施的构造方式。",
    "url": "/4d147fb2/",
    "relUrl": "/4d147fb2/"
  },
  "67": {
    "id": "67",
    "title": "ShotGrid 集成管理员手册",
    "content": "ShotGrid 集成管理员手册简介本文档是面向 ShotGrid 集成管理员的手册。它适用于三个角色：用户、管理员和开发人员。我们的用户手册面向将在其日常工作流中使用 ShotGrid 集成的最终用户（也就是艺术家），我们的开发人员手册是面向编写 Python 代码以扩展功能的人员的技术文档。本文档适用于面向在工作室实施 ShotGrid 集成、管理软件版本以及为发布的文件做出存储决策的人员。标准工作流配置任何 Toolkit 设置的核心都是工作流配置，即一组 YAML 文件，用于管理从安装的应用到软件版本的所有内容，在某些情况下，甚至包含用于设置您的生产目录结构和文件名的模板。标准工作流配置可以高度自定义，但我们提供两种基础配置。基本配置即时可用的集成设计为在不需要设置或修改任何配置文件的情况下运行。当您使用即时可用的集成时，没有要管理的内容，但 Toolkit 在后台使用隐式工作流配置，我们称此工作流配置为基本配置。基本配置使三个 Toolkit 应用（面板、发布器和加载器）可用于所有受支持的软件包，并根据您在 ShotGrid 中的软件实体来确定在 ShotGrid Desktop 中显示哪些软件包。基本配置不包含文件系统位置支持。当您在项目中使用即时可用的集成时，无论何时启动 Desktop，都会自动更新您的基本配置副本，因此，您始终拥有最新版本的集成。您可以在此处订阅发行说明，并在此处查看 GitHub 中的基本配置。默认配置这是高级项目设置的默认基础配置。它包括文件系统位置支持以及一组更广泛的 Toolkit 应用和插件。您可以在此处查看 GitHub 中的默认配置。有关默认配置结构的详细说明，请参见工作流配置中的 config/env/README.md 文件，或在此处查看 GitHub 中的默认配置结构。                    注意: 想要查找原有配置结构？采用 v1.1 版本的集成后，我们重新组织了默认配置的结构，以帮助最大限度地提高效率和可读性，并使其更接近基本配置结构。您仍然可以对项目使用旧的默认配置。只需在 Desktop 设置项目向导中提示选择配置时选择“旧版默认”(Legacy Default)。    发布器发布器旨在简化即时可用的工作流和完整工作流配置之间的过渡。在即时可用的设置中，文件在原位发布，这就不必定义模板或文件系统数据结构。项目完成高级设置并具有完整工作流配置后，同一发布插件将识别向应用设置引入模板的情况，并开始将文件复制到其指定的发布位置，然后再进行发布。因此，工作室可以根据需要为具有完整配置的项目按每个环境或按每个 DCC 引入基于模板的设置。对于基于模板的工作流，默认配置是完整配置的，要了解如何为发布应用配置模板，它是一个很好的参考。有关详细信息，请参见 GitHub 默认配置中的 tk-multi-publish2.yml 文件。有关编写适用于发布器的插件的详细信息，请参见开发人员手册的“发布器”部分。配置软件启动可以使用 ShotGrid 轻松地自动检测系统上的宿主应用程序：只需启动 ShotGrid Desktop，选择一个项目，Desktop 将显示它在标准应用程序目录中找到的所有受支持软件包的启动程序。但我们还提供了强大的工具，用于对您工作室中的软件进行更细致的管理。您可以限制应用程序对特定项目、组甚至单个用户的可见性。您可以指定版本、在您的整个站点内取消激活某个给定软件包以及将软件包分组在一起。所有这些均通过 ShotGrid 中的软件实体进行管理。当您创建新 ShotGrid 站点时，该站点将有一组默认的软件实体 - 每个受支持的宿主应用程序一个实体。您可以修改这些实体以及添加自己的实体，从而以您所需的方式管理 Desktop 中显示的软件。要在 ShotGrid 中查看您的软件实体，请单击屏幕右上角的配置文件图标打开“管理”(Admin)菜单，然后选择 Software。软件实体具有以下字段：  软件名称(Software Name)：软件在 Desktop 中的显示名称。  缩略图(Thumbnail)：上传用作 Desktop 图标的图像文件。  状态(Status)：控制软件是否可用。  插件(Engine)：内容创建工具的集成名称。  产品：对于包含变体的软件包（例如，Houdini 与 Houdini FX），可以在此处指定以逗号分隔的列表。仅在自动检测模式下有效，在手动模式下无效。  版本(Versions)：要显示的软件的具体版本。可以在此处指定以逗号分隔的列表。仅在自动检测模式下有效，在手动模式下无效。  组(Group)：Group 字段值相同的实体将分组在 Desktop 中的单个图标和 ShotGrid 中的单个菜单下。例如，可以创建包含 Houdini 和 Nuke 的特效组。  默认组(Group Default)：如果某个组的一个成员选中了 Group Default，则单击该组的图标或菜单项将启动该软件。  项目(Projects)：将软件限制到特定项目的一种方式。  用户限制(User Restrictions)：将软件限制到特定用户或组的一种方式。  Linux 路径(Linux Path)/Mac 路径(Mac Path)/Windows 路径(Windows Path)：这些字段用于显式指定操作系统特定的软件路径。  Linux 参数(Linux Args)/Mac 参数(Mac Args)/Windows 参数(Windows Args)：启动软件时附加到命令的命令行参数。我们可以通过演示一些使用这些字段的方法来详细了解它们如何协同工作。示例：对同一应用程序的多个版本分组，自动检测假设您的文件系统上有三个版本的 Maya：Maya 2016、Maya 2017 和 Maya 2018。您希望它们均可供您的艺术家使用，但想要将它们分组在 Desktop 中单个图标下。如果这三个版本的 Maya 安装在您的文件系统上的标准位置，则会自动完成上述操作。当您在 Desktop 中选择一个项目时，它将扫描本地计算机上的标准应用程序目录并找到三个版本。由于您在 ShotGrid 中已有一个 Maya 软件实体，在没有指定特定版本或路径的情况下，它将在 Desktop 中显示其找到的所有版本。下面是需要注意的一些事项：  ShotGrid 自动检测您的软件时，单个软件实体会生成所有版本的菜单项。  任何“路径”(Path)字段均未指定值。软件实体处于自动检测模式，因此假定应用位于标准位置。这些均将显示在 Desktop 中，如此处所示：一个表示 Maya 的图标，包含一个下拉菜单，其中列出了所有可用版本。如果单击图标本身，将启动最新版本的 Maya。示例：对同一应用程序的多个版本分组，手动模式将 Maya 存储在您工作室中的非标准文件系统位置完全没有问题。您只需要创建自己的软件实体，并指定路径以让 ShotGrid 知道在何处找到您的软件。您的设置可能如下所示：下面是一些注意事项：  与在自动检测模式下不同，此处，每个版本的给定软件包对应一个软件实体。  为了将它们分组在一起，请使用 Group 和 Group Default 字段。Group 值相同的软件实体将被分组在 Desktop 中单个图标下的下拉菜单中，该图标使用 Group 值作为其名称。  单击该图标本身时，将启动 Group Default 处于选中状态的组中的软件。  在软件实体上为“Linux 路径”(Linux Path)、“Mac 路径”(Mac Path)或“Windows 路径”(Windows Path)中_任何_一个指定值时，该实体将转为手动模式。与自动检测模式（路径字段为空时，软件 会 显示在 Desktop 中）不同，在手动模式下，仅 当为软件指定了路径且在指定路径中存在文件时，软件包才会在给定操作系统上显示。  在此示例中，由于未指定 Windows Path，因此三个 Maya 版本均不会显示在 Windows 上的 Desktop 中。示例：按用户或组限制现在，使用上一个示例，假设我们尚未准备好使 Maya 2018 可供所有用户使用。但我们希望 TD、Dev 和 QA 工程师、Tessa Tester 能对其进行访问。我们可以使用 User Restrictions 字段实现这一点。示例如下：我们基于上一个示例做了一些更改：  组默认值现在是 Maya 2017。我们希望这是正式版本，因此在选中对应复选框的情况下，现在单击 Maya 对应的图标将转到此版本。  我们在 User Restrictions 字段中添加了一些值：该字段可以接受用户和组，我们添加了“Dev”和“TD”组以及用户“Tessa Tester”。现在，只有这些人员将会在 Desktop 中看到 Maya 2018。示例：按项目限制软件版本有时，您希望在您的工作室中对多个项目进行更复杂的版本管理。您可能有个项目面临交付困境，您希望使其不再使用新版本软件更新，而同时该项目的后续事情可能刚开始且能够使用更高版本。在这种情况下，您的软件实体可以设置为如下所示：需要注意的一些重要事项：  此处我们删除了 Group 和 Group Default 值，因为在给定环境中总是只有一个 Maya 版本将显示在 Desktop 中。  我们将所有三个版本的 Software Name 均设置为“Maya”。这样，在每个项目中，用户均将看到一个名称相同的图标，但根据此处配置的内容，它将指向不同的版本。  我们将 Maya 2016 的 Status 字段设置为 Disabled。我们不再在工作室中使用此版本，且此字段切换在所有项目中的全局可见性。  我们针对 Maya 2017 和 Maya 2018 指定了 Projects 值。此 Projects 字段用作限制。Maya 2017 将_仅_显示在 Chicken Planet 项目中，而 Maya 2018 将仅显示在 Chicken Planet II 中。  请注意，一旦指定了某个软件实体的 Projects 值，该软件将仅显示在指定的项目中。因此，如果您的工作室中除了 Chicken Planet 系列外还有其他项目，您需要为它们明确指定软件。示例：添加自己的软件出于以下一些原因，除了 ShotGrid Desktop 已在您的系统上自动检测到的软件外，您可能还会添加新的软件实体：  您要通过 Desktop 使没有插件的应用程序可供您的用户使用。  您有我们没有为其提供集成的内部软件或第三方软件，且您已为其编写自己的插件。  您的软件不在标准位置，因此您要手动在 ShotGrid 中指定该软件的路径。（这是在上面的“对同一应用程序的多个版本分组，手动模式”示例中所述的情况。）在这些情况下，您可以添加自己的软件实体。将需要为 Software Name 字段设置值。如果您的软件使用的是内部插件，请在 Engine 字段中指定插件名称。某些工作室可能要在 Desktop 中添加没有 ShotGrid 集成的应用，以便为艺术家提供方便。您的艺术家可以直接从 Desktop 启动相应的应用。您甚至可以使用上述所有设置来管理版本和使用限制。在这种情况下，请将 Engine 字段保留为空，但需要至少为 Mac Path、Linux Path 和 Windows Path 之一指定值。配置发布的文件路径解析发布文件时，发布器将在 ShotGrid 中创建 PublishedFile 实体，其中包含名为 Path 的文件/链接字段。随后，其他用户可能会尝试使用加载器将此文件加载到自己的工作会话中。加载器使用复杂的逻辑来解析多个操作系统中已发布的文件的有效本地路径。加载器尝试将发布数据解析为路径的方式取决于发布是与本地文件链接关联还是与 file:// URL 关联。解析本地文件链接如果您发布的路径与 ShotGrid 的“站点偏好设置”(Site Preferences)中定义的任何本地存储相匹配，则在发布时会自动生成本地文件链接。如果发布是本地文件链接，则将会使用其本地操作系统表达方式。要了解有关本地文件链接的详细信息，请单击此处。如果未针对您当前使用的操作系统定义本地存储的路径，您可以使用环境变量指定本地存储根。环境变量的名称应采用 SHOTGUN_PATH_&amp;lt;WINDOWS|MAC|LINUX&amp;gt;_&amp;lt;STORAGENAME&amp;gt; 形式。因此，如果您要为名为“Renders”的存储根定义 Mac 上的路径，可以创建 SHOTGUN_PATH_MAC_RENDERS 环境变量。下面我们使用该示例进行更深入的讨论：  假设您的 ShotGrid 站点有一个名为“Renders”的存储根，并指定了以下路径：  Linux 路径：/studio/renders/  Windows 路径：S: renders       Mac 路径：&amp;lt;blank&amp;gt;        您在使用 Mac。    您要使用路径 /studio/renders/sq100/sh001/bg/bg.001.exr 将发布加载到您的会话中。加载器可以解析该路径并推断 /studio/renders/ 是其存储根部分，但没有为 Mac 定义存储根。因此，它将查找 SHOTGUN_PATH_MAC_RENDERS 环境变量，如果找到，则会将路径中的 /studio/renders 替换为其值。注意：如果您定义了 SHOTGUN_PATH_MAC_RENDERS 环境变量，并且本地存储“渲染”(Renders) 确实设置了 Mac 路径，则将使用本地存储值并将记录警告。注意：如果无法针对当前操作系统解析存储，则发出 PublishPathNotDefinedError。解析文件 URL加载器还支持对 file:// URL 进行解析。在发布时，如果您发布的路径与您站点的任何本地存储均不匹配，则该路径将另存为 file:// URL。与本地文件链接相反，这些路径不是以多操作系统表达方式存储，而只是针对其创建时所在的操作系统进行定义。如果您尝试在创建 file:// URL 时所在操作系统之外的其他操作系统上解析该 URL，加载器将尝试使用一系列方法将其解析为有效路径：  首先，它将查找三个环境变量 SHOTGUN_PATH_WINDOWS、SHOTGUN_PATH_MAC 和 SHOTGUN_PATH_LINUX。如果这些已定义，则将尝试按此方式转换路径。例如，如果要尝试在 Windows 中解析 file:///prod/proj_x/assets/bush/file.txt，您可以设置 SHOTGUN_PATH_WINDOWS=P: prod 和 SHOTGUN_PATH_LINUX=/prod 以提示路径的解析方式。  如果要使用多组环境变量以表示多个存储，可以使用后缀扩展以上变量名语法来实现：  如果您有一个用于渲染的存储，您可以执行一些操作，例如，定义 SHOTGUN_PATH_LINUX_RENDERS、SHOTGUN_PATH_MAC_RENDERS 和 SHOTGUN_PATH_WINDOWS_RENDERS，以便为引用渲染存储中数据的所有已发布 file:// URL 提供转换机制。  然后，如果您还有一个用于剪辑数据的存储，则可以定义 SHOTGUN_PATH_LINUX_EDITORIAL、SHOTGUN_PATH_MAC_EDITORIAL 和 SHOTGUN_PATH_WINDOWS_EDITORIAL，以便为剪辑存储根提供转换机制。一旦标准化了这些环境变量，可以考虑将其转换为 ShotGrid 本地存储。一旦在 ShotGrid 的首选项中定义了它们，系统将会自动提取它们且不需要环境变量。  除了上述情况外，在 ShotGrid 的首选项中定义的所有本地存储均将以相同方式进行处理。  如果定义了本地存储，但缺少操作系统，这可以通过环境变量提供。例如，如果 Linux 和 Windows 上定义了一个名为 Renders 的本地存储，则可以通过创建名为 SHOTGUN_PATH_MAC_RENDERS 的环境变量进行扩展以支持 Mac。此项的常规语法为 SHOTGUN_PATH_&amp;lt;WINDOWS|MAC|LINUX&amp;gt;_&amp;lt;STORAGENAME&amp;gt;。  如果没有匹配的根，则将原样返回文件路径。示例如下：假设您在 Linux 上发布了文件 /projects/some/file.txt，且生成了使用 URL ShotGrid 的 file:///projects/some/file.txt 发布。在您的工作室中，Linux 路径 /projects 相当于 Windows 上的 Q: projects，因此您希望将完整路径转换为 Q: projects some file.txt。以下所有设置将对此进行处理：  基于变量的常规替代：  SHOTGUN_PATH_LINUX=/projects  SHOTGUN_PATH_WINDOWS=Q: projects      SHOTGUN_PATH_MAC=/projects        一个名为“Projects”的 ShotGrid 本地存储，进行以下设置：    Linux 路径：/projects  Windows 路径：Q: projects      Mac 路径：/projects        一个名为“Projects”的 ShotGrid 本地存储，使用一个环境变量予以增强：    Linux 路径：/projects  Windows 路径：  Mac 路径：/projects  SHOTGUN_PATH_WINDOWS_PROJECTS=Q: projects注意：如果在 ShotGrid 中定义了一个本地存储 Renders，且设置了 Linux path，另外还定义了 SHOTGUN_PATH_LINUX_RENDERS 环境变量，则将优先使用该存储，忽略该环境变量，并记录警告。一般而言，本地存储定义始终优先于环境变量。高级配置有关执行已发布的文件路径解析的基本方法的信息，请查看我们的开发人员参考文档。如果您要使用“Advanced Project Setup”，可以通过自定义 resolve_publish 核心挂钩添加超出本地文件链接和 file:// URL 的支持。可以进行以下自定义：  具有关联上传文件的发布可以通过核心挂钩自动下载到适当的缓存位置，且会返回路径。  自定义 URL 方案（如 perforce://）可以解析为本地路径。浏览器集成ShotGrid Toolkit 的浏览器集成是指通过 ShotGrid Web 应用程序中的右键单击上下文菜单访问 Toolkit 应用和启动器。这些菜单（如上文所示）包含针对各种实体类型配置的动作。如果某个项目有多个工作流配置，则将按工作流配置组织动作。通过浏览器集成，您可以从浏览器中启动识别 ShotGrid 上下文的内容创建软件（如 Maya 或 Nuke）。浏览器集成简单回顾多年来，ShotGrid Toolkit 的浏览器集成采用了多种形式。随着技术的改进和安全要求的提高，执行浏览器集成的方法也发生了变化。Java 小程序（已弃用）第一种执行方法是使用 Java 小程序，通过它从 ShotGrid Web 应用程序访问本地桌面。由于 Java 小程序被认为是可利用的安全风险，因此不能再使用它们，必须弃用。浏览器插件（已弃用）替换已弃用的 Java 小程序的是浏览器插件，它利用 NPAPI 从 ShotGrid Web 应用程序访问本地桌面。由于 NPAPI 也被认为存在安全风险，主要的 Web 浏览器都已开始阻止其使用。因此必须弃用浏览器插件。通过 ShotGrid Desktop 实现的 websocket v1（旧式）在 ShotGrid Desktop 应用中托管 websocket 服务器过去是且现在仍然是从 ShotGrid Web 应用程序与本地桌面通信时所采用的方法。此 websocket 服务器的 RPC API 的第一次执行利用了为之前的 Java 小程序和浏览器插件开发的相同底层技术。当服务器收到来自 ShotGrid 的请求时，使用关联项目的工作流配置中的 tank 命令来获取要显示在动作菜单中的命令列表。通过 ShotGrid Desktop 实现的 websocket v2websocket 服务器的 RPC API 的第二次迭代更改了用于获取、缓存和执行 Toolkit 动作的基本机制。此执行解决了与早期浏览器集成执行有关的许多性能问题，改进了动作菜单的外观组织，并添加了对即时可用的 ShotGrid 集成的支持，这些集成无需显式配置 Toolkit 即可使用。这是浏览器集成的当前执行方式。配置要针对每个实体类型控制向用户显示的动作，可在您的项目工作流配置中修改 YAML 环境文件。首次尝试自定义时要了解和考虑一些事情。哪个插件配置？在 ShotGrid Web 应用中管理 Toolkit 动作的 Toolkit 插件是 tk-shotgun，因此，此插件的配置控制动作菜单中的显示内容。在上面的 tk-config-basic 示例中，配置了两个应用，它们会使很多插件命令转换为菜单动作。Toolkit 应用将注册要包含在动作菜单中的命令，包括本地系统上发现的每个软件包的启动器命令，这些命令对应于 ShotGrid 站点中的软件实体列表。结果是此处所示的菜单动作列表：浏览器集成代码找到用户系统上安装的 Houdini、Maya、Nuke 和 Photoshop，从而产生用于启动其中每个集成的菜单动作。请注意，在给定的环境配置文件中，必须存在软件实体的_插件_，才会针对该环境的实体显示软件的启动器。因此，在此示例中，从中获取此代码片段的文件中必须存在 tk-houdini、tk-maya、tk-nuke 和 tk-photoshopcc 所有这些插件。如果要从此实体的启动器列表中移除某项（例如 Maya），只需从环境配置文件中移除 tk-maya 插件块。除了这些启动器外，发布应用的“发布…”(Publish…)命令也包含在菜单中。哪个 YML 文件？您可以采用两种途径之一：利用主要环境配置 (config/env/*.yml)（由配置的 pick_environment.py 核心挂钩控制），或 tk-config-default 使用的传统方法（使用 config/env/shotgun_&amp;lt;entity_type&amp;gt;.yml 文件）。如果使用标准环境文件，则浏览器集成使用 pick_environment 核心挂钩来确定将哪个环境配置文件用于给定实体的动作菜单。在最简单的情况下，环境对应于实体类型。例如，如果右键单击镜头，则显示的动作菜单将由 config/env/shot.yml 中的 tk-shotgun 块配置。可以自定义 pick_environment 挂钩以使用更复杂的逻辑。如果标准环境文件中没有配置 tk-shotgun 插件，则存在 shotgun_&amp;lt;entity_type&amp;gt;.yml 文件时发生回退。这样，浏览器集成可以使用利用实体特定的环境文件的旧配置。提示：使用 tk-config-default2 从浏览器启动器中移除软件更新用于从 ShotGrid 浏览器启动软件的配置会有所不同，具体取决于使用的是 tk-config-default 还是 tk-config-default2。使用 tk-config-default2 时，应将更新应用于config/env/includes/settings/tk-shotgun.yml，而在 tk-config-default 中，应将更新应用于 config/env/shotgun_task.yml。例如，通过浏览器从资产启动时，从选项列表中移除 Mari。首先，导航到 config/env/asset.yml，并注意 tk-shotgun 插件块指向 @settings.tk-shotgun.asset 的方法。@ 符号表示配置值来自包含的文件。这意味着您需要转到 env/includes/settings/tk-shotgun.yml 进行更新。在 env/includes/settings/tk-shotgun.yml 中，注意每个实体的每个块。例如，资产为：&amp;lt;a name=&quot;asset&quot;&amp;gt;&amp;lt;/a&amp;gt;# assetsettings.tk-shotgun.asset:  apps:    tk-multi-launchapp: &quot;@settings.tk-multi-launchapp&quot;    tk-multi-launchmari: &quot;@settings.tk-multi-launchapp.mari&quot;    tk-multi-launchmotionbuilder: &quot;@settings.tk-multi-launchapp.motionbuilder&quot;    tk-multi-publish2: &quot;@settings.tk-multi-publish2.standalone&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-shotgun-folders: &quot;@settings.tk-shotgun-folders&quot;    tk-shotgun-launchfolder: &quot;@settings.tk-shotgun-launchfolder&quot;  location: &quot;@engines.tk-shotgun.location&quot;要从浏览器中某个资产的选项列表中移除 Mari，请移除 Mari 行 (tk-multi-launchmari: &quot;@settings.tk-multi-launchapp.mari&quot;)：&amp;lt;a name=&quot;asset&quot;&amp;gt;&amp;lt;/a&amp;gt;# assetsettings.tk-shotgun.asset:  apps:    tk-multi-launchapp: &quot;@settings.tk-multi-launchapp&quot;    tk-multi-launchmotionbuilder: &quot;@settings.tk-multi-launchapp.motionbuilder&quot;    tk-multi-publish2: &quot;@settings.tk-multi-publish2.standalone&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-shotgun-folders: &quot;@settings.tk-shotgun-folders&quot;    tk-shotgun-launchfolder: &quot;@settings.tk-shotgun-launchfolder&quot;  location: &quot;@engines.tk-shotgun.location&quot;然后，针对每个实体（例如镜头）按照相同的说明进行操作，从中移除在 ShotGrid 浏览器中启动特定软件的功能。请注意，保存文件后，您可能需要等待一分钟并对浏览器进行硬刷新才能使其生效。缓存浏览器集成具有强大的缓存机制，可以快速向用户显示菜单动作。由于引导 Toolkit 和获取插件命令列表的过程可能很耗时，因此这是很有必要的。缓存何时失效？websocket 服务器的 RPC API 根据以下两项来确定缓存的数据是否仍有效：YAML 文件修改时间和站点的软件实体的内容。如果自写入缓存数据后对给定配置中的某个环境 YAML 文件进行了修改，则重新缓存必要的数据，并向 ShotGrid Web 应用程序返回最新数据。同样，如果自数据缓存后对 ShotGrid 中任何软件实体的任何字段进行了修改，则引导 Toolkit 并缓存新数据。缓存文件位于磁盘上的什么位置？缓存文件位置取决于操作系统。OS X: ~/Library/Caches/Shotgun/&amp;lt;site_name&amp;gt;/site.basic.desktop/tk-desktopWindows: %APPDATA% Shotgun &amp;lt;site_name&amp;gt; site.basic.desktop tk-desktopLinux: ~/.shotgun &amp;lt;site_name&amp;gt; site.basic.desktop tk-desktop挂钩方法browser_integration.py 挂钩包含在 tk-framework-desktopserver 中，后者提供以下挂钩方法：  get_cache_key：此方法确定给定配置 URI、项目实体和实体类型的缓存条目键。默认执行组合了配置 URI 和实体类型。  get_site_state_data：此方法可用于将来自 ShotGrid 的其他查询数据包含到用于测试缓存数据有效性的哈希中。默认情况下，使用站点中存在的所有软件实体的状态，但如果应在哈希中包含其他数据，可以在此挂钩方法中执行。  process_commands：此方法提供用于自定义或更改要返回到 ShotGrid Web 应用程序的命令的位置。向方法提供的数据结构是词典列表，每个词典代表一个菜单动作。可以根据需要更改、过滤掉数据或将数据添加到列表中，数据将立即反映在请求 Toolkit 动作的菜单中。日志浏览器集成日志位于 Toolkit 的标准日志位置。相关日志文件是 tk-desktop.log 和 tk-shotgun.log。此外，如果使用的是 Google Chrome，有时部分相关日志输出会保存在该浏览器的开发人员控制台中。疑难解答从 Web 应用程序与本地桌面通信的复杂特性意味着中途可能会有故障点。下面介绍了几种此类情况以及在遇到这些情况时首先要采用的一些步骤建议。动作菜单中显示“打开或安装 ShotGrid Desktop…”(Open or install ShotGrid Desktop…)这可能意味着以下三种情况之一：      本地计算机上当前未运行 ShotGrid Desktop。这似乎很明显，但一定要检查确认。        Chrome 或 Python websocket 服务器已拒绝连接，从而导致 ShotGrid Web 应用程序无法与 ShotGrid Desktop 通信。这种情况很可能与用于在请求时允许连接继续的自签名证书有关。从头开始重新生成这些证书通常可以解决该问题，可以从 ShotGrid Desktop 触发此操作，如下所示。    ShotGrid Desktop 的 websocket 服务器无法在启动时启动。可能仅在公开发布的 websocket 服务器版本错误时出现此情况，这应该极少发生。在这种情况下，tk-desktop.log 中将显示对错误进行解释的日志，可以将该日志发送给 ShotGrid 的支持团队。动作菜单中未显示任何动作如果此实体类型应该有动作，这表示出现配置问题。下面是一些可能的问题：      在正确的环境 YAML 文件中配置了 tk-shotgun 插件，但该配置中没有应用。在此情况下，可能是有意设计此实体类型没有动作。        在正确的环境 YML 文件中配置了 tk-shotgun 插件，且存在应用，但菜单中仍未显示动作。这可能是由于应用无法初始化。在这种情况下，tk-shotgun.log and tk-desktop.log 中将提供描述问题的信息。        对应于此实体类型的环境不包含 tk-shotgun 的配置。此处的最终结果与此列表中的第一种情况相同。在此情况下，您可以查看工作流配置的 pick_environment 挂钩来确定正在为此实体类型加载哪个环境，可以在那里验证 tk-shotgun 的配置。        有一个缓存在磁盘上的空菜单动作列表。要强制重新生成缓存，可使用以下几种选项：          在项目的配置中更新 YAML 文件的修改时间。这样，ShotGrid 下一次请求菜单动作时，将触发重新缓存这些菜单动作。值得注意的是，这将触发参与项目的_所有_用户进行重新缓存。      在 ShotGrid 站点中更新任何软件实体中的字段值。该行为与上述涉及 YAML 文件修改时间的选项相同，但将使 ShotGrid 站点上 所有 项目中所有用户的缓存数据无效。软件实体是非项目实体，这意味着它们在所有项目之间共享。如果更改了任何软件实体中的数据，则会影响所有项目。      可以在出现问题的主机上删除缓存文件。移除缓存通常没有问题，因为缓存存储在每个主机本地，这仅会导致在相应系统上从头开始重新缓存数据。缓存存储在 ShotGrid 缓存位置中的以下 SQLite 文件中：&amp;lt;site-name&amp;gt;/site.basic.desktop/tk-desktop/shotgun_engine_commands_v1.sqlite      “Toolkit: 正在检索动作…”(Toolkit: Retrieving actions…)始终不替换为菜单动作出现此情况有几种可能：      websocket 服务器尚未完成动作缓存。如果这是对项目的配置进行重大更新后第一次检索动作，该过程可能需要一些时间才能完成。多等待一段时间，然后观察 tk-desktop.log 的内容看看是否仍在处理。        websocket 服务器无法响应且永远不会响应。这种情况应该很少出现，但如果在请求动作后很明显没有其他处理操作正在进行（如 tk-desktop.log 中所示），那应该就是出现了这种情况，此时请联系 ShotGrid 支持并提供相关日志数据。        用户在多个 ShotGrid 站点上工作。在单个站点上对 ShotGrid Desktop 进行身份认证后，从另一个 ShotGrid 站点请求菜单动作会导致系统询问用户是否重新启动 ShotGrid Desktop 并登录新站点。如果忽略该请求，则另一个站点将永远不会收到菜单动作列表。  Toolkit 配置文件如果您的工作室使用代理服务器，如果您要在初始登录屏幕中预填充某些值，或者如果您要调整基于浏览器的应用程序启动器与 ShotGrid Desktop 的集成方式，有一个名为 toolkit.ini 的特殊配置文件。ShotGrid Desktop 无需此文件即可运行；仅当您需要配置其行为时才需要它。Toolkit 按以下顺序在多个位置查找该文件：  指向文件路径的名为 SGTK_PREFERENCES_LOCATION 的环境变量。  在 ShotGrid Toolkit 首选项文件夹中：（请注意，默认情况下这些位置不存在此文件；您必须创建此文件。）          Windows：%APPDATA% Shotgun Preferences toolkit.ini      macOS：~/Library/Preferences/Shotgun/toolkit.ini      Linux：~/.shotgun/preferences/toolkit.ini      通过 SGTK_PREFERENCES_LOCATION 环境变量选项，您可以将您的配置文件存储在计算机或网络上的其他位置。请注意，toolkit.ini 为当前标准文件名。如果您使用的是 config.ini，请参见下面的_“旧位置”_部分。您可以在此处查看记录的配置文件示例。请注意，此示例文件名为 config.ini，但可以重命名为 toolkit.ini另请注意，您可以在此文件中使用环境变量以及硬编码值，以便您可以执行一些操作，例如，通过 Windows 上存在的 USERNAME 变量提取默认的用户名作为建议提供给用户。旧位置（已弃用）尽管 toolkit.ini 为当前标准文件名，我们以前出于相同目的使用了 config.ini 文件。toolkit.ini 和 config.ini 的内容相同。搜索 config.ini 时将使用以下已弃用的位置：  指向文件的名为 SGTK_DESKTOP_CONFIG_LOCATION 的环境变量。  在以下路径中：          Windows：%APPDATA% Shotgun desktop config config.ini      macOS：~/Library/Caches/Shotgun/desktop/config/config.ini      Linux：~/shotgun/desktop/config/config.ini      代理配置如果您的工作室通过代理访问 Internet，您将需要告诉 Toolkit 在访问 Internet 时使用此代理。可以将您的代理指定为 http_proxy 设置的值来完成此操作：http_proxy: &amp;lt;proxy_server_address&amp;gt;使用本地托管站点时运行 ShotGrid Desktop如果您的 ShotGrid 站点 URL 不是以 shotgunstudio.com 或 shotgrid.autodesk.com 结尾，表示您正在运行本地 ShotGrid 站点。在这种情况下，可能是您的站点尚未完全准备好实施 ShotGrid 集成，ShotGrid 团队可能需要参与进来并进行一些小的调整，然后您才能继续！在这种情况下，请提交工单，我们将帮助您解决问题。使用本地托管站点时连接到应用商店如果您要在使用本地 ShotGrid 站点时通过代理访问 Internet，您可能希望设置一个 HTTP 代理用于访问应用商店，但不用于访问本地 ShotGrid 网站。为此，只需将以下行添加到 toolkit.ini：app_store_http_proxy: &amp;lt;proxy_server_address&amp;gt;其中 &amp;lt;proxy_server_address&amp;gt; 是一个遵循开发人员文档中所记录约定的字符串。如果您需要按每个项目覆盖此设置，可以在项目工作流配置的 config/core/shotgun.yml 中完成此操作。离线使用情况在常规使用中，ShotGrid Desktop 会在启动时自动检查 Desktop 应用本身、tk-desktop 插件和基本配置是否有更新。但是，在某些情况下，您可能需要在离线时或在与 Internet 完全断开连接的计算机上运行集成。以下部分介绍了如何处理其中每种情况。ShotGrid Create本文档中所述的用于解决离线使用情况的方法也适用于 ShotGrid Create 中提供的集成功能。当以与 ShotGrid Desktop 相同的方式使用 ShotGrid Create 时，用于定制 ShotGrid Toolkit 行为的各种环境变量（例如 SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS）适用。离线使用集成情况：我要运行 ShotGrid 集成，但未连接到 Internet。我们有本地 ShotGrid 安装。解决方案  如果您可以临时连接到 Internet，只需下载 ShotGrid Desktop。它预先打包了一组集成，且预先捆绑了适用于所有受支持 DCC 的 ShotGrid 集成所需的各种应用和插件。启动后，它将自动尝试查找升级，但如果无法连接到 ShotGrid 应用商店，它将仅运行本地的最新版本。补充知识  某些 Toolkit 操作（例如注册发布）需要访问 ShotGrid 站点。因此，此解决方案仅适用于本地托管的站点。  更新下载到本地计算机。  如果您在连接和断开连接之间切换，Desktop 以及应用内集成（例如 Maya 和 Nuke 内部的集成）只要处于连接状态，就将在启动时下载升级。通过手动下载管理更新情况：我们的美工人员工作站已断开 Internet 连接，因此无法在 Desktop 中使用自动更新。我们仍想获得更新，但必须通过单台联机计算机下载它们，然后手动将它们传输给艺术家或传输到一个集中位置。解决方案  在连接到 Internet 的工作站上运行 ShotGrid Desktop。该工作站启动后，在 Desktop 启动时将自动下载最新升级。  选项 1：共享 Desktop 包  将缓存复制到所有计算机都可以访问的共享位置。  在离线计算机上设置 SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS 环境变量以指向此位置。  在脱机计算机上启动 Desktop 后，它们将选取缓存中可用的最新升级。  选项 2：本地部署  将更新的缓存分发到每台本地计算机上正确的缓存位置。补充知识  采用选项 1 时，将从 SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS 中定义的位置加载 Toolkit 代码。如果此位置在共享存储上，请确保它的性能足够高，能够加载许多小文件。  对于 Windows 设置，通常不会遇到这种情况。此时，我们改为建议采用选项 2。禁用自动更新虽然 Desktop 的自动更新可以确保您始终拥有最新版本，但有时您希望冻结某个项目甚至整个站点，从而将其锁定到特定版本并阻止任何更新。针对单个项目禁用更新情况：我的项目将要打包，我希望将其冻结，以便不会自动下载 ShotGrid 集成更新。解决方案  确定要将项目锁定到的版本。可以在此查找集成版本。  在 ShotGrid 中，为要锁定的项目创建工作流配置实体，并填充以下字段（在此示例中，我们将配置锁定为使用集成 v1.0.36）：  名称(Name)：Primary  项目(Project)：要锁定的项目  插件 ID(Plugin ids)：basic.*      描述符(Descriptor)：sgtk:descriptor:app_store?name=tk-config-basic&amp;amp;version=v1.0.36    现在，任何在项目中启动 ShotGrid Desktop 的用户始终使用的都将是 v1.0.36。开始处理该项目的任何新用户也将获得 v1.0.36。补充知识  更新下载到本地计算机。  用户下次在连接到 Internet 的情况下启动 Desktop 时，基本配置 v1.0.36 及其所有相关代码将下载到他们的计算机。  basic.* 表示基本配置中的所有插件都将选取此覆盖。例如，如果您想要仅冻结 Nuke 和 Maya 集成，可以指定 basic.maya, basic.nuke。  要进行测试，您可以创建此工作流配置实体的副本，并将您的用户名添加到 User Restrictions 字段中。这将限制该实体，使其仅可供您使用，而不会影响其他用户。然后，您可以从此配置副本启动 Maya 或某些其他软件，并确认它运行的是预期的集成版本。已知问题  Flame 集成的命名空间为 basic.flame，从表面上看应该包含在 basic.* 中。但实际上 Flame 集成并不包含在基本配置中。因此，如果您在某个项目中使用 Flame，然后执行此覆盖，则 Flame 集成将停止工作。  解决方案是专门为 Flame 创建另一个工作流配置覆盖：  配置名称(Config Name)：Primary  项目(Project)：要锁定的项目（如果要锁定所有项目，则为空）  插件 ID(Plugin ids)：basic.flame  描述符(Descriptor)：sgtk:descriptor:app_store?name=tk-config-flameplugin针对站点冻结更新情况：我不需要任何更新。我想要在我的工作室中完全控制所有项目中的下载内容和使用内容。解决方案  按照上面示例中的步骤操作，但保留 Project 字段为空。在 Project 字段中无覆盖的情况下，此工作流配置实体将应用于所有项目，包括“站点”项目，即，Desktop 在任何项目之外使用的站点配置。补充知识  这是想要“锁定站点配置”时使用的工作流。这将锁定所有内容，然后您可以通过 Desktop 菜单继续执行高级项目设置。  如果将整个站点锁定为使用某个版本（例如 v1.2.3），您仍可将单个项目锁定为使用其他配置。已知问题  Flame 会受此影响。有关解决方案，请参见上述情况的“已知问题”部分。针对除一个项目以外的其他所有项目冻结更新情况：我想要锁定站点中除测试项目以外的其他所有项目，而在测试项目中仍允许自动更新。解决方案  按上述部分中所述，针对站点冻结更新。  使用以下字段值配置例外项目的工作流配置实体：  名称(Name)：Primary  项目(Project)：不 希望锁定的项目  插件 ID(Plugin ids)：basic.*  描述符(Descriptor)：sgtk:descriptor:app_store?name=tk-config-basic补充知识  请注意，项目的“描述符”(Descriptor)字段中忽略了版本号。这将意味着项目追踪最新版本的基本配置。安全升级禁用升级的站点  情况：我们已锁定到 v1.0.0，并希望升级到 v2.0.0，但我想在将新版本部署到工作室之前先对其进行测试。*解决方案  通过右键单击并选择“复制选定项”(Duplicate Selected)，在 ShotGrid 中复制工作流配置实体。  将克隆的配置命名为“update test”，并在“用户限制”(User Restrictions)字段中指定您自己。  现在，您将开始使用此工作流配置。  将“描述符”(Descriptor)更改为指向要测试的版本。  您可以根据需要在“用户限制”(User Restrictions)字段中添加用户以邀请他们参与测试。  对测试满意后，只需将主工作流配置更新为使用该版本即可。  用户重新启动 Desktop 或 DCC 后，此更新将生效。接管工作流配置在没有设置任何配置的情况下，您将获得一组即时可用的基本 ShotGrid 集成，本文档介绍了使用这些即时可用的集成可以完成的各种管理工作。此基本设置建立在 ShotGrid 的 Toolkit 平台上，支持更加丰富的自定义。在 Desktop 中，Toolkit 项目设置向导将引导您完成为项目创建一个完整的可自定义工作流配置的过程。以下各部分通过示例和合理默认值建议详细介绍了向导的每个步骤，以防您不确定如何设置内容。从 Desktop 启动设置向导导航至某个项目后，Desktop 右下方的用户菜单中将会有一个“Advanced Project Setup…”菜单项。单击此菜单项可启动 Toolkit 设置向导。选择配置类型开始配置新项目时，首先要确定_使用哪个配置模板_。配置模板基本上是完整的项目配置，包含运行项目所需的所有设置、文件系统模板、应用和逻辑。  如果这是您的第一个项目，请使用 ShotGrid 默认值以便快速入门。  如果您已配置过项目且有以前项目的配置，则可以基于现有项目创建新项目来轻松重用这些配置。  对于高级工作流，您可以使用外部配置或 Git 库中存储的配置。默认配置这是默认的 Toolkit VFX 配置，通常是开始设置各项内容的重要开端。该配置包含 3ds Max、Flame、Houdini、Nuke、Mari、Maya、Motionbuilder 和 Photoshop 设置，以及磁盘上简单明了的文件夹设置。该配置包含多个不同部分：  文件系统设置  一组用于标识磁盘上关键位置的模板  一组预配置的插件和应用，它们一起链接在工作流中。文件系统概述在 ShotGrid 中，标准配置处理资产和镜头。它按工作流工序划分各项内容。一个工作流工序类似于一个部门。每个工作流工序均包含用于各种受支持应用程序的工作和发布区域。镜头结构如下所示：应用程序和工作流该配置包含以下部分：  Maya、Mari、Nuke、3ds Max、Flame、Houdini、Photoshop 和 Motionbuilder 支持  ShotGrid 应用程序启动器  发布、创建快照和版本控制  一个 Nuke 自定义写入节点  ShotGrid 集成  多个其他工具和实用程序除了上述应用外，您可以在安装了配置后轻松地安装其他应用和插件。基于现有项目创建新项目使用以前项目中的所有默认值和设置来创建并运行新项目，此方法既快捷又方便。Toolkit 仅将整个配置从旧设置复制到新项目中。这是用于改进配置的简单实用方法 - 每个新项目均基于某个旧项目。有关如何改进和维护工作流配置的详细方法和文档，请参见此处：管理您的项目配置使用 Git 中的配置模板如果您要使项目的配置与源控制保持连接，请使用此选项。指定指向远程 Git 库或 Github 库的 URL，设置流程将为您克隆它。请注意，这不仅仅是 Github，而是与任何 Git 库一起使用。请务必确保存储库的路径以 .git 结尾，Toolkit 将尝试将其作为 Git 设置进行处理。由于您的项目配置是 Git 库，您可以提交您所做的任何更改并将其推送至您的主存储库，进而推送至其他项目。通过使用基于 Github 的配置，可以轻松地使多个 Toolkit 项目保持同步。可在此处了解详细信息：管理您的项目配置请注意，如果您运行的是 Windows，则需要将 Git 安装在您的计算机上，并可以通过 PATH 访问。在 Linux 和 Mac OS X 上，通常默认安装 Git。浏览配置模板如果您的配置在磁盘上（以文件夹形式，或压缩为 zip 文件），请使用此选项。如果有人通过电子邮件向您发送了配置，或如果您在磁盘上保留了一个主配置，您基于它来建立所有项目，这会很有用。这通常是专家选项，我们建议使用另一个项目的配置或我们的应用商店默认配置中的一个。设置存储每个 Toolkit 项目均会将其所有文件和数据写入到磁盘上的一个或多个共享存储位置。例如，某个配置可能需要一个存储用来存放纹理，一个用来存放渲染，以及一个用来存储场景文件。通常，在 ShotGrid 的“站点偏好设置”(Site Preferences)中的 _“文件管理”(File Management)_选项卡下控制这些存储。Toolkit 设置向导将要求您将配置所需的每个存储根映射到 ShotGrid 中的一个本地存储。所需根在左侧列出并显示其说明（如配置的 roots.yml 文件中所定义）。现有的 ShotGrid 本地存储列表在右侧列出。您必须为每个所需根选择一个存储，并输入当前操作系统的路径（如果 ShotGrid 中还不存在）。您还可以添加其他操作系统的路径（如果未定义）。现有路径会被锁定，以确保您不会意外影响可能依赖相应存储路径的其他项目。向导中的映射页面将确保您已映射每个所需根，并且每个映射都有效。您也可以在向导中选择存储选择列表末尾的 +New 项来创建新的本地存储。系统将提示您提供本地存储名称和当前操作系统的路径。设置项目时，Toolkit 将在每个存储位置中为每个新项目创建一个文件夹。例如，如果您的主存储位置为 /mnt/projects，则称为 The Edwardian Cry 的项目最后将位于 /mnt/projects/the_edwardian_cry 中。如果配置不仅仅使用主存储，则每个存储最后将有一个 the_edwardian_cry 文件夹。主存储位置通常类似于 /mnt/projects 或   studio projects，且通常是一个您已在存储项目数据的位置，位置按项目分组。它几乎始终位于共享网络存储上。选择项目文件夹名称现在要为项目选择磁盘名称。将在配置所需的所有不同存储中创建此文件夹。您可以在 UI 中查看快速预览 - 对于大多数配置，这将仅预览主存储，但如果使用多根配置，其他存储也会显示。Toolkit 将根据 ShotGrid 中的名称建议一个默认项目名称。可以随意调整它以创建适合您的设置的名称。选择配置位置最后，请确定磁盘上存放配置文件的位置。Toolkit 将根据以前的项目建议一个位置，以使它们最终全部位于磁盘上的同一位置。配置通常位于共享存储或磁盘上，以便工作室中需要该配置的所有用户均可以访问它。如果您计划在此项目中使用多个操作系统，请确保输入所有必要的路径。所有路径均应表示磁盘上的同一位置。通常，在 Mac OS X 和 Linux 上路径可以相同，但在 Windows 上不同。如果这是您的第一个项目，您通常要确定磁盘上一个用于存储您的所有将来工作流配置的共享区域。这通常是存储整个工作室共享的软件或软件设置的位置。该位置可能类似于 /mnt/software/shotgun。根据您的工作室网络和文件命名约定，该位置可能会有所不同。在设置第一个配置时，请在配置中为您的工作室中使用的所有平台设置路径。从而，将来能够轻松创建可从所有计算机访问的环境。假设您的项目名称为 Golden Circle，您可以键入以下三个路径：linux:   /mnt/software/shotgun/golden_circlemacosx:  /servers/production/software/shotgun/golden_circlewindows:   prod software shotgun golden_circle有了配置后可以做什么？当您完成并运行第一个配置后，请导航到“后续步骤”文档，详细了解如何配置和调整 Toolkit，以更好地满足您的工作室需要：在您的第一个项目基础上更进一步高级功能静默安装如果在 Windows 网络中，可以使用参数“/S”强制 .exe ShotGrid Desktop 安装程序执行静默安装。然后，您可以将可执行文件的快捷方式的副本推送至启动文件夹。",
    "url": "/8085533c/",
    "relUrl": "/8085533c/"
  },
  "68": {
    "id": "68",
    "title": "集成",
    "content": "RV 集成除了 ShotGrid 集成、RV 审片室和 ShotGrid 审看等不同的 ShotGrid 集成外，RV 还提供适用于 Nuke 和 Maya 的集成工具，但功能集有所不同。下面的前两个文档描述了 Nuke 和 Maya 集成的安装和工作流，后两个文档描述了不同的 ShotGrid 集成，从而帮助您决定要使用哪种集成。",
    "url": "/268002fe/",
    "relUrl": "/268002fe/"
  },
  "69": {
    "id": "69",
    "title": "选择的 LUT 无效",
    "content": "错误“选择的 LUT 无效: Gamma2.2”用例：在 ACES 颜色管理项目中工作时，如果使用默认的 Toolkit 发布，发布将失败并显示错误 Invalid LUT selected : Gamma2.2。导致错误的原因是什么？有一个应用会创建 QuickTime，该应用是 Nuke Toolkit 发布的一部分，名为 tk-multi-reviewsubmission，默认情况下，该应用将创建一个 QT，而该 QT 可与 Nuke 标准颜色模型配合使用。如何修复由于您使用的是 ACES（我假设使用 ICIO 模型），我们只需通过接管该应用并将其添加到 tk-multi-reviewsubmission 挂钩中来更改 codec_settings.py 应用中的颜色空间设置。编解码器因首选项而异，但在此示例中，我们使用 Output - sRGB Codec：因此，在 codec_settings.py 挂钩中，将 settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot; 设置添加到适合您的设置的位置。（我刚刚在所有位置添加了它）        settings = {}        if sys.platform in [&quot;darwin&quot;, &quot;win32&quot;]:            settings[&quot;file_type&quot;] = &quot;mov&quot;            if nuke.NUKE_VERSION_MAJOR &amp;gt;= 9:                # Nuke 9.0v1 changed the codec knob name to meta_codec and added an encoder knob                # (which defaults to the new mov64 encoder/decoder).                                  settings[&quot;meta_codec&quot;] = &quot;jpeg&quot;                settings[&quot;mov64_quality_max&quot;] = &quot;3&quot;                settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;            else:                settings[&quot;codec&quot;] = &quot;jpeg&quot;                settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;        elif sys.platform == &quot;linux2&quot;:            if nuke.NUKE_VERSION_MAJOR &amp;gt;= 9:                # Nuke 9.0v1 removed ffmpeg and replaced it with the mov64 writer                # https://help.thefoundry.co.uk/nuke/9.0/#appendices/appendixc/supported_file_formats.html                settings[&quot;file_type&quot;] = &quot;mov64&quot;                settings[&quot;mov64_codec&quot;] = &quot;jpeg&quot;                settings[&quot;mov64_quality_max&quot;] = &quot;3&quot;                settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;            else:                # the 'codec' knob name was changed to 'format' in Nuke 7.0                settings[&quot;file_type&quot;] = &quot;ffmpeg&quot;                settings[&quot;format&quot;] = &quot;MOV format (mov)&quot;                settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;        return settings现在，如果您已经全部设置好，那么在 Nuke 中发布时，将在 ACES 兼容的颜色空间中生成 QT。在社区中查看完整主题",
    "url": "/749984aa/",
    "relUrl": "/749984aa/"
  },
  "70": {
    "id": "70",
    "title": "Knowledge",
    "content": "Generic KnowledgeIn This Section  Connecting Your Studio With Your AWS VPC  ShotGrid AWS Direct Connect Onboarding  S3  VPC / IAM / Security Group  Direct Connect  Private Link  VPC Endpoints  AWS Knowledge",
    "url": "/540597cc/",
    "relUrl": "/540597cc/"
  },
  "71": {
    "id": "71",
    "title": "Learn",
    "content": "ShotGrid Isolation - LearnThis section will host a learning curriculum for ShotGrid Isolation features n the near future.",
    "url": "/da5a2d10/",
    "relUrl": "/da5a2d10/"
  },
  "72": {
    "id": "72",
    "title": "在 Maya 中，当我输出 context.task 时，它为空白“无”(None)",
    "content": "在 Maya 中，当我输出 context.task 时，它为空白“无”(None)用例在 Maya 中，在输出 context.task 后，它是 empty “None”，但尝试其他步骤/任务中的其他布局文件时，会显示 context.task 详细信息。在导航浏览 Open &amp;gt; Layout &amp;gt; new file 时，也可以输出 context.task 详细信息，但通过“文件保存”(File Save)保存文件时，context.task 为“无”(None)。如何修复尝试取消注册文件夹，以获取其中一个不起作用的镜头，然后再次运行文件夹创建。相关链接在社区中查看完整主题",
    "url": "/38c4e054/",
    "relUrl": "/38c4e054/"
  },
  "73": {
    "id": "73",
    "title": "如何在 Maya 中添加用于启动 Toolki 应用的工具架按钮？",
    "content": "如何在 Maya 中添加用于启动 Toolki 应用的工具架按钮？在 Maya 中添加一个用于启动 Maya 的 Toolkit 应用的工具架按钮是一项非常简单的操作。以下示例显示了如何添加自定义工具架按钮，以便打开加载器应用。                    注意: 假设 Toolkit 当前在 Maya 会话中处于启用状态。此示例代码不会引导 Toolkit。    在 Maya 中打开脚本编辑器并粘贴以下 Python 代码： import maya.cmds as cmds# Define the name of the app command we want to run.# If your not sure on the actual name you can print the current_engine.commands to get a full list, see below.tk_app = &quot;Publish...&quot;try:    import sgtk    # get the current engine (e.g. tk-maya)    current_engine = sgtk.platform.current_engine()    if not current_engine:        cmds.error(&quot;ShotGrid integration is not available!&quot;)    # find the current instance of the app.    # You can print current_engine.commands to list all available commands.    command = current_engine.commands.get(tk_app)    if not app:        cmds.error(&quot;The Toolkit app '%s' is not available!&quot; % tk_app)    # now we have the command we need to call the registered callback    command['callback']()except Exception, e:    msg = &quot;Unable to launch Toolkit app '%s': %s&quot; % (tk_app, e)    cmds.confirmDialog(title=&quot;Toolkit Error&quot;, icon=&quot;critical&quot;, message=msg)    cmds.error(msg)选择此代码并将其拖动到自定义工具架。请参见 Maya 文档以了解有关如何使用自定义工具架按钮的详细信息。您应该可以使用此代码示例启动在 Maya 中启用的任何 Toolkit 应用，方法是修改顶部的 tk_app 和 call_func 变量。",
    "url": "/dba779a5/",
    "relUrl": "/dba779a5/"
  },
  "74": {
    "id": "74",
    "title": "Media Isolation",
    "content": "Media IsolationMedia Isolation allows your studio to retain ownership and control of the media and attachments that you upload to ShotGrid. With Media Isolation, all the content that you upload to ShotGrid is stored in your studio’s private S3 Bucket. Access to the media is provided to the ShotGrid services only, using AWS AssumeRole keyless Security Token Service.Client-Owned S3 BucketStoring media and attachments in an S3 bucket that you own means that you remain the legal owner of these artifacts, allowing you to comply with your company’s security and legal policies. Your studio retains control of asset storage and access, access that you can revoke at will.More about AccessWhen using ShotGrid to upload and download media it is transferred directly to / from AWS S3 without transiting through Autodesk infrastructure. ShotGrid will only access media in two situations:  The ShotGrid Transcoding service will get read/write access once, soon after upload, when transcoding the media. See Ephemeral Transcoding for details.  When the ShotGrid service generates S3 Links to your sources and transcoded media.This is rendered possible by leveraging AWS AssumeRole keyless Security Token Service. When setting up Media Isolation, an AWS Role allowing ShotGrid to access your media for the action listed above is created, and the ShotGrid service is allowed to assume that role.ShotGrid Support staff do not have access to your S3 Bucket under any circumstances.CostsWhen activating Media Isolation the following costs, previously covered by Autodesk, become the responsibility of the client:  S3 Costs. All the S3 storage costs will be assumed by the customer. See Media Isolation for more details about how to reduce costs.  S3 Bandwidth. Bandwidth out of the S3 bucket will be assumed by the customer.What Media Isolation is not providingActivating Media Isolation doesn’t guarantee that the access to your ShotGrid site or media takes place within a closed network.",
    "url": "/a3c0e676/",
    "relUrl": "/a3c0e676/"
  },
  "75": {
    "id": "75",
    "title": "Media Replication",
    "content": "Media ReplicationShotGrid is compatible with the S3 Cross-Region replication feature, allowing your users located in different regions to read from the region closer to them in order to reduce latency and increase throughput. Replication to one region is currently supported.Pre-requisitesMedia Isolation is required in order to elect Media Replication.Configuration by usersWhen using Media Replication, each user can customize which region data is read from. A user can either specify the region to use, or use automatic mode. In automatic mode ShotGrid selects the replica determined by the user’s IP address using IP ranges specified in the Isolation Preferences.How it worksShotGrid can be configured to read from up to two different buckets. Using the AWS S3 Replication feature, you can configure replication between buckets in different regions, and then consume media from the region closest to your users. It is important to underline that media is always uploaded to the main bucket.Following AWS service level agreement, S3 guarantees the replication of 99.99% of the object within 15 minutes.Replication DelayA small amount of time, typically under 15 minutes, is required before replication happens. The replication time depends on the size of the object to replicate. In order to alleviate that replication delay, ShotGrid will, for a small period of time, generate links from to object in the source bucket instead of the replica. The duration of this transitional state is configurable in the Isolation Preferences.CostsActivating the Media Replication feature can increase your AWS costs considerabibly. Before activating, be aware that:  Your S3 cost linked to ShotGrid usage will more or less double, because the media is now stored in two regions.  You will be charged for the transfer cost between the source and the destination region. See AWS S3 CRR and the destination region for more details.Next StepsSee Media Replication Setup for setup instructions.",
    "url": "/0221297e/",
    "relUrl": "/0221297e/"
  },
  "76": {
    "id": "76",
    "title": "Media Traffic Isolation",
    "content": "Media Traffic Isolation using AWS PrivateLink for Amazon S3                    Disclaimer: This documentation is provided solely as an example. It explains how to set up your ShotGrid Isolation environment so that it can be connected to ShotGrid cloud infrastructure. Please adapt it to your studio security requirements as needed. As ShotGrid has no visibility on your AWS Account, ensuring that this account is secure is a client responsibility.    The media traffic isolation feature allows your users to access media in your AWS S3 bucket privately (not transiting over the public Internet). Please note that if you have a multi-region setup and that leverages the ShotGrid Transcoding service there may still be instances where media transits across the public Internet. Reach out to our support team for more details.Media Isolation activation is a pre-requisite to enable this feature. If you haven’t done so already, see Media Isolation.Set up a VPC in your S3 bucket AWS regionYou will need to deploy a VPC with the required VPC endpoint. We provide a private VPC CloudFormation templates as starting points. This template create the necessary VPC, subnets and VPC endpoint.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL to https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-vpc-s3-privatelink.yml  Click Next  Set a stack name. Eg. ShotGrid-vpc  Choose network ranges that doesn’t conflict with your studio network and set subnet CIDR values accordingly  Set your S3 bucket name  Click Next  Click NextSet up access from your site network to your AWS VPCOptions provided by AWS:  AWS Site-to-Site VPN  AWS Direct Connect                    Note: If Direct Connect is chosen, we recommend testing with a simpler / faster solution in the meantime to validate your Isolation setup. You can then replace that solution with Direct Connect once it is available.    Add an S3 endpoint to your VPC                    Note: This step should only be performed if the CloudFormation template was not used.    Simply add an com.amazonaws.us-west-2.s3 Interface VPC Endpoint to your existing VPC. Make sure the associated security group allow traffic from your site network.Add the VPC to your S3 bucket policyIn order for the S3 VPC endpoint to communicate with your S3 bucket your bucket policy must allow access from the S3 endpoint’s VPC. You can find instructions on how to configure the policy in the Fine Tuning step.ValidationTest the S3 VPC endpointUse the endpoint URL to list objects in your bucket using AWS CLI. In the following example, replace the VPC endpoint ID vpce-1a2b3c4d-5e6f.s3.us-east-1.vpce.amazonaws.com and bucket name my-bucket with appropriate information.    aws s3 --endpoint-url https://bucket.vpce-1a2b3c4d-5e6f.s3.us-east-1.vpce.amazonaws.com ls s3://my-bucket/Configure site to use your S3 VPC endpointYou can test by adding a temporary entry to the S3 Configuration site preference on your site.The complete entry will look like the following:{​​​​​​​​   &quot;&amp;lt;S3_CONFIG_NAME&amp;gt;&quot;: {​​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​,   &quot;&amp;lt;S3_CONFIG_NAME_WITH_S3_VPC_ENDPOINT&amp;gt;&quot;: {​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;,     &quot;s3_interface_vpc_endpoint_dns_name&quot;: &quot;vpce-1234567-5e6f.s3.us-east-1.vpce.amazonaws.com&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​After the configuration has been updated on your site, navigate to the /admin/speedtest route of your ShotGrid site. Select the new S3_CONFIG_NAME_WITH_S3_VPC_ENDPOINT and start the test to confirm that all the upload/download tests work as intended.Once it has been verified to work correctly, add the value from s3_interface_vpc_endpoint_dns_name to the main S3 configuration S3_CONFIG_NAME and your current setup should be using Media Traffic Isolation.Erase the S3_CONFIG_NAME_WITH_S3_VPC_ENDPOINT entry from the S3 Configuration to clean up your configurations.Next StepsSee Media Replication to activate the Media Replication Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/2ab85e3e/",
    "relUrl": "/2ab85e3e/"
  },
  "77": {
    "id": "77",
    "title": "Media Traffic Isolation - S3 Proxy",
    "content": "                    Deprecated: The preferred way is to use S3 Private Link instead of a S3 proxy, see Media Traffic Isolation    Media Traffic Isolation using an S3 proxy (DEPRECATED)                    Disclaimer: This documentation is provided solely as an example. It explains how to set up your ShotGrid Isolation environment so that it can be connected to ShotGrid cloud infrastructure. Please adapt it to your studio security requirements as needed. As ShotGrid has no visibility on your AWS Account, ensuring that this account is secure is a client responsibility.    The media traffic isolation feature allows your users to access media in your AWS S3 bucket privately (not transiting over the public Internet). Please note that if you have a multi-region setup and that leverages the ShotGrid Transcoding service there may still be instances where media transits across the public Internet. Reach out to our support team for more details.Media Isolation activation is a pre-requisite to enable this feature. If you haven’t done so already, see Media Isolation.Set up a VPC in your S3 bucket AWS region                    Disclaimer: Before starting, decide whether your S3 proxy will be privately accessible within your VPC or publicly accessible via the Internet and choose the relevant templates in the following instructions.    You will need to deploy a VPC with the required VPC endpoints. We provide both private VPC and public VPC CloudFormation templates as starting points. These template create the necessary VPCs, subnets and VPC endpoints.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL depending upon your desired configuration          Private VPC (default):https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-vpc.yml      Public VPC:https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-public-vpc.yml        Click Next  Set a stack name. Eg. shotgun-vpc  Choose network ranges that doesn’t conflict with your studio network and set subnet CIDR values accordingly  Set your S3 bucket name  Click Next  Click NextSet up access from your site network to your AWS VPCOptions provided by AWS:  AWS Site-to-Site VPN  AWS Direct Connect                    Note: If Direct Connect is chosen, we recommend testing with a simpler / faster solution in the meantime to validate your Isolation setup. You can then replace that solution with Direct Connect once it is available.    Add an S3 endpoint to your VPC                    Note: This step should only be performed if the CloudFormation template was not used when configuring Media Isolation.    Set up S3 proxyYou will need to deploy an S3 proxy in your VPC to forward traffic to the S3 VPC endpoint. We provide both private and public S3 proxy CloudFormation templates as starting points for this purpose. These will create the necessary Elastic Container Service (ECS) cluster and other resources to run the S3 proxy on AWS Fargate behind an AWS Application Load Balancer (ALB).Make the Docker image available from a private AWS ECR repository  Create a new Elastic Container Registry (ECR) repository  Name the repository s3-proxy  Upload the s3-proxy Docker image to the newly created ECR repository          Install Docker on your workstation      Follow the docker login instructions shown by clicking the View push commands button      Run the following commands, substituting the ECR endpoint in the example for yours:        docker pull quay.io/shotgun/s3-proxy:1.0.6docker tag quay.io/shotgun/s3-proxy:1.0.6 627791357434.dkr.ecr.us-west-2.amazonaws.com/s3-proxy:1.0.6docker push 627791357434.dkr.ecr.us-west-2.amazonaws.com/s3-proxy:1.0.6                    Create S3 proxy CloudFormation stackCreate a new stack in AWS Console using either the private or public CloudFormation template.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL depending upon your desired configuration          Private S3 proxy (default):https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-s3-proxy.yml      Public S3 proxy:https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-s3-proxy-public.yml        Click Next  Set a stack name up to 32 characters in length. Eg. shotgun-s3-proxy  Set the parameters that do not have default values with those used when creating the ECR repository, VPC and S3 bucket previously  Click Next  Accept I acknowledge that AWS CloudFormation might create IAM resources  Click NextConfigure HTTPSShotGrid requires that the S3 proxy be accessed via HTTPS, therefore the AWS ALB handling requests for your newly created S3 proxy stack must be configured to accept HTTPS requests.  Create a DNS entry pointing to your S3 proxy, depending upon whether public or private          Private S3 proxy (default):                  Go to the EC2 Load Balancers dashboard, select your S3 proxy’s ALB and make a note of the DNS name          Add a DNS CNAME record pointing to the DNS name of the ALBEg. s3-proxy.mystudio.com. 300 IN CNAME s3proxy-12R1MXX0MFFAV-2025360147.us-east-1.elb.amazonaws.com.                    Public S3 proxy:                  Go to the AWS Global Accelerator dashboard and make a note of the DNS name associated with your S3 proxy’s accelerator          Add a DNS CNAME record pointing to the DNS name of the Global AcceleratorEg. s3-proxy.mystudio.com. 300 IN CNAME a48a2a8de7cfd28d3.awsglobalaccelerator.com.                      Obtain an SSL certificate for your chosen URL, we recommend using AWS Certificate Manager (ACM) for this  Configure HTTPS for the S3 proxy by adding a new HTTPS listener to the AWS ALB          Go to the EC2 Load Balancers dashboard, select your S3 proxy’s ALB and click on the Listeners tab      Click Add listener      Select HTTPS from the Protocol dropdown menu      Click Add action -&amp;gt; Forward to…      Select your S3 proxy’s target group from the Target group dropdown menu      Select the Security policy you’d like to use. Eg. TLS-1-2-Ext-2018-06 (See AWS documentation for more information)      Select the SSL certificate you’d like to use from ACM or import a new certificate      Click Save      Add S3 proxy VPC to S3 bucket policyIn order for the S3 proxy to communicate with your S3 bucket your bucket policy must allow access from the S3 proxy’s VPC. You can find instructions on how to configure the policy in the Fine Tuning step.ValidationTest the S3 proxyTry to access your S3 proxy using the ping route. Eg. https://s3-proxy.mystudio.com/pingConfigure your test site to use the S3 proxy  Navigate to the Site Preferences menu within ShotGrid and expand the Isolation section  Set S3 Proxy Host Address to the S3 proxy url. Eg. https://s3-proxy.mystudio.com then click Save changes  Confirm that you are still able to access existing media  Attempt to upload new mediaNext StepsSee Media Replication to activate the Media Replicaton Traffic Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/85124db5/",
    "relUrl": "/85124db5/"
  },
  "78": {
    "id": "78",
    "title": "Media Traffic Isolation",
    "content": "Media Traffic IsolationCommunication between your client systems and S3 bucket targets a number of AWS network endpoints and data traverses the open Internet by default. Media Traffic Isolation allows you to limit the number of network endpoints used to transfer data to and from your S3 bucket and optionally restrict access to your AWS VPC or a defined set of public address scopes.ConfigurationAn S3 interface VPC endpoint is deployed within your VPC; which is then used as the endpoint for all S3 communication.How it worksShotGrid can be configured to use an S3 interface VPC endpoint to communicate with your S3 bucket. Deploying the S3 VPC endpoint within your VPC makes it possible to isolate traffic from the public Internet completely, or to allow more tightly controlled access from the Internet to your media.CostsActivating the Media Traffic Isolation feature will increase your AWS costs. Before activating, be aware that:  There are costs associated with running the S3 interface VPC Endpoint. See AWS PrivateLink pricing for more details.Next StepsSee Media Traffic Isolation for setup instructions.",
    "url": "/58919eae/",
    "relUrl": "/58919eae/"
  },
  "79": {
    "id": "79",
    "title": "我已从 ShotGrid Desktop 启动 Nuke/Maya 等，但 ShotGrid 菜单中缺少相关条目",
    "content": "我已从 ShotGrid Desktop 启动 Nuke/Maya 等，但 ShotGrid 菜单中缺少相关条目在 ShotGrid 菜单中显示的动作需根据上下文进行配置。这意味着根据您所处的上下文，可用动作列表可能会有所不同。您之后看到的应用可能与您现在看到的应用不同，因为您处于错误的上下文。示例从 ShotGrid Desktop 启动应用程序时，默认进入项目环境中。此环境由工作流配置中位于 config/env/project.yml 下的配置文件进行管理。由于用户的大多数工作可能不在此环境中进行，其中并未配置许多应用供您使用。默认 Maya 项目动作：您可以使用 ShotGrid Workfiles 应用选择要处理的资产、镜头或任务。这将加载相应的新环境，这样，更多的应用便会启用 ShotGrid 菜单中的菜单项。默认 Maya 资产任务动作：如果您认为您处于正确的环境，但动作仍未显示，则下一步是检查相关日志，查看是否存在任何错误。您可能需要启用调试日志记录以获得完整输出。",
    "url": "/901110e2/",
    "relUrl": "/901110e2/"
  },
  "80": {
    "id": "80",
    "title": "Migration",
    "content": "MigrationOnce everything is configured and properly tested with the migration test site, it’s now time to migrate your production site to use the isolation features.Test migrationAsk the ShotGrid team to start the migration process in support ticket/slack.  ShotGrid will clone your production site database to your migration test site.  You will do a first sync of the media from ShotGrid’s S3 bucket to your bucket. ShotGrid will provide the exact instructions.  You can now test your site to be sure your existing media is available.Final migrationThe second test is to definitly migrate your site to use your own S3 bucket.  You will do a second sync of the media from ShotGrid’s S3 bucket to your bucket.  ShotGrid will reconfigure your hosted site with media isolation. Some media will be missing until the final media sync is completed.  You will do a final media sync.",
    "url": "/09699c82/",
    "relUrl": "/09699c82/"
  },
  "81": {
    "id": "81",
    "title": "启动 {% include product %} Desktop 时，错误模块“tank”没有属性“support_url”",
    "content": "启动 ShotGrid Desktop 时，错误模块“tank”没有属性“support_url”问题升级版本后，启动 ShotGrid Desktop 时显示以下消息：ShotGrid Desktop Error:Error: module 'tank' has no attribute 'support_url'原因描述符版本与较新的 ShotGrid Desktop版本 1.7.3 不兼容。在 tk-core v0.19.18 中引入了“support_url”。解决方案要解决此问题，请执行以下操作：  访问 ShotGrid 网站上的“工作流配置列表”(Pipeline Configuration List)页面。  检查“描述符”(Descriptor)字段是否具有与较新的 ShotGrid Desktop 版本不兼容的旧版本。相关链接  知识库支持文章",
    "url": "/2c67d8b6/",
    "relUrl": "/2c67d8b6/"
  },
  "82": {
    "id": "82",
    "title": "ModuleNotFoundError",
    "content": "ModuleNotFoundError用例使用分布式配置时，如果在插件外部引导 tk-shell 以访问 tk.templates 命令，则会出现此错误。按照此文档（第 4 部分）从安装文件夹导入 sgtk v0.19.18 时，出现以下错误：Traceback (most recent call last):  File &quot;.../_wip/sgtk_bootstrap.py&quot;, line 9, in &amp;lt;module&amp;gt;    import sgtk  File &quot;L:/_tech/sgtk_sandbox/install/core/python sgtk __init__.py&quot;, line 16, in &amp;lt;module&amp;gt;    import tank  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank __init__.py&quot;, line 58, in &amp;lt;module&amp;gt;    from . import authentication  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication __init__.py&quot;, line 33, in &amp;lt;module&amp;gt;    from .shotgun_authenticator import ShotgunAuthenticator  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication shotgun_authenticator.py&quot;, line 13, in &amp;lt;module&amp;gt;    from .sso_saml2 import (  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication sso_saml2 __init__.py&quot;, line 15, in &amp;lt;module&amp;gt;    from .core.errors import (  # noqa  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication sso_saml2 core __init__.py&quot;, line 15, in &amp;lt;module&amp;gt;    from .sso_saml2_core import (  # noqa  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication sso_saml2 core sso_saml2_core.py&quot;, line 19, in &amp;lt;module&amp;gt;    from Cookie import SimpleCookieModuleNotFoundError: No module named 'Cookie'如何修复出现此问题，可能是因为使用的是 Python 3（不再支持旧版 Python）。相关链接在社区中查看完整主题",
    "url": "/d8981e04/",
    "relUrl": "/d8981e04/"
  },
  "83": {
    "id": "83",
    "title": "如何将我的工作流配置移动到新位置？",
    "content": "如何将我的工作流配置移动到新位置？                    注意: 本文档的内容仅适用于集中式配置设置。分布式配置在本地缓存到各个客户端计算机，并由 Toolkit 自动管理。    要将工作流配置移动到新位置，最简单的方法是使用 tank move_configuration 命令。该命令将移动文件，更新 ShotGrid，并更新配置文件以指向新位置。以下情况下此命令也非常有用：您仅移动单个操作系统的位置，或者以前未使用某个操作系统，但现在想添加该操作系统。Toolkit 将检测需要移动或添加的内容以及不需要移动或添加的内容，同时还会向您显示即将执行的操作，以便您在继续操作之前进行确认。  使用 tank move_configuration 命令  手动移动工作流配置                    注意: 如果移动具有本地化核心的配置，且拥有使用此工作流配置中嵌入的 Toolkit 核心的其他项目（即，其他配置将此用作共享核心），则您必须手动更新这些项目中的配置文件，使其指向此工作流配置的新位置。这些文件位于以下位置：  /path/to/pipeline_configuration/install/core/core_Darwin.cfg  /path/to/pipeline_configuration/install/core/core_Linux.cfg  /path/to/pipeline_configuration/install/core/core_Windows.cfg    使用 tank move_configuration 命令：    $ cd /sgtk/software/shotgun/scarlet    $ ./tank move_configuration    Welcome to the ShotGrid Pipeline Toolkit!    For documentation, see https://developer.shotgridsoftware.com/d587be80/?title=Integrations+User+Guide    Starting Toolkit for your current path '/sgtk/software/shotgun/scarlet'    - The path is not associated with any ShotGrid object.    - Falling back on default project settings.    - Using configuration 'Primary' and Core v0.15.22    - Setting the Context to Scarlet.    - Running command move_configuration...    ----------------------------------------------------------------------    Command: Move configuration    ----------------------------------------------------------------------    Syntax: move_configuration linux_path windows_path mac_path    This will move the location of the given pipeline configuration.    You can also use this command to add a new platform to the pipeline    configuration.    Current Paths    --------------------------------------------------------------    Current Linux Path:   '/mnt/hgfs/sgtk/software/shotgun/scarlet'    Current Windows Path: 'z: sgtk software shotgun scarlet'    Current Mac Path:     '/sgtk/software/shotgun/scarlet'    You typically need to quote your paths, like this:    &amp;gt; tank move_configuration &quot;/linux_root/my_config&quot; &quot;p: configs my_config&quot;    &quot;/mac_root/my_config&quot;    If you want to leave a platform blank, just just empty quotes. For example, if    you want a configuration which only works on windows, do like this:    &amp;gt; tank move_configuration &quot;&quot; &quot;p: configs my_config&quot; &quot;&quot;示例：    $ cd /sgtk/software/shotgun/scarlet    $ ./tank move_configuration &quot;/mnt/hgfs/sgtk/software/shotgun/scarlet_new&quot; &quot;z: sgtk software shotgun scarlet_new&quot; &quot;/sgtk/software/shotgun/scarlet_new&quot;    Welcome to the ShotGrid Pipeline Toolkit!    For documentation, see https://developer.shotgridsoftware.com/d587be80/?title=Integrations+User+Guide    Starting toolkit for path '/sgtk/software/shotgun/scarlet'    - The path is not associated with any ShotGrid object.    - Falling back on default project settings.    - Using configuration 'Primary' and Core v0.15.22    - Setting the Context to Scarlet.    - Running command move_configuration...    ----------------------------------------------------------------------    Command: Move configuration    ----------------------------------------------------------------------    Current Paths    --------------------------------------------------------------    Current Linux Path:   '/sgtk/software/shotgun/scarlet'    Current Windows Path: 'z: sgtk software shotgun scarlet'    Current Mac Path:     '/sgtk/software/shotgun/scarlet'    New Paths    --------------------------------------------------------------    New Linux Path:   '/mnt/hgfs/sgtk/software/shotgun/scarlet_new'    New Windows Path: 'z: sgtk software shotgun scarlet_new'    New Mac Path:     '/sgtk/software/shotgun/scarlet_new'    The configuration will be moved to reflect the specified path changes.    Note for advanced users: If your configuration is localized and you have other    projects which are linked to the core API embedded in this configuration,    these links must be manually updated after the move operation.    Are you sure you want to move your configuration? [Yes/No] yes    Copying '/sgtk/software/shotgun/scarlet' -&amp;gt; '/sgtk/software/shotgun/scarlet_new'    Copying /sgtk/software/shotgun/scarlet/cache...    Copying /sgtk/software/shotgun/scarlet/config...    Copying /sgtk/software/shotgun/scarlet/config/core...    Copying /sgtk/software/shotgun/scarlet/config/core/hooks...    Copying /sgtk/software/shotgun/scarlet/config/core/schema...    Copying /sgtk/software/shotgun/scarlet/config/env...    Copying /sgtk/software/shotgun/scarlet/config/env/includes...    Copying /sgtk/software/shotgun/scarlet/config/hooks...    Copying /sgtk/software/shotgun/scarlet/config/icons...    Copying /sgtk/software/shotgun/scarlet/install...    Copying /sgtk/software/shotgun/scarlet/install/apps...    Copying /sgtk/software/shotgun/scarlet/install/apps/app_store...    Copying /sgtk/software/shotgun/scarlet/install/core...    Copying /sgtk/software/shotgun/scarlet/install/core/python...    Copying /sgtk/software/shotgun/scarlet/install/core.backup...    Copying /sgtk/software/shotgun/scarlet/install/core.backup/20150518_143244...    Copying /sgtk/software/shotgun/scarlet/install/core.backup/20150518_143940...    Copying /sgtk/software/shotgun/scarlet/install/engines...    Copying /sgtk/software/shotgun/scarlet/install/engines/app_store...    Copying /sgtk/software/shotgun/scarlet/install/frameworks...    Copying /sgtk/software/shotgun/scarlet/install/frameworks/app_store...    Updating cached locations in /sgtk/software/shotgun/scarlet_new/config/core/install_location.yml...    Updating ShotGrid Configuration Record...    Deleting original configuration files...    All done! Your configuration has been successfully moved.手动移动工作流配置                    重要信息: 如果尚未移动工作流配置，我们强烈建议使用上述内置的 tank 命令来自动执行此操作。    如果您已经开始手动移动数据，但遇到了困难，请按照以下说明，了解您需要更改的内容，以确保 Toolkit 此时继续在新位置使用您的工作流配置。      将您的工作流配置文件移动到新位置     $ mv /sgtk/software/shotgun/scarlet /mnt/newserver/sgtk/software/shotgun/scarlet_new            编辑 install_location.yml，以帮助 Toolkit 找到工作流配置所在的位置：     $ vi /mnt/newserver/sgtk/software/shotgun/scarlet_new/config/core/install_location.yml        更新此文件中的路径，以指向工作流配置在所有适用平台上的新位置。如果您未使用平台，请输入空字符串 ''     # ShotGrid Pipeline Toolkit configuration file # This file was automatically created by setup_project # This file reflects the paths in the primary pipeline # configuration defined for this project. Windows: 'Y: sgtk software shotgun scarlet_new' Darwin: '/mnt/newserver/sgtk/software/shotgun/scarlet_new' Linux: '' # End of file.            在 ShotGrid 中找到与此项目对应的 PipelineConfiguration 实体，并修改“Linux 路径”(Linux Path)、“Mac 路径”(Mac Path)和“Windows 路径”(Windows Path)字段值，以匹配您在上面所做的更改。  现在，您的工作流配置应该会在新位置按预期工作。                    注意: 如果使用的是 SG Desktop，您将需要导航退出您的项目，然后再次单击项目图标，以便从新位置重新加载工作流配置。    ",
    "url": "/18e34e3c/",
    "relUrl": "/18e34e3c/"
  },
  "84": {
    "id": "84",
    "title": "如何将我的项目目录移动到新的本地存储根目录？",
    "content": "如何将我的项目目录移动到新的本地存储根目录？                    注意: 在项目进行中移动项目可能带来很多影响，甚至会超出 ShotGrid Toolkit。 切勿草率。    有时，需要将项目文件（场景文件、渲染等）移动到新的根存储位置（例如，从 /mnt/smalldrive 移动到 /mnt/bigdrive/foo）。无论您使用的单存储配置还是多存储配置，都可以执行此操作。例如，假设要移动名为“asset_storage”的存储：  将项目文件从旧位置复制（或移动）到新位置。      在 ShotGrid 中，导航到“管理 &amp;gt; 站点偏好设置”(Admin &amp;gt; Site Preferences)页面并打开“文件管理”(File Management)部分。        将含有每个平台路径的“primary”本地文件存储更新为项目文件的新存储。如果您使用的不是特定平台，请将其留空。  单击页面顶部或底部的“保存更改”(Save Changes)按钮。  更新项目配置中的 config/core/roots.yml 文件以匹配刚刚在 ShotGrid 中保存的新路径值。Toolkit 将发布路径保存为存储根的相对路径。因此，使用旧存储根时，路径展开为如下所示：[asset_storage]/assets/Character/betty =&amp;gt; /mnt/smalldrive/assets/Character/betty使用新存储根定义时，该路径将展开为如下所示：[asset-storage]/assets/Character/betty =&amp;gt; /mnt/bigdrive/foo/assets/Character/betty我们不需要担心在 ShotGrid 或 Toolkit 中更新任何其他发布信息！                    警告: 上述步骤假设您正在重新指定现有存储根的路径。相反，如果您放弃现有存储根或创建一个新的存储根，则您将需要重新注册您的所有文件夹并重新发布 PublishedFiles 实体。    参考如果您的任何场景文件中含有指向旧路径的参考，您将需要自行更新这些参考，或者创建符号链接，以确保系统对其进行正确解析。版本(Versions)如果 ShotGrid 中的版本实体在受此更改影响的“影片路径”(Path to Movie)或“帧路径”(Path to Frames)字段中存储信息，也需要对这些字段进行更新以指向新位置，因为这些字段是包含媒体绝对路径的字符串字段。",
    "url": "/9aaa493a/",
    "relUrl": "/9aaa493a/"
  },
  "85": {
    "id": "85",
    "title": "找不到程序“MTsetToggleMenuItem”",
    "content": "找不到程序“MTsetToggleMenuItem”相关的错误消息：Maya 在加载完整窗口之前、显示常见启动屏幕之后崩溃：  找不到程序“MTsetToggleMenuItem”如何修复：启动 Maya 之前，在 before_app_launch 挂钩中，可能有某些内容被意外从路径中移除，从而导致 Maya 启动时出错。在这种情况下，将 Python 安装添加到 PTHONPATH 会阻止 Maya 2019 查找插件路径。导致此错误的原因示例：用户遇到了多个问题，因为此挂钩确保 C: Python27 已设置为 PYTHONPATH，并且他们实际上已使用此 PYTHONPATH 安装工作站。在社区中查看完整主题。",
    "url": "/74106124/",
    "relUrl": "/74106124/"
  },
  "86": {
    "id": "86",
    "title": "应用商店不包含名为 my-app 的项",
    "content": "错误: 应用商店不包含名为 my-app 的项如何修复：这与自定义应用上的位置描述符有关 - 查看此文档。对于位置，请使用路径描述符设置 my-app - 请在此处了解详细信息。导致此错误的原因示例：tk-multi-snapshot 未显示在 Maya 中，尝试使用 tank 验证时，如果尝试验证自定义应用，则会显示此错误，指出它不在应用商店中。在社区中查看完整主题。",
    "url": "/226a0069/",
    "relUrl": "/226a0069/"
  },
  "87": {
    "id": "87",
    "title": "当我设置 NUKE_PATH 环境变量时为什么 Nuke 集成无法启动？",
    "content": "当我设置 NUKE_PATH 环境变量时为什么 Nuke 集成无法启动？启动 NUKE 时，我们的集成会设置 NUKE_PATH 环境变量，以便引导脚本在 NUKE 启动过程中运行。tk-multi-launchapp 在执行 before_launch_app.py 挂钩之前专门定义了 NUKE_PATH。如果在启动过程中使用 os.environ['NUKE_PATH'] = &quot;/my/custom/path&quot; 等设置此环境变量，ShotGrid 集成将无法启动，因为您已从环境变量删除我们的启动脚本路径。请在 tank.util 中使用此功能，以便将路径附加到 NUKE_PATH 环境变量，同时保留 Toolkit 引导的路径：tank.util.append_path_to_env_var(&quot;NUKE_PATH&quot;, &quot;/my/custom/path&quot;)此外，也可以使用 prepend_path_to_env_var() 附加路径。",
    "url": "/fc2af72c/",
    "relUrl": "/fc2af72c/"
  },
  "88": {
    "id": "88",
    "title": "脱机使用和禁用自动更新",
    "content": "离线使用和禁用自动更新  自动更新          哪些部分会自动更新？      哪些部分不会自动更新？        离线使用集成          初始设置      管理更新        禁用自动更新          在项目级别或站点级别禁用更新      针对除一个项目以外的其他所有项目禁用更新      升级      自动更新哪些部分会自动更新？默认情况下，ShotGrid Desktop 将自动检查更新，并在找到更新时将其安装到本地计算机。它会检查两个组件的更新：  tk-framework-desktopstartup - 用于帮助启动 ShotGrid Desktop 的框架。  tk-config-basic - 默认站点配置。该配置用作保存 ShotGrid Desktop 应使用的应用、插件、框架和核心版本的清单文件。更新该配置也可能会更新其中的任何组件。找到的任何更新都将下载并存储在用户的本地缓存中，而不是修改原始的 ShotGrid Desktop 安装文件。ShotGrid Create 作为应用程序，具有与 ShotGrid Desktop 不同的独立更新机制，此处未涵盖此内容。但是 ShotGrid Create 中提供的集成功能以类似的方式工作，而且还会将 tk-config-basic 自动更新到同一用户缓存中。哪些部分不会自动更新？      如果您已接管站点配置，则系统不会检查是否有较新的 tk-config-basic 更新，相关详细信息请见下文。        未使用默认站点配置的任何项目（即，对其运行了 Toolkit 高级设置向导的项目）的配置不会自动更新。        与 ShotGrid Desktop 捆绑在一起的资源（如 Python 和 QT）不会自动更新。 我们有时会在需要更新这些部分时发布新的 ShotGrid Desktop 安装程序。  离线使用集成初始设置如果您的工作室 Internet 访问受限或无法访问 Internet，则需要确保在本地缓存所需的所有部分。您仍需要一台可以连接到 Internet 的计算机，以便下载 ShotGrid Create 或 ShotGrid Desktop。ShotGrid Desktop 预先打包了运行基本集成所需的所有依存项。虽然 ShotGrid Create 也捆绑了这些依存项，但您仍需按照管理更新中提及的步骤进行操作。启动任一项后，它将自动尝试查找更新，但如果无法连接到 ShotGrid 应用商店，它将仅运行本地的最新版本。建议在安装 ShotGrid Desktop 后，按照下面的管理更新步骤操作，因为与安装程序捆绑在一起的组件可能不是最新组件。                    注意: 根据您的网络设置情况，有时可能即使无法访问更新，也会一直尝试联机查找更新。在这种情况下，您可以将环境变量 SHOTGUN_DISABLE_APPSTORE_ACCESS 设置为 &quot;1&quot; 以阻止其尝试查找更新。                        注意: 您仍然需要能够连接到 ShotGrid 站点。 我们所说的离线是指无法连接到我们的应用商店来下载更新。    管理更新要更新 tk-framework-desktopstartup 组件，您需要下载最新版本，并将环境变量 SGTK_DESKTOP_STARTUP_LOCATION 设置为指向其在磁盘上的位置（这仅适用于 ShotGrid Desktop）。对于 tk-config-basic 组件，由于它的所有依存项，情况有点棘手。  在连接到 Internet 的工作站上运行 ShotGrid Desktop 或 ShotGrid Create。 当它启动时，将会自动下载最新升级。（确保未在此计算机上设置 SHOTGUN_DISABLE_APPSTORE_ACCESS。）  将缓存复制到所有计算机都可以访问的共享位置。  在离线计算机上设置 SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS 环境变量以指向此位置。  在离线计算机上启动 ShotGrid Desktop 或 ShotGrid Create 后，它们将选取缓存中可用的最新升级。                    警告: 根据您的网络设置情况，有时可能即使无法访问更新，也会一直尝试联机查找更新。在这种情况下，您可以将环境变量 SHOTGUN_DISABLE_APPSTORE_ACCESS 设置为 &quot;1&quot; 以阻止其尝试查找更新。    禁用自动更新在项目级别或站点级别禁用更新                    注意: 如果可能，我们建议您继续允许自动更新，以免错过新功能和错误修复。    要对集成禁用自动更新，请按照以下步骤操作。  确定要使用的版本。您可以在此处查找集成版本。      在 ShotGrid 中，在项目或全局页面上创建工作流配置实体，并填充以下字段（在此示例中，我们将配置锁定为使用集成 v1.0.36）：          名称(Name)：Primary      项目(Project)：如果希望对所有项目禁用更新，请保留为空；如果仅希望锁定单个项目，请选取特定项目。      插件 ID(Plugin ids)：basic.*      描述符(Descriptor)：sgtk:descriptor:app_store?name=tk-config-basic&amp;amp;version=v1.0.36                启动 ShotGrid Desktop，如果将“项目”(Project)字段留空，则 ShotGrid Desktop 将切换为使用此版本（如果尚未使用此版本）。        如果设置项目，则只有该项目会受到影响，您在 ShotGrid Desktop 的“关于”(About)窗口中看不到变化。    [可选] 要锁定 tk-framework-desktopstartup 的版本，您需要下载最新版本，并将环境变量 SGTK_DESKTOP_STARTUP_LOCATION 设置为指向其在磁盘上的位置（这仅适用于 ShotGrid Desktop）。大部分功能由配置控制（这可以按上述步骤锁定），但是，如“哪些部分会自动更新？”部分中所述，组件也会更新，并且与配置分开处理。这也仅适用于 ShotGrid Desktop。补充知识  您无需手动下载配置版本，ShotGrid Desktop 会在启动或您进入项目时予以处理。  basic.* 表示基本配置中的所有插件都将选取此覆盖。例如，如果您想要仅冻结 Nuke 和 Maya 集成，可以指定 basic.maya 和 basic.nuke。  要进行测试，您可以创建此工作流配置实体的副本，并将您的用户名添加到 User Restrictions 字段中。这将限制该实体，使其仅可供您使用，而不会影响其他用户。然后，您可以从此配置副本启动 Maya 或某些其他软件，并确认它运行的是预期的集成版本。      将“项目”(Project)字段留空就是我们所说的站点配置。ShotGrid Desktop 使用站点配置，因为它在项目外运行。 在 ShotGrid Desktop 中选择项目时，它也会加载项目配置。    Flame 集成的命名空间为 basic.flame，从表面上看应该包含在 basic.* 中。 但实际上 Flame 集成并不包含在基本配置中。因此，如果您在某个项目中使用 Flame，然后执行此覆盖，则 Flame 集成将停止工作。 解决方案是专门为 Flame 创建另一个工作流配置覆盖：          配置名称(Config Name)：Primary      项目(Project)：要锁定的项目（如果要锁定所有项目，则为空）      插件 ID(Plugin ids)：basic.flame      描述符(Descriptor)：sgtk:descriptor:app_store?name=tk-config-flameplugin      针对除一个项目以外的其他所有项目禁用更新如果您已经对上述示例中提到的所有项目禁用了更新，但希望对特定项目启用更新您可以  如上一部分中所述，对站点禁用更新。  使用以下字段值配置例外项目的工作流配置实体：          配置名称(Config Name)：Primary      项目(Project)：不希望锁定的项目      插件 ID(Plugin ids)：basic.*      描述符(Descriptor)：sgtk:descriptor:app_store?name=tk-config-basic  在“描述符”(Descriptor)字段中忽略版本号后，项目现在将跟踪基本配置的最新版本。      升级在更新配置时，您可能希望先测试更新版本，然后再将其推给所有用户。  通过右键单击并选择“复制选定项”(Duplicate Selected)，在 ShotGrid 中复制工作流配置实体。  将克隆的配置命名为“update test”，并在“用户限制”(User Restrictions)字段中指定您自己。  现在，您将开始使用此工作流配置。  将“描述符”(Descriptor)更改为指向要测试的版本。  您可以根据需要在 User Restrictions 字段中添加用户以邀请他们参与测试。  对测试满意后，只需将主工作流配置更新为使用该版本即可。  用户重新启动 ShotGrid Desktop 并在 ShotGrid 集成运行的情况下重新启动当前打开的任何软件后，将会立即获取更新。",
    "url": "/b31ed3ef/",
    "relUrl": "/b31ed3ef/"
  },
  "89": {
    "id": "89",
    "title": "Onboarding Process",
    "content": "Onboarding ProcessLeveraging the isolation features requires adopters to become AWS users. In order to ensure that this joint venture between Autodesk, AWS, and our clients is as streamlined as possible, we decided to work closely with AWS to define a cooperative onboarding process that would meet client expectations for a premium offering.Autodesk will provide dedicated resources during the onboarding process to help you on this journey.To start the on-boarding process for any of the Isolation features, please fill out this short survey, before proceeding with your setup.Onboarding Process OverviewDuring the onboarding process, you’ll have direct access to Autodesk resources who will support you during the implementation.Setup / Test / Activation:	Iterative installation process where you connect your AWS resources to ShotGrid, and activate the isolation features.Onboarding ResourcesShotGrid Community: The ShotGrid Isolation Community forum can be used to ask questions that can be answered by either ShotGrid Experts or other isolation features users. This should be your first stop when asking general questions about isolation features, during setup and beyond.Dedicated Microsoft Teams team: During the onboarding, you will be given access to a Microsoft Teams team. Your ShotGrid leaders will be available for quick feedback, answers, and ad-hoc meetings to help you progress as fast as possible with your ShotGrid Isolation setup. This channel will be available only for the onboarding period.ShotGrid Support: A ShotGrid Support ticket will be used to track your onboarding at a higher level. Once your ShotGrid Isolation setup is complete, follow-up support tickets can be opened with the support team as needed.Next StepsOnce the onboarding process is started, you can start thinking about your setup",
    "url": "/f66c5afa/",
    "relUrl": "/f66c5afa/"
  },
  "90": {
    "id": "90",
    "title": "其他集成",
    "content": "其他集成借助 ShotGrid 的 API，您可以集成许多第三方软件包。但是，ShotGrid 本身已经集成了一些软件包。cineSyncCineSync 允许您在多个位置之间同步播放。ShotGrid 的集成允许您创建版本播放列表，在 CineSync 中播放该列表，并将在会话期间创建的注释发送回 ShotGrid。有关详细信息，请参见 https://www.cinesync.com/manual/latest。DeadlineShotGrid+Deadline 集成允许您自动将包含缩略图、指向帧的链接和其他元数据的渲染版本提交到 ShotGrid。有关详细信息，请参见 https://docs.thinkboxsoftware.com/products/deadline/5.2/User%20Manual/manual/shotgunevent.html。Rush与 Deadline 集成很像，ShotGrid+Rush 集成允许您自动将包含缩略图、指向帧的链接和其他元数据的渲染版本提交到 ShotGrid。有关详细信息，请参见 https://seriss.com/rush-current/index.html。Subversion (SVN)ShotGrid 简单而灵活的集成（我们在内部使用），让我们可以跟踪修订并将其链接至 ShotGrid 中的工单和发布版本。我们还提供了指向 Trac 的链接以与外部 Web SVN 库查看器集成。操作方法为：向 SVN 添加一个发布-提交挂钩，这是一个 ShotGrid API 脚本，用于从提交中获取某些环境变量，然后在 ShotGrid 中创建一个修订实体，并在其中填充各种字段。可以对其进行修改以满足您的工作室的需求，由于它仅使用 API，因此可以用于本地或托管安装。有关详细信息，请参见 https://subversion.apache.org/docs。",
    "url": "/f0ee6c48/",
    "relUrl": "/f0ee6c48/"
  },
  "91": {
    "id": "91",
    "title": "路径“&lt;PATH&gt;”已与 {% include product %} 实体“&lt;ENTITY&gt;”关联",
    "content": "数据库并发问题：路径 &amp;lt;PATH&amp;gt; 已与 ShotGrid 实体 &amp;lt;ENTITY&amp;gt; 关联相关的错误消息：  数据库并发问题: 路径 &amp;lt;PATH&amp;gt; 已与 ShotGrid 实体 &amp;lt;ENTITY&amp;gt; 关联。  无法解析路径的行 ID！示例：当 Toolkit 用户尝试创建文件夹时，会发生此错误。以下是完整错误：ERROR: Database concurrency problems: The path'Z: projects SpaceRocks shots ABC_0059' is already associated withShotgun entity {'type': 'Shot', 'id': 1809, 'name': 'ABC_0059'}. Please re-runfolder creation to try again.导致错误的原因是什么？当您尝试为已具有 FilesystemLocation 实体的文件夹创建 FilesystemLocation 实体时，会发生这种情况。如何修复清除错误的 FilesystemLocation 实体。如果可以缩小到一组错误的 FilesystemLocation 实体，只需移除这些实体即可。但是，在许多情况下，项目的所有路径都会受到影响，因此它们都需要处理。  如何清除 FilesystemLocation 实体：理想情况下，您可以运行 tank unregister_folders。要清除所有这些，请运行 tank unregister_folders --all。（对于 tank unregister_folders 的所有选项，只需运行它而不使用任何参数，它将输出用法说明。）  但是，由于数据库已处于不稳定状态，因此这可能不起作用，或者可能仅部分起作用。运行该命令后，返回到 ShotGrid 中的 FilesystemLocations，确认您预期删除的内容已消失。如果没有，请选择坏实体，然后手动将其移动到垃圾桶。此时，ShotGrid 中的 FilesystemLocations 是干净的，但艺术家的本地缓存可能不反映您所做的更改。最后一步是实际同步每个用户计算机上的本地缓存。为此，应运行 tank synchronize_folders --full。执行所有这些步骤后，缓存路径应处于良好状态，并且不再显示错误。相关链接  下面是相关代码  什么是缓存路径？什么是文件系统位置？在社区中查看完整主题。",
    "url": "/3636e362/",
    "relUrl": "/3636e362/"
  },
  "92": {
    "id": "92",
    "title": "由于 Windows 路径太长而导致的错误",
    "content": "由于 Windows 路径太长（&amp;gt; 256 个字符）而导致的错误确凿的事实Windows 对路径名的默认限制非常宽松，即 255 个/260 个字符。Microsoft 在此提供了有关此限制的信息，您可以在此处查看更多技术信息。错误该错误会以各种方式表现出来，但通常在 SG Desktop 首次加载配置时发生，会在将项目下载到缓存时遇到此错误。尽管 Windows 10 的最新版本似乎对该错误有所改善，但该错误可能有些隐秘。下面是您可能会看到的一些示例：[ WARNING] Attempt 1: Attachment download of id 3265791 from https://xxxxx.shotgunstudio.com failed: [Error 206] The filename or extension is too long: 'C:  Users  xxxxx  AppData  Roaming  Shotgun  bundle_cache  tmp  0933a8b9a91440a2baf3dd7df44b40ce  bundle_cache  git  tk-framework-imageutils.git  v0.0.2  python  vendors  osx  lib  python2.7  site-packages  pip  _vendor  requests  packages  urllib3  packages  ssl_match_hostname'[ WARNING] File 'c: users xxxxx appdata local temp ab35bd0eb2b14c3b9458c67bceeed935_tank.zip' could not be deleted, skipping: [Error 32] The process cannot access the file because it is being used by another process: 'c:  users  xxxxx  appdata  local  temp  ab35bd0eb2b14c3b9458c67bceeed935_tank.zip'ERROR sgtk.core.descriptor.io_descriptor.downloadable] Failed to download into path C: Users xxxxx AppData Roaming Shotgun bundle_cache tmp 123456789012a34b567c890d1e23456: Failed to download sgtk:descriptor:shotgun?entity_type=PipelineConfiguration&amp;amp;field=uploaded_config&amp;amp;id=38&amp;amp;version=123456 from https://xxxxx.shotgunstudio.com. Error: Failed to download from 'https://xxxxx.shotgunstudio.com' after 5 retries. See error log for details.. Attempting to remove it.WARNING sgtk.core.util.shotgun.download Attempt 4: Attachment download of id 1182 from https://xxxxx.shotgunstudio.com failed: [Errno 2] No such file or directory: 'C:  Users  xxxxx  AppData  Roaming  Shotgun  bundle_cache  tmp  dd2cc0804122403a87ac71efccd383ea  bundle_cache  app_store  tk-framework-desktopserver  v1.3.1  resources  python  build  pip  _vendor  requests  packages  urllib3  packages  ssl_match_hostname  _implementation.py'WARNING sgtk.core.util.filesystem File 'c: users xxxxx appdata local temp 08f94bfe9b6d43e7a7beba30c192a43c_tank.zip' could not be deleted, skipping: [Error 32] The process cannot access the file because it is being used by another process: 'c:  users  xxxxx  appdata  local  temp  08f94bfe9b6d43e7a7beba30c192a43c_tank.zip'ERROR sgtk.core.descriptor.io_descriptor.downloadable] Failed to download into path C: Users xxxxx AppData Roaming Shotgun bundle_cache tmp dd2cc0804122403a87ac71efccd383ea: Failed to download sgtk:descriptor:shotgun?entity_type=PipelineConfiguration&amp;amp;field=sg_uploaded_config&amp;amp;id=1&amp;amp;version=1182 from https://xxxxx.shotgunstudio.com. Error: Failed to download from 'https://xxxxx.shotgunstudio.com' after 5 retries. See error log for details.. Attempting to remove it.ERROR sgtk.core.bootstrap.cached_configuration Failed to install configuration sgtk:descriptor:shotgun?entity_type=PipelineConfiguration&amp;amp;field=sg_uploaded_config&amp;amp;id=1&amp;amp;version=1182. Error: Failed to download into path C: Users xxxxx AppData Roaming Shotgun bundle_cache tmp dd2cc0804122403a87ac71efccd383ea: Failed to download sgtk:descriptor:shotgun?entity_type=PipelineConfiguration&amp;amp;field=sg_uploaded_config&amp;amp;id=1&amp;amp;version=1182 from https://xxxxx.shotgunstudio.com. Error: Failed to download from 'https://xxxxx.shotgunstudio.com' after 5 retries. See error log for details.. Cannot continue.为什么会发生这种情况在 Windows 上，ShotGrid Desktop 将数据存储在 %APPDATA% 文件夹（通常为 C: Users jane AppData Roaming Shotgun）。当使用标准 default2 Toolkit 配置时，只要您的用户名不是超长，就应该没问题。但是，如果要创建自己的应用、插件或框架，则可能会有更大的风险遇到这种情况，尤其是当您将依存项与代码捆绑在一起（像我们一样），并且您的包中有很深的目录树时。解决该问题解决该问题的方法通常是，将 $SHOTGUN_HOME 环境变量设置为非常短的值，如 C: SG。这会告知 SG Desktop 将其数据存储在 C: SG 而不是 C: Users jane AppData Roaming Shotgun 中，这样可以少使用一些字符，通常足以使路径名保持在限制范围内。您可以在此处阅读有关环境变量的信息。未来的可能性？在 Windows 10 的最新版本中，还有另一种方法或许可以缓解此问题，即按此处所述更新注册表，但我认为还需要 SG Desktop 更新其清单文件，以表明它要利用 longPathAware 设置。我是 Mac 用户，因此我不确定我说的是否有用。在社区中查看完整主题",
    "url": "/aed84d1f/",
    "relUrl": "/aed84d1f/"
  },
  "93": {
    "id": "93",
    "title": "性能疑难解答",
    "content": "性能疑难解答您可能会遇到 Toolkit 使用速度变慢的情况。遇到这种情况的原因有很多，从客户端基础设施问题（例如服务器速度或 Internet 连接），到基于配置的问题（Toolkit 或 ShotGrid 没有以高性能的方式配置），再到可用于进一步优化的代码领域。以下是所要检查事项的快速列表，下面我们将详细介绍这些内容：  确保您的应用、插件、框架、核心和 ShotGrid Desktop 都是最新的。  确保在常规使用期间没有启用调试日志记录。  仅创建所需的文件夹并限制文件夹，以便仅在确实需要这些文件夹时才创建它们。在数据结构中添加太多文件夹会降低速度。  将用户缓存存储在服务器上可能会很慢。通过将 ShotGrid_HOME 环境变量设置为指向本地驱动器上的位置，来重定向用户的 ShotGrid 缓存。  配置 Workfiles 和加载器应用以过滤出艺术家不需要的内容。考虑按状态进行过滤，这有助于保持实体列表简短且与美工人员的当前任务相关。  检查您是否有任何自定义挂钩，并且它们不会增加额外开销。下面列出了一些良好做法和常见的性能下降场景。这不是一个详尽的列表，当我们看到新的模式时，可以尝试将它添加到列表中。如果本手册不能帮助您找到您所面临问题的根源，请随时提交支持工单，我们的团队将很乐意进一步帮助您。目录：  常规良好做法          缓存位置      保持最新      集中式配置与分布式配置      调试        启动软件时速度很慢          诊断      问题是在启动前还是启动后发生？      检查日志      软件启动速度慢的常见原因        “File Open”、“File Save”或加载器应用很慢？  文件夹创建速度很慢          解决 I/O 使用问题      注册文件夹      常规良好做法缓存位置ShotGrid Toolkit 将数据缓存到用户的主目录。此缓存可以包括许多不同的 SQLite 数据库以及缓存的应用和配置。通常，用户的主目录存储在计算机的本地硬盘驱动器上，但是工作室将它们重定向到网络存储是相当常见的。这样做会影响性能，尤其是 SQLite 数据库，这些数据库用于浏览器集成和文件夹创建/查找等。如果您的用户目录存储在服务器位置，我们建议使用 ShotGrid_HOME 环境变量重新指定 ShotGrid Toolkit 缓存的路径。ShotGrid_HOME 环境变量用于设置 Toolkit 缓存各种数据的位置，例如缓存、缩略图、用于快速查找数据和其他内容的 SQLite 数据库。调试您可以在 ShotGrid Toolkit 中启用调试日志记录，以便能够从各个进程获取更详细的输出。这在尝试诊断问题时非常有用，但是，调试设置不是设计为在日常使用期间启用的。日志记录输出的增加可能会对性能产生显著影响。当遇到性能问题时，尤其是局限于特定计算机或用户的问题时，请先确认未启用调试日志记录。保持更新如果您遇到性能问题，请检查您的核心、应用、插件和框架是否最新，因为较新版本中可能已经进行了修复或优化。集中式配置与分布式配置可以采用两种不同的方法设置高级 Toolkit 配置：集中式和分布式。主要区别是，集中式配置通常位于工作室的网络存储中，所有用户都可以访问这些配置，分布式配置通常存储在相关服务中，并按用户在本地缓存。虽然这两种方法之间的差异超出了性能范围，但它们都会在性能方面带来一些优点和缺点。下表仅从性能角度展示了利弊。                   优点      缺点                  集中式配置      - 一旦初始设置过程完成，它所需的一切内容均已下载，可供所有用户使用。      - 集中式配置通常保存在网络存储中，因此在正常的 Toolkit 使用期间性能可能会降低。                     - 未来的更新只需要在集中位置下载一次。      - Toolkit 配置包含许多小文件，处理大量小文件的元数据操作对服务器而言可能要慢得多，也更难。此外，通过使用 Toolkit 或通过常规使用服务器进行大量读取操作可能会因为无法快速读取配置而影响 Toolkit 的性能。              分布式配置      - 缓存的应用、插件、框架和核心采用一种可以与其他本地缓存的配置共享的方式存储。这意味着，如果不同的项目共享相同的依赖项，则这些项目的后续加载可能会更快地缓存。      - 分布式配置需要按用户在本地缓存。通常，这包括下载配置和所有必需的应用、插件、框架和核心。                     - 它们存储在用户本地硬盘驱动器上的缓存中，因此通常比服务器速度更快。这意味着，在初始缓存后，性能应该优于集中式配置。      - 这一过程会在后台无缝进行，但是仍然需要下载这些文件的初始成本。                            - 每次更新配置以指向依赖项的新版本时，都需要缓存配置和新的依赖项。      总之，如果您的存储速度较慢，但是 Internet 连接良好，那么分布式配置可能是最佳的解决方案，但是如果您的服务器存储性能很好，而 Internet 连接很差，那么集中式配置可能更合适。                    注意: 如果您对分布式配置感兴趣，但担心按计算机下载依赖项，则可以仅集中缓存，以便在所有用户之间共享。    当使用分布式配置时，用户只需在缓存中找不到相关内容时才下载它，一旦某个用户已下载它，其他用户也能够利用它。为此，您可以在每台计算机上设置 ShotGrid_BUNDLE_CACHE_PATH 环境变量以指向共享位置。启动软件时速度很慢您可能会注意到，当启动诸如 Maya、Nuke、Houdini 或其他软件时，启动时间比不带 ShotGrid 时要长。这是正常的，它们可能比不带 ShotGrid 时稍长片刻，但有时这些时间可能会增加到难以接受的水平（通常取决于我们期望它们在一分钟内启动的软件）。这可能是诊断起来比较棘手的的领域之一，因为启动软件涉及许多过程。诊断首先要做的是弄清楚这是在什么条件下发生的。  不带 ShotGrid 时启动速度慢吗？ - 这似乎是显而易见的，但应注意检查是否仅在带有 ShotGrid 的情况下启动软件时才发生该问题。  不管您使用哪种方法启动，速度都很慢吗？也就是说，如果您从 SG Desktop 启动或使用浏览器集成从 SG 站点启动，情况是否大致相同？ - 如果是从 ShotGrid 站点而不是从 SG Desktop 启动很慢，那么这可能是浏览器集成的问题，或者它可能意味着在磁盘上创建文件夹的问题。如果是从项目以外的上下文启动，那么很可能是在磁盘上创建了更多文件夹，所以这可能解释了所花的时间。同样值得注意的是，每次启动软件时，我们都会检查所需的文件夹是否存在。  是否在所有项目中都发生？ - 如果不是，那么它很可能特定于配置的设置方式。  是否发生在一天中的特定时刻？ - 如果是，那么这可能表明对基础设施的需求较高，例如在一天的某些时间服务器使用率较高。  是否针对使用的所有计算机/操作系统发生此情况？ - 如果特定计算机速度很慢，则可能是 Toolkit 以外的某些内容导致了问题。那么，首先想到是清除该计算机上的 Toolkit 缓存。不同的操作系统随附不同版本的软件和 Python 软件包，有时可能在特定的内部版本中出现性能问题。具体来说，我们已经看到在 Windows 上使用 Samba (SMB) 共享的性能问题。目前还没有解决此问题的方法，但是如果您正在使用它，那么最好能够意识到这一点。如果您认为该问题仅限于特定的操作系统、Python 软件包或软件版本，请联系我们的支持团队，以便他们可以进一步调查。  是否针对所有用户都发生这种情况？ - 与上文类似，如果是同一台计算机上的其他用户，这个问题可能会消失。在这种情况下，首先清除用户的本地 ShotGrid 缓存。此外，请确保没有为正常的生产用途启用调试日志记录，因为这将影响性能。  启动速度慢局限于特定的应用/软件，还是所有应用/软件的启动速度都异常缓慢？ - 如果特定软件启动缓慢，这可能意味着存在配置问题。可能有必要检查一下，是否有任何自定义挂钩设置为在启动之前或之后运行，这可能会影响性能。启动时使用的常见挂钩是 before_app_launch.py、app_launch.py 和核心挂钩 engine_init.py。有时也会出现以下情况：发布了更新版本的软件，而我们的集成启动速度突然慢很多。在这种情况下，您应该联系支持团队以确认他们是否了解这一点，以及是否有任何已知的修复。请提供您使用的软件版本号（如果适用，包括修补程序/Service Pack），以及您正在运行的 TK 插件和核心的版本。问题是在启动前还是启动后发生？如果上述内容没有帮助您缩小问题的范围，那么下一步就是确定在启动过程中什么地方出现了问题。当通过 Toolkit 启动软件时，通常可以将其归结为两步过程。第一步执行一些初始操作，例如收集启动软件所需的信息，从上下文中自动创建文件夹，然后实际启动软件。一旦软件启动，该过程的第二步就会启动 Toolkit 集成。通常，不需要查看日志，就可以看到性能问题是在该过程的第一步还是第二步：  观察软件启动屏幕的启动是否需要很长时间。如果确实如此，则问题可能就在第一步。  看到开始时软件相对较快地启动，但随后变得很慢（在完成初始化并出现 ShotGrid 菜单后）。如果是这样，则问题属于第二步。了解这一点将在接下来的查看日志中对您有所帮助。检查日志现在，您应该知道问题是在启动过程的第一步还是第二步；这将帮助您锁定要查看的日志。日志按插件进行分解，因此，如果问题出现在启动前阶段，那么您需要查看 tk-desktop.log 或 tk-ShotGrid.log，具体取决于您是从 SG Desktop 还是 SG 站点启动。接下来应该做的是启用调试日志记录。                    注意: 如果它已经启用，如上文所述，这可能会导致运行缓慢，所以您还应该在没有启用它的情况下进行测试    启用调试日志记录后，应清除现有日志，然后重现启动过程。然后，您可以使用日志中的时间戳来查看时间跳转出现在何处。例如，以下是在文件夹创建期间发生 5 秒时间跳转的几行代码：2019-05-01 11:27:56,835 [82801 DEBUG sgtk.core.path_cache] Path cache syncing not necessary - local folders already up to date!2019-05-01 11:28:01,847 [82801 INFO sgtk.env.asset.tk-shotgun.tk-shotgun-folders] 1 Asset processed - Processed 66 folders on disk.一旦定位了时间跳转，日志行就有望让您了解在该阶段发生了什么，例如它是在文件夹创建期间发生的，还是在试图获取 ShotGrid 连接时发生的。不过，阅读日志可能比较麻烦，而且内容并不总是有意义，因此，您可以再次联系支持团队来帮助您完成这一点。软件启动速度慢的常见原因            Internet 速度慢      在需要与 ShotGrid 站点连接和通信的 Toolkit 使用的几乎每个方面都会受到 Internet 速度慢的影响。在这种情况下，除了启动软件外，通常还会在其他情况下看到速度问题。但是，如果连接不稳定而不是很慢，那么在启动过程中更有可能遇到性能问题（因为在整个过程中要进行相当多的 ShotGrid 通信）。              服务器访问速度慢      这肯定会影响启动时间。如果使用的是集中式配置（即，您的配置存储在中央服务器上），则在读取配置文件时可能会有大量的 I/O。最重要的是，如果启动软件，则会触发在启动软件的上下文中创建文件夹。这意味着，它将检查是否创建了文件夹，如果没有，则创建文件夹。              文件夹创建      如上所述，文件夹创建可能是导致速度下降的常见原因。有关详细信息，请参见下面的文件夹创建性能疑难解答。      “File Open”、“File Save”或加载器应用很慢？首先要做的是将问题范围缩小到相关应用速度慢的某些方面。  启动应用或浏览选项卡是否很慢？          有可能是该应用当前配置为显示太多信息。可以将“我的任务”(My Tasks)选项卡和其他选项卡配置为从列表中过滤出不需要的实体。例如，您可以过滤出处于特定状态的任务，例如“暂停”(On Hold) (hld) 或“最终”(Final) (fin)。这不仅提供了性能优势，而且还让美工人员仅看到对他们来说重要的信息。可以过滤加载器应用和 Workfiles 应用，但是过滤时 Workfiles 目前没有特定的文档部分，不过过滤器可以作为层次结构设置的一部分应用。      “File Open”应用的层次结构也可以配置为延迟加载子项直到它被展开。现在这是默认的配置设置，但是，如果您有较旧的配置，则可能希望过渡到使用该设置。      确认未启用调试日志记录。这可能会导致大量额外的 I/O，因此会降低速度；这些应用确实包含大量的调试输出。        打开、保存或创建新文件时是否很慢？          检查您是否已接管场景操作或动作挂钩，并确定这些功能是否有任何可能会降低速度的自定义行为。      当创建或保存文件时，Workfiles 将确保在上下文中创建所有必需的文件夹。文件夹创建可能是出现性能问题的常见原因。      文件夹创建速度很慢文件夹创建包含许多部分，这可能会导致出现问题时进程变慢。文件夹创建将：  同步本地缓存路径。  读取配置的数据结构。  生成一个路径列表，这些路径应该在特定的上下文中创建。  根据本地存储的路径注册表检查路径。  如果尚未注册，请尝试在 SG 站点和本地注册新路径。  检查以确定文件夹是否实际存在于磁盘上，无论它们是否已注册，如果不存在，则创建文件夹。简而言之，文件夹创建可能会占用可能磁盘上的大量 I/O，还需要写入本地数据库并与 SG 站点通信。解决 I/O 使用问题在处理许多小型读写操作时，您的存储可能很慢或效率很低，因此任何可用于改进基础设施的操作都将有助于加快文件夹创建操作的速度。但是，可以在 Toolkit 配置端执行一些操作，以尝试尽可能地减少负担。首先要做的是将创建的文件夹限制为对该上下文以及您要在其中工作的环境非常重要的文件夹。例如，如果您正在处理 Maya 中镜头的某个任务，那么理想情况下，您只希望针对特定镜头和软件检查并创建文件夹。基本上，创建允许您保存和发布工作的最低必需文件夹。随父文件夹一起创建有一个 create_with_parent 设置，可应用于数据结构文件夹。将其设置为 True 会导致子文件夹随父文件夹一起创建。您应注意避免这种情况，因为将其设置为 True 会导致检查并创建大量的文件夹。示例如果您有一个镜头序列/镜头文件夹层次结构，并将您的镜头文件夹设置为随其父镜头序列一起创建，那么每当创建镜头序列文件夹时，它将检查所有关联的镜头并为其创建文件夹。虽然在某些情况下这可能很方便，但它会导致检查更多的文件夹，并可能同时创建更多的文件夹。在这种情况下，如果您要针对镜头的某个任务在 Workfiles 中创建新文件，则会触发创建镜头的父镜头序列文件夹，进而会创建所有子镜头文件夹，而不仅仅是您正在处理的镜头。                    注意: 工序数据结构文件夹的设置默认为 True。    延迟创建defer_creation 设置允许您将文件夹的创建限制为仅在特定插件运行时进行，从而进一步细化何时应创建文件夹。您甚至可以使用自定义名称，然后使用 sgtk API 触发它们的创建。示例您可能有一组只能在发布阶段创建的文件夹。在这种情况下，您可以将 custom 设置为 maya_publish 的延迟关键字，然后通过 API 创建使用该关键字作为插件名称的文件夹。数据结构中的文件夹可能如下所示：# the type of dynamic contenttype: &quot;static&quot;# defer creation and only create this folder when Photoshop startsdefer_creation: &quot;publish&quot;然后您将使用如下所示的脚本创建文件夹：sgtk.create_filesystem_structure(entity[&quot;type&quot;], entity[&quot;id&quot;], engine=&quot;publish&quot;)扩展示例考虑进一步延迟文件夹，如果在项目的根目录下有许多非动态文件夹，通常只需要创建一次。例如，默认配置的数据结构根目录下的“editorial”和“reference”文件夹可能只需要在项目开始时创建一次，但默认情况下，每次创建文件夹时都将检查它们是否存在。为了限制这一点，可以为它们创建 yml 文件，您可以在其中设置一个延迟关键字，这样只有在特定插件中运行文件夹创建或传递该关键字时才会创建它们。您可以将延迟关键字设置为 tk-shell，然后通过 tank 命令（如 tank folders）运行文件夹创建。这意味着，只有在通过 tank 命令运行文件夹创建时才会创建这些文件夹，这是 Toolkit 管理员在第一次设置项目时可以执行的操作。或者，您可以编写一个小型脚本，使用 custom 关键字运行文件夹创建，类似于上面的示例。注册文件夹在文件夹创建过程中，将注册文件夹，以便将来可以使用这些路径来查找上下文。如前所述，此过程的一部分需要与 ShotGrid 站点进行通信，该站点是存储注册表的中央位置。但是，这些注册表也在本地缓存，以便通过工具更快地进行查找。SQLite 数据库本地缓存路径使用 SQLite 数据库来存储数据。如果数据库存储在网络存储上，那么可能会严重影响数据库的读取和写入性能。初始同步在某些情况下，需要从头开始为一个已经注册了许多文件夹的项目生成本地缓存（例如，当新用户加入已在进行中的项目时）。这个过程可能会明显延长，但令人高兴的是，对于该项目，这种情况应该仅发生一次。后续同步将仅提取本地缓存和站点注册之间的差异。如果用户不经常处理项目，并且在会话之间创建了许多文件夹，那么当所有内容都缓存时，他们可能会明显等待很长时间。我们在这里看到人们采用的一种方法是，将本地缓存的一个合理最新版本传输到用户的计算机。                    注意: 只有在项目中创建了大量文件夹的情况下，才需要使用此方法。    此更新过程可以通过使用核心挂钩 cache_location.py 自动实现。该挂钩可用于设置缓存的位置，而不是更改位置，您可以使用该挂钩将 path_cache.db 文件的一个版本从中央位置复制到用户的默认位置，从而避免执行代价高昂的完全同步。然后，可以通过从某人的缓存手动复制，或者使用脚本定期传输它，来定期更新集中存储的缓存路径。                    警告: cache_location.py 挂钩可用于设置缓存的位置，但是应该避免针对所有用户将此挂钩设置为指向单一位置，因为当一个或多个进程尝试同时编辑数据库时，这可能会导致数据库锁定。    ",
    "url": "/396dd133/",
    "relUrl": "/396dd133/"
  },
  "94": {
    "id": "94",
    "title": "工作流集成组件",
    "content": "工作流集成组件在这里，您可以找到有关 Toolkit 平台组件的参考文档。",
    "url": "/162eaa4b/",
    "relUrl": "/162eaa4b/"
  },
  "95": {
    "id": "95",
    "title": "工作流集成",
    "content": "工作流集成ShotGrid 的工作流集成用于向艺术家提供 ShotGrid 数据。常用内容创建软件中的可自定义 UI 提供了一些即时可用的工具，艺术家可使用这些工具查看其任务信息，阅读和添加注释以及与团队成员共享文件。工作流集成基于 ShotGrid Toolkit 平台构建而成，开发人员可以使用 Toolkit API 扩展功能或创建自定义 Toolkit 应用。本部分包含可帮助您在管理 ShotGrid 工作流时快速入门的学习材料。您可以找到有关如何配置工作流和管理制作文件系统的手册，有关如何构建基本 VFX 工作流的教程，以及有关如何编写自己的工作流工具的资源。",
    "url": "/e058fbea/",
    "relUrl": "/e058fbea/"
  },
  "96": {
    "id": "96",
    "title": "动画工作流教程",
    "content": "动画工作流教程本教程介绍如何为动画或视觉效果制作打造一个简化但却典型的工作流。按照本教程，您将打造一个全面的工作流，为资产的建模、视觉开发到融入制作场景提供所有必要环节。此工作流中涵盖的大部分流程通过 ShotGrid 的内置集成便可实现。对于工作流中工作室更多时候会构建自定义解决方案的部分，本教程将指导您完成使用 Toolkit 平台自定义艺术家工作流的整个过程。下面是您将在本教程中构建的工作流的简要视图：    Pipeline Overview工作流概述为了简单起见，这里使用的数字内容创作 (DCC) 软件将尽可能最少，并且仅限于 Maya 和 Nuke。另外，为方便起见，工作流各个工序之间传递的数据仅限 Maya ASCII 文件、Alembic 缓存和渲染的图像序列。                    注意: 本教程中概述的简单工作流未在实际制作活动中进行过测试，因此应仅作为示例来讲解如何构建基于 ShotGrid 的工作流。    前提条件      参与 ShotGrid 项目 - 本教程假定您有使用 ShotGrid 跟踪和管理制作数据的经验。        了解 ShotGrid 集成 - ShotGrid 附带一些集成，这些集成提供了一些不需要任何手动配置的简单制作工作流。您应先了解这些工作流的功能和范围，然后再深入了解本教程中介绍的手动配置和自定义。有关 ShotGrid 集成的详细信息，请单击此处。        Maya 和 Nuke 体验 - 本教程旨在使用 Maya 和 Nuke 构建一个简单的工作流。您应该对这些软件包有基本的了解，以便自定义 ShotGrid 提供的集成。        Python 应用知识 - 本教程需要通过采用 Python 编写的“挂钩”修改 ShotGrid 集成的功能。        熟悉 YAML - 您将构建的工作流的很多配置都是通过修改 YAML 文件来完成的。  其他资源      ShotGrid 支持站点        ShotGrid 集成                  用户手册                    管理员手册                    开发人员手册            项目创建和设置在本教程中，您需要在 ShotGrid 中创建一个新项目，并像准备开始制作那样配置该项目。这包括确保所有必要的 ShotGrid 实体都已就位并正确关联。在本教程中，资产、镜头序列、镜头和任务实体是必需的，默认情况下新项目中应提供这些实体。您将创建以下对象：      两个资产：                  茶壶角色                    桌子道具                  一个场        一个链接至您创建的场的镜头        每个工作流工序一个任务  下面是一些屏幕截图，显示了您在 ShotGrid 中配置的项目实体：    茶壶和桌子资产    链接至场的镜头    任务软件启动器接下来，您将需要确保 Maya 和 Nuke 可在 ShotGrid Desktop 中启动。在 Desktop 中，确保每个软件包都可以通过单击其图标启动。确保启动每个软件包的正确版本。如果任一应用程序未显示在 Desktop 中或预期版本无法启动，则可能需要在 ShotGrid 中通过软件实体手动配置启动。    ShotGrid 中定义的默认软件实体软件实体用于驱动在您的制作中使用哪些 DCC 软件包。默认情况下，集成将在标准安装位置搜索这些软件包并使其可通过 Desktop 启动。如果您安装了多个版本或将它们安装在非标准位置，您可能需要在 ShotGrid 中更新相应的软件实体条目以管理您的艺术家的启动体验。有关软件实体以及如何正确配置该实体的完整详细信息，请参见集成管理员手册。在您的 DCC 按预期启动后，可以继续阅读下一节。配置配置定义项目的艺术家工作流。这包括指定哪些 ShotGrid 集成包含在艺术家要启动的 DCC 中，如何定义项目的文件夹结构，以及艺术家共享数据时创建的文件和文件夹的命名约定。默认情况下，所有新项目均配置为使用基本 ShotGrid 集成，这些集成提供了使用许多现成的软件包在艺术家之间共享文件的基本工作流。以下各节概述了如何接管项目的工作流配置以及如何为您的工作室对其进行自定义。接管项目配置可使用 ShotGrid Desktop (Desktop) 接管项目的配置。在 Desktop 中单击鼠标右键或单击右下方的用户图标以显示弹出菜单。选择“Advanced project setup…”选项，然后按照向导操作在本地安装项目配置。以下各图显示了所需的操作步骤。您还可以按照《集成管理员手册》中所述的接管工作流配置的步骤进行操作。    在 Desktop 弹出菜单中选择“高级项目设置…”(Advanced project setup…)    选择“ShotGrid 默认”(ShotGrid Default)作为配置类型如果这是您第一次设置 ShotGrid 项目，系统还会提示您为项目数据定义一个存储位置。否则，可以选择现有存储位置。    创建新存储。    为新存储命名。 请记住，此存储属于站点范围，而非特定于项目。    设置在您要使用的操作系统上将可以访问此存储的路径。您可以在“站点偏好设置”(Site Preferences)的“文件管理”(File Management)部分下查看和编辑 ShotGrid 站点的存储。您可以在此处了解有关这些设置的详细信息。现在，您已选择存储位置，需要在该位置为新项目选择目录名称。    输入项目文件所在文件夹的名称。在本教程中，我们将使用集中式配置。“Distributed Setup”选项提供了一个具有一组不同优势的替代选项，这可能是没有快速共享存储的工作室的首选选项。您可以在 Toolkit 管理演示中详细了解不同配置设置的优缺点。与站点范围的存储不同，配置特定于项目，因此您在此处选择的目录将直接用于存储您的配置。    记下为当前操作系统选择的配置路径。您在上面的屏幕中选择的文件夹将作为配置的安装位置。在本教程中，您将了解并修改此文件夹中的配置的内容。单击以上屏幕中的“Run Setup”后，Desktop 将开始下载并安装您的配置所需的所有组件。安装过程可能需要几分钟时间完成。完成后，您将具有整个项目配置的本地副本，在后面的操作步骤中您将对其进行修改。您在学习 Desktop 安装教程期间指定的配置位置记录在 ShotGrid 中，位于项目的“工作流配置”(Pipeline Configurations)页面。    ShotGrid 中的工作流配置实体熟悉此文件夹中的内容，以便为下一节做好准备。配置组织在开始构建简单的工作流之前，您需要了解工作流配置的组织方式和工作方式。下图高亮显示了配置的主要组件及其用途。有关配置及其管理的其他信息，请参见管理 Toolkit 一文。    项目数据结构您将在本教程中构建的简单工作流使用默认配置提供的项目数据结构。您可以浏览 config/core/schema 文件夹来了解 Toolkit 应用向磁盘写入文件时将创建的结构。有关配置项目目录结构的其他信息，请参见文件系统配置参考文档。模板本教程还使用默认工作流配置中定义的模板。您可以打开 config/core/templates.yml 文件来查看应用将输入和输出文件映射到磁盘上的路径时使用的模板。有关模板系统的详细信息，请参见文件系统配置参考文档。挂钩本教程的很多内容将涉及到修改应用挂钩以便自定义美工人员工作流。在深入了解该自定义之前，您应该对挂钩的概念、工作方式和位置有基本的了解。阅读管理文档的“挂钩”部分。在学习本教程的过程中，您将需要“接管”其中一个 Toolkit 应用定义的挂钩。接管应用挂钩的过程非常简单。每次系统要求您执行此操作时，只需按照以下步骤操作即可：      在您的配置的安装文件夹中找到包含您要覆盖的挂钩的应用。查找该应用的 hooks 子目录，并找到要覆盖的挂钩文件。        复制挂钩（必要时重命名）到您的配置的顶层 hooks 目录。      该文件位于您的配置的 hooks 文件夹后，您便可以进行更改和自定义代码。需要执行另一步操作，将对应的应用指向此新位置。在本教程的后面，您将了解如何执行此操作。构建工作流此时，您应该可以开始构建工作流。您在 ShotGrid 中设置了一个项目，可以通过 Desktop 启动 Maya 和 Nuke，并且已接管了项目配置的控制权。此外，您已对配置的结构有基本的了解，可以开始构建美工人员工作流。以下各节将介绍该工作流的每个工序，重点介绍即时可用的功能，并指导您完成自定义 ShotGrid 集成的整个过程。完成相关各节的学习后，您将构建一个简单、完全可行的端到端制作工作流。您还将了解到艺术家在其制作活动中将执行的工序。                    注意: 本教程的所有代码和配置均位于 pipeline_tutorialtk-config-default2 存储库的分支中。如果您需要有关文件所在位置、代码添加位置等的提示，可以随时使用此分支。    建模工作流简单工作流的第一道工序是建模。在本节中，您将在您的项目中创建茶壶资产的第一个迭代。您要将其保存到磁盘上的项目文件夹结构中，然后将其发布。首先，从 ShotGrid Desktop 启动 Maya。Maya 加载完毕后，将会显示“File Open”对话框。在此对话框中，您可以浏览项目中的现有 Maya 文件。此外，您还可以创建 ShotGrid 集成将会识别的新文件。选择“资产”(Assets)选项卡，然后向下查看茶壶的建模任务。由于此任务还没有艺术家工作文件，请单击“+ 新建文件”(+ New File)按钮。    单击此按钮将创建一个新的空 Maya 会话，并将您的当前工作上下文设置为茶壶资产的建模任务。                    注意: 在本教程中的任何时间，您都可以通过 Maya 或 Nuke 中的 ShotGrid 菜单启动 ShotGrid 面板。在此面板中，您可以查看您的项目数据，而无需离开 DCC。它将向您显示您的当前工作上下文以及该上下文中的任何最近活动。您还可以直接在该面板中为反馈添加注释。有关详细信息，请参见 ShotGrid 面板文档。    接下来，对茶壶建模，或下载并导入提供的茶壶。    当您对自己的茶壶模型满意后，请选择“ShotGrid &amp;gt; 文件保存…”(ShotGrid &amp;gt; File Save…)菜单动作。此对话框将提示您使用给定名称、版本和类型保存该文件。    请注意，此对话框并不要求您指定完整的保存路径。这是因为应用已配置为保存到 maya_asset_work 模板。默认情况下，此模板定义如下：@asset_root/work/maya/{name}.v{version}.{maya_extension}标记化字段 {name}、{version} 和 {maya_extension} 是填充完整路径时应用需要的所有项。模板的 @asset_root 部分定义为：assets/{sg_asset_type}/{Asset}/{Step}如果是在前面创建新文件时设置的当前工作上下文中，Toolkit 平台可以自动推断此处的标记化字段。还请注意该对话框底部显示的文件名和路径预览。请注意，接管项目配置时定义的主存储和项目文件夹构成模板路径的根目录。单击“保存”(Save)按钮保存该茶壶模型。此时务必要注意的一点是，您刚刚完成的步骤与艺术家在整个工作流中打开和保存工作文件时执行的步骤相同。“File Open”和“File Save”对话框属于 Workfiles 应用。此“多”应用在 ShotGrid 集成支持的所有 DCC 中运行，并为所有艺术家提供一致的工作流。下一步是对茶壶进行一些更改。确保壶盖几何体与模型的其余部分相分离，以便以后可以对其进行装配。    当您对自己的作品满意后，再次运行ShotGrid“ &amp;gt; File Save…”菜单动作。此时，在对话框中版本号默认设置为 2。文件版本自动递增功能让艺术家可维护所完成工作的完整历史记录。单击“保存”(Save)按钮。    将茶壶模型保存为版本 2 后，您就可以进行本教程中本节的最后一步。现在，茶壶模型已准备就绪，您需要将其发布，以便可以对其进行贴图和装配。要进行发布，请单击“ShotGrid &amp;gt; 发布…”(ShotGrid &amp;gt; Publish…)菜单动作。此时将显示发布应用对话框。    该对话框为项目树形式，通过各项目来表示将发布的内容。该树包含一些表示要发布的项的条目和一些表示将在发布操作过程中执行的动作的条目。在该对话框左侧，您将看到表示当前 Maya 会话的项。在它下面，您将看到“Publish to ShotGrid”子动作。表示“All Session Geometry”的另一项显示为当前会话的子项。它也有“Publish to ShotGrid”子动作。                    注意: 如果“所有会话几何体”(All Session Geometry)项没有显示，请确保在 Maya 中已启用 Alembic 导出插件。    可单击树左侧的项了解发布应用。您将注意到，在选择要对其执行操作的项后，您可以输入要发布的内容的说明。您还可以单击右侧的摄影机图标拍摄屏幕截图以与该项关联。当您准备好时，单击右下角的“发布”(Publish)按钮发布当前工作文件和茶壶几何体。完成后，您可以浏览到 ShotGrid 中的茶壶资产以验证发布是否已成功完成。    在上图中，您可以看到包含茶壶模型的已发布 Alembic 文件。您还应看到 Maya 会话文件的发布。这些发布对应于发布应用的树视图中的项。与使用“File Save”对话框时创建的工作文件一样，这两个发布的输出路径也是由模板驱动。它们类似如下（稍后将介绍在哪里为应用配置这些模板）：Maya 会话发布：@asset_root/publish/maya/{name}.v{version}.{maya_extension}默认情况下，此模板与工作文件模板非常相似，唯一的区别是 publish 文件夹。资产发布：@asset_root/publish/caches/{name}.v{version}.abc此模板与 Maya 会话发布模板相似，但文件写入 caches 文件夹。与“File Save”对话框不同，发布时，您不需要提供名称、版本和文件扩展名值。这是因为，默认情况下，发布器会从工作文件路径提取这些值。在后台，它通过工作模板提取这些值，然后将其应用到发布模板。这是关于 Toolkit 平台以及如何使用模板将一个工作流工序的输出连接到另一个工作流工序的输入的重要概念。在后续各节中将深入介绍此内容。浏览到磁盘上的文件，确保已在正确位置创建它们。恭喜您！您已成功创建茶壶的第一个发布迭代。看看您是否可以使用所学内容从桌子道具的建模任务发布桌子模型。结果应与下图类似：    接下来，将介绍贴图工作流。贴图工作流在本节中，您将基于您在建模一节中所学内容进一步学习。您将了解如何使用加载器应用加载在上一节中创建的茶壶模型。还将了解如何自定义发布应用来为茶壶发布着色器。首先，从 Desktop 启动 Maya。如果在完成上一节后 Maya 仍保持打开状态，则不需要重新启动。打开 Maya 后，使用“ShotGrid &amp;gt; 文件保存…”(ShotGrid &amp;gt; File Save…)菜单项打开 Workfiles 应用。与建模一节中一样，使用“资产”(Assets)选项卡向下查看茶壶资产的任务。此时，选择贴图任务，然后单击“+ 新建文件”(+ New File)。    您现在已进入茶壶的贴图任务。验证您是否在正确的制作环境中的简单方法是检查 ShotGrid 菜单中的第一个条目。    接下来，您需要将茶壶模型加载到新的贴图工作文件中。要执行此操作，请通过 Maya 中的“ShotGrid &amp;gt; 加载…”(ShotGrid &amp;gt; Load…)菜单项启动加载器应用。    加载器应用的布局类似于 Workfiles 应用，但现在您是浏览已发布的文件以进行加载，而不是浏览工作文件以进行打开。在“资产”(Assets)选项卡中，浏览到茶壶角色以显示您在上一节中创建的茶壶发布。您应该会看到 Maya 场景和 Alembic 缓存发布。选择 Alembic 缓存发布以在对话框右侧显示其详细信息。接下来，单击 Alembic 缓存发布的“动作”(Actions)菜单中的“Create Reference”项。默认情况下，加载器将保持打开状态以允许执行其他动作，但您可以将其关闭以继续其他操作。您应该会在 Maya 中看到创建了一个引用，它指向来自建模任务的茶壶发布。    接下来，向茶壶添加一个简单的程序着色器。    构建工作流时，着色器的管理可能会是一项耗时并且复杂的任务。通常在很大程度上依赖于每个工作室的具体情况。正因如此，随附的 Maya 集成未提供即时处理着色器或纹理管理的功能。可使用“ShotGrid &amp;gt; 文件保存…”(ShotGrid &amp;gt; File Save…)菜单动作保存当前会话，然后再继续。自定义着色器发布就此简单工作流而言，您将对发布器应用进行自定义，在贴图工序将 Maya 着色器网络导出为其他发布项。在本教程的后面，您将设计一个快速但不完善的解决方案，让着色器在被下游引用时可重新连接至 Alembic 几何体缓存。                    注意: 需要承认的是，您将添加的自定义非常简单而又不稳固。更保险的解决方案可能需要将已贴图角色的其他表现形式以及使用外部图像作为纹理贴图所带来的资产管理任务考虑在内。此示例只是构建实际解决方案的基础。                        注意: 此处提供了有关如何编写发布器插件的完整详细信息。    覆盖 Maya 收集器首先，您需要修改发布应用的收集逻辑。发布器配置了一个收集器挂钩，它定义用于“收集”要在应用中发布和显示的项的逻辑。您可以在项目配置的此文件中找到已配置应用的设置：env/includes/settings/tk-multi-publish2.yml此文件定义发布应用将在所有艺术家环境中的使用方式。打开文件并搜索 Maya 部分，尤其是 asset step 的配置。该部分如下图所示：    收集器设置定义发布器的收集逻辑所在的挂钩。默认情况下，该值为：collector: &quot;{self}/collector.py:{engine}/tk-multi-publish2/basic/collector.py&quot;此定义包含两个文件。如果挂钩设置中列出多个文件，则表示存在继承性。第一个文件包含 {self} 代币，其求值结果为已安装发布应用的 hooks 文件夹。第二个文件包含 {engine} 代币，其求值结果为当前插件（在本示例中为已安装的 Maya 插件）的 hooks 文件夹。简而言之，此值表示 Maya 特定的收集器继承发布应用的收集器。这是发布器配置的常见模式，因为应用的收集器挂钩具有无论运行的是什么 DCC 都很有用的逻辑。DCC 特定的逻辑继承自该基本逻辑，并对其扩展以收集特定于当前会话的项。                    注意: 我们只更改资产工序环境的收集器设置，因此，在其他上下文（如镜头工序）中工作的艺术家不会看到我们所做的修改。他们将继续使用随附的默认 Maya 收集器。    在“配置”一节中，您了解了如何接管挂钩。自定义过程从接管您的配置中 Maya 插件的收集器挂钩开始。    上图显示了如何执行此操作。首先，在您的项目配置的 hooks 文件夹中创建一个文件夹结构。这将为收集器插件提供一些命名空间，因为以后您可能会为其他 DCC 覆盖同一挂钩。接下来，将安装文件夹中 Maya 插件的收集器挂钩复制到新挂钩文件夹结构中。现在您的配置中应该有 Maya 收集器的副本，路径如下：config/hooks/tk-multi-publish2/maya/collector.py接下来，更新 publish2 设置文件以指向新挂钩位置。您的收集器设置现在应具有以下值：collector: &quot;{self}/collector.py:{config}/tk-multi-publish2/maya/collector.py&quot;注意 {config} 代币。该路径现在将解析为您的项目配置中的 hooks 文件夹。您的收集器新副本将继承自应用本身定义的收集器。                    注意: 如果此时发布，发布逻辑将完全相同，因为只是简单地复制并从一个新位置引用了收集器。    现在，您需要在首选 IDE 或文本编辑器中打开您的收集器副本，然后找到 process_current_session 方法。此方法负责收集当前 DCC 会话中的所有发布项。由于您将收集一个新发布类型，因此请转到此方法的底部并添加以下行：self._collect_meshes(item)这是您将添加用于收集当前会话中发现的任何网格的新方法。此方法将创建着色器发布插件（您将在后面创建）可以对其进行操作的网格项。要传入的项是将作为网格项的父项的会话项。                    注意: 这是非常直接的修改现有发布插件的方法。要更深入地了解发布器的结构及其所有移动部分，请查看开发人员文档。    现在，将下面的新方法定义添加到文件底部：    def _collect_meshes(self, parent_item):       &quot;&quot;&quot;       Collect mesh definitions and create publish items for them.       :param parent_item: The maya session parent item       &quot;&quot;&quot;       # build a path for the icon to use for each item. the disk       # location refers to the path of this hook file. this means that       # the icon should live one level above the hook in an &quot;icons&quot;       # folder.       icon_path = os.path.join(           self.disk_location,           os.pardir,           &quot;icons&quot;,           &quot;mesh.png&quot;       )       # iterate over all top-level transforms and create mesh items       # for any mesh.       for object in cmds.ls(assemblies=True):           if not cmds.ls(object, dag=True, type=&quot;mesh&quot;):               # ignore non-meshes               continue           # create a new item parented to the supplied session item. We           # define an item type (maya.session.mesh) that will be           # used by an associated shader publish plugin as it searches for           # items to act upon. We also give the item a display type and           # display name (the group name). In the future, other publish           # plugins might attach to these mesh items to publish other things           mesh_item = parent_item.create_item(               &quot;maya.session.mesh&quot;,               &quot;Mesh&quot;,               object           )                     # set the icon for the item           mesh_item.set_icon_from_path(icon_path)           # finally, add information to the mesh item that can be used           # by the publish plugin to identify and export it properly           mesh_item.properties[&quot;object&quot;] = object该代码已添加注释，您可由此了解执行的操作。要点是您现在已添加逻辑来收集当前会话中任何顶级网格的网格项。但是，如果此时执行发布器，项树中将不会有任何网格项。这是因为没有定义对其进行操作的发布插件。接下来，您将编写一个新着色器发布插件，该插件将附加到这些网格项并处理其发布以供下游使用。                    注意: 您可能在上面的代码中看到为网格项设置图标的调用。为了能够执行此操作，您需要在指定路径向您的配置添加一个图标：    config/hooks/tk-multi-publish2/icons/mesh.png创建着色器发布插件下一步是将新收集的网格项连接到发布插件，该插件可以将网格的着色器导出到磁盘并发布它们。您将需要创建一个新发布插件来执行此操作。单击此链接，访问此挂钩的源代码，并将其保存在 hooks/tk-multi-publish2/maya 文件夹中，然后将其命名为 publish_shader_network.py。                    注意: 如果您是刚刚接触 Toolkit 平台和发布代码，该插件中有大量代码需要了解。现在不必担心。在学习本教程以及接触发布器的功能过程中，您将有时间来查看并了解具体内容。现在，只需创建文件并知道其用途是将着色器网络写入磁盘。    要想发布着色器，还有最后一步，即添加新着色器发布插件定义的模板和配置。您可以在 settings 属性中看到该插件定义的设置：    @property    def settings(self):       &quot;”” … &quot;””       # inherit the settings from the base publish plugin       plugin_settings = super(MayaShaderPublishPlugin, self).settings or {}       # settings specific to this class       shader_publish_settings = {           &quot;Publish Template&quot;: {               &quot;type&quot;: &quot;template&quot;,               &quot;default&quot;: None,               &quot;description&quot;: &quot;Template path for published shader networks. &quot;                              &quot;Should correspond to a template defined in &quot;                              &quot;templates.yml.&quot;,           }       }       # update the base settings       plugin_settings.update(shader_publish_settings)       return plugin_settings此方法定义插件的配置界面。为了告诉插件将着色器网络写入磁盘的什么位置，需要使用“Publish Template”设置。将新发布插件添加到发布器配置并包含模板设置。这是之前在接管收集器时修改的同一配置块。它在此文件中定义：env/includes/settings/tk-multi-publish2.yml您的配置现在应与下图类似：    最后，需要在您的配置中定义新的 maya_shader_network_publish 模板。编辑此文件来添加此项：config/core/templates.yml找到定义与资产相关的 Maya 模板的部分，并添加新模板定义。您的定义将与下图类似：    全部操作完毕。您已改写发布应用的收集器挂钩来查找要为其发布着色器的网格。您已执行一个新发布插件以附加到收集的着色器项，并且已定义和配置一个用于指示将着色器网络写入磁盘的新发布模板。                    注意: 如果在为您的配置创建自定义项时关闭了 Maya，不要担心。只需重新启动 Maya，并使用“文件打开”(File Open)对话框打开您的贴图工作文件。您可以跳过下面的重新加载步骤。    重新加载 ShotGrid 集成为了试验您的自定义项，您需要在 Maya 会话中重新加载集成。为此，请单击“ShotGrid &amp;gt; [任务名称] &amp;gt; 工作区信息…”(ShotGrid &amp;gt; [Task Name] &amp;gt; Work Area Info…)菜单动作。    这将启动工作区信息应用，该应用提供有关当前上下文的信息。它还有一个方便的按钮，用于在您更改配置时重新加载集成。单击此按钮可重新加载应用和插件，然后关闭该对话框。    发布着色器网络现在可以查看更改项目配置的效果。从 ShotGrid 菜单启动发布应用。您应该会看到收集的茶壶网格项以及附加的“Publish Shaders”插件：    输入作品说明，并截取已贴图茶壶的缩略图以关联已发布的文件。最后，单击“Publish”将茶壶着色器导出到磁盘并在 ShotGrid 中将文件注册为发布。完成后，请注意，会话发布插件已自动将您的工作文件保存为下一个可用版本。这是 ShotGrid 集成支持的所有 DCC 中的默认行为。现在，您可以浏览到 ShotGrid 中的茶壶资产以验证是否一切都符合预期。    恭喜您！您已成功自定义您的工作流，并为茶壶发布了着色器。看看您是否可以使用所学内容从桌子道具的贴图任务发布着色器。结果应与下图类似：    接下来，将介绍装配工作流。装配工作流此时，您应该可以非常轻松地使用 ShotGrid 提供的 Workfiles 和“发布”应用打开（或创建）、保存和发布工作文件。此外，您还曾使用加载器应用加载来自上游的发布。使用所学内容完成以下任务：      从 ShotGrid Desktop 启动 Maya        在茶壶资产的装配工序中创建一个新工作文件        加载（引用）来自建模工序的茶壶 Alembic 缓存发布        对茶壶的壶盖进行装配以打开与合上（力求简单）        保存和发布茶壶装配  在 ShotGrid 中最后的结果应与下图类似：    接下来，让我们看看艺术家如何在其工作流中处理上游更改。打开建模工作文件并对茶壶模型进行一些更改。然后发布更新的作品。结果应与下图类似：    在茶壶的装配工序中重新打开工作文件（通过“ShotGrid &amp;gt; 文件打开…”(ShotGrid &amp;gt; File Open…)）。现在，打开“ShotGrid &amp;gt; 场景细分…”(ShotGrid &amp;gt; Secene Breakdown…)菜单动作。这将启动细分应用，该应用将显示您在工作文件中引用的所有上游发布。在本示例中，只有上游茶壶模型。您应该会看到类似如下的内容：    对于每次引用，应用将向您显示两个指示符之一：绿色对勾表明引用的发布是最新版本，红色“x”表明有更新的发布可用。在此例中，我们可以看到有更新的发布可用。现在，选择引用的茶壶 Alembic 缓存项（或单击底部的“Select All Red”按钮），然后单击“Update Selected”。应用会将 Maya 引用更新到茶壶 Alembic 缓存的最新迭代。现在，应该会在文件中看到您的新模型。    对装配设置进行所需的任何调整以匹配新模型，然后发布更改。在以下各节中，您将在镜头上下文中工作。接下来，将介绍镜头布局。布局工作流在本节中，您将开始在为您的项目创建的镜头上下文中工作。您将加载在前面各节中创建的资产并安排镜头。然后，将重新自定义发布器，这次是为了发布镜头摄影机。首先，使用在前面各节中所学内容完成以下任务：      从 ShotGrid Desktop 启动 Maya        在镜头的布局工序中创建一个新工作文件（提示：使用加载器中的“镜头”(Shots)选项卡）        加载（引用）来自茶壶的装配工序的茶壶发布        加载（引用）来自桌子的建模工序的桌子发布  现在，设计一个简单的场景，将茶壶放在桌子上。向场景中添加一个称为 camMain 的摄影机，然后对一些帧添加动画效果以创建镜头的摄影机移动。    当您对自己的镜头布局满意后，通过“ShotGrid &amp;gt; 文件保存…”(ShotGrid &amp;gt; File Save…)菜单动作保存文件。如果此时继续操作并发布，您只会看到整个 Maya 会话是一个要发布的可用项。我们要添加一项简单自定义，这也是可为工作流带来很大灵活性的自定义，那就是将独立摄影机发布为可轻松导入其他软件包的文件格式的功能。通过此功能，您可以生成一次摄影机（通常在布局中），然后让所有其他工作流工序（如动画、照明和合成）直接使用它。收集摄影机与着色器发布一样，第一步是自定义收集器挂钩。您已接管 Maya 的收集器挂钩，并为资产工序对其进行了配置。现在，您需要为镜头工作流工序更新配置。要执行此操作，请修改发布器的配置文件，然后编辑 Maya 镜头工序收集器设置。    现在，在镜头上下文中执行任务时，您的自定义收集器逻辑将运行。下一步是添加自定义摄影机收集逻辑。打开自定义收集器挂钩，并在 process_current_session 方法底部添加以下方法调用，之前在贴图一节中已在此方法中添加了用于收集网格的调用：self._collect_cameras(item)接下来，将该方法本身添加到文件底部：    def _collect_cameras(self, parent_item):       &quot;&quot;&quot;       Creates items for each camera in the session.       :param parent_item: The maya session parent item       &quot;&quot;&quot;       # build a path for the icon to use for each item. the disk       # location refers to the path of this hook file. this means that       # the icon should live one level above the hook in an &quot;icons&quot;       # folder.       icon_path = os.path.join(           self.disk_location,           os.pardir,           &quot;icons&quot;,           &quot;camera.png&quot;       )       # iterate over each camera and create an item for it       for camera_shape in cmds.ls(cameras=True):           # try to determine the camera display name           try:               camera_name = cmds.listRelatives(camera_shape, parent=True)[0]           except Exception:               # could not determine the name, just use the shape               camera_name = camera_shape           # create a new item parented to the supplied session item. We           # define an item type (maya.session.camera) that will be           # used by an associated camera publish plugin as it searches for           # items to act upon. We also give the item a display type and           # display name. In the future, other publish plugins might attach to           # these camera items to perform other actions           cam_item = parent_item.create_item(               &quot;maya.session.camera&quot;,               &quot;Camera&quot;,               camera_name           )           # set the icon for the item           cam_item.set_icon_from_path(icon_path)           # store the camera name so that any attached plugin knows which           # camera this item represents!           cam_item.properties[&quot;camera_name&quot;] = camera_name           cam_item.properties[&quot;camera_shape&quot;] = camera_shape同样，该代码已添加注释，您可由此了解执行的操作。您已添加用于收集当前会话中所有摄影机的摄影机项的逻辑。与以前一样，如果此时执行发布器，项树中将不会有任何摄影机项。这是因为没有定义对其进行操作的发布插件。接下来，您将编写一个摄影机发布插件，该插件将附加到这些项并处理其发布以供下游使用。                    注意: 您可能会在上面的代码中看到为摄影机项设置图标的调用。为了能够执行此操作，您需要在指定路径向您的配置添加一个图标：    config/hooks/tk-multi-publish2/icons/camera.png自定义摄影机发布插件下一步是将新收集的摄影机项连接到发布插件，该插件可以将摄影机的着色器导出到磁盘并发布它们。您将需要创建一个新发布插件来执行此操作。单击此链接，访问此挂钩的源代码，并将其保存在 hooks/tk-multi-publish2/maya 文件夹中，然后将其命名为 publish_camera.py。摄影机发布配置最后，您需要为镜头工序更新发布应用的配置。编辑设置文件以添加您的新插件。env/includes/settings/tk-multi-publish2.yml您的配置现在应与下图类似：    您将注意到两个设置按新插件的 settings 方法定义添加到文件中。与着色器插件一样，有一个“Publish Template”设置，用于定义摄影机文件的写入位置。摄影机设置是摄影机字符串列表，用于驱动插件应对其进行操作的摄影机。我们要求应用某种摄影机命名约定，对于不符合该约定的摄影机，此设置将防止向用户呈现发布项。在上图中，将仅呈现 camMain 摄影机以供发布。执行您添加的插件时，还可以处理通配符模式，例如 cam*。测试更改之前的最后一步是添加新摄影机发布模板的定义。编辑 config/core/templates.yml 文件，并向 Maya 镜头模板部分添加模板定义：    此时，您应该可以使用新插件发布摄影机。使用工作区信息应用重新加载集成，然后启动发布器。    如图中所示，收集了新摄影机项并附加了发布插件。继续操作并单击“发布”(Publish)将摄影机写入磁盘，然后向 ShotGrid 注册该摄影机。                    注意: 与 Alembic 导出类似，摄影机发布插件需要加载 FBX 导出插件。如果您没有看到摄影机发布插件项，请确保 FBX 插件已加载，然后重新启动发布器。    在 ShotGrid 中您应当看到与下图类似的效果：    就这么简单！接下来，将介绍动画。动画工作流到目前为止，您只自定义了发布应用以便将自定义文件类型/内容写入磁盘以及与其他工作流工序共享这些文件类型/内容。在本节中，您将自定义加载器应用的配置来完成往返操作，以便能够导入/引用自定义发布。使用在前面各节中所学内容完成以下任务。      从 ShotGrid Desktop 启动 Maya        在镜头的动画工序中创建一个新工作文件        加载（引用）来自镜头的布局工序的 Maya 会话发布                      注意: 您将注意到摄影机已包含在布局会话发布文件中。在强大的工作流中，摄影机可能会明确隐藏或从会话发布中排除，以便单独的摄影机发布文件可以作为一个真实的摄影机定义。继续操作，删除或隐藏通过引用包含进来的摄影机。    自定义摄影机加载器动作为了自定义加载器应用以导入/引用摄影机发布，您将需要编辑应用的设置文件。这是您配置中的文件的路径：config/env/includes/settings/tk-multi-loader2.yml找到为 Maya 配置应用的部分，然后将此行添加到 action_mappings 设置中的动作列表：FBX Camera: [reference, import]在自定义摄影机发布插件中，Maya 中的 FBXExport MEL 命令用于将摄影机写入磁盘，用于向 ShotGrid 注册文件的发布类型是 FBX Camera。您添加到设置的行向加载器表明，对于类型为 FBX Camera 的任何发布，显示 reference 和 import 动作。这些动作在加载器应用的 tk-maya-actions.py 挂钩中定义。以某种方式执行这些动作以处理 Maya 可以引用或导入的任何类型的文件。自定义插件生成的 .fbx 文件属于该类别，因此，为了能够加载已发布的摄影机，这是唯一要做的更改。现在应用设置应如下所示：    现在，通过工作区信息应用重新加载集成以获取新设置，然后浏览到布局工序发布的摄影机。    按新发布类型过滤，然后创建对摄影机的引用。关闭加载器，您应该能够使用新引用的摄影机播放在上一节中创建的摄影机运动。接下来，为茶壶模型添加动画效果以执行某些操作（力求简单）。    当您对自己的动画满意后，保存并发布您的工作文件，就像在前面各节中执行的操作一样。接下来，将介绍照明。照明工作流在本节中，您将汇聚在前面各节中发布的内容并渲染您的镜头。要执行此操作，您将自定义加载器应用以加载在茶壶资产的贴图工序中发布的着色器。首先，使用在前面各节中所学内容完成以下任务。      从 ShotGrid Desktop 启动 Maya        在镜头的照明工序中创建一个新工作文件        加载（引用）来自镜头的动画工序的 Maya 会话发布        加载（引用）来自镜头的布局工序的摄影机发布  自定义着色器加载器动作为了加载在贴图工序中发布的着色器，您将需要接管上一节中提到的 tk-maya-actions.py 挂钩。将该挂钩从安装位置复制到您的配置中。    该挂钩负责生成可对给定发布执行的动作的列表。加载器应用为随附的集成支持的每个 DCC 定义此挂钩的不同版本。在“贴图工作流”一节中发布的着色器是 Maya 文件，因此，与导出的摄影机一样，无需更改现有的逻辑，加载器就可以引用它们。唯一要做的更改是向动作挂钩添加一个新逻辑，以在着色器被引用到文件中之后将它们连接至适当的网格。在动作挂钩结尾处添加以下方法（在类外部）。    def _hookup_shaders(reference_node):       &quot;&quot;&quot;       Reconnects published shaders to the corresponding mesh.       :return:       &quot;&quot;&quot;       # find all shader hookup script nodes and extract the mesh object info       hookup_prefix = &quot;SHADER_HOOKUP_&quot;       shader_hookups = {}       for node in cmds.ls(type=&quot;script&quot;):           node_parts = node.split(&quot;:&quot;)           node_base = node_parts[-1]           node_namespace = &quot;:&quot;.join(node_parts[:-1])           if not node_base.startswith(hookup_prefix):               continue           obj_pattern = node_base.replace(hookup_prefix, &quot;&quot;) + &quot; d*&quot;           obj_pattern = &quot;^&quot; + obj_pattern + &quot;$&quot;           shader = cmds.scriptNode(node, query=True, beforeScript=True)           shader_hookups[obj_pattern] = node_namespace + &quot;:&quot; + shader       # if the object name matches an object in the file, connect the shaders       for node in (cmds.ls(references=True, transforms=True) or []):           for (obj_pattern, shader) in shader_hookups.iteritems():               # get rid of namespacing               node_base = node.split(&quot;:&quot;)[-1]               if re.match(obj_pattern, node_base, re.IGNORECASE):                   # assign the shader to the object                   cmds.select(node, replace=True)                   cmds.hyperShade(assign=shader)现在，在 _create_reference 方法结尾处添加以下两行，用于调用着色器挂接逻辑：    reference_node = cmds.referenceQuery(path, referenceNode=True)    _hookup_shaders(reference_node)&amp;lt;/td&amp;gt;每当创建新引用时都会运行该代码，因此，如果文件中已存在着色器，则它应在引用新几何体时指定着色器。同样，如果几何体已存在，则它应在引用着色器时指定几何体。                    注意: 此挂接逻辑非常暴力，无法正确处理命名空间以及在执行制作就绪的工作流时应考虑的与 Maya 相关的其他细微之处。    最后，通过编辑此文件使镜头的加载器设置指向新挂钩：config/env/includes/settings/tk-multi-loader2.yml同时，还将 Maya 着色器网络发布类型与引用动作相关联。现在加载器设置应如下所示：    现在，通过工作区信息应用重新加载集成以获取新设置，然后浏览到贴图工序发布的着色器。创建对茶壶着色器网络发布的引用。    现在，加载桌子着色器网络。如果在 Maya 中启用了“硬件纹理”(Hardware Texturing)，着色器应已自动连接到来自动画工序的网格引用。    现在，向场景中添加一些灯光（力求简单）。    发布 Maya 渲染将镜头渲染到磁盘。                        注意: 如您所见，茶壶和桌子资产的贴图存在问题。对于本教程而言，假定这些是有意做出的艺术效果。如果您想要解决这些问题，可以始终加载这些资产的贴图工作文件，调整着色器并重新发布它们。如果这么做，请记得更新照明工作文件中的引用并重新渲染。如果您执行这些步骤，可能会发现，在重新加载引用后，细分应用并不重新连接更新的着色器。根据您修改加载器以挂接着色器引用的经验，您应该能够更新细分应用的场景操作挂钩来添加所需的逻辑。请参见此文件中的更新方法。    随附的 ShotGrid 集成通过查看文件中定义的渲染层来收集图像序列。完成渲染后，启动发布器。您将看到渲染的序列显示为树中的一项。    继续操作并发布会话和渲染的图像文件序列。在 ShotGrid 中您应当看到与下图类似的效果：    接下来将介绍合成。合成工作流在本教程的最后一节中，将向您介绍 Nuke 提供的一些默认集成。除了在前面各节中提到的应用之外，您还将了解 ShotGrid 可识别的写入节点和一个用于将渲染快速发送给其他人以供审核的应用。首先，执行以下步骤来准备工作文件。      从 ShotGrid Desktop 启动 Nuke        与在 Maya 中一样，使用“ShotGrid &amp;gt; File Open…”菜单动作在镜头的合成工序中创建一个新工作文件。  通过加载器应用加载在上一节中渲染并发布的图像序列。    为 Image 和 Rendered Image 发布类型（类型取决于文件扩展名）定义的动作是“创建读取节点”(Create Read Node)。单击此动作可在 Nuke 会话中创建一个新的 Read 节点。请确保您的 Nuke 项目设置输出格式与渲染的图像匹配。创建一个恒定颜色以用作背景，并将其与读取节点合并。附加查看器以查看合成。    当您对自己的合成满意后，使用“ShotGrid &amp;gt; 文件保存…”(ShotGrid &amp;gt; File Save…)菜单动作保存工作文件。然后，单击 Nuke 的左侧菜单中的 ShotGrid 标识。在该菜单中单击一个 ShotGrid 可识别的写入节点：    ShotGrid 写入节点应用在内置 Nuke 写入节点之上提供了一层，它会基于当前 ShotGrid 上下文自动得出输出路径。    将图像帧渲染到磁盘。您现在可以发布 Nuke 会话以将工作文件与渲染的图像关联。默认情况下，发布器将收集渲染的帧并附加一个插件以向 ShotGrid 注册帧。另一个插件将通过一个在后台运行的名为审核提交的集成上传帧以供审核。此应用使用 Nuke 生成将上传并提交供审核的 QuickTime 影片。    另一个有用的集成是快速审核应用。这是一个输出节点，该节点将快速生成 QuickTime 影片并将其上传到 ShotGrid 以供审核。该应用位于左侧菜单中 ShotGrid 写入节点旁边。    创建一个快速审核节点，然后单击“上传”(Upload)按钮以将输入渲染到磁盘、生成 QuickTime 影片，并将结果上传到 ShotGrid 以供审核。提交帧时，有一些标准选项可供选择。    在 ShotGrid 中检查“媒体”(Media)选项卡以查看两个上传的 QuickTime 影片。    有关在 ShotGrid 中查看媒体的详细信息，请参见官方文档。总结祝贺您，您已完成本教程！我们希望本教程能为您使用 ShotGrid 集成打造自己的自定义工作流奠定良好的基础。学完本教程，您应该能够了解如何根据自己工作室的特定需求扩展默认的集成。在 shotgun-dev Google Group 中询问问题并了解其他工作室如何使用 Toolkit。请订阅以查看最新的帖子！如果您认为默认的集成未涵盖某些功能或工作流，可以随时编写自己的应用。这里是一份详实的文档，可帮助您快速开始编写第一个应用。与以往一样，如果您对本教程、ShotGrid 或 Toolkit 平台有其他疑问，请访问社区。",
    "url": "/cb8926fc/",
    "relUrl": "/cb8926fc/"
  },
  "97": {
    "id": "97",
    "title": "Planning Your Setup",
    "content": "Planning Your SetupPick your optionsPick which features you want to activate  Media Isolation  Media Traffic Isolation  Media ReplicationAWS Account CreationBefore going further, you will require an AWS Account. If you don’t already have an AWS Account, create your AWS Account.Choose an AWS RegionChoose an AWS Region for your AWS S3 bucket and VPC. Which region to use? You should chose the a region that is the closest possible to your studio.If your company is located in different locations, consider enabling the media replication feature to reduce latency and improve performancePlan the VPC IP rangesPlan your AWS VPC and subnets IP ranges if you plan to use Media Traffic Isolation.IP Range Example            Region      VPC      Subnet 1      Subnet 2      Subnet 3                  ap-southeast-2      10.1.0.0/16      10.1.0.0/24      10.1.1.0/24      10.1.2.0/24      Plan how you will privately access your AWS VPCIf you plan to activate any of the Traffic Isolation feature, you will need a way to connect your AWS VPC and your network infrastructure. The main options are:  AWS Direct Connect  Other VPN solutionWe highly recommand you to leverage Direct Connect. Direct Connect guarantees the lowest latency possible to the ShotGrid services, a consistent network experience, and allow you to leverage the optimization AWS is relying on to guarantee an optimal performance across the globe.Next StepWith your plan layed down, you are ready to start implementing the AWS building blocks that will allow you to activate the isolation features.See Media Isolation for activating the Media Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/7897b2e2/",
    "relUrl": "/7897b2e2/"
  },
  "98": {
    "id": "98",
    "title": "Private Link",
    "content": "Private LinkAWS PrivateLink is an AWS service that connects different AWS VPCs without going through the public internet.In conjunction with AWS Direct Connect, PrivateLink helps create a dedicated connection between your studio and ShotGrid’s infrastructure.",
    "url": "/9da985a7/",
    "relUrl": "/9da985a7/"
  },
  "99": {
    "id": "99",
    "title": "urlopen 错误 SSL CERTIFICATE_VERIFY_FAILED 证书验证失败(_ssl.c:726)",
    "content": "[ERROR publish_creation] &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;用例在 Houdini 17.5 中开发数字资产工具时，我使用构建工具包应用执行一个挂钩，尝试注册已发布的文件。该脚本将执行代码：    args = {        &quot;tk&quot;: self.parent.tank,        &quot;context&quot;: self.parent.engine.context,        &quot;path&quot;: esto['operator'],        &quot;name&quot;: os.path.basename(esto['operator']),        &quot;version_number&quot;: 6,        &quot;published_file_type&quot;: &quot;Library item&quot;,    }    print 'sgtk: ', sgtk.__file__    sg_publish = sgtk.util.register_publish(**args)已发布的文件已在 ShotGrid 中正确注册，但显示以下错误：---------------------------------------------------------------------------[ERROR publish_creation] &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;Traceback (most recent call last):  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank/util/shotgun/publish_creation.py&quot;, line 308, in register_publish    tk.shotgun.upload_thumbnail(published_file_entity_type, entity.get(&quot;id&quot;), no_thumb)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank_vendor/shotgun_api3/shotgun.py&quot;, line 2173, in upload_thumbnail    field_name=&quot;thumb_image&quot;, **kwargs)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank_vendor/shotgun_api3/shotgun.py&quot;, line 2263, in upload    tag_list, is_thumbnail)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank_vendor/shotgun_api3/shotgun.py&quot;, line 2383, in _upload_to_sg    result = self._send_form(url, params)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank_vendor/shotgun_api3/shotgun.py&quot;, line 3806, in _send_form    resp = opener.open(url, params)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 429, in open    response = self._open(req, data)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 447, in _open    '_open', req)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 407, in _call_chain    result = func(*args)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 1241, in https_open    context=self._context)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 1198, in do_open    raise URLError(err)URLError: &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;Traceback (most recent call last):  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/config/hooks/publish_digital_asset.py&quot;, line 66, in register_publishedfile    description='Alembic nodes.')  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank/log.py&quot;, line 503, in wrapper    response = func(*args, **kwargs)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank/util/shotgun/publish_creation.py&quot;, line 323, in register_publish    entity=entityShotgunPublishError: Unable to complete publishing because of the following error: &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;, although PublishedFile PIGS_libary_tool_hda_asasas_v017.hda (id: 114715) was created.---------------------------------------------------------------------------导致错误的原因是什么？缺少 cacert.pem 和指向该位置的所需环境变量 SHOTGUN_API_CACERTS。如何修复添加 cacert.pem 和指向该位置的环境变量 SHOTGUN_API_CACERTS。在社区中查看完整主题。",
    "url": "/02a75bb2/",
    "relUrl": "/02a75bb2/"
  },
  "100": {
    "id": "100",
    "title": "Python 3 Porting Best Practices",
    "content": "Python 3 Porting Best PracticesWhy the move to Python 3?There are a few compelling reasons to make the leap to Python 3.  Perhaps the most dramatic is the Python 2 end of life, which occurred on January 1, 20201. With the sunsetting of Python 2, all support for Python 2 ceases, meaning that even new security vulnerabilities found in Python 2 will not be addressed.Things to Consider Before StartingWhen considering moving to Python 3, it’s good to look at the requirements and application of your codebase to set expectations.  Obviously, any host applications your code runs in will help drive this decision.  Knowing whether you need to support many different Python interpreter versions and, if so, which ones, will be important information as you decide on the porting process that makes sense for you.Next, take an audit of what libraries your code depends on.  If any of these libraries do not have Python 3 compatible versions, you’ll need to find an alternative library, or fork the library to provide compatibility yourself. Both of these options could potentially be costly decisions and are important to consider early on.  Additionally, even libraries that do offer Python 3 compatible versions may not be drop-in replacements, and some libraries choose to fork for Python 3 support rather than maintain compatibility for both Python 2 and 3 as a single source.  We’ll discuss this in more depth in the “Porting Options” section below.Finally, it’s worth noting that while it is possible to continue to support Python versions older than 2.5 and Python 3 simultaneously2, this will make your life much harder.  Since Python 2.5 is very old and not used in modern DCC versions, this guide will work under the assumption that Python 2.5 and earlier will not be targeted.  If you do need to support older versions of Python, a branching approach as described in the “Porting Options” section below may be your best option.What’s Different in Python 3Python 3 comes with some slight syntax changes, changes to builtin functions, new features, and small behavior changes.  There are many great guides that enumerate these specific changes and provide examples.  Rather than dive into specifics here, the goal of this guide will be to describe the porting process from a higher-level perspective, with a few small deep dives where compatibility may be more complicated than just matching syntax.Porting OptionsFor most of us, porting our code to only support Python 3 is not yet an option.  Many DCCs still require Python 2 support, and this is unlikely to change overnight.  This means that in the real world, it will be a necessity to be able to support both Python 2 and 3.There are two major approaches to supporting Python 2 and 3 simultaneously.  We’ll discuss both of them briefly:BranchingIn this approach, a new Python 3 compatible branch of your code is maintained in parallel with the current (Python 2 compatible) branch.  This has the advantage of letting you write cleaner, easier to read Python 3 code, and allows you to fully leverage new features without needing branching logic to maintain Python 2 support.  It also means that when the time comes to drop support for Python 2, you’ll be left with a cleaner, more modern starting point in your Python 3 branch.  The obvious downside here is that maintaining two branches can be unwieldy and mean more work, especially if the Python 3 and Python 2 code starts to diverge as the Python 3 branch can leverage new features that can significantly change how your code looks (e.g. asyncio.)Cross-CompatibilityIn this approach, a single branch is maintained that uses the subset of syntax and builtins that are compatible with both Python 2 and 3.  This allows for a graceful transition from Python 2 to 3 without maintaining multiple branches of your code.  There are a few popular libraries designed to help with this approach, and it’s a commonly-used solution to the problem of transition from Python 2 to 3.  In addition to the reduced complexity compared to maintaining multiple branches, this approach also means you don’t need to change your code distribution mechanisms or worry about using the correct (Python 2 or 3) version of your code at import time.The two most commonly used libraries for this approach are future and six.futureThe future module is probably the most popular choice for Python 2 + 3 compatibility.  It backports many Python 3 libraries to Python 2, and aims to allow you to move your codebase to a pure Python 3 syntax.  Because it backports modules and works by shadowing builtins, it is slightly more invasive than six.  Given the variety of DCCs and unknown client code in VFX environments, future may be too invasive and in an environment like this may pose a greater risk of causing problems down the road.  For this reason, we will focus on using six instead.sixThe six module does not attempt to backport Python 3 modules, or allow you to write pure Python 3 syntax, but instead unifies renamed modules and changed interfaces inside the six.moves namespace.  This allows you to update imports and use six’s helper functions to write code that is both Python 2 and 3 compatible.Testing and LintingBlackThe porting process requires an examination of the entire python codebase, and introduces a fair amount of noise in the revision control history.  This makes it a good opportunity to take care of any other housekeeping that may have similar impacts.  We took this opportunity to apply black to our code.  This is not strictly necessary or directly related to Python 3 compatibility (unless your code is mixing tabs and spaces3), but given the reasons identified above, we decided this was a good opportunity to modernize our code formatting.TestsTest coverage was incredibly valuable during the porting process since it allowed us to quickly find problems that still needed to be addressed, and verify that large sections of code were working as expected without as much manual intervention.  In many cases, we found it worthwhile to increase test coverage as part of the porting process to ensure that Python 2/3 specific cases (e.g. unicode handling) were being addressed correctly.  This being said, we recognize that in many cases the realities of production mean that test coverage is sparse, and that adding tests to code that has little or no coverage may be too time consuming to be worthwhile as part of a project like adding Python 3 compatibility.  For those in this situation, there may still be some value in using coverage measurement tools and some more basic testing code during the porting process, as these tools can provide fast feedback on what code has been covered and what may still need attention.Porting ProcedureAutomated Porting using modernizepython-modernize is a tool that can be very useful for automatically generating Python 3 compatible code.  modernize usually produces runnable code with minimal human intervention, and because of this can be a great tool to get most of the way to Python 3 compatibility very quickly.  Of course, as an automated tool it does come with the drawbacks one would expect.  It frequently produces less readable and less efficient code (e.g. wrapping all iterables in a list() instantiation.)  In some cases, modernize can even introduce regressions that might be difficult to spot.  There are also some areas where you’ll find modernize is not much help at all, like when dealing with bytes and text.  Since these decisions require a bit more understanding of context, you’ll likely have to spend some time manually addressing the handling of strings in your code even if you do rely on modernize for the bulk of the compatibility work.The alternative to using an automated tool like modernize, of course, is to go through code manually to fix incompatibilities.  This can be tedious, but in our experience generally produces nicer looking code.For our process we went with a hybrid approach, using modernize with a select set of fixers, and doing some of the work manually.  We also broke the process into two stages; first doing a pure syntax compatibility and code formatting pass, and then doing a more manual Python 3 port.  Our process was as follows:In a branch:  Run modernize with the except, numliterals, and print fixers  python-modernize --no-diffs --nobackups -f except -f numliterals -f print -w .  Make sure the resulting code is Python 3 syntax compliant by compiling it with Python 3.  The goal here is not to have your code work in Python 3, but to ensure that the basic formatting and automatable syntax fixes are in place.  If your code does not successfully compile after this step, you’ll need to find the source of the problem and either add additional fixers to the above step, or manually fix the incompatibilities.  Ensure that any changes you make manually at this stage are syntax only and will not change the behavior of the code in Python 2.  python3 -m compileall .  Run black on the resulting codeThis branch should not change any behavior or functionality, and should not introduce regressions, so it is considered safe to merge at this point.  This helps keep the history easier to read, and means that the Python 3 compatibility branch and master will diverge less during the porting process, making for an easier merge once the work is done.In a new branch, the actual Python 3 port can now begin:  Search for method names that may require some work to deal with list/view/iterator differences between Python 2 and 3.  In Python 3 .values(), .items() and .keys() return an iterator or view instead of a list, so in cases where these methods are called the code should be able to handle both iterator and list returns, otherwise the result will need to be cast to a list.  Similarly, the filter() method returned a list in Python 2, but now returns an iterator.  Change calls from dict.iteritems() and dict.itervalues() to dict.items() and dict.values() if the returned collection won’t be too big.  In these cases, the resulting cleaner code at the cost of a slight performance hit in Python 2 is preferable.  In cases where the collection might contain thousands of items or more, use six.iteritems and six.itervalues instead.  If dict.iterkeys() was used, simply replace the code with something like for key in dictionary:, since this will iterate on keys in both Python versions.  Watch out that returning an iterator in Python 3 doesn’t change the semantics of the code however. If a method used to return dict.values(), you’ll need to wrap the call inside list(dict.values()) to ensure the method always returns a list in all versions on Python.  Search for str, basestring, unicode, open, pickle, encode, decode since these will be areas of the code that likely require some attention to handling of bytes and strings.  We used the coercion helper methods provided by six (e.g. ensure_string) where needed.  See the sections on bytes and pickle below.  Unless generating a super long range, xrange can be changed to range for simplicity, otherwise six.range can be used.  After committing the manual changes from above, run a full python-modernize and go through the diff manually.  Many of the resulting changes will be unwanted, as discussed above, however this is a good way to catch potential problems that were overlooked in the manual porting process.  python-modernize --no-diffs --nobackups -f default . -w &amp;amp;&amp;amp; git diff HEAD  Test the resulting code to find the remaining problems.  There are some incompatibilities that don’t have fixers (this is a good resource to look at to get an idea of what those changes entail), and it’s easy to overlook text/binary problems during the port process.We chose to use this process because we believe it allowed us to maintain a standard of more readable, efficient code than would have been automatically generated by using modernize on its own.GotchasBytes WoesPython 3 introduces a strict separation between binary and textual data.  This is a long-called-for addition that most see as an improvement, but for Python 2 + 3 compatible code it adds some headaches.  Since Python 2 does not enforce this separation, and Python 3 introduces new types to do so, code that deals with data and strings will likely need some attention.  For the most part this just means making sure that strings are encoded / decoded properly, for which the six.ensure_binary and six.ensure_text helper functions are invaluable.  See the examples below for common applications of these methods.  In some cases, however, this can be more complicated.  For an example of this, see the pickle section below.# base64.encodestring expects str in Python 2, and bytes in Python 3.# By using six.ensure_binary() we can ensure that the we always# pass it the correct type.base64.encodestring(six.ensure_binary(some_string))# In this example (from tk-multi-publish2), we get a list of files# from a QDropEvent in Pyside.  The  filenames are unicode, however# they're being passed to code that expects str.# In Python 2, this had looked like:if isinstance(category_type, unicode):                    category_type = category_type.encode(&quot;utf-8&quot;)# Using six, we can get the same behavior in Python 2, and ensure# compatibility with Python 3 with:category_type = six.ensure_str(category_type)The pickle PicklePickle in Python 3 returns a bytes object from dumps(), where previously it had returned a str.  Additionally, the output of pickle.dumps() in Python 3 contains  x00 bytes, which cannot be decoded. This is not a  problem if the data is being stored in a file, but if the pickled data is being stored in, for example, an environment variable, this can become problematic.  As a workaround, we found that by forcing pickle to use protocol 0, no 0 bytes were included, and the output is once again decodable.  This comes at the cost of the slightly less efficient and fewer-featured older protocol.# Dumping data to a pickle string:DUMP_KWARGS = {&quot;protocol&quot;: 0}# Force pickle protocol 0, since this is a non-binary pickle protocol.# See https://docs.python.org/2/library/pickle.html#pickle.HIGHEST_PROTOCOL# Decode the result to a str before returning.pickled_data = six.ensure_str(cPickle.dumps(data, **DUMP_KWARGS))# Loading data from a pickle string:LOAD_KWARGS = {&quot;encoding&quot;: &quot;bytes&quot;} if six.PY3 else {}data = cPickle.loads(six.ensure_binary(data), **LOAD_KWARGS)Regex  W flagIn Python 3, regular expression metacharacters match unicode characters where in Python 2 they do not.  To reproduce the previous behavior, Python 3 introduces a new re.ASCII flag, which does not exist in Python 2.  To maintain consistent behavior across Python 2 and 3, we wrapped re functions to include this flag across the board in Python 3.Dictionary OrderPrior to Python 3.7, dictionary order was not guaranteed.  As of Python 3.7, insertion order is preserved in dictionaries[11].  In practice, on Python 2.7 dictionary order was random but deterministic (though this was not guaranteed), on some versions of Python (including some version of Python 3) dictionary order is non-deterministic[10].  While code prior to Python 3.7 should not rely on dictionary key order being deterministic, there were instances where this assumption was made in our unit tests.  These tests broke in Python 3.7, and needed to be updated to ensure that dictionary key order was not relied upon.sys.platformIn Python 3.3+ sys.platform on Linux returns linux, where previously it had returned “linux” appended with the kernel major version (i.e. linux2).  Of course when testing for Linux it is easy enough to check sys.platform.startswith('linux').  We chose to centralize these tests and platform “normalization”, and introduced functions sgtk.util.is_windows(), sgtk.util.is_linux(), sgtk.util.is_macos(), as well as a sgsix.platform constant that contains a normalized platform string that can be used for consistent mapping to platform names across python versions.Notes            https://www.python.org/doc/sunset-python-2/ &amp;#8617;              https://docs.python.org/3/howto/pyporting.html#drop-support-for-python-2-6-and-older &amp;#8617;              https://portingguide.readthedocs.io/en/latest/syntax.html#tabs-and-spaces &amp;#8617;      ",
    "url": "/5583eab1/",
    "relUrl": "/5583eab1/"
  },
  "101": {
    "id": "101",
    "title": "Python API 最佳实践",
    "content": "Python API 最佳实践下面是使用 ShotGrid Python API 时的最佳实践列表。性能  不要请求您的脚本不需要的任何字段。包括不需要的附加字段可能会增加不必要的请求开销。  过滤器应尽可能具体。尽可能在 API 查询中过滤，而不要在获得结果后进行解析，这样比较好。  精确匹配过滤器的表现将优于部分匹配过滤器。例如，使用“是”(is)的效果将优于使用“包含”(contains)。控制和调试  对脚本使用单独的密钥，以便每个工具都具有唯一密钥。这对于调试非常有用。  确保每个脚本都对应一个所有者或维护人员，且“脚本”(Scripts)页面（位于“管理”(Admin)菜单下）中的信息是最新的。  考虑为 API 用户创建只读权限组。许多脚本仅需要读取访问权限，这可以防止意外更改。  跟踪正在使用哪些密钥，以便删除旧脚本。为了简化该操作，一些工作室在 API 封装器中为审核信息编写脚本。  检查实体名称和字段。ShotGrid 的每个字段都有两个名称：UI 中使用的显示名称（并不一定唯一）和 API 使用的内部字段名称。显示名称可以随时更改，因此无法通过显示名称可靠地预测字段名称。您可以通过转到“管理”(Admin)菜单中的“字段”(fields)选项来查看字段名称，也可以使用 schema_read(), schema_field_read(), schema_entity_read() methods，如 https://developer.shotgridsoftware.com/python-api/reference.html?%20read#working-with-the-shotgun-schema 中所述。概念设计  尤其是对于大型工作室而言，考虑使用 API 隔离层（封装器）。它可以使工具与 ShotGrid API 中的更改隔离开来。这也意味着您无需修改 API 本身即可控制 API 访问、管理调试和跟踪审核等。  使用最新版本的 API。它将包含错误修复和性能改进。  注意脚本的起始运行环境。在渲染农场中运行的脚本（在此，对相同信息，每分钟向 ShotGrid 调用该脚本 1000 次）可能会影响站点性能。在这种情况下，请考虑实施只读缓存层以减少不必要的重复调用。  可以关闭脚本的事件生成功能。对于运行频率非常高且稍后无需跟踪其事件的脚本而言，这一操作非常有用。对于运行频率极高的脚本而言，强烈建议执行这一操作，否则事件日志将变得非常大。",
    "url": "/09b77cf4/",
    "relUrl": "/09b77cf4/"
  },
  "102": {
    "id": "102",
    "title": "创建和管理 API 脚本",
    "content": "创建和管理 API 脚本按照以下步骤创建新脚本：  转到“管理”(Admin)菜单并选择“脚本”(Scripts)。  使用“+ 脚本”(+ Script)按钮创建新脚本。      从应用程序密钥中获取值。您需要此值来启动与 ShotGrid 的连接。          注意：API 密钥作为密码处理，并且一经创建，便无法通过 ShotGrid Web 应用或 API 再次查看。确保先复制密钥，然后再继续。        现在，可以使用脚本密钥来连接到 ShotGrid。请参见 API 文档中的“ShotGrid 方法”(ShotGrid Methods)，详细了解如何通过脚本连接到 ShotGrid。  提示：如果出于某些原因需要重置脚本的应用程序密钥，则需要创建新的 ShotGrid 脚本实体来执行此操作。首先将现有脚本重命名为“[My Script] - OLD”这样的名称，然后将其删除。创建新脚本。之所以需要重命名旧脚本，是因为 ShotGrid 要求每个脚本具有唯一名称。何时设置新脚本可以记录脚本操作。对各个脚本密钥的使用越细化，就越容易跟踪哪个脚本正在进行调试更改。使用单独的脚本也有助于跟踪哪些脚本将受到对 ShotGrid 站点所做更改的影响以及跟踪谁来维护脚本。",
    "url": "/99105475/",
    "relUrl": "/99105475/"
  },
  "103": {
    "id": "103",
    "title": "Python API",
    "content": "Python API在这里，您可以找到 Python API 的参考文档。",
    "url": "/682204e9/",
    "relUrl": "/682204e9/"
  },
  "104": {
    "id": "104",
    "title": "API 概述",
    "content": "API 概述注意：有关 ShotGrid API 的详细信息，请参见我们的 API 文档。借助 ShotGrid Python 应用程序编程接口 (API)，用户可以轻松地将其工具与 ShotGrid 集成。通过它您可以创建自动化流程，集成众多第三方软件包，并与工作室内的现有工具进行通信。由于各个工作室的需求迥异，因此 ShotGrid API 提供了强大的基础功能，并将大部分业务逻辑都留给您自己来处理。API 使用 Python 构建而成，Python 是传媒和娱乐行业广泛使用的常见编程语言。ShotGrid Python API 包含在您的 ShotGrid 站点中，可免费使用。API 遵循 CRUD 模式，允许您的脚本对单个实体类型运行创建、读取、更新和删除操作。许多操作中都能够定义过滤器、要返回的列，以及对结果进行排序。使用 Python API 设置环境概述视频脚本密钥为了通过 API 与 ShotGrid 服务器通信，您的脚本可以通过提供用户的凭据或利用脚本密钥向服务器进行身份认证。您可以从“脚本”(Scripts)页面（在“管理”(Admin)菜单中列出）生成新脚本密钥：提示：单独注册脚本并让每个脚本具有各自的 API 密钥。这将有助于在事件日志中更准确地监视每个脚本和它们执行的操作。个人访问代币 (PAT)除了脚本密钥，您还需要设置个人访问代币 (PAT)，以便与您的 ShotGrid 站点进行通信。请参考以下视频文档进行设置：  配置个人访问代币 (PAT)。常用的第一个项目您可以在 https://github.com/shotgunsoftware/python-api 下载 API。一些常用的第一个项目包括：  创建版本并将其链接到镜头。允许您自动提交新的渲染以供审核。  上传缩略图。无需手动添加，站点上的所有内容便可拥有最新的缩略图。  将 ShotGrid 与您的代码库（如 SVN）集成。利用 ShotGrid 对任何软件开发进行项目管理。使用 API 无法完成的操作  访问或更改权限规则（出于安全原因）  读取或更改页面设置  访问各个页面或控件的过滤器或查询设置  与 UI 交互  添加、编辑或删除条件格式规则  创建或编辑查询字段动作菜单项 (AMI)如果要编写从 ShotGrid 界面中轻松启动的脚本，可以通过 AMI 来完成。这些是可自定义的选项，右键单击一行数据时，这些选项显示在上下文菜单中。单击后，它们将向 Web 服务器或自定义浏览器协议处理程序发送上下文数据转存，然后您可以在其中运行自定义业务逻辑。可以为不同实体设置不同的 AMI，并按项目或权限组限制对它们的访问。事件触发器进程在 ShotGrid 中执行的每个操作（通过用户或 API 脚本）均会生成一个事件。事件进程可以监视事件流，然后基于定义的条件执行特定的 API 脚本。一些示例包括：  基于上游任务状态自动更改下游任务状态。  数值变化时重新计算相关剪辑镜头时长字段。  在镜头设置为特定状态时执行文件打包和传输操作。其他信息有关 ShotGrid API 的详细信息，请参见以下文章：  从 GitHub 下载 ShotGrid API  ShotGrid API 文档  ShotGrid 开发人员列表（公共）  ShotGrid 事件进程示例代码  编写事件驱动的触发器  ShotGrid 数据结构  API 最佳实践贡献和协作您是否使用 ShotGrid 制造了令人为之惊叹的工具并希望与其他用户共享？太棒了！我们拥有一个充满活力、生机勃勃、喜欢彼此共享和协作的开发人员社区。参与社区活动：  加入 ShotGrid 社区。  将代码发布到 GitHub（确保代码不特定于工作流，记录详尽，并且具有 .txt 或 .mdk 格式的自述文件）。  向开发人员列表发布链接和说明。开发人员社区和 ShotGrid 开发人员将对其进行检查、提供反馈并予以表扬。客户制作的工具和实现的集成总能为我们制造惊喜，并为我们提供了源源不断的创意灵感。快来展示您的实力吧！",
    "url": "/b6636515/",
    "relUrl": "/b6636515/"
  },
  "105": {
    "id": "105",
    "title": "API 用户权限组",
    "content": "API 用户权限组可以为 API 用户创建单独的权限组，以便脚本和密钥可以具有不同的权限级别，就像“人员”(People)一样。访问 API 用户页面转到“管理”(Admin)菜单并选择“权限 - 脚本”(Permissions - Scripts)。有关用法，请参见。如何使用 API 用户权限组在初始“API Admin”之外创建 API 权限组之后，可以将这些权限组用于 API 脚本。  从“管理”(Admin)菜单中选择“脚本”(Scripts)。  显示“权限组”(Permission Group)列并选择适当的权限组。示例为什么要使用它呢？有许多可能的用法，下面这几种用法只是抛砖引玉：示例 1：您希望将 API 密钥提供给工作室中某个不应具有完整管理员权限的人。示例 2：您希望将只读 API 密钥提供给合作伙伴工作室，以执行从您的  数据库到对方  数据库的单向同步，并仅显示一个有限的实体集。示例 3：您想要限制每个项目的 API 脚本。  通过“管理员”(Admin)菜单导航至您的“权限 - 脚本”(Permissions - Scripts)页面，并创建一个新角色。 确保“仅查看分配的项目”(See Assigned Projects Only)高级权限处于启用状态。您还可以根据需要调整其他任何权限（例如，如果您希望他们对特定实体/字段仅具有读取权限）。  通过“管理员”(Admin)菜单导航至“脚本”(Scripts)页面。显示“项目”(Projects)字段。在这里，您可以在“项目”(Projects)中输入脚本的限制范围。  通过“权限组”(Permission Group)字段，确保将此脚本权限指定给在步骤 1 中创建的新角色。",
    "url": "/bbae2ca7/",
    "relUrl": "/bbae2ca7/"
  },
  "106": {
    "id": "106",
    "title": "如何使用 ShotGrid Desktop 来重新设置 Toolkit 项目？",
    "content": "如何使用 ShotGrid Desktop 来重新设置 Toolkit 项目？如果您已为某个项目设置 Toolkit 配置并且需要重新开始，ShotGrid Desktop 中的“高级设置向导”将不允许您重新设置项目，除非已删除以前设置的配置。以下介绍了如何手动删除这些设置：  在 ShotGrid 中删除链接到项目的任何 PipelineConfiguration 实体。  在 ShotGrid 中将 Project 实体上的 Tank Name 字段设置为空白值。  删除磁盘上的任何相应工作流配置目录。  在 ShotGrid Desktop 中选择您想设置的项目。如果您已经在查看项目，跳出到项目列表视图，然后再回到您的项目。**  现在，可以再次运行项目设置过程。替代方法如果您习惯使用命令行通过 tank setup_project 命令来设置您的项目，您可以在命令结尾添加 --force 参数。这样您无需遵循上述手动步骤即可设置以前设置过的项目。tank setup_project --force&quot;",
    "url": "/fb5544b1/",
    "relUrl": "/fb5544b1/"
  },
  "107": {
    "id": "107",
    "title": "Client Responsibilities",
    "content": "Client ResponsibilitiesBelow, we have outlined setup responsibilities between Autodesk and You.Isolation SetupYou are entirely responsible for the validity, security, and execution of the Isolation setup in Your AWS Account. Autodesk should not, under any circumstances, be granted access to Your AWS environment.Autodesk is available during the process for assistance, but the configuration of Isolation features in Your AWS Account is to be executed by You on Your own.Isolation feature set activation requires the ShotGrid Support team’s intervention. Activation delays are to be expected and will depend on demand. You understand that an estimated period of 2-8 weeks is usually required to complete the setup necessary to implement the isolation feature set. The setup time is highly dependent on your cooperation, so please plan to dedicate resources for the setup before beginning the onboarding process.Autodesk does not guarantee any timeline for setup completion.Onboarding            Type      Description / Agreement      Responsibility      Available for Assistance                  AWS Knowledge      Acquiring the AWS-specific knowledge required to set up the isolation features.      You      N/A              S3      Setting up the S3 Bucket that will host Your media Securing access to the S3 Bucket. Additional high-availability measures (versioning, bucket replication, etc.)      You      ShotGrid and *AWS              Closed VPC      Setting up DirectConnect/VPN, etc. to allow closed access to the VPC. Securing the VPC by putting the correct Security Groups in place.      You      *AWS              Media Isolation      Creating the S3 end-points. Deploying the S3 Proxy.      You      ShotGrid and *AWS              Traffic Isolation      Creating VPCs. Creating Subnets.      You      ShotGrid              Monitoring and Reliability      Maintaining uptime up to Autodesk standards. High availability and redundancy of Cloud Services. Metadata and database resiliency and redundancy. Maintaining Recovery Point Objective (RPO) for metadata and database.      ShotGrid      N/A              Service Level Objective      Maintaining ShotGrid target RPO and RTO (See ShotGrid Security White Paper for more details).      ShotGrid      N/A              Security and Governance      Maintaining the ShotGrid Cloud Services that Isolation clients are interfacing with, so that they are meeting expectations in terms of security, vulnerability patching, scanning, auditing, etc. (See ShotGrid Security White Paper for more details).      ShotGrid      N/A      *You are solely responsible to seek or obtain any support services AWS may provide under any existing relationship between You and AWS. Autodesk teams are not parties to Your relationship with AWS and therefore not responsible or liable for any services or lack thereof provided by AWS to You.",
    "url": "/2f59bc69/",
    "relUrl": "/2f59bc69/"
  },
  "108": {
    "id": "108",
    "title": "异常 审核提交失败。无法渲染和提交与审核关联的场。",
    "content": "异常: 审核提交失败。无法渲染和提交与审核关联的场。用例：Nuke 中的“Submit for publish”从未起作用。问题 1：向上导航继承流的最佳方式是什么？我一直导航到“HookBaseClass”，然后有点迷路了。我目前的问题是，想让“Submit for review”在 Nuke 中正常运行。在 Nuke 的 SG 发布 GUI 中遇到以下错误：Traceback (most recent call last):  File &quot;C: Users STEVE AppData Roaming Shotgun bundle_cache app_store tk-multi-publish2 v2.4.1 python tk_multi_publish2 api plugins publish_plugin_instance.py&quot;, line 282, in _handle_plugin_error    yield  File &quot;C: Users STEVE AppData Roaming Shotgun bundle_cache app_store tk-multi-publish2 v2.4.1 python tk_multi_publish2 api plugins publish_plugin_instance.py&quot;, line 198, in run_publish    self._hook_instance.publish(settings, item)  File &quot;C: Users STEVE AppData Roaming Shotgun bundle_cache app_store tk-nuke v0.12.5 hooks tk-multi-publish2 basic submit_for_review.py&quot;, line 272, in publish    raise Exception(&quot;Review submission failed. Could not render and &quot;Exception: Review submission failed. Could not render and submit the review associated sequence.还会出现以下异常：'sg_publish_data' was not found in the item's properties. Review Submission for 'path/to/sequences/AB/AB_001/comp/work/images/AB_001_comp_v002_output/AB_001_comp_v002_output.%04d.jpg' failed. This property must be set by a publish plugin that has run before this one.因此，它在“publish_plugin_instance.py”中查找以下内容：_handle_plugin_error    yieldrun_publish    self._hook_instance.publish(settings, item)我可以在本地 Appdata 文件夹中找到这些内容，但在主安装中没有，因此我假设我需要在“submit_for_review.py”中查找以弄清楚此问题。查看此文件，我可以看到，它使用了来自继承链“HookBaseClass”更高层的项的设置和信息。因此，在“submit_for_review.py”中查找“sg_publish_data”的设置位置，我看到第 225 行：sg_publish_data = item.properties.get(&quot;sg_publish_data&quot;)问题 2在上游哪里设置“item.properties”？我怀疑在 nuke collector.py 中，但“sg_publish_data”不在那里，而且也是“HookBaseClass”的子项如何修复简短的回答：假设您没有添加自定义代码或对配置进行太多修改，只需确保已选中要提交以供审核的项的 Publish to ShotGrid详实的回答：首先，这是发布器 API 的文档。在此将介绍解决此问题所涉及的大多数概念。下面是您的具体问题的细分。希望这样做也能帮助您调试未来的问题。在上面的屏幕截图中，在 ShorgunWrite1 项下，您会看到两个 plugins。它们对应于配置中定义的插件。这些插件按顺序运行，并作用于内存中的同一项。要找到问题的根源，您需要查看这两个插件的代码。通过查看 hook 设置，可以找出这些插件所在的位置。对于第一个插件，由于我们查看的是 tk-multi-publish2 的设置，{self} 是指 tk-multi-publish2。因此{self}/publish_file.py可以在 tk-multi-publish2 应用文件夹下找到：应用在文件系统中的位置取决于 app_locations.yml 的配置方式，但如果您未在其中更改任何内容，则可以在缓存文件夹中找到该应用。下面介绍了如何查找缓存位置（如果需要）。对于第二个插件，挂钩路径为{engine}/tk-multi-publish2/basic/submit_for_review.py当在 Nuke 中时，我们要运行 tk-nuke 插件，因此要查找此发布挂钩，我们需要在 tk-nuke 下查找，它也应该位于您的缓存中。现在，您知道在何处查找代码，您可以看到第一个插件设置了预期存在于第二个插件中的值。组合这两个插件的思路是，您要提交一些已经发布（并且不会更改）的内容以供审核。因此，工作流是先发布源文件，然后从源文件创建 SG 版本以供审核。版本也链接到发布。第一个插件执行文件发布并将信息存储在项中，以供第二个发布使用。您提到了继承性，因此我也想澄清一下。我认为您在文档中遇到的是由配置驱动的挂钩继承性，而不是像您所认为的那样由 Python 继承性驱动的。在 Python 文件中，您会看到所有挂钩都继承自 HookBaseClass。但是，配置中的挂钩机制允许您实际将这些基础挂钩视为混合，并将它们组合在一起，以在重用代码时获得所需的所有功能。您可以在 tk-multi-publish2 配置中看到此示例：settings.tk-multi-publish2.nuke.shot_step:  collector: &quot;{self}/collector.py:{engine}/tk-multi-publish2/basic/collector.py&quot;此处定义的收集器在任何 Python 文件中都不存在。它实际上是 tk-multi-publish2 的 collector.py 和 tk-nuke 的 collector.py 的组合。如果快速修复对您而言不够，并且您需要修改这些挂钩，请查看自定义发布工作流视频。这是一个良好的开端。在社区中查看完整主题。",
    "url": "/1d15d7ad/",
    "relUrl": "/1d15d7ad/"
  },
  "109": {
    "id": "109",
    "title": "审核",
    "content": "审核了解如何充分利用 RV，这是一套屡获殊荣的数字审核工具，使您能够通过协作工具和诸多深度集成播放、比较和转换数字媒体。深入研究 RV 参考手册，以全面了解节点图表、自定义着色器、事件处理和网络连接。查看 RV-SDI 手册，了解我们如何将 NVIDIA SDI 视频设备作为演示模式设备进行实施。借助与 Maya、Nuke 甚至 ShotGrid 本身的集成软件包，实现无缝工作流。",
    "url": "/61e62b21/",
    "relUrl": "/61e62b21/"
  },
  "110": {
    "id": "110",
    "title": "无法解析路径的行 ID！",
    "content": "无法解析路径的行 ID！相关的错误消息：  无法解析路径的行 ID！  数据库并发问题: 路径 &amp;lt;PATH&amp;gt; 已与 ShotGrid 实体 &amp;lt;ENTITY&amp;gt; 关联。示例：当 Toolkit 用户创建文件夹时收到错误“无法解析路径的行 ID！”。奇怪的是，这会创建 FileSystemLocation 实体，但有时会导致重复项，这可能会导致一系列问题。完整的错误如下所示：Creating folders, stand by...ERROR: Could not resolve row id for path! Please contact support! trying toresolve path '  server nas_production CLICK 00_CG scenes Animation 01 001'.Source data set: [{'path_cache_row_id': 8711, 'path':'    server  NAS_Production  CLICK  00_CG  scenes  Animation  01  001','metadata': {'type': 'ShotGrid_entity', 'name': 'sg_scenenum', 'filters':[{'path': 'sg_sequence', 'values': ['$sequence'], 'relation': 'is'}],'entity_type': 'Shot'}, 'primary': True, 'entity': {'type': 'Shot', 'id':1571, 'name': '001_01_001'}}, {'path_cache_row_id': 8712, 'path':'    server  NAS_Production  CLICK  00_CG  scenes  Animation  01  001  Fx','metadata': {'type': 'ShotGrid_step', 'name': 'short_name'}, 'primary': True,'entity': {'type': 'Step', 'id': 6, 'name': 'FX'}}, {'path_cache_row_id':8713, 'path':'    server  NAS_Production  CLICK  00_CG  scenes  Animation  01  001  Comp',注意：它的运行时间可能比这长得多。导致错误的原因是什么？此错误指出，工作流配置中的 ShotGrid（“站点偏好设置 -&amp;gt; 文件管理”(Site Preferences -&amp;gt; File Management)）和 config/core/roots.yml 中指定的存储根之间不匹配。这通常是由于运行 Windows 的工作室中的大小写不匹配而导致的。它们的路径不区分大小写，但我们的配置区分大小写。像 E: Projects 与 E: projects 这样简单的差异都可能会导致此错误。在后台发生了什么？代码在 ShotGrid 中为刚创建的路径创建了 FilesystemLocation 实体，使用 ShotGrid 的存储根来确定路径的根。然后，它在本地缓存中创建相同的条目，并且必须确定将其放置在数据库中的哪个位置。对于本地缓存，它使用 roots.yml 确定路径的根，并且由于大小写不匹配，它生成的路径与刚在 ShotGrid 中输入的路径不匹配。此时，它将引发错误。这尤其糟糕，因为错误不清晰：创建了文件夹，创建了 FilesystemLocation 条目，它们没有在本地缓存路径中同步，由于存储根不匹配，它们也无法同步。如何修复首先，确保“站点偏好设置”(Site Preferences)中的存储根路径与 config/core/roots.yml 中的路径相匹配。要修复不匹配问题，就应该在后续的文件夹创建调用中消除错误。然后，清除错误的 FilesystemLocation 实体。如果可以缩小到一组错误的 FilesystemLocation 实体，只需移除这些实体即可。但是，在许多情况下，项目的所有路径都会受到影响，因此它们都需要处理。  如何清除 FilesystemLocation 实体：理想情况下，您可以运行 tank unregister_folders。要清除所有这些，请运行 tank unregister_folders --all。（对于 tank unregister_folders 的所有选项，只需运行它而不使用任何参数，它将输出用法说明。）  但是，由于数据库已处于不稳定状态，因此这可能不起作用，或者可能仅部分起作用。运行该命令后，返回到 ShotGrid 中的 FilesystemLocations，确认您预期删除的内容已消失。如果没有，请选择坏实体，然后手动将其移动到垃圾桶。此时，ShotGrid 中的 FilesystemLocations 是干净的，但艺术家的本地缓存可能不反映您所做的更改。最后一步是实际同步每个用户计算机上的本地缓存。为此，应运行 tank synchronize_folders --full。执行所有这些步骤后，缓存路径应处于良好状态，并且不再显示错误。相关链接  下面是相关代码  什么是缓存路径？什么是文件系统位置？在社区中查看完整主题。",
    "url": "/da6b219a/",
    "relUrl": "/da6b219a/"
  },
  "111": {
    "id": "111",
    "title": "RV 开发人员概述",
    "content": "RV 开发人员概述RV 核心参考用户手册本用户手册概括介绍了 RV 和 RVIO 入门知识以及完整命令行和 GUI 用法。此外，您还将找到安装注意事项和提示以更大限度地提高性能，并找到有关 LUT、RV 像素工作流、立体三维、使用软件包扩展 RV、RV 网络连接和 RVLS 媒体列表实用程序的详尽信息。  RV 用户手册  问题和疑难解答论坛技术参考手册本参考手册是了解如何自定义 RV 的入门手册。它概述了 RV 软件包系统和 Mu 脚本功能。如果您要更改热键、添加菜单、自定义颜色管理、创建新控件或将 RV 与您的工作流相集成，可通过本参考手册入门。  技术参考手册  扩展 RV 论坛RV-SDI 手册本手册介绍了 Tweak 如何将 NVIDIA SDI 视频设备作为演示模式设备进行实施。有关演示模式及其与 RV 的常规关联方式的详细信息，请参见 RV 用户手册。要使用 RV-SDI，则必须运行“RV”（或“rv.exe”）可执行文件，并具有“rvsdi”许可。  RV-SDI 手册RV 集成RV/Nuke 集成RV 现在附带 Nuke 集成工具。本文档介绍了适用于单个或系统范围设置的安装，并介绍了 RV/Nuke 的工作流、工具、概念和用法。  RV-Nuke 集成文档RV/Maya 集成RV 现在附带 Maya 集成。本文档介绍了如何安装 RV/Maya 软件包，并介绍了 RV/Maya 工作流、如何比较和组织播放预览，以及如何在编辑、A/B 比较和布局中呈现。  RV-Maya 集成文档",
    "url": "/7e1071f0/",
    "relUrl": "/7e1071f0/"
  },
  "112": {
    "id": "112",
    "title": "S3",
    "content": "S3Amazon S3 is an object storage service offered by AWS. It can be thought of as a highly durable storage space in the cloud. ShotGrid uses S3 to store uploaded media and files.In order to use ShotGrid isolation features, you will bring your own S3 bucket and configure ShotGrid to use it for storage. Please refer to our S3 Bucket Setup article for details on how to do this.",
    "url": "/dfc0cc1b/",
    "relUrl": "/dfc0cc1b/"
  },
  "113": {
    "id": "113",
    "title": "Media Isolation",
    "content": "Media Isolation                    Disclaimer: The security of your S3 bucket is solely a client responsibility, and the integrity of your data will be at risk without it. We very strongly recommend securing your S3 bucket properly.    AWS Account CreationYou can quickly create your AWS Account.You should also contact your AWS contacts to get help with your AWS account setup.AWS CloudFormation templateIt’s possible to start from the Private S3 bucket AWS CloudFormation template and customize it for your needs for a faster deployment.                    Disclaimer: This template is provided as an example only. It is your responsibility to validate that running the template will result in the configuration/policy/security settings your studio requires.      Go the CloudFormation service in AWS Console  Select Template is ready  Set Amazon S3 URL to https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-s3-bucket.yml  Next  Set a stack name like ShotGrid-s3-bucket  Set your S3 bucket name and your ShotGrid site name  Next  Accept I acknowledge that AWS CloudFormation might create IAM resources  NextCORS ConfigurationCORS policy on your S3 bucket will be minimally configured, allowing only the required origin (your site) and methods, amongst other things.IAM RoleThe template will create an AWS Role with the following permissions on your bucket:  Allow ShotGrid to access your S3 bucket.  Allow the ShotGrid account to assume the role by setting the role Trust Relationship.Media Isolation ActivationPlease contact ShotGrid support via the dedicated Microsoft Teams channel and provide the following information:  ShotGrid IAM Role ARNShotGrid will allow your site to use your IAM role.Media Configuration SetupNavigate to your site’s site preferences and under the Isolation section, fill in the S3 Configuration preference with the following JSON:{​​​​​​​   &quot;&amp;lt;S3_CONFIG_NAME&amp;gt;&quot;: {​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​}​​Fields description            Field      Description                  S3_CONFIG_NAME      Unique name for the configuration. This will be selectable as a bucket later on.              BUCKET_REGION      Isolation bucket’s region              BUCKET_NAME      Isolation bucket’s name              BUCKET_PREFIX      The S3 prefix where the media is located on the isolation bucket              ROLE_ARN      AWS Role ARN that ShotGrid can use to access the bucket. This must be the same role specified in the Initial Setup              S3_INTERFACE_VPC_ENDPOINT      Optional - This is only needed if Media Traffic Isolation is utilized.      Testing Media ConfigurationAfter the configuration has been updated on your site, navigate to the /admin/speedtest route of your ShotGrid site. Select the new S3_CONFIG_NAME that was just set up previously and start the test to confirm that all the upload/download tests work as intended.Next StepsSee Media Traffic Isolation to activate the Media Traffic Isolation feature.See Media Replication to activate the Media Replication Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/439f0627/",
    "relUrl": "/439f0627/"
  },
  "114": {
    "id": "114",
    "title": "Media Replication",
    "content": "Media ReplicationDescriptionIt’s possible to add S3 replication between two S3 buckets in different regions and configure ShotGrid to leverage it for faster access to media.Features  Support one replica bucket in another region leveraging the AWS S3 replication featureHow it worksWhen S3 bucket replication is activated, users will be able download media files from the replica S3 bucket.For each user, the S3 replication is activated by the Use S3 Replication field.            Value      Behavior                  no      Never use replica S3 bucket (default)              yes      Use replica S3 bucket when delay is over              auto      Use replica S3 bucket when delay is over and the client IP is in IP Adresses for S3 replication range      The IP Adresses for S3 replication preference can be edited in Site Preferences under the Isolation category.Limitations  Only one replica S3 bucket can be configured  Only downloading from the replica bucket is supported  Configurable delay for new media to be replicated before being made available to usersSetup steps  Create the replica S3 bucket in a new AWS region. See Media Isolation  Update your existing ShotGrid role policy to allow ShotGrid to also access the replica bucket  Setup the replication rules on the primary S3 bucket. See How do I add a replication rule to an S3 bucket?  Setup a VPC + Direct Connect + S3 proxy in the new AWS region if needed. See Media Traffic IsolationConfigure your siteTo configure S3 replication, you will need to add an additional entry to the “S3 Configuration” site preference.The complete entry may look something like the following:{​​​​​​​​   &quot;&amp;lt;S3_CONFIG_NAME&amp;gt;&quot;: {​​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;,     &quot;s3_interface_vpc_endpoint_dns_name&quot;: &quot;&amp;lt;S3_INTERFACE_VPC_ENDPOINT&amp;gt;&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​,   &quot;&amp;lt;S3_CONFIG_NAME_REPLICA&amp;gt;&quot;: {​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION_REPLICA&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME_REPLICA&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX_REPLICA&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;,     &quot;s3_interface_vpc_endpoint_dns_name&quot;: &quot;&amp;lt;S3_INTERFACE_VPC_ENDPOINT_REPLICA&amp;gt;&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​After the configuration has been updated on your site, navigate to the /admin/speedtest route of your ShotGrid site. Select the new S3_CONFIG_NAME_REPLICA and start the test to confirm that all the upload/download tests work as intended.Update the following Site Preferences:  S3 Bucket for Replication - This should have the same value as S3_CONFIG_NAME_REPLICA from the S3 Configuration  S3 Replication Delay - Set this to something reasonable such as 60 seconds.FAQCopy existing mediaS3 replication only applies to media uploaded after the feature has been enabled. Existing media in the primary bucket must be copied to the replica bucket manually. You can simply use aws-cli sync or use Amazon S3 Batch Operations if you have a lot of media to achieve this.Next StepsSee Fine Tuning to finalize your setup and optimize costs and security.Go to Setup for an overview of the possible next steps.",
    "url": "/44623c83/",
    "relUrl": "/44623c83/"
  },
  "115": {
    "id": "115",
    "title": "集成用户手册",
    "content": "集成用户手册在本手册中：  简介  Desktop 快速入门          Desktop 安装                  安装更高版本的 Desktop                    自主托管时登录或在代理服务器后台登录                  身份认证和浏览器集成                    系统托盘      项目浏览器      命令启动器      控制台        启动应用程序  面板          概述      UI 详细信息                  活动流          创建和回复注释          注释、版本、发布和任务          “信息”(Info)选项卡          搜索          动作          当前工作区和主页区域          当前工作区                      发布器          概述      界面组件和概念      基本工作流                  在内容创建软件中发布          发布项目和任务                          上下文              验证              多文档工作流                                单机发布          发布类型                          单机              3ds Max              Houdini              Maya              Nuke              Nuke Studio              Photoshop CC                                            加载器          概述      树视图      导航      查看发布      将一个或多个发布添加到场景中      使用早期发布      相关审核        高级功能  致谢简介ShotGrid 集成可将 ShotGrid 引入到您的内容创建工具中。使用 ShotGrid 集成时，您将能够轻松启动软件，使用面板来跟踪 ShotGrid 中与您的任务相关的注释和数据，并使用发布器和加载器来跟踪文件并将其带入到场景中。艺术家将有权从应用内直接访问与其任务相关的所有 ShotGrid 数据，以及其项目上的所有任务。他们可以回复注释、播放版本、发布文件，以及加载同事发布的文件。有关 ShotGrid 集成的最新更新，请订阅发行说明。Desktop 快速入门ShotGrid Desktop 应用是集成的核心。该软件应用程序将 ShotGrid 体验延伸到本地计算机，让您可以轻松访问 ShotGrid 数据、启动应用程序，并直接从您的计算机上运行工作流集成工具。运行 Toolkit 经典还是自定义安装？ShotGrid 集成可自动安装。如果您是希望安装经典 Toolkit 配置的高级客户，或者您拥有自定义 Toolkit 安装程序并希望通过 Desktop 安装向导进行安装，请参见管理员手册了解如何执行此操作。Desktop 安装您可以在“应用”(Apps)菜单中下载 ShotGrid Desktop。按照提示进行操作，然后选择下载适用于 Mac、Windows 还是 Linux 的 Desktop。安装更高版本的 Desktop您可以在所有支持的操作系统上更新 ShotGrid Desktop，而无需卸载当前版本。但是，请确保在更新 ShotGrid Desktop 版本之前关闭现有会话。注意：在 Windows 上，如果在 Desktop 正在运行时更新版本，则二进制锁将干扰安装并导致安装程序停止。这将导致安装不完整，因为已经复制了某些文件。要修复此问题，请退出 Desktop，然后选择“重试”(Retry)。自主托管时登录或在代理服务器后台登录注意：如果您是自主托管的或使用代理服务器，则需要使用以下有关登录的内容。这不是默认行为。如果您是自主托管的或使用代理服务器，则首次打开 Desktop 时，浏览器将提示您提供证书。这样做的目的是连接 ShotGrid 与 Desktop 应用。如果您在设置证书时遇到问题，请查看 Firefox 和 Chrome 及其他浏览器的疑难解答文档。您只需更新一次安全证书列表。请注意，只有 Mac 和 Windows 显示证书提示，Linux 不显示。设置完毕以后，您需要登录到您的 ShotGrid 站点。如果使用代理，则需要进行一些额外的配置。请参见管理员手册中有关如何执行此操作的说明。身份认证和浏览器集成Desktop 提供的服务支持 ShotGrid Web 应用程序与您的计算机交互。这样可启用本地文件链接和软件启动等功能。出于安全原因，您必须以浏览器中同一 ShotGrid 站点上的同一用户身份登录 Desktop。如果您使用其他用户登录或登录到其他站点，Desktop 将提示您切换帐户。如果切换，它将重新启动并提示您输入相应的凭据。系统托盘应用程序启动时，将在系统托盘中显示为一个图标。要显示窗口，请单击该图标。默认情况下，窗口将固定到系统托盘中，这意味着当窗口失去焦点时将自动隐藏。您可以从用户菜单中选择“Undock from Menu”或通过拖动其标题来取消固定窗口。窗口取消固定后，它看起来像一个常规窗口，当失去焦点时将不再隐藏。当窗口取消停靠时，可以通过单击关闭按钮将其隐藏。要再次显示，请单击系统托盘图标。项目浏览器应用的第一个主视图是项目浏览器。在此，您将看到 ShotGrid 实例中的所有项目。最近访问的项目将首先列出。在窗口右下角附近，您将看到 ShotGrid 帐户的缩略图。这是用户菜单，从中可以执行许多操作，如停靠和取消停靠窗口、使其始终位于其他窗口之上、显示日志记录控制台。在窗口的顶部，可以单击放大镜图标以显示搜索框。在此框中键入内容，会将所示项目列表过滤至仅显示那些包含您键入的字母的项目。单击一个项目会转到该项目的命令启动器视图，从中可以启动可供该项目使用的工具。命令启动器选择某个项目之后会转到该项目的命令启动器。此窗口会将可供该项目使用的所有工具和应用程序显示为按钮网格。只需单击按钮，即可启动对应的应用程序。应用程序将在项目特定环境中运行，如果 ShotGrid 有相应集成，您将看到列出所有可用工具的 ShotGrid 菜单。控制台您可以通过用户菜单启动控制台。自启动项目以来的所有记录将在此处显示。如果您遇到错误，错误的详细信息也应在此处显示。如果右键单击控制台，将显示标准编辑菜单，您可以在控制台中选择所有文本、复制所选内容或清除文本。启动应用程序启动 ShotGrid Desktop 并选择一个项目后，该程序将扫描您的操作系统的标准应用程序目录。Desktop 将显示我们集成的任何应用程序的启动器。如果您有同一软件的多个版本，启动器将给出一个包含所有可用版本的下拉列表。单击启动器图标将启动最新版本。您可以在 ShotGrid Desktop 中直接启动 Maya 和 Nuke 等应用程序，也可以通过 ShotGrid 直接启动它们。无论是哪种方式，都可从应用程序内访问 ShotGrid 集成。除了现有配置，工作室通常还需要其他配置。工作室可能具有位于非标准文件系统位置的软件或本地不支持的软件的内部插件。在 ShotGrid Web 应用中可以轻松配置这些情况。有关详细信息，请参见管理员手册。如果您没有看到所需应用，请查看管理员手册的“在 ShotGrid Desktop 中配置软件”部分。面板概述从 Desktop 或 ShotGrid 启动应用程序后，将显示 ShotGrid 面板。ShotGrid 面板是小型轻量版 ShotGrid，可直接在艺术家的应用程序（如 Maya 和 Nuke）中运行。通过该面板可以快速访问 ShotGrid 信息，而无需离开您正在使用的应用程序。您可以轻松访问当前任务相关信息，还可以通过 ShotGrid 即时访问活动流、注释、任务、版本和发布。您可以播放发送给团队其他成员审核的版本，回复注释，创建新任务，以及搜索 ShotGrid 站点。UI 详细信息ShotGrid 面板包含几个主 UI 元素。在顶部可以看到一个 工具栏 ，其中包含用于导航和搜索的按钮。工具栏正下方是 详细信息区域 ，其中显示有关您当前正在查看的项目的信息。此详细信息区域可供配置，因此，如果您要显示自定义字段或对您的工作流特别重要的数据，只需简单操作就可以在此处显示这些信息。最后，您会发现一些 内容选项卡 。这些选项卡均显示 ShotGrid 数据列表，通过它们可以在 ShotGrid 面板内轻松导航，快速浏览发布等内容，检查版本，或查看何人分配到链接至当前焦点的任务。如果应用程序中的集成支持停靠，则 ShotGrid 面板将无缝地停靠在 UI 中。在其他应用程序中，面板将显示为常规窗口。下面简要概述了 ShotGrid 面板中可供使用的不同选项卡和功能。活动流活动流的工作方式与 ShotGrid 中的活动流一样 - 显示您所查看的对象中以及围绕这些对象进行的所有操作：  创建注释的用户  提交以供审核的版本  工作流创建的发布。您可以直接通过活动流添加新注释，还可以回复现有注释。附件会自动显示，单击附件将显示较大的预览。请注意，上传文件后，您可能会看到一个占位符图标。在最终缩略图可用后，手动刷新面板可显示出来。创建和回复注释借助 ShotGrid 面板可轻松创建或回复注释。只需导航至活动流或注释详细信息页面，然后单击 “创建注释”(create note) 或 “回复注释”(reply to note) 。此时将显示一个对话框，您可以在其中键入注释文本。如果您希望将注释发送给特定人员，可以使用 @name 表示法 - 这会自动将此人添加到注释的“收件人”(TO)字段。注释、版本、发布和任务“注释”(Notes)、“版本”(Versions)、“发布”(Publishes)和“任务”(Tasks)选项卡的工作方式均相同 - 显示与您正在查看的当前项目相关联的数据。您可以双击某个项目以聚焦该项目。一旦导航至某个 发布 ，即可查看该发布的依存关系。如果您的工作流要跟踪依存关系信息，则该功能非常有用，此外，您还可以即时了解资产的互连方式。“信息”(Info)选项卡如果在其他选项卡上找不到要查找的内容，请尝试导航到“信息”(Info)选项卡。此选项卡包含适用于您聚焦的实体的大多数 ShotGrid 字段，您可以单击蓝色超链接以导航到其他 ShotGrid 位置。搜索如果要快速导航到 ShotGrid 中的其他位置或对象，可以使用内置的搜索功能。这类似于 ShotGrid Web 应用程序中的全局搜索功能。只需键入您要查找的内容的名称或说明。键入三个或更多字符后，将看到结果显示。动作借助 ShotGrid 面板，您还可以使用 ShotGrid 数据在场景中运行操作。与加载器类似，面板的动作系统能够轻松注册代码段并通过浏览器某一项上的菜单触发该代码段。您可以从详细信息区域和列表处访问各动作。详细信息区域中的动作按钮也包含一些方便的内置功能，可快速跳转到 ShotGrid 和刷新当前视图。当前工作区和主页区域左上角的图标可导航到您的当前工作区。该工作区通常显示您当前正在处理的任务，通过它您可以快速访问注释，审核版本，并查看与当前处理的工作相关的其他信息。这也是 ShotGrid 面板启动时聚焦的位置。在右上角，您将看到一个显示当前用户缩略图的按钮。此按钮将转到一个页面，其中显示当前用户的相关信息。这包括  您已提交的所有发布和版本  分配给您的任务  您参与的或其中的注释与您相关（例如，与分配给您的任务相关的注释）的所有注释对话。当前工作区当您开始处理任务时，您可以使用面板来设置当前工作区。然后，当您发布您的作品时，它将与您在 ShotGrid 中的当前任务相关联。发布器概述通过发布应用，艺术家可以发布他们的作品，以便其可供下游的艺术家使用。它支持在艺术家的内容创建软件中以传统方式发布工作流，以及在磁盘上单独发布任何文件。在内容创建软件中操作并使用基本 ShotGrid 集成时，该应用将自动发现并显示项目以供艺术家发布。对于较复杂的制作需求，工作室可以编写自定义发布插件来推动艺术家工作流。以下各部分介绍了发布器 UI 和基本集成工作流。有关根据工作室特定需求自定义发布器的信息，请参见发布器开发手册。界面组件和概念可从本地文件系统上的任意位置拖放文件。使用浏览按钮可打开文件浏览器，选择一个或多个要发布的文件。左侧的项目树状图显示了将发布的文件。顶层项目可以包含相关的子项目，例如从工作文件中生成的渲染或缓存。每个项目下有一个或多个发布任务，这是发布时要执行的动作。项目本身都分组到上下文标题下，表明发布文件将要关联的 ShotGrid 上下文。如果有多个顶层项目，则将显示摘要项目，概述将发布的项目和将执行的动作。选择一个项目后，界面的右侧将显示该项目的详细信息。这包括目标上下文以及发布的缩略图和说明。还包括该项目和所有子项目的摘要。界面底部的左侧有一系列工具按钮。这些按钮包括：  浏览(Browse)：浏览要发布的文件  刷新(Refresh)：刷新发布项目列表  删除(Delete)：从列表中移除所选项目  展开(Expand)：展开列表中的所有项目  收拢(Collapse)：收拢列表中的所有项目  文档(Documentation)：打开工作流文档中间是状态标签。在发布器进行验证并执行发布任务时，状态标签将更新。单击后，您会看到“Progress Details”叠加。最右侧是“验证”(Validate)和“发布”(Publish)按钮。“验证”(Validate)按钮将对所有项目和任务执行初始验证过程，以确保其处于可发布状态。“发布”(Publish)按钮将发布列表中的项目。“Progress Details”叠加将显示列表中项目的集合、验证和发布的输出。使用“Copy to Clipboard”按钮，用户可以轻松共享发布日志。出现验证或发布错误时，该日志消息可能包括一个动作按钮，引导用户获取其他信息，在某些情况下甚至可以进行即时修复。基本工作流发布应用的目的是，让艺术家将自己的作品提供给其他艺术家使用。在 ShotGrid 中，发布文件意味着在 ShotGrid 中创建包含待发布文件相关信息（包括路径、版本号、艺术家信息、ShotGrid 相关上下文等）的记录。在 ShotGrid 中跟踪文件后，其他用户可以通过加载器应用来使用它。基本 ShotGrid 集成提供了两种方式在工作流中使用发布应用：单机发布和在内容创建软件中发布。以下各部分概括介绍了这两种不同情况下的工作流。在内容创建软件中发布基本 ShotGrid 集成包括对 3dsMax、Houdini、Maya、Nuke、Nuke Studio 和 Photoshop 等内容创建软件的发布工作流支持。当发布器与内容创建软件一同启动时，发布器将自动尝试查找要发布的项目。尽管根据不同的软件和艺术家工作文件内容，显示的待发布项目将稍有不同，但均适用相同的基本发布概念。此处是一个在 Nuke 中进行发布的示例：发布项目和任务在此，您可以在左侧看到已收集的发布项目。有三个发布项目：选定的项目是工作文件本身，其下方则是两个子项目。此外，还有一个图像文件序列和一个 Alembic 缓存。这些项目都附有一个 Publish to ShotGrid 发布任务，执行该任务时，将在 ShotGrid 中创建发布条目以跟踪各个文件或图像序列。表示 Nuke 脚本的父项目都附有一个 Begin file versioning 插件。工作文件的路径中没有版本号时，将显示此插件。如果选中此任务，将在文件名中插入版本号，然后再进行发布。在本例中，文件将从 bunny_010_0010.nk 重命名为 bunny_010_0010.v001.nk。这促使人们保留艺术家工作文件的历史记录。此任务并非默认选中，并且也不一定要运行。如果项目已发布且任务处于启用状态，则下次发布工作文件时，由于文件名中包含版本号，任务将不显示。可以根据需要启用或禁用发布任务。项目上的复选框反映和控制其子任务的选中状态。例如，取消选中一个项目将取消选中其所有任务。取消选中多个任务中的一个会使项目处于半选中状态。要切换特定类型的所有任务（例如，所有“发布到 ShotGrid”(Publish to ShotGrid)任务）的选中状态，只需在选中复选框时按住 Shift 键。选择发布任务将显示任务内容相关信息。上下文在 Nuke 脚本项目之上，可以看到已发布项目将在 ShotGrid 中关联的上下文的名称。可通过更改界面右侧的“任务”(Task)和/或“链接”(Link)字段来修改这一名称。如果有多个项目要发布，这些项目可能会出现在不同的上下文中。发布项目左侧标有三条水平线的图标是拖动控制柄，可将项目从一个上下文移至另一个。“任务”(Task)输入字段旁还有一个菜单下拉按钮。该菜单显示您可能感兴趣的多组任务。它将显示分配给当前用户的所有任务、当前上下文相关任务（例如分配给相同镜头的其他任务）和最近浏览的所有任务。要搜索任务或实体链接，只需单击其中一个字段或单击搜索图标并开始键入您感兴趣的上下文名称。字段将显示匹配的任务或实体链接，然后您可以单击或导航到所需的上下文。对于每个发布项目，均可通过单击摄影机图标，选择屏幕的一部分作为 ShotGrid 中的发布的缩略图。对于有子项目的情况，子项目默认从父项目继承该缩略图。您可以通过选择子项目并单击其缩略图来覆盖子项目的缩略图。输入的说明将包含在 ShotGrid 中的发布数据内。与缩略图一样，说明继承自父项目，但可以通过在子项目的详细信息中输入新说明来覆盖。验证准备好发布项目之后，可以单击“验证”(Validate)按钮，确保文件和发布项目的状态允许发布按预期完成。如果所有项目验证正确，则可在右侧看到绿色复选标记。对于任何未验证的项目，则将显示一个警告图标。状态也会显示在发布器底部的状态标签区域。单击项目中的图标或状态标签，将打开“Progress Details”叠加并高亮显示验证问题。在上面的示例中，Nuke 脚本尚未保存。在某些情况下，将提供动作按钮以快速指导您修复问题或获取更多有关问题的信息。在这里，您可以看到“另存为…”(Save As…)动作按钮，该按钮将打开 Nuke 保存对话框。一旦验证问题得到更正，即可关闭“Progress Details”叠加以返回到发布项目视图。在解决发布任务警告或错误的同时，可根据需要多次运行验证。在按下“发布”(Publish)按钮后，应用将遍历列表中的项目和任务，对每个项目和任务运行另一个验证过程，然后执行发布逻辑以在 ShotGrid 中创建条目、上传缩略图、切换工作文件版本等。还将执行最后一个过程以总结每个项目的发布并执行任何必要的清理工作。通过单击发布器底部的状态标签以显示“Progress Details”叠加，可以查看整个流程的结果。也可以在发布时保持“Progress Details”视图，以查看发布后的输出。您可以看到此处显示的其他动作按钮，以快速跳转到 ShotGrid 中新创建的发布条目。多文档工作流对于内容创建软件（如 Photoshop 或 Nuke Studio）中的多文档工作流，发布项目列表中将显示多个顶层项目。只有当前/激活状态的文档将得以展开和选中。要选中待发布的所有文档，只需按住 Shift 并单击其中一个未选中项目的复选框。要展开已收拢项目，请使用底部工具栏中的展开按钮。如果有多个顶层项目，列表顶部也会包含“摘要”(Summary)项目。选择此项将显示所有选定项目（供发布）的完整摘要。在上图中总共可以看到四个项目、八个任务，这八个任务要在四个不同的上下文中执行。您可以在该视图中覆盖所有项目的上下文和说明（如果需要）。在上图中还可以看到“Upload for review”任务。此任务不限于 Photoshop 工作流。它可用于任何可以进行转码并作为可审核媒体上传到 ShotGrid 的文件类型。单机发布发布应用不需要在内容创建软件中运行。在这里，可以看到发布器可直接从 ShotGrid Desktop 启动。在单机模式下启动时，将出现一个区域，用于浏览或拖放文件。单击浏览按钮将打开标准文件浏览器，从中可以选择要发布的文件。从浏览器中选择文件或从文件系统上的某个位置拖放文件后，应用会将其作为顶层项目显示以供发布。与上述示例一样，您可以选择每个项目的上下文，设置说明，并确定发布时应执行哪些任务。发布类型以下各部分介绍了每个基本 ShotGrid 集成的自动收集的发布类型。单机单机工作流不自动收集文件进行发布。用户必须将文件路径拖动到界面中或浏览到文件才能进行发布。在单击“发布”(Publish)按钮之前，发布器将接受在任何点浏览或拖放的文件。基本集成将接受任何使用已知文件类型的文件扩展名，以关联到 ShotGrid 发布类型。如果文件扩展名未经识别，将使用文件的 MIME 类型。已识别的图像和视频 MIME 类型可供发布，并附有一个待上传审核的任务。基本集成假定拖放的文件夹包含图像序列。文件夹中任何已识别的图像序列将显示为待发布项目。如果没有找到序列，将不创建用于发布的项目。3ds Max将收集当前 Max 会话以供发布，其发布类型为 3dsmax 场景，可以通过加载器将其合并或参照到另一个 Max 会话中。如果可以确定用于当前会话的项目文件夹，则位于该项目 export 文件夹中的所有文件将显示为可发布。同样，位于该项目 preview 文件夹中的所有影片文件也将显示为可发布。Houdini将收集当前 Houdini 会话以供发布，其发布类型为 Houdini 场景，可以通过加载器将其合并到另一个 Houdini 会话中。另外，还将自动收集从以下类型节点写入磁盘的任何文件并显示为发布项目：  alembic  comp  ifd  opengl  wrenMaya将收集当前 Maya 会话以供发布，其发布类型为 Maya 场景，可以通过加载器将其导入或参照到另一个 Maya 会话中。如果可以确定用于当前会话的项目根，则位于该项目 cache/Alembic 文件夹中的所有 Alembic 文件将显示为可发布。同样，位于该项目 movies 文件夹中的所有影片文件也将显示为可发布。Nuke将收集当前 Nuke 会话以供发布，其发布类型为 Nuke 脚本，可以通过加载器将其导入到另一个 Nuke 会话中或作为新会话打开。另外，还将自动收集从以下类型节点写入磁盘的任何文件并显示为发布项目：  Write  WriteGeoNuke Studio将收集任何打开的 Nuke Studio 项目以供发布，其发布类型为 NukeStudio 项目，可以通过加载器将其作为新项目在另一个 Nuke Studio 会话中打开。Photoshop CC将收集任何打开的 Photoshop 文档以供发布，其发布类型为 Photoshop 图像，可以通过加载器在另一个 Photoshop 会话中将其作为新图层加载或作为新文档打开。加载器使用 ShotGrid 加载器可以快速简要了解和浏览已发布到 ShotGrid 的文件。通过一个可搜索的树视图导航系统可以轻松快速地到达您要查找的任务、镜头或资产，之后，加载器显示相应项目的所有发布的缩略图式概况。通过可配置的挂钩，您便可以轻松地在您的当前场景中引用或导入发布。发布是 ShotGrid 中的记录，每个发布都代表磁盘上的一个文件或一个文件序列（例如图像序列）。发布可以由任何应用程序创建，但通常是通过发布器来创建。发布创建以后，工作流中的其他人便可加载它们。此时就需要使用加载器。通过加载器，您可以浏览存储在 ShotGrid 中的发布，其方式类似于文件系统浏览器。概述通过加载器应用，可以快速浏览已发布到 ShotGrid 的文件。该应用具有可搜索的树视图导航系统，可以轻松查看任务、镜头或资产的缩略图。树视图使用左侧的树视图可以快速找到您要查找的镜头、资产或任务。如果您知道要查找的项目名称，可以在搜索区域中键入该名称，此时，只有匹配搜索短语的项目才会显示在树中。一旦您开始键入，树周围将显示一个蓝色条，表示您查看的不再是完整的树，而是树中基于搜索短语的项目子集。在您开始搜索之时，树中的所有节点将自动展开。为了方便起见，如果右键单击树，您将看到用于展开或收拢树中所有节点的选项。导航在树视图顶部，您将看到三个导航按钮。如果单击主页按钮，加载器将自动导航到表示您当前工作区的镜头或资产。如果要快速加载与您当前正在进行的工作相关的内容，该功能将非常有用。启动时，这也是加载器默认显示的位置。当您选择树视图中的不同项目时，将逐渐积累历史记录。与浏览器一样，可以使用后退和前进按钮来导航历史记录。查看发布一旦您选择树中的一个项目，可供使用的发布将显示在 UI 中间的发布区域。该视图中的每个项目都是发布流中的最新项目，因此，如果您查看版本 15 的纹理，这意味着该项目的版本历史记录中有 14 个先前版本。除了发布之外，您还将看到代表镜头、场、资产或其他 ShotGrid 实体类型的文件夹图标。如果有对象的缩略图，您会看到它叠加在文件夹的顶部，旨在使导航快速直观。双击文件夹将向下导航到位于层次结构中的该文件夹。有两种查看模式。如果您直观地浏览（例如查找纹理），缩略图模式非常有用。您可以快速查看列表，然后使用缩放控制柄快速放大和缩小。如果您浏览的内容不像纹理那么直观，例如 Nuke 脚本或 Maya 文件，您可以使用列表视图而非缩略图视图。此模式提供了更多信息，也更紧凑，允许您快速滚动浏览大量项目。如果您仅希望查看特定类型的项目，则可以使用左下方的 过滤器面板 来快速显示或隐藏发布。您还将在列表中的每个类型旁边看到一个摘要，表明为当前选择的树项目找到的每一类型发布数量。将一个或多个发布添加到场景中如果要将某个项目引入到场景中，只需双击它，加载器将执行发布的 默认动作 。可以采用多种方法将项目添加到场景中（例如，在 Maya 中，您可能希望将其他 Maya 文件参照或导入到场景中）。在这种情况下，单击 “动作”(Actions) 下拉菜单或右键单击发布的任意位置即可查看所有可用选项。如果要将多个项目引入到场景中，请选择多个元素，然后右键单击已选内容中的任意一项以显示 “动作”(Actions) 弹出菜单。请注意，仅显示可应用于已选内容中每一项的动作。如果您选择镜头或资产文件夹对象而不是发布，将显示用于在 ShotGrid 中或在文件系统中显示该项目的选项。使用早期发布如果您打开右侧详细信息窗格，将看到您选择的发布的所有版本历史记录。这样，您可以加载先前版本的发布。如果希望执行此操作，只需在版本历史记录中选择相应版本并使用动作菜单将其载入，就像在主视图中加载发布一样。相关审核如果发布具有关联的审核版本，您将在详细信息窗格中看到一个播放按钮。单击该按钮将在网页中打开审片室，您可以快速查看版本或向版本添加注释，以及使用 QuickTime 播放关联的审核版本。高级功能所有 ShotGrid 集成都是基于可高度自定义和扩展的工作流构建平台（名为 Toolkit）而建。有关如何访问和配置此功能的详细信息，请参见管理员手册。致谢  PySide 的错误修复版本随 ShotGrid Desktop 一起分发，可在此处获取。  动画电影“Big Buck Bunny”（大雄兔）由 (CC) Blender Foundation (www.blender.org) 提供通过添加 TANK_NO_HEADER 这个特殊标记，指示文档生成系统不需要生成标题。",
    "url": "/d587be80/",
    "relUrl": "/d587be80/"
  },
  "116": {
    "id": "116",
    "title": "为 Desktop 设置 Python 3",
    "content": "将 ShotGrid Desktop 中的默认 Python 版本设置为 Python 3                    警告: 本主题仅在使用 ShotGrid Desktop 版本 1.7.3 时有效，使用较新版本的 ShotGrid Desktop 时不再需要这些步骤。由于安全原因，ShotGrid Desktop 1.8.0 于 2023 年 1 月 26 日发布后，Python 2 随即遭到删除。单击此处了解更多信息。      Windows  MacOS  CentOS 7Windows在 Windows 上手动将 SHOTGUN_PYTHON_VERSION 环境设置为 2  在 Windows 任务栏上，右键单击 Windows 图标，然后选择“系统”，导航到“控制面板”/“系统和安全”/“系统”。  在此位置，选择“高级系统设置”。  接下来，在“系统属性”中选择“环境变量”。  在“环境变量”窗口中，可以通过选择“新建…”来添加/编辑路径。  对于“变量名”，添加 SHOTGUN_PYTHON_VERSION，并将“变量值”设置为 2。  重新启动 ShotGrid Desktop 应用程序。现在，您应该会看到 Python 版本已更新为运行 Python 2。MacOS在 MacOS 上将 SHOTGUN_PYTHON_VERSION 环境设置为 2  在 ~/Library/LaunchAgents/ 下创建名为 my.startup.plist 的属性文件$ vi my.startup.plist  将以下内容添加到 my.startup.plist 并保存：&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;https://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt; &amp;lt;plist version=&quot;1.0&quot;&amp;gt; &amp;lt;dict&amp;gt;   &amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;   &amp;lt;string&amp;gt;my.startup&amp;lt;/string&amp;gt;   &amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt;   &amp;lt;array&amp;gt;     &amp;lt;string&amp;gt;sh&amp;lt;/string&amp;gt;     &amp;lt;string&amp;gt;-c&amp;lt;/string&amp;gt;     &amp;lt;string&amp;gt;launchctl setenv SHOTGUN_PYTHON_VERSION 2&amp;lt;/string&amp;gt;   &amp;lt;/array&amp;gt;   &amp;lt;key&amp;gt;RunAtLoad&amp;lt;/key&amp;gt;   &amp;lt;true/&amp;gt; &amp;lt;/dict&amp;gt; &amp;lt;/plist&amp;gt;      重新启动 Mac 后，新环境变量将保持活动状态。        重新启动 ShotGrid Desktop 应用程序。现在，您应该会看到 Python 版本已更新为运行 Python 2。  CentOS 7在 CentOS 7 上将 SHOTGUN_PYTHON_VERSION 环境设置为 2  将以下内容添加到 ~/.bashrc 文件：export SHOTGUN_PYTHON_VERSION=&quot;2&quot;  通过运行以下命令重新启动操作系统：$ sudo reboot   重新启动 ShotGrid Desktop 应用程序。现在，您应该会看到 Python 版本已更新为运行 Python 2。",
    "url": "/69833488/",
    "relUrl": "/69833488/"
  },
  "117": {
    "id": "117",
    "title": "如何在启动软件之前设置环境变量？",
    "content": "如何在启动软件之前设置环境变量？ShotGrid Toolkit 允许您在启动过程中使用挂钩来配置环境并运行自定义代码。通过 ShotGrid Desktop 或浏览器集成启动软件（如 Nuke 或 Maya）时，将运行 tk-multi-launchapp。此应用负责启动软件并确保 ShotGrid 集成按预期启动。在此过程中将通过挂钩公开两个点以允许运行自定义代码。before_app_launch.py软件启动前将调用 before_app_launch.py 挂钩。这提供了一个绝佳机会来设置任何自定义环境变量以传递给启动的软件。示例：import osimport tankclass BeforeAppLaunch(tank.Hook):    def execute(self, app_path, app_args, version, engine_name, **kwargs):        if engine_name == &quot;tk-maya&quot;:            os.environ[&quot;MY_CUSTOM_MAYA_ENV_VAR&quot;] = &quot;Some Maya specific setting&quot;                    警告: 请注意，不要完全重新定义 ShotGrid 设置的环境变量。例如，如果需要将路径添加到 NUKE_PATH（对于 Nuke）或 PYTHONPATH（对于 Maya）中，请确保将您的路径附加到现有值，而不是将其替换。您可以使用便捷方法实现此目的：tank.util.append_path_to_env_var(&quot;NUKE_PATH&quot;, &quot;/my/custom/path&quot;)    自定义封装器某些工作室具有自定义封装器，支持设置环境变量和启动软件。如果您更愿意使用像这样的自定义代码设置环境，可以将 Software 实体的路径字段指向可执行封装器，此时将改为由 tk-multi-launchapp 运行。                    警告: 请谨慎使用此方法以保留 ShotGrid 设置的环境变量，否则集成将无法启动。    ",
    "url": "/624f2593/",
    "relUrl": "/624f2593/"
  },
  "118": {
    "id": "118",
    "title": "Setup",
    "content": "ShotGrid Isolation Feature Set - SetupIsolation the isolation features are independent of each other, and can be activated independently of each other. Media replication have as pre-requisite for Media Isolation to be implemented.The setup process will depend on which feature you want to activate for your site.In This Section  Planning your Setup  Media Isolation  Media Traffic Isolation  Media Replication  Isolation Fine Tuning  ActivationSetup OverviewUnderstand your responsibilitiesMake sure that you understand the client responsibilities and the implication of activating any of the Isolation feature.Start the onboarding processLeveraging the isolation features requires adopters to become AWS users. The features activation also requires Autodesk Support intervention. In order to ensure that this joint venture between Autodesk, AWS, and our clients is as streamlined as possible, we decided to work closely with AWS to define a cooperative onboarding process that would meet client expectations for a premium offering. Kick-start the onboarding process before going further.Planning your SetupBefore you start working on your setup, put a plan in place. Choose the features you need and get the required security/legal approval from your team to get started with the Isolation feature set.Media IsolationThis feature allow you to use a S3 Bucket owned by your studio to store media.Media Traffic IsolationThis feature allows for private routing of the media through the AWS Backbone and your studio network, isolating the media traffic from the public internet.Media ReplicationThis feature allows the media to be replicated between AWS Regions, for faster access in your world wide studios. Media Isolation is required.Fine TuningOnce the isolation features you need are activated, make sure that you everything is properly configured for security and cost-efficiency by reviewing this fine tuning guide.ActivationOnce everything is ready, it’s now time to migrate your production site to use the isolation features.",
    "url": "/8128c5fb/",
    "relUrl": "/8128c5fb/"
  },
  "119": {
    "id": "119",
    "title": "ShotGrid Desktop 能否在 Ubuntu 等 Debian 系统上运行？",
    "content": "ShotGrid Desktop 能否在 Ubuntu 等 Debian 系统上运行？目前，ShotGrid Desktop 不支持基于 Debian 的发行版。过去，我们有一些客户曾试图让 ShotGrid Desktop 在此类系统上正常运行，使用 cpio 从 RPM 提取 ShotGrid Desktop，然后尝试满足库依存关系，但这样导致了较差的结果。有关参考，请在我们的 dev 组中查看此主题。请注意，我们未提供显式的库依存关系列表，因为 Python 本身位于很多系统级库之上。目前我们还没有正式的 Debian 支持计划。Ubuntu 构建存在问题，但在更改时需要进行 QA 并支持额外的操作系统，这并不是一件简单的事情。如果要手动运行并激活 Toolkit 而不使用 ShotGrid Desktop（如此处文档所述），请从该文档页面下载 activate_shotgun_pipeline_toolkit.py 脚本 - 即手册的第 8 步，单击“单击以下载…”标题。",
    "url": "/3830df9d/",
    "relUrl": "/3830df9d/"
  },
  "120": {
    "id": "120",
    "title": "开发应用",
    "content": "开发自己的应用简介本手册概述了什么是 Toolkit 应用，说明了如何创建应用，并介绍了有关应用开发的一些基础知识。ShotGrid Pipeline Toolkit 不仅是 ShotGrid Software 维护的一套应用和插件，还是一个可用来轻松快速构建自定义工作流工具的开发平台！  什么是 Toolkit 应用？  创建自己的应用。步骤：  创建开发沙盒  Fork 或下载入门应用库  将应用添加到配置  开发应用          模板入门应用剖析      配置设置      框架      重新加载更改        测试  准备第一个版本发布附加信息：  修改现有应用          贡献      什么是 Toolkit 应用？Toolkit 应用可定义如下：  通常由最终用户使用 ShotGrid 集成运行的工具。  这些应用通常具有图形用户界面，用户可以使用该界面来指导应用的操作，但这不是必需的。应用也可以是向集成注册的命令，由用户从宿主软件中的 ShotGrid 菜单触发。  它们可以包含 API/公共方法，其他流程或应用可以通过这些方法进行交互。  它们可以支持多平台且与软件无关。  可以根据环境将其设置为以不同方式配置。  它们可以支持上下文感知。例如，应用可以识别用户正在处理的任务，并执行相应的动作。  只能从 Toolkit 插件运行它们。Toolkit 应用由 Toolkit 插件初始化。插件适于在特定软件环境中运行，它们可在此环境中提供一个用于运行 Toolkit 应用的界面。插件消除了需要从应用处理各种软件环境的复杂性。这意味着，应用只需专注于提供实现其用途的功能，无需考虑其他方面，例如，处理窗口父子关系、跟踪用户的上下文或提供用于启动本身的快捷方式。创建自己的应用。ShotGrid Software 维护和发布的应用和插件全部开源，可从 GitHub 获取这些应用和插件。本部分介绍如何使用我们的入门模板创建新应用。我们假设您熟悉 GitHub 和 Git 工作流。但是请注意，即使您不使用 Git 作为源代码管理解决方案，也可以进行 Toolkit 开发。第 1 部分：创建开发沙盒在进行其他任何操作之前，建议您先通过克隆项目配置来设置一个开发沙盒。这将创建一个单独的配置，您可以在其中开发代码并测试更改，而不会影响参与制作的其他任何人。第 2 部分：Fork 或下载入门应用库我们提供了模板入门应用，您可以在此基础上创建自己的应用。使用此应用，所有的标准 Toolkit 样板代码都已为您设置好，还提供了一个基本示例 GUI。要使用它，您可以 Fork Git 库，然后将其克隆到磁盘上的本地开发区域；或者如果您不想在此阶段使用 Git 源代码管理工具，只需从 GitHub 下载 zip 格式的文件，并在本地解压缩（以后随时可以设置 Git 库）。无论哪种情况，目标都是获得入门应用代码的本地副本，以便可以开始进行更改。第 3 部分：将应用添加到配置我们建议阅读“添加应用”手册，此手册详细介绍了如何将应用添加到配置。在将应用添加到配置时，需要考虑应用的使用位置，即，可能只在 Nuke 中、在多个不同的软件中或与 ShotGrid Desktop 分开单独使用。此外，还需要考虑应用将依赖的上下文。例如，您的应用仅在您知道用户正在处理的任务时才能运行，还是只要知道项目就可以运行？了解这一点将决定需要向哪些环境 YAML 和插件添加应用设置。如果您现在不确定，建议先将其添加到项目环境中的 tk-shell 插件。这样，您就可以从 IDE 运行它，或者如果您有集中式配置，则通过命令行和 tank 命令运行它。从而可以更快地进行开发。首先，使用开发描述符作为应用的位置。tk-multi-starterapp:  location:    type: dev    path: /path/to/source_code/tk-multi-starterapp此设置指示 Toolkit 直接从磁盘的给定位置加载应用代码，对于需要不停更改代码的开发工作来说，这种做法非常方便。以后，当您将应用添加到制作配置时，可能希望使用其他描述符。现在，您已将应用添加到环境中；您应该能够继续操作并启动它。应用的启动方式取决于在其中定义它的插件和环境。第 4 部分：开发应用现在，您已准备好开始开发您的应用！模板入门应用剖析模板入门应用包含以下基本结构：  app.py - 应用入口点和菜单注册信息可在 app.py 文件中找到。通常在这里设置类、进行初始化和注册菜单项。  info.yml - 也称为清单文件。它定义此应用安装时所需的所有不同设置，以及相应的默认值（如果提供）。当您需要可重用的应用、不想以硬编码方式向应用本身写入任何值时，这些设置通常非常有用。  python/app/dialog.py - 包含生成主应用窗口的逻辑、事件回调等。  python/app/ui - 此文件夹包含自动生成的 UI 代码和资源文件。您不是直接编辑此文件夹，而是编辑 resources 文件夹中的 Qt UI 文件。  resources/ - 在 resources 文件夹中，dialog.ui 文件是一个 Qt Designer 文件，您可以打开并使用它快速设计和定义应用的外观。进行更改后，您需要执行 build_resources.sh 脚本，将 UI 文件转换为 Python 代码并将其存储为 /python/app/ui/dialog.py。  style.qss - 您可以在此文件中定义 UI 的 QSS（Qt 样式表）。                    注意: 应用不必具有 UI，成为有效应用的最低要求是有一个包含 Application 类的 app.py 和一个 info.yml。    配置设置在清单文件中，应该有一个可用于定义应用设置的 configuration 部分。通过在清单文件中定义设置，您可以在环境 YAML 文件中为应用配置不同的设置值。如果应用需要根据其所在环境呈现不同的行为，这很有用。例如，您可能希望有一个设置用于定义保存文件时使用的模板。save_template:    type: template    default_value: &quot;maya_asset_work&quot;    description: The template to use when building the path to save the file into    allows_empty: False为此创建设置意味着您不必在应用代码中对模板名称进行硬编码，而是可以从 info.yml 中默认定义的设置或环境 YAML 文件设置中的覆盖定义的设置获取值。template = app.get_setting(&quot;save_template&quot;)这意味着您可以将应用配置为根据应用的运行环境使用不同的模板。有关配置设置的详细信息，请参见参考文档。框架如果您知道将要使用框架，可以将其添加到清单文件中。例如，如果您计划为应用使用 Qt 控件和 ShotGrid 实用程序框架，请将以下内容添加到 info.yml 中：# the frameworks required to run this appframeworks:    - {&quot;name&quot;: &quot;tk-framework-shotgunutils&quot;, &quot;version&quot;: &quot;v2.x.x&quot;}    - {&quot;name&quot;: &quot;tk-framework-qtwidgets&quot;, &quot;version&quot;: &quot;v1.x.x&quot;}框架版本最低要求如果框架具有最低版本要求，可以在 info.yml 中使用 minimum_version 设置：# the frameworks required to run this appframeworks:    - {&quot;name&quot;: &quot;tk-framework-shotgunutils&quot;, &quot;version&quot;: &quot;v2.x.x&quot;}    - {&quot;name&quot;: &quot;tk-framework-qtwidgets&quot;, &quot;version&quot;: &quot;v1.x.x&quot;, &quot;minimum_version&quot;: &quot;v1.5.0&quot;}上面的代码将确保应用可以使用 v1.5.0 版本的 tk-framework-qtwidgets。如果这个版本不可用，应用将不会在启动时加载，并在控制台显示错误。当使用 tank updates 更新应用时，所有不符合最低版本要求的已配置框架都将随应用一起自动更新。有关框架及其用途的详细信息，请参见以下链接：  QT 控件框架  ShotGrid实用程序框架重新加载更改如果您在 Maya 等软件中测试应用，那么只要您的配置中有一个或多个开发项，Toolkit 就会自动将“重新加载并重新启动”(Reload and Restart)选项添加到 ShotGrid 菜单中。单击此选项将重新加载配置和代码，然后重新启动插件。这意味着您可以快速进行迭代：只需启动 Maya 一次，之后每次做出所需的代码或配置更改时，只需单击“重新加载并重新启动”(Reload and Restart)按钮，即可调入这些更改。                    注意: 如果屏幕上有任何用户界面处于激活状态，这些用户界面将不会自动更新，您必须进入菜单重新启动它们。    第 5 部分：测试当您想要测试代码时，可以轻松邀请其他用户访问您的开发沙盒，方法是将他们添加到 ShotGrid 中 PipelineConfiguration 实体的 User Restrictions 字段中。添加用户后，这些用户随即就会在 ShotGrid Create 中自己的菜单和浏览器动作中看到新条目，以及一个用于在 ShotGrid Desktop 中选取配置的选项。                    注意: 还要确保他们有权限查看您的应用代码，否则应用将不会加载。    第 6 部分：准备第一个版本发布在第 3 部分中，已使用 dev 描述符将配置设置为指向应用。对于发布的软件，您希望确保应用可供所有用户访问，并且对内容进行版本控制，以便安全、轻松地升级。ShotGrid 提供的所有应用均使用 Toolkit 应用商店跟踪更新和版本发布，它们带有一个类似如下的 location 标记：location:   name: tk-multi-setframerange   type: app_store   version: v0.1.7通过该标记，Toolkit（例如 tank updates 命令）可以检查更新何时可用，并以一种非常安全的方式更新和维护配置。每当运行更新命令以及有新版本可用时，Toolkit 都会下载代码，将其放在磁盘上的一个本地“缓存”中，并确保用户可以访问它。有几个不同的选项可用于为应用版本提供来源。  Git 和 GitHub  ShotGrid 上传  本地路径在您的制作配置中，可以添加应用，并转为使用符合您的需求的描述符。基于 Git 的描述符我们建议开始使用源代码管理工具以确保跟踪更改，无论您是否要使用 Git 描述符都是如此。Toolkit 支持即时使用 Git（https://git-scm.com/），在对配置运行 tank updates 时，它可以检查您的 Git 库中的最新版本，并更新配置，就像使用应用商店描述符一样。此项的要求如下：  您的 Git 库需要仅包含一个应用  您的 Git 库应与入门应用库具有相同的结构。  创建标记时，使用“语义版本控制”(Semantic Versioning)。Toolkit 将使用这些版本号来尝试确定哪个版本是最新版本，版本号遵循 vX.Y.Z 约定形式。在 Git 中创建第一个标记（例如 v1.0.0）后，可以设置配置以使用指向标记的 Git 描述符。然后，您就可以直接运行 tank updates，如果已创建新标记，程序将提示您是否要升级。此时，整个工作流便与官方应用商店的流程完全相同。                    注意: Git 描述符适用于集中式配置，在该配置下，应用的缓存通常由管理员运行并存储到所有用户均可访问的集中位置。但是，如果您使用的是分布式配置，则可能不太合适。您的应用将以单个用户为单位进行下载，这意味着每个用户都需要安装并设置 Git 才能向您的库认证身份并访问代码。    修改现有应用有时，我们并不会使用空白的入门模板从头创建应用，而是需要为现有应用（例如 ShotGrid Software 的某个标准应用）添加一项小功能。处理修改版的应用时，您通常会想要比照源应用，确保定期下载更改和错误修复。当您进行这类开发时，首先是提取父代码，然后应用自己的更改，再将此版本发布到您的工作流中。您发布的版本实际上由应用的基础版本和您应用的本地更改组成。我们建议您为现有版本号添加版本后缀。这种做法非常适合 Toolkit，并且看起来相对直观。下面的工作流说明了整个操作：  您对父应用执行 Fork 操作，并创建自己的库。通过 Fork 操作，您获得所有 Git 标记。假定最新的标记名为 v0.2.12，主分支基本上与此标记中的内容相同。  您应用自己的更改，并提交至主分支。这时得到的是 v0.2.12 加上您的更改。将此版本发布到生产环境时，您需要创建一个标记。将该标记命名为 v0.2.12.1，以表示您的代码基于 v0.2.12，并且是第一个版本发布。  现在有人发现您的修改中有一个错误。您修复此错误、更新标记并发布 v0.2.12.2。  父库中发布了多项重要的错误修复。您将它们下载到您的库。由于父库中发布了若干个版本，最新标记现在为 v0.2.15。将您的更改合并到主分支，并进行测试。这时得到的基本上是父应用 v0.2.15 与您的更改合并后的结果。更新标记为 v0.2.15.1。上面概述的标记方案可保证 Toolkit 更新能够正确工作，并且便于您快速了解 Fork 中每个标记基于哪些代码。贡献我们欢迎大家提出 Pull 请求！如果您觉得自己的更改对其他人有益，请随时以 Pull 请求的形式反馈给我们。我们随后可以将更改合并到应用的主版本中。或者，您也可以在路线图页面上添加有关新想法的建议。如果您开发了完整的应用并愿意与社区共享，请在论坛上告诉大家。",
    "url": "/2e5ed7bb/",
    "relUrl": "/2e5ed7bb/"
  },
  "121": {
    "id": "121",
    "title": "引导和运行应用",
    "content": "引导和运行应用本手册将指导您完成 Toolkit 插件初始化过程，以便您可以运行自定义代码或启动应用，该过程也称为引导。引导适用于 Toolkit 插件尚未启动而您需要使用 API 的情况。例如，您可能有一个处理脚本，它在渲染农场上运行，并且需要利用 Toolkit API 来处理路径和上下文。或者，您可能希望能够从您常用的 IDE 运行 Toolkit 应用。                    注意: 如果您使用的是分布式配置，则必须先初始化 Toolkit 插件，然后再运行 Toolkit API 方法。如果使用的是集中式配置，可以在不引导插件的情况下使用 API（这时使用工厂方法），但是，在导入 sgtk 时，需要手动查找用于项目的正确核心 API 的路径。    要求  了解 Python 编程基础知识。  采用高级配置的项目。如果您之前尚未设置配置，可以按照“配置快速入门”手册进行操作。步骤  导入 Toolkit API 以便进行引导  日志记录  身份认证  引导插件  启动应用  完整脚本第 1 部分：导入 Toolkit API 以便进行引导应从何处导入 sgtk？如果您已按照“生成路径并发布”手册进行操作，则您已完成导入 sgtk 的步骤。该手册指出您必须从要使用的项目配置导入 sgtk 软件包。对于引导，仍是这样，但是，导入哪个初始 sgtk 软件包无关紧要，因为任何 Toolkit API 都可以执行引导操作以采用不同的项目配置。引导过程会将当前导入的 sgtk 软件包换为新项目配置的 Toolkit API。下载独立的 Toolkit 核心 API首先，您需要导入 sgtk API 软件包，该软件包位于 tk-core 中。您可以从现有项目导入一个软件包，但是，这可能不太容易找到。建议下载最新核心 API 的独立副本，该副本将只用于引导。应将其存储在方便导入的位置。确保添加的路径指向 tk-core 文件夹内的 python 文件夹，因为这是 sgtk 软件包所在的位置。代码# If your sgtk package is not located in a location where Python will automatically look# then add the path to sys.path.import syssys.path.insert(0, &quot;/path/to/tk-core/python&quot;)import sgtk第 2 部分：日志记录如果您要通过 IDE 或 Shell 运行此脚本，则很可能希望能够输出日志记录。为此，您需要运行 LogManager().initialize_custom_handler()。您不需要为此目的提供自定义处理程序，因为如果不提供，将会设置基于流的标准日志记录处理程序。（可选）您还可以设置 LogManager().global_debug = True 以便获得更详细的输出。这意味着，现在将会输出我们或您自己的代码中的任何 logger.debug() 调用。日志记录可能会影响性能，因此只应在开发时启用调试日志记录，并尝试限制 logger.info() 方法调用的数量，以仅输出对在正常操作期间了解状况非常重要的内容。import sgtk# Initialize the logger so we get output to our terminal.sgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing).sgtk.LogManager().global_debug = True第 3 部分：身份认证在已启动 ShotGrid Toolkit 的环境之外运行使用 Toolkit API 的脚本时，始终需要进行身份认证。因此，要执行引导，需要向 ShotGrid 站点认证 Toolkit API 的身份。您可以使用用户凭据或脚本凭据进行身份认证。  如果目的是为面向用户的过程（如启动应用或运行需要用户输入的代码）引导，则用户身份认证是最佳方式（这是我们的所有集成的默认工作方式）。  如果您要编写脚本来自动执行某项操作，并且没有用户要进行身份认证，则应使用脚本凭据。身份认证通过 ShotGridAuthenticator 类进行处理。下面是用户和脚本身份认证示例。用户身份认证# Import Toolkit so we can access to Toolkit specific features.import sgtk# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Optionally you can clear any previously cached sessions. This will force you to enter credentials each time.authenticator.clear_default_user()# The user will be prompted for their username,# password, and optional 2-factor authentication code. If a QApplication is# available, a UI will pop-up. If not, the credentials will be prompted# on the command line. The user object returned encapsulates the login# information.user = authenticator.get_user()# Tells Toolkit which user to use for connecting to ShotGrid. Note that this should# always take place before creating an `Sgtk` instance.sgtk.set_authenticated_user(user)脚本身份认证# Import Toolkit so we can access to Toolkit specific features.import sgtk# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your ShotGrid site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to ShotGrid.sgtk.set_authenticated_user(user)第 4 部分：引导插件现在，您已为会话认证了 Toolkit API 的身份，可以开始引导过程了。您可以在我们的参考文档中找到大量有关引导 API 的信息。高级别的引导过程基本上会执行以下步骤：  检索或找到 Toolkit 配置文件夹。  确保缓存中存在配置依存项（如应用和插件）。如果它们不存在，并且它们使用基于远程服务的描述符（如 app_store 或 ShotGrid），则该过程会将其下载到缓存。  将当前加载的 sgtk 核心换为适合配置的核心。  初始化插件、应用和框架。                    注意: 通常情况下，引导应处理相应插件成功运行所需的所有事项。但是，在某些情况下，插件可能会有不属于引导过程的特定设置要求，必须单独处理。    引导准备要进行引导，必须先创建 ToolkitManager 实例。mgr = sgtk.bootstrap.ToolkitManager(user)  如果 user 未传递到 ToolkitManager 的初始化器，则会在内部调用 ShotgunAuthenticator().get_user()，这将返回当前已经过身份认证的 ShotGrid 用户。要使用任何其他 HumanUser 或 ScriptUser 进行引导，请传入通过 ShotgunAuthenticator.create_session_user 或 ShotgunAuthenticator.create_script_user 创建的用户。为使 Toolkit 正常引导，至少需要知道实体、插件 ID 和插件。由于参考文档中介绍了所有可用参数和选项，因此本手册未做全面介绍。插件 ID在调用引导方法之前，可以通过向 ToolkitManager.plugin_id 参数传递字符串来定义插件 ID。在本手册中，您将引导 tk-shell 插件，因此应按照参考文档中所述的约定提供合适的插件 ID 名称。mgr.plugin_id = &quot;basic.shell&quot;插件如果您的目标是在 Maya 或 Nuke 等软件之外的独立 Python 环境中启动应用或运行 Toolkit 代码，则要引导到 tk-shell 插件。如果您想在支持的软件中运行 Toolkit 应用，则需要选取合适的插件，如 tk-maya 或 tk-nuke。此参数将直接传递给 ToolkitManager.bootstrap_engine() 方法。请参见下面的“实体”部分中的示例。实体ToolkitManager.bootstrap_engine() 方法 entity 参数用于为启动的插件设置上下文以及环境。该实体可以是将配置设置为与其一起使用的任何实体类型。例如，如果提供 Project 实体，则插件将在项目上下文中启动，并使用项目环境设置。同样，您可以提供 Task 实体（即任务链接到 Asset），则它将使用 asset_step.yml 环境启动。这取决于默认配置行为，选择的环境通过核心挂钩 pick_environment.py 进行控制，因此可以更改为根据上下文或其他参数选取不同的环境。您需要以 ShotGrid 实体词典的格式提供实体，必须至少包含类型和 ID：task = {&quot;type&quot;: &quot;Task&quot;, &quot;id&quot;: 17264}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=task)如果引导到 Project 以外的实体类型，则可能需要确保缓存路径同步，否则，在某些情况下（如引导过程尝试解析模板），可能无法加载环境。由于在引导之前没有 Sgtk 实例，因此您需要告知引导过程在创建 Sgtk 实例后、启动插件之前执行同步。这可以通过将 ToolkitManager.pre_engine_start_callback 属性设置为指向自定义方法来实现。然后可以在该方法中运行同步：def pre_engine_start_callback(ctx):    '''    Called before the engine is started.    :param :class:&quot;~sgtk.Context&quot; ctx: Context into        which the engine will be launched. This can also be used        to access the Toolkit instance.    '''    ctx.sgtk.synchronize_filesystem_structure()mgr.pre_engine_start_callback = pre_engine_start_callback配置选择您可以选择明确定义要引导的配置，也可以让引导逻辑自动检测合适的配置。您甚至可以设置回退配置，以在未自动找到配置的情况下使用。在本手册中，我们假定您的项目已设置配置，并且将会自动找到它。引导设置了所有 ToolkitManager 参数并调用 ToolkitManager.bootstrap_engine() 方法后，将立即启动插件，并返回指向插件实例的指针。下面是到目前为止的所有相关代码：# Import Toolkit so we can access to Toolkit specific features.import sgtk# Initialize the logger so we get output to our terminal.sgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing).sgtk.LogManager().global_debug = True# Authentication################# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your ShotGrid site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to ShotGrid.# This is actually not necessary when using the ToolkitManager. The authenticated user will be set# before launching the engine.# sgtk.set_authenticated_user(user)# Bootstrap############ create an instance of the ToolkitManager which we will use to set a bunch of settings before initiating the bootstrap.mgr = sgtk.bootstrap.ToolkitManager(user)mgr.plugin_id = &quot;basic.shell&quot;project = {&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=project)第 5 部分：启动应用现在，您已经有了插件实例，接下来就可以开始使用 Toolkit API。在介绍如何启动应用之前，需要指出的是，您可以通过插件获取当前上下文、Sgtk 实例和 ShotGrid API 实例。engine.contextengine.sgtkengine.shotgun虽然本手册的最终目标是介绍如何启动应用，但您可以在此基础之上，利用上述属性并测试一些代码段，或者运行一些利用 Toolkit API 的自动操作。启动应用插件启动时，会初始化为环境定义的所有应用。这些应用进而向插件注册命令，而且插件通常会将这些命令作为动作显示在菜单中（如果在 Maya 等软件中运行）。查找命令要先查看已注册的命令，可以输出 Engine.commands 属性：# use pprint to give us a nicely formatted output.import pprintpprint.pprint(engine.commands.keys())&amp;gt;&amp;gt; ['houdini_fx_17.5.360', 'nukestudio_11.2v5', 'nukestudio_11.3v2', 'after_effects_cc_2019', 'maya_2019', 'maya_2018', 'Jump to Screening Room Web Player', 'Publish...',...]从该列表可以查看已注册并且可以运行的命令。运行命令命令运行方式因插件而异，因为当前没有标准化方法。对于 tk-shell 插件，您可以使用便捷方法：Engine.execute_command()。它需要命令字符串名称（已在前面列出），以及应用的命令预期要传递的参数列表。if &quot;Publish...&quot; in engine.commands:    # Launch the Publish app, and it doesn't require any arguments to run so provide an empty list.    engine.execute_command(&quot;Publish...&quot;,[])如果不在 tk-shell 插件中运行，则可以回退以直接调用已注册的回调。# now find the command we specifically want to executeapp_command = engine.commands.get(&quot;Publish...&quot;)if app_command:    # now run the command, which in this case will launch the Publish app.    app_command[&quot;callback&quot;]()现在，应用应该已经启动，如果您运行 tk-shell 插件，输出应显示在终端/控制台中。第 6 部分：完整脚本# Import Toolkit so we can access to Toolkit specific features.import sgtk# Initialize the logger so we get output to our terminalsgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing)sgtk.LogManager().global_debug = True# Authentication################# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your ShotGrid site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to ShotGrid.# This is actually not necessary when using the ToolkitManager. The authenticated user will be set# before launching the engine.# sgtk.set_authenticated_user(user)# Bootstrap############ create an instance of the ToolkitManager which we will use to set a bunch of settings before initiating the bootstrap.mgr = sgtk.bootstrap.ToolkitManager(user)mgr.plugin_id = &quot;basic.shell&quot;project = {&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=project)# Optionally print out the list of registered commands:# use pprint to give us a nicely formatted output.# import pprint# pprint.pprint(engine.commands.keys())if &quot;Publish...&quot; in engine.commands:    # Launch the Publish app, and it doesn't require any arguments to run so provide an empty list.    engine.execute_command(&quot;Publish...&quot;,[])",
    "url": "/3d8cc69a/",
    "relUrl": "/3d8cc69a/"
  },
  "122": {
    "id": "122",
    "title": "开发插件",
    "content": "开发自己的插件简介本文档概述了与 Toolkit 插件开发相关的一些技术细节。目录：  什么是 Toolkit 插件？  开始之前要了解的事项  插件集成方法          宿主软件包含 Qt、PyQt/PySide 和 Python      宿主软件包含 Qt 和 Python 但不包含 PySide/PyQt      宿主软件包含 Python      宿主软件不包含 Python，但您可以编写插件      宿主软件完全不提供脚本编写功能        Qt 窗口父子关系设置  启动行为  宿主软件期望具备的特性列表什么是 Toolkit 插件？开发插件时，您实际上是在宿主软件与插件中加载的各种 Toolkit 应用和框架之间搭建一个连接桥梁。通过插件，可以抽象出各个软件之间的不同，从而可以使用 Python 和 Qt 以很大程度上与软件无关的方式编写应用。插件是一系列文件的集合，结构上与应用相似。它具有一个 engine.py 文件，而且该文件必须派生自核心 Engine 基类。不同的插件根据内部的复杂性，重新执行此基类的各个方面。插件通常处理或提供下列服务：  菜单管理。插件启动时，待应用加载完毕后，插件需要创建其 ShotGrid 菜单，并将各种应用添加到此菜单中。  日志记录方法通常会被改写，以便向软件的日志/控制台写入数据。  用于显示 UI 对话框和窗口的方法。如果插件处理 Qt 的方式与默认基类行为不同，通常会改写这些方法，以确保无缝集成 Toolkit 应用启动的窗口和基本宿主软件窗口管理设置。  提供一个 commands 词典，其中包含应用注册的所有命令对象。创建菜单项时通常会访问此词典。  基类公开各种 init 和 destroy 方法，这些方法将在启动过程的不同时间点执行。用户可改写这些方法来控制启动和关闭的执行。  启动时由 tk-multi-launchapp 调用的启动逻辑以及自动发现软件。插件由 Toolkit 平台使用 sgtk.platform.start_engine() 或 sgtk.bootstrap.ToolkitManager.bootstrap_engine() 方法启动。此命令会读取配置文件、启动插件并加载所有应用等。插件的目的在于，一旦启动，它将为各种应用提供一个统一的 Python/Qt 界面。由于所有插件执行的是同一个基类，因此应用可调用插件上的方法来执行各种操作，例如创建 UI。每个插件自己决定如何执行这些方法，以便它们能在宿主软件内部良好运行。开始之前要了解的事项我们为最常用的内容创建软件提供了集成。此外，还有 Toolkit 社区成员构建和共享的插件。但是，有时需要对还没有 Toolkit 插件的软件使用工作流集成。如果您有时间和资源，我们鼓励您帮助 Toolkit 社区（以及您自己）编写您想要使用但目前缺少的插件！在着手编写代码前，欢迎与我们交流和讨论！我们无法做出任何承诺，但我们很乐意与您讨论您的计划。我们或许还可以为您介绍其他对同样的插件感兴趣或进行过类似开发的用户。如果可以，请与要集成 Toolkit 的软件的技术联系人或开发人员建立沟通渠道。这将有助于您深入了解开发过程中存在的各种可能性和/或障碍。在建立联系并向他们说明您的基本构想后，您可以让我们也加入讨论，安排会议共同讨论插件的一些具体细节。此外，您还可以通过 ShotGrid 社区论坛直接加入 Toolkit 社区讨论。我们期待看到新的集成，对于大家为 Toolkit 社区所做的慷慨贡献感激不尽！                    提示: 开发自己的应用提供了应用开发分步指南，其中包含适用于插件开发的原则以及本手册中未介绍的原则。    插件集成方法根据宿主应用程序功能的不同，插件开发的复杂程度也会各异。本部分概述了我们在插件开发过程中遇到的几种不同的复杂程度。宿主软件包含 Qt、PyQt/PySide 和 Python这是 Toolkit 的最佳设置，在支持 Qt、Python 和 PySide 的宿主软件之上执行插件，操作起来非常简单。Nuke 插件或 Maya 插件就是一个很好的例子。集成操作只是连接一些日志文件管理和编写代码设置 ShotGrid 菜单而已。宿主软件包含 Qt 和 Python 但不包含 PySide/PyQt例如，Motionbuilder 就是此类软件，它们相对易于集成。由于宿主软件本身使用 Qt 编写，并且包含 Python 解释器，因此我们可以编译一个 PySide 或 PyQt 版本，然后使用插件进行分发。随后，这个 PySide 会被添加到 Python 环境中，这样我们将可以使用 Python 访问 Qt 对象。通常，在编译 PySide 时，必须使用与编译镜头应用程序时完全相同的编译器设置，以保证它能够正常工作。宿主软件包含 Python例如，第三方集成 Unreal 就是此类软件。这些宿主软件具有非 Qt UI，但是包含 Python 解释器。这意味着，Python 代码可以在环境内执行，只是没有现有的 Qt 事件循环运行。这种情况下，需要在插件中包含 Qt 和 PySide，并且必须将 Qt 消息泵（事件）循环与 UI 中的主事件循环相连。宿主软件有时可能包含专门用于此用途的特殊方法。如果不包含，则必须做好安排，例如通过 on-idle 调用方法，让 Qt 事件循环定期运行。宿主软件不包含 Python，但您可以编写插件此类软件包括 Photoshop 和 After Effects。程序没有 Python 脚本编写功能，但是可以创建 C++ 插件。在这种情况下，采取的策略通常是创建一个插件，该插件包含一个 IPC 层，并会在启动时以单独的进程启动 Qt 和 Python。等到辅助进程开始运行时，将使用 IPC 层来回发送命令。这类宿主软件往往意味着我们需要进行大量工作才能获得可以使用的插件解决方案。                    提示: 实际上，我们为 Photoshop 和 After Effects 插件创建了一个处理 Adobe 插件的框架。这两个插件均利用该框架与宿主软件通信，而且利用该框架可以更加轻松地为 Adobe 系列的其余产品构建其他插件。    宿主软件完全不提供脚本编写功能如果宿主软件完全不能通过编程方式访问，将无法为它创建插件。Qt 窗口父子关系设置窗口父子关系设置通常是一个需要特别注意的方面。通常，PySide 窗口在控件层次结构中并不会自然具有父窗口，这需要明确指出。窗口父子关系设置对于提供一致的体验来说非常重要，如果不实现这一点，Toolkit 应用窗口可能会显示在主窗口后面，看上去会非常混乱。启动行为插件还负责处理软件及其集成的启动方式。当 tk-multi-launchapp 尝试使用插件启动软件时，将调用此逻辑。有关如何设置此项的详细信息，请参见核心文档。宿主软件期望具备的特性列表Toolkit 插件可利用宿主软件的以下特性 (Trait)。支持的特性越多，插件的体验越好！  内置 Python 解释器、Qt 和 PySide！  可在软件启动/初始化时运行代码。  可在两种情况下访问和自动运行代码：一个是软件正常运行时，另一个是 UI 已完全初始化时。  提供 API 命令来打包文件系统交互操作：“打开”(Open)、“保存”(Save)、“另存为”(Save As)、“添加参考”(Add Refernece)等。      提供 API 命令来添加用户界面元素          向应用中添加自定义 QT 控件作为面板（最好是通过捆绑的 PySide）      添加自定义菜单/上下文菜单项      在基于节点的软件包中添加自定义节点（通过简单的方法集成自定义 UI 进行交互）      提供自检功能发现选定的项/节点等对象        灵活的事件系统          “有意义”的事件可以触发自定义代码        支持异步运行用户界面          例如，当某个自定义菜单项被触发时弹出一个不锁定界面的对话框      为顶层窗口提供句柄，以便可以正确设置自定义 UI 窗口的父子关系      ",
    "url": "/be19bc87/",
    "relUrl": "/be19bc87/"
  },
  "123": {
    "id": "123",
    "title": "开发框架",
    "content": "开发自己的框架简介本文档概述了与 Toolkit 框架开发相关的一些技术细节。目录：  什么是 Toolkit 框架？  预制 ShotGrid 框架  创建框架  通过挂钩使用框架什么是 Toolkit 框架？Toolkit 框架与 Toolkit 应用非常相似。主要区别在于，框架不会自行运行。而是需要将框架导入应用或插件中。它使您可以独立保存可重用的逻辑，以便在多个插件和应用中使用。可重用的 UI 组件库就是一个框架示例，其中可能包含一个播放列表拾取器组件。然后，您可以将此框架导入应用中，并将播放列表拾取器组件插入到主应用 UI 中。预制 ShotGrid 框架ShotGrid 提供了一些预制的框架，在创建自己的应用时，您会发现这些框架非常有用。Qt 控件和 ShotGrid 实用程序框架在应用开发中特别有用。创建框架当创建您自己的框架时，设置与编写应用几乎相同，您可以在“开发自己的应用”手册中了解有关编写应用的详细信息。框架在框架软件包根目录下有一个 framework.py（而非 app.py 文件），其中包含从 Framework 基类派生的类。此外，您的框架不会向插件注册命令。您可以直接在框架实例本身中存储方法，或将模块存储在 python/ 文件夹中。例如，Shotgun 实用程序框架将它们存储在 Python 文件夹中。要访问它们，需要导入框架，然后使用 import_module() 方法访问子模块。API 文档中包含有关如何导入框架的示例。通过挂钩使用框架创建框架非常有用，这使您可以跨挂钩共享一些常用逻辑。通过 Hook.load_framework() 方法，可以在应用或其他框架挂钩中使用框架，即使应用/框架在清单文件中未明确要求如此。请注意，即使使用此方法，也无法在核心挂钩中使用框架。",
    "url": "/312b792f/",
    "relUrl": "/312b792f/"
  },
  "124": {
    "id": "124",
    "title": "生成路径并发布",
    "content": "生成路径并发布本手册介绍了 ShotGrid Toolkit Python API 快速入门相关信息，我们的工作流集成基于此 API 构建而成。本手册旨在介绍如何使用此 API 的基本示例，最后，您将能够导入 Toolkit API 并生成和发布路径。要求  了解 Python 编程基础知识。  采用高级配置的项目。如果您之前尚未设置配置，可以按照配置快速入门手册进行操作。步骤  导入 sgtk  获取 Sgtk 实例  获取上下文  创建文件夹  使用模板构建路径  查找现有文件并获取最新版本号  注册已发布的文件  全部整合到一个完整脚本中第 1 部分：导入 sgtkToolkit API 包含在名为 sgtk 的 Python 软件包中。每个 Toolkit 配置均有自己的 API 副本，tk-core 中对此 API 进行了介绍。要在项目配置中使用 API，必须从要使用的配置导入 sgtk 软件包，从其他配置导入此软件包会导致出现错误。                    注意: 有时，您可能会遇到 tank 软件包。这是旧名称，但内容相同。尽管这两个名称均适用，但 sgtk 是今后会采用的正确名称。    要导入 API，您需要确保 sys.path 中存在指向核心 python 文件夹的路径。但是，对于此示例，我们建议您在 ShotGrid Desktop 的 Python 控制台中运行此代码。这意味着，正确的 sgtk 软件包路径已添加到 sys.path 中。同样，如果您在已在运行 ShotGrid 集成的软件中运行此代码，则无需添加路径。在 ShotGrid 已启动的环境中运行代码时，只需编写以下内容即可导入 API：import sgtk如果要在 ShotGrid 集成之外使用 API（例如，如果在您常用的 IDE 中对其进行测试），则需要先设置 API 的路径：import syssys.path.append(&quot;/shotgun/configs/my_project_config/install/core/python&quot;)import sgtk                    注意: 如果您使用的是分布式配置，且要在 Toolkit 尚未引导的环境中导入 sgtk，则需要采取不同的方法。有关更多详细信息，请参见引导手册。    第 2 部分：获取 Sgtk 实例要开始使用 Toolkit API，您需要创建 Sgtk 类的实例。Sgtk 是 sgtk 软件包中的类，用作 API 的主接口。创建 Sgtk 实例后，您将能够执行获取上下文、创建文件夹或访问模板等操作。如 API 文档所述，您不会直接创建 Sgtk 实例。下面提供了一些用于获取 Sgtk 实例的选项。      如果在已在运行 ShotGrid 集成的环境中运行 Python 代码（例如，已从 ShotGrid 启动 Maya 情况下的 Maya Python 控制台），则可以从当前插件获取 Sgtk 实例。Engine.sgtk 属性保留插件的 Sgtk 实例。例如，在 Maya 中，可以运行以下命令：    # Get the engine that is currently running.current_engine = sgtk.platform.current_engine()# Grab the already created Sgtk instance from the current engine.tk = current_engine.sgtk        您可以通过 Engine.sgtk 属性访问 Sgtk 实例。    注意：Engine.sgtk 属性不应与第 1 部分中导入的 sgtk 软件包相混淆或视为相同。        sgtk.sgtk_from_entity() - 如果您在插件尚未启动的环境中运行，则可以使用此方法根据实体 ID 获取 Sgtk 实例。您提供其 ID 的实体必须属于从中导入 sgtk API 的项目。这不适用于分布式配置，请参见引导手册以了解更多详细信息。        sgtk.sgtk_from_path() - 与 sgtk_from_entity() 非常相似，只是它将接受配置路径、指向项目根文件夹或其内部的路径，例如，工作文件或镜头文件夹。这不适用于分布式配置，请参见引导手册以了解更多详细信息。  在本手册中，我们假定您在插件已启动的环境中运行此代码，因此我们将使用选项 1。此外，将 Sgtk 类实例存储在名为 tk 的变量中。如果您使用的是 ShotGrid Python 控制台，则 tk 变量已预定义为全局变量。现在，您拥有了一个 Sgtk 实例，可以开始使用 API。现在，发布脚本应如下所示：import sgtk# Get the engine that is currently running.current_engine = sgtk.platform.current_engine()# Grab the already created Sgtk instance from the current engine.tk = current_engine.sgtk第 3 部分：获取上下文什么是上下文，我为什么需要它？Toolkit 中执行的大量操作均围绕上下文展开，也就是说，知道您正在处理什么并能够相应地采取行动。对于 Toolkit API，您将需要能够存储有关所处理实体的重要详细信息，并与应用或其他进程共享，以便它们能够以上下文感知的方式进行操作。例如，如果 Toolkit 知道您正在处理什么任务，它将可以自动将您发布的文件链接到 ShotGrid 中对应的任务。Context 类充当此信息的容器。您可以将 Task、Step、entity（如 Shot 或 Asset）、Project 和当前 HumanUser 等存储在此类的实例中。您可以在给定会话中创建任意多个不同的上下文对象。但是，如果存在插件，则会有一个当前上下文的概念，插件会对其进行跟踪。这是用户当前所处的上下文，也是应用应该正在使用的上下文。在后面的步骤中，您将使用上下文来帮助解析可用于保存或复制文件的路径。获取上下文要创建上下文，必须使用以下构造函数方法之一：Sgtk.context_from_entity()、Sgtk.context_from_entity_dictionary() 或 Sgtk.context_from_path()。通过在先前步骤中创建的 Sgtk 实例（存储在 tk 变量中）访问这些方法。                    注意: 要从路径中获取上下文，必须已创建文件夹，这将在本手册的下一步中加以介绍。    无需创建新的上下文，您可以从插件获取当前上下文（第 2 部分中已收集），如下所示：context = current_engine.context由于您将在后面的步骤中使用上下文来帮助解析镜头任务的文件路径，因此需要确定上下文中包含相关信息。如果您的代码作为 Toolkit 应用的一部分运行，且您的应用已配置为仅在 shot_step 环境中运行，则可以放心地假定您可以获取适当的当前上下文。但是，为了避免本手册中存在不明确性，您将使用 Sgtk.context_from_entity() 从 Task（必须属于 Shot）明确创建上下文。创建上下文时，您可以提供操作所需的最深级别。例如，您可以从任务创建上下文，Toolkit 会为您确定其余的上下文参数。context = tk.context_from_entity(&quot;Task&quot;, 13155)如果输出上下文实例的表示，您将获取如下所示的内容：print(repr(context))&amp;gt;&amp;gt; &amp;lt;Sgtk Context:   Project: {'type': 'Project', 'name': 'My Project', 'id': 176}  Entity: {'type': 'Shot', 'name': 'shot01_running_away', 'id': 1381}  Step: {'type': 'Step', 'name': 'Comp', 'id': 8}  Task: {'type': 'Task', 'name': 'Comp', 'id': 13155}  User: None  Shotgun URL: https://mysite.shotgunstudio.com/detail/Task/13155  Additional Entities: []  Source Entity: {'type': 'Shot', 'name': 'shot01_running_away', 'id': 1381}&amp;gt;尽管您仅提供了任务，但应已填写其他相关详细信息。现在，发布脚本应如下所示：import sgtk# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work.context = tk.context_from_entity(&quot;Task&quot;, 13155)第 4 部分：创建文件夹Toolkit 可以根据项目实体在磁盘上动态生成文件夹结构。这可实现两个目的。  在磁盘上创建组织有序的结构，您可以在其中放置文件。  使 Toolkit 能够以编程方式了解您的结构、从中派生上下文并知道在何处放置文件。您需要确保磁盘上存在文件夹，以便在后面的步骤中解析路径。您将使用 Sgtk.create_filesystem_structure() 方法实现此操作：tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])您可以使用上下文对象获取任务 ID 以生成文件夹。现在，代码应如下所示：import sgtk# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task, this Task must belong to a Shot for the future steps to work.context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the task.tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])现在，您已完成所有准备步骤，接下来，可以使用模板生成路径。第 5 部分：使用模板构建路径生成路径无论何时，只要您想知道应在 Toolkit 的哪个位置放置或找到文件，就可以使用模板解析磁盘上的绝对路径。模板本质上是标记化字符串，当您将上下文和其他数据应用于这些字符串时，可以解析为文件系统路径。它们可通过项目的工作流配置进行自定义，旨在提供标准化方法来确定文件应存储的位置。首先，您需要为要生成的路径获取模板实例。利用您创建的 Sgtk 实例，可以通过 Sgtk.templates 属性访问所需的 Template 实例，此属性是一个词典，其中键是模板名称，值是 Template 实例。template = tk.templates[&quot;maya_shot_publish&quot;]在此示例中，您将使用 maya_shot_publish 模板。在默认配置中，未解析的模板路径如下所示：'sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{version}.{maya_extension}'模板由键组成，您需要将这些键解析为实际值。由于上下文包含大多数键的充足信息，因此可以先使用此信息提取值：fields = context.as_template_fields(template)&amp;gt;&amp;gt; {'Sequence': 'seq01_chase', 'Shot': 'shot01_running_away', 'Step': 'comp'}Context.as_template_fields() 方法可提供一个包含正确值的词典以解析模板键。但是，它并未提供所有键对应的值。name、version 和 maya_extension 仍缺失。在模板键部分中，maya_extension 键定义默认值，因此无需为此键提供值，但是如果需要默认值以外的值，也可以提供值。这样，就只剩下 name 和 version。由于名称可以进行选择，因此您可以对默认值进行硬编码或使用户能够输入值（例如，通过弹出界面）。现在，您将对二者均进行硬编码，但在下一步中，我们将介绍如何查找下一个可用的版本号。fields[&quot;name&quot;] = &quot;myscene&quot;fields[&quot;version&quot;] = 1现在，您拥有了所有字段，可以使用 Template.apply_fields() 将模板解析为绝对路径：publish_path = template.apply_fields(fields)&amp;gt;&amp;gt; /sg_toolkit/mysite.shotgunstudio.com/my_project/sequences/seq01_chase/shot01_running_away/comp/publish/maya/myscene.v001.ma确保文件夹存在尽管您之前运行了文件夹创建方法，但可能还是需要执行额外的步骤以确保所有文件夹都存在。例如，如果模板定义的文件夹在结构中不存在，则表明原始 create_filesystem_structure() 调用中未创建此文件夹，这时可能就需要执行上述额外的操作。您可以使用多种便捷方法来执行此操作。如果您的代码在 Toolkit 应用或挂钩中运行，则可以使用 Application.ensure_folder_exists() 方法。如果有插件，则可以使用 Engine.ensure_folder_exists() 方法。或者，如果您在插件之外运行代码，则可以使用 sgtk.util.filesystem.ensure_folder_exists()。确保仅为目录（而非完整文件路径）创建文件夹。您可以导入 os 模块并运行 os.path.dirname(publish_path) 以提取完整文件路径的文件夹部分。使用路径创建或复制文件此时，您已拥有路径，可以使用此路径执行诸多操作，例如，告知 Maya 将文件保存到此路径，或从其他位置将文件复制到此路径。针对本手册，您并不一定要执行任何行为以在磁盘的相应位置上实际创建文件。即使没有文件，您仍可发布路径。不过，您可以使用 sgtk.util.filesystem.touch_file() 让 Toolkit 在磁盘上创建空文件。将到目前为止的所有代码整合到一起import sgtkimport os# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work.context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the task.tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])# Get a template instance by providing a name of a valid template in your config's templates.yml.template = tk.templates[&quot;maya_shot_publish&quot;]# Use the context to resolve as many of the template fields as possible.fields = context.as_template_fields(template)# Manually resolve the remaining fields that can't be figured out automatically from context.fields[&quot;name&quot;] = &quot;myscene&quot;fields[&quot;version&quot;] = 1# Use the fields to resolve the template path into an absolute path.publish_path = template.apply_fields(fields)# Make sure we create any missing folders.current_engine.ensure_folder_exists(os.path.dirname(publish_path))# Create an empty file on disk. (optional - should be replaced by actual file save or copy logic)sgtk.util.filesystem.touch_file(publish_path)下一步是动态确定下一个版本号，而非对其进行硬编码。第 6 部分：查找现有文件并获取最新版本号在这里，您可以使用两种方法。  由于在此特定示例中，您要解析发布文件，因此可以使用 ShotGrid API 在 PublishedFile 实体上查询下一个可用版本号。  您可以扫描磁盘上的文件并确定已存在的版本，然后提取下一个版本号。如果您使用的文件未在 ShotGrid 中进行跟踪（如工作文件），这将非常有用。尽管第一个选项可能更适合本手册中的示例，但这两种方法均有其各自的用途，因此我们都会进行介绍。在 ShotGrid 中查询下一个版本号。利用 ShotGrid API 和 summarize() 方法，可以在 PublishedFile 实体（这些实体共享相同的名称和任务）中获取最高版本号，然后加 1。r = sg.summarize(entity_type=&quot;PublishedFile&quot;,                 filters = [[&quot;task&quot;, &quot;is&quot;, {&quot;type&quot;:&quot;Task&quot;, &quot;id&quot;: context.task[&quot;id&quot;]}],                            [&quot;name&quot;,&quot;is&quot;, fields[&quot;name&quot;] + &quot;.ma&quot;]],                 summary_fields=[{&quot;field&quot;:&quot;version_number&quot;, &quot;type&quot;:&quot;maximum&quot;}])# Extract the version number and add 1 to it.# In scenarios where there are no files already this summary will return 0.# Apply the version number to the fields dictionary, that will be used to resolve the template into a path.fields[&quot;version&quot;] = r[&quot;summaries&quot;][&quot;version_number&quot;] + 1在文件系统中搜索下一个版本号。利用 Toolkit API，可以收集现有文件列表，从中提取模板字段值，然后找出下一个版本。在下面的示例中，将从工作文件模板中收集最新版本。假定工作文件模板和发布文件模板具有相同的字段，则可以使用相同字段调用下面的方法两次以确定最高发布和工作文件版本，并决定使用这两者的组合。def get_next_version_number(tk, template_name, fields):    template = tk.templates[template_name]    # Get a list of existing file paths on disk that match the template and provided fields    # Skip the version field as we want to find all versions, not a specific version.    skip_fields = [&quot;version&quot;]    file_paths = tk.paths_from_template(                 template,                 fields,                 skip_fields,                 skip_missing_optional_keys=True             )    versions = []    for a_file in file_paths:        # extract the values from the path so we can read the version.        path_fields = template.get_fields(a_file)        versions.append(path_fields[&quot;version&quot;])    # find the highest version in the list and add one.    return max(versions) + 1# Set the version number in the fields dictionary, that will be used to resolve the template into a path.fields[&quot;version&quot;] = get_next_version_number(tk, &quot;maya_shot_work&quot;, fields)sgtk.paths_from_template() 方法将收集磁盘上与所提供的模板和字段匹配的所有文件。此方法对于要为用户查找和显示文件列表的情况也非常有用。您可以选择使用任一选项，但为了简单起见，本手册将使用选项 1 中的代码。第 7 部分：注册已发布的文件现在，您已拥有一个路径，可以进行发布。要执行此操作，可以使用实用程序方法 sgtk.util.register_publish()。也可以使用 ShotGrid API 的 ShotGrid.create() 方法来创建 PublishedFile 实体，但我们强烈建议在此处使用 Toolkit API，因为它可确保提供并正确填写所有必填字段。# So as to match the Publish app's default behavior, we are adding the extension to the end of the publish name.# This is optional, however.publish_name = fields[&quot;name&quot;] + &quot;.ma&quot;version_number = fields[&quot;version&quot;]# Now register the publishsgtk.util.register_publish(tk,                           context,                           publish_path,                           publish_name,                           version_number,                           published_file_type = &quot;Maya Scene&quot;)此时，还值得注意的是，我们的发布应用也附带了其自己的 API。尽管这仍然在本质上使用了相同的 sgtk.util.register_publish() 方法，但它基于发布过程构建而成，通过提供框架进行收集、验证和发布。第 8 部分：完整脚本# Initialization# ==============import sgtkimport os# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work.context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the tasktk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])# Generating a Path# =================# Get a template instance by providing a name of a valid template in your config's templates.ymltemplate = tk.templates[&quot;maya_shot_publish&quot;]# Use the context to resolve as many of the template fields as possible.fields = context.as_template_fields(template)# Manually resolve the remaining fields that can't be figured out automatically from context.fields[&quot;name&quot;] = &quot;myscene&quot;# Get an authenticated Shotgun API instance from the enginesg = current_engine.shotgun# Run a Shotgun API query to summarize the maximum version number on PublishedFiles that# are linked to the task and match the provided name.# Since PublishedFiles generated by the Publish app have the extension on the end of the name we need to add the# extension in our filter.r = sg.summarize(entity_type=&quot;PublishedFile&quot;,                 filters = [[&quot;task&quot;, &quot;is&quot;, {&quot;type&quot;:&quot;Task&quot;, &quot;id&quot;: context.task[&quot;id&quot;]}],                            [&quot;name&quot;,&quot;is&quot;, fields[&quot;name&quot;] + &quot;.ma&quot;]],                 summary_fields=[{&quot;field&quot;:&quot;version_number&quot;, &quot;type&quot;:&quot;maximum&quot;}])# Extract the version number and add 1 to it.# In scenarios where there are no files already this summary will return 0.# Apply the version number to the fields dictionary, that will be used to resolve the template into a path.fields[&quot;version&quot;] = r[&quot;summaries&quot;][&quot;version_number&quot;] + 1# Use the fields to resolve the template path into an absolute path.publish_path = template.apply_fields(fields)# Make sure we create any missing folderscurrent_engine.ensure_folder_exists(os.path.dirname(publish_path))# Creating a file# ===============# This is the bit where you would add your own logic to copy or save a file using the path.# In the absence of any file saving in the example, we'll use the following to create an empty file on disk.sgtk.util.filesystem.touch_file(publish_path)# Publishing# ==========# So as to match publishes created by the Publish app's, we are adding the extension to the end of the publish name.publish_name = fields[&quot;name&quot;] + &quot;.ma&quot;version_number = fields[&quot;version&quot;]# Now register the publishsgtk.util.register_publish(tk,                           context,                           publish_path,                           publish_name,                           version_number,                           published_file_type = &quot;Maya Scene&quot;)                    提示: 此时，代码变得有点长，因此建议下一步将其整理一下，分解成多个方法。    总结希望本手册能够使您对如何开始使用 Toolkit API 有一个基本的了解。当然，API 还有许多其他用途，因此我们建议通读 tk-core API 以了解详细信息。此外，我们的论坛是探讨 API 问题和获取答案的好地方，甚至可以通过此论坛向我们提供有关本手册的反馈。",
    "url": "/836446f3/",
    "relUrl": "/836446f3/"
  },
  "125": {
    "id": "125",
    "title": "集成开发人员手册",
    "content": "集成开发人员手册面板有关面板操作的示例，请参见 https://github.com/shotgunsoftware/tk-multi-shotgunpanel/tree/master/hooks。配置显示的内容详细信息区域和列表中的值都可以通过 shotgun_fields 挂钩进行配置。您可以为此挂钩创建子类，并更改执行，以便显示您需要的值。模板系统此挂钩支持简单的模板语言，可提供出色的灵活性。它还支持 Qt 所支持的 HTML 子集，因此您可以控制显示的值的颜色、字体大小、粗细等。模板语言用法如下：      ShotGrid 的值括在 {brackets} 中，例如 &amp;lt;b&amp;gt;Description:&amp;lt;/b&amp;gt; {description}。此模板呈现时，{description} 部分将替换为 description 字段的值。        如果您想为值添加一个仅当值不为空时才显示的可选前缀或后缀，可使用 {[Prefix]sg_field[suffix]} 语法。对于模板 {[Start: ]start_date} {[End: ]end_date}，如果同时填充了两个值，将显示 Start: 12 July 2009 End: 14 July 2012，如果未设置结束日期，则显示 Start: 12 July 2009。        您可以定义回退机制，在某些值未设置的情况下进行回退。对于 ShotGrid 版本而言，artist 字段优先于 created_by 字段，这是为了支持由制片代表艺术家提交版本的工作流。在这种情况下，版本将由制作人员创建，但 artist 字段会设置为美工人员。不过，情况并非总是如此。有时，在由美工人员自己提交工作的工作流中，artist 字段会留空。因此，在显示版本时，能够首先检查 artist 字段是一项有用的功能，如果发现此字段未设置，则回退到 created_by 字段。我们使用 {field1|field2} 语法实现这个机制，例如：Created By: {artist|created_by}。您可以将此字段与可选字段结合使用，例如 {[Created By: ]artist|created_by}。  此挂钩包含以下方法：控制列表中显示的列表项get_list_item_definition() 方法接受 ShotGrid 实体类型，会返回一个词典，该词典控制各种列表中列表项的外观。它返回的词典具有 top_left、top_right 和 body 键，例如：{ &quot;top_left&quot;: &quot;&amp;lt;big&amp;gt;{code}&amp;lt;/big&amp;gt;&quot;, &quot;top_right&quot;: &quot;{updated_at}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}控制顶部详细信息区域get_main_view_definition() 方法接受 ShotGrid 实体类型，会返回一个具有 title 和 body 键的词典。这些值控制详细信息区域中对象的外观，例如：{ &quot;title&quot;: &quot;{type} {code}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}控制“信息”(Info)选项卡中显示的字段get_all_fields() 方法返回给定实体在“信息”(Info)选项卡上呈现时要显示的字段列表。配置动作动作是对一段 ShotGrid 数据执行操作的代码片段。例如：  一个为给定 ShotGrid 版本启动 RV 的动作  一个让用户可指派自己执行给定任务的动作  一个将 ShotGrid 发布加载到 Maya 中作为 Maya 参考的动作。动作的实际负载在 动作挂钩 中定义。定义动作逻辑后，您可以在应用配置中将该动作映射到 ShotGrid 对象。这些动作的映射关系可能类似如下：action_mappings:  PublishedFile:  - actions: [reference, import]    filters: {published_file_type: Maya Scene}  - actions: [texture_node]    filters: {published_file_type: Rendered Image}  Task:  - actions: [assign_task]    filters: {}  Version:  - actions: [play_in_rv]    filters: {}在上面的示例中，我们使用了 reference、import、texture_node、assign_task 和 play_in_rv 动作。然后，我们将这些动作映射到各种 ShotGrid 对象和条件。例如，我们让所有 Maya 场景类型的发布都显示 import 动作。将对象加载到面板中时，会读入并分析上面的动作配置。确定适合当前对象的动作的列表，并执行 generate_actions() 挂钩方法。给定实体的 ShotGrid 数据将在此时传递给挂钩，以便挂钩代码判断是否可以为此特定 ShotGrid 对象运行该动作。这种方法让每个挂钩可在显示前运行检查。例如，play_in_rv 挂钩可能只有在本地有可用媒体时才有意义 - 配置中设置的动作映射会告诉面板为给定 ShotGrid 实体启用哪些动作，但是这些动作可能不会全部显示，因为 generate_actions() 方法可能会判定某些动作不适合这个给定对象。generate_actions() 方法返回的动作将显示在动作菜单上，当用户单击该菜单时，会调用 execute_acton() 挂钩方法运行动作。对于面板支持的每个应用程序，都有一个动作挂钩来执行合适的动作。例如，在 Maya 这样的应用程序中，默认挂钩将执行 reference、import 和 texture_node 动作，每个动作执行特定的 Maya 命令，将发布导入当前的 Maya 场景中。与所有挂钩一样，我们完全可以改写和更改这些设置，还可根据内置挂钩创建派生挂钩，这样不必复制大量代码就能轻松向内置挂钩中添加其他动作。面板使用 Toolkit 第二代挂钩界面，具有更强的灵活性。此挂钩的格式采用经过改进的语法。您可以在默认配置设置中查看，语法类似如下：actions_hook: '{self}/tk-maya_actions.py'{self} 关键字指示 Toolkit 在应用的 hooks 文件夹中查找挂钩。如果您要使用自己的执行改写此挂钩，请将值更改为 {config}/panel/maya_actions.py。这将指示 Toolkit 使用您的配置文件夹中称为 hooks/panel/maya_actions.py 的挂钩。有关详细信息，请参见应用随附的挂钩文件。挂钩还会利用继承性，这意味着您不需要改写挂钩中的所有内容，而是可以更轻松地用各种方式对默认挂钩进行扩展或补充，使挂钩更易于管理。单击此处详细了解第二代挂钩格式。通过在挂钩中运用继承性，您可以像下面这样向默认挂钩中添加附加动作：import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_data, actions, ui_area):        &quot;&quot;&quot; Returns a list of action instances for a particular object. The data returned from this hook will be used to populate the  actions menu. The mapping between ShotGrid objects and actions are kept in a different place (in the configuration) so at the point when this hook is called, the app has already established *which* actions are appropriate for this object. This method needs to return detailed data for those actions, in the form of a list of dictionaries, each with name, params, caption and description keys. Because you are operating on a particular object, you may tailor the output  (caption, tooltip etc) to contain custom information suitable for this publish. The ui_area parameter is a string and indicates where the publish is to be shown.  - If it will be shown in the main browsing area, &quot;main&quot; is passed.  - If it will be shown in the details area, &quot;details&quot; is passed. :param sg_data: ShotGrid data dictionary with all the standard publish fields. :param actions: List of action strings which have been defined in the app configuration. :param ui_area: String denoting the UI Area (see above). :returns List of dictionaries, each with keys name, params, caption and description &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_data):        &quot;&quot;&quot; Execute a given action. The data sent to this be method will represent one of the actions enumerated by the generate_actions method. :param name: Action name string representing one of the items returned by generate_actions. :param params: Params data, as specified by generate_actions. :param sg_data: ShotGrid data dictionary with all the standard publish fields. :returns: No return value expected. &quot;&quot;&quot;        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_data)然后，我们可以在配置中将这个新动作绑定到一组发布类型：action_mappings:  PublishedFile:  - actions: [reference, import, my_new_action]    filters: {published_file_type: Maya Scene}  Version:  - actions: [play_in_rv]    filters: {}按上面所示从挂钩派生的自定义挂钩代码只需要包含实际添加的业务逻辑，因此维护和更新起来更加简单。发布器发布应用可以采用挂钩形式进行高度自定义，控制如何将内容项呈现给艺术家以供发布以及稍后如何处理这些内容项。有关发布器应用的完整开发人员文档，请参见 Toolkit 开发人员站点。有关如何使用发布应用的详细信息，请参见用户手册。加载器有关加载操作的示例，请参见 https://github.com/shotgunsoftware/tk-multi-loader2/tree/master/hooks。高级功能使用 ShotGrid Toolkit 可轻松开发工具我们有没有提到您可以编写自己的应用？每个插件都基于 Python 和 PySide 公开了一个一致的接口，因此您可以编写一个适用于 Nuke、Photoshop 和 3dsmax 应用。有了核心 API 功能，开发资源可以专注于解决生产问题，而无需为工作室构建大型工作流堆栈。通过 Toolkit 可以在项目之间轻松地重用工具 - 如果文件命名约定或其他要求发生改变，只需重新配置应用即可。通过 Toolkit 的内置 Git 和 Github 支持可安全地推出工具，并在开发时快速地热加载代码。您只需在自己的 Dev Sandbox 中工作，并邀请 TD 和早期采用者测试您的代码，而不必将其展示给项目的每个参与者。",
    "url": "/93c6e555/",
    "relUrl": "/93c6e555/"
  },
  "126": {
    "id": "126",
    "title": "如何提交集成修复",
    "content": "如何提交集成修复我们欢迎 Toolkit 社区的贡献！如果您有或许可行的方法修复发现的某个问题，或者执行了一项您认为我们应该包含的功能，欢迎您按照下面的指导原则，通过适当渠道反馈给我们。联系我们我们鼓励您联系我们，共同讨论您的开发构想或要修复的问题。我们也许能提供有用的信息为您指引正确的方向，或者帮助您避免很多不必要的工作。最重要的是，我们喜欢了解用户想要构建什么，他们如何使用 Toolkit，以及我们如何使它变得更出色。Fork 位于 GitHub 上的库大多数 Toolkit 插件、应用和框架的代码都公开在 GitHub 上开发。您可以将要修改的库从 GitHub 上 Fork 到您的本地环境。进行更改在本地的一个分支上进行开发，然后在您自己的环境中测试，直到确信应用可以提交给我们。尽量与现有代码库的风格保持一致。保证您的更改专注于实现您的目的。例如，如果您是要修复 3 行代码中的某个错误，那么就不要试图修改整个文件中的空格问题。否则 Toolkit 小精灵会发飙的。注释！务必添加详细的注释，说明您要做什么以及为什么这样做。请记住，可能会有其他像您一样的用户以后会 Fork 此库，他们需要了解您的代码的用意和原因。注释要清楚，但也不要过度注释。:)测试请记住，其他用户会有各种各样的环境和变量，并且可能与您工作室的配置不尽相同。Toolkit 会尽可能减少这类问题给用户造成的影响，但是不同用户的环境总会有些差异。例如：  您的代码是否能在 OS X、Windows 和 Linux 上同样正常运行？  代码是否能在某个软件的所有支持版本中正常运行？  无论用户从终端、SG Desktop、ShotGrid 还是自己的自定义应用中启动代码，代码是否都能一样运行？创建 Pull 请求一切准备就绪后，您可以使用 Push 操作将更改上传回 GitHub，并创建 Pull 请求。您的 Pull 请求应详细全面，说明您的代码有何用意，以及为何需要这些更改。撰写这些内容时，请考虑到那些初涉这个领域、对这方面代码知之甚少的用户。大家会看到您的 Pull 请求，其他用户也会很高兴能够理解您条理清晰的说明！然后呢？我们会在有时间时审核您的 Pull 请求。我们很可能会给出意见和建议，并询问您一些有关代码或用例的问题。我们也可能会将请求退回，并请您进行更改。请不要因此生气！我们欢迎大家提出自己的方案，但是也深知问题怎样才能得到解决。我们每天都在与代码打交道，因此也知道并非每个人都能提交完美的代码。审核完代码后，如果我们接受您的 Pull 请求，会安排对您的代码进行 QA，然后将它合并到我们的库，并安排在某个时间发布。具体的时间安排会受许多因素的影响。因此请耐心等待。另外，我们还可能礼貌地拒绝您的 Pull 请求。同样，请不要生气。我们由衷感谢您做出的所有努力和贡献。有很多因素可能导致您的请求被拒。但是，如果您遵循上面的指导原则，一般不会出现这种情况。",
    "url": "/924c14e8/",
    "relUrl": "/924c14e8/"
  },
  "127": {
    "id": "127",
    "title": "如何在自定义脚本中处理身份认证和登录凭据？",
    "content": "如何在自定义脚本中处理身份认证和登录凭据？错误消息如果出现类似以下来自脚本的错误，则意味着脚本无权与 ShotGrid 站点进行通信。tank.errors.TankError: Missing required script user in config '/path/to/your/project/config/core/shotgun.yml'如果未预先提供用户身份认证或脚本身份认证，则 Toolkit 会回退到检查是否已在配置的 shotgun.yml 文件中定义凭据。在 shotgun.yml 文件中定义凭据是处理身份认证的旧方法。您应避免在 shotgun.yml 文件中定义凭据，而改用下面详细介绍的方法之一：面向用户的脚本如果脚本面向用户，您可以在创建 Sgtk 实例前，在脚本开头添加以下内容：# Import the Toolkit API so we can access Toolkit specific features.import sgtk# Import the ShotgunAuthenticator from the tank_vendor.shotgun_authentication# module. This class allows you to authenticate either programmatically or, in this# case, interactively.from tank_vendor.shotgun_authentication import ShotgunAuthenticator# Instantiate the CoreDefaultsManager. This allows the ShotgunAuthenticator to# retrieve the site, proxy and optional script_user credentials from shotgun.ymlcdm = sgtk.util.CoreDefaultsManager()# Instantiate the authenticator object, passing in the defaults manager.authenticator = ShotgunAuthenticator(cdm)# Optionally clear the current user if you've already logged in before.authenticator.clear_default_user()# Get an authenticated user. In this scenario, since we've passed in the# CoreDefaultsManager, the code will first look to see if there is a script_user inside# shotgun.yml. If there isn't, the user will be prompted for their username,# password and optional 2-factor authentication code. If a QApplication is# available, a UI will pop-up. If not, the credentials will be prompted# on the command line. The user object returned encapsulates the login# information.user = authenticator.get_user()# print &quot;User is '%s'&quot; % user# Tells Toolkit which user to use for connecting to ShotGrid. Note that this should# always take place before creating a Sgtk instance.sgtk.set_authenticated_user(user)## Add your app code here...## When you are done, you could optionally clear the current user. Doing so# however, means that the next time the script is run, the user will be prompted# for their credentials again. You should probably avoid doing this in# order to provide a user experience that is as frictionless as possible.authenticator.clear_default_user()如果 QApplication 可用，您将看到类似如下的内容：                    注意: 如果导入的 Toolkit API（sgtk 软件包）未与配置关联，例如您已下载用于引导到其他配置的 Toolkit API，则不应尝试创建 CoreDefaultsManager。应改为创建 ShotgunAuthenticator() 实例，而不传递默认管理器。authenticator = ShotgunAuthenticator()    非面向用户的脚本如果脚本不面向用户，比如在渲染农场或事件处理程序中，您可以在创建 Sgtk/Tank 实例前，在脚本开头添加以下内容：# Import Toolkit so we can access to Toolkit specific features.import sgtk# Import the ShotgunAuthenticator from the tank_vendor.shotgun_authentication# module. This class allows you to authenticate either interactively or, in this# case, programmatically.from tank_vendor.shotgun_authentication import ShotgunAuthenticator# Instantiate the CoreDefaultsManager. This allows the ShotgunAuthenticator to# retrieve the site, proxy and optional script_user credentials from shotgun.ymlcdm = sgtk.util.CoreDefaultsManager()# Instantiate the authenticator object, passing in the defaults manager.authenticator = ShotgunAuthenticator(cdm)# Create a user programmatically using the script's key.user = authenticator.create_script_user(    api_script=&quot;Toolkit&quot;,    api_key=&quot;4e48f....&amp;lt;use the key from your ShotGrid site&amp;gt;&quot;)# print &quot;User is '%s'&quot; % user# Tells Toolkit which user to use for connecting to ShotGrid.sgtk.set_authenticated_user(user)                    注意: 如面向用户的脚本部分末尾所述，如果您导入的 sgtk 软件包是独立的/不是来自于配置，则不应创建默认管理器。此外，还应为 create_script_user() 方法提供 host kwarg：user = authenticator.create_script_user(    host=&quot;https://yoursite.shotgunstudio.com&quot;,    api_script=&quot;Toolkit&quot;,    api_key=&quot;4e48f....&amp;lt;use the key from your Shotgun site&amp;gt;&quot;)    ",
    "url": "/724152ce/",
    "relUrl": "/724152ce/"
  },
  "128": {
    "id": "128",
    "title": "如何在项目之间共享资产？",
    "content": "如何在项目之间共享资产？常见的做法是将某项目用作资产库，其中包含可在其他项目中加载到镜头的资产。在“资产”(Asset)实体上引入“链接的项目”(Linked Projects)字段后，就可以将单个选项卡添加到包含所有链接项目的加载器应用。要执行此操作，您必须在加载器设置中针对插件和您的工作环境对此进行定义。您可能需要在多个位置对其进行更新。- caption: Assets - Linked    entity_type: Asset    filters:      - [linked_projects, is, &quot;{context.project}&quot;]    hierarchy: [project.Project.name, sg_asset_type, code]您可以参考 tk-multi-loader2.yml 配置文件（包含在 tk-config-default2 中）中的 Alias 插件设置，因为这是该处的默认行为。在“资产”(Assets)中引入“链接的项目”(Linked Projects)字段之前，实现跨项目共享的初始方法是向加载器应用添加一个选项卡，其中列出了特定资产库项目中的资产。例如，要将该选项卡添加到镜头工序环境中的 Maya 插件，您需要添加以下代码段：- caption: Asset Library    hierarchy: [project, sg_asset_type, code]    entity_type: Asset    filters:      - [project, is, {'type': 'Project', 'id': 207}]将 207 替换为库项目的 ID。如果您现在正在 Maya 的镜头工序环境中工作，系统将添加一个新选项卡，其中显示该项目中所有可用的发布。如果您想将该选项卡添加到其他插件（如 Nuke、3dsmax 等）中的加载器，还需要修改其中每个插件的 tk-multi-loader2 设置。如果要在其他环境中启用该设置，您将需要在资产工序环境中以及您希望启用该设置的所有其他环境中执行相同的工序。操作过程有点麻烦，但可以实现某种精细控制。通过这些设置，加载器应用应该可以显示一个列出已标识项目中的发布的选项卡。                    注意: 此处仍包含此初始技术，因为它提供了一种让加载器中标识的每个项目都拥有不同选项卡的方法。    要了解有关基于 Web 的跨项目资产链接的详细信息，请访问此处的跨项目资产链接文档。",
    "url": "/2088a677/",
    "relUrl": "/2088a677/"
  },
  "129": {
    "id": "129",
    "title": "概述",
    "content": "ShotGrid 开发管理制作时需要执行大量工作以使所有运作部分保持同步。使用我们的 ShotGrid REST API 或 Python API 直接关联您的数据，使用事件触发器框架自动执行重复性任务，并使用动作菜单项直接从 ShotGrid 的 Web 界面启动应用。建议您使用 ShotGrid API 开发自己的服务、应用程序、模块和组件，以便在本服务上运行或与本服务一起运行，供您自己和授权用户使用。                    身份验证密钥: 我们要求您切勿披露（并且不允许您的授权用户披露）包含身份认证密钥的 API 信息，或者其他可能允许用户在没有登录的情况下访问本服务或其功能的方法，或者您自己使用 API 在没有登录的情况下访问或允许用户访问本服务或其功能的方法。    ",
    "url": "/6dfa5d53/",
    "relUrl": "/6dfa5d53/"
  },
  "130": {
    "id": "130",
    "title": "Migration Test Site",
    "content": "ShotGrid Migration Test SiteActivating the isolation feature set is an intrusive procedure that can have an impact on the usability of your site. To prevent a production stopping event, we require clients to follow an approach where the configuration is first validated on a test site, before being applied to the production site.The ShotGrid team will create a temporary site to be used as a Proof of Concept for your ShotGrid Isolation deployment. Upon the successful completion of the setup process, your existing ShotGrid site can be migrated to your ShotGrid Isolation environment.If your Migration Test Site has not been created yet, please reach out to our Support team through your Zendesk ticket or your dedicated on-boarding Slack Channel.Next StepsOnce you have your test site, you can the implementation of the feature you need.See Media Isolation for activating the Media Isolation feature.See Web Traffic Isolation for activating the Web Traffic Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/0bbe0010/",
    "relUrl": "/0bbe0010/"
  },
  "131": {
    "id": "131",
    "title": "SSLHandshakeError CERTIFICATE_VERIFY_FAILED 证书验证失败",
    "content": "SSLHandshakeError: [SSL: CERTIFICATE_VERIFY_FAILED] 证书验证失败用例在使用防火墙进行本地数据包检测的本地网络上，您可能会收到以下错误消息：SSLHandshakeError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)发生此错误是因为这些防火墙通常配置有网络管理员自行创建且 Python 无权访问的自签名证书。遗憾的是，与其他应用程序不同，Python 并不总是在操作系统的密钥链中查找证书，因此您必须自己提供。如何修复您需要设置 SHOTGUN_API_CACERTS 环境变量以指向磁盘上的文件，该文件包含 Python API 和 Shotgun Desktop 可以信任的证书颁发机构的完整列表。您可以从 Github 上最新的 certifi 软件包副本下载此类副本。完成此操作后，需要在该文件的底部添加公司防火墙的公共密钥并保存。完成后，只需将 SHOTGUN_API_CACERTS 环境变量设置为路径位置，例如 /opt/certs/cacert.pem，然后启动 Shotgun Desktop。相关链接在社区中查看完整主题",
    "url": "/4528ba21/",
    "relUrl": "/4528ba21/"
  },
  "132": {
    "id": "132",
    "title": "警告 存储根主存储无法映射到 SG 本地存储",
    "content": "警告: 存储根主存储无法映射到 SG 本地存储用例尝试使用“驱动器文件”流设置项目并将 Google Drive 用作主存储时，项目向导在访问存储配置时在控制台中发出警告：[WARNING] Storage root primary could not be mapped to a SG local storage按“继续”不起作用。如何修复如果存储名称中存在拼写错误，则可能会导致此问题。确保它与 Google Drive 的名称完全匹配。此外，使用 Google Drive 时，请确保将其设置为始终将文件保留在本地，以避免出现重复的项目。相关链接在社区中查看完整主题",
    "url": "/a59c77b9/",
    "relUrl": "/a59c77b9/"
  },
  "133": {
    "id": "133",
    "title": "无法解析上下文的模板数据",
    "content": "TankError: 无法解析上下文的模板数据用例对新项目执行高级项目设置，并使用 ShotGrid Desktop 中的单机版发布器应用为我创建的新资产任务发布某些图像时，在选择上下文以验证发布后，出现以下错误：creation for %s and try again!&quot; % (self, self.shotgun_url))TankError: Cannot resolve template data for context ‘concept, Asset door-01’ - this context does not have any associated folders created on disk yet and therefore no template data can be extracted. Please run the folder creation for and try again!在终端中运行 tank.bat Asset door-01 folders 可解决此问题。但是，以前的任何项目中都从未出现过这种情况。如何修复这可能是因为这是第一次尝试在不先通过 DCC 的情况下为新实体/任务执行单机发布。之前可能没有发生这种情况的原因是，您在使用单机版发布器之前已在软件中开始处理资产，因此文件夹已创建/同步。启动软件（通过 Toolkit）将为启动的上下文创建文件夹，打开的应用将为启动新文件的上下文创建文件夹。因此，通常不需要专门创建文件夹。通常的做法是，工作室一般会在镜头/资产添加到 ShotGrid 中后手动创建文件夹。另请记住，这受“文件夹数据结构”的影响，如果它与模板不完全匹配，则可能会导致奇怪的问题。相关链接在社区中查看完整主题",
    "url": "/5cdbc2a3/",
    "relUrl": "/5cdbc2a3/"
  },
  "134": {
    "id": "134",
    "title": "TankError 尝试从模板解析路径",
    "content": "TankError: 尝试从模板解析路径用例 1当为 SGTK 设置新配置时，尝试通过“文件打开”(File Open)对话框（在 tk-multi-workfiles2 中）创建新文件时，会出现以下错误：TankError: Tried to resolve a path from the template &amp;lt;Sgtk TemplatePath asset_work_area_maya:用例 2当尝试在某些任务中保存时，会收到错误：TankError: Tried to resolve a path from the template &amp;lt;Sgtk TemplatePath nuke_shot_work:如何修复对于用例 1：检查 asset.yml 文件，它可能缺少过滤器： - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }对于用例 2：这可能是由于场被重命名，并留下一些 FilesystemLocation，从而给 Toolkit 造成混乱。修复：  在 Shotgun 中删除旧的 FilesystemLocation  从 Toolkit 中取消注册与旧 FilesystemLocation 相关的文件夹  从 Toolkit 再次注册文件夹相关链接单击此处在社区中查看完整主题，也可以单击此处在此社区主题中进行查看。",
    "url": "/ea55eac2/",
    "relUrl": "/ea55eac2/"
  },
  "135": {
    "id": "135",
    "title": "您正从位于以下位置的工作流配置加载 Toolkit 平台",
    "content": "TankInitError: 您正从位于以下位置的工作流配置加载 Toolkit 平台用例运行某些代码以从应用发布文件时，有时文件属于其他项目。能否解决 TankInitError: You are loading the Toolkit platform from the pipeline configuration located in 错误？理想情况下，可以从路径中查找上下文以正确注册这些文件（即使它们属于其他项目）。如何修复使用以下函数：def get_sgtk(proj_name, script_name):    &quot;&quot;&quot; Load sgtk path and import module    If sgtk was previously loaded, replace include paths and reimport    &quot;&quot;&quot;    project_path = get_proj_tank_dir(proj_name)    sys.path.insert(1, project_path)    sys.path.insert(1, os.path.join(        project_path,        &quot;install&quot;, &quot;core&quot;, &quot;python&quot;    ))    # unload old core    for mod in filter(lambda m: m.startswith(&quot;sgtk&quot;) or m.startswith(&quot;tank&quot;), sys.modules):        sys.modules.pop(mod)        del mod    if &quot;TANK_CURRENT_PC&quot; in os.environ:        del os.environ[&quot;TANK_CURRENT_PC&quot;]    import sgtk    setup_sgtk_auth(sgtk, script_name)    return sgtk该键从 sys.modules 中删除与 sgtk 相关的所有模块，并从环境中移除 TANK_CURRENT_PC。有关概述信息，请参见如何使用 shotgunEvent 进程加载不同的 Toolkit 核心模块？相关链接在社区中查看完整主题",
    "url": "/a2befe6a/",
    "relUrl": "/a2befe6a/"
  },
  "136": {
    "id": "136",
    "title": "Isolation Features",
    "content": "Isolation Feature SetThe isolation feature set is an hybrid solution that satisfies strict security and legal requirements, while minimizing ShotGrid System Admin specific required knowledge and maintenance. These features enable creative studios to confidently meet their supplier’s and studio’s highly stringent security, privacy, and performance requirements—from the cloud.Continue to About the isolation feature set for more details.Go to Setup if you are ready to activate the Isolation features.In This SectionGetting Started  About Isolation  Client Responsibilities  Onboarding Process  Planning your SetupFeatures Description  Media Isolation  Media Traffic Isolation  Media ReplicationSetup  Setup Overview  Media Isolation  Media Traffic Isolation  Media Replication  Isolation Fine Tuning  ActivationAWS Knowledge  Connecting Your Studio With Your AWS VPC  ShotGrid AWS Direct Connect Onboarding  S3  VPC / IAM / Security Group  Direct Connect  Private Link  VPC Endpoints  AWS Knowledge",
    "url": "/f378a164/",
    "relUrl": "/f378a164/"
  },
  "137": {
    "id": "137",
    "title": "3ds Max Plus",
    "content": "3dsMax PlusShotGrid 3ds Max Plus 插件在 3ds Max 应用程序与 ShotGrid Pipeline Toolkit 之间提供桥接。该插件支持 PySide 和所有多应用，这意味着您可以在 3ds Max 中运行我们的标准应用 - 也可以在 Maya 和 Nuke 等中运行的相同应用。该插件使用 3ds Max Plus Python API。支持的应用程序版本此插件已经过测试，已知可支持以下应用程序版本：2020 - 2023文档此插件借助 Max Plus 的 Python 支持将 ShotGrid Pipeline Toolkit (Sgtk) 与 3D studio Max 连接在一起。安装和更新将此插件添加到 ShotGrid Pipeline Toolkit如果您想将此插件添加到 Project XYZ 中名为 asset 的环境中，请执行以下命令：&amp;gt; tank Project XYZ install_engine asset tk-3dsmaxplus更新至最新版本如果您已在某个项目中安装了此应用，要获取最新版本，可运行 update 命令。您可以导航到该特定项目随附的 tank 命令，并在该项目中运行它：&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updates或者，也可以运行您的工作室的 tank 命令并指定项目名称，指示该命令要对哪个项目运行更新检查：&amp;gt; tank Project XYZ updates协作和代码演进如果您可以获取 ShotGrid Pipeline Toolkit，意味着也可以获取我们在 GitHub 中存储和管理的所有应用、插件和框架的源代码。欢迎根据实际需要演进和完善这些内容，以它们为基础做进一步的独立开发，修改它们（以及向我们提交 Pull 请求！），或者只是随手玩一玩，简单了解它们的构建方式和 Toolkit 的工作原理。您可以访问此代码库 (https://github.com/shotgunsoftware/tk-3dsmaxplus)。特殊要求需要安装 ShotGrid Pipeline Toolkit 核心 API 版本 v0.19.18 或更高版本才能使用此功能。",
    "url": "/7112d6a1/",
    "relUrl": "/7112d6a1/"
  },
  "138": {
    "id": "138",
    "title": "3ds Max",
    "content": "3ds MaxShotGrid 3ds Max 插件包含一个用于在 3ds Max 中集成 ShotGrid Toolkit (Sgtk) 应用的标准平台。它采用轻量型设计，操作简单直观，并会向主菜单中添加一个 ShotGrid 菜单。支持的应用程序版本此插件已经过测试，已知可支持以下应用程序版本：2020 - 2023文档ShotGrid 3dsMax 插件包含一个用于在 3dsMax 中集成 ShotGrid Pipeline Toolkit (Sgtk) 应用的标准平台。它采用轻量型设计，操作简单直观，并会向主菜单中添加一个 ShotGrid 菜单。安装和更新将此插件添加到 ShotGrid Pipeline Toolkit如果您想将此插件添加到 Project XYZ 中名为 asset 的环境中，请执行以下命令：&amp;gt; tank Project XYZ install_engine asset tk-3dsmax更新至最新版本如果您已在某个项目中安装了此应用，要获取最新版本，可运行 update 命令。您可以导航到该特定项目随附的 tank 命令，并在该项目中运行它：&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updates或者，也可以运行您的工作室的 tank 命令并指定项目名称，指示该命令要对哪个项目运行更新检查：&amp;gt; tank Project XYZ updates协作和代码演进如果您可以获取 ShotGrid Pipeline Toolkit，意味着也可以获取我们在 GitHub 中存储和管理的所有应用、插件和框架的源代码。欢迎根据实际需要演进和完善这些内容，以它们为基础做进一步的独立开发，修改它们（以及向我们提交 Pull 请求！），或者只是随手玩一玩，简单了解它们的构建方式和 Toolkit 的工作原理。您可以访问此代码库 (https://github.com/shotgunsoftware/tk-3dsmax)。特殊要求需要安装 ShotGrid Pipeline Toolkit 核心 API 版本 v0.19.18 或更高版本才能使用此功能。",
    "url": "/bb1266cb/",
    "relUrl": "/bb1266cb/"
  },
  "139": {
    "id": "139",
    "title": "After Effects",
    "content": "After EffectsShotGrid After Effects 插件提供一个用于在 After Effects 工作流中集成 ShotGrid 的平台。它包含一个标准 ShotGrid Pipeline Toolkit 插件并依赖于 tk-framework-adobe (CEP)。启用后，ShotGrid Adobe Panel 在 After Effects 中变为可用。此面板显示有关当前 ShotGrid 上下文以及该上下文中安装的应用注册的各种命令的信息。支持的应用程序版本此插件已经过测试，已知可支持以下应用程序版本：2020 (v17.0) - 2023 (v23.6)请注意，此插件也许（甚至非常有可能）支持更新的发行版本，但是尚未正式在这些版本中进行测试。界面概述ShotGrid 扩展面板采用与原生 After Effects 面板相同的配色和基本布局。面板由五个部分组成：  上下文标题 - 当前上下文的缩略图和字段。  收藏工具架 - 用于显示当前上下文中最常用的应用。  命令列表 - 当前上下文的所有未收藏命令。  上下文菜单 - 与上下文相关的其他命令和调试工具。  日志记录控制台 - 一个控制台叠加层，显示调试的日志记录输出。安装ShotGrid After Effects 插件在安装方面遵循的协议与其他 ShotGrid 集成相同。有关安装插件和应用的信息，请参见管理 Toolkit 文章。此外，您还可以参考默认 Toolkit 配置，以它为例了解如何配置集成。启用扩展安装此扩展后，需要通过 After Effects 中的扩展菜单启动它。此操作只需要执行一次，之后 ShotGrid 扩展面板便可一直留在 After Effects 布局中，后续启动时不必再启用。启用后，在以后启动时，扩展面板将在引导 ShotGrid 集成期间显示一个正在加载屏幕。此屏幕通常会持续显示几秒钟，待当前上下文确定后再显示命令。界面组成部分以下部分概述了 ShotGrid After Effects 集成的组成部分。上下文标题上下文标题是一个可自定义的区域，可显示有关当前 ShotGrid 上下文的信息。上下文由当前激活的文档决定。插件确定上下文后，标题会更新并显示上下文的缩略图字段详情。这些字段信息由一个挂钩来控制。有关如何对字段的显示进行自定义的信息，请参见下面的上下文字段显示挂钩部分。另外还需要注意的是，仅当使用 ShotGrid open 时才能识别上下文切换。收藏工具架收藏工具架与 Maya 和 Houdini 等其他 ShotGrid DCC 集成中提供的菜单收藏夹类似。在界面的这个部分，用户随手即可访问最常用的 Toolkit 应用，并可按照上下文标题轻松找到应用。此工具架以按钮的形式显示收藏的命令，将鼠标移至这些按钮时，按钮从灰色变为彩色，同时顶部的标签中显示它们的名称。将鼠标悬停在按钮上方时，将显示它们的工具提示。单击其中一个按钮，将触发回调，执行注册的命令。有关如何指定命令收藏夹的详细信息，请参见下面的工具架收藏夹部分。命令列表命令列表显示当前上下文注册的其他“常规”命令。通常，工作流配置内安装的应用会注册一个或多个命令，这些命令将显示在这里。如果命令未标识为收藏项，也未被指定为上下文菜单命令，它们将显示在此处。命令列表中按钮的行为与收藏工具架中按钮的行为类似。唯一真正的区别在于它们以列表的形式显示，并且其图标右侧带有完整名称。上下文菜单所有注册为上下文菜单命令的命令将显示在 ShotGrid 扩展面板的上下文菜单中。与其他命令区域一样，这些命令会随上下文一起变化。诸如 Jump to ShotGrid 和 Jump to Filesystem 这样的命令将始终位于此处。日志记录控制台日志记录控制台同时显示来自 CEP Javascript 解释器和 Toolkit Python 进程的所有日志记录输出。当扩展遇到任何需要技术支持的问题时，日志记录控制台的输出就变得极为有用，这些信息可帮助 ShotGrid 技术支持团队调试问题。配置和技术细节以下部分对集成中技术性更强的一些方面进行了概述，以帮助您根据自己工作室工作流的具体需求来配置集成。PySideShotGrid After Effects 插件依赖于 PySide。请参见有关安装 Pyside 的官方说明。CEP 扩展扩展本身与插件捆绑在一起，插件会在首次启动 After Effects 时自动安装扩展。扩展安装在美工人员的本地计算机上，位于操作系统特定的标准 CEP 扩展目录中：# Windows&amp;gt; C: Users [user name] AppData Roaming Adobe CEP extensions # OS X&amp;gt; ~/Library/Application Support/Adobe/CEP/extensions/每次启动 After Effects 时，插件引导代码会对照计算机上安装的扩展版本，检查随插件捆绑的扩展版本。这意味着，当插件更新后，假设它随附了一个新的扩展版本，已安装的扩展会自动更新为新捆绑的版本。配置收藏夹我们可以配置收藏工具架，让它显示已安装应用的任何注册命令。要执行此操作，只需向环境配置的 tk-aftereffects 部分添加 shelf_favorites 设置即可。示例如下：shelf_favorites:    - {app_instance: tk-multi-workfiles2, name: File Save...}    - {app_instance: tk-multi-workfiles2, name: File Open...}    - {app_instance: tk-multi-publish, name: Publish...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}设置的值是一个词典列表，每个词典指定了配置中安装的一个应用提供的一个注册命令。app_instance 键标识了一个特定的已安装应用，name 键则与该应用注册的命令的显示名称一致。在上面的示例中，您可以看到四个收藏的命令：tk-multi-workfiles2 应用的“File Open”和“File Save”对话框，以及 Toolkit 的“发布”(Publish)和“Snapshot”标准对话框。这四个命令现在将显示在收藏工具架中。环境变量为了辅助调试，有一组环境变量可用来更改插件的某些默认值：  SHOTGUN_ADOBE_HEARTBEAT_INTERVAL - Python 的心跳检测间隔（以秒为单位，默认为 1 秒）。  SHOTGUN_ADOBE_HEARTBEAT_TOLERANCE - 退出前允许出现的心跳检测错误的数量（默认值为 2）。旧环境变量  如果设置，也会考虑 SGTK_PHOTOSHOP_HEARTBEAT_TOLERANCE。  SHOTGUN_ADOBE_NETWORK_DEBUG - 在输出日志记录时包含附加的网络连接调试消息。旧环境变量  如果设置，也会考虑 SGTK_PHOTOSHOP_NETWORK_DEBUG。  SHOTGUN_ADOBE_PYTHON - 启动插件时使用的 Python 可执行文件的路径。如果不设置，将使用系统的 Python。如果 Photoshop 是从某个 Python 进程启动（如 ShotGrid Desktop 或通过 tk-shell 插件），则 Photoshop 集成将使用该进程使用的 Python。注意：Adobe 框架中存在其他环境变量。有关详细信息，请参见开发人员文档。上下文字段显示挂钩插件随附了一个挂钩，用来控制面板的上下文标题部分显示的字段。我们可以改写挂钩中的两个方法来自定义显示的内容。第一个方法是 get_entity_fields() 方法。此方法接受一个表示当前 ShotGrid 上下文的实体类型。返回的值应该是要为该实体查询并显示的各个字段的列表。插件自己负责异步查询数据。从 ShotGrid 查询到数据后，会调用挂钩中的第二个方法。此方法是 get_context_html() 方法，它接受上下文实体词典，其中填充有 get_entity_fields() 方法指定的查询字段。返回的值应该是一个字符串，该字符串包含带格式的 HTML，用以显示查询到的实体字段。默认的挂钩执行对于了解这些方法都需要什么来说是一个很好的参考。要注意的是，插件始终会显示实体的缩略图（如果有的话）。导入连续镜头挂钩插件提供了一个挂钩，用于控制特定文件类型的导入行为。用户可能想将 psd 文件导入为单个层，而不是合成。在这种情况下，该挂钩可以用来覆盖此行为。默认的挂钩执行After Effects API有关 After Effects API 的详细信息，请参见开发人员文档。",
    "url": "/1eca509c/",
    "relUrl": "/1eca509c/"
  },
  "140": {
    "id": "140",
    "title": "Alias",
    "content": "AliasShotGrid Alias 插件包含一个用于在 Alias 中集成 ShotGrid 应用的标准平台。它采用轻量型设计，操作简单直观，并会向 Alias 菜单中添加一个 ShotGrid 菜单。支持的应用程序版本此插件已经过测试，已知可支持以下应用程序版本：2020 - 2023请注意，此插件也许（甚至非常有可能）支持更新的发行版本，但是尚未正式在这些版本中进行测试。Python 版本支持  重要信息：随着 Alias ShotGrid Toolkit 插件 v2.1.5 的发布，我们不再支持 Python v2.7.x。请下载 ShotGrid Desktop v1.7.3（或更高版本），以确保默认使用 Python 3。旧版本有关 Python 版本对旧版本支持的详细信息，请单击此处。备注本地安装的解释器可能会导致出现意外行为。如果您想在工作室环境中使用此解释器，请联系技术支持。应用开发人员须知PySideShotGrid Alias 插件使用随 ShotGrid Desktop 发行的 PySide 版本，并在必要时将其激活。Alias 项目管理ShotGrid Alias 插件在每次启动时，都会将 Alias 项目设置为指向此插件的设置中定义的位置。这意味着，当您打开新文件时，项目也可能会发生变化。设置Shotgun Alias 项目的详细信息，可以使用模板系统，在配置文件中配置。使用 tk-alias此 ShotGrid 集成支持 Alias 应用程序系列（Concept、Surface 和 AutoStudio）。当 Alias 打开时，ShotGrid 菜单（Alias 插件）会添加到菜单栏中。“File Open”和“File Save”使用“我的任务”(My Tasks)和“零部件”(Assets)选项卡可以查看您的所有已分配任务，并浏览零部件。 在右侧，使用这些选项卡可以查看所有文件、与左侧选定内容关联的工作文件或已发布文件。发布(Publish)打开“发布”(Publish)对话框以将文件发布到 ShotGrid，然后供下游艺术家使用。有关详细信息，请参见在 Alias 中发布。 加载器(Loader)打开内容加载器应用，从而可以将数据加载到 Alias 中。有关详细信息，请参见在 Alias 中加载。Scene Breakdown打开“Scene Breakdown”对话框，其中显示已参考（WREF 参考）内容的列表，以及场景中过时或使用备用版本的 PublishedFile 的内容。有关详细信息，请参见 Alias 中的场景细分。",
    "url": "/8229b689/",
    "relUrl": "/8229b689/"
  },
  "141": {
    "id": "141",
    "title": "Create",
    "content": "ShotGrid CreateDesktop2 插件是运行在 ShotGrid Create 应用程序内部的插件。它用于从 ShotGrid Create 启动 DCC 以及通过浏览器集成从 ShotGrid Web 应用程序启动 DCC。tk-desktop2 插件支持 Toolkit 与 ShotGrid Create 的集成。ShotGrid Create 支持 Toolkit 用户熟悉的功能，包括 DCC 启动。安装和更新将此插件添加到 ShotGrid Pipeline Toolkit如果您想将此插件添加到 Project XYZ 和名为 asset 的环境中，请执行以下命令：&amp;gt; tank Project XYZ install_engine asset tk-desktop2Updating to the latest version如果您已在某个项目中安装了此应用，要获取最新版本，可运行 update 命令。您可以导航到该特定项目随附的 tank 命令，并在该项目中运行它：&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updates或者，也可以运行您的工作室的 tank 命令并指定项目名称，指示该命令要对哪个项目运行更新检查：&amp;gt; tank Project XYZ updates协作和代码演进如果您可以获取 ShotGrid Pipeline Toolkit，意味着也可以获取我们在 GitHub 中存储和管理的所有应用、插件和框架的源代码。欢迎根据实际需要演进和完善这些内容，以它们为基础做进一步的独立开发，进行更改（以及向我们提交 Pull 请求！）或者只是随手玩一玩，简单了解它们的构建方式和 Toolkit 的工作原理。您可以通过 https://github.com/shotgunsoftware/tk-desktop2 访问此代码库。特殊要求需要安装 ShotGrid Pipeline Toolkit 核心 API 版本 v0.19.1 或更高版本才能使用此功能。修复 ShotGrid 集成错误您的用户将收到以下错误消息：无法初始化集成。ValueError - ShotGrid 中的本地主机证书数据无效! 请与支持人员联系。此错误消息指示，当您的 ShotGrid 实例未配置为使用 ShotGrid Toolkit 集成时，他们尝试访问 ShotGrid Toolkit 功能。要防止用户访问 ShotGrid Toolkit 并看到错误消息，请启用环境变量 SHOTGUN_CREATE_DISABLE_TOOLKIT_INTEGRATION。此环境变量完全禁用 Create 中的 ShotGrid Toolkit 集成。如果错误地启用了此环境变量，则禁用它应该可以恢复 ShotGrid Toolkit 集成。",
    "url": "/969c1d7f/",
    "relUrl": "/969c1d7f/"
  },
  "142": {
    "id": "142",
    "title": "Tk-desktop 控制台以静默方式忽略错误",
    "content": "Tk-desktop 控制台以静默方式忽略错误用例开发 Toolkit 应用时，tk-desktop 会以静默方式忽略应用在初始化期间引发的所有异常，即使“切换调试日志记录”(Toggle debug logging)复选框处于启用状态也是如此。确定存在问题的唯一方法是，在加载项目的配置后，注册的命令不显示。如何修复当 Desktop 为项目加载应用时，该日志记录永远不会传递到 SG Desktop 主 UI 进程。但是，它应该仍会输出到 tk-desktop.log。检查该文件中是否存在异常。相关链接在社区中查看完整主题",
    "url": "/228e7940/",
    "relUrl": "/228e7940/"
  },
  "143": {
    "id": "143",
    "title": "Desktop",
    "content": "Desktoptk-desktop 插件是一个让您易于运行 Toolkit 应用的应用程序。它是一个基于系统托盘的窗口，通过它可轻松上手使用 Toolkit，为 Toolkit 设置项目，以及访问项目的工作流。站点配置和项目配置当您启动 Desktop 应用程序时，它会为站点配置启动 tk-desktop 插件。此配置的管理通常是自动的，但是我们也可以禁用自动管理，自己控制环境中的一切。Toolkit 的一个基本原则是，各个项目可以完全彼此隔离。通常，这是为了确保一个项目的更改不会对另一个项目造成不利影响（临近交付时可能出现这种情况）。为了提供这种项目隔离机制，Desktop 插件确保无论您何时使用某个特定项目的命令，都将在专为这个项目初始化的单独 Python 解释器中运行它们。当您单击一个项目时，后台会启动一个 Python 解释器。此 Python 解释器是为该项目配置的解释器，启动时将为该项目初始化 tk-desktop。插件的这个实例会与图形用户界面通信，指示可以启动什么命令。当您单击一个命令时，后台运行的 Python 进程会负责启动该命令。注册自定义面板具有基于面板的 UI 的 Toolkit 应用在执行时将自动停靠在 Desktop 内的选项卡中。如果您有基于面板的应用（如 ShotGrid 面板）并希望它在 ShotGrid Desktop 中显示为选项卡，只需将其配置为在启动时运行。Desktop 在其站点上下文模式下启动时（此时它显示所有项目），它将启动注册为自动启动的所有项。如果其中任何项是面板，则这些项将会停靠。这些项按其在配置中定义的顺序进行处理，该顺序即表示选项卡顺序。例如，如果您希望 ShotGrid 面板在 ShotGrid Desktop 中显示为选项卡，则为您的站点级环境添加以下配置：tk-desktop:  apps:    tk-multi-shotgunpanel:      actions_hook: ...      action_mappings: ...      location: ...  location: ...  run_at_startup:  - {app_instance: '', name: Apps}  - {app_instance: tk-multi-shotgunpanel, name: ''}请注意，特殊的 Apps 条目控制默认 Apps 选项卡应显示的位置（按照选项卡顺序）。",
    "url": "/75097ed0/",
    "relUrl": "/75097ed0/"
  },
  "144": {
    "id": "144",
    "title": "Flame 导出",
    "content": "Flame 导出ShotGrid Flame 导出应用可帮助您快速开始项目！在 Flame 中创建初始套底后，镜头导出器可帮助您在 ShotGrid 中快速生成内容，将图版渲染到磁盘，并发送内容以供审看。当流程开始正常运转后，导出器应用还会跟踪 Flare 或 Flame 批处理模式下发生的所有渲染，让您在工作流中轻松将内容送去审看。向 ShotGrid 发布套底当您在 Flame 中为一个场设置了套底，并为时间线中的所有分段分配了镜头名称后，选择该场，单击鼠标右键并选择“ShotGrid 镜头导出”(Flame Shot Export)选项。此时将显示一个 ShotGrid 用户界面，您可以在其中为发布输入一些初始注释。这些注释将被送去审核。另外，在向发布和其他内容添加说明信息时，也会使用这些注释。除了说明信息外，您还可以选择要为导出的图版使用哪种输出数据格式。这些预设是 Toolkit 应用配置的一部分，您可以配置它们来满足自己工作室的需要。单击“提交”(Submit)按钮后，将立即执行以下操作：      将在 ShotGrid 中创建镜头和任务。通过任务模板设置，可配置要与创建的每个新镜头关联的任务列表，以便快速轻松地创建一致的结构。默认情况下，镜头将以镜头序列为父项，但是您也可以对此进行配置，并且如果您处理的是场景或集结构，可以重新配置导出器支持这些设置。        当 ShotGrid 包含正确的数据后，将使用标准文件夹创建机制在磁盘上创建文件夹。这将确保项目可以快速启动，创建的所有镜头都有一套统一的文件夹结构。  执行上面两个步骤后，您便有了进行后续操作的基本结构。后台将执行以下操作：      根据配置中定义的预设，在磁盘上导出每个镜头的图版。文件位置使用 Toolkit 模板系统进行定义，这意味着这些图版的位置定义清楚，工作流中的其他下游工具可以识别它们。        将导出批处理文件和视频片段 XML 文件。Flame 将使用这些内容启用一个迭代工作流，您可以在其中快速渲染新的版本，然后将它们导入 Flame 中的主套底。        生成 QuickTime 影片并上传至 ShotGrid 进行审看。  发送批处理渲染进行审看为镜头发布了 Flame 批处理文件后，您可以直接从该镜头启动 Flare，打开预填充了渲染和输出设置的批处理文件。要渲染出新的版本，只需单击“Render Range”按钮即可。Toolkit 会在此时显示一个对话框，让您选择是否将渲染发送至 ShotGrid 进行审看。ShotGrid 将发布并跟踪文件，并且也可选择将文件送去审看。想了解更多信息？如果您想了解更多信息以及此工作流的实际操作，请参见 Flame 插件文档。另外，我们还在文档中提供了一些演示各种工作流实际操作的视频内容。LINKBOX_ENGINE：ShotGridsoftware/tk-flame：Flame 插件与以往一样，如果您对集成或自定义有任何疑问，请随时访问我们的支持站点。高级主题下面提供了更多与配置和自定义相关的高级详细信息。使用导出预设导出器在其配置中使用了“导出预设”的概念。当您在 Flame 内启动导出用户界面时，将看到一个下拉列表，其中包含可用的导出预设。每个预设都是一个配置选项，通过它可配置将文件写入磁盘和上传至 ShotGrid 的方式。诸如文件在磁盘上的位置等高级设置直接在环境配置中进行控制，以易于调整默认的配置选项来适合您的工作流。更高级的设置，以及为控制 Flame 而对传递给 Flame 的实际导出 XML 内容施加的控制，则由一个挂钩进行处理，其中定义了每个预设的行为。在该挂钩中，您可以完全控制导出器生成媒体的方式。绕过 ShotGrid 服务器端转码默认情况下，我们通过设置 Version.sg_uploaded_movie 字段，将 QuickTime 影片上传至 ShotGrid 进行审看。这进而会触发 ShotGrid 服务器端转码；上传的 QuickTime 影片会进一步转换为专为在浏览器中和移动设备上播放而定制的 mp4 和 webm 格式。有时，绕过这种服务器端转码可能会有好处。我们可以通过设置 bypass_shotgun_transcoding 配置设置来做到这一点。当此设置为 True 时，集成会直接上传至 ShotGrid 中的 Version.sg_uploaded_movie_mp4 字段，从而绕过服务器端转码。这种情况下，不会生成 webm 版本，因此在 Firefox 中无法进行审看播放。有关详细信息，请参见 https://help.autodesk.com/view/SGSUB/CHS/?guid=SG_Supervisor_Artist_sa_review_approval_sa_transcoding_html自定义 ffmpeg导出器在生成 QuickTime 影片时，使用 Flame 随附的 ffmpeg 版本。您可以通过修改导出器中的设置挂钩，指定使用某个外部 ffmpeg 版本来代替内置版本。随 Flame 一起分发的 ffmpeg 版本将跟踪 ffmpeg 转码和性能方面的最新进展，因此使用最新版本有时会带来性能提升。请注意，与默认使用的版本相比，最新版本中向 ffmpeg 传递 h264 参数的方式有所变化。通过切换到最新版本的 ffmpeg，可以丝毫不差地实施建议的转码指导原则，在 ShotGrid 端实现最优的上传和性能。您可以在以下位置找到这些指导原则：https://help.autodesk.com/view/SGSUB/CHS/?guid=SG_Supervisor_Artist_sa_review_approval_sa_transcoding_html仅当您是高级用户时，我们才建议更改 ffmpeg 版本。在这种情况下，请按以下步骤操作：复制设置挂钩您可以在 Flame 导出应用随附的设置挂钩中找到需要修改的所有设置。要修改此挂钩，首先需要将此挂钩文件从应用内的默认位置复制到您的配置中。在您的项目配置中，该挂钩文件通常位于类似如下位置：install/apps/app_store/tk-flame-export/va.b.c/hooks/settings.py。将此文件复制到配置内的 hooks 位置，例如 config/hooks。建议将它重命名为比 settings.py 更详细的名称，以便对文件的性质一目了然：install/apps/app_store/tk-flame-export/va.b.c/hooks/settings.py -&amp;gt; config/hooks/flame_export_settings.py接下来，编辑 Flame 环境配置文件。此文件通常为 config/env/includes/flame.yml。在 tk-flame-export 标题下，您会发现挂钩路径定义为 settings_hook: '{self}/settings.py'。这实际意味着，配置将在应用所在位置（例如 {self}）内查找挂钩文件。将此设置更改为 settings_hook: '{config}/flame_export_settings.py' 将指示 Toolkit 改为在配置内查找挂钩文件。总结如下：settings_hook: '{self}/settings.py' -&amp;gt; '{config}/flame_export_settings.py'修改挂钩现在，我们已准备好开始修改 config/hooks/flame_export_settings.py 挂钩！在文本编辑器中打开它。您会发现几个与 ffmpeg 和 ffmpeg 设置相关的方法。首先要修改的是以下内容：def get_external_ffmpeg_location(self):    &quot;&quot;&quot;    Control which version of ffmpeg you want to use when doing transcoding.    By default, this hook returns None, indicating that the app should use    the built-in version of ffmpeg that comes with Flame.    If you want to use a different version of ffmpeg, simply return the path    to the ffmpeg binary here.    :returns: path to ffmpeg as str, or None if the default should be used.    &quot;&quot;&quot;    return None默认情况下，导出器返回 None，将使用 Flame 的内置 ffmpeg。更改此设置，使其返回您的 ffmpeg 的完整路径。记住，如果您运行的是 Backburner 集群，可能会从集群内的任何计算机调用 ffmpeg，因此请确保所有位置都安装了可执行文件。更新 ffmpeg 位置后，您很可能需要或者想要调整传递给 ffmpeg 的参数。这需要使用两个不同的方法进行更改：      get_ffmpeg_quicktime_encode_parameters 将返回生成上传至 ShotGrid 的 QuickTime 影片时使用的参数。        get_local_quicktime_ffmpeg_encode_parameters 将返回向磁盘写入 QuickTime 影片时使用的参数。  对于 ShotGrid 上传，建议开始时使用默认的 ShotGrid 编码设置：def get_ffmpeg_quicktime_encode_parameters(self):    return &quot;-vcodec libx264 -pix_fmt yuv420p -vf 'scale=trunc((a*oh)/2)*2:720' -g 30 -b:v 2000k -vprofile high -bf 0&quot;对于本地 ShotGrid 转码，建议以 ShotGrid 转码设置为基础设定您的设置，但是要删除分辨率约束并增大码率：def get_local_quicktime_ffmpeg_encode_parameters(self):    return &quot;-vcodec libx264 -pix_fmt yuv420p -g 30 -b:v 6000k -vprofile high -bf 0&quot;",
    "url": "/04a6342b/",
    "relUrl": "/04a6342b/"
  },
  "145": {
    "id": "145",
    "title": "Flame 审看",
    "content": "Flame 审看ShotGrid Flame 审看应用让您可轻松将一个或多个场从 Flame 推送到 ShotGrid 审看功能。只需在要审核的一个或一组镜头序列上单击鼠标右键：选择“ShotGrid 审看”(ShotGrid Review)选项：此时将显示一个 Toolkit 用户界面，您可以在其中添加审核注释：单击“确定”(OK)后，将生成一个后台作业，所有处理都在后台进行。将要执行的步骤包括：      将镜头序列作为 QuickTime 影片导出到磁盘。此导出按 Flame QuickTime 影片导出处理，您可以通过配置挂钩完全控制各种设置。        场处理完毕后，Toolkit 会检查 ShotGrid 中是否有匹配的场。如果没有，将自动创建一个镜头序列。        生成一个审核版本，并将它与镜头序列关联。        最后，将 QuickTime 影片上传至该审核版本。  此过程支持音频轨道、转场等，并且采用“所见即所得”的方式。在 ShotGrid 中，您可以用多种方式审看媒体，包括使用客户审核和 ShotGrid iPhone 应用。自定义和设置Flame 审核应用可进行以下几种不同的自定义：      您可以控制在 ShotGrid 中使用哪种实体类型来表示 Flame 中的场。例如，如果您处理的是剧集内容，更合理的做法是将审看版本链接到 ShotGrid 中的剧集，而不是场。        您可以自定义应用应该自动将哪些任务添加到 ShotGrid 中新创建的项。这可以通过任务模板设置来实现，并且这样做可对创建的结构进行标准化设置。        通过挂钩，您可以对应用在 Flame 中生成 QuickTime 影片所用的 XML 预设进行完全控制。  ",
    "url": "/b38dc286/",
    "relUrl": "/b38dc286/"
  },
  "146": {
    "id": "146",
    "title": "Flame",
    "content": "Flame安装ShotGrid Flame 插件依赖于 Flame 2015 Extension 2 中新增的几个集成挂钩。为了保证插件正常工作，必须使用这一版本的 Flame。有关 Flame 2015 Extension 2 的详细信息（包括如何获取），请联系 Flame 支持。要想快速开始学习 ShotGrid Flame 插件，最简单的方法是使用我们的示例工作流配置设置一个新的测试项目。您只要启动 ShotGrid Desktop，运行项目设置向导设置一个新项目，然后选择默认的 Flame 配置（在默认配置部分）即可。支持的应用程序版本此插件已经过测试，已知可支持以下应用程序版本：2020+Flame 项目设置ShotGrid Flame 插件还能帮您将 ShotGrid 项目与 Flame 项目关联起来，需要时还可创建 Flame 项目。这是集成的关键所在，因为这可以确保 Flame 的数据与 ShotGrid 中的正确数据相关联。作为一项附加特性，插件还提供管理 Flame 项目命名约定以及项目其他各种设置的功能。首次通过 ShotGrid 启动 Flame 时，会显示一个创建 Flame 项目的用户界面，让艺术家可在标准 Flame 项目创建屏幕中编辑常用设置：但是，利用 ShotGrid 集成，我们可以为这些设置预先填充适合工作流的值，帮助艺术家不假思索地快速获取需要的内容。默认值可通过 project_setup_hook 进行自定义，此设置支持以下选项：use_project_settings_ui 如果设置为 True，将显示项目创建用户界面。如果设置为 False，将根据挂钩中的其余默认值自动创建 Flame 项目。get_server_hostname 默认情况下，此选项设置为“localhost”，但可根据需要改写。get_project_name 默认情况下，此选项设置为与 ShotGrid 项目相同的值，但可根据需要改写。get_volume 默认情况下，此选项设置为第一个可用的存储设备，但可根据需要改写。get_workspace 默认情况下，Flame 会根据其标准工作空间创建逻辑创建一个默认工作空间，但可根据需要改写。get_user 此选项会尝试将登录到 Flame 计算机的用户与 ShotGrid 中的用户关联。get_project_settings 这是配置 Flame 主要设置的地方，挂钩将帮助用户构建 Flame 项目的 XML 流。必须提供以下参数：  FrameWidth（例如 1280）  FrameHeight（例如 1080）  FrameDepth（16-bit fp、12-bit、12-bit u、10-bit、8-bit）  FieldDominance（PROGRESSIVE、FIELD_1、FIELD_2）  AspectRatio（4:3、16:9 或字符串形式的浮点值）另外，还可以提供代理设置。有关详细信息，请参见 Autodesk Wiretap SDK 文档！要查看 project_setup 挂钩的整个代码库，请参见插件的 Github 库。",
    "url": "/d5d7b724/",
    "relUrl": "/d5d7b724/"
  },
  "147": {
    "id": "147",
    "title": "管理员 UI",
    "content": "Toolkit 管理用户界面框架管理用户界面框架实现了一个环境来容纳打包 Toolkit 管理命令的标准用户界面。目前只有一个针对 setup_project 命令的界面。SetupProjectWizard API 参考这是一个 QWizard 执行，它将引导用户在 Toolkit 的 ShotGrid 实例中按步骤设置项目。要使用此向导程序，只需创建一个类实例，传入要设置的项目（采用标准 ShotGrid API 实体词典形式）和要设置父子关系的窗口。adminui = sgtk.platform.import_framework(&quot;tk-framework-adminui&quot;, &quot;setup_project&quot;)setup = adminui.SetupProjectWizard(project, parent)dialog_result = setup.exec_()此操作将运行向导程序，并返回一个标准的 QDialog 接受 (Accepted) 或拒绝 (Rejected) 值。SetupProjectWizard 构造函数初始化 SetupProjectWizard。  这是 QtGui.QWizard 的一个子类。SetupProjectWizard()",
    "url": "/02fa2cba/",
    "relUrl": "/02fa2cba/"
  },
  "148": {
    "id": "148",
    "title": "桌面服务器框架",
    "content": "Toolkit 桌面服务器框架桌面服务器框架提供相关功能来支持 ShotGrid 本地文件链接和 Toolkit 集成功能。它提供一个本地 Websocket 服务器，该服务器会以安全的方式侦听 ShotGrid 网站发出的需要访问桌面的动作请求。对于本地文件链接，这些请求让 ShotGrid 能够从 Web 界面访问本地文件路径，并且在收到请求时，能够直接从 ShotGrid 页面打开这些文件。对于 Toolkit，它们让 ShotGrid 能够判断给定的实体注册了哪些工作流动作，并执行这些动作。如何让桌面集成正常运行要让这些 ShotGrid 功能正常工作，某些支持的桌面集成必须运行。此页面介绍了 ShotGrid 如何与桌面集成的各种选项。“Websocket 服务器”部分介绍了此框架提供的功能。ShotGrid Desktop此框架与 ShotGrid Desktop 捆绑在一起，可以按照以下步骤下载。ShotGrid Desktop 运行时，会自动启动 Websocket 服务器。如果 ShotGrid Desktop 已运行，您的设置过程即告完成。配置服务器您可以将浏览器集成设置存储在配置文件中。可以通过设置环境变量 SGTK_BROWSER_INTEGRATION_CONFIG_LOCATION 指定此配置文件。有关如何配置本地服务器的更多详细信息，请参见我们的示例文件。删除证书如果您想删除之前创建的证书，可以运行 python certificates.py --remove 命令。通过封装器启动默认情况下，服务器使用操作系统的默认方式来启动命令（相当于 Linux 上的“xdg-open”、OS X 上的“打开”和 Windows 上的“运行”）。如果您想使用自己的封装器来启动文件，可以设置 SHOTGUN_PLUGIN_LAUNCHER 环境变量，使它指向您的自定义封装器。如果设置了该环境变量，系统将会调用封装器，同时路径是它唯一的参数。证书当您第一次运行服务器时，它会生成建立安全连接所需的证书。这些证书存储在您计算机的本地，绝不会对外公开。使用证书，可以建立 Websocket 所需的加密连接，而且即使所有通信都在本地（从您的浏览器到服务器），加密连接也是必要的；ShotGrid 的 Websocket 通信永远不会面向 Internet 公开。证书向系统注册时，您会看到如下所示的对话框。单击“确定”(OK)继续注册。  使用 ShotGrid Desktop 时，生成的证书存储在以下位置：OS X：~/Library/Caches/Shotgun/desktop/config/certificatesWindows：%AppData% Shotgun desktop config certificatesLinux：~/.shotgun/desktop/config/certificates安全设置 - 本地 ShotGrid 安装默认情况下，Websocket 服务器设置为在端口 9000 上侦听托管的 ShotGrid 站点。如果您运行的是本地 ShotGrid 服务器，将需要更新 ShotGrid 服务器的配置，以便可以从您的 Websocket 服务器进行连接。运行 ShotGrid Desktop 时，您需要设置一个 config.ini 文件，该文件与 ShotGrid 二进制文件位于同一个位置。此文件内有一个部分用来控制 Websocket 服务器的功能。典型的配置如下所示：[BrowserIntegration]low_level_debug=0port=9000enabled=1whitelist=*.shotgunstudio.com疑难解答在 Linux 平台上，该服务器增加了对 libffi 的依赖。如果 Desktop 在启动时崩溃，并且日志中包含未找到 libffi 的消息，您需要安装此软件包。如果您在设置过程中遇到任何问题或疑问，请访问我们的支持站点。如果运行服务器时遇到问题，请在 config.ini 文件中将 debug 设置为 1，并包含 Desktop 的日志文件。日志文件可在以下位置找到：OS X：~/Library/Logs/Shotgun/tk-desktop.logWindows：~%APPDATA% Shotgun tk-desktop.logLinux：~/.shotgun/tk-desktop.log",
    "url": "/c79f1656/",
    "relUrl": "/c79f1656/"
  },
  "149": {
    "id": "149",
    "title": "桌面启动",
    "content": "Toolkit 桌面启动框架桌面启动框架用于执行 ShotGrid Desktop 的启动逻辑。它的主要功能包括：  初始化浏览器集成  完成用户登录  下载 Toolkit  配置站点配置  自动更新自身并在必要时更新站点配置  启动 tk-desktop 插件。  这是一个内部 Toolkit 框架，因此它实现的界面随时可能发生变化。建议您不要在自己的项目中使用此框架。锁定启动逻辑  请注意，此操作需要使用版本为 1.3.4 的 ShotGrid Desktop 应用。如果您不确定自己的应用程序版本，请启动 ShotGrid Desktop。登录后，单击右下角的用户图标，然后单击 About...。App Version 应该为 1.3.4 或更高版本。默认情况下，ShotGrid Desktop 会将 tk-framework-desktopstartup 更新下载到用户计算机本地，并在应用程序启动过程中使用它。当您启动应用程序时，Toolkit 会自动检查是否有此框架的更新。如果有更新，它还会自动下载并安装更新。另外，您还可以将 ShotGrid Desktop 配置为使用框架的特定副本，而不使用本地副本。这样做将禁用自动更新功能，您需要自己更新启动逻辑。从 GitHub 下载特定的发布版本有时，您需要手动从 GitHub 下载更新。您可以很容易地从版本(Releases)页面下载软件包，并可在此处找到有关每个官方发布版本的详细信息。配置 ShotGrid Desktop 使用特定副本要锁定启动逻辑，唯一的方法是使用环境变量。将 SGTK_DESKTOP_STARTUP_LOCATION 设置为框架某个副本的根文件夹，即表示您指示 ShotGrid Desktop 在启动时使用这份代码副本。变量设置完毕后，您可以启动 ShotGrid Desktop，它将使用这份特定的启动逻辑副本。  请注意，撰写本文时，由于技术限制，About... 框中的 Startup Version 字段在锁定启动逻辑时将为 Undefined。还原至旧的行为要还原您的更改，只需取消设置环境变量，然后启动 ShotGrid Desktop 即可。",
    "url": "/3414fbb3/",
    "relUrl": "/3414fbb3/"
  },
  "150": {
    "id": "150",
    "title": "Hiero/Nuke Studio 导出",
    "content": "Hiero/Nuke Studio 导出简介此应用为 Hiero 的场导出对话框添加 ShotGrid 感知功能。概述视频和演示如果您是刚刚接触 ShotGrid Toolkit 或 Hiero 集成，请观看下面的视频，快速了解一下 ShotGrid Toolkit Hiero 集成在您的工作流中能做些什么。如果您已熟悉 Toolkit 和 Hiero，可以继续阅读下面的文档。ShotGrid 镜头处理器此应用在激活时会为 Hiero 导出对话框注册一系列更改：首先是注册的新处理器：当您单击此处理器时，有一些新的变化值得注意。在对话框顶部，有一个额外的用户界面，它可以帮助您控制导出场时如何在 ShotGrid 中创建/更新镜头：标记(Tags)通过调整下拉列表，您可以将各种 Hiero 标记映射到 ShotGrid 镜头状态和镜头任务模板。这样，通过 Hiero 的标记工作流，您可以将某个 ShotGrid 镜头设置为正在进行中，或者为镜头设置绿屏、CG 额外奖励或任何对您的配置有意义的任务。此用户界面通过一个挂钩填充，并且很容易配置额外奖励功能。整理应用还提供选项，控制如何对照 Hiero 的内置逻辑将轨道项整理在一起。  如果您的一个镜头由多个项构成（无论是重叠、在不同轨道上还是在多个轨道上具有相同的镜头名称），应开启这些选项。这样，ShotGrid Toolkit 镜头更新程序会将匹配的整理项视为一个镜头。例如，假设我们有两个轨道项，分别代表镜头 010 和 020。010 在前，020 在不同的轨道上与 010 的结尾重叠。由于 010 在前，它是主镜头并启用了整理功能，ShotGrid 会将这两个项视为一个镜头 (010)。这意味着，应用将在 ShotGrid 中创建或更新镜头 010。剪辑镜头入点将匹配轨道项 010 的开头，剪辑镜头出点将匹配轨道项 020 的结尾。应用将为每个轨道项创建一个可供审片室审看的版本，但这两个版本都将链接至镜头 010。应用还将以发布文件的形式为每个轨道项创建一个图版，但二者都将链接至镜头 010。此外，应用将发布一个 Nuke 脚本，该脚本链接至镜头 010，包含 2 个读取节点，每个项各一个节点。请注意，在这种情况下，不会在 ShotGrid 中创建或更新镜头 020，因为它已整理到镜头 010 中。路径在 ShotGrid 用户界面下面，是标准路径对话框。默认情况下，会通过 Hiero 向镜头添加三项内容，包括一个默认的 Nuke 脚本、一个默认的 Nuke 写入位置和一个默认的图版转码位置。  这些项的位置由应用的配置决定，并可完全使用模板系统：此应用会向 Hiero 添加一个 {tk_version} 令牌，它将被替换为版本字符串，并采用 ShotGrid Toolkit 要求的正确格式。自定义模板字段您在 custom_template_fields 设置中定义的由 resolve_custom_strings 挂钩解析的任何令牌都将自动添加到 Hiero 的有效替换令牌列表中，并被视为 Toolkit 模板路径中的有效替换项。例如，在 Toolkit 的 templates.yml 文件中，假设您使用以下内容定义一个键：    resolution:        type: str        filter_by: alphanumeric  在 tk-hiero-export 的 project.yml 设置中，有以下设置：  ...  ...  tk-hiero:    apps:      tk-hiero-export:        custom_template_fields:        - {description: Shot Resolution, keyword: resolution}  ...  ...然后，您按如下所示修改 resolve_custom_strings 挂钩：# Copyright (c) 2014 ShotGrid Software Inc.## CONFIDENTIAL AND PROPRIETARY## This work is provided &quot;AS IS&quot; and subject to the ShotGrid Pipeline Toolkit# Source Code License included in this distribution package. See LICENSE.# By accessing, using, copying or modifying this work you indicate your# agreement to the ShotGrid Pipeline Toolkit Source Code License. All rights# not expressly granted therein are reserved by ShotGrid Software Inc.from tank import Hookclass HieroResolveCustomStrings(Hook):    &quot;&quot;&quot;Translates a keyword string into its resolved value for a given task.&quot;&quot;&quot;    RESOLUTION_TOKEN_NAME = &quot;{resolution}&quot;    def execute(self, task, keyword, **kwargs):        &quot;&quot;&quot;        &quot;&quot;&quot;        self.parent.log_debug(&quot;attempting to resolve custom keyword: %s&quot; % keyword)        if keyword == self.RESOLUTION_TOKEN_NAME:            translated_value = self._clip_resolution_string(task)        else:            raise RuntimeError(&quot;No translation handler found for custom_template_field: %s&quot; % keyword)        self.parent.log_debug(&quot;Custom resolver: %s -&amp;gt; %s&quot; % (keyword, translated_value))        return translated_value    # Handle the {resolution_fs} token    def _clip_resolution_string(self, task):        &quot;&quot;&quot; returns sequence resolution or task format override&quot;&quot;&quot;        width = &quot;&quot;        height = &quot;&quot;        sequence_format = task._sequence.format()        width = sequence_format.width()        height = sequence_format.height()        if &quot;reformat&quot; in task._preset.properties():            task_reformat_settings = task._preset.properties()[&quot;reformat&quot;]            if task_reformat_settings['to_type'] != &quot;None&quot;:                width = task_reformat_settings['width']                height = task_reformat_settings['height']        return &quot;%sx%s&quot; % (width, height)现在，您不仅可以在 Hiero 中使用 resolution 令牌，而且它还会对照您在 Toolkit 中定义的任何模板路径进行验证，这样便可导出到一个类似如下的位置：    hiero_plate_path: &quot;sequences/{Sequence}/{Shot}/hiero_plates/{resolution}/v{version}/{project}_{Shot}.mov&quot;ShotGrid 任务注册的新任务类型有两个。ShotGrid 转码图像这是标准 Hiero 转码任务的一个子类，它会在 ShotGrid 中将转码结果注册为发布。另外，还将选择性地在 ShotGrid 中创建一个版本。如果创建了版本，还会创建一个 QuickTime 影片，并将它上传为审片室媒体。ShotGrid Nuke 项目文件这是标准 Hiero Nuke 脚本导出器的一个子类，它会在 ShotGrid 中将生成的 Nuke 脚本注册为与镜头链接的已发布文件。这些设置让您可指定导出时在文件中包含哪些支持 Toolkit 的写入节点。plate_published_file_type 和 nuke_script_published_file_type 这两项应用设置让您可控制发布文件注册的文件类型。此外，nuke_script_toolkit_write_nodes 让您可控制应在导出对话框中提供哪些写入节点设置。导出过程运行导出时，导出队列中会出现一些额外的任务：每个镜头会运行一个 ShotGridShotUpdater 任务，该任务负责在 ShotGrid 中创建镜头，并创建数据结构配置中指定的完整镜头结构。ShotGrid 中的场和镜头更新应用将使用 Hiero 镜头序列的名称作为镜头序列名称，并且会在镜头中填入它们的剪辑镜头信息（剪辑镜头顺序、剪辑序列开头入点、剪辑镜头入点、剪辑镜头出点、剪辑序列结尾出点、剪辑镜头时长和剪辑序列时长）。  此外，如果选择了构成镜头的镜头序列或内容项中的某些帧作为海报帧，还会上传它们作为镜头的缩略图。如果您的工作流使用不同于“镜头序列”(Sequence)的其他实体作为镜头的父对象（比如“集”(Episode)），可以改写 hook_get_shot 挂钩中的 get_shot_parent 方法。 默认的执行会创建（如果有必要）并返回一个“镜头序列”(Sequence)实体。剪辑镜头数据结构支持如果您的 ShotGrid 站点支持剪辑镜头数据结构（v7.0.0 或更高版本），此应用会自动在 ShotGrid 中生成一个具有对应“剪辑镜头项”(CutItem)的“剪辑镜头”(Cut)。“剪辑镜头”(Cut)实体对应 Hiero 镜头序列，“剪辑镜头项”(CutItem)实体对应镜头序列中的项。 “剪辑镜头”(Cut)实体将链接到 hook_get_shot 挂钩中的 get_shot_parent 方法返回的父实体（默认为“镜头序列”(Sequence)）。 “剪辑镜头项”(CutItem)将与一个“镜头”(Shot)实体关联，并链接到导出期间创建的可审看的“版本”(Version)实体。 导出后，将可以在 ShotGrid 的“媒体”(Media)选项卡和 RV 中播放该“剪辑镜头”(Cut)。所有与“剪辑镜头”(Cut)和“剪辑镜头项”(CutItem)实体关联的元数据均从 Hiero 推算得出，但“Cut Type”**字段除外，此字段可在导出用户界面中指定。此处的值将显示在“剪辑镜头”(Cut)实体的“类型”(Type)字段中。需要注意的是，选择了任意整理选项后，将不支持剪辑镜头数据结构，并会跳过“剪辑镜头”(Cut)和“剪辑镜头项”(CutItem)项的创建。此外，剪辑镜头数据结构并不处理重定时的视频片段。导出重定时的视频片段时，会记录一条调试警告消息。交替镜头层次结构对于不采用标准“镜头序列 &amp;gt; 镜头”层次结构、可能会使用“集”和/或“场景”的工作室，有一个 hiero_get_shot 挂钩可用来配置应用，使其支持您的工作室当前使用的任何镜头层次结构。",
    "url": "/523d3720/",
    "relUrl": "/523d3720/"
  },
  "151": {
    "id": "151",
    "title": "在 ShotGrid 中打开 Hiero/Nuke Studio",
    "content": "在 ShotGrid 中打开 Hiero/Nuke Studio此应用向 Hiero 电子表格和时间线添加一个上下文菜单，让您可在 ShotGrid 中打开有对应镜头的给定轨道项。通常，在配置此应用时，要通过向 ShotGrid Nuke 插件配置中添加以下内容，将它添加到 Hiero 中的时间线和电子表格菜单：    timeline_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: &quot;Open in ShotGrid&quot;, requires_selection: true}    spreadsheet_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: &quot;Open in ShotGrid&quot;, requires_selection: true}",
    "url": "/88ae1c1d/",
    "relUrl": "/88ae1c1d/"
  },
  "152": {
    "id": "152",
    "title": "Houdini Alembic 节点",
    "content": "Houdini Alembic 节点Houdini Alembic 节点应用提供一个自定义的 ShotGrid Alembic 输出节点，通过它可轻松设置标准化的 Alembic 文件输出位置。您可以为每个环境配置它。一般用法要使用 ShotGrid Alembic 输出，请先将您的脚本另存为 Toolkit 工作文件，然后通过 Houdini 中的 TAB 菜单创建一个新节点。这将创建一个与普通 Alembic 输出节点类似的节点：此节点可配置多个输出配置文件，每个配置文件使用一个不同的模板路径指定 Alembic 缓存在磁盘上的写入位置。您不用手动输入路径，只需指定要使用哪个输出配置文件，节点便会自动计算路径的其余部分。您可以在用户界面中查看计算出的路径。输出的 Alembic 文件分为不同版本，版本号始终遵循当前的 Houdini 场景文件版本，当您使用多发布进行发布时，版本会自动递增。配置Toolkit 的 Alembic 节点提供为一个环境配置指定多个输出配置文件的功能。下面是一个为节点配置多个配置文件的示例：  tk-houdini:    apps:      tk-houdini-alembicnode:        location:          name: tk-houdini-alembicnode          type: app_store          version: v0.2.2        work_file_template: houdini_shot_work        default_node_name: tk_alembic_out        output_profiles:          - name: For Publishing            settings: {}            color: [1.0, 0.5, 0.0]            output_cache_template: houdini_shot_work_alembic_cache          - name: Local Testing            settings: {}            color: [0.0, 0.5, 1.0]            output_cache_template: houdini_shot_local_alembic_cache您可以使用输出配置文件通过 color 字段改变节点的外观，并可通过提供与 settings 字段中的参数匹配的键/值对，调整底层 Alembic 节点上的单个参数。最后，output_cache_template 字段驱动写入磁盘的 Alembic 缓存的输出路径。",
    "url": "/55f75584/",
    "relUrl": "/55f75584/"
  },
  "153": {
    "id": "153",
    "title": "Houdini Mantra 节点",
    "content": "Houdini Mantra 节点Houdini Mantra 节点应用提供一个自定义的 ShotGrid Mantra 输出节点，通过它可轻松设置标准化的渲染文件输出位置。您可以为每个环境配置它。一般用法要使用 ShotGrid Mantra 节点，请先将您的脚本另存为 Toolkit 工作文件，然后通过 Houdini 中的 TAB 菜单创建一个新节点。这将创建一个与普通 Mantra 输出节点类似的节点：此节点可配置多个输出配置文件，每个配置文件使用一组不同的模板路径指定渲染输出（图像、ifd、dcm、aov 等）在磁盘上的写入位置。您不用手动输入路径，只需指定要使用哪个配置，节点便会自动计算路径的其余部分。您可以在用户界面中查看计算出的路径。渲染的文件分为不同版本，版本号始终遵循当前的 Houdini 场景文件版本，当您使用多发布进行发布时，版本会自动递增。配置Toolkit 的 Mantra 节点提供为一个环境配置指定多个输出配置文件的功能。下面是一个为节点配置多个配置文件的示例：  tk-houdini:    apps:      tk-houdini-mantranode:        location:          name: tk-houdini-mantranode          type: dev          version: v0.2.2        default_node_name: tk_mantra_out        work_file_template: houdini_shot_work        output_profiles:          - name: Primary Render            settings: {}            color: [1.0, 0.5, 0.0]            output_render_template: houdini_shot_render            output_ifd_template: houdini_shot_ifd            output_dcm_template: houdini_shot_dcm            output_extra_plane_template: houdini_shot_extra_plane          - name: Local Render            settings: {}            color: [0.0, 0.5, 1.0]            output_render_template: houdini_shot_local_render            output_ifd_template: houdini_shot_local_ifd            output_dcm_template: houdini_shot_local_dcm            output_extra_plane_template: houdini_shot_local_extra_plane您可以使用输出配置文件通过 color 字段改变节点的外观，并可通过提供与 settings 字段中的参数匹配的键/值对，调整底层 Alembic 节点上的单个参数。最后，output_*_template 字段控制 Mantra 渲染器写入磁盘的文件的输出路径。",
    "url": "/2c47f879/",
    "relUrl": "/2c47f879/"
  },
  "154": {
    "id": "154",
    "title": "Houdini",
    "content": "HoudiniShotGrid Houdini 插件包含一个用于在 Houdini 中集成 ShotGrid 应用的标准平台。应用开发人员须知支持的平台ShotGrid Houdini 插件目前支持在 Windows、Linux 和 OS X 平台运行支持的应用程序版本此插件已经过测试，已知可支持以下应用程序版本：17.5 - 19.5 Note: Running on Apple Silicon (M1/M2), Houdini is supported for both Native mode and Rosetta mode.PySide对于先前的 Houdini 版本（13 及更早），需要安装 PySide 的外部版本。在 Windows 上，我们已经捆绑了一个兼容的 PySide 版本，该版本可支持 Houdini 运行的 Python。在 Linux 上，Houdini 使用系统 Python（依据https://www.sidefx.com/docs/houdini12.0/hom/），而系统 Python 需要具有 PySide 或 PyQt 支持。菜单加载自 Houdini 15 起，Side Effects 引入了一个动态菜单系统，因此插件现在支持在上下文切换时重建 ShotGrid 菜单。在 Houdini 14 及更早的版本中，ShotGrid 菜单在 Houdini 启动前生成，并且在整个会话期间是静态的。因此，菜单中注册的 Toolkit 命令不会随上下文变化而更新。ShotGrid 工具架发布版本 v0.2.4 为插件引入了一个动态的 ShotGrid 工具架。此工具架将所有注册的应用命令显示为工具按钮。按钮将按照与菜单命令大致相同的顺序显示。使用 enable_sg_shelf 设置可在环境内开启此工具架。如果使用不支持动态菜单的 Houdini 版本（14 或更早的版本），使用工具架时可能还要关闭 ShotGrid 菜单。通过将 enable_sg_menu 设置设定为 false，可以做到这一点。要启用通过工具架切换上下文的功能，您还需要在插件配置中向 tk-multi-workfiles 应用的 sg_entity_types 设置添加实体类型。ShotGrid 工具架的相关设置看起来如下所示：tk-houdini:  apps:    # ... other app definitions    tk-multi-workfiles:       # ... other app settings       sg_entity_types: [Shot, Asset] # allow context switching to Shots or Assets       # ... other app settings  enable_sg_shelf: true  enable_sg_menu: false  # ... other engine settings启用 ShotGrid 工具架后，您需要手动将它添加到 Houdini 内部的一个工具架集。ShotGrid 工具架添加到工具架集后，在两次 Houdini 会话之间将留在该工具架集中，并会随 ShotGrid 上下文的变化动态更新。面板自 v0.2.8 起，插件增加了对嵌入式 Toolkit 面板的支持。面板支持目前需要使用 Houdini 版本 15.0.272 或更新版本，以便面板正确嵌入。在支持的 Houdini 版本中，注册的面板将以窗格形式显示在窗格菜单中。在先前的 Houdini 版本中，注册面板将显示为对话框。SESI 可能会将某些问题修复向后移植到 Houdini 14 的较新内部版本中。当出现这种情况时，我们会使嵌入式面板也支持这些版本。具有 OTL 的应用ShotGrid Houdini 插件让您可轻松加载应用程序随附的 OTL。如果您编写的应用使用 OTL，只需将这些 OTL 放入名为 otls 的文件夹，插件便会自动将它们加载到会话中：然后，您可以通过常用的 Houdini 方法轻松访问您的节点。警告！！请注意，虽然 OTL 用起来可能很方便，但如果您想在场景中创建持久性节点，使用 OTL 往往并不合适。这是因为一旦将 OTL 放入场景，就在该场景与 OTL 代码之间建立了依赖关系。这样，不仅需要在每次加载场景时都加载 ShotGrid Toolkit，还需要小心管理代码，确保代码的任何更新都不会影响场景中使用的旧 OTL。在 OS X 上通过终端进行启动调试在 OS X 上为 tk-houdini 插件开启 debug_logging 功能，并不会将所有调试消息都发送至终端。这是因为默认情况下，tk-multi-launchapp 应用使用 open 命令启动可执行文件。这样并不会从终端生成一个新的子进程，而是使用 OS X 的启动服务在别处创建一个新进程。因此，不会显示日志语句。即使在用户默认桌面的 Houdini 中保存一个 Python Shell，似乎也不会在启动时显示调试语句。启动后，嵌入式 Python Shell 会显示调试日志记录语句，但是启动期间的可用输出存在差异。如果您需要在插件启动期间访问调试日志记录语句，可以进行两处更改。首先，更改测试配置中的 houdini_mac 路径（临时），将其指向 Houdini 应用包内的可执行文件。例如：#houdini_mac: /Applications/Houdini 15.0.272/Houdini Apprentice.apphoudini_mac: /Applications/Houdini  15.0.272/Houdini  Apprentice.app/Contents/MacOS/happrentice接下来，可以在测试配置的 config/hooks 目录中为 tk-multi-launchapp 应用的 app_launch 挂钩创建一份副本，并在 config/env/includes/app_launchers.yml 文件中指向该副本：launch_houdini:  defer_keyword: ''  engine: tk-houdini  extra: {}  hook_app_launch: app_launch    # &amp;lt;----- use a custom app_launch hook  hook_before_app_launch: default  icon: '{target_engine}/icon_256.png'  linux_args: ''  linux_path: '@houdini_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.6.6}  mac_args: ''  mac_path: '@houdini_mac'  menu_name: Launch Houdini  versions: []  windows_args: ''  windows_path: '@houdini_windows'然后，只需修改启动逻辑，直接启动可执行文件即可。例如，您可以针对目录（应用程序包）保留旧的行为，在其他情况下直接执行命令。示例如下：        elif system == &quot;darwin&quot;:            # on the mac, the executable paths are normally pointing            # to the application bundle and not to the binary file            # embedded in the bundle, meaning that we should use the            # built-in mac open command to execute it            if os.path.isdir(app_path):                cmd = &quot;open -n  &quot;%s &quot;&quot; % (app_path)                if app_args:                    cmd += &quot; --args  &quot;%s &quot;&quot; % app_args.replace(&quot; &quot;&quot;, &quot;   &quot;&quot;)            # not a directory, execute directly            else:                cmd = &quot;%s %s&quot; % (app_path, app_args.replace(&quot; &quot;&quot;, &quot;   &quot;&quot;))下次在终端中通过 tank 运行 launch_houdini 时，应该可以得到所有调试输出信息。完成测试后，别忘了还原路径并撤消所做的应用启动更改。祝您调试顺利！",
    "url": "/797202da/",
    "relUrl": "/797202da/"
  },
  "155": {
    "id": "155",
    "title": "Mari 项目管理器",
    "content": "Mari 项目管理器Mari 项目管理器简化了在 Mari 中创建新项目的过程，从而允许艺术家快速选择已发布的几何体以使用 ShotGrid 加载器进行加载。使用此应用创建的项目可感知 ShotGrid，让艺术家不必操心导出选项和文件位置，轻松就能将纹理发布至工作流的其他环节。",
    "url": "/82aaf735/",
    "relUrl": "/82aaf735/"
  },
  "156": {
    "id": "156",
    "title": "Mari",
    "content": "MariShotGrid Mari 插件包含一个用于在 Mari 中集成 ShotGrid Toolkit 应用的标准平台。它采用轻量型设计，操作简单直观，并会向主菜单中添加一个 ShotGrid 菜单。支持的应用程序版本此插件已经过测试，已知可支持以下应用程序版本：4.0 - 6.0v2请注意，此插件也许（甚至非常有可能）支持更新的发行版本，但是尚未正式在这些版本中进行测试。概述视频请参见此处的概述视频。安装和更新将此插件添加到 ShotGrid Pipeline Toolkit如果您想将此插件添加到 Project XYZ 中名为 asset 的环境中，请执行以下命令：&amp;gt; tank Project XYZ install_engine asset tk-mari更新至最新版本如果您已在某个项目中安装了此应用，要获取最新版本，可运行 update 命令。您可以导航到该特定项目随附的 tank 命令，并在该项目中运行它：&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updates或者，也可以运行您的工作室的 tank 命令并指定项目名称，指示该命令要对哪个项目运行更新检查：&amp;gt; tank Project XYZ updates协作和代码演进如果您可以获取 ShotGrid Pipeline Toolkit，意味着也可以获取我们在 GitHub 中存储和管理的所有应用、插件和 ShotGrid 的源代码。欢迎根据实际需要演进和完善这些内容，以它们为基础做进一步的独立开发，修改它们（以及向我们提交 Pull 请求！），或者只是随手玩一玩，简单了解它们的构建方式和 Toolkit 的工作原理。您可以访问此代码库 (https://github.com/shotgunsoftware/tk-mari)。",
    "url": "/301f5e66/",
    "relUrl": "/301f5e66/"
  },
  "157": {
    "id": "157",
    "title": "错误 {% include product %} tk-maya Toolkit 产生异常",
    "content": "错误: ShotGrid tk-maya: Toolkit 产生异常用例可以将 Toolkit 应用设置为在触发运行时接收自定义参数。例如，运行应用时，您可能希望提供某种状态标志，使应用根据状态以不同方式启动。下面是一些已使用这种设置的示例：  tk-shotgun-folders 应用（它基于 Shotgun Web 应用中的选定实体创建文件夹）将传递用户在 Shotgun Web 应用中选择并在其上运行操作的 Shotgun 实体和实体类型：https://github.com/shotgunsoftware/tk-shotgun-folders/blob/v0.1.7/app.py#L86  tk-multi-launchapp（负责启动具有 Shotgun 集成的软件）可以传递 file_to_open 参数，一旦该软件启动，将使用它打开文件： https://github.com/shotgunsoftware/tk-multi-launchapp/blob/v0.11.2/python/tk_multi_launchapp/base_launcher.py#L157 通常，当您通过 ShotGrid Desktop 启动软件时，它不会提供 file_to_open 参数，但是，如果您使用的是集中式配置 (tank maya_2019 /path/to/maya/file.mb)，则可以通过 tank 命令调用该应用。此外，我们的 tk-shotgun-launchpublish 应用会进而启动 tk-multi-launchapp，并提供已发布的文件作为 file_to_open 参数。https://github.com/shotgunsoftware/tk-shotgun-launchpublish/blob/v0.3.2/hooks/shotgun_launch_publish.py#L126-L133对应用进行编程以接受参数如果您要编写自定义应用，只需将在插件中注册的回调方法设置为接受所需的参数。下面是一个简单的应用，它设置为需要两个参数，接受任何其他参数，然后输出它们：from sgtk.platform import Applicationclass AnimalApp(Application):    def init_app(self):        self.engine.register_command(&quot;print_animal&quot;, self.run_method)    def run_method(self, animal, age, *args):        print (&quot;&quot;,animal)        print (&quot;age&quot;,age)        print (&quot;args&quot;, args)从 tank 命令运行现在，如果在 shell 中运行以下 tank 命令： ./tank print_animal cat 7 Tortoiseshell large它会导致输出以下内容：...----------------------------------------------------------------------Command: Print animal----------------------------------------------------------------------libpng warning: iCCP: known incorrect sRGB profile('animal', 'cat')('age', '7')('args', ('Tortoiseshell', 'large'))从脚本运行如果要在 tk-shell 插件上从脚本调用应用，则可以执行以下操作：# This assumes you have a reference to the `tk-shell` engine.engine.execute_command(&quot;print_animal&quot;, [&quot;dog&quot;, &quot;3&quot;, &quot;needs a bath&quot;])&amp;gt;&amp;gt;# ('animal', 'dog')# ('age', '3')# ('args', ('needs a bath',))如果您在 Maya 中，则会执行如下操作：import sgtk# get the engine we are currently running in.engine = sgtk.platform.current_engine()# Run the app.engine.commands['print_animal']['callback'](&quot;unicorn&quot;,4,&quot;it's soooo fluffy!!!!&quot;)&amp;gt;&amp;gt;# ('animal', 'unicorn')# ('age', 4)# ('args', (&quot;it's soooo fluffy!!!!&quot;,))错误消息如果您尝试从 Maya 中的菜单启动应用，则会收到如下错误：// Error: Shotgun tk-maya: An exception was raised from ToolkitTraceback (most recent call last):  File &quot;/Users/philips1/Library/Caches/Shotgun/bundle_cache/app_store/tk-maya/v0.10.1/python/tk_maya/menu_generation.py&quot;, line 234, in _execute_within_exception_trap    self.callback()  File &quot;/Users/philips1/Library/Caches/Shotgun/mysite/p89c1.basic.maya/cfg/install/core/python/tank/platform/engine.py&quot;, line 1082, in callback_wrapper    return callback(*args, **kwargs)TypeError: run_method() takes at least 3 arguments (1 given) //这是因为应用设置为需要参数，而菜单按钮不知道提供它们。如何修复建议编写应用的 run_method，以使用如下关键字参数：    def run_method(self, animal=None, age=None, *args):        print (&quot;&quot;,animal)        print (&quot;age&quot;,age)        print (&quot;args&quot;, args)然后，您可以处理未提供参数时发生的情况，并实现回退行为。在社区中查看完整主题。",
    "url": "/0c5e6ac8/",
    "relUrl": "/0c5e6ac8/"
  },
  "158": {
    "id": "158",
    "title": "Maya",
    "content": "MayaShotGrid Maya 插件包含一个用于在 Maya 中集成 ShotGrid 应用的标准平台。它采用轻量型设计，操作简单直观，并会向 Maya 菜单栏中添加一个 ShotGrid 菜单。支持的应用程序版本此插件已经过测试，已知可支持以下应用程序版本：2020 - 2024 Note: Apple Silicon (M1/M2) native is supported starting with Maya 2024.请注意，此插件也许（甚至非常有可能）支持更新的发行版本，但是尚未正式在这些版本中进行测试。PySideShotGrid Maya 插件包含一个 PySide 安装，必要时会激活此安装。Maya 项目管理ShotGrid Maya 插件在每次启动时，都会将 Maya 项目设置为指向此插件的设置中定义的位置。这意味着，当您打开新文件时，项目也可能会发生变化。我们可以使用模板系统，在配置文件中配置有关基于文件设置 Maya 项目的详细信息。安装和更新将此插件添加到 ShotGrid Pipeline Toolkit如果要将此插件添加到 Project XYZ 和名为 asset 的环境，请执行以下命令：&amp;gt; tank Project XYZ install_engine asset tk-maya更新至最新版本如果您已在某个项目中安装了此应用，要获取最新版本，可运行 update 命令。您可以导航到该特定项目随附的 tank 命令，并在该项目中运行它：&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updates或者，也可以运行您的工作室的 tank 命令并指定项目名称，指示该命令要对哪个项目运行更新检查：&amp;gt; tank Project XYZ updates协作和代码演进如果您可以获取 ShotGrid Pipeline Toolkit，意味着也可以获取我们在 GitHub 中存储和管理的所有应用、插件和框架的源代码。欢迎根据实际需要演进和完善这些内容，以它们为基础做进一步的独立开发，修改它们（以及向我们提交 Pull 请求！），或者只是随手玩一玩，简单了解它们的构建方式和 Toolkit 的工作原理。您可以访问此代码库 (https://github.com/shotgunsoftware/tk-maya)。",
    "url": "/9e62da4a/",
    "relUrl": "/9e62da4a/"
  },
  "159": {
    "id": "159",
    "title": "Motion Builder",
    "content": "Motion BuilderShotGrid Motion Builder 插件包含一个用于在 Motion Builder 中集成 ShotGrid Toolkit 应用的标准平台。它采用轻量型设计，操作简单直观，并会向主菜单中添加一个 ShotGrid 菜单。支持的应用程序版本此插件已经过测试，已知可支持以下应用程序版本：2020 - 2024请注意，此插件也许（甚至非常有可能）支持更新的发行版本，但是尚未正式在这些版本中进行测试。安装和更新将此插件添加到 ShotGrid Pipeline Toolkit如果您想将此插件添加到 Project XYZ 中名为 asset 的环境中，请执行以下命令：&amp;gt; tank Project XYZ install_engine asset tk-motionbuilder更新至最新版本如果您已在某个项目中安装了此应用，要获取最新版本，可运行 update 命令。您可以导航到该特定项目随附的 tank 命令，并在该项目中运行它：&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updates或者，也可以运行您的工作室的 tank 命令并指定项目名称，指示该命令要对哪个项目运行更新检查：&amp;gt; tank Project XYZ updates协作和代码演进如果您可以获取 ShotGrid Pipeline Toolkit，意味着也可以获取我们在 GitHub 中存储和管理的所有应用、插件和框架的源代码。欢迎根据实际需要演进和完善这些内容，以它们为基础做进一步的独立开发，修改它们（以及向我们提交 Pull 请求！），或者只是随手玩一玩，简单了解它们的构建方式和 Toolkit 的工作原理。您可以访问此代码库 (https://github.com/shotgunsoftware/tk-motionbuilder)。",
    "url": "/54009c12/",
    "relUrl": "/54009c12/"
  },
  "160": {
    "id": "160",
    "title": "关于",
    "content": "关于此应用以图形方式显示当前工作区和当前环境中运行的所有应用的细分。您可以在上下文菜单中找到它：重新加载所有应用此应用提供一个方便的按钮，用来重新加载整个环境。当您在开发过程中想要试一下所做的某些代码更改时，此按钮可以派上用场。您不需要重新启动 Maya 或 Nuke，只要点击重新加载按钮即可！除了重新加载功能，此应用还显示当前工作区及当前加载的所有应用的细分。共有三个单独的视图：当前工作区此视图显示当前的镜头或资产，以及当前的任务等。如果双击列表中的任意项，系统将打开该项的 ShotGrid 详细信息页面。正在运行的应用此视图显示当前正在运行的所有应用，以及它们的版本和说明。双击一个应用将启动该应用的文档页。当前环境此视图显示当前加载的环境文件和插件。这些信息对于调试很有用。",
    "url": "/c542e4dd/",
    "relUrl": "/c542e4dd/"
  },
  "161": {
    "id": "161",
    "title": "细分",
    "content": "细分场景细分应用会显示引用内容的列表，并告诉您哪些内容项已过期。您可以从 ShotGrid 菜单访问它。您可以选择一项或多项内容，然后单击更新选定项。这会使这些项使用最新版本的内容。扫描场景细分应用在扫描场景中的引用时，会调用一个特殊的扫描挂钩。此扫描挂钩将返回一个含有文件对应路径的节点列表。对于找到的每个引用，挂钩会返回文件路径，然后 tank 会查看该文件路径，并首先检查是否可将它识别为发布，如果可以识别为发布，则检查是否有更新的版本可用。如果用户单击过期版本显示的更新按钮，应用将调用另一个挂钩来执行实际的更新工作。这意味着，通过自定义这些挂钩，可以相对简单地向细分中添加新的自定义节点。访问 ShotGrid 数据如果您需要在挂钩中访问要进行更新的发布的 ShotGrid 数据，操作起来很简单直接；只需调用 find_publish 即可从应用检索所有传入项的元数据，如下所示：class BreakdownHook(Hook):    def update(self, items):        &quot;&quot;&quot;        Perform replacements given a number of scene items passed from the app.        Once a selection has been performed in the main UI and the user clicks        the update button, this method is called.        The items parameter is a list of dictionaries on the same form as was        generated by the scan_scene hook above. The path key now holds        the that each node should be updated *to* rather than the current path.        &quot;&quot;&quot;        engine = self.parent.engine        # resolve ShotGrid data for all paths passed via the items dictionary        sg_data = tank.util.find_publish(engine.sgtk,                                         [i[&quot;path&quot;] for i in items],                                         fields=[&quot;id&quot;, &quot;code&quot;, &quot;version_number&quot;])        for i in items:            node_name = i[&quot;node&quot;]            node_type = i[&quot;type&quot;]            new_path = i[&quot;path&quot;]            # now that each item is processed, it is easy to access the            # ShotGrid data via a dictionary lookup:            sg_data = sg_data.get(i[&quot;path&quot;])            # once we have all our desired info and metadata, we can go ahead            # and apply the update business logic.            # [-business logic here-]API 访问您可以使用 API 以编程方式访问细分应用。目前有以下方法：显示细分用户界面app_object.show_breakdown_dialog()如果您想显示细分用户界面，请执行 show_breakdown_dialog() 方法。假设应用位于当前运行的环境的 tk-multi-breakdown 部分，我们可以像下面这样操作：&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; e = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; e.apps[&quot;tk-multi-breakdown&quot;].show_breakdown_dialog()运行场景分析items = app_object.analyze_scene()您可以通过执行 analyze_scene() 方法，以编程方式运行场景分析逻辑。这将执行与构建场景内容项列表时细分用户界面所用完全相同的逻辑。该方法将返回一个细分内容项列表。每个内容项由一个词典表示，词典包含若干个键来描述该内容项。方法只会检测到路径与 Toolkit 模板文件中的模板相对应的文件。文件不需要在 ShotGrid 中以发布的形式存在，但是如果如此，此方法将返回它们的基本 ShotGrid 发布元数据。node_name 和 node_type 这两个键用于返回一个以 DCC 为中心的“地址”或表示方式，以便可以在 DCC 内识别路径。例如在 Maya 和 Nuke 中，此方法将返回节点名称和类型。此方法的逻辑在挂钩中执行，并且因 DCC 的不同而异。此方法会尝试连接 ShotGrid，但是进行的调用次数是固定的，不受场景复杂性的影响。下面的示例显示了返回的数据中的一个典型词典：{'fields': {'Sequence': 'aaa',            'Shot': 'aaa_00010',            'Step': 'Comp',            'eye': '%V',            'height': 1556,            'name': 'test',            'output': 'output',            'version': 1,            'width': 2048}, 'template': &amp;lt;Sgtk TemplatePath nuke_shot_render_pub_mono_dpx&amp;gt;, 'node_name': 'Read2', 'node_type': 'Read', 'sg_data': {'code': 'aaa_00010_test_output_v001.%04d.dpx',             'entity': {'id': 1660, 'name': 'aaa_00010', 'type': 'Shot'},             'id': 1424,             'name': 'test',             'published_file_type': {'id': 3,                                     'name': 'Rendered Image',                                     'type': 'PublishedFileType'},             'task': {'id': 4714, 'name': 'Comp', 'type': 'Task'},             'type': 'PublishedFile',             'project': {'id': 234, 'name': 'Climp', 'type': 'Project'},             'version_number': 1}, }实用提示！：如上面所见，每个内容项会返回一个 template 对象和一个 fields 词典来表示路径。如果您想查看内容项的实际原始路径，只需运行 template_obj.apply_fields(fields_dict) 即可。在此方法返回的其中一个内容项词典的上下文中，代码将为breakdown_items = analyze_scene()for item in breakdown_items:   path = item[&quot;template&quot;].apply_fields(item[&quot;fields&quot;])计算内容项的最高版本highest_version = app_object.compute_highest_version(template, fields)要知道内容项的最高版本，请使用 compute_highest_version(template, fields) 方法。template 和 fields 参数表示要分析的路径，该路径通常抓取自 analyze_scene() 方法的输出。使用细分应用时，包含版本号的模板键必须始终命名为 {version}。这将执行磁盘扫描，以确定最高版本。此方法会返回在磁盘上找到的最高版本号。请参见下面的用法示例了解更多详细信息。更新场景的内容项app_object.update_item(node_type, node_name, template, fields)要更新内容项，您可以使用 update_item(node_type, node_name, template, fields) 方法。template 和 fields 参数表示应更新至的路径。node_name 和 node_type 参数用于确定场景中的哪个节点需要修改。通常，这些值抓取自 analyze_scene() 方法的输出。这样做类似于在细分用户界面中运行更新。实际的更新调用将分派给处理 DCC 特定逻辑的挂钩。请参见下面的用法示例了解更多详细信息。细分 API 示例下面是一个示例，说明了如何检索场景细分并更新所有未使用最新版本的内容项。# find the breakdown app instanceimport sgtkengine = sgtk.platform.current_engine()breakdown_app = engine.apps[&quot;tk-multi-breakdown&quot;]# get list of breakdown itemsitems = breakdown_app.analyze_scene()# now loop over all itemsfor item in items:    # get the latest version on disk    latest_version = breakdown_app.compute_highest_version(item[&quot;template&quot;], item[&quot;fields&quot;])    # if our current version is out of date, update it!    current_version = item[&quot;fields&quot;][&quot;version&quot;]    if latest_version &amp;gt; current_version:        # make a fields dictionary representing the latest version        latest_fields = copy.copy(item[&quot;fields&quot;])        latest_fields[&quot;version&quot;] = latest_version        # request that the breakdown updates to the latest version        breakdown_app.update_item(item[&quot;node_type&quot;], item[&quot;node_name&quot;], item[&quot;template&quot;], latest_fields)",
    "url": "/3c0c0ab6/",
    "relUrl": "/3c0c0ab6/"
  },
  "162": {
    "id": "162",
    "title": "演示",
    "content": "演示本演示应用提供 ShotGrid 原生开发平台组件的直观演示，包括 ShotGrid 实用程序框架、Qt 控件框架和 Toolkit 核心。本应用中展示的每项演示均包含一个可用的交互式用户界面，用以说明如何使用该原生平台的一个或多个组件。此外，运行的代码随时可复制并粘贴到您自己的应用中。此应用使用起来非常简单。只需从左侧的列表中选择一项演示，然后在右侧与组件进行交互即可。有些演示很简单，只是显示 Qt 控件框架中的一个控件；有些演示则提供示例，说明通常如何在生产应用中组合使用 ShotGrid 平台的各种组件。随着新的组件加入平台，在时间允许的情况下，我们会相应添加新的演示。如果您知道某种常见的组件使用方式，或者希望看到某项演示，请通过提交工单告知我们。安装要安装此演示应用，请运行以下命令：tank install_app project tk-shell tk-multi-demo安装后，可运行以下命令启动应用：./tank demos",
    "url": "/42395ae7/",
    "relUrl": "/42395ae7/"
  },
  "163": {
    "id": "163",
    "title": "启动器应用",
    "content": "启动器应用此应用提供了一个快捷方式，让您可轻松从 ShotGrid 跳转至任何支持的应用程序。它会根据您的配置选择为 ShotGrid 中的各种实体创建 ShotGrid 动作项。工作方式当您在实体上单击鼠标右键或使用 ShotGrid 动作菜单或配置菜单时，ShotGrid 会根据您的配置选项显示菜单项。例如，下面这张屏幕截图来自一个站点，该站点的配置使用此应用三次，分别实现 Maya、Nuke 和 Photoshop 的菜单。目前支持的应用程序和插件包括：  3DSMax  Hiero  Maya  MotionBuilder  Nuke  Photoshop  Mari  Houdini  Flame启动时使用命令行参数许多应用程序具有可调用的命令行选项，用于选择不同的应用程序版本（例如 Nuke 与 NukeX）或指定其他各种用法。启动器应用针对每个操作系统有一个可进行这种配置的“args”设置。例如，如果您在此设置中加入“–nukex”，启动器会将它添加到命令行启动，并运行 NukeX 而不是常规的 Nuke：示例：启动 NukeXlaunch_nuke:  engine: tk-nuke  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: '--nukex'  linux_path: '@nuke_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.15}  mac_args: '--nukex'  mac_path: '@nuke_mac'  menu_name: Launch Nuke  windows_args: '--nukex'  windows_path: '@nuke_windows'设置环境变量并自动化启动时的行为为了在工作室工作流中正常运行，应用程序通常需要设置某些环境变量和插件路径等。启动器应用可通过“before_app_launch”这个挂钩帮助解决此问题。使用此挂钩，您可以定义一段代码，让它在应用程序每次启动时运行。默认情况下，“before_app_launch”这个挂钩只是一个简单的通道，不执行任何操作，但我们可以按照此文档中的说明覆盖此挂钩。例如，如果您使用 Zync Render，需要同时在 $PYTHONPATH 和 $XBMLANGPATH 中都包含 Zync Maya 插件目录。要让启动器应用设置这些环境变量，请按如下所示为 before_app_launch 挂钩更新几行代码：示例：设置环境变量def execute(self, **kwargs):    &quot;&quot;&quot;    The execute functon of the hook will be called to start the required application            &quot;&quot;&quot;    # Example to show how to set env vars on Maya launch    # Append the desired path to the existing $PYTHONPATH to ensure    # everything upstream still works    os.environ[&quot;PYTHONPATH&quot;] = os.environ[&quot;PYTHONPATH&quot;] + os.pathsep + &quot;~/Library/zync/zync-maya&quot;    # Set $XBMLANGPATH to the desired path, may need to append it as    # with $PYTHONPATH if already defined in your pipeline    os.environ[&quot;XBMLANGPATH&quot;] = &quot;~/Library/zync/zync-maya&quot;您还可以使用“before_app_launch”自动化其他行为，包括 ShotGrid 更新。例如，您可以按如下所示，配置启动器应用在每次启动时（当然前提是从任务进行启动）更新任务状态（在本例中更新为“正在进行”）：示例：自动化任务状态更新def execute(self, **kwargs):    &quot;&quot;&quot;    The execute functon of the hook will be called to start the required application            &quot;&quot;&quot;    # If there is a Task in the context, set its status to 'ip'    if self.parent.context.task:        task_id = self.parent.context.task['id']        data = {            'sg_status_list':'ip'        }        self.parent.shotgun.update(&quot;Task&quot;, task_id, data)您可以想象到，这其中有许多可能性，而启动器应用的目的在于提供工作流所需的灵活性。启动尚无插件的应用程序您还可以使用启动器应用启动尚无 Toolkit 插件的应用程序。在这种情况下，会在磁盘上为执行启动的镜头、任务或资产创建文件夹，然后启动应用程序。但是，应用程序启动后不会运行代码，应用程序内也不会出现 ShotGrid 菜单。这意味着，您可以从 ShotGrid 内启动 Toolkit 尚不支持的应用程序。为此，需要为应用配置要启动的应用程序的路径，但保留插件选项为空字符串。技术细节3DSMax此应用会自动向 3DSMax 命令行添加一个名为 init_tank.ms 的 MaxScript，3DSMax 会在引导过程中运行它。3DSMax 引导时，会发生以下情况：  3DSMax 将在启动时运行 init_tank.ms  init_tank.ms 确保有可用的 Python 解释器并运行 tank_startup.py  使用 ShotGrid Toolkit 上下文 API，从 ShotGrid 传递的实体 ID 将被转换为 Toolkit 上下文。  启动适当的插件（通过 tank.system.start_engine()）并传入该上下文。插件将处理剩下的事情。Maya此应用会向 Maya 注册一个 userSetup.py 自动启动脚本，Maya 会在引导过程中调用它。Maya 引导时，会发生以下情况：  Maya 开始执行 userSetup.py 启动脚本  使用 ShotGrid Toolkit 上下文 API，从 ShotGrid 传递的实体 ID 将被转换为 Toolkit 上下文。  启动适当的插件（通过 tank.system.start_engine()）并传入该上下文。插件将处理剩下的事情。MotionBuilder此应用会向 MotionBuilder 注册一个 init_tank.py 自动启动脚本，MotionBuilder 会在引导过程中调用它。MotionBuilder 引导时，会发生以下情况：  MotionBuilder 开始执行 init_tank.py 启动脚本  使用 ShotGrid Toolkit 上下文 API，从 ShotGrid 传递的实体 ID 将被转换为 Toolkit 上下文。  启动适当的插件（通过 tank.system.start_engine()）并传入该上下文。插件将处理剩下的事情。Nuke此应用会向 Nuke 注册一个 menu.py 自动启动脚本，Nuke 会在引导过程中调用它。Nuke 引导时，会发生以下情况：  Nuke 开始执行 menu.py 启动脚本  使用 ShotGrid Toolkit 上下文 API，从 ShotGrid 传递的实体 ID 将被转换为 Toolkit 上下文。  启动适当的插件（通过 tank.system.start_engine()）并传入该上下文。插件将处理剩下的事情。Photoshop此应用会使用 Adobe Extension Manager 安装或确保已安装 Tank 插件。Photoshop 引导时，会发生以下情况：  Photoshop 将开始执行 Tank 插件  使用 ShotGrid Toolkit 上下文 API，从 ShotGrid 传递的实体 ID 将被转换为 Toolkit 上下文。  启动适当的插件（通过 tank.system.start_engine()）并传入该上下文。插件将处理剩下的事情。额外配置如果您想使用此应用启动 Photoshop，需要在 extra 部分提供四个配置值。下面是需要根据您的系统和安装位置做出调整的配置和合理的默认值：mac_python_path: &quot;/usr/bin/python&quot;windows_python_path: &quot;C:  Python27  python.exe&quot;mac_extension_manager_path: &quot;/Applications/Adobe Extension Manager CS6/Adobe Extension Manager CS6.app&quot;windows_extension_manager_path: &quot;C:  Program Files (x86)  Adobe  Adobe Extension Manager CS6  XManCommand.exe&quot;",
    "url": "/1b9c259a/",
    "relUrl": "/1b9c259a/"
  },
  "164": {
    "id": "164",
    "title": "加载器",
    "content": "加载器本文档介绍仅当控制 Toolkit 配置时可用的功能。有关详细信息，请参见 ShotGrid 集成用户手册。配置加载器具有高度的可配置性，您可以通过多种不同的方式对其进行设置。加载器有两个主要的配置区域：  设置左侧树视图中显示哪些选项卡和内容。  控制针对不同的发布显示哪些动作，以及这些动作实际执行什么操作。下面各部分将简要介绍如何配置加载器。有关配置方面的技术细节，请参见文档后面的单独章节。树视图树视图具有高度的可配置性，您可以使用标准 ShotGrid 过滤语法控制各个选项卡的内容。每个选项卡包含一个 ShotGrid API 查询，通过分组构成一个层次结构。您可以添加任意过滤器来控制要显示哪些项，并可使用特殊关键字 {context.entity}、{context.project}、{context.project.id}、{context.step}、{context.task} 和 {context.user} 基于当前上下文确定查询范围。每个关键字将被替换为相关的上下文信息，可以是 None（当上下文的对应部分未填充数据时）或包含键 ID、类型和名称的标准 ShotGrid 链接词典。默认情况下，加载器将显示属于当前项目的资产和镜头。通过重新配置，可以轻松对此进行扩展，例如显示来自其他项目（或特定资产库项目）的内容项。您还可以使用过滤器仅显示具有某个审批状态的内容项，或者按状态或其他 ShotGrid 字段对内容项进行分组。下面是一些配置设置示例，说明了树视图选项卡的设置方式：# An asset library tab which shows assets from a specific# ShotGrid projectcaption: Asset Libraryentity_type: Assethierarchy: [sg_asset_type, code]filters:- [project, is, {type: Project, id: 123}]# Approved shots from the current projectcaption: Shotshierarchy: [project, sg_sequence, code]entity_type: Shotfilters:- [project, is, '{context.project}']- [sg_status_list, is, fin]# All assets for which the current user has tasks assignedcaption: Assetsentity_type: Taskhierarchy: [entity.Asset.sg_asset_type, entity, content]filters:- [entity, is_not, null]- [entity, type_is, Asset]- [task_assignees, is, '{context.user}']- [project, is, '{context.project}']过滤发布我们可以对加载器从 ShotGrid 加载发布数据时所执行的发布查询应用 ShotGrid 过滤器。此功能由 publish_filters 参数控制，可用于隐藏尚未获得批准的发布或其关联的审看版本尚未得到批准的发布。求助，不显示任何动作！加载器针对每个插件随附了一些不同的动作。例如，对于 Nuke，有两个动作：“导入脚本”和“创建读取节点”。动作在挂钩中定义，这意味着您可以修改它们的行为，或根据需要添加附加动作。然后，在加载器的配置中，可以将这些动作绑定至您拥有的某些发布类型。将一个动作绑定至一个发布类型，也就意味着该动作将显示在加载器内该类型的所有项的动作菜单上。例如，默认情况下，Nuke 的映射关系设置如下：action_mappings:  Nuke Script: [script_import]  Rendered Image: [read_node]如果您发现不显示任何动作菜单，可能是因为您为当前使用的发布类型选择了不同的名称。如果是这样，请进入配置并添加这些类型，以便在加载器内显示它们。管理动作加载器支持的每个应用程序都有一个对应的动作挂钩，用于执行该应用程序支持的动作。例如，在 Maya 这样的应用程序中，默认挂钩将执行 reference、import 和 texture_node 动作，每个动作执行特定的 Maya 命令，将内容导入当前的 Maya 场景中。与所有挂钩一样，我们完全可以改写和更改这些设置，还可根据内置挂钩创建派生挂钩，这样不必复制大量代码就能轻松向内置挂钩中添加其他动作。在动作挂钩中定义了动作列表后，您便可以将这些动作绑定至发布文件类型。例如，如果您的工作流中有一个名为“Maya 场景”(Maya Scene)的发布文件类型，可以在配置中将此类型绑定至挂钩中定义的 reference 和 import 动作。这样，Toolkit 会向显示的每个 Maya 场景发布中添加一个引用动作和一个导入动作。像这样将发布类型与实际挂钩分离开来，将更易于重新配置加载器，使其适用于默认配置随附的类型以外的发布类型设置。加载器使用 Toolkit 第二代挂钩界面，具有更强的灵活性。此挂钩的格式采用经过改进的语法。您可以在加载器安装的默认配置设置中查看此语法，类似下面所示：actions_hook: '{self}/tk-maya_actions.py'{self} 关键字指示 Toolkit 在应用的 hooks 文件夹中查找挂钩。如果您要使用自己的执行改写此挂钩，请将值更改为 {config}/loader/my_hook.py。这将指示 Toolkit 使用您的配置文件夹中称为 hooks/loader/my_hook.py 的挂钩。加载器使用的第二代挂钩的另一个功能是，挂钩不再需要具有 execute() 方法。相反，挂钩更像一个普通类，并可包含一套适合组合在一起的方法。在使用加载器时，您的动作挂钩需要执行以下两个方法：def generate_actions(self, sg_publish_data, actions, ui_area)def execute_multiple_actions(self, actions)有关详细信息，请参见应用随附的挂钩文件。挂钩还会利用继承性，这意味着您不需要改写挂钩中的所有内容，而是可以更轻松地用各种方式对默认挂钩进行扩展或补充，使挂钩更易于管理。请注意，在 v1.12.0 之前的版本中，应用程序会调用 execute_action 挂钩来执行动作。而较新的版本会调用 execute_multiple_actions 挂钩。为了向后兼容现有挂钩，execute_multiple_actions 挂钩实际为提供的每个动作调用 execute_action。如果应用程序在升级到 v1.12.0 或更高版本后提示未定义 execute_multiple_actions 挂钩，请确保环境中的 actions_hook 设置正确地从内置挂钩 {self}/{engine_name}_actions.py 继承设置。要了解有关如何从内置挂钩派生自定义挂钩的详细信息，请参见 Toolkit 参考文档。单击此处详细了解第二代挂钩格式。通过在挂钩中运用继承性，您可以像下面这样向默认挂钩中添加附加动作：import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_publish_data, actions, ui_area):        &quot;&quot;&quot;        Returns a list of action instances for a particular publish.        This method is called each time a user clicks a publish somewhere in the UI.        The data returned from this hook will be used to populate the actions menu for a publish.        The mapping between Publish types and actions are kept in a different place        (in the configuration) so at the point when this hook is called, the loader app        has already established *which* actions are appropriate for this object.        The hook should return at least one action for each item passed in via the        actions parameter.        This method needs to return detailed data for those actions, in the form of a list        of dictionaries, each with name, params, caption and description keys.        Because you are operating on a particular publish, you may tailor the output        (caption, tooltip etc) to contain custom information suitable for this publish.        The ui_area parameter is a string and indicates where the publish is to be shown.        - If it will be shown in the main browsing area, &quot;main&quot; is passed.        - If it will be shown in the details area, &quot;details&quot; is passed.        - If it will be shown in the history area, &quot;history&quot; is passed.        Please note that it is perfectly possible to create more than one action &quot;instance&quot; for        an action! You can for example do scene introspection - if the action passed in        is &quot;character_attachment&quot; you may for example scan the scene, figure out all the nodes        where this object can be attached and return a list of action instances:        &quot;attach to left hand&quot;, &quot;attach to right hand&quot; etc. In this case, when more than        one object is returned for an action, use the params key to pass additional        data into the run_action hook.        :param sg_publish_data: ShotGrid data dictionary with all the standard publish fields.        :param actions: List of action strings which have been defined in the app configuration.        :param ui_area: String denoting the UI Area (see above).        :returns List of dictionaries, each with keys name, params, caption and description        &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_publish_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_publish_data):        &quot;&quot;&quot;        Execute a given action. The data sent to this be method will        represent one of the actions enumerated by the generate_actions method.        :param name: Action name string representing one of the items returned by generate_actions.        :param params: Params data, as specified by generate_actions.        :param sg_publish_data: ShotGrid data dictionary with all the standard publish fields.        :returns: No return value expected.        &quot;&quot;&quot;        # resolve local path to publish via central method        path = self.get_publish_path(sg_publish_data)        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_publish_data)然后，我们可以在配置中将这个新动作绑定到一组发布类型：action_mappings:  Maya Scene: [import, reference, my_new_action]  Maya Rig: [reference, my_new_action]  Rendered Image: [texture_node]按上面所示从挂钩派生的自定义挂钩代码只需要包含实际添加的业务逻辑，因此维护和更新起来更加简单。参考在应用实例上可以使用以下方法。open_publish()显示“打开文件”风格的加载器版本，让用户可以选择发布。然后将返回选定的发布。在此模式下运行时，不允许使用为应用配置的普通动作。app.open_publish( str title, str action, list publish_types )参数和返回值  str title - 打开发布对话框中显示的标题。  str action - 用于“打开”(Open)按钮的动作名称。  list publish_types - 一个发布类型列表，用于过滤可用的发布列表。如果此值为空/None，将显示所有发布。  返回值：用户选择的 ShotGrid 实体词典的列表。示例&amp;gt;&amp;gt;&amp;gt; engine = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; loader_app = engine.apps.get[&quot;tk-multi-loader2&quot;]&amp;gt;&amp;gt;&amp;gt; selected = loader_app.open_publish(&quot;Select Geometry Cache&quot;, &quot;Select&quot;, [&quot;Alembic Cache&quot;])&amp;gt;&amp;gt;&amp;gt; print selected",
    "url": "/a4c0a4f1/",
    "relUrl": "/a4c0a4f1/"
  },
  "165": {
    "id": "165",
    "title": "发布",
    "content": "发布概述通过发布应用，美工人员可以发布他们的作品，以便其可供下游的美工人员使用。它支持在艺术家的内容创建软件中以传统方式发布工作流，以及在磁盘上单独发布任何文件。在内容创建软件中操作并使用基本 ShotGrid 集成时，该应用将自动发现并显示项目以供艺术家发布。对于较复杂的生产需求，工作室可以编写自定义发布插件来推动美工人员工作流。文档发布器的完整文档位于此处！",
    "url": "/bc718491/",
    "relUrl": "/bc718491/"
  },
  "166": {
    "id": "166",
    "title": "Python 控制台",
    "content": "Python 控制台这是一个用在 DCC 中的 Python 控制台面板，它为不支持与 Python 解释器交互或者支持非常有限的 DCC 提供访问 Python 解释器的途径。面板安装后，该控制台将在 DCC 中注册为面板，并显示在 ShotGrid 菜单中。在支持嵌入式 Toolkit 面板的应用（Maya、Nuke 和 Houdini）中，该控制台将显示在一个停靠的面板中。 当使用这些 DCC 的早期版本时，或在不支持面板的 DCC 中，该控制台只显示为一个常规的 Toolkit 对话框。选项卡Python 控制台会显示一个或多个选项卡，每个选项卡包含一个编辑器和一个输出窗口。单击右下角的 + 按钮可创建新选项卡。选项卡名称旁边有一个 x 按钮，单击此按钮可删除选项卡。双击选项卡本身将提示您为选项卡输入新名称。通过拖放，可重新排列选项卡。关闭 DCC 时，会保存这些选项卡的状态；下次启动 DCC 时，将恢复这些选项卡的状态。编辑器控制台有一个输入区域用来编辑 Python。该编辑器包含行号，会高亮显示光标当前所在行，并支持一些基本语法高亮显示。控制台会尝试使用 DCC 的配色，让编辑器有协调统一的观感。支持缩进和取消缩进代码块。选择一行或多行并按 tab 以缩进四个空格，或按 shift + tab 取消缩进四个空格。它尝试将四个空格作为一个缩进量，因此将缩进/取消缩进距整个代码块最近的四个空格。此外，还支持备注和取消备注代码块。选择一行或多行并按 cmd + /（对于 Mac）或按 ctrl + /（对于 Windows 和 Linux）。如果任何选定行在开头处都没有 #，则会向所有选定行添加一个。如果所有行都具有 #，则会将其移除。输出输出区域显示 Python 语句的执行结果。源 Python 命令回显功能默认已开启，并在输出中通过前缀 &amp;gt;&amp;gt;&amp;gt; 加以区分。每次执行还带有一个时间戳标记。界面上提供了一个开关用来关闭回显功能。语法和运行时错误以红色显示，并提供完整的堆栈跟踪，以方便调试。按钮输出  清除 - 清除输出浏览器的内容。  回显 - 在输出浏览器中开启/关闭回显执行命令的功能。编辑器  执行 - 执行编辑器的内容  保存 - 将编辑器的当前内容保存到文件。  打开 - 在编辑器中打开文件。  清除 - 清除编辑器的内容。  行号 - 显示/隐藏当前选项卡的行号全局参数控制台中预先定义了一些 ShotGrid/Toolkit 全局参数，这与 ShotGrid Shell 插件中提供的参数类似。  Tk API 句柄通过 tk 变量提供  ShotGrid API 句柄通过 shotgun 变量提供  当前上下文存储在 context 变量中  Shell 插件可通过 engine 变量访问外部源应用随附一个挂钩，我们可以执行它来从外部位置加载 Python 源。这个挂钩称为 external_sources_hook，它需要执行一个称为 get_external_source_actions 的方法。这个方法应返回一个 QActions 列表，当被触发时，会向控制台添加新的选项卡（包含内容）。 应用随附了一个示例执行，该执行从 GitHub 为一系列预定义用户加载 Gist。挂钩返回的动作将显示在按住“打开”(Open)按钮时所显示的弹出菜单中。热键  使用 Ctrl + Enter 执行选定项  使用 Ctrl + T 创建新选项卡  使用 Ctrl + Shift + [ 或 Ctrl + Shift + ] 在选项卡之间导航  使用 Ctrl + Wheel 调整输入/输出的字体大小注意：这些热键并非适用于所有 DCC。其他说明  在某些早期版本的 DCC 中，Python 控制台如果在关闭会话时处于打开状态，可能会导致崩溃。我们认为这可能是某些早期版本的 PySide 的一个错误。较新版本的 DCC 捆绑了更新版本的 PySide，退出时不会发生崩溃。如果您在使用最新 DCC 版本时遇到此问题，请提交工单，以便我们可以进一步调查。",
    "url": "/770a748a/",
    "relUrl": "/770a748a/"
  },
  "167": {
    "id": "167",
    "title": "审核提交",
    "content": "审核提交如何使用此应用？作为 API此应用提供了一种模式以从多发布应用等其他应用内进行调用。此模式基于图像序列创建 QuickTime 影片文件，然后将它们以版本形式提交至 ShotGrid，以方便审核。生成的 QuickTime 影片文件将具有场记板信息和场景信息覆层。字体、徽标位置、影片压缩选项和场景信息覆层/场记板信息目前在默认挂钩中采取硬编码方式编写，因此建议您重新执行挂钩函数以调整行为。下面是场记板信息和场景信息覆层当前的默认格式：如果您想在自己的应用或挂钩中使用此应用，下面快速介绍了一种简单的方法。  从当前插件中获取 tk-multi-reviewsubmission 应用。我们可以在一个挂钩内通过调用 self.parent.engine.apps.get('tk-multi-reviewsubmission') 来做到这一点。  如果应用可用，调用 render_and_submit_version() 方法。下面的示例显示了此应用在您的挂钩代码中的样子：review_submission_app = self.parent.engine.apps.get(&quot;tk-multi-reviewsubmission&quot;)if review_submission_app:    review_submission_app.render_and_submit_version(        template,        fields,        first_frame,        last_frame,        sg_publishes,        sg_task,        comment,        thumbnail_path,        progress_cb,        color_space    )您需要传递给 render_and_submit_version 的参数如下所示：  template：一个模板，用于定义要发布的文件的所在位置  fields：用来填写模板的字段  first_frame：要处理的图像序列的第一帧  last_frame：要处理的图像序列的最后一帧  sg_publishes：要与版本链接的 ShotGrid 已发布文件对象的列表。  sg_task：要与版本链接的 ShotGrid 任务链接词典。  comment：要添加到版本说明中的文字。  thumbnail_path：影片未上传至 ShotGrid 时为版本使用的缩略图的路径（在配置中设置）。  progress_cb：一个用于报告进度的回调。  此值的格式应为：callback(percent, message)  color_space：输入帧所在的颜色空间。  在 Nuke 中，这是写入节点的颜色空间按钮的其中一个枚举值。作为菜单项此模式向 DCC 内的 ShotGrid 菜单添加菜单项。此模式创建当前视口的快照，并将其作为版本草稿发送到 ShotGrid Create。然后，用户可以通过添加标注、文字或比较注释，在 ShotGrid Create 内扩展审核提交。要将此功能添加到上下文，您需要：  设置 display_name 字段，使其显示在菜单项中。  将 render_media_hook 字段设置为挂钩，告知如何在 DCC 中渲染媒体（tk-photoshopcc 和 tk-maya 具有默认执行）  将 submitter_hook 字段设置为 {self}/submitter_create.py如下所示：tk-multi-reviewsubmission:  display_name: Send for review  render_media_hook: '{self}/render_media.py:{self}/{engine_name}/render_media.py'  submitter_hook: '{self}/submitter_create.py'  location:    type: app_store    name: tk-multi-reviewsubmission    version: v1.0.1",
    "url": "/4badd856/",
    "relUrl": "/4badd856/"
  },
  "168": {
    "id": "168",
    "title": "审片室",
    "content": "审片室这是一个将您当前的 Maya 会话与审片室建立连接的小应用。它会向 ShotGrid 菜单添加一个名为“Jump to Screening Room”的菜单项。单击此按钮将启动审片室，并将它指向当前的 ShotGrid Toolkit 上下文 - 例如镜头、资产或任务。然后，您可以使用审片室浏览所有提交的内容。",
    "url": "/f3e452a2/",
    "relUrl": "/f3e452a2/"
  },
  "169": {
    "id": "169",
    "title": "设置帧范围",
    "content": "设置帧范围此应用可帮助您管理当前打开的场景中的帧范围。您可以从 ShotGrid 菜单中单击“与 ShotGrid 同步帧范围”(Sync Frame Range with ShotGrid)菜单选项访问它。当您单击它时，ShotGrid Toolkit 会检查与当前工作区关联的 ShotGrid 实体（通常是镜头），并查找包含镜头入点帧和镜头出点帧信息的镜头入点和镜头出点字段。这些信息通常与镜头结合使用，在这种情况下，应用会使用 ShotGrid 默认配置中定义的标准镜头入点和镜头出点字段。但是，我们完全可以配置应用，让它从其他字段提取帧范围。当您运行此应用时，它会使用这些入点和出点信息更新当前场景，最后显示一条摘要消息：多个 ShotGrid 字段同步选项您可以通过设置 menu_name 属性在 ShotGrid 菜单中定义此应用的多个实例。这样，您可以定义多个菜单动作，以便同步不同的 ShotGrid 字段。要执行此操作，请为每个实例设置不同的应用实例名称 menu_name 以及输入帧和输出帧字段：tk-multi-setframerange_cuts:  menu_name: Sync frame range using cut fields  sg_in_frame_field: sg_cut_in  sg_out_frame_field: sg_cut_out  location: &quot;@apps.tk-multi-setframerange.location&quot;tk-multi-setframerange_handles:  menu_name: Sync frame range using handle fields  sg_in_frame_field: sg_handle_in  sg_out_frame_field: sg_handle_out  location: &quot;@apps.tk-multi-setframerange.location&quot;这些内容应该在 ShotGrid 菜单中显示为单独的选项：注意：这是 v0.4.0 版应用的新功能。操作挂钩在帧操作挂钩中处理用于获取当前场景帧范围或设置帧范围的软件特定逻辑。如果想要添加对新插件的支持或更改行为的实现方式，可以通过设置 hook_frame_operation 应用属性并实施自己的获取和设置逻辑来接管帧操作挂钩。注意：这是 v0.4.0 版应用的新功能。",
    "url": "/8ac43263/",
    "relUrl": "/8ac43263/"
  },
  "170": {
    "id": "170",
    "title": "ShotGrid 面板",
    "content": "ShotGrid 面板本文档介绍仅当控制 Toolkit 配置时可用的功能。有关详细信息，请参见 ShotGrid 集成用户手册。配置 ShotGrid 面板ShotGrid 面板中有两个主要区域可进行大量配置：一个是用户界面文字的外观，另一个是要与数据关联的动作。以下部分概述如何控制这两个系统的配置。配置显示的内容详细信息区域和列表中的值都可以通过 ShotGrid_fields 挂钩进行配置。您可以为此挂钩创建子类，并更改执行，以便显示您需要的值：模板系统此挂钩支持简单的模板语言，可提供出色的灵活性。它还支持 Qt 所支持的 HTML 子集，因此您可以控制显示的值的颜色、字体大小、粗细等。模板语言用法如下：      ShotGrid 的值括在 {brackets} 中，例如 &amp;lt;b&amp;gt;Description:&amp;lt;/b&amp;gt; {description}。此模板呈现时，{description} 部分将替换为 description 字段的值。        如果您想为值添加一个仅当值不为空时才显示的可选前缀或后缀，可使用 {[Prefix]sg_field[suffix]} 语法。对于模板 {[Start: ]start_date} {[End: ]end_date}，如果同时填充了两个值，将显示 Start: 12 July 2009 End: 14 July 2012，如果未设置结束日期，则显示 Start: 12 July 2009。        您可以定义回退机制，在某些值未设置的情况下进行回退。对于 ShotGrid 版本而言，artist 字段优先于 created_by 字段，这是为了支持由制片代表艺术家提交版本的工作流。在这种情况下，版本将由制作人员创建，但 artist 字段会设置为美工人员。不过，情况并非总是如此。有时，在由美工人员自己提交工作的工作流中，artist 字段会留空。因此，在显示版本时，能够首先检查 artist 字段是一项有用的功能，如果发现此字段未设置，则回退到 created_by 字段。我们使用 {field1|field2} 语法实现这个机制，例如：Created By: {artist|created_by}。您可以将此语法与可选字段结合使用，例如 {[Created By: ]artist|created_by}。  此挂钩包含以下方法：控制列表中显示的列表项get_list_item_definition() 方法接受 ShotGrid 实体类型，会返回一个词典，该词典控制各种列表中列表项的外观。它返回的词典具有 top_left、top_right 和 body 键，例如：{ &quot;top_left&quot;: &quot;&amp;lt;big&amp;gt;{code}&amp;lt;/big&amp;gt;&quot;, &quot;top_right&quot;: &quot;{updated_at}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}控制顶部详细信息区域get_main_view_definition() 方法接受 ShotGrid 实体类型，会返回一个具有 title 和 body 键的词典。这些值控制详细信息区域中对象的外观，例如：{ &quot;title&quot;: &quot;{type} {code}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}控制“信息”(Info)选项卡中显示的字段get_all_fields() 方法返回给定实体在“信息”(Info)选项卡上呈现时要显示的字段列表。配置动作动作是对一段 ShotGrid 数据执行操作的代码片段。例如：  一个为给定 ShotGrid 版本启动 RV 的动作  一个让用户可指派自己执行给定任务的动作  一个将 ShotGrid 发布加载到 Maya 中作为 Maya 参考的动作。动作的实际负载在“动作挂钩”中定义。**定义动作逻辑后，您可以在应用配置中将该动作映射到 ShotGrid 对象。这些动作的映射关系可能类似如下：action_mappings:  PublishedFile:  - actions: [reference, import]    filters: {published_file_type: Maya Scene}  - actions: [texture_node]    filters: {published_file_type: Rendered Image}  Task:  - actions: [assign_task]    filters: {}  Version:  - actions: [play_in_rv]    filters: {}在上面的示例中，我们使用了 reference、import、texture_node、assign_task 和 play_in_rv 动作。然后，我们将这些动作映射到各种 ShotGrid 对象和条件。例如，我们让所有 Maya 场景类型的发布都显示 import 动作。将对象加载到面板中时，会读入并分析上面的动作配置。接下来确定当前对象适合的动作列表，然后执行 generate_actions() 挂钩方法。给定实体的 ShotGrid 数据将在此时传递给挂钩，这样挂钩代码便可判断是否可以为这个特定的 ShotGrid 对象运行该动作。这种方法让每个挂钩可在显示前运行检查。例如，play_in_rv 挂钩可能只有在本地有可用媒体时才有意义 - 配置中设置的动作映射会告诉面板为给定 ShotGrid 实体启用哪些动作，但是这些动作可能不会全部显示，因为 generate_actions() 方法可能会判定某些动作不适合这个给定对象。generate_actions() 方法返回的动作将显示在动作菜单上，当用户单击该菜单时，会调用 execute_action() 挂钩方法运行动作。对于面板支持的每个应用程序，都有一个动作挂钩来执行合适的动作。例如，在 Maya 这样的应用程序中，默认挂钩将执行 reference、import 和 texture_node 动作，每个动作执行特定的 Maya 命令，将发布导入当前的 Maya 场景中。与所有挂钩一样，我们完全可以改写和更改这些设置，还可根据内置挂钩创建派生挂钩，这样不必复制大量代码就能轻松向内置挂钩中添加其他动作。面板使用 Toolkit 第二代挂钩界面，具有更强的灵活性。此挂钩的格式采用经过改进的语法。您可以在默认配置设置中查看，语法类似如下：actions_hook: '{self}/tk-maya_actions.py'{self} 关键字指示 Toolkit 在应用的 hooks 文件夹中查找挂钩。如果您要使用自己的执行改写此挂钩，请将值更改为 {config}/panel/maya_actions.py。这将指示 Toolkit 使用您的配置文件夹中称为 hooks/panel/maya_actions.py 的挂钩。有关详细信息，请参见应用随附的挂钩文件。挂钩还会利用继承性，这意味着您不需要改写挂钩中的所有内容，而是可以更轻松地用各种方式对默认挂钩进行扩展或补充，使挂钩更易于管理。LINKBOX_DOC:5#The%20hook%20data%20type：单击此处详细了解第二代挂钩格式。通过在挂钩中运用继承性，您可以像下面这样向默认挂钩中添加附加动作：import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_data, actions, ui_area):        &quot;&quot;&quot;        Returns a list of action instances for a particular object.        The data returned from this hook will be used to populate the        actions menu.        The mapping between ShotGrid objects and actions are kept in a different place        (in the configuration) so at the point when this hook is called, the app        has already established *which* actions are appropriate for this object.        This method needs to return detailed data for those actions, in the form of a list        of dictionaries, each with name, params, caption and description keys.        Because you are operating on a particular object, you may tailor the output        (caption, tooltip etc) to contain custom information suitable for this publish.        The ui_area parameter is a string and indicates where the publish is to be shown.        - If it will be shown in the main browsing area, &quot;main&quot; is passed.        - If it will be shown in the details area, &quot;details&quot; is passed.        :param sg_data: ShotGrid data dictionary with all the standard publish fields.        :param actions: List of action strings which have been defined in the app configuration.        :param ui_area: String denoting the UI Area (see above).        :returns List of dictionaries, each with keys name, params, caption, group and description        &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;group&quot;: &quot;Pipeline Utils&quot;,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_data):        &quot;&quot;&quot;        Execute a given action. The data sent to this be method will        represent one of the actions enumerated by the generate_actions method.        :param name: Action name string representing one of the items returned by generate_actions.        :param params: Params data, as specified by generate_actions.        :param sg_data: ShotGrid data dictionary with all the standard publish fields.        :returns: No return value expected.        &quot;&quot;&quot;        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_data)然后，我们可以在配置中将这个新动作绑定到一组发布类型：action_mappings:  PublishedFile:  - actions: [reference, import, my_new_action]    filters: {published_file_type: Maya Scene}  Version:  - actions: [play_in_rv]    filters: {}按上面所示从挂钩派生的自定义挂钩代码只需要包含实际添加的业务逻辑，因此维护和更新起来更加简单。",
    "url": "/c0b0ce05/",
    "relUrl": "/c0b0ce05/"
  },
  "171": {
    "id": "171",
    "title": "快照",
    "content": "快照ShotGrid 快照是快速增量备份，让您可以对您工作中的增加部分进行版本控制和管理，而不会与其他人共享。可创建快照、添加说明和缩略图，并创建一个时间点，您可以在以后随时回到该时间点并进行恢复。如果您要进行重大更改并要确保具有先前版本的场景的备份，这很有用。",
    "url": "/233f8961/",
    "relUrl": "/233f8961/"
  },
  "172": {
    "id": "172",
    "title": "Workfiles",
    "content": "Workfiles“File Open”对话框在工作区中导航主对话框分为两个部分。左侧是一系列选项卡。第一个选项卡名为“我的任务”(My Tasks)，显示分配给当前用户的所有任务。这个选项卡非常像 ShotGrid 网站上的“我的任务”(My Tasks)页面。另外，用户也可以使用实体选项卡浏览 ShotGrid 实体。默认情况下，工作文件应用程序让用户可通过查看相应的选项卡，浏览与镜头或资产关联的任何任务。整套选项卡全部可通过环境文件中的 entities 设置进行配置。您可以通过在应用设置中设置 show_file_open: true/false 来禁用/启用此对话框。查找文件在右侧，您将看到与左侧选择的内容关联的工作文件和发布。使用“所有”(All)、“工作”(Working)和“发布”(Publishes)选项卡，可以一起或单独查看工作文件和发布。访问先前版本有两种方式可以访问先前版本。首先，用户可单击浏览器顶部的“所有版本”(All Versions)方框，这将展开版本并在浏览器中单独列出所有版本。另一个方法是在文件上单击鼠标右键，这样可以访问前 10 个版本。用户沙盒如果您的工作流配置使用了用户沙盒，默认情况下将只会看到当前用户的文件。如果用户想查看其他用户沙盒中的文件，可以使用顶部的按钮选取要显示哪个沙盒中的文件。缩小结果您可以通过键入文字来缩小任何视图中的结果。搜索将匹配任意项的名称。“File Save”对话框默认情况下，“File Save”对话框让用户可在当前上下文中保存文件。应用程序将提示用户输入场景名称、版本号以及可选的文件扩展名（如果有的话），此时“保存”(Save)按钮将灰显。仅当应用程序确认了场景名称的下一个可用版本号时，右下角的“保存”(Save)按钮才会启用。您可以通过在应用设置中设置 show_file_save: true/false 来禁用/启用此对话框。在不同的上下文中保存文件要在不同的上下文中保存文件，用户可单击对话框左上角的展开按钮，这将展开“File Save”对话框，让用户选择另一个要保存文件的上下文。添加文件扩展名下拉列表使用新的“File Save”对话框，可以选取保存文件的扩展名。要启用此功能，您需要调整工作流配置的 templates.yml 文件。首先，需要在 templates.yml 内的令牌列表中定义一个令牌。maya_extension:    type: str    choices:        ma: Maya Ascii (.ma)        mb: Maya Binary (.mb)    default: ma    alias: extensionmaya_extension 是令牌的名称。choices 是下拉列表中将会显示的文件类型的词典。键（ma 和 mb）是此模板令牌可以具有的值。值（Maya Ascii (.ma) 和 Maya Binary (.mb)） 是可供 Toolkit 应用程序使用的用户界面友好的说明。alias 是工作文件应用程序需要的提示。它将告诉应用程序此令牌是一个扩展名，应显示在下拉列表控件中。然后，可以将此令牌添加到任何 Maya 特定的模板中。maya_shot_work:    definition: '@shot_root/work/maya/{name}.v{version}.{maya_extension}'    root_name: 'primary'“Change Context”对话框“Change Context”对话框与打开的对话框类似，只是它没有用于在右侧浏览文件的功能。您可以选择任务或实体，然后通过按“Change Context”按钮更改当前插件上下文。您可以通过在应用设置中设置 show_change_context: true/false 来禁用/启用此对话框。工序过滤检索任务时，如果 step 包含在层次结构中，则可以通过工作流工序过滤减少从 ShotGrid 检索的数据量：将仅检索链接到选定工序列表的任务。选项卡中显示的工序列表由 step_filter_on 设置来控制。如果未设置此项，则将显示现有的所有工作流工序。以下示例定义两个选项卡，分别显示资产的任务和镜头的任务：  - caption: Assets Tasks    entity_type: Task    step_filter_on: Asset    filters:    - [entity, type_is, Asset]    hierarchy: [entity.Asset.sg_asset_type, entity, step, content]  - caption: Shots Tasks    entity_type: Task    step_filter_on: Shot    filters:    - [entity, type_is, Shot]    hierarchy: [entity.Shot.sg_sequence, entity, step, content]延迟查询为了获得更好的性能，构建实体树可以分为两个工序查询：  第一个查询用于从 ShotGrid 检索记录并填充树的顶部。  第二个查询用于在用户展开树时检索子项。在使用以下设置的情况下，将在启动应用时从 ShotGrid 检索资产和镜头。然后，在树视图中选择或展开特定资产或镜头时，将仅检索链接到此资产或镜头的任务。  entities:  - caption: Assets    entity_type: Asset    hierarchy: [sg_asset_type, code]    filters:    sub_hierarchy:      entity_type: Task      filters:      link_field: entity      hierarchy: [step]  - caption: Shots    entity_type: Shot    filters:    hierarchy: [sg_sequence, code]    sub_hierarchy:      entity_type: Task      filters:      link_field: entity      hierarchy: [step]",
    "url": "/9a736ee3/",
    "relUrl": "/9a736ee3/"
  },
  "173": {
    "id": "173",
    "title": "Nuke Quickreview",
    "content": "Nuke Quickreview使用 Quickreview 应用可以轻松地提交 Nuke 渲染以在 ShotGrid 中进行审核。每次通过 Quickreview 提交时都会在 ShotGrid 中创建一个版本。它显示为 Nuke 中的一个节点，位于 ShotGrid 节点菜单中。只需创建一个新节点，将其附加到您的 Nuke 网络，双击该节点，然后单击“上传”(Upload)按钮。您将看到以下 UI，通过它可以控制如何在 ShotGrid 中创建您的版本：可以控制以下项：  版本名称是基于当前加载的 Nuke 脚本预先填充的，可以根据需要进行调整。  与版本关联的实体链接和任务是基于当前上下文的，可以进行调整。  要提交的帧范围可以进行调整。  创建的版本可以添加到播放列表中。将会显示一个包含最近播放列表的下拉列表。按“上传”(Upload)按钮后，将在 Nuke 中生成 QuickTime 影片，然后上传到 ShotGrid。上传后，将显示以下屏幕，您可以选择在 Nuke 中的内置 ShotGrid 面板中或在 Web 悬浮播放器中显示版本。场景信息覆层和场记板信息默认情况下，应用将生成一个包含场记板信息和场景信息覆层的 QuickTime 影片： 自定义审核提交的大多数方面都可以使用挂钩进行调整。请单击此处获取相关文档。",
    "url": "/40da6878/",
    "relUrl": "/40da6878/"
  },
  "174": {
    "id": "174",
    "title": "Nuke 写入节点",
    "content": "Nuke 写入节点Nuke 写入节点应用提供一个自定义的 ShotGrid 写入节点，让您可轻松设置标准化的图像渲染位置。您可以为每个环境配置它。除了路径以外，配置还将决定要使用的渲染格式。一般用法要使用 ShotGrid 写入节点，可先将脚本另存为 Toolkit 工作文件，然后通过 Nuke 菜单创建一个新节点。此操作将创建一个与普通写入节点类似的节点：您不用输入路径，只需指定输出名称，Toolkit 便会自动计算路径的其余部分。您可以在用户界面中查看计算得到的路径，并可单击“显示在文件系统中”(Show in File System)按钮打开磁盘上的位置。渲染内容的写入位置取决于 Toolkit 的配置。渲染内容将实施版本控制，版本号始终遵循当前的 Nuke 脚本版本，会在您使用多发布进行发布时自动递增。重置渲染路径写入节点会缓存当前路径，以便文件在 Toolkit 工作区外部打开时，路径仍然有效。有时，这意味着路径可能会变得不同步和被“锁定”。如果渲染路径被锁定，将无法发布使用此写入节点创建的渲染内容。要重置渲染路径，请使用工作文件应用的“升级场景版本”命令升级场景的版本，或单独选择写入节点，然后在属性中单击“重置路径”(Reset Path)：添加另一个写入节点配置文件ShotGrid 写入节点封装了 Nuke 内置的写入节点，因此 Nuke 支持的任何格式均可用于此应用，并且通过配置可另外再添加节点。最简单的入门方法是使用您需要的参数设置一个简单的 Nuke 写入节点。例如，我们假设您使用 LZW 压缩来保存 16 位 TIFF 文件。如果您在文本编辑器中查看自己的 Nuke 脚本，会发现写入节点将如下所示：Write {    file /Users/ryanmayeda/Desktop/test.%04d.tif    file_type tiff    datatype &quot;16 bit&quot;    compression LZW    checkHashOnRead false    name Write1    xpos -145    ypos -61}上面的文本显示了您需要的参数名称和值各是什么。在本例中为 datatype 和 compression。接下来，转到环境配置（例如：/path/to/pipeline/config/env/shot_step.yml）并找到配置 tk-nuke-writenode 应用的部分。在 settings 部分使用这两个参数添加另一个写入节点：tk-nuke-writenode:  location: {name: tk-nuke-writenode, type: app_store, version: v0.1.6}  template_script_work: nuke_shot_work  ...  write_nodes:  - file_type: exr    ...  - file_type: dpx    ...  - file_type: tiff    name: Mono Tif    publish_template: nuke_shot_render_pub_mono_tif    render_template: nuke_shot_render_mono_tif    proxy_publish_template: null    proxy_render_template: null    settings: {datatype: 16 bit, compression: LZW}    tank_type: Rendered Image    tile_color: []    promote_write_knobs: []更新后的配置将在 Nuke 显示这个另外添加的 ShotGrid 写入节点：注意： 请务必将任何新模板（例如 nuke_shot_render_mono_tif）添加到 templates.yml 文件中，该文件可在项目配置中找到 (&amp;lt;configuration root&amp;gt;/config/core/templates.yml)。下面是另一个示例，显示了如何添加一个以 0.5 的压缩率和 4:2:2 的子采样率输出 JPEG 的 ShotGrid 写入节点。此配置文件还使用了“promote_write_knobs”选项将 JPEG 质量旋钮提升到小控件的用户界面。这样，配置文件便可以设置图片质量的默认值，同时还能为用户提供滑块控件以自己更改该设置：tk-nuke-writenode:  write_nodes:    - file_type: jpeg      name: Compressed JPEG      publish_template: nuke_shot_render_pub_jpeg      render_template: nuke_shot_render_jpeg      proxy_publish_template: null      proxy_render_template: null      settings: {_jpeg_quality: 0.5, _jpeg_sub_sampling: &quot;4:2:2&quot;}      tank_type: Rendered Image      tile_color: []      promote_write_knobs: [_jpeg_quality]提升写入旋钮如上面的配置文件示例中所示，封装的写入节点中的旋钮可以通过提升，显示在 ShotGrid 写入节点的属性面板中。提升的写入旋钮在配置文件中定义，并以旋钮名称进行标识。有多个旋钮可以提升。渲染农场集成工作室常常使用渲染农场来运行作业管理工具（例如 Deadline），这类工具往往会在渲染时直接启动 Nuke。由于这些工具不是以 ShotGrid 可识别的方式（例如，通过 Desktop 或 tank 命令）启动 Nuke，因此，ShotGrid 写入节点没有运行所需的信息。我们提供了几种方式来消除此限制。将 ShotGrid 写入节点转换为标准 Nuke 写入节点一个简单的解决方案是先将 ShotGrid 写入节点转换为常规 Nuke 写入节点，然后再发送要渲染的脚本。有两种方法：1. 可以启用转换菜单选项并使用该选项；2. 可以在应用上使用 API 转换方法。启用转换菜单选项有一个名为 show_convert_actions 的配置选项，可以将其添加到应用设置的环境 yml 文件中。当您添加设置 show_convert_actions: True 时，“将 SG 写入节点转转为写入节点…”(Convert SG Write Nodes to Write Nodes…) 和 “将写入节点转换回 SG 格式…”(Convert Write Nodes back to SG format…) 菜单选项将可用。但是，如果定义了任何提升写入旋钮的 ShotGrid 写入节点配置文件，则这些菜单选项将隐藏，即使 show_convert_actions 设置为 True。这是因为，目前转换回功能不支持提升的旋钮。使用 API 进行转换在 tk-nuke-writenode 应用上可使用 convert_to_write_nodes() 方法执行此转换。要将某个脚本中的所有 ShotGrid 写入节点都转换为常规 Nuke 写入节点，请在 Nuke 中运行以下代码：import sgtkeng = sgtk.platform.current_engine()app = eng.apps[&quot;tk-nuke-writenode&quot;]if app:    app.convert_to_write_nodes() 这将从场景中移除 ShotGrid 写入节点，因此，我们建议的工作流是，为要渲染的脚本创建一个副本，对该副本执行转换，然后将副本提交到农场。场景中不再有任何 Toolkit 引用，因此在渲染农场上打开 Nuke 脚本时不需要 Toolkit。注意：提供了对应的 convert_from_write_nodes() 方法，但为了确保数据完整性，建议仅将其用于调试，不应在您的工作流中使用。使用 init.py 引导 ShotGrid Pipeline Toolkit 插件Nuke 将运行在其插件路径中找到的任何 init.py 脚本。此方式是向 init.py 添加代码（从而执行 tk-nuke 插件的精简引导），以便 ShotGrid 写入节点能够在渲染农场中按预期运行。此工作流有几个步骤：首先，“实施前”提交脚本（在 ShotGrid 可识别的 Nuke 会话中运行）获取将用于为农场作业设置环境的数据。然后，由渲染农场管理员设置用于在渲染农场中对 ShotGrid 会话进行身份认证的其他环境变量。最后，将包含 ShotGrid 引导代码的 init.py 放置在渲染农场中的 Nuke 会话将检测并运行它的位置，从而在会话中引导 tk-nuke 插件，以及允许 ShotGrid 写入节点正常运行。1. 实施前提交脚本此方法假定艺术家在 ShotGrid 可识别的 Nuke 会话中提交农场作业。在提交时，应运行以下代码。此代码将从当前 Nuke 会话中提取环境信息（如 Toolkit 上下文、工作流配置 URI、Toolkit 核心 API 位置等）来填充一个词典，该词典将传递给渲染作业以用来设置环境变量。# Populating environment variables from running Nuke:# https://developer.shotgridsoftware.com/tk-core/platform.html#sgtk.platform.create_engine_launchercurrent_engine = sgtk.platform.current_engine()launcher = sgtk.platform.create_engine_launcher(     current_engine.sgtk,     current_engine.context,     current_engine.name)# Get a dictionary with the following keys:# SHOTGUN_SITE: The ShotGrid site url# SHOTGUN_ENTITY_TYPE: The ShotGrid Entity type, e.g. Shot# SHOTGUN_ENTITY_ID: The ShotGrid Entity id, e.g. 1234environment = launcher.get_standard_plugin_environment()# Get the current pipeline config descriptorenvironment[&quot;SHOTGUN_CONFIG_URI&quot;] = os.path.join(current_engine.sgtk.configuration_descriptor.get_uri(),&quot;config&quot;)# Get the current tk-core installation pathenvironment[&quot;SHOTGUN_SGTK_MODULE_PATH&quot;] = sgtk.get_sgtk_module_path()收集了此信息后，可以将其传递给渲染提交工具。根据所用的渲染农场管理系统，此过程会有所不同。有关如何编写渲染提交脚本的详细信息，请参见您的农场管理系统文档。2. ShotGrid 身份认证引导 API 的 ToolkitManager 需要脚本用户才能初始化。在我们的示例中，我们假定您的站点名称、脚本用户和脚本密钥以环境变量的形式存在于农场计算机上。通常，这是由渲染农场管理员管理的。下面是我们的代码需要的环境变量名称以及示例值：SHOTGUN_SITE = “https://mysitename.shotgunstudio.com”SHOTGUN_FARM_SCRIPT_USER = “sg_api_user”SHOTGUN_FARM_SCRIPT_KEY = “xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx”有关身份验证的详细信息，请参见开发人员文档。有关保护脚本用户安全的注意事项：建议锁定您在农场中使用的脚本用户，以免其拥有管理员级别的权限。您可在此处详细了解 API 用户权限。3.init.py 脚本目前，Toolkit 环境数据是从渲染提交工具传递过来的，身份认证数据位于渲染农场计算机上的环境变量中。在渲染作业中引导 Toolkit 的最后一部分是将以下示例 init.py 代码放置在 Nuke 的插件路径中，以便 Nuke 在启动时启动它。（有关更多详细信息，请参见 Foundry 的启动脚本文档。）# This script shows how a Toolkit as a plugin approach could be used to bootstrap# Toolkit in Nuke on the render farm.# https://developer.shotgridsoftware.com/tk-core/bootstrap.html#bootstrapping-toolkitimport sysimport os# If your render nodes can access the same tk-core install location as# artist workstations, retrieve its path from the environment and ensure# it is in the PYTHONPATHTK_CORE_PATH = os.environ[&quot;SHOTGUN_SGTK_MODULE_PATH&quot;]if TK_CORE_PATH not in sys.path:    sys.path.append(TK_CORE_PATH)# If your render nodes don’t have access to the Toolkit Core API in the same filesystem location as artist workstations, you have to make sure that it is available in the PYTHONPATH, so that render nodes can import it. An easy way # to install tk-core in a centralized location is with pip. You can read more # about it here:# https://developer.shotgridsoftware.com/tk-core/bootstrap.html#installing-the-sgtk-module-using-pipimport sgtk# Authenticate using a pre-defined script user.sa = sgtk.authentication.ShotgunAuthenticator()# Here we retrieve credentials from environment variables, assuming a script user# will be used when rendering. This should be typically be handled by your render# farm administrators.SG_SITE_URL = os.environ[&quot;SHOTGUN_SITE&quot;]SG_SCRIPT_USER = os.environ[&quot;SHOTGUN_FARM_SCRIPT_USER&quot;]SG_SCRIPT_KEY = os.environ[&quot;SHOTGUN_FARM_SCRIPT_KEY&quot;]user = sa.create_script_user(    api_script=SG_SCRIPT_USER,    api_key=SG_SCRIPT_KEY,    host=SG_SITE_URL)# Start up a Toolkit Manager with our script usermgr = sgtk.bootstrap.ToolkitManager(sg_user=user)# Set the base pipeline configuration from the environment variable:mgr.base_configuration = os.environ[&quot;SHOTGUN_CONFIG_URI&quot;]# Disable ShotGrid lookup to ensure that we are getting the Pipeline # Configuration defined in SHOTGUN_CONFIG_URI, and not a dev or override# Pipeline Configuration defined in ShotGrid.mgr.do_shotgun_config_lookup = False# Set a plugin id to indicate to the bootstrap that we are starting# up a standard Nuke integrationmgr.plugin_id = &quot;basic.nuke&quot;# Retrieve the Toolkit context from environment variables:# SHOTGUN_SITE: The ShotGrid site url# SHOTGUN_ENTITY_TYPE: The ShotGrid Entity type, e.g. Shot# SHOTGUN_ENTITY_ID: The ShotGrid Entity id, e.g. 1234sg_entity = mgr.get_entity_from_environment()# Now start up the Nuke engine for a given ShotGrid Entitynuke_engine = mgr.bootstrap_engine(&quot;tk-nuke&quot;, entity=sg_entity)如果您的配置比此示例复杂，或要使用 -t 标志而不是使用 Nuke (.nk) 脚本将 Python 脚本传递到命令行，则您可能需要扩展此脚本。Deadline 特定的步骤Deadline 可能会在渲染时将 Nuke 脚本复制到一个临时位置。这会导致 Toolkit 出现问题，因为这种情况下文件已不在 Toolkit 识别的磁盘位置。要禁用此行为并从原始位置加载脚本，请执行以下操作：  在 Deadline 中，导航到“Tools &amp;gt; Configure Plugin”（在超级用户模式下）  禁用“Enable Path Mapping”选项技术细节应用提供以下 API 方法：get_write_nodes()返回当前场景中所有 ShotGrid 写入节点的列表。list app.get_write_nodes()参数和返回值  返回值：list - 在场景中找到的 Toolkit 写入节点的列表。示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()get_node_name()返回指定的写入节点的名称。string get_node_name(node 节点)参数和返回值  node node - 要查询的写入节点。  返回值：string - 节点名称。示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_name(nodes[0])get_node_profile_name()获取指定的写入节点使用的配置文件的名称。string get_node_profile_name(node 节点)参数和返回值  node node - 要查询的写入节点。  返回值：string - 配置为此写入节点定义的配置文件名称。示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_profile_name(nodes[0])get_node_render_path()获取指定的写入节点渲染图像的路径。string get_node_render_path(node 节点)参数和返回值  node node - 要查询的写入节点。  返回值：string - 此节点的渲染路径。示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_path(nodes[0]) get_node_render_files()获取指定的写入节点已渲染的所有图像文件的列表。list get_node_render_files(node 节点)参数和返回值  node node - 要查询的写入节点。  返回值：list - 此写入节点渲染的图像文件的列表。示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_files(nodes[0])get_node_render_template()获取配置中定义的一个模板，该模板决定指定的写入节点将渲染图像写入哪个位置。template get_node_render_template(node 节点)参数和返回值  node node - 要查询的写入节点。  返回值：template - 此节点配置使用的渲染模板。示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_template(nodes[0]) get_node_publish_template()获取配置中定义的一个模板，该模板决定指定的写入节点将渲染图像发布至哪个位置。template get_node_publish_template(node 节点)参数和返回值  node node - 要查询的写入节点。  返回值：template - 此节点配置使用的发布模板。示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_publish_template(nodes[0]) get_node_proxy_render_path()获取指定的写入节点渲染代理图像的路径。string get_node_proxy_render_path(node 节点)参数和返回值  node node - 要查询的写入节点。  返回值：string - 此节点的代理渲染路径。示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_path(nodes[0]) get_node_proxy_render_files()获取指定的写入节点已渲染的所有代理图像文件的列表。list get_node_proxy_render_files(node 节点)参数和返回值  node node - 要查询的写入节点。  返回值：list - 此写入节点渲染的代理图像文件的列表。示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_files(nodes[0])get_node_proxy_render_template()获取配置中定义的一个模板，该模板决定指定的写入节点将代理渲染图像写入哪个位置。如果指定的节点未配置代理渲染模板，将返回常规渲染模板。template get_node_proxy_render_template(node 节点)参数和返回值  node node - 要查询的写入节点。  返回值：template - 此节点配置使用的代理渲染模板。示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_template(nodes[0]) get_node_proxy_publish_template()获取配置中定义的一个模板，该模板决定指定的写入节点将代理渲染图像发布到哪个位置。如果指定的节点未配置代理发布模板，将返回常规发布模板。template get_node_proxy_publish_template(node 节点)参数和返回值  node node - 要查询的写入节点。  返回值：template - 此节点配置使用的代理发布模板。示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_publish_template(nodes[0]) get_node_published_file_type()获取配置中定义的一个发布文件类型，为指定的写入节点渲染的图像创建发布文件时，将使用此类型。string get_node_published_file_type(node 节点)参数和返回值  node node - 要查询的写入节点。  返回值：string - 此节点配置使用的发布文件类型。示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_published_file_type(nodes[0]) generate_node_thumbnail()为指定的写入节点生成缩略图。此方法会将镜头序列中间的一帧渲染到一个临时文件 (.png)，最大尺寸为 800x800 像素。当不再需要此文件时，调用程序负责清理此文件。string generate_node_thumbnail(node 节点)参数和返回值  node node - 要查询的写入节点。  返回值：string - 渲染的缩略图图像在磁盘上的路径。示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.generate_node_thumbnail(nodes[0]) reset_node_render_path()将指定的写入节点的渲染路径重置为与当前脚本一致。None reset_node_render_path(node 节点)参数和返回值  node node - 要查询的写入节点。  返回值：None - 不返回任何值。示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.reset_node_render_path(nodes[0]) is_node_render_path_locked()判断指定的写入节点的渲染路径是否已锁定。bool is_node_render_path_locked(node 节点)参数和返回值  node node - 要查询的写入节点。  返回值：bool - 渲染路径锁定时返回 True，否则返回 False。示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.is_node_render_path_locked(nodes[0]) convert_to_write_nodes()将在当前脚本中找到的所有 ShotGrid 写入节点转换为常规 Nuke 写入节点。其他 Toolkit 信息将存储在名为“tk_*”的用户旋钮上。None convert_to_write_nodes()示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.convert_to_write_nodes() convert_from_write_nodes()将之前从 ShotGrid 写入节点转换而来的所有常规 Nuke 写入节点转换回 ShotGrid 写入节点。None convert_from_write_nodes()示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.convert_from_write_nodes() process_placeholder_nodes()将任何占位符节点转换为完整的 ShotGrid 写入节点。这主要用于在 Nuke 中首次打开脚本时转换由 Hiero Toolkit 脚本导出器创建的占位符节点。None process_placeholder_nodes()示例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.process_placeholder_nodes() ",
    "url": "/09168e73/",
    "relUrl": "/09168e73/"
  },
  "175": {
    "id": "175",
    "title": "Nuke",
    "content": "NukeShotGrid Nuke 插件包含一个用于在 Nuke、Nuke Studio 和 Hiero 中集成 ShotGrid 应用的标准平台。它采用轻量型设计，操作简单直观，并会向 Nuke 中添加一系列新功能。它会在 Nuke 中创建一个 ShotGrid 菜单，上面显示各种菜单项：它会在 Nuke 中创建一个 ShotGrid 节点菜单，上面显示各种菜单项：它会向文件对话框中添加 ShotGrid 快捷方式，以便可轻松跳转至文件系统的不同位置：您可以使用 favourite_directories 设置，基于当前环境中的模板路径添加自己的快捷方式。该设置应为词典列表，每个列表项表示一个新的收藏夹目录。下面是一个可使用的格式示例：（也可以不指定图标，方法是提供 “” 值。）  favourite_directories:  - display_name: &quot;Shot Publish Path&quot;    template_directory: &quot;shot_publish_area_nuke&quot;    icon: &quot;icons/custom_publish_icon.png&quot;  - display_name: &quot;Shot Work Path&quot;    template_directory: &quot;shot_work_area_nuke&quot;    icon: &quot;icons/custom_work_icon.png&quot;对于定义的每个根目录，会自动添加一个“ShotGrid Current Project”收藏夹。您可以使用 project_favourite_name 设置来自定义名称，也可以将此值设置为空字符串 ''，禁用这些收藏夹。支持的应用程序版本此插件已经过测试，已知可支持以下应用程序版本：12.0 - 14.0v5请注意，此插件也许（甚至非常有可能）支持更新的发行版本，但是尚未正式在这些版本中进行测试。注意：目前，Nuke 8.0 在 CentOS 6.5 这个特定版本上运行时存在一个错误，会导致 Nuke 在运行 Toolkit 时发生崩溃。其他版本的 CentOS 不受影响。The Foundry 已知晓此问题（错误号 43766）。如果您遇到此问题，请联系我们，我们可以尝试帮助您以变通方法暂时绕过此问题，直到 Nuke 在以后的更新中修复它。应用开发人员须知上下文跟踪ShotGrid Nuke 插件会在加载文件时自动切换上下文。文件加载后，插件会查看该文件，并尝试从中解析上下文。具有自定义小控件的应用ShotGrid Nuke 插件让您可轻松处理自定义小控件 (Gizmo)。如果您编写的应用使用自定义小控件，只需将这些小控件放入名为 gizmos 的文件夹，插件便会自动将该位置添加到 nuke 路径：然后，您可以通过“创建节点”功能轻松访问小控件：  nuke.createNode(&quot;WriteTank&quot;)                    警告: 请注意，虽然小控件用起来可能很方便，但如果您想在场景中创建持久性节点，小控件通常不是正确的做法。这是因为一旦将小控件放入场景，就在该场景与小控件代码之间建立了依赖关系。这样，不仅需要在每次加载场景时都加载 ShotGrid Toolkit，还需要小心管理代码，确保代码的任何更新都不会影响场景中使用的旧的小控件。    创建节点的应用对于会创建自定义 Nuke 节点的应用，需要小心对待。我们建议不要使用小控件，因为它们需要在场景与小控件代码之间建立依赖关系。可以将自定义节点另存为 Nuke 文件，然后将它们导入场景：    group_node_script = os.path.join(self.disk_location, &quot;resources&quot;, &quot;my_group_node.nk&quot;)    group_node = nuke.nodePaste(group_node_script)任何从应用内调用节点的代码均可直接使用返回的实例。任何需要从组内部调用应用的代码，在调用时要特别小心，以确保代码的向后兼容性。我们建议您遵循以下做法：应用启动时，将应用句柄注册为 Nuke 命名空间的一部分：    def init_app(self):        nuke.tk_nuke_nameofmyapp = self如果您在组节点上有一个按钮，并且想调用某段 ShotGrid 应用代码，当找不到 ShotGrid Toolkit 时，请尝试以正常方式提示失败。下面的代码与一个 Python 按钮关联，该按钮属于应用可以创建的组节点：# have to gracefully support the case when# sgtk is not in the system at all!import nuketry:  app = nuke.tk_nuke_nameofmyapp  app.do_something_v1(nuke.thisNode())except:  nuke.warning(&quot;Could not do XYZ! Most likely Sgtk is not currently active.&quot;)如果您更改了应用的行为，只需在应用回调时保持版本号递增，这样您的应用代码就能同时支持新旧两种行为。在 Hiero 内使用 ShotGrid Nuke 插件ShotGrid Nuke 插件还用于构建在 Hiero 内运行的可感知 ShotGrid 的集成。通过它，您可以在应用程序中的一些位置放置 ShotGrid 应用动作，比如在主菜单栏上的特定 ShotGrid 菜单中和不同 Hiero 面板中的各种右键单击上下文菜单中。如何配置 Hiero 菜单由于 Hiero 有多种不同的菜单，因此，用于配置菜单项放置位置的选项要比诸如 Maya 或 Nuke 等应用程序中更多。ShotGrid Nuke 插件的 Hiero 工作流配置可能如下所示：  tk-hiero:    location: {name: tk-nuke, type: app_store, version: v0.6.9}    debug_logging: false    timeline_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: Open in Shotgun, requires_selection: true}    spreadsheet_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: Open in Shotgun, requires_selection: true}    bin_context_menu:    - {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;ShotGrid Save As...&quot;, requires_selection: true}    - {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;Version up Current Scene...&quot;, requires_selection: true}    - {app_instance: tk-multi-snapshot, keep_in_menu: false, name: &quot;Snapshot...&quot;, requires_selection: true}    - {app_instance: tk-multi-snapshot, keep_in_menu: false, name: &quot;Snapshot History...&quot;, requires_selection: true}    - {app_instance: tk-multi-publish, keep_in_menu: false, name: &quot;Publish Project...&quot;, requires_selection: true}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: Shotgun File Manager...}大多数插件都有一个 menu_favourites 选项，这是一个列表，您可以在这里指定要放在 ShotGrid 主菜单上的“快捷方式”。除此以外，特定于 Hiero 的配置还有三个特殊部分：  timeline_context_menu 表示在时间线编辑器中的视频片段上单击鼠标右键时弹出的菜单。  spreadsheet_context_menu 表示在电子表格编辑器中的选定项上单击鼠标右键时弹出的菜单。  bin_context_menu 表示在 bin 编辑器中的选定项上单击鼠标右键时弹出的菜单，您可以在该菜单上看到所有不同的项目和媒体。要向这些菜单中添加菜单项，只需确保配置中定义的 name 字段与应用在自己菜单中显示的内容一致即可。需要用到当前场景概念的应用某些 Toolkit 应用需要用到默认场景或默认项目的概念。例如，快照应用知道如何为当前场景拍摄快照。但是，与 Maya 或 Nuke 不同，Hiero 没有当前场景的概念。在 Hiero 中，可以同时打开多个项目。因此，您常常需要在挂钩中添加特殊的逻辑，帮助应用（比如快照应用）识别用户正在单击哪个项目。在本文档接下来的部分，我们将对此加以说明。应用开发人员须知因为 Hiero 没有当前项目的概念，我们加入了更强大的工具，让应用很容易就能识别用户在 Hiero 内单击了什么对象。ShotGrid Hiero 插件为此加入了两个方法：get_menu_selection()返回最近一次单击菜单操作选中的 Hiero 对象的列表。此列表可能包含各种类型的内容项。要了解哪种方法到底返回了什么内容，可开启调试日志记录功能 - 此功能会将具体的过程打印出来。下面是返回的各种对象的示例：  在 bin 视图中选择一个项目：hiero.core.Bin  在 bin 视图中选择一个内容项：hiero.core.BinItem  选择轨道：hiero.core.TrackItemlist engine_object.get_menu_selection()参数和返回值  返回值：Hiero 对象列表示例获取最近一次单击操作选中的对象，确保选中的只有一个对象，并且此对象是有效的 Hiero 项目。 例如，当您想在 Hiero 中触发某个项目的保存、加载或发布操作时，此设置非常有用。# get the menu selection from the engineselection = engine_obj.get_menu_selection()if len(selection) != 1:    raise TankError(&quot;Please select a single Project!&quot;)if not isinstance(selection[0] , hiero.core.Bin):    raise TankError(&quot;Please select a Hiero Project!&quot;)project = selection[0].project()if project is None:    # apparently bins can be without projects (child bins I think)    raise TankError(&quot;Please select a Hiero Project!&quot;)HieroEngine.get_menu_category()返回上次发生单击菜单操作的用户界面区域。此命令不太可能会用到 - 当您希望应用命令根据调用它时所在的菜单做出不同行为时，可能需要使用此命令。area_enum engine_object.get_menu_category()参数和返回值返回以下常量之一：  HieroEngine.HIERO_BIN_AREA  HieroEngine.HIERO_SPREADSHEET_AREA  HieroEngine.HIERO_TIMELINE_AREA  None（表示未知或未定义）如何配置挂钩以支持 Hiero为 Hiero 配置的多用应用通常需要判断用户单击的是哪个项目。例如，tk-multi-workfiles 应用需要对项目执行“ShotGrid 另存为”操作。因此，我们向 Hiero 中的 bin 菜单添加了 Tank Save As 命令，这样用户便可在 bin 视图中的项目上单击鼠标右键并选择“另存为”(Save As)**选项。插件配置将如下所示：bin_context_menu:- {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;ShotGrid Save As...&quot;, requires_selection: true}现在，在应用本身中，每个插件需要配置一个挂钩，用来处理诸如保存和加载这样的场景事件。 对于 Maya 或 Nuke 这样的应用程序，通常只要进行保存、加载等操作即可。但是对于 Hiero，则需要首先判断用户实际单击的是哪个项目。上面示例中的挂钩代码将如下所示：class SceneOperation(Hook):    &quot;&quot;&quot;    Hook called to perform an operation with the    current scene    &quot;&quot;&quot;    def execute(self, operation, file_path, context, **kwargs):        &quot;&quot;&quot;        Main hook entry point        :operation: String                    Scene operation to perform        :file_path: String                    File path to use if the operation                    requires it (e.g. open)        :context:   Context                    The context the file operation is being                    performed in.        :returns:   Depends on operation:                    'current_path' - Return the current scene                                     file path as a String                    'reset'        - True if scene was reset to an empty                                     state, otherwise False                    all others     - None        &quot;&quot;&quot;        if operation == &quot;current_path&quot;:            # return the current script path            project = self._get_current_project()            curr_path = project.path().replace(&quot;/&quot;, os.path.sep)            return curr_path        elif operation == &quot;open&quot;:            # open the specified script            hiero.core.openProject(file_path.replace(os.path.sep, &quot;/&quot;))        elif operation == &quot;save&quot;:            # save the current script:            project = self._get_current_project()            project.save()        elif operation == &quot;save_as&quot;:            project = self._get_current_project()            project.saveAs(file_path.replace(os.path.sep, &quot;/&quot;))        elif operation == &quot;reset&quot;:            # do nothing and indicate scene was reset to empty            return True        elif operation == &quot;prepare_new&quot;:            # add a new project to hiero            hiero.core.newProject()    def _get_current_project(self):        &quot;&quot;&quot;        Returns the current project based on where in the UI the user clicked        &quot;&quot;&quot;        # get the menu selection from the engine        selection = self.parent.engine.get_menu_selection()        if len(selection) != 1:            raise TankError(&quot;Please select a single Project!&quot;)        if not isinstance(selection[0] , hiero.core.Bin):            raise TankError(&quot;Please select a Hiero Project!&quot;)        project = selection[0].project()        if project is None:            # apparently bins can be without projects (child bins I think)            raise TankError(&quot;Please select a Hiero Project!&quot;)        return project使用调试日志记录功能查看菜单事件如果您想知道单击某个选择项时 Hiero 返回哪些对象，只需开启插件调试模式即可。 在脚本编辑器中，可以看到每次单击操作选择的对象的摘要信息：",
    "url": "/4dc252e5/",
    "relUrl": "/4dc252e5/"
  },
  "176": {
    "id": "176",
    "title": "Photoshop",
    "content": "PhotoshopShotGrid Photoshop CC 插件提供一个用于在 Photoshop CC 工作流中集成 ShotGrid 的平台。它包含一个标准 ShotGrid Pipeline Toolkit 插件并依赖于 tk-framework-adobe (CEP)。启用后，Photoshop CC 中将出现一个 ShotGrid Adobe Panel。此面板显示有关当前 ShotGrid 上下文以及该上下文中安装的应用注册的各种命令的信息。支持的应用程序版本此插件已经过测试，已知可支持以下应用程序版本：2020 (v21.0) - 2023 (v24.7) Note: Apple Silicon (M1/M2) native is not supported, Apple Silicon with Rosetta is supported, learn more here.请注意，此插件也许（甚至非常有可能）支持更新的发行版本，但是尚未正式在这些版本中进行测试。界面概述ShotGrid 扩展面板采用与原生 Photoshop CC 面板相同的配色和基本布局。面板由五个部分组成：  上下文标题 - 当前上下文的缩略图和字段。  收藏工具架 - 用于显示当前上下文中最常用的应用。  命令列表 - 当前上下文的所有未收藏命令。  上下文菜单 - 与上下文相关的其他命令和调试工具。  日志记录控制台 - 一个控制台叠加层，显示调试的日志记录输出。安装ShotGrid Photoshop CC 插件在安装方面遵循与其他 ShotGrid 集成相同的协议。有关安装插件和应用的信息，请参见管理 Toolkit 文章。此外，您还可以参考默认 Toolkit 配置，以它为例了解如何配置集成。启用扩展安装此扩展后，需要通过 Photoshop CC 中的“Extensions”菜单启动它。此操作只需要做一次，之后 ShotGrid 扩展面板便可一直留在 Photoshop CC 布局中，后续启动时不必再启用。启用后，在以后启动时，扩展面板将在引导 ShotGrid 集成期间显示一个正在加载屏幕。此屏幕通常会持续显示几秒钟，待当前上下文确定后再显示命令。界面组成部分以下部分概述了 ShotGrid Photoshop CC 集成的组成部分。上下文标题上下文标题是一个可自定义的区域，可显示有关当前 ShotGrid 上下文的信息。上下文由当前激活的文档决定。插件确定上下文后，标题会更新并显示上下文的缩略图字段详情。这些字段信息由一个挂钩来控制。有关如何对字段的显示进行自定义的信息，请参见下面的上下文字段显示挂钩部分。另外还要注意的是，由于 Photoshop CC 是一个多文档界面，上下文（因此也包括 ShotGrid 扩展）会随着您切换激活文档而更新。艺术家要理解这种行为，特别是当同时在多个 ShotGrid 上下文中工作时，明白这一点非常重要。收藏工具架收藏工具架与 Maya 和 Houdini 等其他 ShotGrid DCC 集成中提供的菜单收藏夹类似。在界面的这个部分，用户随手即可访问最常用的 Toolkit 应用，并可按照上下文标题轻松找到应用。此工具架以按钮的形式显示收藏的命令，将鼠标移至这些按钮时，按钮从灰色变为彩色，同时顶部的标签中显示它们的名称。将鼠标悬停在按钮上方时，将显示它们的工具提示。单击其中一个按钮，将触发回调，执行注册的命令。有关如何指定命令收藏夹的详细信息，请参见下面的工具架收藏夹部分。命令列表命令列表显示当前上下文注册的其他“常规”命令。通常，工作流配置内安装的应用会注册一个或多个命令，这些命令将显示在这里。如果命令未标识为收藏项，也未被指定为上下文菜单命令，它们将显示在此处。命令列表中按钮的行为与收藏工具架中按钮的行为类似。唯一真正的区别在于它们以列表的形式显示，并且其图标右侧带有完整名称。上下文菜单所有注册为上下文菜单命令的命令将显示在 ShotGrid 扩展面板的上下文菜单中。与其他命令区域一样，这些命令会随上下文一起变化。诸如 Jump to ShotGrid 和 Jump to Filesystem 这样的命令将始终位于此处。日志记录控制台日志记录控制台同时显示来自 CEP Javascript 解释器和 Toolkit Python 进程的所有日志记录输出。当扩展遇到任何需要技术支持的问题时，日志记录控制台的输出就变得极为有用，这些信息可帮助 ShotGrid 技术支持团队调试问题。配置和技术细节以下部分对集成中技术性更强的一些方面进行了概述，以帮助您根据自己工作室工作流的具体需求来配置集成。PySideShotGrid Photoshop CC 插件依赖于 PySide。请参见有关安装 Pyside 的官方说明。CEP 扩展扩展本身与插件捆绑在一起，插件会在首次启动 Photoshop CC 时自动安装扩展。扩展安装在美工人员的本地计算机上，位于操作系统特定的标准 CEP 扩展目录中：# Windows&amp;gt; C: Users [user name] AppData Roaming Adobe CEP extensions # OS X&amp;gt; ~/Library/Application Support/Adobe/CEP/extensions/每次启动 Photoshop CC 时，插件引导代码会对照计算机上安装的扩展版本，检查随插件捆绑的扩展版本。这意味着，当插件更新后，假设它随附了一个新的扩展版本，已安装的扩展会自动更新为新捆绑的版本。配置收藏夹我们可以配置收藏工具架，让它显示已安装应用的任何注册命令。要执行此操作，只需向环境配置的 tk-photoshopcc 部分添加 shelf_favorites 设置即可。示例如下：shelf_favorites:    - {app_instance: tk-multi-workfiles2, name: File Save...}    - {app_instance: tk-multi-workfiles2, name: File Open...}    - {app_instance: tk-multi-publish, name: Publish...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}设置的值是一个词典列表，每个词典指定了配置中安装的一个应用提供的一个注册命令。app_instance 键标识了一个特定的已安装应用，name 键则与该应用注册的命令的显示名称一致。在上面的示例中，您可以看到四个收藏的命令：tk-multi-workfiles2 应用的“File Open”和“File Save”对话框，以及 Toolkit 的“发布”(Publish)和“Snapshot”标准对话框。这四个命令现在将显示在收藏工具架中。上下文字段显示挂钩插件随附了一个挂钩，用来控制面板的上下文标题部分显示的字段。我们可以改写挂钩中的两个方法来自定义显示的内容。第一个方法是 get_entity_fields() 方法。此方法接受一个表示当前 ShotGrid 上下文的实体类型。返回的值应该是要为该实体查询并显示的各个字段的列表。插件自己负责异步查询数据。从 ShotGrid 查询到数据后，会调用挂钩中的第二个方法。此方法是 get_context_html() 方法，它接受上下文实体词典，其中填充有 get_entity_fields() 方法指定的查询字段。返回的值应该是一个字符串，该字符串包含带格式的 HTML，用以显示查询到的实体字段。默认的挂钩执行对于了解这些方法都需要什么来说是一个很好的参考。要注意的是，插件始终会显示实体的缩略图（如果有的话）。Photoshop API插件向 Python 公开了适用于 Photoshop CC 的 Javascript API。Photoshop API 对象被公开为 engine.adobe。下面的示例说明怎样才能从 Toolkit 应用和挂钩内直接操纵 Photoshop DOM。标准 Toolkit 应用还包含有关如何与 Photoshop 文档进行交互的可行示例。示例加载文件：f = adobe.File('/Path/To/File.jpeg')adobe.app.load(f)将标尺单位设置为像素 (PIXELS)：pixels = adobe.Units.PIXELSadobe.app.preferences.rulerUnits = pixels使用默认选项将当前文档导出为 Web 格式：temp_thumb_file = adobe.File(out_path)save_for_web = adobe.ExportType.SAVEFORWEBexport_options = adobe.ExportOptionsSaveForWeb()adobe.app.activeDocument.exportDocument(temp_thumb_file, save_for_web, export_options)将每个层导出为单独的文件：doc = adobe.app.activeDocumentlayers = doc.artLayerslayers = [layers[i] for i in xrange(layers.length)]original_visibility = [layer.visible for layer in layers]save_for_web = adobe.ExportType.SAVEFORWEBexport_options = adobe.ExportOptionsSaveForWeb()for layer in layers:    layer.visible = Falsefor layer in layers:    layer.visible = True    out_file = adobe.File(&quot;c:/layer.%s.jpg&quot; % str(layer.name))    doc.exportDocument(        out_file,        save_for_web,        export_options,    )    layer.visible = Falsefor (i, layer) in enumerate(layers):    layer.visible = original_visibility[i]环境变量为了辅助调试，有一组环境变量可用来更改插件的某些默认值：SHOTGUN_ADOBE_HEARTBEAT_INTERVAL - Python 的心跳检测间隔（以秒为单位，默认为 1 秒）。如果设置了旧的环境变量 SGTK_PHOTOSHOP_HEARTBEAT_INTERVAL，此变量也有效。SHOTGUN_ADOBE_HEARTBEAT_TOLERANCE - 退出前允许出现的心跳检测错误的数量（默认值为 2）。如果设置了旧的环境变量 SGTK_PHOTOSHOP_HEARTBEAT_TOLERANCE，此变量也有效。SHOTGUN_ADOBE_NETWORK_DEBUG - 在输出日志记录时包含附加的网络连接调试消息。如果设置了旧的环境变量 SGTK_PHOTOSHOP_NETWORK_DEBUG，此变量也有效。SHOTGUN_ADOBE_PYTHON - 启动插件时使用的 Python 可执行文件的路径。如果不设置，将使用系统的 Python。如果 Photoshop 是从某个 Python 进程启动（如 ShotGrid Desktop 或通过 tk-shell 插件），则 Photoshop 集成将使用该进程使用的 Python。注意：Adobe 框架中存在其他环境变量。有关详细信息，请参见开发人员文档。应用开发人员须知  因为 Python 进程与 Photoshop CC 进程彼此分离，所以插件内部会进行一些处理，让应用窗口以尽可能整洁的方式显示在 Photoshop 窗口之上。此项设置需要注意的一点是，默认选项是为 QFileDialog 使用原生操作系统窗口。如果您要开发与此插件一起使用的应用，务必将此选项设置为不使用原生对话框。请参见 tk-multi-pythonconsole 应用中关于此选项的示例。",
    "url": "/8d461cbe/",
    "relUrl": "/8d461cbe/"
  },
  "177": {
    "id": "177",
    "title": "Shell",
    "content": "ShellShotGrid Shell 插件可处理命令行的交互，并与随核心 API 一起分发的 tank 命令紧密集成。当您在终端中执行 tank 命令时，Toolkit 会启动该插件来负责应用的执行。有关 tank 命令的详细信息，请参见高级 Toolkit 管理文档。安装和更新将此插件添加到 ShotGrid Pipeline Toolkit如果您想将此插件添加到 Project XYZ 中名为 asset 的环境中，请执行以下命令：&amp;gt; tank Project XYZ install_engine asset tk-shell更新至最新版本如果您已在某个项目中安装了此应用，要获取最新版本，可运行 update 命令。您可以导航到该特定项目随附的 tank 命令，并在该项目中运行它：&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updates或者，也可以运行您的工作室的 tank 命令并指定项目名称，指示该命令要对哪个项目运行更新检查：&amp;gt; tank Project XYZ updates协作和代码演进如果您可以获取 ShotGrid Pipeline Toolkit，意味着也可以获取我们在 GitHub 中存储和管理的所有应用、插件和框架的源代码。欢迎根据实际需要演进和完善这些内容，以它们为基础做进一步的独立开发，修改它们（以及向我们提交 Pull 请求！），或者只是随手玩一玩，简单了解它们的构建方式和 Toolkit 的工作原理。您可以通过 https://github.com/shotgunsoftware/tk-shell 访问此代码库。",
    "url": "/2ad59ee8/",
    "relUrl": "/2ad59ee8/"
  },
  "178": {
    "id": "178",
    "title": "ShotGrid 文件夹",
    "content": "ShotGrid 文件夹ShotGrid Toolkit 有一个内置系统，负责基于配置创建标准目录结构。利用这个系统，我们很容易就能快速为多个镜头创建一致的文件系统布局。此应用将 Sgtk 核心 API 中用于创建文件系统的 API 方法与 ShotGrid 连接在一起。这样就能轻而易举地创建文件夹；只需选择一组镜头或资产，然后单击“Create Folders”动作即可。工作方式只需选择一个或多个任务、镜头或其他实体（取决于配置）。然后，从动作菜单中选择“Ceate Folders”。处理完成后，您将得到一份有关文件夹创建数量的报告。",
    "url": "/134adb0e/",
    "relUrl": "/134adb0e/"
  },
  "179": {
    "id": "179",
    "title": "ShotGrid 启动文件夹",
    "content": "ShotGrid 启动文件夹启动文件夹应用是一个 ShotGrid 实用工具，它让您可以从 ShotGrid 跳转到文件系统中。工作方式启动文件夹应用让您可以从 ShotGrid 跳转到文件系统中。您可以为 ShotGrid 实体类型（如镜头、资产和场）注册该应用。激活后，它将显示在“动作”(Action)菜单中：您可以在 ShotGrid 中选择一个或多个条目，当单击该菜单动作时，将启动一个标准文件浏览器（在 Windows 上将启动资源管理器，在 Mac 上将启动 Finder，等等）。",
    "url": "/0c3049eb/",
    "relUrl": "/0c3049eb/"
  },
  "180": {
    "id": "180",
    "title": "ShotGrid 启动发布",
    "content": "ShotGrid 启动发布此应用向 ShotGrid 中的“已发布的文件”(Published File)实体添加一个“在关联应用程序中打开”(Open in Associated Application)动作。这让您可以轻松打开已发布的文件：只需导航到该文件，在文件上单击鼠标右键，然后选择动作即可。此应用让您可轻松为不同文件配置不同的应用启动顺序 – 所有这些都在一个挂钩内完成。它还会将图像序列发送至查看器（如 RV）。挂钩无法识别的文件将发送至操作系统级别的应用。",
    "url": "/a01dbeb7/",
    "relUrl": "/a01dbeb7/"
  },
  "181": {
    "id": "181",
    "title": "ShotGrid",
    "content": "ShotGridShotGrid 插件用来管理可以从 ShotGrid 内启动的应用。有时，我们称这些 Toolkit 应用为“动作”**。它们通常以菜单项的形式显示在 ShotGrid 内的菜单上。使用 ShotGrid Pipeline Toolkit 动作ShotGrid 主页上列出了这些动作：另外，您也可以在标准 ShotGrid 上下文菜单上找到这些动作，在对象或选择内容上单击鼠标右键即可显示上下文菜单：单击某个动作，将立即开始处理操作。应用完成处理后，通常会显示一条包含状态信息的消息，如果动作未正常运行，则会显示错误消息。为 ShotGrid 开发应用开发在 ShotGrid 内运行的应用非常简单！如果您不熟悉应用开发的一般流程，请访问平台文档库阅读相关的介绍资料。在这部分，我们将只介绍应用开发流程中特定于 ShotGrid 的方面！自 Core v0.13 起，所有多用应用都可以与 ShotGrid 插件一起使用。从技术上讲，ShotGrid 插件与其他插件没有太大区别，但还是有些细微差异：  如果想在 ShotGrid 插件中执行基于 QT 的应用，需要在标准 Python 环境中手动安装 PySide 或 PyQt。  在 ShotGrid 插件中，可根据用户所属的权限组向用户显示动作。例如，如果想向 ShotGrid 动作菜单添加某个命令，并且只希望管理员才能看到该命令，就可以使用此功能。一个样式简单、仅对管理员可见的 ShotGrid 应用如下所示：from tank.platform import Applicationclass LaunchPublish(Application):    def init_app(self):        &quot;&quot;&quot;        Register menu items with ShotGrid        &quot;&quot;&quot;                params = {            &quot;title&quot;: &quot;Hello, World!&quot;,            &quot;deny_permissions&quot;: [&quot;Artist&quot;],        }        self.engine.register_command(&quot;hello_world_cmd&quot;, self.do_stuff, params)    def do_stuff(self, entity_type, entity_ids):        # this message will be displayed to the user        self.engine.log_info(&quot;Hello, World!&quot;)    安装和更新将此插件添加到 ShotGrid Pipeline Toolkit如果您想将此插件添加到 Project XYZ 中名为 asset 的环境中，请执行以下命令：&amp;gt; tank Project XYZ install_engine asset tk-shotgun更新至最新版本如果您已在某个项目中安装了此应用，要获取最新版本，可运行 update 命令。您可以导航到该特定项目随附的 tank 命令，并在该项目中运行它：&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updates或者，也可以运行您的工作室的 tank 命令并指定项目名称，指示该命令要对哪个项目运行更新检查：&amp;gt; tank Project XYZ updates协作和代码演进如果您可以获取 ShotGrid Pipeline Toolkit，意味着也可以获取我们在 GitHub 中存储和管理的所有应用、插件和框架的源代码。欢迎根据实际需要演进和完善这些内容，以它们为基础做进一步的独立开发，修改它们（以及向我们提交 Pull 请求！），或者只是随手玩一玩，简单了解它们的构建方式和 Toolkit 的工作原理。您可以通过 https://github.com/shotgunsoftware/tk-shotgun 访问此代码库。特殊要求需要安装 ShotGrid Pipeline Toolkit 核心 API 版本 v0.19.5 或更高版本才能使用此功能。",
    "url": "/02c2d8aa/",
    "relUrl": "/02c2d8aa/"
  },
  "182": {
    "id": "182",
    "title": "VRED",
    "content": "VREDShotGrid VRED 插件包含一个用于在 VRED 中集成 ShotGrid 应用的标准平台。它采用轻量型设计，操作简单直观，并会向 VRED 菜单中添加一个 ShotGrid 菜单。支持的应用程序版本此插件已经过测试，已知可支持以下应用程序版本：2020.3 - 2023请注意，此插件也许（甚至非常有可能）支持更新的发行版本，但是尚未正式在这些版本中进行测试。应用开发人员须知VRED 项目管理ShotGrid VRED 插件在每次启动时，都会将 VRED 项目设置为指向此插件的设置定义的位置。这意味着，当您打开新文件时，项目也可能会发生变化。可以使用模板系统，在配置文件中配置有关如何基于文件设置 VRED 项目的详细信息。使用 tk-vred此 ShotGrid 集成支持 VRED 产品系列（Pro 和 Design）。当 VRED 打开时，ShotGrid 菜单（VRED 插件）会添加到菜单栏中。“File Open”和“File Save”使用“我的任务”(My Tasks)和“资产”(Assets)选项卡可以查看您的所有已分配任务，并浏览资产。 在右侧，使用这些选项卡可以查看所有文件、与左侧选定内容关联的工作文件或已发布文件。发布(Publish)发布(Publish)：打开“发布”(Publish)对话框以将文件发布到 ShotGrid，然后供下游艺术家使用。有关 VRED 发布的详细信息，请参见此处。加载器(Loader)加载(Load)：打开内容加载器应用，并附有解释其工作原理的教学幻灯片。要查看有关 VRED 加载的详细信息，请参见此处。Scene BreakdownScene Breakdown：打开“Breakdown”对话框，其中显示“已参考”文件（及其链接）的列表，以及场景中过时或使用备用版本的 PublishedFile 的内容。",
    "url": "/9d824e0b/",
    "relUrl": "/9d824e0b/"
  },
  "183": {
    "id": "183",
    "title": "API",
    "content": "Toolkit API在此处，您可以找到适用于 Toolkit 平台提供的 API 的参考文档。",
    "url": "/6c5b0b61/",
    "relUrl": "/6c5b0b61/"
  },
  "184": {
    "id": "184",
    "title": "应用",
    "content": "Toolkit 应用在此处，您可以找到适用于 Toolkit 平台的应用的参考文档。",
    "url": "/f8596e35/",
    "relUrl": "/f8596e35/"
  },
  "185": {
    "id": "185",
    "title": "环境配置",
    "content": "环境配置参考简介Toolkit 工作流的核心是环境配置。在 Toolkit 工作流配置中，环境配置文件用于定义在不同的 DCC 中哪些 Toolkit 应用可用，以及为每个应用自定义相应设置。本文档提供了有关环境配置文件的结构和功能的完整参考，并涵盖了用于在一个项目中配置不同工作流的 Toolkit 环境概念、配置结构、文件引用以及可用自定义项确定方式。                    注意: 本文档提供了有关环境配置文件的参考，而有关“编辑工作流配置”的 Toolkit 基础知识手册提供了有关编辑配置设置的分步示例。    什么是环境？ShotGrid Toolkit 平台为常用内容创建软件提供了一组完全可自定义的集成，您可以通过其构建工作室工作流。在项目的配置中，您可以指定哪些软件包具有集成，在每个软件包中哪些特定 Toolkit 应用可用，以及针对每个应用所做的选择 - 构建符合工作室需求的美工人员工作流。但在工作室工作流中，通常情况下，不同类型的美工人员一般会采用不同的工作流。举一个简单的示例，对于处理资产的美工人员，您可能希望提供纹理绘制软件（如 Mari），而对于处理镜头的美工人员，您可能希望提供合成软件（如 Nuke）。除了软件包之外，对于不同的美工人员，同一 Toolkit 应用也可能需要使用不同的设置。例如，镜头艺术家和资产艺术家都可能使用 Workfiles 应用，但您可能希望对文件导航进行限制：对于前者，只能导航到与镜头实体关联的文件；对于后者，只能导航到与资产实体关联的文件。为了在一个项目中支持不同的工作流，Toolkit 跨环境分隔其应用和插件配置。一个环境中包含一组软件包的集成及其设置，所有这些都共用一个特定上下文。在上述示例中，处理资产的美工人员将在资产工序环境中工作，而处理镜头的美工人员将在镜头工序环境中工作。每个环境的配置操作都独立于任何其他环境，从而可以在一个项目中支持不同的工作流。Toolkit 的默认配置注意事项使用 Toolkit 时，您可以相当自由地构建环境配置。本文档提供了您可用的所有选项的参考，以便您掌握必要的知识来选择更适合特定工作流需求的选项。本文档也穿插提供了一些我们在作为起点提供的工作流配置（称为默认配置）中所做的特定选择。如果您已准备好自定义工作流，第一步是为您的项目创建一个可编辑的工作流配置。虽然这些选择只是惯例，并没有硬编码到 Toolkit 工作流中，但将默认配置作为示例进行参考很有用，可以了解在自定义工作流时可用的功能，并了解在构建自己的配置时可以应用的最佳实践。此外，由于这是面向 Toolkit 新用户的建议起点，因此有助于了解其中一些惯例。本文档中自始至终区分介绍 Toolkit 环境配置的常规功能和默认配置中的特定选择。有关默认配置的环境结构的特定详细信息，请参见其自述文件。文件位置在工作流配置中，config/ 目录包含要自定义的所有文件和文件夹。在 config/ 中，包含三个子目录：cache、core 和 env。env 目录包含环境配置文件，因此本文档将涉及 config/env 中的文件。在默认配置中，config/env/ 中包含以下文件：asset.ymlasset_step.ymlproject.ymlsequence.ymlshot.ymlshot_step.yml其中每个文件都对应于一个环境；通过采用单独的文件，可以单独配置每个环境。Toolkit 确定当前环境的方式Toolkit 使用称为 pick_environment 的核心挂钩来根据当前上下文确定要在给定时间使用的环境文件。pick_environment 挂钩的返回值对应于环境配置文件。例如，如果 pick_environment 返回 shot_step，则 Toolkit 将使用 config/env/shot_step.yml 配置 Toolkit 环境。自定义环境上面列出的环境配置文件是默认配置附带的文件。但是，一些工作室可能需要使用其他环境或额外的环境。例如，工作室可能需要为工作流的每个阶段（asset_step_rig、asset_step_model、shot_step_anim、shot_step_light 等）使用不同的配置设置。幸运的是，您可以完全自定义可用环境。为此，请将所需的环境配置文件添加到 config/env 目录中。然后，覆盖 pick_environment 核心挂钩，将定义何时使用新环境的逻辑添加到其中。基本结构Toolkit 的配置文件采用 YAML 编写。任何包（应用、插件或框架）的常规配置结构如下：bundle_name:  setting1: value  setting2: value  complex_setting:    sub_setting1: value      Sub_setting2: value  location:    type: descriptor_type    descriptor_setting1: value    descriptor_setting2: value为了说明此结构，此处提供一个非常简单的示例：在一个环境中有一个插件，此插件中定义一个应用。在此配置中 project.yml 的内容可能如下所示：engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4插件块每个环境配置文件都以 engines 块开头。其中嵌套了为相应环境定义的所有插件。在我们的示例中，只定义了一个插件：tk-maya。它有两个列出的设置：apps 和 location。location 是每个包都需要的特殊设置。apps 设置是为插件定义的所有应用列表，每个应用都有自己的设置。在此示例中，只为插件定义了一个应用：tk-multi-workfiles2。位置描述符每个 Toolkit 包都有一个 location 设置，我们将其称为包的描述符。描述符告知 Toolkit 在何处查找给定包，以及根据其类型，是直接访问它还是在本地缓存它。Toolkit 包可以来自多个位置，例如，ShotGrid 应用商店、git 库、磁盘上的路径或上传到 ShotGrid 站点的 zip 文件。其中每个位置都有一个对应的描述符类型，相应类型具有特定设置。下面是上述示例中 tk-maya 插件的描述符：    location:        type: app_store        name: tk-maya        version: v0.9.4这是类型为 app_store 的描述符，此描述符告知 Toolkit 从 ShotGrid 应用商店获取给定包。类型为 app_store 的描述符具有设置 name 和 version。相反，如果您正在开发自定义包 - 即您正在为工作室中的一个特定工作流编写一个 Toolkit 应用，您可能希望直接从磁盘上的路径获取它。在此示例中，将使用类型为 dev 的描述符，它可能如下所示：    location:        type: dev        path: /path/to/appdev 描述符的设置与 app_store 描述符的设置不同。虽然它可以采用其他设置，但可以直接为其设置指向应用所在磁盘位置的 path 设置。有关所有可用描述符类型及其设置的详细信息，请参见 Toolkit 核心 API 文档的“描述符”部分。应用块应用是 Toolkit 的用户工具，每个应用都可以独立于任何其他应用运行。您可以根据工作流需求选择要使用的应用，而插件块内的 apps 设置用于定义在给定插件中哪些应用可用。下面是上述示例中的 apps 设置：engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8您可以看到我们定义了一个应用：tk-multi-workfiles2 应用。当前它只定义了一个设置：其描述符。如果您要在 project 环境的 tk-maya 插件中提供其他应用，可以在此处添加它们。现在将 Panel tk-multi-shotgunpanel 和 About 应用 tk-multi-about 添加到插件中。示例 project.yml 文件现在如下所示：engines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4现在要注意几个重要事项：  默认配置按字母顺序列出包，此示例遵循此惯例。  文件会开始变长，即使尚未添加任何配置设置也是如此。  您可以设想将在其他插件和其他环境中使用这些应用。例如，您可能将在不同的插件（如 Houdini、Nuke 或 Photoshop）和不同的环境（如 asset_step 或 shot_step）中使用所有这三个应用（Panel、About 应用以及 Workfiles 应用）。在配置中的多个位置定义常用应用设置，这意味着进行更改时，必须在多个位置进行修改。为了解决最后两个问题，Toolkit 支持 includes。includes通过 includes，可以在配置中的一个文件中引用其他文件的一部分。通过使用 includes，可以在一个位置设置一个配置设置，但在多个环境中使用它。includes 包括两个部分：  includes 列表：YAML 词典，其键为 includes，其值为我们要从其包含的所有文件列表。  配置设置中的引用，带有 @ 符号前缀，并命名为指向要从包含的文件引用的部分的名称。为了充实上述示例，可以使用一个文件存放所有插件的位置描述符。我们将该文件放在 includes 子文件夹中，并将其命名为 engine_locations.yml。engine_locations.yml 的内容如下所示：config/env/includes/engine_locations.yml：engines.tk-maya.location:  type: app_store  name: tk-maya  version: v0.9.4engines.tk-nuke.location:  type: app_store  name: tk-nuke  version: v0.11.5...此文件可以用作所有插件位置的单个源，而且所有环境配置都可以引用它。使用此包含文件后，我们的示例现在如下所示：config/env/project.yml：includes:- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location: @engines.tk-maya.location在此处可以看到，tk-maya 插件的 location 设置的值现在是对包含的 YAML 文件中的一个键的引用。                    注意: 将所有插件位置放在 config/env/includes/engine_locations.yml 文件中（如在此示例中所做）时遵循默认配置的惯例。    可以添加另一个包含文件用于存放应用位置，实际上，默认配置就是这么做的。我们来扩展一下示例：config/env/includes/app_locations.yml:apps.tk-multi-about.location:  type: app_store  name: tk-multi-about  version: v0.2.8apps.tk-multi-shotgunpanel.location:  type: app_store  name: tk-multi-shotgunpanel  version: v1.6.3apps.tk-multi-workfiles2.location:  type: app_store  name: tk-multi-workfiles2  version: v0.11.8config/env/project.yml：includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.location现在，我们从包含的 engine_locations.yml 文件中获取 tk-maya 插件的描述符，从包含的 app_locations.yml 文件获取为 tk-maya 插件定义的每个应用的描述符。                    注意: 默认配置使用一个第二层嵌套（未在此处说明）。还具有描述符以外的设置的每个应用或插件在 includes/settings 中都有一个设置文件（如 includes/settings/tk-maya.yml 和 includes/settings/tk-multi-workfiles2.yml）。插件设置文件包含应用设置文件中的应用设置，环境配置文件包含插件设置文件中的插件设置。有关默认配置结构的详细信息，请参见其自述文件。有关修改配置设置的详细介绍，请参见有关“编辑配置设置”的 Toolkit 基础知识手册。    简约配置每个 Toolkit 包都有一组可用的配置设置，每个设置都有默认值。Toolkit 允许使用简约配置：如果未在环境配置文件（和/或其包含的文件）中明确指定配置设置，则将使用包中的默认值。在我们的示例中，除了 location 外，我们没有为应用指定任何设置。因此，在配置的当前状态中，三个应用的所有设置都将使用默认值。那么，我们如何知道哪些配置设置可用？                    注意: 虽然不要求 Toolkit 配置是简约配置，但默认配置是简约配置。    确定可用配置设置使用简约配置时，难以直接通过查看配置文件确定哪些配置设置可用于应用。要确定应用有哪些配置设置可用，可以采用两种方式：  应用文档：每个应用都有其自己的文档页面，每个页面都有“配置选项”部分。此部分列出相应应用的所有可用配置设置，每个设置都有说明和默认值。例如，您可以查看 Workfiles 文档页面。应用和插件页面列出了所有应用和插件的文档页面。  清单文件：每个 Toolkit 包的根目录中都包含一个名为 info.yml 的文件。我们将此文件称为包的清单文件，此文件定义相应包的所有可用配置设置，每个设置都有说明和默认值。您可以在自己的包缓存中查找清单文件（例如工作流配置中的 install/app_store/tk-multi-workfiles2/v0.11.8/info.yml），也可以在 Github 中查找清单文件（例如，此处是 Workfiles 的清单文件）。修改配置设置要修改某个配置的默认值，只需在工作流配置中的适当环境中将其添加到相应块中，并设置其值。回到我们的示例，假设我们要配置 tk-multi-workfiles2，以便在项目环境中启动 Maya 时它会自动启动。我们可以在应用的清单文件中看到有一个 launch_at_startup 设置（用于控制是否在应用程序启动时启动 Workfiles UI），其默认值为 False。因此，我们只需添加 launch_at_startup 选项，并将其设置为 True。project.yml 文件现在如下所示：config/env/project.yml：includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        launch_at_startup: True        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.location请注意，如果 tk-multi-workfiles2 的设置来自一个包含的文件，我们将在该文件中进行此更改。其他资源  Toolkit 基础知识手册：编辑工作流配置  Toolkit 基础知识手册：添加应用  动画工作流教程  描述符参考文档  网络讲座：Toolkit 管理  文件系统配置参考  默认配置环境结构自述文件",
    "url": "/c73fcb84/",
    "relUrl": "/c73fcb84/"
  },
  "186": {
    "id": "186",
    "title": "配置",
    "content": "Toolkit 配置在此处，您可以找到有关配置 Toolkit 平台的参考文档",
    "url": "/10e8ee51/",
    "relUrl": "/10e8ee51/"
  },
  "187": {
    "id": "187",
    "title": "如何使用 ShotGrid 事件进程加载不同的 Toolkit 核心模块？",
    "content": "如何使用 shotgunEvent 进程加载不同的 Toolkit 核心模块？非常感谢 Benoit Leveau @ Milk VFX 分享此信息。问题Toolkit 的 sgtk API 以项目为中心。换句话说，您必须专门从要使用它的项目导入此 API。这意味着，如果您在单个 Python 会话中对多个项目使用 sgtk API 操作，您将会遇到问题，因为 Python 仅允许具有相同名称的模块导入一次。如果您使用的是 ShotGrid 事件进程，您可能需要在特定事件对应的插件内部执行 Toolkit 操作。这并非易事，因为 Python 仅导入一次模块。因此，如果您在第一次运行该插件时导入了用于项目 A 的 Toolkit 核心 API，则在此进程的使用周期内将始终导入该版本。这意味着，如果分派给该插件的下一个事件用于项目 B，则当您尝试使用来自项目 A 的核心 API 实例化用于项目 B 的新 Toolkit 对象时，可能会发生错误。使用集中式配置时的问题示例：  事件 123 用于项目 A。  项目 A 的核心 API 位于 /mnt/toolkit/projectA/install/core/python。  在 sys.path 前面加上此目录。  import sgtk 从该位置导入。  使用此核心 API 实例化一个 Toolkit 实例并执行一些操作。  将核心 API 目录从 sys.path 中去掉。  事件 234 用于项目 B。  项目 B 的核心 API 位于 /mnt/toolkit/projectB/install/core/python。  在 sys.path 前面加上此目录。  import sgtk 不会执行任何操作，因为 Python 发现它已经导入了 sgtk。  使用此核心 API 实例化一个 Toolkit 实例并执行一些操作。  这将导致错误，因为 Toolkit 核心用于项目 (A)，而不是您尝试执行操作的项目 (B)。解决方案下面的示例说明了在可能已经导入不同版本模块的情况下，如何在脚本或插件中导入正确版本的 sgtk 核心。原始导入将会卸载并从 Python 内存中移除，这样，便可成功导入并使用新的模块实例。&quot;&quot;&quot;Example of how to import the correct sgtk core code in a script wherea different instance of the module may have already been imported. Theoriginal import is unloaded and removed from memory in Python so the newinstance of the module can be imported and used successfully.Thanks to Benoit Leveau @ Milk VFX for sharing this.&quot;&quot;&quot;import osimport sysdef import_sgtk(project):    &quot;&quot;&quot;    Import and return the sgtk module related to a Project.    This will check where the Core API is located on disk (in case it's localized or shared).    It shouldn't be used to get several instances of the sgtk module at different places.    This should be seen as a kind of 'reload(sgtk)' command.    :param project: (str) project name on disk for to import the Toolkit Core API for.    &quot;&quot;&quot;    # where all our pipeline configurations are located    shotgun_base = os.getenv(&quot;SHOTGUN_BASE&quot;, &quot;/mnt/sgtk/configs&quot;)    # delete existing core modules in the environment    for mod in filter(lambda mod: mod.startswith(&quot;tank&quot;) or mod.startswith(&quot;sgtk&quot;), sys.modules):        sys.modules.pop(mod)        del mod    # check which location to use to import the core    python_subfolder = os.path.join(&quot;install&quot;, &quot;core&quot;, &quot;python&quot;)    is_core_localized = os.path.exists(os.path.join(shotgun_base, project, &quot;install&quot;, &quot;core&quot;, &quot;_core_upgrader.py&quot;))    if is_core_localized:        # the core API is located inside the configuration        core_python_path = os.path.join(shotgun_base, project, python_subfolder)    else:        # the core API can still be localized through the share_core/attach_to_core commands        # so look in the core_Linux.cfg file which will give us the proper location (modify this        # to match your primary platform)        core_cfg = os.path.join(shotgun_base, project, &quot;install&quot;, &quot;core&quot;, &quot;core_Linux.cfg&quot;)        if os.path.exists(core_cfg):            core_python_path = os.path.join(open(core_cfg).read(), python_subfolder)        else:            # use the studio default one            # this assumes you have a shared studio core installed.            # See https://developer.shotgridsoftware.com/b12f2510/#how-do-i-share-the-toolkit-core-between-projects            core_python_path = os.path.join(shotgun_base, &quot;studio&quot;, python_subfolder)    # tweak sys.path to add the core API to the beginning so it will be picked up    if sys.path[0] != &quot;&quot;:        sys.path.pop(0)    sys.path = [core_python_path] + sys.path    # Remove the TANK_CURRENT_PC env variable so that it can be populated by the new import    if &quot;TANK_CURRENT_PC&quot; in os.environ:        del os.environ[&quot;TANK_CURRENT_PC&quot;]    # now import the sgtk module, it should be found at the 'core_python_path' location above    import sgtk    return sgtk分布式配置上述示例假设您使用的是集中式配置，但是，如果您使用的是分布式配置，情况可能略有不同。要为分布式配置导入 sgtk API，您需要使用引导 API。使用引导 API 时，您通常应首先导入不以项目为中心的 sgtk API，然后使用此 sgtk API 为指定项目引导插件。引导过程将换出 sgtk 模块，以便在引导过程结束后具有插件对象。如果在引导后导入 sgtk，它将导入适合您的项目的相关 sgtk 模块。在上面的示例中，需要为多个项目加载 sgtk，因此需要针对多个项目进行引导。有一个小问题是您一次只能运行一个插件，因此您在加载其他插件之前必须将其破坏。                    警告: 引导配置可能会很慢，因为此过程需要确保在本地缓存配置并且将下载所有依存关系。在事件进程插件中引导可能会严重影响性能。一种可能的方法是，针对每次项目引导添加单独 Python 实例，以便从插件进行通信和发送命令。这将避免在每次需要项目时必须重新引导它。    下面提供一个示例：# insert the path to the non project centric sgtk APIsys.path.insert(0,&quot;/path/to/non/project/centric/sgtk&quot;)import sgtksa = sgtk.authentication.ShotgunAuthenticator()# Use the authenticator to create a user object.user = sa.create_script_user(api_script=&quot;SCRIPTNAME&quot;,                            api_key=&quot;SCRIPTKEY&quot;,                            host=&quot;https://SITENAME.shotgunstudio.com&quot;)sgtk.set_authenticated_user(user)mgr = sgtk.bootstrap.ToolkitManager(sg_user=user)mgr.plugin_id = &quot;basic.&quot;engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity={&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176})# import sgtk again for the newly bootstrapped project, (we don't need to handle setting sys paths)import sgtk# perform any required operations on Project 176 ...# Destroy the engine to allow us to bootstrap into another project/engine.engine.destroy()# now repeat the process for the next project, although we don't need to do the initial non-project centric sgtk import this time.# We can reuse the already import sgtk API to bootstrap the next...                    注意: 也可以引导集中式配置，因此如果您使用混合配置，也可以使用相同的方法。    ",
    "url": "/3520ad2e/",
    "relUrl": "/3520ad2e/"
  },
  "188": {
    "id": "188",
    "title": "Toolkit 插件支持的操作系统版本",
    "content": "Toolkit 插件支持的操作系统版本下面列出了 Toolkit 插件支持的操作系统。            Windows      macOS      Linux                  10      10.14+ 注意：不支持 M1 原生，但支持搭载 Rosetta 算法的 M1，请单击此处了解详细信息。      CentOS 7.4、Rocky 8.5      ",
    "url": "/918daccf/",
    "relUrl": "/918daccf/"
  },
  "189": {
    "id": "189",
    "title": "插件支持的版本",
    "content": "Toolkit 插件支持的版本下面列出了适用于 Toolkit 平台的插件上支持的最低应用程序版本。            集成      插件      支持的版本                        tk-3dsmax      2020 - 2023                    tk-aftereffects      2020 (v17.0) - 2023 (v23.6)                    tk-alias      2020 - 2023                    tk-flame      2020+                    tk-houdini      17.5 - 19.5 Note: Running on Apple Silicon (M1/M2), Houdini is supported for both Native mode and Rosetta mode.                    tk-mari      4.0 - 6.0v2                    tk-maya      2020 - 2024 Note: Apple Silicon (M1/M2) native is supported starting with Maya 2024.                    tk-motionbuilder      2020 - 2024                    tk-nuke      12.0 - 14.0v5                    tk-photoshopcc      2020 (v21.0) - 2023 (v24.7) Note: Apple Silicon (M1/M2) native is not supported, Apple Silicon with Rosetta is supported, learn more here.                    tk-vred      2020.3 - 2023      ",
    "url": "/cc3d2160/",
    "relUrl": "/cc3d2160/"
  },
  "190": {
    "id": "190",
    "title": "引擎",
    "content": "Toolkit 插件在此处，您可以找到适用于 Toolkit 平台的插件的参考文档。",
    "url": "/3a69db47/",
    "relUrl": "/3a69db47/"
  },
  "191": {
    "id": "191",
    "title": "框架",
    "content": "Toolkit 框架在此处，您可以找到适用于 Toolkit 平台的框架的参考文档。",
    "url": "/c6db88dd/",
    "relUrl": "/c6db88dd/"
  },
  "192": {
    "id": "192",
    "title": "Toolkit 概述",
    "content": "Toolkit 概述简要介绍 ShotGrid Pipeline Toolkit 中的各种概念。在本文中，我们将详细介绍各种主要概念，其中包括：应用和插件的工作方式、Toolkit 如何启动和管理当前上下文（工作区）、如何在磁盘上创建文件夹等。我们建议参与配置或开发的所有人都从此处开始。请注意，本文档介绍仅当您控制了 Toolkit 配置时才可用的功能。有关详细信息，请参见 ShotGrid 集成管理员手册。简介本文档将更深入地为您讲解一些主要功能。通过讲解、示例和简短的演示，我们将带您全面了解 Toolkit。如果您想熟悉 Toolkit，或者想了解 Toolkit 如何为您的工作室带来价值，从本文档开始是个不错的选择。读完本文档后，您将很好地掌握一些主要概念以及它们在实践中的应用。下面是 Toolkit (SGTK) 的简要说明：  Toolkit 是一个基于 ShotGrid 平台的 Pipeline Toolkit，通过它可以更轻松地为工作室编写和安装各种工具。  Toolkit 基于文件系统 - 它可以帮助您组织管理各种内容在磁盘上的存储，让磁盘内容井井有条。  Toolkit 是得力的助手 - 它并不会试图接管您工作流中的数据或对它们进行抽象，而是为艺术家提供强大的工具，帮助他们更轻松地查找信息和避免错误。  Toolkit 通过将所有发布存储在 ShotGrid 中来帮助您共享工作。Toolkit 使您可以在制作过程中轻松共享更新和正在进行的工作。在接下来的部分中，我们将深入了解 Toolkit 以及它的工作方式。项目和配置在 Toolkit 中，一切都以项目为中心。项目通常从 ShotGrid 内开始生命周期，经过投标和前期制作阶段，然后，为内容创建阶段做好准备后，即可将 Toolkit 用于该项目。在设置新项目时，您需要使用 模板配置 。这是一个预定义配置，其中包含插件和应用、文件系统配置和其他设置。如果您是刚刚开始接触 Toolkit，可以先使用我们的示例配置，以此为出发点开始探索。如果您已在另一个项目中使用 Toolkit，建议以那个项目的配置为基础开始新项目。这样，您将逐步形成并发展出一个工作室配置，然后针对每个新项目优化该配置。当然，也可以单独维护一个工作室配置，将它用作所有新项目的模板。每个配置都定义了一些 存储点 。对于标准示例配置 tk-config-default，我们定义了一个称为 primary 的存储点。这意味着您的所有制作数据将位于一个文件系统项目根目录下。您也可以设置具有多个文件系统根目录的配置。我们将这类配置称为 多存储配置 。例如，当您为渲染和剪辑等内容分别设置了单独的存储时，就需要使用多存储配置。每个存储点在 ShotGrid 中需要以 本地文件存储 的形式存在 - 您可以在“站点偏好设置”(Site Preferences)中的 “文件管理”(File Management) 选项卡下设置这些。Toolkit 会将实际项目配置安装在您喜欢的任意位置。通常，这将转到磁盘上的 软件安装 区域，而不是项目数据区域本身。逐步发展您的工作室配置设置新项目时，您可以使用现有项目作为基础。Toolkit 会将该项目的配置文件夹复制到您的新项目。这意味着，新项目将获得与它基于的项目完全相同的应用和插件版本、相同的设置和相同的自定义。如果您想 逐步发展完善自己的工作流 ，并利用现有制作中所做的改进和调整，此功能非常有用。或者，如果您对某个项目的设置满意，也可以直接选择该项目的配置文件夹，将它另存到别处的某个集中位置。随后可以将此配置用作工作室模板，每次创建新项目时以此配置为基础。如果需要，您甚至可以使用诸如 Git 等修订控制系统控制此工作室模板配置的源代码，并能简单、透明地跟踪工作流配置模板如何随时间逐步完善。每当您想要更新模板时，只需复制一个项目的配置并提交更改即可。有关配置管理的详细信息，请查看我们的详细文档：管理您的项目配置。每个项目各有一个工作流配置每当您为项目设置 Toolkit 时，都会创建一个工作流配置。此配置包含项目需要的所有设置和文件。配置有一个专用的 tank 命令，当您想直接处理该项目时，可以在 Shell 中运行此命令（另外还有一个适用于所有项目的全局 tank 命令）。在 ShotGrid 中，工作流配置已注册为一个特殊的工作流配置实体，以易于跟踪项目配置在磁盘上的位置。除了设置项目时创建的主配置外，您还可以为项目创建另外的配置。当您想更改配置但又不想影响项目的所有用户时，这种做法通常很有用。要创建另外的配置，可以在 ShotGrid 中导航到一个工作流配置，单击鼠标右键并选择克隆该配置即可。这将会基于另一个工作流配置为项目创建一个新配置。使用这个新配置，您可以在不影响其他用户的情况下安全地测试新应用。请注意，项目的主配置需要命名为 Primary。如果您重命名、修改或删除主配置，项目可能无法正常工作。存储在 ShotGrid 中的工作流配置不是手动操纵的，而是通过各种特定的 tank 管理命令来操纵。示例：如何克隆配置检查更新与其他应用商店类似，Toolkit 应用商店会经常发布新版本的应用和插件。这些新版本可能包含重要的错误修复或有趣的新功能。升级应用和插件并不是强制性的要求。这个过程通常很快，升级脚本在进行任何更改前都会提示您。同样，如果您意外安装了不满意的版本，回退也很简单直接。一个命令控制整个升级过程。只需运行位于项目配置文件夹中的 tank 命令，并添加 updates 参数：/software/shotgun/bug_buck_bunny/tank updates运行此命令时，如果不添加任何参数，将检查所有环境、插件和应用。这可能需要花费很长时间，但您也可以对一部分已安装的应用和插件运行更新程序。一般语法：tank updates [environment_name] [engine_name] [app_name]可以使用特殊关键词 ALL 表示一个类别中的所有项。示例：  检查所有内容：tank updates  检查镜头环境：tank updates Shot  检查所有环境中的所有 Maya 应用：tank updates ALL tk-maya  检查镜头环境中的所有 Maya 应用：tank updates Shot tk-maya  确保所有地方的加载器应用保持更新：tank updates ALL ALL tk-multi-loader  确保 Maya 中的加载器应用保持更新：tank updates ALL tk-maya tk-multi-loader除了检查应用商店，此脚本还会检查其他所有注册的位置。因此，它可能会查询您本地的 Git、GitHub 库、磁盘上的文件和应用商店，具体取决于各个应用的部署位置。请注意，新版本的应用可能会引入应用配置方面的更改。例如，某项新功能可能会需要新的配置参数。这种情况下，tank 升级脚本会提示您键入这些参数的值。检查核心 API 的更新有时，我们会发布新版本的 Toolkit 核心 API。有一个单独的命令用来更新核心 API。在本例中，该命令为 tank core。在磁盘上创建文件夹为项目设置 Toolkit 后，可以使用它帮助您创建一致的文件夹结构。可以通过在磁盘上的工作流配置中创建文件系统模板，来配置此文件夹结构。在此文件夹结构中，某些路径是动态路径。例如，您可以用一个名为 asset 的文件夹来表示 ShotGrid 资产实体。这些动态文件夹可以与 ShotGrid 查询和许多其他对象相连。Toolkit 提供多种不同类型的动态文件夹，用来应对不同的设置和情况。设置文件夹创建方式时，您可以使用标准 ShotGrid API 查询语法。您可以组织文件系统，将不同类型的资产归入文件系统上的不同文件夹。有关如何操作的详细介绍，请参见管理员手册：管理 ShotGrid Pipeline ToolkitToolkit 的文件夹创建操作分为两个过程 - 一个是直接过程，任何人在任何时间都可以运行；另一个是延迟过程，通常由艺术家在应用程序临启动前运行。延迟过程完全自动，并可用来设置应用程序特定的文件夹和用户沙盒。当前上下文创建文件系统结构后，Toolkit 会知道磁盘上的文件夹与派生该文件夹的 ShotGrid 对象之间的关系。这一点很重要，因为这样 Toolkit 才能很容易地在发布、加载或解析路径时将 ShotGrid 中的对象与磁盘上的文件夹或文件相关联。另外，它还与我们所说的 上下文 或 当前工作区 有关。上下文对象是 Toolkit 核心的一部分，可跟踪当前正在处理的内容。这是 Toolkit 解析文件系统路径时的一个中心机制。我们可以从任务、资产或镜头等 ShotGrid 对象创建上下文，也可以从磁盘路径创建上下文。应用在运行时始终可以访问上下文，这让构造应用变得很容易，您不需要了解文件系统的命名约定，也不必知道应用是用在资产工作流中还是镜头工作流中。所有这些全部由 Toolkit 核心 API 和上下文处理。文件系统模板Toolkit 核心包含一个处理文件路径的系统。我们称之为 模板系统 。由于 Toolkit 基于文件系统，因此每当应用需要在磁盘上读取或写入数据时，都需要解析文件路径。应用对文件系统结构不了解，这意味着它们不知道文件系统的组织结构。模板系统负责为它们处理这一切。在模板系统的核心，有一个 模板配置文件 。此文件包含项目的所有重要文件系统位置。模板 与下面类似：maya_shot_publish: 'shots/{Shot}/{Step}/pub/{name}.v{version}.ma'模板本质上定义了一个包含一些动态字段的路径。每个字段都可以配置验证和键入内容，例如您可以定义上面模板中的 {version} 字段是一个填充三个零的整数（例如 001、012、132）。每当应用需要在磁盘上写入或读取数据时，都会向模板文件中添加一个描述该位置的模板。由于应用通常会构成一个工作流，因此一个应用（例如发布应用）的输出模板往往是另一个应用（例如加载应用）的输入模板。这就是所有文件系统位置都保留在一个文件内的原因。模板 API 让您可以在一系列字段值和路径之间跳转：# get a template object from the API&amp;gt;&amp;gt;&amp;gt; template_obj = sgtk.templates[&quot;maya_shot_publish&quot;]&amp;lt;SGTK Template maya_asset_project: shots/{Shot}/{Step}/pub/{name}.v{version}.ma&amp;gt;# we can use the template object to turn a path into a set of fields...&amp;gt;&amp;gt;&amp;gt; path = '/projects/bbb/shots/001_002/comp/pub/main_scene.v003.ma'&amp;gt;&amp;gt;&amp;gt; fields = template_obj.get_fields(path){'Shot': '001_002', 'Step': 'comp', 'name': 'main_scene', 'version': 3}# alternatively, we can take a fields dictionary and make a path&amp;gt;&amp;gt;&amp;gt; template_obj.apply_fields(fields)'/projects/bbb/shots/001_002/comp/pub/main_scene.v003.ma'请注意，上述路径和模板具有两种不同类型的字段。Shot 和 Step 字段是高级字段，在 ShotGrid 中具有等效对象（镜头和工作流工序），而 name 和 version 字段则特定于此特定类型的模板。如果我们想描述一个资产（而非镜头）的发布路径，仍然会有 name 和 version 字段，因为这是所有发布都需要的，无论数据类型如何。但是，将不会有 Shot 和 Step 字段。相反，可能会有 Asset 和 Step 字段，其中的 asset 字段会与 ShotGrid 中的某个资产相关联。在开发用于发布类操作的应用时，很显然我们不想使用单独的应用分别执行镜头发布和资产发布。我们更希望开发一个可以应对任何发布情景的发布应用，无论要发布的是场、镜头、资产还是其他任何内容。这时就需要用到 Toolkit 上下文。Toolkit 上下文让我们可以将模板字段分为两个不同的组；上下文字段（Shot、Step、Asset 等）是我们想确保在应用外部解析的字段 - 这样应用逻辑就不必包含专门用于处理镜头和资产这类概念的代码。应用只需填充与应用的特定 业务逻辑 直接关联的字段。在我们的发布应用示例中，业务逻辑由 name 和 version 字段组成。因此，如上图所示，Toolkit 会将字段解析分为两个不同阶段：一些字段由上下文填充，另一些字段则由应用内部的业务逻辑填充。这样，应用的设计便可不局限于特定的文件系统布局。我们认为这是构建良好工作流工具的一个重要方面。处理路径解析的应用代码通常如下所示：# start with an empty fields dictionaryfields = {}# first let the context populate all its fieldsfields.update( self.context.as_template_fields( publish_template_obj ) )# fields is now {'Shot': '001_002', 'Step': 'comp' }# now the app can add its business logicfields[&quot;name&quot;] = &quot;main_scene&quot;fields[&quot;version&quot;] = 234# and finally the app can produce the path it needs in# order to save out the filepath = publish_template_obj.apply_fields(fields)有关您可以如何配置和使用模板 API 的更多详细信息，请参见以下内容：文件系统配置参考核心 API 参考选择要运行的插件和应用Toolkit 核心的另一个重要作用是决定 应向用户显示哪些应用 。如果您在处理角色装配工作并启动了 Maya，可能会需要一套与进行镜头照明工作时不同的应用。此外，应用的配置可能会因您需要的操作方式而异。因此，同一个审核应用，用于装配时可能会生成一个转台，而当动画设计师运行它时，则会使用镜头摄影机播放动画预览。为了实现这种灵活性，Toolkit 项目配置包含一系列 环境 。一个环境就是一个配置文件，用来定义一套应用和插件，以及它们的所有配置参数。Toolkit 启动时，需要决定对 哪个 环境进行初始化。这通过一段称为 挂钩 的 Python 代码来实现，您可以在其中添加自己的业务逻辑。上下文 对象将传递到这段代码中，这通常用于确定要使用哪个环境。这样，您便可以为工作流的不同环节配置一套单独的应用。此外，您还可以独立更新它们，甚至安排不同的主管分别管理它们。默认配置中的环境为了给您一个实际示例来说明环境的工作方式和结构，我们来看一下默认配置随附的环境：  project.yml - 当上下文仅包含项目时要运行的应用和插件。  shot_and_asset.yml - 当上下文包含镜头或资产时要运行的应用和插件。  shot_step.yml - 当上下文包含镜头和工作流工序时要运行的应用和插件。  asset_step.yml - 当上下文包含资产和工作流工序时要运行的应用和插件。默认配置基于工作流工序来组织其文件系统。这意味着在某个镜头位置下，您可以看到针对建模和装配等的文件夹。实际上，您所执行的每个工作流工序都有一个对应的文件夹。每个文件夹在磁盘上都有自己的工作区和发布区。这意味着发布模板可能如下所示：maya_shot_publish: 'sequences/{Sequence}/{Shot}/{Step}/pub/{name}.v{version}.ma'为了使用此模板，上下文需要同时包含一个实体和一个工作流工序。对于父场 ABC 下的镜头 1122 和 Modeling 这个工作流工序，上面的模板将解析为 sequences/ABC/1122/Modeling/...。这意味着，一个包含镜头但不包含工作流工序的上下文并不足以填充上面的模板。您无法为仅镜头上下文启动 Maya，并使用上述模板。为使其正常运行，需要一个工序。这样我们就得出了上面所示的环境细分。由于默认配置中定义的文件系统结构以工序为中心，因此所有主要应用都需要在一个定义了工序的上下文中运行。我们在默认配置中定义了两个这样的环境：asset_step.yml 文件和 shot_step.yml 文件。每个文件都包含针对多个 DCC（例如 Maya、Nuke、3ds Max、MotionBuilder、Photoshop 等）的插件。当您从 ShotGrid 内的任务启动 Maya 时，选取环境挂钩将选择 shot_step 环境，启动 Maya 并加载 Maya 应用配置。有时候，直接从 ShotGrid 内的镜头对象启动 Maya 也是有用的。更重要的是，能在控制台中键入 tank Shot 1122 launch_maya 真的是一项非常实用的功能。这时就需要用到 shot 和 asset 环境。当您为 Maya 加载一个包含镜头或资产但不包含工作流工序的上下文时，它将会加载其中一个环境。由于文件系统结构都是按工作流工序组织的，因此如果我们的上下文中缺少该信息，实际上不能进行任何加载或发布。Maya 会使用一个空配置启动，其中仅包含 Workfiles 应用。此应用用于选择要处理的任务。选取任务后，Toolkit 会为您切换上下文并重新启动插件，还会为 shot_step 环境加载全套应用。同样，project 环境是一个适合所有情况的备选方案，它也只包含 Workfiles 应用。这使您几乎可以从项目内的任何地方启动 Maya，它会对 Toolkit 进行最小程度的初始化，让您可以使用 Workfiles 应用跳转到有效的工作区。配置应用每个应用都有一些需要指定的配置参数。当您安装或升级某个应用时，Toolkit 会确保您指定了所有必需的设置。简单的设置值（如字符串或整数值）直接在环境配置中指定。各个模板是不同的，由于 Toolkit 要将所有模板保存在一处，因此环境文件只是指向模板文件中定义的模板。每个应用在其配置中使用的模板需要的字段各不相同。在前面的示例中，发布应用在磁盘上创建输出文件时，使用一个包含 name 和 version 字段的模板。因此，该应用的一项配置设置需要使用包含 name 和 version 字段的模板。如果您配置应用时尝试使用的模板包含比 name 和 version 上下文字段更多的字段，应用将不知道如何填充这些额外的字段，也无法根据该模板生成路径。同样，如果您提供的模板缺少其中某个字段，会导致结果混淆。在我们的示例中，将不会为应用写出版本号。因此，Toolkit 会在启动时验证配置，确保您为所有模板提供了必要的字段。Toolkit 还支持几种使用默认值和可选字段的方式。有关完整参考，请查看以下链接：应用和插件配置参考文件系统配置参考挂钩除了使用模板的应用设置外，Toolkit 还支持称为 挂钩 的概念。挂钩是小段的 Python 代码片段，让您可以在配置中自定义应用的各个部分。下面我们来介绍它是如何工作的，以及为什么它非常有用。应用之所以强大，是因为它们可以在多个插件和项目中重复使用。但是，应用往往需要一些特定于插件逻辑的小段代码。例如，如果我们要构建一个可同时在 Nuke 和 Maya 中运行的加载器应用，就需要有处理 实际文件加载 操作的代码，而这些代码在 Nuke 和 Maya 中必然是不同的。不仅如此，我们还希望此应用最好能用于任何插件！不同工作室向场景中加载内容项的方式也有所不同，有些工作室可能需要支持自定义的 Maya 引用节点，有些则只要执行导入即可。在 Toolkit 中，这种情况可以使用 挂钩 来解决。挂钩是一段可自定义的代码。应用随附一个默认挂钩，其中包含一个基础执行，这意味着应用可以开箱即用。但是，如果您想自定义行为，可以将默认挂钩文件复制到您的配置中，Toolkit 会改为使用该代码。阅读《管理员手册》了解有关使用挂钩的详细信息。从 ShotGrid 和 Shell 运行安装 Toolkit 之后，您可以从几个主要的入口点访问它：  ShotGrid 内的右键单击菜单上将显示 ShotGrid 动作  ShotGrid Desktop 应用中的项目将显示启动图标  您可以在控制台中使用 tank 命令。  在应用程序内和 Shell 中均可使用 Toolkit 的 Python API。从 ShotGrid 内运行 Toolkit 是一种启动应用程序和执行任务的常见方式。ShotGrid 将使用 ShotGrid Desktop 与计算机本地安装的 Toolkit 进行通信，并使用本地 Python 执行 Toolkit 命令。这意味着您可以直接从 ShotGrid 内运行创建文件夹等本地操作。您还可以从 Shell 访问 Toolkit。每个项目配置随附属于自己的 tank 命令。您只需导航到项目配置的根目录，在其中执行 ./tank 命令即可。最后，您可以直接将 Toolkit API 添加到 PYTHONPATH 环境变量，然后将其导入。使用 API 非常简单直接。如果您想在 Maya 内手动启动 Toolkit，或者想将它作为现有工作室启动系统的一部分，那么可以不使用 ShotGrid Desktop，只需执行几个简单的命令即可。正在发布当您想与其他人共享自己正在处理的文件时，可以发布这些文件。这意味着将在 ShotGrid 中创建一个 PublishedFile 实体，其他用户可以使用 Toolkit 的加载器应用导入该实体。这种做法对于数据管理（数据在磁盘上的存储位置、文件包含的内容等）到底意味着什么，交给处理实际工作的应用去考虑。Toolkit API 为开发人员提供了各种方法，让他们可以轻松在 ShotGrid 内创建发布，并将这些发布链接到正确的对象，以确保 ShotGrid 可以直接将通知推送给所有合适的人员。我们还提供一个默认的发布应用，它不仅功能灵活多样，而且可配置程度很高，但这并不是使用 Toolkit 执行版本控制的唯一途径。因为 Toolkit 可扩展，所以如果需要，您可以使用 Toolkit 打造自己的自定义版本控制和发布系统。但是一开始，建议您使用我们的发布应用：默认的 Multi Publish 应用。构建可重用的应用Toolkit 不止是一套应用和插件。它还是一个框架，您可以用它开发自己的工具和技术！我们已在 Toolkit 中包含了大量功能，将它打造成一个功能丰富的工作室开发平台。有了 Toolkit 作为基础，您可以专注于解决手中的问题，而不必花费精力自己构建基础平台。我们努力让开发人员可以在不意外打断艺术家工作流的前提下轻松构建、评估和发布软件。  插件将确保无论底层基础是什么，开发人员都可以使用 Python 和 Qt (PySide/PySide2) 编写应用。这意味着，有些插件非常简单，而有些插件较为复杂，具体取决于其提供的 API。因此，工作室有一种直观、一致的方式来开发工具。根据我们的经验，Python 和 Qt 是工作室常用的开发环境，许多技术总监都熟悉它们。  插件层还有一个好处，那就是应用只需编写一次，便可在多种环境中部署。我们将开发的标准应用套件称为 多应用 ，意思是同一个应用适用于所有插件。当然，难免会有些特定的代码需要定制后才能用于每个 DCC 应用程序公开的特定 API，但是这些代码通常包含在一个或多个挂钩中，这让重用应用变得很简单。能够创建这种多应用的另一个好处是，在开发新插件的过程中，很容易就可以配置所有标准应用来支持新插件。  通过工作流配置和克隆，我们可以轻松创建开发沙盒，让开发人员能够在制作环境中工作，同时又不会干扰日常的制作活动。工具做好部署准备后，轻松即可更新主项目配置，然后将工具部署给所有艺术家。  应用在插件内运行，因此重新加载很容易。不必每次测试新的代码更改时都重新启动 Nuke 或 Maya，只需单击 Toolkit 中的重新加载按钮，即可加载最新代码。有关应用开发方面的更详尽介绍，请参见以下文档：Toolkit 应用开发简介。Toolkit API 参考应用和插件配置参考",
    "url": "/e95205a8/",
    "relUrl": "/e95205a8/"
  },
  "193": {
    "id": "193",
    "title": "工作流集成",
    "content": "工作流集成ShotGrid 包含各种集成，可将 ShotGrid 体验融入艺术家每天使用的创意工具中。开箱即用，您可以获取艺术家工具中的插件，从而为您的基本发布工作流奠定基础。这些集成基于 Toolkit 平台、一系列 API、UI 和配置构建而成，可为工作室提供各种工具以构建自定义工作流。",
    "url": "/3d1cd26d/",
    "relUrl": "/3d1cd26d/"
  },
  "194": {
    "id": "194",
    "title": "Web Traffic Isolation",
    "content": "Web Traffic IsolationThe goal is to set up an AWS PrivateLink to privately access your ShotGrid site.Set up PrivateLink to ShotGrid      Ask ShotGrid support to provide you with the ShotGrid PrivateLink service name for your AWS region.        Update the private VPC CloudFormation stack you created earlier and set ShotGridPrivateServiceName parameter.  Manual steps if needed      Add a new VPC Endpoint in your VPC        For the security group, ShotGrid service only requires the inbound port tcp/443 to be open.  DNS ConfigurationProvide your PrivateLink DNS name to ShotGrid support. We will setup a new private URL for your site that will look like mystudio-staging.priv.shotgunstudio.com.ValidationVerify that your site private URL resolves to IPs in your AWS VPC block.nslookup mystudio-staging.priv.shotgunstudio.comTry to access your test site from inside your office ie https://mystudio-staging.priv.shotgunstudio.comNext StepsSee Fine Tuning to finalize your setup and optimize costs and security.Go to Setup for an overview of the possible next steps.",
    "url": "/d9ef03ce/",
    "relUrl": "/d9ef03ce/"
  },
  "195": {
    "id": "195",
    "title": "故障排除指南",
    "content": "故障排除指南一组旨在解决问题的快速解答。常规疑难解答帮助  性能疑难解答  如何启用调试日志记录？  远程调试  我的日志文件位于何处？  Toolkit 日志如何运行以及如何判断要查看哪一个日志？  我的配置位于何处？  如何解决 Toolkit 应用未加载、未显示以及在菜单、ShotGrid Desktop 或 AMI 中缺失等问题？  为什么我的上下文缺少任务/工序，但它却出现在文件名中？  为什么要取消注册文件夹以及如何取消注册？  我能否删除站点上的文件系统位置而不是取消注册文件夹？  使用分布式配置时如何取消注册文件夹？错误消息指导  错误：模块“tank”没有属性“support_url”  ASCII 编解码器无法解码位置 10 中的字节 0x97: 序号不在范围内  配置未指向磁盘上的有效包！  找不到程序“MTsetToggleMenuItem”  无法解析路径的行 ID！  data_handler_cache 错误消息：错误 sgtk.env.project.tk-nuke.tk-multi-workfiles2 无法创建“文件打开”(File Open)对话框！  数据库并发问题：路径 &amp;lt;PATH&amp;gt; 已与 ShotGrid 实体 &amp;lt;ENTITY&amp;gt; 相关联  错误：应用商店不包含名为 my-app 的项  [错误] 尝试在未完成加密握手的情况下进行通信  错误“选择的 LUT 无效：Gamma2.2”  [错误] [代理] 调用 __commands::unreal_engine 时出错  [错误 publish_creation] &amp;lt;urlopen 错误 [SSL: CERTIFICATE_VERIFY_FAILED] 证书验证失败(_ssl.c:726)&amp;gt;  错误：ShotGrid tk-maya: Toolkit 产生异常  错误 18:13:28.365:Hiero(34236): 错误！任务类型  异常：审核提交失败。无法渲染和提交与审核关联的场。  由于 Windows 路径太长（&amp;gt; 256 个字符）而导致的错误  无法更改工作区 - 执行 MEL 脚本期间出错  无法创建文件夹：文件夹创建中止  帧服务器遇到错误  ModuleNotFoundError  在 Maya 中，当我输出 context.task 时，显示空白“无”(None)  解决与 Python API 相关的 SSL: CERTIFICATE_VERIFY_FAILED 问题  在本地 ShotGrid 站点上使用 ShotGrid Desktop 时显示 CERTIFICATE_VERIFY_FAILED  SSLError: [Errno 8] _ssl.c:504: 违反协议时发生 EOF  [SSL: CERTIFICATE_VERIFY_FAILED] 证书验证失败：无法获取本地颁发机构证书  TankInitError：您正从位于以下位置的工作流配置加载 Toolkit 平台  TankError：无法解析上下文的模板数据  TankError：尝试从模板解析路径  Tk-desktop 控制台以静默方式忽略错误  SSLHandshakeError: [SSL: CERTIFICATE_VERIFY_FAILED] 证书验证失败 (_ssl.c:727)  TankError：无法在磁盘上创建文件夹。报告错误：严重！无法使用文件夹数据更新 ShotGrid。  [警告] 存储根主存储无法映射到 SG 本地存储软件集成  建议通过哪种形式在项目之间共享/更新工作流配置？  如何为居家办公的用户分发工作流配置？  如何将集中式配置转变为分布式配置以迎合某些用户的需求？  如何在 Windows 上编译 Qt UI 和资源文件？  如何在 ShotGrid UI 中添加 Toolkit 上下文菜单项？  为什么我的 Houdini ShotGrid 集成没有启动？  我已从 ShotGrid Desktop 启动 Nuke/Maya/其他软件，但 ShotGrid 菜单缺少条目，怎么办？  当我设置 NUKE_PATH 环境变量时为什么 Nuke 集成无法启动？  安装两种扩展时的 Photoshop 集成疑难解答  使用 ShotGrid Toolkit 时，为什么启动时 3ds Max 发生崩溃？  如何设置默认软件版本？  为什么加载器应用不显示我的 Alembic 发布？  当 Toolkit 引导时，使用什么顺序来确定正确的 PipelineConfiguration 实体？  为什么 Photoshop 中出现了两个不同的 SG 面板？  Photoshop 集成面板无法加载！“出现了一些问题”  Desktop 缺少软件实体，如何修复此问题？  Tank.template_from_path() 无法返回多个模板？  如何以程序方式使用艺术家的工作文件填充一系列镜头（整个场）？  当用户启动 tk-maya 时，我如何控制 userSetup.py？  用于开发配置的 Tank 命令有哪些？  我想仅在艺术家打开现有发布时（而不是在他们打开现有工作文件时）才执行操作。如何使用挂钩执行此操作？  如何在文件夹创建期间将实体名称中的空格转换为下划线而不是连字符？浏览器集成  我无法通过 Chrome 使用本地文件链接和启动 Toolkit 应用程序  我无法通过 Firefox 使用本地文件链接和启动 Toolkit 应用程序  无法在 Linux 上启动 ShotGrid Desktop/浏览器集成找不到答案？如需进一步排查问题，您可以搜索我们的社区寻找答案！",
    "url": "/7ef5be1d/",
    "relUrl": "/7ef5be1d/"
  },
  "196": {
    "id": "196",
    "title": "Fine Tuning",
    "content": "Fine TuningCost Management RecommendationsS3 Infrequent AccessWe recommend enabling S3 Infrequent Access to easily reduce costs without impacting performance. For the ShotGrid Cloud hosted offering, we apply a policy for all objects older than one month.With Infrequent Access, objects are stored at a lower cost. However, if they are accessed, it will involve an additional cost. ShotGrid has observed that one month was the right policy to use globally, but you may want to adapt that policy to your studio workflows as needed.Read more about S3 Infrequent Access and other storage classes here.S3 Bucket policyWe recommend you restrict access to your S3 bucket to only your VPC and ShotGrid transcoding services IPs. There is an example policy, replace your_vpc_id and your_s3_bucket by your values.We strongly recommend you test media access and media transcoding in your site right after applying the bucket policy changes to be sure your S3 bucket is still accessible from your VPC and from ShotGrid transcoders.{    &quot;Version&quot;: &quot;2012-10-17&quot;,    &quot;Id&quot;: &quot;Policy1415115909152&quot;,    &quot;Statement&quot;: [        {            &quot;Sid&quot;: &quot;AllowSSLRequestsOnly&quot;,            &quot;Effect&quot;: &quot;Deny&quot;,            &quot;Principal&quot;: &quot;*&quot;,            &quot;Action&quot;: &quot;s3:*&quot;,            &quot;Resource&quot;: [                &quot;arn:aws:s3:::your_s3_bucket&quot;,                &quot;arn:aws:s3:::your_s3_bucket/*&quot;            ],            &quot;Condition&quot;: {                &quot;Bool&quot;: {                    &quot;aws:SecureTransport&quot;: &quot;false&quot;                }            }        },        {            &quot;Sid&quot;: &quot;Access-to-specific-VPC-only and Shotgun transcoder&quot;,            &quot;Effect&quot;: &quot;Deny&quot;,            &quot;Principal&quot;: &quot;*&quot;,            &quot;Action&quot;: &quot;s3:GetObject*&quot;,            &quot;Resource&quot;: &quot;arn:aws:s3:::your_s3_bucket/shotgun/*&quot;,            &quot;Condition&quot;: {                &quot;NotIpAddress&quot;: {                    &quot;aws:SourceIp&quot;: [                        &quot;34.200.155.69/32&quot;,                        &quot;34.224.232.103/32&quot;,                        &quot;34.202.127.170/32&quot;                    ]                },                &quot;StringNotEquals&quot;: {                    &quot;aws:sourceVpc&quot;: [                        &quot;vpc-2fd62a56&quot;,                        &quot;your_vpc_id&quot;                    ]                }            }        }    ]}S3 endpoint policyWe recommend setting a VPC endpoint policy on your S3 endpoint to allow access to your S3 bucket only. See here for an example.Application Load Balancer  We recommend you enable deletion protection on the S3 proxy load balancer to prevent accidental deletion.  We recommend you enable access logging on the S3 proxy load balancer to aid in traffic analysis and identification of security issues.Next StepsSee Activation to migrate your production site to use the isolation features.Go to Setup for an overview of the possible next steps.",
    "url": "/26190270/",
    "relUrl": "/26190270/"
  },
  "197": {
    "id": "197",
    "title": "如何启用调试日志记录？",
    "content": "如何启用调试日志记录？有时，您想要查看比 Toolkit 工具默认输出更多的日志记录数据。您可以启用调试日志记录以获取更详细的日志输出，且有多种方法可以执行此操作。                    注意: 不确定在何处查找日志文件？请参见我的日志文件位于何处？文档。    通过 ShotGrid Desktop 启用调试启用调试最简单的方法是，通过 ShotGrid Desktop 应用进行启用。登录 ShotGrid Desktop 后便可进行相关设置：单击应用右下方的个人资料图片，然后选择“高级 -&amp;gt; 切换调试日志记录”(Advanced -&amp;gt; Toggle Debug Logging)。此设置在会话之间持久有效，因此请在完成后将其禁用。此外还应注意，启用此项后，从 ShotGrid Desktop 启动的应用，甚至整个浏览器集成中的 Toolkit 命令，也将继承此调试状态。设置环境变量永久启用调试日志记录TK_DEBUG=1首先，您需要设置新的环境变量：                    注意: 我们建议您与工作室的技术专家讨论如何设置环境变量，因为具体说明特定于平台。但是，以下示例介绍了在 Windows 7 计算机上设置环境变量。    Windows 7 使用示例  您可以永久启用调试日志记录，方法是导航到 Windows 图标 &amp;gt;“控制面板 &amp;gt; 系统 &amp;gt; 高级系统设置 &amp;gt; 环境变量… &amp;gt; 新建…”  变量名称：TK_DEBUG  变量值：1  选择“确定”。现在，环境变量已设置正确并且已启用调试日志记录。                    注意: 务必重新启动 Desktop 以使日志记录生效。    如果要禁用调试日志记录，您可以：a. 将 TK_DEBUG 环境变量值设置为 0。b. 删除 TK_DEBUG 环境变量。检查是否已设置此环境变量要查看是否已设置此环境变量，请打开终端并执行以下命令：set然后，搜索 TK_DEBUG=1。这可确保启动 Desktop 后系统将启用调试日志记录。临时启用调试日志记录如果您希望临时使用一会儿调试日志记录，可以打开终端并使用以下命令来设置调试日志记录：set TK_DEBUG=1然后，通过您的终端启动 Desktop。                    注意: 关闭 ShotGrid Desktop 和终端后，调试日志记录将不再启用。    高级配置调试日志记录选项如果您使用高级设置，还有其他几个选项可供您使用。仅当您能够控制 Toolkit 配置时，此功能才可用。每个插件在环境文件中都有一项 debug_logging 设置。启用此项时，会将其他调试级日志消息发送至软件中的默认输出（例如，Nuke 或 Maya 中的脚本编辑器）。 在插件中运行的所有应用都会发出这些调试级消息，因此，为插件启用此设置实际上也是为所有应用启用它。这不会将任何日志消息输出到文件。为了可以将日志消息输出到文件，我们正在致力于开发一个更标准的日志记录框架。例外情况是 ShotGrid Desktop 和 Photoshop 插件，它们会将输出同时记录到 GUI 控制台和文件。为软件中的插件启用调试日志记录例如，要在镜头工序环境下为 Nuke 插件启用调试输出，请在您的环境文件中找到 Nuke 插件 (tk-nuke) 部分并将此设置更新为 debug_logging: true。编辑 config/env/shot_step.yml。engines:  ...  ...  tk-nuke:    apps:      ...      ...    compatibility_dialog_min_version: 9    debug_logging: true    favourite_directories: []    location: {name: tk-nuke, type: app_store, version: v0.2.23}    ...   ...保存文件并在镜头工序环境下重新启动 Nuke。现在，您可以在脚本编辑器窗口中看到调试输出。                    注意: 如果通过 ShotGrid Desktop 复选框、环境变量或插件配置设置中的任意一个启用调试日志记录，则将输出调试日志记录。此外，这三项中的每一项均独立于其他项进行修改：复选框值是持久有效的应用设置，完全独立于插件设置或环境变量。这意味着，尽管 Desktop 复选框可能处于取消选中状态，但调试日志记录可能仍会通过其他方法之一进行启用。    为 tank 命令启用调试日志记录如果您正在运行 tank 命令并且希望在终端中看到调试输出，请将 --debug 选项与您正在运行的命令结合使用，这将为该命令启用调试日志记录。./tank --debug coreDEBUG [10:11:38 617.835998535]:DEBUG [10:11:38 618.768930435]: Running with debug output enabled.DEBUG [10:11:38 618.921995163]:DEBUG [10:11:38 619.092941284]: Core API resides inside a (localized) pipelineconfiguration.DEBUG [10:11:38 619.235992432]: Full command line passed:['/sgtk/software/shotgun/scarlet/install/core/scripts/tank_cmd.py','/sgtk/software/shotgun/scarlet', '--debug', 'core']DEBUG [10:11:38 619.364023209]:DEBUG [10:11:38 619.463920593]:DEBUG [10:11:38 619.575977325]: Code install root:/sgtk/software/shotgun/scarletDEBUG [10:11:38 619.678020477]: Pipeline Config Root:/sgtk/software/shotgun/scarletDEBUG [10:11:38 619.756937027]:DEBUG [10:11:38 619.826078415]:DEBUG [10:11:38 619.905948639]:DEBUG [10:11:38 619.978904724]: Context items:['/sgtk/software/shotgun/scarlet']DEBUG [10:11:38 620.06688118]: Command: coreDEBUG [10:11:38 620.129108429]: Command Arguments: []DEBUG [10:11:38 620.193004608]: Sgtk Pipeline Config Location:/sgtk/software/shotgun/scarletDEBUG [10:11:38 620.270967484]: Location of this script (__file__):/sgtk/software/shotgun/scarlet/install/core/scripts/tank_cmd.pyWelcome to the Shotgun Pipeline Toolkit!For documentation, see https://developer.shotgridsoftware.com/d587be80/?title=Integrations+User+GuideStarting Toolkit for your current path '/sgtk/software/shotgun/scarlet'- The path is not associated with any Shotgun object.- Falling back on default project settings.DEBUG [10:11:39 125.463962555]: Sgtk API and Context resolve complete.DEBUG [10:11:39 126.449108124]: Sgtk API: Sgtk Core v0.15.18, config/sgtk/software/shotgun/scarletDEBUG [10:11:39 126.588106155]: Context: scarlet- Using configuration 'Primary' and Core v0.15.18- Setting the Context to scarlet.DEBUG [10:11:39 129.276990891]: No need to load up the engine for thiscommand.- Running command core...----------------------------------------------------------------------Command: Core----------------------------------------------------------------------Welcome to the ShotGrid Pipeline Toolkit update checker!This script will check if the Toolkit Core API installedin /sgtk/software/shotgun/scarletis up to date.Please note that when you upgrade the core API, you typically affect more thanone project. If you want to test a Core API upgrade in isolation prior torolling it out to multiple projects, we recommend creating a special*localized* pipeline configuration. For more information about this, pleasesee the Toolkit documentation.You are currently running version v0.15.18 of the Shotgun Pipeline ToolkitNo need to update the Toolkit Core API at this time!DEBUG [10:11:39 981.74405098]: Exiting with exit code None",
    "url": "/143e0a94/",
    "relUrl": "/143e0a94/"
  },
  "198": {
    "id": "198",
    "title": "安装两种扩展时的 Photoshop 集成疑难解答",
    "content": "安装两种扩展时的 Photoshop 集成疑难解答问题是什么？在发布的 After Effects 集成中，包含一个与 ShotGrid 集成的所有 Adobe 应用都可使用的通用插件。作为此更改的一部分，我们需要重命名扩展，以便可以保留与较早的 Photoshop 集成的向后兼容性，并使工作室能够顺利过渡到更新。不幸的是，这也意味着升级的同时可能安装两种 ShotGrid 扩展：ShotGrid Adobe Panel 为新扩展，应该在使用 v1.7.0 或更新版本的 Photoshop 集成时使用。如何解决？要删除旧扩展，可将其从您的主目录中的 Adobe 安装位置移除。启动 Photoshop 后，此扩展对应的文件夹可在调试输出中看到，位于  OSX：~/Library/Application Support/Adobe/CEP/extensions/com.sg.basic.ps  Windows：%AppData% Adobe CEP extensions com.sg.basic.ps如果退出 Photoshop 并移除该目录，则重新启动时应只有一个扩展。                    注意: 如果在多个环境或多个配置中具有 Photoshop 集成，并且新旧插件混合存在，则用户启动包含旧集成的 Photoshop 时，将返回旧插件。建议全面更新 Photoshop，以便只需执行一次清理。    ",
    "url": "/3fd1f835/",
    "relUrl": "/3fd1f835/"
  },
  "199": {
    "id": "199",
    "title": "无法获取本地颁发机构证书",
    "content": "[SSL: CERTIFICATE_VERIFY_FAILED] 证书验证失败: 无法获取本地颁发机构证书用例在 Windows 上，用户在使用 Python API 从 Amazon 上传和下载媒体时遇到问题。Python API 引发以下错误消息，说明了此问题：shotgun_api3.shotgun.ShotgunFileDownloadError: Failed to open https://xxx.shotgunstudio.com/file_serve/attachment/xyz&amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1108)&amp;gt;Amazon 在其后端更新了一些证书。浏览需要新证书的网页时，Windows 通常会刷新其证书存储。在未看到常规浏览活动的计算机上运行的独立 Python 脚本将不检索证书更新，这可能导致该计算机缺少相当多的证书更新。如何修复如果您对有问题的计算机具有 GUI 访问权限，只需播放当前存储在 S3 上的任何媒体，即可更新证书存储。此播放解决方案仅适用于 Chrome、Internet Explorer、Edge 或其他基于 Chromium 的浏览器。此播放解决方案在 Firefox 或 Safari 上不起作用，因为这些浏览器不使用 Windows 标准 API 进行证书验证。对于此解决方案不起作用的用户，或者如果您有大量要更新的计算机（如 Deadline 渲染农场），我们还提供了一个脚本，该脚本会将缺失的证书添加到您的计算机中。下面是我们共享的脚本的链接。对于 Windows 10 上的 PowerShell 或 Windows 7 上的 PowerShell 3 用户，您可以在计算机上以管理员身份运行以下脚本以获取新证书。$cert_url = &quot;https://www.amazontrust.com/repository/AmazonRootCA1.cer&quot;$cert_file = New-TemporaryFileInvoke-WebRequest -Uri $cert_url -UseBasicParsing -OutFile $cert_file.FullNameImport-Certificate -FilePath $cert_file.FullName -CertStoreLocation Cert: LocalMachine Root如果该命令起作用，您应该会看到以下内容：   PSParentPath: Microsoft.PowerShell.Security Certificate::LocalMachine RootThumbprint                                Subject----------                                -------8DA7F965EC5EFC37910F1C6E59FDC1CC6A6EDE16  CN=Amazon Root CA 1, O=Amazon, C=US这将使证书可用于运行该证书的计算机上的所有用户帐户。如果您没有管理员访问权限，可以使用以下命令更改最后一行：Import-Certificate -FilePath $cert_file.FullName -CertStoreLocation Cert: CurrentUser Root将仅为当前用户添加证书。如果您是像我一样的老派人士，仍然痴迷于使用 cmd.exe，也可以使用 certutil。首先，您需要从 https://www.amazontrust.com/repository/AmazonRootCA1.cer 下载证书，并将其保存到计算机上的某个位置。然后，在管理模式下启动命令提示符：并执行以下行：certutil -addstore root &amp;lt;path-to-the-cert&amp;gt;这将使证书适用于所有用户帐户。如果您没有管理员访问权限，可以添加 -user 以像这样仅为当前用户安装证书certutil -user -addstore root &amp;lt;path-to-the-cert&amp;gt;相关链接在社区中查看完整主题",
    "url": "/e9d994eb/",
    "relUrl": "/e9d994eb/"
  },
  "200": {
    "id": "200",
    "title": "如何卸载应用或插件？",
    "content": "如何卸载应用或插件？您可以通过编辑配置的环境 YAML 文件来删除应用或插件，使其不再存在。环境文件允许您将应用配置为仅适用于特定上下文或插件，而不是完全删除它们。有关编辑环境文件的更多常规信息，请查看此手册。示例以下示例展示了如何从默认配置完全删除发布应用。在环境设置内应用添加到插件，因此我们必须从添加发布应用的所有插件中将其删除。从插件中删除应用每个插件的 .../env/includes/settings 内都有自己的 YAML 文件；由于所有插件中都包含发布应用，因此您需要修改每个插件 YAML 文件。以 Maya 插件为例，您将打开 tk-maya.yml 并删除对发布应用的所有引用。首先，包含部分中具有对它的引用：.../env/includes/settings/tk-maya.yml L18在资产工序上下文中，Maya 插件中也包含应用：.../env/includes/settings/tk-maya.yml L47并且还有一行，将其添加到菜单收藏夹：.../env/includes/settings/tk-maya.yml L56然后将在镜头工序设置下重复这些行：.../env/includes/settings/tk-maya.yml L106.../env/includes/settings/tk-maya.yml L115然后对所有其他插件环境 yml 文件重复这些步骤，例如 tk-nuke、tk-3dsmaxplus、tk-desktop 等。                    重要信息: 现在，您已做好充分准备，只要您需要，就可禁止应用显示在用户的集成中。但是，如果您要从配置中完全删除对应用的引用以使其保持干净，则需要完成其余步骤。    删除应用设置所有插件 YAML 文件都包括 tk-multi-publish2.yml 设置文件。现在您已在插件 YAML 文件中删除对它的引用，您可以完全删除此文件。                    重要信息: 如果您删除了 tk-multi-publish2.yml 但仍有插件文件指向它，则可能会收到错误，如下所示：ErrorInclude resolve error in '/configs/my_project/env/./includes/settings/tk-desktop2.yml': './tk-multi-publish2.yml' resolved to '/configs/my_project/env/./includes/settings/./tk-multi-publish2.yml' which does not exist!    删除应用位置在默认配置下，所有应用都将位置描述符存储在 …/env/includes/app_locations.yml 文件中。tk-multi-publish2.yml 引用了它，因此您需要删除描述符行。",
    "url": "/86ab39ef/",
    "relUrl": "/86ab39ef/"
  },
  "201": {
    "id": "201",
    "title": "调用 __commands::unreal_engine 时出错",
    "content": "[ERROR] [PROXY] 调用 __commands::unreal_engine 时出错]用例：现在，设置 ShotGrid 桌面应用并能够使 UE4 在 ShotGrid 应用中显示后，当我尝试启动 Unreal 时，收到以下消息：2020-06-06 03:22:24,246 [ ERROR] [PROXY] Error calling __commands::unreal_engine_4.24.3((), {}):Traceback (most recent call last):File “C: Users USER0 AppData Roaming Shotgun bundle_cache app_store tk-desktop v2.4.12 python tk_desktop desktop_engine_project_implementation.py”, line 164, in _trigger_callbackcallback(*args, **kwargs)File “C: Users USER0 AppData Roaming Shotgun babilgames p91c38.basic.desktop cfg install core python tank platform engine.py”, line 1084, in callback_wrapperreturn callback(*args, **kwargs)File “C: Users USER0 AppData Roaming Shotgun bundle_cache app_store tk-multi-launchapp v0.10.2 python tk_multi_launchapp base_launcher.py”, line 125, in launch_version*args, **kwargsFile “C: Users USER0 AppData Roaming Shotgun bundle_cache app_store tk-multi-launchapp v0.10.2 python tk_multi_launchapp base_launcher.py”, line 343, in _launch_callback“Could not create folders on disk. Error reported: %s” % errTankError: Could not create folders on disk. Error reported: Could not resolve row id for path! Please contact support! trying to resolve path ‘D: UEProjects SON D: UEProjects SON’. Source data set: [{‘path_cache_row_id’: 2, ‘path’: ‘D: UEProjects SON’, ‘metadata’: {‘root_name’: ‘primary’, ‘type’: ‘project’}, ‘primary’: True, ‘entity’: {‘type’: ‘Project’, ‘id’: 91, ‘name’: ‘SON’}}]导致错误的原因是什么？磁盘上 UE4 项目的路径 D: UEProjects PROJECT_NAME  不正确。如何修复为 ShotGrid 的设置创建新文件夹可解决该问题。在社区中查看完整主题。",
    "url": "/5e456562/",
    "relUrl": "/5e456562/"
  },
  "202": {
    "id": "202",
    "title": "如何使用 API 以编程方式更新我的 Toolkit 配置？",
    "content": "如何使用 API 以编程方式更新我的 Toolkit 配置？更新应用、插件和框架如果您想要以编程方式将所有插件、应用和框架更新到最新版本，可以使用以下代码执行此操作：import syssys.path.append(&quot;&amp;lt;path_to_your_config&amp;gt;/install/core/python&quot;)import sgtk# substitute your Project id here or alternatively use sgtk_from_path()tk = sgtk.sgtk_from_entity('Project', 161)c=tk.get_command(&quot;updates&quot;)# setup authenticationif hasattr(sgtk, &quot;set_authenticated_user&quot;):     from tank_vendor.shotgun_authentication import ShotgunAuthenticator     user = ShotgunAuthenticator(sgtk.util.CoreDefaultsManager()).get_default_user()     sgtk.set_authenticated_user(user)# finally, execute the commandc.execute({})                    注意: 这会将此工作流配置中的所有插件、应用和框架更新为最新版本，而无需执行任何进一步交互或确认操作。在继续之前，请确保了解这一点。    更新核心如果要通过脚本更新项目的核心版本以便采用非交互方式运行该版本，可以使用以下代码执行此操作：import syssys.path.append(&quot;&amp;lt;path_to_your_config&amp;gt;/install/core/python&quot;)import sgtk# substitute your Project id here or alternatively use sgtk_from_path()tk = sgtk.sgtk_from_entity('Project', 161)c=tk.get_command(&quot;core&quot;)# setup authenticationif hasattr(sgtk, &quot;set_authenticated_user&quot;):    from tank_vendor.shotgun_authentication import ShotgunAuthenticator    user = ShotgunAuthenticator(sgtk.util.CoreDefaultsManager()).get_default_user()    sgtk.set_authenticated_user(user)# finally, execute the commandc.execute({})                    注意: 这会将 Toolkit 核心更新为最新版本，而无需执行任何进一步交互或确认操作。如果您正在从共享核心运行，此操作将更新共享此核心版本的所有项目使用的核心版本！在继续之前，请确保了解这一点。    请参见：  自定义脚本中的身份认证和登录凭据",
    "url": "/4de9c1d6/",
    "relUrl": "/4de9c1d6/"
  },
  "203": {
    "id": "203",
    "title": "如何更新我的工作流配置核心位置？",
    "content": "如何更新我的工作流配置核心位置？如何更新我的工作流配置以使用本地核心？如果您的工作流配置已设置为使用共享 Toolkit 核心，那么您实际上可以撤消该过程，或者“取消共享”核心，并使用 tank localize 命令在工作流配置内安装 Toolkit 核心 API 的副本。我们将其称为“本地化”核心。       打开终端并导航到要安装 Toolkit 核心的工作流配置。     $ cd /sgtk/software/shotgun/scarlet            运行以下 tank 命令：     $ ./tank localize ... ... ---------------------------------------------------------------------- Command: Localize ---------------------------------------------------------------------- This will copy the Core API in /sgtk/software/shotgun/studio into the Pipeline configuration /sgtk/software/shotgun/scarlet. Do you want to proceed [yn]        Toolkit 将确认所有内容，然后再继续。工作流配置当前指向的 Toolkit 核心的副本将在本地复制到您的工作流配置中。        Toolkit 现在会将工作流配置使用的所有应用、插件和框架本地复制到 install 文件夹中。然后，它将复制 Toolkit 核心并更新工作流配置中的配置文件，以使用新安装的本地 Toolkit 核心。     Copying 59 apps, engines and frameworks... 1/59: Copying tk-multi-workfiles v0.6.15... 2/59: Copying tk-maya v0.4.7... 3/59: Copying tk-nuke-breakdown v0.3.0... 4/59: Copying tk-framework-widget v0.2.2... 5/59: Copying tk-shell v0.4.1... 6/59: Copying tk-multi-launchapp Undefined... 7/59: Copying tk-motionbuilder v0.3.0... 8/59: Copying tk-hiero-openinshotgun v0.1.0... 9/59: Copying tk-multi-workfiles2 v0.7.9... ... ... 59/59: Copying tk-framework-qtwidgets v2.0.1... Localizing Core: /sgtk/software/shotgun/studio/install/core -&amp;gt; /sgtk/software/shotgun/scarlet/install/core Copying Core Configuration Files... The Core API was successfully localized. Localize complete! This pipeline configuration now has an independent API. If you upgrade the API for this configuration (using the 'tank core' command), no other configurations or projects will be affected.                          注意: 您的输出将根据所安装的应用、插件和框架版本而有所不同。    如何更新我的工作流配置以使用现有共享核心？如果您有现有的共享 Toolkit 核心，则可以使用 tank 命令来更新任何现有的“本地化”工作流配置，以使用该共享核心。      打开终端并导航到要更新的工作流配置。     $ cd /sgtk/software/shotgun/scarlet            接下来，您将运行 tank attach_to_core 命令并提供共享核心在当前平台上的有效路径。     $ ./tank attach_to_core /sgtk/software/shotgun/studio ... ... ---------------------------------------------------------------------- Command: Attach to core ---------------------------------------------------------------------- After this command has completed, the configuration will not contain an embedded copy of the core but instead it will be picked up from the following locations: - Linux: '/mnt/hgfs/sgtk/software/shotgun/studio' - Windows: 'z: sgtk software shotgun studio' - Mac: '/sgtk/software/shotgun/studio' Note for expert users: Prior to executing this command, please ensure that you have no configurations that are using the core embedded in this configuration. Do you want to proceed [yn]        Toolkit 将确认所有内容，然后再继续。由于此共享核心已针对多个平台设置，它将显示每个平台的位置。    如果您需要为新平台添加该位置，请更新共享核心配置中的 config/core/install_location.yml 文件并添加必要的路径。        现在，Toolkit 会在工作流配置中备份本地核心 API，移除本地化核心，并添加必要的配置以将工作流配置指向共享核心。     Backing up local core install... Removing core system files from configuration... Creating core proxy... The Core API was successfully processed.        如果您稍后决定要在工作流配置中本地化 Toolkit 核心（即，从共享核心分离工作流配置并使用本地安装的版本），则可以使用 tank localize 命令执行此操作。                      注意: 共享工作室核心的版本必须与当前工作流配置的核心相同或更高。    如何在项目之间共享 Toolkit 核心？目前，使用 SG Desktop 设置项目时，Toolkit 核心 API 会进行“本地化”，这意味着它会安装在工作流配置内部。也就是说，每个工作流配置会完全独立地安装 Toolkit。您可能更希望在项目之间共享 Toolkit 核心 API 版本，这样可以最大程度减少维护量，并可确保所有项目均使用相同的核心代码。我们有时称之为 “共享工作室核心”。以下介绍了如何创建可在不同项目工作流配置之间共享的新 Toolkit 核心 API 配置。      打开终端并导航到包含要共享的 Toolkit 核心版本的现有工作流配置。该过程完成后，此工作流配置将不再进行本地化，而是使用新创建的共享核心。     $ cd /sgtk/software/shotgun/pied_piper            运行以下 tank 命令，以将 Toolkit 核心复制到磁盘上的外部位置。您提供的位置应该是可以在所有平台上找到此路径（linux_path、windows_path、mac_path）。我们建议使用引号将每个路径引起来。如果不是在特定平台上使用 Toolkit，只需指定一个空字符串 &quot;&quot;。      $ ./tank share_core &quot;/mnt/sgtk/software/shotgun/studio&quot; &quot;Z: sgtk software shotgun studio&quot;   &quot;/sgtk/software/shotgun/studio&quot;            系统将显示一个在 Toolkit 继续之前要进行的更改的摘要。     ---------------------------------------------------------------------- Command: Share core ---------------------------------------------------------------------- This will move the embedded core API in the configuration '/sgtk/software/shotgun/pied_piper'. After this command has completed, the configuration will not contain an embedded copy of the core but instead it will be picked up from the following locations: - Linux: '/mnt/sgtk/software/shotgun/studio' - Windows: 'Z: sgtk software shotgun studio' - Mac: '/sgtk/software/shotgun/studio' Note for expert users: Prior to executing this command, please ensure that you have no configurations that are using the core embedded in this configuration. Do you want to proceed [yn]            Toolkit 将核心安装复制到新共享位置，并将更新现有工作流配置以指向新共享核心。     Setting up base structure... Copying configuration files... Copying core installation... Backing up local core install... Removing core system files from configuration... Creating core proxy... The Core API was successfully processed.      现在，您可以从其他工作流配置中使用此新共享核心。要更新工作流配置以使用现有共享核心（如刚创建的共享核心），您可以使用 tank attach_to_core 命令。",
    "url": "/b12f2510/",
    "relUrl": "/b12f2510/"
  },
  "204": {
    "id": "204",
    "title": "版本与已发布的文件之间有何差异？",
    "content": "版本与已发布的文件之间有何差异？“发布” 表示可在应用程序内部使用的磁盘上的文件（或图像序列）或数据。它可以是 exr 序列、abc、Maya 文件等。发布由 ShotGrid 中的 PublishedFile 实体表示。“版本”（ShotGrid 中的 Version 实体）是发布的直观表示，用于审核和记录。Version 实体有一个名为“已发布的文件”(Published Files)的字段，您可在此字段中填充任意数量的发布记录以将其连接在一起。这是您可以跟踪哪个审核 Version 与一组发布相关联的方法。我们建议您在发布时填充此关系。版本由 ShotGrid 中的 Version 实体表示。最终想法是：在发布时，您可以生成一组文件 - 有时是不同的文件格式但包含相同的内容（Maya 文件、obj、alembic 等）- 这些文件以不同方式表示相同的内容。之后，它们与单一审核 Version 关联起来，以便预览发布数据并进行记录。当发布的数据是图像序列时，这种想法就有点多余了。实际上，图像序列既是您想要审核的内容，又是要沿管道发送的内容。在这种情况下，您可能需要“双管齐下”，同时创建发布和 Version。这样，您可以加载表示 Version 的已发布数据（例如，通过加载器应用）。",
    "url": "/b867b4b0/",
    "relUrl": "/b867b4b0/"
  },
  "205": {
    "id": "205",
    "title": "Toolkit 网络讲座",
    "content": "ShotGrid Toolkit 网络讲座更新日期：2020/5/8ShotGrid Toolkit 网络讲座播放列表ShotGrid Toolkit 网络讲座视频1：ShotGrid Toolkit 网络讲座：即时可用的集成（60 分钟）在全新系列 Toolkit 网络讲座的第一个讲座中，Rob Blau 和 Manne Öhrström 将为您解答有关即时可用的集成的问题。2：ShotGrid Toolkit 网络讲座：揭秘新的默认配置（60 分钟）在此网络讲座中，Josh Tomlinson 和 Rob Blau 将为您介绍 Toolkit 项目的新默认配置中发生了哪些变化（以及变化原因）。3：ShotGrid Toolkit 网络讲座：自定义发布工作流 - 现场演示（60 分钟）在此网络讲座中，Josh Tomlinson 分步演练了在 Maya 中创建自定义发布工作流的过程。了解发布应用的构造、发布应用的配置方式以及如何编写用于收集和发布数据的自定义挂钩。补充材料工作流教程4：ShotGrid Toolkit 网络讲座：远程服务配置和多位置工作流（60 分钟）在此网络讲座中，Manne Ohrstrom 探讨了工作室的艺术家们分布在不同位置时的工作流。补充材料有关 Toolkit 初始化和配置管理的开发人员文档Manne 在视频中提及的描述符类型的列表5：ShotGrid 生态系统网络讲座：REST API（60 分钟）在此网络讲座中，Brandon Ashworth 将为我们演练一些有用的演示、示例和模板，以展示 REST API 的用途、重要意义及其使用方式。补充材料REST API 参考文档6：ShotGrid Toolkit 网络讲座：新的 Publisher API（35 分钟）最新的集成发布包括经过改进的 Publish API，此 API 允许您将发布逻辑与 GUI 应用分离，并通过您自己的工具、甚至在渲染农场上运行发布。在此网络讲座中，Jean-Francois Boismenu 将演示如何使用此 API 将发布项目树从 Publisher UI 传递到渲染农场作业。补充材料GitHub 库与配置31:00 - Pull 请求发布 API 文档7：ShotGrid Toolkit 网络讲座：After Effects 集成（38 分钟）Adobe After Effects 是我们最新的 ShotGrid 集成。在此网络讲座中，Rob Blau 将深入剖析 After Effects 集成并现场演示相关功能，而后讨论我们如何通过 Photoshop 集成推动为任何 Adobe 集成开发可重复使用的框架。此外，Tannaz Sassooni 为我们导览了新的开发人员文档站点，并展示我们如何让用户更轻松地了解与 ShotGrid 的集成方式。补充材料After Effects 集成文档开发人员文档门户ShotGrid 开发人员日播放列表ShotGrid 开发人员日视频在 SIGGRAPH 2018 和 2019 上，ShotGrid 团队展示了 ShotGrid 开发人员日：这是一系列课程，旨在使开发人员熟悉可用于实现任务自动化、编写自定义应用等的各种资源。在 SIGGRAPH 之后，我们举办了一系列以开发人员日的内容为专题的网络讲座。此播放列表包含这些网络讲座的录像。有关完整幻灯片、代码示例和与此内容相关的其他资源，请单击此处查看 2019 版，单击此处查看 2018 版。1：2019 SIGGRAPH 开发人员日：ShotGrid 开发简介（83 分钟）在此网络讲座中，Tannaz Sassooni 和 Patrick Boucher 对 ShotGrid 开发进行了介绍，并讨论了 ShotGrid 的自动化入口点、ShotGrid 的 Python 和 REST API，以及 ShotGrid 的 API 如何自动化工作室的任务和数据跟踪。0:56 欢迎和定位3:00 ShotGrid 开发简介：从较高层面简单介绍常见流程需求以及如何使用 ShotGrid 的 API 和开发框架来解决这些需求。[Tannaz Sassooni]25:59 介绍使用 ShotGrid API 管理数据的过程：深入剖析使用简单 Python 和 REST 脚本的 ShotGrid API，以及用于创建动作菜单项的框架。[Patrick Boucher]2：2019 SIGGRAPH 开发人员日：高级 ShotGrid 开发（78 分钟）在此网络讲座中，Brandon Ashworth 和 Manne Öhrström 深入剖析 ShotGrid 如何使用事件进程和新 Webhook 响应 ShotGrid 中的数据变更，并介绍如何使用 ShotGrid Toolkit 编写简单的工作流工具。0:39 欢迎和定位2:33 使用 ShotGrid 事件 [Brandon Ashworth]41:25 开发可在多个艺术家应用中运行的 ShotGrid 工具 [Manne Öhrström]3：SIGGRAPH 开发人员日：Toolkit 管理（1 小时 15 分钟）在此网络讲座中，Josh Tomlinson、Tannaz Sassooni 和 Phil Scadding 演示了如何接管集成并创建自定义目录结构和挂钩以在工作室中实现更多数据流的自动化。0:00 欢迎和定位1:04 ShotGrid Toolkit 管理：了解如何通过我们的 ShotGrid Desktop 应用启动常用内容创建软件，并了解艺术家如何在不离开其工作会话的情况下，通过我们的默认工作流集成与 ShotGrid 进行交互。[Phil Scadding]32:41 Toolkit 配置简介：掌握如何浏览整个 Toolkit 工作流配置，了解如何使用该配置自定义工作流。[Tannaz Sassooni]56:20 管理挂钩：了解如何使用 ShotGrid Toolkit 的众多挂钩来向配置添加自定义逻辑并根据工作室的需求定制 Toolkit 工作流。[Josh Tomlinson]4：SIGGRAPH 开发人员日：高级 ShotGrid 开发（1 小时 15 分钟）Manne Ohrstrom、Jeff Beeland 和 Rob Blau 演示了源控制和基于远程服务的工作流部署的最佳实践，并深入剖析了应用构建以及使用 Toolkit 的标准框架快速设计 UI 和处理数据的过程。0:00 欢迎和定位2:31 Toolkit 平台：开发和部署模式：了解设置和部署 Toolkit 工作流配置的不同方法，包括开发工作流、版本控制最佳实践，以及通过将工作流配置上传到您的 ShotGrid 站点而将工作流配置分发给远程用户。[Manne Ohrstrom]30:23 Toolkit 平台：编写您自己的应用：演示如何编写简单的 Toolkit 应用，利用提供的 API 和框架快速创建强大的 UI。[Jeff Beeland]1:02:22 Autodesk Forge 简介：了解 Autodesk 的 API 驱动型系列远程服务 Forge，以及如何使用这些远程服务来扩展 ShotGrid 体验。[Rob Blau]",
    "url": "/869a6fab/",
    "relUrl": "/869a6fab/"
  },
  "206": {
    "id": "206",
    "title": "VPC / IAM / Security Group",
    "content": "VPC / IAM / Security GroupAmazon Virtual Private Cloud permits users to logically separate virtual networks that host their AWS resources and provides you complete control over access to your AWS network.Within a VPC, security groups act as a basic firewall and control what inbound and outbound connections are permitted to each given resource. For example, a security group can allow inbound HTTPS traffic to a proxy server but block all other inbound traffic.With AWS Identity and Access Management (IAM), access to AWS resources and services can be controlled at a more fine-grained level. For example, IAM can be leveraged to control who or which resources can access S3 buckets used by ShotGrid.All three of the above features are used in the ShotGrid isolation features implementation to ensure that you securely connect your closed VPC to ShotGrid and allow access to the media S3 buckets.",
    "url": "/28430132/",
    "relUrl": "/28430132/"
  },
  "207": {
    "id": "207",
    "title": "Web Traffic Isolation",
    "content": "Web Traffic IsolationCommunication between your client systems and your ShotGrid site will traverse the open Internet by default. Web Traffic Isolation allows you to restrict access to your ShotGrid site from the public Internet entirely and ensure that all traffic transits directly between your AWS VPC and Autodesk’s AWS VPC.ConfigurationA unique VPC endpoint is provided by Autodesk. Access to the endpoint must be configured from your VPC, and the relevant DNS configuration must be completed to allow your client systems to reach the new endpoint.How it worksBy using the provided VPC endpoint, web traffic is isolated from the public Internet completely. All web traffic transits between your AWS VPC and Autodesk’s AWS VPC, rather than the public Internet.CostsThe only cost associated with Web Traffic Isolation are those related to web traffic transiting to/from your AWS VPC. See AWS VPC Pricing for more details.Next StepsSee Web Traffic Isolation for setup instructions.",
    "url": "/57122ae9/",
    "relUrl": "/57122ae9/"
  },
  "208": {
    "id": "208",
    "title": "Webhook",
    "content": "WebhookWebhook 允许向您控制的服务通知 ShotGrid 中发生的事件。当您创建 Webhook 时，需指定感兴趣的事件类型，并告诉 ShotGrid 在该事件触发后要将数据发送至哪个 URL。ShotGrid 中发生相关事件后，会将描述事件的数据的有效负载发送到 Webhook 的 URL。这样就可以构建与 ShotGrid 的紧密集成并使工作流的某些部分实现自动化。有哪些示例说明 Webhook 的用法？我们提供了很多 Webhook 用例。本文档中概述了一些我们认为非常吸引人的用例，但其用途并不仅限于这些示例。创建实体后在磁盘上创建目录结构我们看到重复出现多次的一个工作流就是，在 ShotGrid 中创建新实体后需要在磁盘上创建目录结构。为何不提前准备，确保在 ShotGrid 中创建新镜头后即可自动供艺术家使用？状态管理自动化当动画团队完成工作后，为何不提前准备，更改同一镜头中下游任务的状态，以指示可以开始执行更多工作？这样，您就可以自动通知不同领域的指定艺术家一切都已准备就绪！另一个说明如何自动进行状态管理的示例是，在创建新的 Note 后触发 Task 实体状态更改。这是一种很好的方法，可以告知艺术家和制作团队，主管在审核会话后已请求更改或修复当前作品。何时应使用 Webhook，而不是 ShotGrid 事件进程？Webhook 和 ShotGrid 事件进程提供类似的功能，但有一些主要区别。事件进程要求您运行、监视和维护自己的服务。您的所有代码都必须使用 Python 编写，并且允许您启动自己的 ShotGrid 连接。相反，Webhook 会应答连接，并且可以使用任何编程语言编写。它们可以托管在无服务器环境（例如 AWS Lambda）中，也可以触发任何联机可用的自动化平台（例如 Zapier 和 IFTTT）。如果您的用例用到 Webhook，这应该是首选解决方案。创建 Webhook要开始创建 Webhook，请转到“Webhook”页面。然后选择“创建 Webhook”(Create Webhook)。                    注意: 对 Webhook 的访问权限由“高级”(Advanced)权限下的“显示 Webhook”(Show Webhooks)控制。默认情况下，对于管理员和经理权限角色，此选项处于启用状态。    接下来，填写创建新 Webhook 所需的信息。访问密钥为 Webhook 指定访问密钥是可选的。如果提供，任何发送至 Webhook URL 的请求都会使用该令牌进行签名。令牌值作为名为 X-SG-SIGNATURE 的标题随请求一起发送。使用 HMAC 与 SHA1 计算签名，并且签名的消息是请求的 JSON 主体。标头格式&amp;lt;algorithm&amp;gt;=&amp;lt;signature&amp;gt;为何使用访问密钥？尽管不是严格要求，但提供访问密钥可以对发送到 Webhook URL 的有效负载进行签名。这允许使用者服务验证数据是否来自预期的源，并且有效负载在传输过程中没有发生任何改变。签名验证下面使用 Python 举例说明如何验证有效负载的签名。&amp;gt;&amp;gt;&amp;gt; import hmac&amp;gt;&amp;gt;&amp;gt; import hashlib&amp;gt;&amp;gt;&amp;gt; body | `&amp;lt;json body&amp;gt;'&amp;gt;&amp;gt;&amp;gt; token | `mytoken'&amp;gt;&amp;gt;&amp;gt; 'sha1=' + hmac.new(token, body, hashlib.sha1).hexdigest()  == 'sha1=32824e0ea4b3f1ae37ba8d67ec40042f3ff02f6c'True验证 SSL 证书验证 SSL 证书是一项可选功能，该功能可帮助确保到 Webhook 的使用者 URL 的任何连接的安全性。如果启用，则向 Webhook 的 URL 交付内容时，ShotGrid 将使用 OpenSSL 的证书验证例程来验证证书。以批处理格式交付在此处了解有关以批处理格式交付的详细信息。不稳定时通知“不稳定时通知”(Notify when unstable)允许您选择一个用户或组，以在 Webhook 失败时予以通知。此设置为可选项。按项目和实体过滤选择特定项目、实体和字段将尽可能减少传输到 Webhook 的通信，从而：  提高性能  降低资源成本  防止出现不必要的积压工作                    注意: 如果选择项目，则您只能选择始终属于单个项目的实体（例如“版本”(Versions)）。如果要选择非项目（或多项目）实体（例如“人员”(Person)），则不应选择项目。这可确保 Webhook 事件过滤不会增加实体更新的性能开销。    Webhook 状态一个 Webhook 可以具有几种不同的状态之一，以指示其运行状况和继续接收交付内容的能力。            状态      示例      说明                  活动            Webhook 运行稳定。在过去 24 小时内，向此 Webhook 的使用者 URL 进行的交付都已到达其目的地。              不稳定            Webhook 运行不稳定。在过去 24 小时内，某些交付未能到达其目的地，但不足以导致 ShotGrid 将 Webhook 视为终止。              失败            Webhook 被视为终止，且不会再尝试交付。这是因为在短时间内出现太多交付失败，且系统已确定不应再将 Webhook 视为可行。如果在过去 24 小时内出现 100 次交付失败，则 Webhook 将被视为失败。              禁用            Webhook 处于禁用状态，并且在重新启用之前，不会再尝试进行任何交付。      交付从 Webhook 列表中选择一个 Webhook 将显示七天以来向该 Webhook 进行的所有交付。                    注意: 超过七天的交付日志将被删除且不可恢复。    交付状态交付状态指示是否已成功交付到 Webhook 的 URL。交付详细信息交付可展开以显示有关发送到此 Webhook URL 的请求以及对此请求的响应的详细信息。请求有效负载发送到 Webhook URL 的有效负载包含描述在 ShotGrid 中发生的事件及其触发者的信息。它以 JSON 格式提供。                    有效负载大小: 交付的有效负载最大为 1 MB。ShotGrid 中触发的任何导致有效负载超过 1 MB 的事件都将移除其 new_value 和 old_value 键，并添加一个 warning 键，添加的键中包含一条消息，说明发生了什么、为什么以及如何从 ShotGrid 检索完整事件日志条目。    有效负载示例{  &quot;data&quot;: {    &quot;id&quot;: &quot;11777.3065.0&quot;,    &quot;meta&quot;: {      &quot;type&quot;: &quot;attribute_change&quot;,      &quot;entity_id&quot;: 1246,      &quot;new_value&quot;: &quot;*Add fog and mist with depth&quot;,      &quot;old_value&quot;: &quot;*Add fog and mist.&quot;,      &quot;entity_type&quot;: &quot;Shot&quot;,      &quot;attribute_name&quot;: &quot;description&quot;,      &quot;field_data_type&quot;: &quot;text&quot;    },    &quot;user&quot;: {      &quot;id&quot;: 88,      &quot;type&quot;: &quot;HumanUser&quot;    },    &quot;entity&quot;: {      &quot;id&quot;: 1246,      &quot;type&quot;: &quot;Shot&quot;    },    &quot;project&quot;: {      &quot;id&quot;: 122,      &quot;type&quot;: &quot;Project&quot;    },    &quot;operation&quot;: &quot;update&quot;,    &quot;created_at&quot;: &quot;2022-02-01 20:53:08.523887&quot;,    &quot;event_type&quot;: &quot;Shotgun_Shot_Change&quot;,    &quot;delivery_id&quot;: &quot;3a5de4ee-8f05-4eac-b537-611e845352fc&quot;,    &quot;session_uuid&quot;: &quot;dd6a1d6a-83a0-11ec-8826-0242ac110006&quot;,    &quot;attribute_name&quot;: &quot;description&quot;,    &quot;event_log_entry_id&quot;: 545175  },  &quot;timestamp&quot;: &quot;2022-02-01T20:53:09Z&quot;}会话 UUID事件有效负载的一部分是在 ShotGrid 中触发事件的 session_uuid。此值可以提供给 ShotGrid 的 Python API，这将导致具有该 session_uuid 的任何打开的浏览器会话显示由此 API 生成的事件的更新。来自 Webhook 的响应“响应”(Response)选项卡显示有关 Webhook 对交付的响应的详细信息。您可以查看 Webhook 的响应 HTTP 标头、正文和测量的响应时间。Webhook 的响应正文最多保留 100 个字符。（如上所述，交付信息将保留 7 天以供查看，之后将被删除。）                    安全最佳实践: 请勿在 Webhook 的响应中包含任何安全数据，也不要在响应中返回系统错误的详细信息。    响应交付Webhook 使用者服务必须响应交付，这样系统才会将其视为已成功交付。                    响应超时: 必须在交付到 Webhook URL 后六秒内收到响应，之后连接将关闭。未能及时响应将导致交付失败。    系统会记录每次交付的处理时间，您可以在“响应详细信息”(Response details)选项卡中查看该时间。限制您的使用者响应交付的时间将影响您站点的 Webhook 吞吐量。每个站点允许的响应时间为 1 分钟。因此，如果某个站点的所有已配置使用者端点都需要整整 6 秒时间来响应，则该站点的 Webhook 交付限制为每分钟 10 个。如果需要较高的整体吞吐量，则应根据以下模型设计使用者端点：  接收请求  生成另一个进程/线程以按所需方式对其进行处理  立即回答确认 200状态代码            状态(Status)      代码      说明                  成功      &amp;lt; 400      交付已接收并成功处理。              错误      &amp;gt;= 400      交付已接收，但未成功处理。              重定向      3xx      交付已接收，但应重定向到其他 URL。      确认可以更新交付，使其包含确认。进行交付后，标题将作为请求的一部分提供。标头中包含交付记录的 ID（存储在 x-sg-delivery-id 键中）。此 ID 可用于更新交付记录，以使用 ShotGrid REST API 包含确认信息。                    确认信息的大小: 确认信息允许的最大大小为 4 KB。    标头示例{  &quot;accept&quot;: &quot;application/json&quot;,  &quot;content-type&quot;: &quot;application/json; charset=utf-8&quot;,  &quot;x-sg-webhook-id&quot;: &quot;30f279a0-42a6-4cf2-bb5e-6fc550d187c8&quot;,  &quot;x-sg-delivery-id&quot;: &quot;dea7a71d-4896-482f-b238-b61820df8b65&quot;,  &quot;x-sg-event-batch-id&quot;: &quot;1&quot;,  &quot;x-sg-event-batch-size&quot;: &quot;4&quot;,  &quot;x-sg-webhook-site-url&quot;: &quot;https://yoursite.shotgunstudio.com/&quot;,  &quot;x-sg-event-batch-index&quot;: &quot;3&quot;}确认有什么用途？确认允许在带外详细报告对 Webhook URL 已成功接收的交付的处理是成功还是失败。这会将从 ShotGrid 接收交付的状态与此次交付的关联事件处理成功还是失败分开。因此，成功交付的事件可以包含对调试有用的其他信息。一个很好的示例是在创建 Asset 实体时触发的 Webhook。如果该 Webhook 的职责是为每个新 Asset 在磁盘上创建目录结构，则 Webhook URL 可以成功接收交付，但由于磁盘或网络故障无法创建关联的目录。然后，它可以使用详细的错误消息更新交付记录，说明未创建目录结构及其原因。测试 Webhook您可以使用任何在线免费提供的 Webhook URL 生成器进行测试。这些服务专门用于测试 Webhook 和其他类型的 HTTP 请求。这是快速了解 Webhook 的好方法，无需在自己的网络上设置任何基础设施。使用 webhook.site我们建议使用 webhook.site。它提供了可复制并粘贴到 Webhook 的唯一 URL，并且向您实时显示向该地址执行的交付。可以自定义页面，以便对具有特定状态代码和正文的交付做出响应，这意味着您可以测试交付是成功还是失败。webhook.site 服务存在严格的速率限制。这意味着，最后很容易出现某些交付被拒绝，从而导致 Webhook 不稳定或失败的情况。在测试时，建议您使用已知且可控制的项目环境，而不是生产环境中的实时数据。                    制作数据: 建议不要将制作事件数据发送到可公开获得的第三方 Web 服务！我们建议仅当使用 webhook.site 等服务测试 Webhook 时才使用测试数据。    ",
    "url": "/3d448f5e/",
    "relUrl": "/3d448f5e/"
  },
  "209": {
    "id": "209",
    "title": "什么是缓存路径？什么是文件系统位置？",
    "content": "什么是缓存路径？什么是文件系统位置？缓存路径由 Toolkit 用来跟踪磁盘上的文件夹与 ShotGrid 中的实体之间的关联。主缓存以 FilesystemLocation 实体类型形式存储在 ShotGrid 中。之后，每个用户都有自己的缓存路径版本，该版本存储在磁盘本地的 Toolkit 缓存目录中，它将随着应用程序的启动或文件夹的创建而在后台进行同步。通常情况下，我们建议不要手动修改缓存路径。我们的内部流程不仅使本地缓存与 ShotGrid 中的 FilesystemLocation 实体同步，而且还创建事件日志条目，从而使所有用户的计算机都能与 ShotGrid 保持同步。有几个 tank 命令可用于修改缓存路径：  tank unregister_folders   移除缓存路径关联。  tank synchronize_folders 强制使本地缓存路径与 ShotGrid 同步。通常情况下，您不需要运行这些命令，但在某些情况下，它们可能会很有用。例如，在项目中重命名或重新创建实体之前，应该运行 unregister_folders。",
    "url": "/cbbf99a4/",
    "relUrl": "/cbbf99a4/"
  },
  "210": {
    "id": "210",
    "title": "我的日志文件位于何处？",
    "content": "我的日志文件位于何处？默认情况下，ShotGrid Desktop 和 ShotGrid 集成将其日志文件存储在以下目录中：Mac~/Library/Logs/Shotgun/Windows%APPDATA% Shotgun logs Linux~/.shotgun/logs/日志文件名采用 tk-&amp;lt;ENGINE&amp;gt;.log 格式。示例包括 tk-desktop.log 和 tk-maya.log。如果已将 ShotGrid_HOME 环境变量设置为覆盖用户的缓存位置，则日志文件将位于：$SHOTGUN_HOME/logs。                    注意: 您也可以从 ShotGrid Desktop 访问此目录。选择一个项目，单击项目名称右侧的向下箭头按钮，然后选择“打开日志文件夹”(Open Log Folder)。    ",
    "url": "/38c5c024/",
    "relUrl": "/38c5c024/"
  },
  "211": {
    "id": "211",
    "title": "我的缓存位于何处？",
    "content": "我的缓存位于何处？缓存根目录位置Toolkit 将某些数据存储在本地缓存中，以防止向 ShotGrid 服务器进行不必要的调用。这包括缓存路径、缓存和缩略图。虽然默认位置应该适用于大多数用户，但如果您需要更改它，可以使用 cache_location 核心挂钩对其进行配置。默认缓存根位置为：Mac OS X~/Library/Caches/ShotgunWindows%APPDATA% ShotgunLinux~/.shotgun缓存路径缓存路径位于：&amp;lt;site_name&amp;gt;/p&amp;lt;project_id&amp;gt;c&amp;lt;pipeline_configuration_id&amp;gt;/path_cache.db缓存分布式配置缓存是在 ShotGrid 站点的所有项目中使用的所有应用程序、插件和框架的缓存集合。分布式配置的缓存存储在以下位置：Mac：~/Library/Caches/Shotgun/bundle_cacheWindows：%APPDATA% Shotgun bundle_cacheLinux：~/.shotgun/bundle_cache                    注意: 您可以使用 SHOTGUN_BUNDLE_CACHE_PATH 环境变量覆盖这些位置，因此，特定实施可能会有所不同。    集中式配置集中式配置的缓存位于集中式配置内。...{project configuration}/install/如果您的配置使用共享核心，那么它将位于共享核心的安装文件夹内。缩略图Toolkit 应用（如加载器）使用的缩略图存储在本地 Toolkit 缓存中。它们根据需要按项目、工作流配置和应用进行存储。缓存根目录下的结构如下所示：&amp;lt;site_name&amp;gt;/p&amp;lt;project_id&amp;gt;c&amp;lt;pipeline_configuration_id&amp;gt;/&amp;lt;app_or_framework_name&amp;gt;/thumbs/",
    "url": "/7c9867c0/",
    "relUrl": "/7c9867c0/"
  },
  "212": {
    "id": "212",
    "title": "工作流",
    "content": "工作流一组基于 Toolkit 工作流的相关快速解答。  版本与已发布的文件之间有何差异？",
    "url": "/8396394b/",
    "relUrl": "/8396394b/"
  },
  "213": {
    "id": "213",
    "title": "工作流",
    "content": "工作流ShotGrid 工作流集成中的自定义项允许您使用工具来创建各种工作流：从动画长片到剧集工作流，从视觉特效到游戏。本部分包含用于构建特定工作流的资源。",
    "url": "/f5a4341f/",
    "relUrl": "/f5a4341f/"
  }
}
