{
  "0": {
    "id": "0",
    "title": "Flow Production Tracking Toolkit を使用する場合、3ds Max が起動時にクラッシュするのはなぜですか?",
    "content": "Flow Production Tracking Toolkit を使用する場合、3ds Max が起動時にクラッシュするのはなぜですか?Flow Production Tracking Toolkit または Flow Production Tracking Web サイトから 3ds Max を起動すると、真っ白なダイアログが表示されて 3ds Max がフリーズするか、または次のメッセージが表示されます。Microsoft Visual C++ Runtime Library (Not Responding)Runtime Error!Program: C: Program Files Autodesk 3ds Max 2016 3dsmax.exeR6034An Application has made an attempt to load the C runtime library incorrectly.Please contact the application's support team for more information.通常、これは、パス内の msvcr90.dll のバージョンと 3ds Max にバンドルされている Python のバージョンの競合が原因です。 解決策最初に、パイプライン設定の config/hooks フォルダに移動し、ファイル before_app_launch.py を作成します。そのファイル内に次のコードを貼り付けます。&quot;&quot;&quot;Before App Launch HookThis hook is executed prior to application launch and is useful if you needto set environment variables or run scripts as part of the app initialization.&quot;&quot;&quot;import osimport tankclass BeforeAppLaunch(tank.get_hook_baseclass()):    &quot;&quot;&quot;    Hook to set up the system prior to app launch.    &quot;&quot;&quot;    def execute(self, **kwargs):        &quot;&quot;&quot;        The execute functon of the hook will be called to start the required application        &quot;&quot;&quot;        env_path = os.environ[&quot;PATH&quot;]        paths = env_path.split(os.path.pathsep)        # Remove folders which have msvcr90.dll from the PATH        paths = [path for path in paths if &quot;msvcr90.dll&quot; not in map(            str.lower, os.listdir(path))        ]        env_path = os.path.pathsep.join(paths)        os.environ[&quot;PATH&quot;] = env_pathここでファイルを保存します。次に、パイプライン設定で config/env/includes/app_launchers.yml を開き、エントリ launch_3dsmax を探します。hook_before_app_launch: default を hook_before_app_launch: '{config}/before_app_launch.py' に置き換える必要があります。これで Flow Production Tracking と Flow Production Tracking Toolkit から 3ds Max を正しく起動できるようになりました。問題が解決しない場合は、サポート サイトにアクセスしてサポートを依頼してください。",
    "url": "/a7555f37/",
    "relUrl": "/a7555f37/"
  },
  "1": {
    "id": "1",
    "title": "About the Isolation Feature Set",
    "content": "What is the Isolation Feature SetThe isolation feature set combines our Cloud Hosted Platform with client-managed AWS resources to provide a solution that satisfies the most stringent security and privacy requirements. Clients retain control of their sensitive content without having to host Flow Production Tracking on their infrastructure.Leveraging the isolation feature set has the following advantages over the Standard offering:  Media Isolation by hosting of assets and attachments in a client-owned S3 Bucket  Media Traffic Isolation from the public internet  Media Replication allowing you to replicate media in one additional AWS Region  Access to fully managed Flow Production Tracking Cloud Services  Automatic and continuous version upgrades  Ephemeral compute + in-memory segration between clientsIn a nutshell, this means that with the isolation features, your Flow Production Tracking site and the data related to it cannot be reached by anyone outside of your studio network.The isolation feature set is a solution that requires less upkeep, as well as less IT/System Administrator knowledge and skills, than hosting Flow Production Tracking on-premise. The list of advantages compared to on-premise includes, but is not limited to:  No Flow Production Tracking specific knowledge required  No manual Flow Production Tracking updates required  Very low level of maintenance required for the AWS componentsMedia isolation featureMedia Isolation allows your studio to keep the ownership and control of the media and attachments that you upload to Flow Production Tracking. With Media Isolation, all the content that you upload to Flow Production Tracking can be store in your studio private S3 bucket. Access to the media is provided to the Flow Production Tracking service only, using AWS AssumeRole keyless Security Token Service. Your studio remains in control of the assets and the access to the assets, access that you can revoke at will.Traffic isolation featureMedia traffic isolation feature can be enabled to prevent your media traffic from being routed on the public internet, limiting it to the AWS backbone and your studio network. The traffic between Flow Production Tracking Services and your studio stays in closed network, never going outside AWS or your Studio network.With the Media Traffic Isolation feature activated, the media will only leave your studio infrastructure once to get transcoded.Media ReplicationFlow Production Tracking is compatible with the S3 Cross-Region replication feature, allowing your users located in different regions to read from the region closer to them in order to reduce latency and increase throughput. Replication to one region is currently supported.EligibilityThe Isolation feature set is available to clients with an active Flow Production Tracking subscription. See Getting Started for more details about how to active the different features. The activation of the isolation feature set is not instantaneous, and requires manual setup involving your AWS account.What the Isolation Feature Set is notThe isolation feature set is not a completely isolated solution. Both the compute services and the database services are shared amongst clients, and managed by Flow Production Tracking. From a hardware standpoint, the isolation features does not guarantee complete physical isolation. However, Flow Production Tracking services are guaranteeing isolation at the memory level. Processes are never reused to answer requests from different clients during their lifetime. Client metadata is stored in different databases. Client media is individually stored on S3.High Level ArchitectureThe Flow Production Tracking cloud service  can be decoupled at a high level in 3 parts:Compute Stack: The part of the Flow Production Tracking Service that handles client requests and serves data to the client.Data Stack: Metadata storage (databases).Media Storage: Where the client’s attachments, media, and assets are stored. Flow Production Tracking uses AWS S3 to store client content.Please read Securing Studio IP in AWS: Cloud-based VFX Project Management with Autodesk Flow Production Tracking for more details about the architecture.Ephemeral compute and memory isolationEven if clients share the same infrastructure, Flow Production Tracking guarantees a complete memory isolation, both in transit and at rest, of client data. This makes Flow Production Tracking less prone to data leaking due to architecture flaws or software vulnerabilities exploiting memory, like buffer overflow.Ephemeral transcodingEverytime media is uploaded to Flow Production Tracking, the transcoding service is invoked to create a web friendly versions of your assets. That process happens only once, after the initial upload. The media is directly uploaded from the client to S3, from where it is fetched by the Flow Production Tracking Transcoding Service. Each transcoding job is handled by a single container, which is killed after that unique job. The only place the media temporarily lives is in the container memory. The Flow Production Tracking Transcoding service doesn’t store permanently a copy of your media.",
    "url": "/84dfd5cc/",
    "relUrl": "/84dfd5cc/"
  },
  "2": {
    "id": "2",
    "title": "カスタム アクション メニュー アイテム",
    "content": "カスタム アクション メニュー アイテムAPI 開発者は、アクション メニュー アイテム(AMI)からエンティティごとにコンテキスト メニュー項目をカスタマイズできます。たとえば、Versions ページから複数のバージョンを選択して右クリックし、Build a PDF Report を選択します。アクション メニュー アイテム フィールド:1.[タイトル] (Title) (title): メニュー項目の表示名です。2.[エンティティ タイプ] (Entity Type) (entity_type): メニュー項目が特定のタイプのエンティティ ページ([バージョン] (Version)など)にのみ表示されるように制限します。このキー(nil 値)を省略すると、すべてのメニュー項目が有効になります。3.URL (url): PDF レポートを作成するスクリプトの URL です。4.[順序] (Order) (list_order): メニュー項目の順番です(他のカスタム メニュー項目に関連)。5.[軽量ペイロード] (Light Payload) (light_payload): カスタム プロトコルを使用している場合、スクリプトは、完全なペイロードではなく、ペイロード情報を保持するイベント ログ エントリ レコードの ID を受け取ります。6:設定メニュー オプション: 次のオプションから選択できます。      [エンティティ レコードの右クリック メニューに含める] (Include in the right-click menu on an Entity record): レコードを右クリックして AMI を含める既定値です。        エンティティ ページの[エンティティを追加] (Add Entity)ドロップダウン メニューに含める: この AMI を[エンティティの追加] (Add Entity)ドロップダウンメニューに含めるオプション(例: 「アセットの追加」、「ショットの追加」など)。        エンティティ ページの[エンティティを追加] (Add Entity)ボタンをオーバーライド: このオプションを使用すると、[エンティティの追加] (Add Entity)ボタンを AMI で上書きすることができます。        [ユーザ]メニューの内部リソース セクションに含める: これにより、内部リソースを使用してユーザ メニューをカスタマイズすることができます。内部リソースを使用してユーザ メニューをカスタマイズする方法の詳細については、こちらを参照してください。  7.[フォルダ] (Folder) (folder): コンテキスト メニュー内のフォルダに AMI を収納できます(現在は単一レベルのフォルダのみをサポート)。8.[モーダル オーバーレイで開く] (Open in Modal Overlay): AMI を新しいタブで開かずに、iframe ウィンドウ内に開くことができます。Shotgun で HTTPS が実行されている場合は、すべての iframe を HTTPS に設定する必要もあります。9.[データ更新のポーリング] (Poll for Data Updates) (poll_for_data_updates): イベント ログ エントリをクエリーするためのポーリング ループを開始します。これは、ActionMenuItem の反対側のコードを変更して、ActionMenuItem をトリガしたページに表示されているエンティティの API を介して Shotgun に戻る場合に使用します。10.[権限グループに制限] (Restrict to Permission Groups) (permissions_groups): AMI へのアクセスを、指定した権限グループのみに制限できます。空の場合は、すべてのユーザが AMI を使用できます。11.[プロジェクトに制限] (Restrict to Projects) (projects): AMI が指定したプロジェクトにのみ表示されるようにします。空の場合は、すべてのプロジェクトで AMI を使用できます。12.[シークレット トークン] (Secret Token): シークレット トークンを設定して、AMI を保護します。13.[選択が必要] (Selection Required) (selection_required): 選択中の行がない場合にメニュー項目を有効にするかどうかを決定します。アクション メニュー アイテムのタイプ作成できるメニュー項目は次の 2 つです。HTTP URL の例たとえば、「Build PDF Report」と呼ばれるカスタム メニュー項目を作成できます。 これにより、ユーザは任意のバージョン ページに移動し、1 つまたは複数のバージョンを選択して右クリックし、Flow Production Tracking メニューから「Build PDF Report」を選択することができます。この操作により、スクリプトが起動し(このスクリプトは作成する必要があります)、適切にフォーマット化されたレポートがブラウザに送られます。次にその方法を説明します。UI を使用してメニュー項目を作成する設定メニューから[アクション メニュー アイテム] (Action Menu Item)を選択し、AMI の管理ページを開きます。新しい AMI を作成するには、をクリックします。タイトルと他の必須フィールドを入力し、[アクション メニュー アイテムを作成] (Create Action Menu Item)をクリックします。ユーザが AMI をクリックすると起こることFlow Production Tracking が新しいウィンドウ(オプションが選択されている場合はモーダル ダイアログ)で POST 要求を割り当て、現在のページから POST 要求に含まれるデータを受信 URL にデータを送信します。次に、ワークフローの例を示します。  [バージョン] (Versions)ページに移動します  1 つまたは複数のバージョンを選択します  コンテキスト メニューを表示します(ツールバーの歯車メニューを右クリックまたはクリック)  ユーザが Build PDF Report をクリックします  Flow Production Tracking が新しいウィンドウで POST 要求を AMI の URL に割り当てます(Flow Production Tracking サーバに HTTPS 経由で接続している場合に、URL を HTTP 経由で送受信すると、ブラウザに警告が表示されます)  指定した URL に格納されたスクリプトが POST データを処理し、PDF ドキュメントを生成します  適切にフォーマット化された PDF レポートが、表示またはダウンロード用にユーザに送り返されますカスタム プロトコル ハンドラの例カスタム AMI の最新の実装には、カスタム プロトコル ハンドラのセットアップが含まれます(例: Flow Production Tracking://process_version)。これにより、ローカル コンピュータ上のスクリプトを介して Maya、RV、Cinesync などのアプリケーションと Flow Production Tracking を接続できます。HTTP(S)プロトコル以外を指定すると、POST の代わりに GET を使用してデータが URL に送信されます。異なる要求を割り当てる社内ツールを起動するために使用することもできます。カスタム プロトコルの詳細については、「カスタム ブラウザ プロトコルを使用してアプリケーションを起動する」を参照してください。  注: Flow Production Tracking の統合により、Maya などのソフトウェア パッケージに組み込んで統合することもできます。  軽量ペイロードカスタム プロトコルを使用する場合、クエリー情報は GET 要求として送信されます。特定のオペレーティング システムとブラウザの組み合わせには、許容される GET 要求のサイズに関するさまざまな制限事項があります。カスタム プロトコル AMI で軽量ペイロード チェックボックスをオンにすることをお勧めします。軽量ペイロードをオンにすると、レコードの meta フィールドの ami_payload キーを読み取ることで完全なペイロードを取得するためにフェッチできる、単一のイベント ログ エントリ ID をスクリプトが受け取ります。例次に、基本的ないくつかのサンプル スクリプトを示します。  ActionMenuItem 呼び出しの処理  バージョン パッケージャペイロードの内容ユーザ データ  user_id: 現在ログイン中のユーザのユーザ ID (例: 34)  user_login: 現在ログイン中のユーザのログイン(例: joe)エンティティ データ  entity_type: 現在のページまたはビューのエンティティ タイプ(例: Version)  selected_ids: 選択したエンティティ ID のカンマ区切りリスト(例: 931、900)  ids: 現在のページのクエリーが返すエンティティのすべての ID のカンマ区切りリスト。これにより、ページネーションが原因で表示されない ID を含めたすべての ID が返されます(例: 931, 900, 904, 907)AMI で[選択が必要] (Selection required)がオンになっている場合、この値は selected_ids と同じ値になります。ページ データ  title: ページ タイトル(例: “All Versions”)  page_id:アクション メニュー アイテムのクリック元のページの ID (例: 1353)  server_hostname: AMI がトリガされたシステムのホスト名。同じ AMI を呼び出す複数のサーバがある場合に役立ちます(ステージング サーバとプロダクション サーバなど)。  referrer_path: AMI が呼び出された URL の正規のパス。  session_uuid: この AMI が呼び出されたウィンドウの一意の識別子。これは、[データ更新のポーリング] (Poll for Data Updates)チェックボックスと Python API の set_session_uuid メソッドと一緒に使用して、AMI が呼び出されたページに情報を一斉送信することができます。注: この機能の更新のポーリングは急激に減少し、最終的に停止します。そのため、ポーリングが停止する前に AMI が更新されない場合、ソース ページに更新が表示されないことがあります。  cols: ページで表示可能なすべての列のシステム フィールド名を含むカンマ区切りリスト(例: code, sg_status_list, description)  column_display_names: ページで表示可能なすべての列の表示名を含むカンマ区切りリスト(例: Version, Status, Description)  view: AMI が呼び出されたときに選択されていたビュー。ページのデザイン モードを使用して、任意のページに対して複数のビューを作成できます。  sort_column: ソート基準となった列のシステム名(例: code)。最初のソート キーのみが送信されます。複数ある場合は、sort_columns を参照してください  sort_direction: (例: asc または desc)最初のソート方向のみが送信されます。複数ある場合は、sort_directions を参照してください  sort_columns: ページまたはビューのソート基準となった列のシステム名のカンマ区切りリスト(例: code,created_at)。複数のソート キーがある場合にのみ送信されます  sort_directions: ページまたはビューのソート基準となった列のシステム名のカンマ区切りリスト(例: code, created_at)。複数のソート キーがある場合にのみ送信されます  grouping_column: グループ化の基準となった列のシステム名(例: code)。最初のグループ化列のみが送信されます。複数ある場合は、grouping_columns を参照してください  grouping_method: グループ化する方法(例: エンティティ フィールドの場合は entitytype によるグループ化、日付フィールドの場合は month によるグループ化)。最初のグループ化方法のみが送信されます。複数ある場合は、grouping_methods を参照してください  grouping_direction: グループ化の方向(例: asc または desc)。複数のグループ化がある場合は、最初のグループ化の方向のみが送信されます。grouping_directions を参照してください。  grouping_columns: データをグループ化する際の基準となった列のシステム名のカンマ区切りリスト(例: code,created_at)。複数のグループ化列がある場合にのみ送信されます  grouping_methods: グループ化方法のカンマ区切りリスト(例: entity_type,month)。複数のグループ化列がある場合にのみ送信されます  grouping_directions: グループ化の方向のカンマ区切りリスト(例: asc,desc)。複数のグループ化列がある場合にのみ送信されますプロジェクト データ(現在のページのすべてのエンティティが同じプロジェクトを共有する場合のみ送信されます)  project_name: プロジェクトの名前(例: Gunslinger)  project_id: プロジェクトの ID (例: 81)内部リソース メニューユーザ メニューの内部リソースのアクション メニュー項目の活用の詳細については、『管理者ガイド』を参照してください。",
    "url": "/67695b40/",
    "relUrl": "/67695b40/"
  },
  "3": {
    "id": "3",
    "title": "アクション メニュー アイテム",
    "content": "アクション メニュー アイテムこのセクションでは、カスタム アクション メニュー アイテム(AMI)の作成と、カスタム ブラウザ プロトコルを使用したアプリケーションの起動について説明します。  カスタム アクション メニュー アイテム  カスタム ブラウザ プロトコルを使用してアプリケーションを起動するユーザ メニューの内部リソースのアクション メニュー項目の活用の詳細については、『管理者ガイド』を参照してください。",
    "url": "/581648bb/",
    "relUrl": "/581648bb/"
  },
  "4": {
    "id": "4",
    "title": "Activation",
    "content": "ActivationOnce everything is configured and properly tested, it’s now time to migrate your production site to use the isolation features.TestNavigate to the /admin/speedtest route of your Flow Production Tracking site. Select the new S3_CONFIG_NAME that was just set up previously and start the test to confirm that all the upload/download tests work as intended.Switch to your own Isolation S3 BucketNavigate to the Advanced section of Site Preferences page and set the storage location to your own S3 bucket.",
    "url": "/47ecbf94/",
    "relUrl": "/47ecbf94/"
  },
  "5": {
    "id": "5",
    "title": "管理",
    "content": "管理Toolkit セットアップの管理および設定に基づくクイック アンサーのコレクションです。Flow Production Tracking デスクトップ:  Flow Production Tracking Toolkit を使用して Toolkit プロジェクトを再セットアップするにはどうすればいいですか?  Windows で Flow Production Tracking Toolkit をサイレント インストールするにはどうすればいいですか?  Linux で Flow Production Tracking Toolkit のデスクトップ/ランチャー アイコンをセットアップするにはどうすればいいですか?  Flow Production Tracking Toolkit のブラウザ統合を無効にするにはどうすればいいですか?設定の管理:  複数のストレージ ルートを使用するように設定を変更するにはどうすればいいですか?  パイプライン設定を新しい場所に移動するにはどうすればいいですか?  プロジェクト ディレクトリを新しいローカル ストレージのルートに移動するにはどうすればいいですか?  パイプライン設定のコアの場所を更新するにはどうすればいいですか?  プロジェクト間でアセットを共有するにはどうすればいいですか?  アプリまたはエンジンをアンインストールするにはどうすればいいですか?キャッシュベースの質問:  パス キャッシュとは何ですか? ファイルシステムの場所とは何ですか?  キャッシュの場所",
    "url": "/ba09d04c/",
    "relUrl": "/ba09d04c/"
  },
  "6": {
    "id": "6",
    "title": "管理",
    "content": "管理Flow Production Tracking のパイプライン統合により、幅広いカスタマイズ オプションが提供されます。スタジオが必要とするパイプラインを稼働させるには、設定を行い、コマンドライン ツールを実行し、スタジオ環境で Flow Production Tracking ツールが動作することを確認する必要があります。このセクションには、スタジオの Flow Production Tracking Toolkit パイプラインの管理に関する情報が記載されています。",
    "url": "/a944bb05/",
    "relUrl": "/a944bb05/"
  },
  "7": {
    "id": "7",
    "title": "高度な Toolkit 管理",
    "content": "高度な Toolkit 管理ここでは、高度な設定用に Toolkit を管理および設定する方法について紹介します。このトピックの内容:  はじめに  Tank コマンドを使用する          デバッグ モードで実行する      Tookit API を使用して Tank コマンドを実行する      役に立つ Tank コマンド                  setup_project          core          configurations          updates          install_app, install_engine          app_info          folders, preview_folders          shell          dump_config 高度な Tank コマンド                      Toolkit Python API  パイプライン設定とサンドボックス          サンドボックス用に Tank コマンドを実行する      サンドボックスの Core API を使用する      サンドボックスにアクセスする      パイプライン設定をローカライズする      クローン作成した環境設定を削除する        更新を確認する          ステージング サンドボックスを作成する        アプリの起動方法を設定する  ディスク上にフォルダを作成する          ファイル システムの場所      Toolkit のフォルダの名前を変更する      遅延作成とユーザ サンドボックス        テンプレートを設定する          テンプレート ファイルの @include 構文      テンプレート ファイルに外部ファイルを含める      フォルダ作成とテンプレート        フック          アプリ レベル フック      コア レベル フック      スタジオ レベル フック      プロジェクト名フック      接続フック        アプリとエンジンを設定する          アプリごとの場所の設定      ファイルをインクルードする      テンプレート設定(ファイル パス)を設定する      フックを使用してアプリの動作をカスタマイズする      はじめにFlow Production Tracking Toolkit 管理者ガイドへようこそ。このドキュメントでは、管理者から見た Flow Production Tracking Toolkit との連携方法、アプリのインストールと更新、新しいプロジェクトのセットアップ、スタジオ設定の管理について説明します。Toolkit はある程度技術的であるため、設定と管理の担当者はシステム管理者、パイプラインやツールの開発者、または TD である必要があります。詳細を説明する前に、以下のドキュメントをまだ確認していない場合は先に確認することをお勧めします。数多くの基本的なコンセプトと、設定管理と更新の概要について説明されています。 Pipeline Toolkit の基本的なコンセプトの概要Flow Production Tracking Toolkit をまだセットアップしていない場合は、『統合ユーザ ガイド』を参照してください。Tank コマンドを使用するFlow Production Tracking Toolkit を管理して Toolkit を一般的に使用する場合は、tank コマンドを使用することになります。tank コマンドを使用すると、コマンド シェルから管理コマンドと実際のアプリの両方をすばやく簡単に実行できます。既定では、新しいプロジェクトごとに独自の Core API とその独自の tank コマンドを作成します。プロジェクト設定の場所に移動して tank コマンドを実行すると、このプロジェクトに適用可能なすべてのコマンドが表示されます。cd /mnt/software/ShotGrid/big_buck_bunny./tankTank コマンドはさまざまな方法で使用することができます。基本的な考え方としては、まず動作させる場所を Tank コマンドに指示し、次に実行する内容を指示します。 実行する内容を指示しない場合は、利用可能なすべてのコマンドのリストが表示されます。 動作させる場所を指示しない場合は、現在のディレクトリが使用されます。 また、Tank コマンドを使用すると、Flow Production Tracking で項目をリスト表示することもできます。Tank コマンドの使用方法の基本的な概要を次に示します。# Show all tank commands for an asset named 'piano'&amp;gt; tank Asset piano# We can also list all assets containing the phrase 'pi'&amp;gt; tank Asset pi# We can execute the built-in folder creation command for# the piano&amp;gt; tank Asset piano folders# If the application launcher app is installed, we can launch maya# and set the work area to the piano&amp;gt; tank Asset piano launch_maya# Alternatively, we can specify a path on disk instead of a Flow Production Tracking entity&amp;gt; tank /mnt/projects/hero/assets/piano launch_maya# Or we can change our work directory and run tank like this&amp;gt; cd /mnt/projects/hero/assets/piano launch_maya&amp;gt; tank launch_mayaデバッグ モードで実行する内部で何が起こっているかを確認すると役立つことがあります。tank コマンドに --debug フラグを渡すと、詳細な出力とタイミング設定が有効になるため、問題を簡単にトラックしたり、予想外の動作の理由を把握したりできます。Tookit API を使用して Tank コマンドを実行するほとんどの Tank コマンドの実行も API を使用して完全にサポートされています。このため、幅広いスクリプト作成ワークフローの一部として、Toolkit に関連するメンテナンス操作を簡単に実行できます。この詳細については、「Core API リファレンス」を参照してください。役に立つ Tank コマンド次に、Flow Production Tracking Toolkit の管理に役立つ Tank コマンドの簡単なリストを示します。setup_projectFlow Production Tracking Toolkit にあるセットアップ プロジェクト ウィザードのコマンド ライン バージョンです。Flow Production Tracking Toolkit を使用して新しいプロジェクトを設定します。Flow Production Tracking 内にプロジェクトがあり、このプロジェクトを拡張して Toolkit を使用する場合は、ここから開始します。コマンドに従ってプロセスを進めると、使用する設定やセットアップするプロジェクトなど、さまざまな情報の入力が求められます。同一プロジェクトで setup_project を再実行する既定では、setup_project はまだセットアップされていないプロジェクトのみを表示します。ただし、多くの場合、特にテスト中は同一プロジェクトで setup_project を再実行する必要があります。このためには、以前にセットアップされているプロジェクトを特定するメモを使用して、すべてのプロジェクトを表示する –force フラグを指定します。&amp;gt; tank setup_project --forceWelcome to SGTK!For documentation, see https://developer.shotgridsoftware.com- Running setup_project...force mode: Projects already set up with Toolkit can be set up again.Welcome to SGTK Project Setup!Connecting to Flow Production Tracking...Connecting to the App Store...------------------------------------------------------------------Which configuration would you like to associate with this project?You can use the configuration from an existing project as a template for thisnew project. All settings, apps and folder configuration settings will becopied over to your new project. The following configurations were found:   big_buck_bunny: '/mnt/software/sgtk/big_buck_bunny'   ghosts: '/mnt/software/sgtk/ghosts'   chasing_perfection: '/mnt/software/sgtk/chasing_perfection'If you want to use any of the configs listed about for your new project, justtype in its path when prompted below.You can use the Default Configuration for your new project.  The defaultconfiguration is a good sample config, demonstrating a typical basic setup ofthe Flow Production Tracking Toolkit using the latest apps and engines. This will beused by default if you just hit enter below.If you have a configuration stored somewhere on disk, you can just enter thepath to this config it will be used for the new project.[tk-config-default]:Downloading Config tk-config-default v0.4.15 from the App Store...This is the 'Default Config' config.Below are all active projects, including ones that have been set up:--------------------------------------------------------------------[ 4] Demo Project     Fubar is an epic story of an on-going political wa...[ 5] Big Buck BunnyNote: This project has already been set up.     A killer bunny movie[ 6] The Ghosts of Pere LachaiseNote: This project has already been set up.     De Films en Aiguille and ChezEddy present this year...[ 7] Chasing PerfectionNote: This project has already been set up.     You've seen the car commercials, the car races, and...[ 8] What Happened to My Headphones?     The Ryan Mayeda storyPlease type in the id of the project to connect to or ENTER to exit:Toolkit は、プロジェクト セットアップ プロセスの一部としてプロジェクト名を提案します。その名前に問題がない場合は、[Enter]キーを押して続行するか、手動で別の名前を入力できます。プロジェクト用に特別な独自の命名規則がある場合は、セットアップ プロジェクト プロセスで提案される既定値を制御することもできます。それには高度なスタジオ レベルのフックを使用します。本ドキュメントのスタジオ レベルのフック セクションを参照してください。coreCore API の更新をチェックします。アプリ ストアに接続し、最新バージョンの Core API が利用可能かどうかを確認します。利用可能な場合、更新するかどうかを尋ねられます。このコマンドの出力例:&amp;gt; tank coreWelcome to Sgtk!Starting Sgtk for your current directory '/private/tmp'- Running core...WARNING: You are potentially about to update the Core API for multipleprojects.Welcome to the Sgtk update checker!This script will check if the Sgtk Core APIinstalled in /mnt/software/sgtk/studiois up to date.You are currently running version v0.13.22 of the Sgtk PlatformNo need to update the Sgtk Core API at this time!configurationsプロジェクトの全環境設定の概要を表示します。プロジェクトの現在のアクティビティの概要を取得する場合に便利です。このコマンドの出力例:&amp;gt; tank Project Bunny configurationsWelcome to Sgtk!Will search across all Flow Production Tracking Projects.- Found Project Big Buck Bunny- Starting Sgtk v0.13.22 using configuration/mnt/software/sgtk/big_buck_bunny.- Setting the Context to Big Buck Bunny.- Running configurations...Fetching data from Flow Production Tracking...======================================================================Available Configurations for Project 'Big Buck Bunny'======================================================================Configuration 'Primary' (Public)-------------------------------------------------------This is the Project Master Configuration. It will be used whenever thisproject is accessed from a studio level sgtk command or API constructor.Linux Location:  /mnt/software/sgtk/big_buck_bunnyWinows Location: z: mnt software sgtk big_buck_bunnyMac Location:    /mnt/software/sgtk/big_buck_bunnyThis configuration is using a shared version of the Core API.If you want it torun its own independent version of the Toolkit Core API, you can run:&amp;gt; /mnt/software/sgtk/big_buck_bunny/tank localizeIf you want to check for app or engine updates, you can run:&amp;gt; /mnt/software/sgtk/big_buck_bunny/tank updatesIf you want to change the location of this configuration, you can run:&amp;gt; /mnt/software/sgtk/big_buck_bunny/tank move_configurationThis is a public configuration. In Flow Production Tracking, the actions defined in thisconfiguration will be on all users' menus.Configuration 'Dev Area' (Private)-------------------------------------------------------Linux Location:  /Users/manne/sgtk_devWinows Location: z: Users manne sgtk_devMac Location:    /Users/manne/sgtk_devThis configuration is using a shared version of the Core API.If you want it torun its own independent version of the Toolkit Core API, you can run:&amp;gt; /Users/manne/sgtk_dev/tank localizeIf you want to check for app or engine updates, you can run:&amp;gt; /Users/manne/sgtk_dev/tank updatesIf you want to change the location of this configuration, you can run:&amp;gt; /Users/manne/sgtk_dev/tank move_configurationThis is a private configuration. In Flow Production Tracking, only Admin 3 will see the actionsdefined in this config. If you want to add additional members to thisconfiguration, navigate to the SG Pipeline Configuration Page and addthem to the Users field.updatesこのコマンドはプロジェクトに関連付けられているすべての環境を表示し、最新バージョンのアプリやエンジンが利用可能かどうかを確認します。アプリとエンジンのインストール方法に応じて異なりますが、ローカルの git リポジトリ、Github、または Flow Production Tracking Toolkit アプリ ストアが確認されます。最新バージョンが検出された場合は、セットアップを更新するかどうかが尋ねられます。新しい設定パラメータが最新バージョンのアプリで導入されている場合は、値についてプロンプトが表示されることがあります。一般的な構文:&amp;gt; tank updates [environment_name] [engine_name] [app_name]特別なキーワードである ALL を使用すると、カテゴリ内のすべての項目を指定できます。以下に例を示します。  すべてをチェックする: tank updates  ショット環境をチェックする: tank updates Shot  すべての環境内のあらゆる Maya アプリをチェックする: tank updates ALL tk-maya  ショット環境内のあらゆる Maya アプリをチェックする: tank updates Shot tk-maya  Loader アプリが常に最新の状態を維持するようにする: tank updates ALL ALL tk-multi-loader  Loader アプリが Maya で最新の状態を維持するようにする: tank updates ALL tk-maya tk-multi-loaderinstall_app、install_engineプロジェクトに関連付けられた環境の 1 つに新しいエンジンまたはアプリをインストールします。このコマンドを使用すると、Toolkit アプリまたは git のいずれかからインストールできます。app_infoすべてのアプリとその主な環境設定の概要が表示されます。folders、preview_foldersディスク上で項目のフォルダを作成します。このコマンドの出力例Welcome to Sgtk!Will search across all Flow Production Tracking Projects.- Found Asset Squirrel (Project 'Big Buck Bunny')- Starting Sgtk v0.13.22 using configuration/mnt/software/sgtk/big_buck_bunny.- Setting the Context to Asset Squirrel.- Running folders...Creating folders, stand by...The following items were processed: - /mnt/projects/big_buck_bunny - /mnt/projects/big_buck_bunny/reference - /mnt/projects/big_buck_bunny/reference/artwork - /mnt/projects/big_buck_bunny/reference/footage - /mnt/projects/big_buck_bunny/sequences - /mnt/projects/big_buck_bunny/assets - /mnt/projects/big_buck_bunny/assets/Character - /mnt/projects/big_buck_bunny/assets/Character/Squirrel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/sgtk_overrides.yml - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/elements - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/photoshop/jpg - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/photoshop/psd - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/reference - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/reference/artwork - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/reference/footage - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/review - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/images - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/maya/workspace.mel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/maya/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/nuke/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/photoshop/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/elements - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/photoshop/jpg - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/photoshop/psd - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/reference - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/reference/artwork - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/reference/footage - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/review - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/images - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/maya/workspace.mel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/maya/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/nuke/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/photoshop/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/elements - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/photoshop/jpg - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/photoshop/psd - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/reference - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/reference/artwork - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/reference/footage - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/review - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/images - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/maya/workspace.mel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/maya/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/nuke/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/photoshop/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/elements - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/photoshop/jpg - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/photoshop/psd - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/reference - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/reference/artwork - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/reference/footage - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/review - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/images - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/maya/workspace.mel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/maya/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/nuke/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/photoshop/snapshotsIn total, 93 folders were processed.shell現在選択しているコンテキストでインタラクティブな Python シェルを開始します。初期化済み API、コンテキスト、エンジン オブジェクトに関する便利なリファレンスをセットアップします。./tank shell を使用すると、Toolkit と Flow Production Tracking API のコード例を試してみることができます。Tank の実行可能ファイルはローカル マシン上のパイプライン設定ルートに格納されており、次のようなコードになります。&amp;gt; cd /my_tank_configs/project_foobarこのコマンドの出力例:Welcome to SGTK!For documentation, see https://developer.shotgridsoftware.comYou are running a tank command associated with Flow Production Tracking Project 'Chasing theLight'. Only items associated with this project will be considered.- Found Shot moo87 (Project 'Chasing the Light')- Starting the SG pipeline toolkit v0.15.14.- Setting the Context to Shot moo87.- Started Shell Engine version v0.3.3- Environment: /mnt/software/tank/chasing_the_light/config/env/shot.yml.- Running shell...Welcome to SG Pipeline Toolkit Python!2.7.1 (r271:86832, Jul 31 2011, 19:30:53)[GCC 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2335.15.00)]Running on darwin- A tk API handle is available via the tk variable- A Shotgun API handle is available via the Shotgun variable- Your current context is stored in the context variable- The shell engine can be accessed via the engine variable&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; tk&amp;lt;Sgtk Core vHEAD@0x105f66990 Config /mnt/software/tank/chasing_the_light&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; context&amp;lt;Sgtk Context:   Project: {'type': 'Project', 'id': 88, 'name': 'Chasing the Light'}  Entity: {'type': 'Shot', 'id': 1184, 'name': 'moo87'}  Step: None  Task: None  User: {'type': 'HumanUser', 'id': 42, 'name': 'Manne  xc3 x96hrstr xc3 xb6m'}  Additional Entities: []&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Shotgun&amp;lt;tank_vendor.Shotgun_api3.Shotgun.Shotgun object at 0x105fb2990&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; engine&amp;lt;Sgtk Engine 0x105feead0: tk-shell, env: shot&amp;gt;&amp;gt;&amp;gt;&amp;gt;上記の例では、./tank は Python シェルを開始し、必要に応じていくつかの変数をセットアップしています。このため、上記変数にこのようなハンドルとコンテキストを指定すると、認証とユーザ セッションのセットアップや Flow Production Tracking サイトへの接続の開始など、基本的な作業が省略されます。  変数 tk には Toolkit API にアクセスできるハンドルがあります。  変数 Flow Production Tracking には、サイトに既に接続され、[Flow Production Tracking サイト]のデータベースや他の項目をクエリーする準備が完了した Flow Production Tracking API のハンドルがあります。  コンテキスト変数は現在のコンテキスト(プロジェクト、ショット、アセット、パイプライン ステップ、ユーザなど)を読み込みます。アクティブなコンテキストの例については、こちらを参照してください。この例では、コンテキスト インスタンスを使用して現在のコンテキストを定義する主なフィールド セットを収集します。コンテキストは現在の作業領域として参照することがあります。通常、これは誰かが作業している現在のショットまたはアセットになります。この例で、プロジェクトは「Chasing the Light」、ID は 1184、ショットは「moo87」です。割り当てられたパイプライン ステップやタスクはありませんが、ユーザは Manne です。Toolkit API のスクリプトを作成する場合にこの情報が必要になる場合がありますが、すべての情報はこの便利なコンテキスト変数から入手できます。&amp;lt;Sgtk Context:   Project: {'type': 'Project', 'id': 88, 'name': 'Chasing the Light'}     Entity: {'type': 'Shot', 'id': 1184, 'name': 'moo87'}     Step: None     Task: None     User: {'type': 'HumanUser', 'id': 42, 'name': 'Manne  xc3 x96hrstr xc3 xb6m'}     Additional Entities: []&amp;gt;変数 engine は、現在動作中のシェル エンジンのインスタンスを指しています。dump_configCore v0.18 で利用可能です。既存の環境設定を STDOUT または別のファイルにダンプします。環境設定の完全表現または簡易表現をダンプする機能があります。完全表現にはすべての設定の既定値が含まれ、簡易表現には設定の既定値とは異なる値のみが含まれます。既定では、コマンドの出力には、既定値を見つけた場所のマニフェストと設定とは異なる既定値を記録する各設定のコメントが含まれます。このコマンドは、安全対策として既存のファイルへの環境設定のダンプを許可していません。使用方法:./tank dump_config env_name [--sparse | --full] [--no_debug-comments] [--file=/path/to/output/file.yml]このコマンドの出力例:&amp;gt; ./tank dump_config shot_step --sparse --file=/tmp/shot_step.ymlWelcome to SGTK!For documentation, see https://developer.shotgridsoftware.comStarting toolkit for path '/Shotgun/configs/sparse34913'- The path is not associated with any SG object.- Falling back on default project settings.- Running as user 'Toolkit'- Using configuration 'Primary' and Core HEAD- Setting the Context to sparse34913.- Running command dump_config...----------------------------------------------------------------------Command: Dump config----------------------------------------------------------------------Dumping config...上記のコマンドを実行すると、/tmp/shot_step.yml に現在のプロジェクトの環境ファイル shot_step の簡易表現のコピーが書き込まれます。追加のデバッグ コメントを除外するには、--no_debug_comments フラグを使用します。高度な Tank コマンド次に、Flow Production Tracking Toolkit の管理に使用できる高度な Tank コマンドの簡単なリストを示します。      tank share_core: 新しいプロジェクトを作成すると、多くの場合、各プロジェクトで Core API のコピーを独自に管理するように新しいプロジェクトが作成されます。このコマンドを使用すると、このようなプロジェクトの Core API を取り込み、ディスク上の別の場所に移動することができます。これにより、複数のプロジェクトで Core API の 1 つのコピーが共有されるように共有コアを作成できます。        tank attach_to_core: 新しいプロジェクトを作成すると、多くの場合、各プロジェクトで Core API のコピーを独自に管理するように新しいプロジェクトが作成されます。このコマンドを使用すると、独自の組み込みバージョンの Core API を維持するのではなく、既存の Core API インストールに設定を追加できます。        tank localize: このコマンドは、特定のパイプライン設定の場所に Core API をダウンロードします。これは、Toolkit のステージング領域内で新しいバージョンの Core API をテストする場合に役立ちます。このプロセスの詳細はこの文書の後半で説明します。        tank clear_cache: Toolkit の一部のキャッシュをクリアします。これは、メニュー項目が何らかの理由で Flow Production Tracking 内に表示されない場合に役立ちます。        tank validate: プロジェクト設定を検証します        tank cache_apps: 必要なすべてのアプリ、エンジン、およびフレームワークのバージョンがディスク上に保存されていることを確認します。        tank switch_app: 開発に役立ちます。アプリ ストア モードからローカル モードや git モードにアプリを切り替えたり、またはその逆の切り替えを行います。        tank push_configuration: 現在のパイプライン設定に含まれる環境設定を別のパイプライン設定に送信します。  Toolkit Python APIFlow Production Tracking Toolkit、tank コマンド、または Flow Production Tracking を使用してアプリケーションを起動する場合、Toolkit は PYTHONPATH に自動的に追加されて、初期化されます。Toolkit API を手動で取得して実行する場合に役立つことがあります。このためには、Toolkit Core API を Python パスに追加して読み込みます。各プロジェクト設定の project_config_root/install/core/python 内に python フォルダがあります。この場所を Python パスに追加するだけで sgtk API を読み込むことができます。import sgtk# create a Sgtk API object for a Flow Production Tracking entitytk = sgtk.sgtk_from_entity(&quot;Shot&quot;, 123)# Create a Sgtk API object based on a file system locationtk = sgtk.sgtk_from_path(&quot;/mnt/projects/hero/assets/chair&quot;)パイプライン設定とサンドボックスパイプライン設定の基本構造はスタジオのインストールと同じです。最も重要なのは、tank コマンドと install/core/python 内の Toolkit API の両方が含まれることです。API と Tank コマンドが各設定で複製される理由は、プロダクション環境以外で開発と作業を簡単に行うことができるようにするためです。新しいプロジェクトを Flow Production Tracking Toolkit でセットアップすると、プロジェクトのプライマリ パイプライン設定が作成されます。これは常に「プライマリ」と呼ばれ、プロジェクトの主要な設定を表します。プロジェクトのパイプライン設定エンティティの形式で Flow Production Tracking 内に表示される環境設定を確認できます。開発時や環境設定の変更を行う場合、通常はプライマリ環境設定で作業は行いません。何かを偶然壊した場合、そのプロジェクトで作業するすべてのユーザが影響を受けるからです。代わりに、Flow Production Tracking 内の環境設定の「クローン」を作成できます。これで、独自の並列設定を使用して、他のユーザに影響を与えずに変更を加えることができます。サンドボックス用に Tank コマンドを実行するスタジオ レベルの tank コマンドを使用してアプリを実行する場合は、プロジェクトに対して常にプライマリ環境設定が使用されます。そのため、tank Shot ABC123 launch_maya と入力するだけで、Flow Production Tracking Toolkit はこのショット ABC123 が属するプロジェクトを探し、そのプライマリ パイプライン設定を見つけ、Maya の起動時にその設定が使用されます。あるいは、開発サンドボックスで実験的な設定を使用する必要がある場合は、Maya を起動するために開発サンドボックス内で特定の Tank コマンド(~/sgtk_dev_sandbox/tank Shot ABC123 launch_maya)を使用します。Toolkit はプロジェクトのプライマリ環境設定の代わりに開発サンドボックスで実験的な設定を使用できるようになります。サンドボックスの Core API を使用する同様に、スタジオのインストール場所ではなく、パイプライン設定内から Toolkit API を実行する場合は、スタジオの Python API ではなく、PYTHONPATH に開発サンドボックスを追加できます。サンドボックスにアクセスするFlow Production Tracking 内ではさらに簡単です。プロジェクトの各パイプライン設定にはこの設定を表示できるユーザのリストがあります。このフィールドを空のままにすると、すべてのユーザにこの設定が表示されます。環境設定のクローンを作成すると(Flow Production Tracking で右クリックして実行)、この設定と自動的に関連付けられるため、実質的に、この設定は作成者にのみ表示されるようになります。Maya で新しいツールを開発し、アーティストにこのツールをテストしてもらう場合は、パイプライン設定の開発サンドボックスにアーティストを追加するだけで、アーティストがサンドボックスから Maya を起動し、拡張ツールで作業にアクセスできるようになります。パイプライン設定をローカライズする既定では、パイプライン設定はそのコードを、インストールした Flow Production Tracking Toolkit Studio から選択します。Toolkit Studio のインストールには、Flow Production Tracking Toolkit が使用しているすべてのアプリとエンジンのコードのキャッシュと、Toolkit Core API インストールが含まれます。各パイプライン設定は、スタジオの場所にある Core API とアプリ キャッシュを共有します。これは、すべてのプロジェクトに Core API を同時に適用することができるため便利です。スタジオの場所を更新するだけで、すべてのプロジェクトに反映されます。ただし、パイプライン設定を中断して独立できるようにする際に役立つ場合があります。次にその例を示します。  もうすぐ完了するプロジェクトがあり、更新を中断して何も変更されないようにする場合。  パイプライン設定があり、そこで新しいバージョンの Toolkit Core API をテストする場合。  自宅で作業する場合に使用する Toolkit 最小バンドルを組み立てる場合。スタジオ インストールから完全に独立したパイプライン設定を作成するこのプロセスは設定のローカライズと呼ばれ、基本的には Core API をパイプライン設定にコピーすることを意味します。それには tank localize コマンドを実行します。設定をローカライズすると、必然的にスタジオの Tank コマンドを実行できなくなります。基本的に、プロジェクトがローカライズされると、そのローカルにある Tank コマンドと Python API を使用する必要があります。クローン作成した環境設定を削除するクローン作成した環境設定または開発領域がこれ以上必要ない場合は、レコードを削除して、ディスクから削除するだけです。更新を確認するアプリやエンジンの更新の確認は簡単です。プロジェクトで tank updates コマンドを実行するだけです。Flow Production Tracking Toolkit により更新がチェックされ、更新するかどうかが確認されます。既定値が設定されていない新しいパラメータがある場合、更新スクリプトが値の入力を求めるプロンプトを表示します。変更内容の詳細を確認する場合のために、各更新にはリリース ノート ページへの URL リンクが表示されます。このプロセスはいつでも終了できます。Toolkit Core API の更新は同じくらい簡単です。tank core コマンドを実行するだけです。ステージング サンドボックスを作成するプライマリ環境設定で tank updates を実行するだけならほとんど問題ありませんが、この環境設定をプロダクション環境に適用する前にテストした方がよい場合があります。この場合、単純にプライマリ パイプライン設定のクローンを作成し、ここで更新コマンドを実行します。Core API をアップグレードする場合、core コマンドを実行する前にサンドボックスをローカライズしているかを確認します(ローカライズの詳細については上記を参照)。更新の動作を確認したら、プライマリ環境設定で更新を再び実行します。この方法の詳細については、「設定を管理する」を参照してください。アプリの起動方法を設定するインストール直後に設定する必要のある Toolkit 設定の一部にアプリの起動設定があります。これはスタジオが既にカスタマイズしてツールを展開していることの多い領域であるため、柔軟にカスタマイズできるようにしました。Flow Production Tracking 内からまたは Tank コマンドを使用してアプリケーション(Maya や Nuke など)を起動する場合は、アプリケーションの起動と Toolkit の初期化を管理するアプリを実行します。このアプリは、tk-multi-launchappと呼ばれます。Toolkit のスターター設定のいずれかを使用して新しいプロジェクトをセットアップする場合は、起動アプリケーションで使用するアプリケーション パスの変更方法に関する手順が表示されます。別のシステムが導入され、同様に機能している場合は、このアプリを使用する必要はありません。通常、ランチャー アプリケーションは次の手順を実行します。      使用するコンテキストを特定します。コンテキストは現在の作業領域を表します。Flow Production Tracking 内のタスク、アセット、またはショットを右クリックすると、クリック対象に基づいてコンテキストが作成されます。Tank コマンドを使用している場合は、コマンド ラインの一部として指定するか、現在のディレクトリから選択します。        次に、アプリケーションの環境設定に基づいてアプリケーションが起動されます。起動アプリケーションは、アプリケーションへのパス、渡すコマンド ライン引数、アプリケーションの起動前に設定する必要があるアプリケーションと環境変数を実行する実際のコードなど、複数の方法で設定できます。        後で Toolkit API が初期化されるように PYTHONPATH が設定されます。        アプリケーションを起動すると、Toolkit API が読み込まれて初期化されます。        最後にエンジンが起動します。  例: Flow Production Tracking Toolkit の起動方法の詳細なサンプルToolkit の通常のブートストラップはいくつかのフェーズで発生します。      メインのホスト アプリケーションが起動します。これには Python インタプリタが含まれます。最も単純なものとして、標準シェルで実行される CPython インタプリタがあります。また、Maya や Nuke または Python インタプリタが組み込まれたアプリもあります。        Toolkit Core API が PYTHONPATH に追加されて読み込まれます(import sgtk)。        ここで、コンテキストを特定する必要があります。これにはディスク上のパスまたは Flow Production Tracking オブジェクトを指定できます。ファクトリ メソッド tk = sgtk.sgtk_from_path(&quot;/mnt/projects/hero/assets/chair01/lighting&quot;) を使用して Toolkit API インスタンスを作成できるようになりました。または、Flow Production Tracking エンティティ tk = sgtk.sgtk_from_entity(&quot;Shot&quot;, 123) を使用できます。エンティティを使用する場合、上記のコードは Flow Production Tracking に接続し、このショットのパイプライン設定を解決して、ディスク上のパイプライン設定を特定し、ファイル システム テンプレートなどの Sgtk の基本設定をロードします。この時点でロードされるアプリまたはエンジンはありません。パスを参照する場合、ファイル システムを使用してパイプライン設定を特定します。        ここで、現在の作業領域を表すコンテキスト オブジェクトを作成します。これにはエンティティ ctx = tk.context_from_entity(&quot;Shot&quot;, 123) またはパス ctx = tk.context_from_path(&quot;/mnt/projects/hero/assets/chair01/lighting&quot;) を使用します。        最後にエンジンを起動します。Maya を起動していると仮定した場合、Maya の Python インタプリタでこのコマンドを実行すると、sgtk.platform.start_engine('tk-maya', tk, ctx) のようになります。これにより、次の操作を実行します。                  コンテキストの選択環境フックを実行します。選択環境フックは使用する環境設定を返します。環境設定には、ロードするすべてのアプリのリストとその設定値が含まれます。                    環境ファイルが決定されると、エンジンがメモリにロードされます。これにより、エンジン ベースのオブジェクトが自動的にロードされ、その初期化メソッドが実行されます。エンジンがロードされると、すべてのアプリが同じ方法でロードされます。通常、この一環として、エンジンはアプリケーション内に「Flow Production Tracking」メニューを登録し、各アプリは一連のコマンドをエンジンに登録します。このコマンドは後で実行する際のエントリ ポイントになります。ユーザが Flow Production Tracking メニューのどれかをクリックすると、アプリの実行がトリガされます。            完全なサンプルでは次のような行が含まれます。# starting up sgtk when your context is based on a pathimport sgtkpath = &quot;/mnt/projects/hero/assets/chair01/lighting&quot;# create a sgtk api handletk = sgtk.sgtk_from_path(path)# create a context objectctx = tk.context_from_path(path)# start the tank enginesgtk.platform.start_engine('tk-maya', tk, ctx)# starting up sgtk when your context is based on a Flow Production Tracking objectimport sgtkentity_type = &quot;Shot&quot;entity_id = 123# create a sgtk api handletk = sgtk.sgtk_from_entity(entity_type, entity_id)# create a context objectctx = tk.context_from_entity(entity_type, entity_id)# start the sgtk enginesgtk.platform.start_engine('tk-maya', tk, ctx)ディスク上にフォルダを作成するToolkit 設定の主な要素の 1 つにファイル システム設定があります。Flow Production Tracking Toolkit は一貫した方法でディスク上にフォルダを作成することができ、作成プロセスは Flow Production Tracking によって決定されます。次に、設定内のコア フォルダの概要を示します。フォルダ設定のセットアップは比較的簡単です。この設定の基本は、フォルダがアセットやショットなどを表すことを示すいくつかの設定ファイルを使用して作成する、テンプレート フォルダ構造です。ファイル システム構造を設定する場合、フォルダ プレビュー機能を使用すると、作成内容のリストを確認できます。このコマンドは Flow Production Tracking と Tank コマンドの両方で使用できます。最初に標準フォルダを使用するスキャフォールディングを定義します。アセット、ショット、またはパイプラインの手順などを表現する動的フォルダがスキャフォールディングにある程度作成されている場合、この時点では無視します。結果に問題がなければ、各動的フォルダに動的機能を段階的に追加します。このためには、各フォルダと同じ名前の yml ファイルを追加します。yml ファイル内で、特殊な構文を使用してフォルダの作成方法を定義します。Flow Production Tracking Toolkit は幅広い動的な動作を数多くサポートしますが、通常の動作は Flow Production Tracking エンティティを表す動的ノードです。この場合、設定ファイルは次のようになります。# the type of dynamic contenttype: &quot;Shotgun_entity&quot;# the Shotgun field to use for the folder namename: &quot;{code}_{sg_prefix}&quot;# the Shotgun entity type to connect toentity_type: &quot;Asset&quot;# Shotgun filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std Shotgun API syntax)# any values starting with $ are resolved into path objectsfilters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }これは、動的フォルダでアセット エンティティの 2 つの Flow Production Tracking フィールドを使用する名前のフォルダを作成する必要があることを示します。標準的な Flow Production Tracking API クエリー構文を使用することで、制限事項の定義も親フォルダに基づいて行われます。考慮する必要があるのは、現在のプロジェクトのアセットとアセット タイプのみです。サポート対象のノード タイプの完全なリファレンスについては、リファレンス ドキュメントを参照してください。ファイル システムの場所Toolkit フォルダ作成システムを使用してディスク上にフォルダを作成した場合、このフォルダは Flow Production Tracking 内で保存およびトラックされます。フォルダは、管理者メニューの下にある、Flow Production Tracking の[ファイルシステムの場所] (Filesystem Location)エンティティとして表示されます。通常このデータは Toolkit によってシーンの背後でトラックされるため、ユーザは何も確認する必要がありません。この[ファイルシステムの場所] (Filesystem Location)エンティティはディスク上のフォルダを同期およびトラックするために Toolkit によって使用され、このエンティティを使用すると、最初にフォルダ作成を実行して作成したときと同じようにディスク上にフォルダ構造を再作成できます。[ファイルシステムの場所] (Filesystem Location)エンティティ データは、ディスク上の特定のパスに関連付けられた Flow Production Tracking エンティティを特定する場合に主に使用されます。パフォーマンス上の理由から、[ファイルシステムの場所] (Filesystem Location)テーブルの内容はユーザのローカル マシン上にキャッシュ化されます。これはフォルダ/エンティティの参照スピードを上げるためです。エキスパート ユーザの場合は、cache_location コア フックを変更してこのキャッシュの場所をカスタマイズできます。キャッシュ化されたローカル フォルダ表現は、ディスク上へのフォルダ作成時とアプリケーションの起動時に同期されます。Toolkit のフォルダの名前を変更するToolkit のフォルダ作成を実行すると、Flow Production Tracking のエンティティとディスク上のフォルダ間の接続が確立されます。Toolkit はそのフォルダ スキーマ設定を使用して、ディスク上に一連のフォルダを生成します。各フォルダは Flow Production Tracking に Filesystem Location エンティティとして登録されます。これは、Flow Production Tracking データ(ショットやアセット名など)と設定がディスクの実際のフォルダおよび Flow Production Tracking に「ベイク処理」されていると考えることができます。フォルダが作成されると、Flow Production Tracking のエンティティの名前を自由に変更できなくなります。エンティティの名前を変更しようと Toolkit を起動すると、エラー メッセージが表示されます。これは、特定のエンティティに関連付けられたフォルダのトラック情報を失わないようにするためです。Toolkit のフォルダの名前を変更するには、次の手順を実行します。  最初に Flow Production Tracking のエンティティ(アセットまたはショット)の名前を変更します。  tank unregister_folders コマンドを実行して登録されているフォルダを登録解除します。これにより、ディスク上のエンティティと場所の関係をトラッキングする Flow Production Tracking の[ファイルシステムの場所] (Filesystem Location)エンティティが削除されます。このコマンドはディスク上のコンテンツには影響せず、ディスク上の場所を示す Flow Production Tracking の Filesystem Location エンティティにだけ影響します。たとえば、Plant という名前の付いたアセットのフォルダを登録解除するには、tank Asset Plant unregister_folders コマンドを実行します。登録解除するフォルダの概要が表示され、この操作を確定するように求められます。  フォルダを登録解除すると、基本的にはアセットを「リセット」したことになります。このアセットとフォルダの関連付けはなくなるため、Flow Production Tracking で新しい名前を指定してフォルダ作成を実行すると、ディスク上に新しいフォルダが作成されます。  最後に、ディスク上の以前の場所から新しい場所にデータを移動します。また、ファイル間のリンクが更新され、新しい場所をポイントすることを確認してください。遅延作成とユーザ サンドボックスToolkit のフォルダ作成をセットアップして、フォルダ作成コマンドを実行したときとアプリケーションを起動する直前という 2 つのフェーズで実行されるようにすることもできます。これは Toolkit アプリケーション ランチャーに組み込まれた動作です(フォルダ作成を実行する標準的な API メソッドを呼び出すだけです)。遅延フォルダ作成を使用すると、次の状況に対応できます。  パイプラインに複数の異なるコンテンツ作成アプリケーションがあるが実際に必要になるまでどのアプリケーションにも完全なフォルダ スキャフォールディングを追加しない場合、各コンテンツ作成アプリケーションで設定内に独自の遅延サブツリーが設定されるようにフォルダ作成をセットアップできます。制作者または管理者がショット用のフォルダを作成する場合、Maya、Nuke、Mari などの作業領域を作成する直前に停止します。その後、アプリケーションを起動すると、このフォルダはアプリケーションの起動直前に作成されます。  ファイル システム内のユーザ ベースのサンドボックスを作成する場合は、作業を開始する直前に作成する必要があります。遅延フォルダ作成を使用すると、このプロセスを簡単にする特別なユーザ ノードを追加できます。テンプレート設定でユーザ ノードを参照する場合は、Flow Production Tracking API での表記方法である HumanUser を使用します。遅延作成の詳細については、リファレンス ドキュメントを参照してください。テンプレートを設定するファイル システム構造を作成したら、上記のフォルダ構造に基づいて一連のファイル システムの場所を設定することをお勧めします。この場所は「テンプレート」と呼ばれ、Flow Production Tracking Toolkit に不可欠なものです。テンプレート ファイルには 3 つのセクションがあります。各フィールドの意味を定義できるキー セクション、テンプレート パスを定義できるパス セクション、文字列式を定義できる文字列セクションです。 ファイルでは 2 つの構文を使用できます。1 つのストレージ ルートを持つ設定に使用できるシンプルな形式の構文と、マルチルート設定に使用できる高度な構文です。例: 単一のルート テンプレート形式# The keys section contains the definitions for all the different keys that are being# used in the Toolkit. A key is a magic token that is replaced by a value at runtime, for example# {Shot}. The section below tells the Toolkit which data types and formats to expect for each key.keys:    Sequence:        type: str    Shot:        type: str    Step:        type: str    sg_asset_type:        type: str    Asset:        type: str    name:        type: str        filter_by: alphanumeric    iteration:        type: int    version:        type: int        format_spec: '03'    version_four:       type: int       format_spec: '04'       alias: version    timestamp:        type: str    width:        type: int    height:        type: int    channel:        type: str        filter_by: alphanumeric    SEQ:        type: sequence        format_spec: '04'    eye:        type: str# The paths section contains all the the key locations where files are to be stored# by the Toolkit Apps. Each path is made up of several keys (like {version} or {shot}) and# these are defined in the keys section above.## Toolkit apps use these paths as part of their configuration to define where on disk# different files should go.paths:    ##########################################################################################    # Shot pipeline / maya    shot_root: 'sequences/{Sequence}/{Shot}/{Step}'    # define the location of a work area    shot_work_area_maya: '@shot_root/work/maya'    # define the location of a publish area    shot_publish_area_maya: '@shot_root/publish/maya'    # The location of WIP files    maya_shot_work: '@shot_root/work/maya/{name}.v{version}.ma'    # The location of backups of WIP files    maya_shot_snapshot: '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'    # The location of published maya files    maya_shot_publish: '@shot_root/publish/maya/{name}.v{version}.ma'    ##########################################################################################    # Asset pipeline / maya    asset_root: 'assets/{sg_asset_type}/{Asset}/{Step}'    # define the location of a work area    asset_work_area_maya: '@asset_root/work/maya'    # define the location of a publish area    asset_publish_area_maya: '@asset_root/publish/maya'    # The location of WIP files    maya_asset_work: '@asset_root/work/maya/{name}.v{version}.ma'    # The location of backups of WIP files    maya_asset_snapshot: '@asset_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'    # The location of published maya files    maya_asset_publish: '@asset_root/publish/maya/{name}.v{version}.ma'# The strings section is similar to the paths section - but rather than defining paths# on disk, it contains a list of strings. Strings are typically used when you want to be# able to configure the way data is written to Flow Production Tracking - it may be the name field for a# review version or the formatting of a publish.strings:    nuke_shot_version_name: '{Shot}_{name}_{channel}_v{version}.{iteration}'    nuke_asset_version_name: '{Asset}_{name}_{channel}_v{version}.{iteration}'例: マルチ ルート テンプレート形式## The keys section contains the definitions for all the different keys that are being# used in the Toolkit. A key is a magic token that is replaced by a value at runtime, for example# {Shot}. The section below tells the Toolkit which data types and formats to expect for each key.#keys:    Sequence:        type: str    Shot:        type: str    Step:        type: str    sg_asset_type:        type: str    Asset:        type: str    name:        type: str        filter_by: alphanumeric    iteration:        type: int    version:        type: int        format_spec: '03'    version_four:       type: int       format_spec: '04'       alias: version    timestamp:        type: str    width:        type: int    height:        type: int    channel:        type: str        filter_by: alphanumeric    SEQ:        type: sequence        format_spec: '04'    eye:        type: str# The paths section contains all the the key locations where files are to be stored# by the Toolkit Apps. Each path is made up of several keys (like {version} or {shot}) and# these are defined in the keys section above.# Toolkit apps use these paths as part of their configuration to define where on disk# different files should go.paths:    ##########################################################################################    # Shot pipeline / Maya    shot_root: 'sequences/{Sequence}/{Shot}/{Step}'    # define the location of a work area    shot_work_area_maya:      definition: '@shot_root/work/maya'      root_name: primary    # define the location of a publish area    shot_publish_area_maya:      definition: '@shot_root/publish/maya'      root_name: primary    # The location of WIP files    maya_shot_work:      definition: '@shot_root/work/maya/{name}.v{version}.ma'      root_name: primary    # The location of backups of WIP files    maya_shot_snapshot:      definition: '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'      root_name: primary    # The location of published maya files    maya_shot_publish:      definition: '@shot_root/publish/maya/{name}.v{version}.ma'      root_name: primary    ##########################################################################################    # Asset pipeline / Maya    asset_root: 'assets/{sg_asset_type}/{Asset}/{Step}'    # define the location of a work area    asset_work_area_maya:      definition: '@asset_root/work/maya'      root_name: secondary    # define the location of a publish area    asset_publish_area_maya:      definition: '@asset_root/publish/maya'      root_name: secondary    # The location of WIP files    maya_asset_work:      definition: '@asset_root/work/maya/{name}.v{version}.ma'      root_name: secondary    # The location of backups of WIP files    maya_asset_snapshot:      definition: '@asset_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'      root_name: secondary    # The location of published maya files    maya_asset_publish:      definition: '@asset_root/publish/maya/{name}.v{version}.ma'      root_name: secondary# The strings section is similar to the paths section - but rather than defining paths# on disk, it contains a list of strings. Strings are typically used when you want to be# able to configure the way data is written to Flow Production Tracking - it may be the name field for a# review version or the formatting of a publish.strings:    # when a review version in Flow Production Tracking is created inside of nuke, this is the    # name that is being given to it (the code field)    nuke_shot_version_name: '{Shot}_{name}_{channel}_v{version}.{iteration}'    nuke_asset_version_name: '{Asset}_{name}_{channel}_v{version}.{iteration}'テンプレート ファイルに使用可能な設定オプションが数多くあります。完全なリファレンスについては、こちらを参照してください。テンプレート ファイルの @include 構文テンプレート ファイルで繰り返しを減らすために、フィールドを再利用することができます。paths:    asset_root: 'assets/{sg_asset_type}/{Asset}/{Step}'    maya_asset_work: '@asset_root/work/maya/@maya_asset_file'strings:    maya_asset_file: '{name}.v{version}.ma'また、複数のファイル間でテンプレートを分割し、他のファイルにファイルを含めることもできます。詳細については、リファレンス ドキュメントを参照してください。テンプレート ファイルに外部ファイルを含める環境設定を複数のファイルに分割して他のファイルにファイルを含めるのと同じように、テンプレート ファイルをこの方法で管理することができます。これは、複数のプロジェクトで共有されるグローバル環境設定をセットアップする場合などに役立ちます。次のいずれかの include 構文を使用して、templates.yml ファイルに別のファイルを含めます。# single include using a path local to the location of the current fileinclude: './include_file.yml'# multiple incudes, processed in orderincludes: ['./include_file_1.yml', './include_file_2.yml']# you can also use absolute paths when including things:include:# files that are not recognized are skipped, so you can put paths for# windows and linux next to each other for multi platform support:includes: ['/foo/bar/hello.yml', 'z: foo bar hello.yml']# you can use environment variables inside of full paths tooincludes: ['$STUDIO_ROOT/foo/bar/hello.yml', '%STUDIO_ROOT% foo bar hello.yml']含めるファイルにはメインの templates.yml ファイルと同じ構造が必要です。つまり、paths、keys、および strings セクションが含まれている必要があります。Toolkit が複数の include を処理する場合、降順かつ深さ優先で再帰的に読み込みを行い、paths、keys、および paths の 3 つの「バケット」にデータを個別に追加します。この処理中に値がバケット内に既に存在する場合は上書きされます。すべての include が処理されると、環境設定全体が検証されます。次に、簡単な例を示します。これはメインの templates.yml ファイルです。include: ./global_defs.ymlkeys:    name:        type: str        filter_by: alphanumeric    version:        type: int        format_spec: &quot;03&quot;paths:    maya_shot_work: '@shot_root/work/maya/{name}.v{version}.ma'これは追加されたファイル global_defs.yml のコンテンツです。keys:    Sequence:        type: str    Shot:        type: str    Step:        type: strpaths:    shot_root: sequences/{Sequence}/{Shot}/{Step}各ファイルに必要なすべての情報が含まれるように、キーとパスを一緒に保管することをお勧めします(ただし、常に適切だとは限りません)。通常は、これで維持が簡単になります。フォルダ作成とテンプレートフォルダ作成システムで作成されたフォルダを参照するテンプレートを作成する場合、「Flow Production Tracking API」スタイルの表記を使用してフィールドを指定する必要があります。これは見逃してしまいがちな細かい設定です。上記の例はそのことを適切に示しています。フォルダ作成では、最初にアセット タイプとアセット名ごとに項目をグループ化する環境設定をセットアップします。以下に例を示します。/mnt/projects/my_project/assets/character/Heroその後、このパスに一致するテンプレートを Toolkit で作成します。パスとコンテキストが設定されたテンプレートと Flow Production Tracking Toolkit を一致させるには、Flow Production Tracking API を使用して名前を付けた場合と同じようにフィールドに名前を付けます。アセット タイプ フォルダ レベルは Flow Production Tracking のこのフィールドのフィールド名であるため、sg_asset_type と名前を付ける必要があります。アセット レベル フォルダには Asset (大文字 A)と名前を付ける必要があります。これは Flow Production Tracking API を使用する場合にアセット エンティティ タイプをこのように参照するからです。フックフックは Toolkit 設定の中で柔軟性に優れた部分です。通常、アプリ、エンジン、または Core API を設定する場合は、何らかの動作を定義するパラメータのコレクションを指定します。しかし、これでは十分な強力さが得られない場合があります。そのときはフックを使用します。 フックは Python コードの小さなかたまりで、アプリ、エンジン、または実際の Core の特性をカスタマイズするために使用できます。フックは軽量でアトミックになるように設計されています。フックは Toolkit に 3 つの異なるレベルで表示されます。各レベルの詳細については、以下のセクションを参照してください。アプリ レベル フック各 Toolkit アプリ(これに該当するエンジン)には一連の設定が含まれ、その一部はフックです。各アプリには既定のフック コレクションが設定されており、特別にオーバーライドしない限り自動的に使用されます。通常、フックはアプリケーション固有の動作をカスタマイズするために使用します。たとえば、Maya にイメージをロードする Toolkit の場合、UI コードとすべての相互作用ロジックはアプリ内に格納されていますが、実際にイメージを Maya にロードするビジネス ロジックの一部はフック内に格納されています。このため、スタジオで動作をカスタマイズすることができます。既定のフックは Maya で標準的なテクスチャ ノードを作成するだけですが、異なるノード タイプの使用を望むスタジオはこのフックをオーバーライドして、コードを再作成せずにアプリ全体の動作を簡単に変更できます。アプリのフックをカスタマイズする場合は、通常、アプリのフック フォルダ内の既定のフックをプロジェクトのフック フォルダにコピーします。次に、既定のフックではなく、新しいフックが読み込まれるように、環境ファイル内のアプリ設定を更新する必要があります。カスタム フックはアプリに含まれる既定のフックから自動的に継承されるため、既定のフックのビジネス ロジックの大部分を維持したまま簡単に微調整することができます。フックの継承の詳細については、「環境設定リファレンス」を参照してください。コア レベル フックコア フックを使用すると、Toolkit でシステム全体の動作をオーバーライドできます。コア レベル フックはプロジェクトごとにすべてオーバーライドされるため、各プロジェクトはオーバーライド値で個別にセットアップする必要があります (新しいプロジェクトのセットアップ時と同じ環境設定を再利用する場合は、通常はこの方法が簡単です)。コア設定領域には特別な hooks フォルダがあります。このフォルダには特定のコア フックの独自の実装を格納できます。コア フックはアプリ内のフックと似ており、Toolkit からコード スニペットを抽出してカスタマイズすることができます。Core API を使用すると、ファイル システム I/O、フォルダ作成、ファイル システム構造の検証など、数多くのさまざまなコアの動作をオーバーライドできます。既定では、Toolkit は API フォルダ自身から必要なコア フックを選択します。動作をカスタマイズする場合は、自分の環境設定の config/core/hooks 領域にフック ファイルをコピーします。次にコードを修正します。利用可能なコア フックのリストについては、Core API 内のフックのフォルダを確認してください。各フックには、その機能と修正方法に関する広範なドキュメントが含まれます。スタジオ レベル フック「スタジオ レベル フック」と呼ばれるいくつかの非常に特殊なフックもあります。 このフックはグローバルであり、すべてに影響します。特定のプロジェクトには含まれない Toolkit の特性を制御します。プロジェクト名フックプロジェクト セットアップ プロセスによりプロジェクトの「ディスク名」の入力を求めるプロンプトが表示され、Flow Production Tracking でのプロジェクト名に基づいた名前が提示されます。スペースやファイル システム以外に対応した他の文字はアンダースコアに置き換えられます。ディスク名は、プロジェクト データと環境設定が格納されるフォルダの名前になります。ディスク名の指定にはスラッシュを使用できます。これにより、複数のフォルダ階層に渡るプロジェクト ルート ポイントが生成されます。スタジオで分野(コマーシャルや vfx など)に基づいてプロジェクトを整理する場合や、ファイル システムの 1 つのレベルで概要を表示できないほどスタジオのプロジェクト量が膨大になった場合に役立つことがあります。常にスラッシュ(「/」)を使用する必要があります。Windows では、Toolkit が必要な調整を行います。上記のマルチ レベルのフォルダを組み合わせると、Toolkit がセットアップ プロセスの一環として推奨する名前をカスタマイズすることもできます。これには特別なスタジオ レベルのフックを使用します。この動作をカスタマイズする場合は、config/core フォルダ内のスタジオの API の場所に project_name.py という名前のファイルを作成します。このフォルダには、install_location.yml、app_store.yml、shotgun.yml などのファイルが既に含まれています。project_name.py フック ファイルの表示例は次のとおりです。from tank import Hookimport osclass ProjectName(Hook):    def execute(self, sg, project_id, **kwargs):        &quot;&quot;&quot;        Gets executed when the setup_project command needs a disk name preview.        &quot;&quot;&quot;        # example: create a name based on both the sg_type field and the name field        sg_data = sg.find_one(&quot;Project&quot;, [[&quot;id&quot;, &quot;is&quot;, project_id]], [&quot;name&quot;, &quot;sg_type&quot;])        # create a name, for example vfx/project_x or commercials/project_y        name = &quot;%s/%s&quot; % ( sg_data[&quot;sg_type&quot;], sg_data[&quot;name&quot;] )        # perform basic replacements        return name.replace(&quot;_&quot;, &quot;/&quot;).replace(&quot; &quot;, &quot;/&quot;)接続フックToolkit には、関連付けられた Flow Production Tracking インスタンスに接続できるように接続設定が保存されています。動的な方法でこの接続設定を制御すると便利な場合があります。この場合、config/core フォルダ内のスタジオの API の場所に sg_connection.py という名前のファイルを作成します。このフォルダには、install_location.yml、app_store.yml、shotgun.yml などのファイルが既に含まれています。Flow Production Tracking 接続後に呼び出されるこのフックは設定ファイル shotgun.yml と app_store.yml から読み込まれます。一部の外部環境変数に依存するプロキシ サーバのセットアップなど、接続設定を段階的かつ簡単に修正できます。フックには次の 3 つのパラメータが渡されます。      config_data は、読み込まれた Flow Production Tracking 設定ファイル内の設定を含むディクショナリです。通常、host、api_script、api_key、および http_proxy の各キーが含まれます。        user は、接続情報が関連付けられたユーザ プロファイルです。これはエキスパート設定で、通常は defualt に設定されています。        cfg_path は、config_data のロード元の設定ファイルのパスです。  フックは、config_data と同じ形式のディクショナリを返す必要があります。プロキシ設定をカスタマイズする場合、プロキシ文字列は、123.123.123.123, 123.123.123.123:8888 や username:pass@123.123.123.123:8888 など、Flow Production Tracking API の作成者が予期する形式と同じものを返す必要があります。次に、初めての使用に最適な実装例を示します。from tank import Hookimport osclass CustomShotunConnection(Hook):    &quot;&quot;&quot;    Allows for post processing of Flow Production Tracking connection data prior to connection    &quot;&quot;&quot;    def execute(self, config_data, user, cfg_path, **kwargs):        # explicitly set the proxy server setting        config_data[&quot;http_proxy&quot;] = &quot;123.123.123.123&quot;        return config_dataアプリとエンジンを設定するここでは、ディスク上のすべてのキーの場所を定義するテンプレート ファイルをセットアップし、環境設定内に含めるアプリとエンジンの特定を開始します。導入用マニュアルの他の部分で説明したように、アプリとエンジンの設定は一連の環境設定に分けられています。環境設定の基本は代替設定です。これは、多くの場合、それぞれのアプリ スイートでショット作業やアセット作業ごとに設定を変える必要があるため便利です。複雑なパイプラインの場合、モデリングでリギングとは異なるセットアップを指定できるように、部門ごとに設定を分けることができます。これはすべて環境設定で処理されます。環境ファイルは数多くの利用可能なエンジンを定義します。実行するアプリケーションに応じて、このセクションのいずれかが使用されます。たとえば、Maya を実行する場合、Toolkit に「tk-maya」エンジンを起動するように指示します。Flow Production Tracking Toolkit は使用する環境を(現在の作業領域に基づいて)最初に特定し、この環境内で tk-maya エンジンを探します。エンジンが見つかった場合は、このセクションで定義したすべてのアプリにロードします。各アプリには指定可能な設定が数多く用意されています。アプリをインストールまたはアップグレードする場合は、Flow Production Tracking Toolkit によって、既定値が指定されていない設定を指定するように指示されます。多くの場合、Toolkit アプリは再利用可能であるため、セットアップ方法に応じて、さまざまな方法とワークフローで使用することができます。同じ環境で同じアプリを何回か定義することもできます。たとえば、Maya メニューに 2 つのパブリッシャを表示するとします。1 つがリグ パブリッシュ用、もう 1 つがモデル パブリッシュ用の場合、両方とも同じパブリッシュ アプリを使用して設定をそれぞれ変えられます。例: 環境ファイルinclude: ./includes/app_launchers.ymlengines:  # 3dsmax engine  tk-3dsmax:    debug_logging: false    location: {name: tk-3dsmax, type: app_store, version: v0.2.6}    # all the registered apps for this engine    apps:      tk-multi-about:        location: {name: tk-multi-about, type: app_store, version: v0.1.8}      tk-multi-loader-texture:        dependency_mode: false        hook_add_file_to_scene: default        location: {name: tk-multi-loader, type: app_store, version: v0.2.6}        menu_name: Load Texture...        publish_filters: []        sg_entity_types:          Asset: []        single_select: true        tank_types: [Diffuse Texture, Specular Texture]      tk-multi-publish:        display_name: Publish        hook_copy_file: default        hook_post_publish: default        hook_primary_pre_publish: default        hook_primary_publish: default        hook_scan_scene: default        hook_secondary_pre_publish: default        hook_secondary_publish: default        hook_thumbnail: default        location: {name: tk-multi-publish, type: app_store, version: v0.2.5}        primary_description: Publish and version up the current 3ds Max scene        primary_display_name: 3ds Max Publish        primary_icon: icons/publish_3dsmax_main.png        primary_publish_template: max_shot_publish        primary_scene_item_type: work_file        primary_tank_type: 3dsmax Scene        secondary_outputs: []        template_work: max_shot_work      tk-multi-screeningroom: '@launch_screeningroom'      tk-multi-snapshot:        hook_copy_file: default        hook_scene_operation: default        hook_thumbnail: default        location: {name: tk-multi-snapshot, type: app_store, version: v0.1.15}        template_snapshot: max_shot_snapshot        template_work: max_shot_work      tk-multi-workfiles:        hook_copy_file: default        hook_scene_operation: default        location: {name: tk-multi-workfiles, type: app_store, version: v0.2.5}        sg_entity_types: [Shot, Asset]        template_publish: max_shot_publish        template_publish_area: shot_publish_area_max        template_work: max_shot_work        template_work_area: shot_work_area_max  # the maya engine  tk-maya:    debug_logging: false    location: {name: tk-maya, type: app_store, version: v0.2.7}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: File Manager...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}    - {app_instance: tk-multi-workfiles, name: Save As...}    - {app_instance: tk-multi-publish, name: Publish...}    template_project: shot_work_area_maya    # all the registered apps for this engine    apps:      tk-maya-breakdown:        hook_multi_update: default        hook_scan_scene: default        location: {name: tk-maya-breakdown, type: app_store, version: v0.2.7}      tk-multi-about:        location: {name: tk-multi-about, type: app_store, version: v0.1.8}      tk-multi-loader-1:        dependency_mode: false        hook_add_file_to_scene: default        location: {name: tk-multi-loader, type: app_store, version: v0.2.6}        menu_name: Load Assets...        publish_filters: []        sg_entity_types:          Asset: []        single_select: true        tank_types: [Maya Model, Maya Rig]      tk-multi-loader-2:        dependency_mode: false        hook_add_file_to_scene: default        location: {name: tk-multi-loader, type: app_store, version: v0.2.6}        menu_name: Load Shots...        publish_filters: []        sg_entity_types:          Shot: []        single_select: true        tank_types: [Maya Anim, Maya Lighting, Maya Scene]      tk-multi-publish:        display_name: Publish        hook_copy_file: default        hook_post_publish: default        hook_primary_pre_publish: default        hook_primary_publish: default        hook_scan_scene: default        hook_secondary_pre_publish: default        hook_secondary_publish: default        hook_thumbnail: default        location: {name: tk-multi-publish, type: app_store, version: v0.2.5}        primary_description: Publish and version up the current Maya scene        primary_display_name: Maya Publish        primary_icon: icons/publish_maya_main.png        primary_publish_template: maya_shot_publish        primary_scene_item_type: work_file        primary_tank_type: Maya Scene        secondary_outputs: []        template_work: maya_shot_work      tk-multi-screeningroom: '@launch_screeningroom'      tk-multi-setframerange:        location: {name: tk-multi-setframerange, type: app_store, version: v0.1.2}        sg_in_frame_field: sg_cut_in        sg_out_frame_field: sg_cut_out      tk-multi-snapshot:        hook_copy_file: default        hook_scene_operation: default        hook_thumbnail: default        location: {name: tk-multi-snapshot, type: app_store, version: v0.1.15}        template_snapshot: maya_shot_snapshot        template_work: maya_shot_work      tk-multi-workfiles:        hook_copy_file: default        hook_scene_operation: default        location: {name: tk-multi-workfiles, type: app_store, version: v0.2.5}        sg_entity_types: [Shot, Asset]        template_publish: maya_shot_publish        template_publish_area: shot_publish_area_maya        template_work: maya_shot_work        template_work_area: shot_work_area_mayaアプリごとの場所の設定環境ファイルの各項目には特別な location トークンがあります。このトークンは、Toolkit がアプリ コードを選択する場所と新しいバージョンのアプリを確認する方法を定義します。たとえば、場所のトークンは次のように定義できます。location: {name: tk-multi-setframerange, type: app_store, version: v0.1.2}タイプは、このアプリがアプリ ストアから取得されたものであり、特定のバージョンが使用されていることを示しています。更新チェックを実行すると、Flow Production Tracking Toolkit はアプリ ストアに接続して、v0.1.2 よりも新しいバージョンがあるかどうか、その場合にアップグレードするかどうかを確認します。Toolkit は、git や github など、異なるいくつかの場所タイプをサポートしているため、独自のアプリを作成し、git を使用してこのアプリをトラックできます。git で新しいタグを作成する場合、この更新はアップグレード チェックで正しく処理されるかを検出します。詳細については、リファレンス ドキュメントを参照してください。ファイルをインクルードする環境ファイルに外部ファイルをインクルードすることができます。これは、設定を集中管理したり、オーバーライドを管理したりする場合に便利です。      複数の環境で Maya を起動しても、アプリケーション(Maya、Nuke)のすべてのファイル パスを 1 つの場所で管理できるように環境設定を整理することができます。        複数の環境で同じ設定を使用するアプリを 1 つの場所で定義できます。        複数のプロジェクトで共有される「一括」パイプライン設定を管理でき、それを更新することですべてのプロジェクトが更新のメリットを受けられます。各プロジェクトでは、特定の動作を設定する必要がある場合、含まれる一括設定をオーバーライドまたは拡張できます。        コンテキストのファイルをオーバーライドとしてインクルードできます。つまり、ショットまたはアセットごとに設定パラメータを再設定することができます。これは、ショットまたはアセットごとに Maya や Nuke などのパスをオーバーライドできる既定の設定に示されています 。        フル パスで環境変数を使用する場合は自動的に展開されます。Linux の場合、インクルード パーサが混乱するため、環境変数は、${ENV_VAR} 形式ではなく $ENV_VAR 形式で指定する必要があります。例: ['$STUDIO_ROOT/foo/bar/hello.yml'、'%STUDIO_ROOT% foo bar hello.yml'] をインクルードします。  例: アプリの起動に関するショット固有のオーバーライドシェル エンジンで次の環境ファイルを指定するとします。include: ./includes/app_launchers.ymlengines:  tk-shell:    debug_logging: false    location: {name: tk-shell, type: app_store, version: v0.3.0}    apps:        tk-multi-launch3dsmax: '@launch_3dsmax'        tk-multi-launchmaya: '@launch_maya'        tk-multi-launchmotionbuilder: '@launch_motionbuilder'        tk-multi-launchnuke: '@launch_nuke'        tk-multi-launchphotoshop: '@launch_photoshop'各アプリは、app_launchers インクルード ファイルで定義されたリファレンスです。このファイルには各アプリの実際のアプリ設定が含まれ、次のようになります。includes:    # first include the configuration's global settings for application paths    - ./paths.yml    # now include overrides - these will be loaded if they are found    - sequences/{Sequence}/{Shot}/sgtk_overrides.yml    - assets/{sg_asset_type}/{Asset}/sgtk_overrides.ymllaunch_3dsmax:  engine: tk-3dsmax  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: ''  linux_path: ''  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.4}  mac_args: ''  mac_path: ''  menu_name: Launch 3DSMax  windows_args: ''  windows_path: '@3dsmax_windows'launch_maya:  engine: tk-maya  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: ''  linux_path: '@maya_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.4}  mac_args: ''  mac_path: '@maya_mac'  menu_name: Launch Maya  windows_args: ''  windows_path: '@maya_windows'上記のファイルには、Maya や Nuke などの実際のパスは含まれません。その代わりに、別のファイル paths.yml で定義されます。# mayamaya_windows: 'C: Program Files Autodesk Maya2012 bin maya.exe'maya_mac: /Applications/Autodesk/maya2012/Maya.appmaya_linux: maya# nukenuke_mac: /Applications/Nuke6.3v8/Nuke6.3v8.appnuke_windows: 'C: Program Files Nuke6.3v8 Nuke6.3.exe'nuke_linux: Nuke6.3最初、app_launchers ファイルには上記のファイルがインクルードされますが、後で sequences/{Sequence}/{Shot}/sgtk_overrides.yml もインクルードされます。これはテンプレートのようなコンテキスト固有のファイル パスなので、現在のコンテキストと比較してパスが解決されます。解決する場合は、パスを検出してロードします。つまり、ショットの場所に sgtk_overrides.yml を作成し、固有のショットに対してのみアプリケーション パスをオーバーライドします。# mayamaya_windows: 'C: Program Files Autodesk Maya2012 bin special_maya.exe'ここでは、Maya for Windows の特別バージョンを使用しています。残りのパスは paths.yml ファイルで定義された元のパスになります。インクルードの動作の詳細については、リファレンス ドキュメントを参照してください。テンプレート設定(ファイル パス)を設定する多くのアプリで使用される重要な設定タイプは template です。ファイル システムの場所を指定する必要のあるアプリはこの設定を使用します。アプリは、任意のファイル システム構造または命名規則に対応して汎用性と柔軟性に優れた設計となるように開発されています。テンプレートは、アプリが基本のファイル システムから独立するために重要な部分です。詳細については、コンセプトの概要を参照してください。テンプレート設定を伴うアプリを設定する場合、適切なフィールド セットを含むテンプレートを指定する必要があります。フィールドには必須とオプションがあります。必須フィールドはテンプレートに含める必要があり、オプション フィールドはテンプレートに含めることはできますが、このフィールドをテンプレートで定義していなくてもアプリは動作します。アプリを実行すると、環境設定で指定したテンプレートのパスが作成されます。このパスは、現在のコンテキストに加えて、アプリ ロジックによって指定された一連のフィールドに基づいて作成されます。つまり、コンテキストに含まれないフィールドまたはアプリのオプション フィールドや必須フィールドに含まれないフィールドがテンプレートに含まれる場合、アプリはそのフィールドの値の設定方法が分からないため、動作しません。この状況は、起動時に環境設定を検証する Toolkit によって回避されます。テンプレート設定の検証時、Toolkit は最初にコンテキストをチェックし、コンテキストによって指定されたフィールドとテンプレート内のフィールドを比較します。コンテキストと比較されたフィールドのリストがアプリの必須とオプションのパラメータ定義と一致しない場合、検証エラーが発生します。実例: スナップショット アプリ次に、この機能についての実例を示します。Toolkit アプリの 1 つであるスナップショット アプリを見てみましょう。このアプリでは、多くのテンプレート設定を使用します。次に、アプリ設定ブレイクダウンで定義されている設定の 1 つを示します。  設定名: template_snapshot  タイプ: template  必要なテンプレート キー: version  オプション テンプレート キー: name、timestamp、increment  説明: スナップショットのバックアップが保存されるディスク上の場所を定義するテンプレートのリファレンスです。実行時にコンテキストによって指定されるフィールドに加えて、このテンプレート設定には version フィールドを含むテンプレートが必要です。また、name、timestamp、または increment のオプション フィールドも含まれますが、他のフィールドは含まれません。以下に例を示します。ショットのタスクで Maya を起動するとします。コンテキストには次のフィールドが含まれます。  現在のプロジェクトが設定されます。  現在のエンティティ(ショットなど)が設定されます。  現在のステップが設定されます。  現在のタスクが設定されます。エンジンが起動すると、この設定が確認されます。次に、上記の template_snapshot フィールドに異なる設定を指定した場合の例を示します。      テンプレート sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{version}.ma は、スナップショット template_snapshot 設定を使用すると有効になります。          Sequence、Shot、および Step がコンテキストで統合されます。コンテキストは現在のショットを把握しているため、自動的に現在のシーケンスが特定されます(ファイル システムの親フォルダであるため)。      アプリ設定で必要なテンプレートには version フィールドがあります。      name フィールドはオプションです。      他のフィールドはありません。            (ショット)コンテキストは Asset フィールドの解決方法を把握していないため、テンプレート assets/{Asset}/work/maya/{name}.v{version}.ma は無効になります。        version 必須フィールドが見つからないため、テンプレート sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.ma は無効になります。        フィールド extension は不明で、アプリが統合方法を把握していないため、テンプレート sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{version}.{extension} は無効になります。  フックを使用してアプリの動作をカスタマイズするアプリで頻繁に使用される設定のタイプに hook 設定タイプもあります。フックは、アプリが通常の実行の一部として実行するコードの一部です。フックを使用すると、アプリを非常に柔軟にカスタマイズできます。つまり、アプリのビジネス ロジックの一部を実際のアプリ コードから分離できるということです。たとえば、シーンのさまざまなリファレンスとファイル入力値をスキャンする必要のあるブレイクダウン アプリがあるとします。Maya の場合、Maya が提供する標準的なリファレンス ノードを処理する既定の動作を指定できますが、スタジオでリファレンス ノードのカスタム タイプを使用する場合はどうすればよいでしょうか。通常、スタジオはアプリを選択して github に取り込みますが、シーンのリファレンス ノードをスキャンするコードにカスタム ノード タイプを追加するだけの場合、これは非常に極端な操作です。その代わりに、ブレイクダウン アプリはシーン スキャン コードのスニペットをフックとして実装できます。つまり、アプリ設定の一部として効果的に設定できるということです。これには、シンプルな Maya の動作を処理する既定値が設定されているため、すぐに利用できますが、必要に応じてこの動作を完全に変更するように Flow Production Tracking Toolkit を設定することも簡単に行えます。アプリをインストールすると、すべてのフック設定が既定値として環境設定に表示されます。 つまり、アプリは、このアプリに付属する組み込みのフック実装を使用します。たとえば、次に、ランチャー アプリの設定例を示します。launch_maya:  engine: tk-maya  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: ''  linux_path: '@maya_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.4}  mac_args: ''  mac_path: '@maya_mac'  menu_name: Launch Maya  windows_args: ''  windows_path: '@maya_windows'ここでは hook_app_launch と hook_before_app_launch の 2 つのフックがあり、両方とも既定のアプリ実装を使用しています。これらのフックは、スタジオで起動プロセスをカスタマイズしたり、環境変数を設定したりできるように作成されています。これらのフックをカスタマイズするには、最初に元の実装を探す必要があります。各アプリには、フックが登録されるフック フォルダがあります。ここでカスタマイズするフックを選択し、このフックを環境設定内のフック フォルダにコピーします。必要に応じてコードを変更します。環境設定のフックは、変更しない限りまだ default に設定されています。アプリに付属する既定のフックのみが選択されます。新しい設定を選択するには、既定値を環境設定のフック フォルダ内にある Python フック ファイルの名前に変更します。例: フックをカスタマイズする方法次に、アプリ ランチャーの hook_before_app_launch フックのカスタマイズ方法に関する概要を示します。      既定のフック実装をコピーします。アプリに付属する既定のフックの場所については、上図を参照してください。ここでこのファイルをフック フォルダの設定領域にコピーします。たとえば、パイプライン設定が /mnt/software/sgtk/big_buck_bunny 内に格納されている場合は、ファイルを /mnt/software/sgtk/big_buck_bunny/config/hooks/before_app_launch.py にコピーします。        必要に応じて Python コードを変更します。        最後に、新しいコードを使用するように環境設定を更新します。  yaml launch_maya: engine: tk-maya extra: {} hook_app_launch: default hook_before_app_launch: before_app_launch # &amp;lt;-- uses custom hook! linux_args: '' linux_path: '@maya_linux' location: {name: tk-multi-launchapp, type: app_store, version: v0.2.4} mac_args: '' mac_path: '@maya_mac' menu_name: Launch Maya windows_args: '' windows_path: '@maya_windows'次に起動アプリを実行すると、既定のフック コードの代わりにこのコードが実行されます。",
    "url": "/425b1da4/",
    "relUrl": "/425b1da4/"
  },
  "8": {
    "id": "8",
    "title": "設定のセットアップ",
    "content": "設定の基本操作このガイドを読み終えると、プロジェクト情報を設定に追加するための基本的な知識を習得し、その設定をプロジェクトに関連付けて、パイプライン設定をカスタマイズするための準備を行えるようになります。このガイドについてこのガイドでは、Flow Production Tracking Toolkit の[Advanced Project Setup]ウィザードを使用して、デジタル コンテンツ作成パイプラインの設定を作成する方法について説明します。短時間で設定ツールを習得し、ウィザードの使用方法を学習して、さらに知識を広げることできます。ウィザードを使用することにより、プロジェクトのパイプライン設定を作成でき、パイプラインの各ステップに対応するように編集、拡張する準備が整います。設定により、プロダクション パイプラインをサポートするために必要なユーザ インタフェース、Flow Production Tracking アプリ、およびさまざまなツールの特性がコントロールされます。ウィザードを使用することは、設定を拡張するための 1 つの方法にすぎません。ウィザードによってパイプラインの各ステップに具体的な設定が追加されるだけでなく、ソフトウェア アプリケーションとの統合も追加されます。このガイドでは、プロジェクトの設定のベースとして Toolkit の既定の設定を使用します。このガイドでは、次のユーザを対象としています。  [Advanced Project Setup]ウィザードを使用したことがないユーザ  Flow Production Tracking の使用方法に関する基本知識を持っているユーザ  Flow Production Tracking Toolkit を新たに使用するユーザこのドキュメントの使い方このガイドを使用してカスタマイズ可能なプロジェクトの設定を作成するには、以下が必要になります。  アクティブな Flow Production Tracking サイト。こちらから Flow Production Tracking に登録し、30 日間の無償体験版を取得して試してみることができます。  Flow Production Tracking Toolkit。Desktop がインストールされていない場合は、こちらのリンクの手順で開始してください。  プロジェクト ファイルおよびパイプライン設定を保存できるファイルシステムへのアクセス権。ファイルシステム上に Shotgun というフォルダを作成し、その中に projects と configs という 2 つのフォルダを作成します。[Advanced Project Setup]ウィザードについてFlow Production Tracking Toolkit の[Advanced Project Setup]ウィザードは、既定の設定に基づいてパイプライン設定を生成します。既定の設定により、パイプライン プロセスをサポートするカスタマイズ可能な設定、アプリ、UI 要素を備えた、構築のための強固な基盤が提供されます。ユーザはプロジェクトのパイプラインに関するニーズに合わせて、このウィザードで作成される設定を編集したり、拡張したりできます。既定の設定は、次のとおりです。  ディスク上のファイルの配置場所を決定する、ファイルシステムの基本的なスキーマおよびテンプレート  ユーザのソフトウェア アプリケーション内から Flow Production Tracking およびパイプラインの機能を直接操作できる、サポート対象のすべてのソフトウェア統合。カスタマイズするには、想像力、賢さ、プログラミング上の知識の他に、Flow Production Tracking コミュニティ内の他のユーザが作成した作品から借用する能力が必要です。設定を作成する設定はプロジェクトごとに必要です。Flow Production Tracking Toolkit を介してプロジェクトに初めてアクセスするときに、基本設定がダウンロードされて、設定されます。この基本設定により、ユーザがシステムにインストールしているサポート対象のコンテンツ作成ソフトウェアが自動的に検出され、その設定がプロジェクトに関連付けられます。サポート対象ソフトウェア アプリケーション内の統合は、パイプライン設定内の設定値によって管理されます。Panel アプリには Flow Production Tracking のプロジェクト情報が表示されるため、アーティストは作業セッションから移動しなくてもノートに返信し、バージョンを確認することができます。Publisher アプリを使用すると、アーティストはチーム内の他のメンバーに自分の作品を公開することができます。また、Loader アプリを使用すると、アーティストはチームメイトがパブリッシュしたファイルをロードすることができます。基本設定には、ファイルシステムの管理に関する設定や、ディスク上のファイルおよびフォルダの命名方法を指定するためのテンプレートの開発は含まれていません。また、既定の設定を行ったときに追加された多数のアプリも含まれていません。基本設定は、設定ファイルを手動で編集しなくても Toolkit で実行できるシンプルな設定です。ウィザードを使用すると、基本設定が既定の設定に置き換わります。また、作業中のユーザをサポートするアプリおよびソフトウェアが幅広く統合されます。基本設定を編集することもできますが、プロジェクトを設定してカスタマイズするには、高度な設定を行うことが必要になります。基本設定と既定の設定の違い            機能      基本設定      既定の設定                  ダウンロード      プロジェクトにアクセスしたときに自動的にダウンロードされる      [Advanced Project Setup]ウィザードで作成される              アクセシビリティ      システムの場所に格納される      手動で編集可能なファイル形式              更新      自動的に更新      手動で更新              ファイルシステムのサポート      ファイルシステム スキーマはサポートされない      フォルダ構造とファイルの命名基準をサポートするためのツールが付属              ソフトウェア統合      3ds Max、Houdini、Maya、Nuke、Photoshop、Flame      基本設定に加えて、Hiero、Motionbulder、Mari              Toolkit アプリ      Flow Production Tracking Panel、Publisher、Loader      基本設定に加えて、Workfiles、Snapshot、Scene Breakdown、Nuke 書き込みノード、Houdini Mantra ノードなど      このガイドでは、Flow Production Tracking Toolkit のウィザードを使用し、既定の設定に基づいてプロジェクトのパイプライン設定を生成します。この設定を生成すると、独自のプロダクション パイプラインをサポートするために必要なカスタマイズを実行できるようになります。実習を開始既定の設定の作成準備を行う手順 1: Flow Production Tracking で「the_other_side」という新しいプロジェクトを作成します。手順 2: Flow Production Tracking Toolkit アプリを起動し、ユーザ名およびパスワードを使用して Flow Production Tracking サイトからログインします。手順 3: サムネイル イメージを選択して、ウィザードを実行するプロジェクトにナビゲートします。                    ヒント: Desktop を開いているときに新しいプロジェクトを作成した場合、新しいプロジェクトを表示するには、プロジェクト ウィンドウを更新しなければならないことがあります。デスクトップの右下にあるプロファイルのアバターを選択して、[Refresh Projects]を選択します。    既定の設定にアクセスするプロジェクトにアクセスし、基本設定をダウンロードして設定しました。また、Publish アプリおよびサポート対象のソフトウェア パッケージが検出されて、Flow Production Tracking Toolkit の[Apps]ペインに自動的に追加されました。手順 4: プロジェクトがロードされたら、画面の右下にあるプロファイルのアバターを選択します。ポップアップメニューで、[Advanced project setup…]を選択して、ウィザードを開始します。ダイアログ ボックスが開き、[Flow Production Tracking Default]が選択された状態で 4 つのオプションが表示されます。この時点で、プロジェクトのパイプライン設定のベースを既存のプロジェクトの設定にするのか、GIT リポジトリの設定にするのか、それともディスクのパスにするのかを選択できます。この演習では[Flow Production Tracking Default] を選択します。このオプションを使用すると、Flow Production Tracking の既定の設定に基づいてプロジェクトのパイプライン設定が作成されます。手順 5: [Continue]を選択します。ダイアログ ボックスが開き、[Default]が選択された状態で 2 つのオプションが表示されます。この時点で、[Legacy Default]設定オプションを選択することができます。この設定は、まだ以前のバージョンの Flow Production Tracking を使用しているスタジオのために、以前のバージョンの Shotgun の設定を継承しています。この演習では[Default]を使用します。手順 6: [Continue]を選択します。プロジェクト ファイルの保存場所を定義するダイアログ ボックスが開き、Storage: という単語の横にドロップダウン メニューが表示されます。手順 7: このプロジェクトのプロジェクト データの保存場所を識別します。ダイアログ ボックスの上部にあるドロップダウンで[+ New]を選択し、フィールドに「projects」と入力します。Flow Production Tracking Toolkit では、Linux、Mac、Windows の 3 つのオペレーティング システムをサポートしています。手順 8: プロジェクト データを保存するのに利用するオペレーティング システムの横にあるフィールドを選択します。フォルダ アイコンを選択し、この演習の前にファイルシステム上に作成したプロジェクト フォルダにナビゲートします。この設定の場合、Flow Production Tracking からアクセスできるのは、プロダクション データを保存するために識別されたフォルダに限定されます。この演習の準備中に、Flow Production Tracking のルート ディレクトリ内に projects/ ディレクトリを追加しました。projects/ ディレクトリには、プロジェクトに関連するローカルな情報が格納されます。手順 9: [Save]を選択して、プロジェクト データの保存先としてプロジェクト フォルダを識別します。オペレーティング システムのパスが自動的に更新されて、プロジェクト データの保存場所が識別されます。手順 10: [Continue]を選択します。プロジェクト フォルダに名前を付けるダイアログ ボックスが表示され、プロジェクトの名前がテキスト フィールドに入力されます。この名前はプロジェクトの情報から自動的に入力され、パスは自動的に更新されます。Toolkit は、2 つのいずれかの設定で機能します。パイプライン設定が Flow Production Tracking にアップロードされ、ユーザごとにローカルにキャッシュされる分散設定(Distributed Setup)と、ディスク上の共有場所に保管された単一の設定にユーザがアクセスする中央設定(Centralized Setup)です。この演習では分散設定を使用します。分散設定の詳細については、こちらを参照してください。最後の手順では、該当するフォルダ、ファイル、およびプロジェクトに固有の設定を作成するために必要なデータを生成します。手順 11: 該当するオペレーティング システムの[Browse…]を選択し、この演習の準備中に作成した設定フォルダ configs にナビゲートして、プロジェクト名として「the_other_side」と入力します。プロジェクト設定が保存されるフォルダが作成されます。[Run Setup]を選択して、セットアップが完了するまで待ちます。手順 12: [Done]を選択します。プロジェクト ウィンドウに入力するアイコンが表示されます。ヒント: アプリをメニュー バーに固定すると、Flow Production Tracking Toolkit にすばやくアクセスできるようになります。アバターを選択して、[Pin to Menu]を選択します。これでプロジェクトの設定は完了です。指定した場所にプロジェクトの Toolkit パイプライン設定が保存され、カスタマイズを開始できるようになりました。configs フォルダを調べると、いくつかのフォルダとファイルが配置されています。内容を調べてみましょう。ここからの作業は、設定で実行できるすべての操作について楽しみながら学習することができます。次に、これから調べる高度なトピックをいくつか示します。高度なトピックFlow Production Tracking Toolkit では、さまざまな方法で設定の編集、クローン作成、またはやり直しを行うことができます。既存の設定を拡張することにより、作業時間を短縮し、ネットワーク内の他のユーザが作成したすべての便利なツールにアクセスできます。広大な Flow Production Tracking のコミュニティ を利用して、必要な設定を取得することができます。Flow Production Tracking のコミュニティは共有コミュニティです。そのため、他のユーザに対して親切に対応し、感謝を示し、あなたのジョブに役立つ設定を作成してくれたユーザに賞賛の念を示すことが大切です。そして「お返し」をすることを忘れてはいけません。それこそが Flow Production Tracking の仲間をサポートし、このコミュニティへの参加が特別なことであることを示す理由なのです。次に、設定による楽しみ方の例をいくつかを示します。コマンド ラインを使用して既定の設定を作成するいずれかのプロジェクト設定内で tank コマンドを使用すると、端末から管理コマンドを実行できます。各プロジェクトには専用の tank コマンドがあります。tank setup_project コマンドの機能は、[Advanced Setup Wizard]の機能と似ていて、既存のプロジェクトの設定や既定の設定に基づいて、プロジェクトで使用される編集可能な設定をディスク上に作成することができます。tank setup_project の実行方法については、こちらを、tank コマンドの詳細については、こちらを参照してください。プロダクション中に設定を編集する現在プロダクションで使用している設定を変更する必要があっても、アーティストが使用している間は編集したくない場合があります。Flow Production Tracking には、コマンドをいくつか実行するだけで既存の設定をコピーできる機能があります。この機能を使用すると、プロダクション環境に送信する前に変更内容について安全にテストすることができます。このプロセスを行うと、プロダクションの設定が新しい設定に置き換えられ、古い設定が自動的にバックアップされます。設定のコピーを操作する必要があるのは、次の理由からです。  設定を更新する  実行する前にいくつかの変更をテストする  一部のアプリをアップグレードまたは追加する  テスト後に開発を行って、展開する設定のクローン作成方法、および設定管理に関するその他の基本情報については、「設定のステージングとロールアウト」のドキュメントを参照してください。パイプライン設定のクラウドへの分散このガイドでは、中央設定の作成方法について説明します。中央設定とは、ネットワーク上の共有場所に配置されていて、すべてのユーザがアクセスできるパイプライン設定の単一コピーのことです。従業員が複数の場所およびネットワークに分散している場合は、パイプライン設定の単一コピーを共有できないことがあります。Toolkit は分散設定オプションを提供することによってこのシナリオを可能にします。すなわち、パイプライン設定を Flow Production Tracking にアップロードして、ユーザがプロジェクトにアクセスするたびに設定がダウンロードされ、ローカルにキャッシュされます。分散設定の詳細については、Core API 開発者向けドキュメントを参照してください。複数のルート フォルダを操作する理想的なのは、特定のタスクに合わせて施設を最適化することです。複数のルート フォルダを使用すると、1 台のサーバで日常業務を行い、もう 1 台のサーバでインタラクティブな処理を行うようビデオの再生を最適化することができます。Toolkit では複数のストレージのルートを操作し、上記のようなワークフローを容易に実行することができます。単一ルート設定からマルチルート設定への変換方法を確認してください。これで、プロジェクトのパイプライン設定が作成されたので、編集してみましょう。詳細については、次のガイドの「パイプライン設定の編集」にアクセスしてください。",
    "url": "/5d83a936/",
    "relUrl": "/5d83a936/"
  },
  "9": {
    "id": "9",
    "title": "Alias Flow Production Tracking ワークフロー",
    "content": "Alias Flow Production Tracking のワークフローこれらのワークフローでは、自動車設計における Flow Production Tracking と Alias の使用法について説明します。その他のチュートリアルについては、次のサイトを参照してください。  自動車設計のアーティスト向けワークフロー  自動車デザイン プロジェクトの概要チュートリアル",
    "url": "/7584b650/",
    "relUrl": "/7584b650/"
  },
  "10": {
    "id": "10",
    "title": "アプリケーションとエンジン設定のリファレンス",
    "content": "アプリケーションとエンジン設定のリファレンスこのドキュメントでは、Flow Production Tracking Toolkit でアプリケーション、エンジン、フレームワークの環境設定を作成する場合に追加できるさまざまなすべてのオプションの概要について説明します。アプリケーションの高度な設定を作成する場合に便利で、開発する場合とパラメータをアプリケーション設定マニフェストに追加する必要がある場合に重要です。このドキュメントは、Toolkit の設定を管理するユーザのみが使用可能な機能について説明します。詳細については、『Flow Production Tracking 統合管理者ガイド』を参照してください。はじめにこのドキュメントには、Sgtk が構成と設定に使用するさまざまなファイル形式の仕様が含まれます。これは利用可能なさまざまなオプションとパラメータを説明するリファレンス ドキュメントです。環境設定の管理方法に関するベスト プラクティスについては、次のドキュメントを参照してください。設定管理のベスト プラクティスFlow Production Tracking Toolkit の環境Toolkit の主要なコンポーネントは次の 3 つです。  エンジン はホスト アプリケーション(Maya や Nuke など)と Sgtk アプリケーション間の変換レイヤまたはアダプタを提供します。アプリケーションは通常、Python と PySide を使用しますが、標準化された方法でホスト アプリケーションを提供するのはエンジンの責任です。たとえば、PySide がまだ存在しない場合は、ホスト アプリケーションの最上位に PySide を追加します。  アプリ はビジネス ロジックを提供します。基本的に、これは何かを処理するツールです。アプリケーションは特定のホスト アプリケーションで動作するように作成したり、複数のホスト アプリケーションで動作するように設計できます。  フレームワーク は、エンジン、アプリ、または他のフレームワークで使用されるライブラリです。フレームワークにより、複数のアプリ間で共有されるコードまたは動作を簡単に管理できます。環境ファイル には、エンジン、アプリ、およびフレームワークのコレクションの環境設定が含まれています。このコレクションは「環境」と呼ばれます。Sgtk はさまざまなファイルまたはユーザに対して異なる環境を起動します。たとえば、ショット制作の環境とリギングの環境を設定できます。各環境は 1 つの yaml ファイルです。環境ファイルは /&amp;lt;sgtk_root&amp;gt;/software/shotgun/&amp;lt;project_name&amp;gt;/config/env に格納されています。yaml ファイルの基本的な形式は次のとおりです。    engines:        tk-maya:            location            engine settings                apps:                tk-maya-publish:                    location                    app settings                    tk-maya-revolver:                    location                    app settings            tk-nuke:            location            engine settings                apps:                tk-nuke-setframerange:                    location                    app settings                    tk-nuke-nukepub:                    location                    app settings        frameworks:        tk-framework-tools:            location            framework settings各アプリとエンジンは設定を介して指定できます。この設定は、アプリやエンジンが info.yml と呼ばれるマニフェスト ファイルで公開している設定のリストに対応しています。Sgtk Core の v0.18.x 以降、設定はマニフェスト ファイルで指定された既定値と異なる場合にのみ指定する必要があります。マニフェスト ファイルに加えて、通常、構成可能な設定は Toolkit アプリ ストア内のアプリとエンジンのページに表示されます。各項目で定義されるさまざまな設定とは別に、各アプリ、エンジン、およびフレームワークではそれぞれのコードの格納場所も定義する必要があります。これには特別な location パラメータを使用します。コードの場所環境ファイルで定義された各アプリ、エンジン、またはフレームワークには、実行するアプリのバージョンとダウンロード元を定義した location パラメータがあります。多くの場合、これは tank updates と tank install コマンドで自動的に処理されます。ただし、環境設定を手動で編集する場合は、Toolkit の展開と構成用のさまざまなオプションを使用できます。現在、Toolkit は次の場所の 記述子 を使用してアプリのインストールと管理をサポートします。  記述子 app_store は Toolkit アプリ ストアの項目を表します  記述子 Flow Production Tracking は Flow Production Tracking に保存された項目を表します  記述子 git は git リポジトリのタグを表します  記述子 git_branch は git ブランチのコミットを表します  記述子 path はディスク上の場所を表します  記述子 dev は開発者用サンドボックスを表します  記述子 manual はカスタムの展開とロールアウトに使用しますさまざまな記述子の使用方法のドキュメントについては、Toolkit リファレンス ドキュメントを参照してください。アプリとエンジンを無効にするアプリまたはエンジンを一時的に無効にすると、役に立つ場合があります。無効にするには、アプリまたはエンジンのロード元を指定する場所のディクショナリに disabled: true パラメータを追加することをお勧めします。この構文はさまざまな場所のタイプすべてでサポートされています。たとえば、次のようになります。location: {&quot;type&quot;: &quot;app_store&quot;, &quot;name&quot;: &quot;tk-nukepublish&quot;, &quot;version&quot;: &quot;v0.5.0&quot;, &quot;disabled&quot;: true}また、特定のプラットフォームのみでアプリを実行する場合は、特別な deny_platforms 設定を使用して指定することができます。location: {&quot;type&quot;: &quot;app_store&quot;, &quot;name&quot;: &quot;tk-nukepublish&quot;, &quot;version&quot;: &quot;v0.5.0&quot;, &quot;deny_platforms&quot;: [windows, linux]}deny_platforms パラメータの有効値は、windows、linux、および mac です。設定とパラメータ各アプリ、エンジン、またはフレームワークは、設定ファイルをオーバーライドできる数多くの設定を明示的に定義します。この設定は、文字列、整数、リストなどのタイプに分類されます。詳細については、Toolkit リファレンス ドキュメントを参照してください。",
    "url": "/6d10dedf/",
    "relUrl": "/6d10dedf/"
  },
  "11": {
    "id": "11",
    "title": "as_template_fields() でコンテキスト内に存在する値が見つからない",
    "content": "as_template_fields() でコンテキスト内に存在する値が見つからないas_template_fields() メソッドはパス キャッシュを使用するため、テンプレートのキーに対応するフォルダがまだ作成されていない場合、フィールドは返されません。これにはいくつかの原因があります。  テンプレート定義とスキーマを同期させる必要があります。このテンプレート定義またはパイプライン設定のスキーマの両方ではなく、いずれかを修正した場合は、予想フィールドが返されません。  フォルダはこの特定のコンテキスト用に作成されていません。まだ作成されていない場合は、パス キャッシュで一致するレコードがないため、予想フィールドが返されません。",
    "url": "/8d9d2658/",
    "relUrl": "/8d9d2658/"
  },
  "12": {
    "id": "12",
    "title": "ascii codec can’t decode byte 0x97 in position 10",
    "content": "ASCII codec can’t decode byte 0x97 in position 10: ordinal not in range関連するエラーメッセージ:設定のクローン作成している場合  TankError: Could not create file system structure: ascii! codec can’t decode byte 0x97 in position 10: ordinal not in range(128)別のプロジェクトを使用してプロジェクト設定をセットアップしている場合  ” ‘ascii’ codec can’t decode byte 0x97 in position 10: ordinal not in range(128)”修正方法:通常、「config」フォルダ内に Unicode または特殊文字が存在する場合は、このエラーが表示されます。ユーザが特殊文字を見つけることができるかどうかを確認するために、コメントを追加しました。このエラーの原因の例:この場合、エラーは、Windows がファイル名の末尾に接尾語 – を追加したことに起因していました。これらのファイルをすべて削除すると、機能するようになりました。コミュニティの完全なスレッドを参照してください。",
    "url": "/483eb2db/",
    "relUrl": "/483eb2db/"
  },
  "13": {
    "id": "13",
    "title": "AWS Knowledge",
    "content": "AWS KnowledgeBelow you can find links to additional reading material from AWS, including documentation on technologies leveraged by the Isolation feature set, as well as compliance information:  [AWS Media Blog] Securing Studio IP in AWS: Cloud-based VFX Project Management with Autodesk Shotgun  [AWS Media Blog] Designing for Studio-Grade Security  [Compliance] MPAA &amp;amp; Studio Security  [AWS Direct Connect] Overview          [AWS Direct Connect] User Guide        [AWS S3] Overview          [AWS S3] User Guide        [AWS EC2] Overview          [AWS EC2] User Guide        [AWS VPC] Overview          [AWS VPC] User Guide        [AWS PrivateLink] Overview",
    "url": "/5528234a/",
    "relUrl": "/5528234a/"
  },
  "14": {
    "id": "14",
    "title": "Webhook バッチ配信",
    "content": "バッチ配信バッチ配信を有効にするバッチ形式で配信オプションを選択すると、バッチ ペイロード形式で要求を行うように Webhook を設定できます。このオプションを有効にすると、各要求が形成された時点で、最大 50 個の保留中の配信がペイロードに格納されてバッチ処理されます。これは、多数の SG イベントが短時間に生成された結果、急増した配信の処理を管理する際に役立ちます。一般的なシステム運用環境では、登録済みのイベントが 2 秒間に 1 回を超える頻度で生成された場合、1 つのペイロードにつき複数の配信が発生します。配信に応答するバッチ配信を有効にする場合は、イベントにつき 1 秒を超える速度で確実に応答するよう設計されている受信サービスを使用することをお勧めします。そうしないと、バッチが巨大化した場合に、タイムアウトと Webhook エラーが生じるリスクが高まります。                    注: 1 つのイベントへの応答に 1 秒程度かかる受信サービスを使用している場合、パフォーマンスを決定する主な要因は、配信のオーバーヘッドではなく、応答時間です。バッチ配信しても、あまりメリットはありません。    非バッチ配信型の Webhook  タイムアウトの許容時間は、配信あたり 6 秒です。つまり、Webhook エンドポイントは、6 秒以内に各要求に応答する必要があります。バッチ配信型の Webhook  タイムアウトの許容値は、最大で 6 秒、またはバッチ内のイベントあたり 1 秒です。  スロットル制限は引き続き適用されます。Flow Production Tracking サイトごとに許可される 1 分間あたりの Webhook エンドポイント応答時間は、Webhook 全体で 1 分です。Webhook 配信形式の比較非バッチ配信型の Webhook メッセージの本文(配信数は常に 1):{  &quot;data&quot;:{    &quot;id&quot;:&quot;119.110.0&quot;,    &quot;event_log_entry_id&quot;:479004,    &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,    &quot;operation&quot;:&quot;update&quot;,    &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},    &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1419},    &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:127},    &quot;meta&quot;:{      &quot;type&quot;:&quot;attribute_change&quot;,      &quot;attribute_name&quot;:&quot;code&quot;,      &quot;entity_type&quot;:&quot;Asset&quot;,      &quot;entity_id&quot;:1419,      &quot;field_data_type&quot;:&quot;text&quot;,      &quot;old_value&quot;:&quot;Cypress test asset for Webhooks deliveries&quot;,      &quot;new_value&quot;:&quot;Revised test asset for Webhooks deliveries&quot;    },    &quot;created_at&quot;:&quot;2021-02-22 17:40:23.202136&quot;,    &quot;attribute_name&quot;:&quot;code&quot;,    &quot;session_uuid&quot;:null,  },  &quot;timestamp&quot;:&quot;2021-02-22T17:40:27Z&quot;}バッチ配信型 Webhook メッセージの本文(配信数は 1 ～ 50)バッチ処理を有効にした場合は、バッチ内のイベント数が 1 つのみのときでも、deliveries キーは常に存在します。この値は個々のイベント配信データの配列であり、配信ごとに指定される情報は非バッチ モードと同じです。{  &quot;timestamp&quot;:&quot;2021-02-22T18:04:40.140Z&quot;,  &quot;data&quot;:{    &quot;deliveries&quot;:[      {        &quot;id&quot;:&quot;170.141.0&quot;,        &quot;event_log_entry_id&quot;:480850,        &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,        &quot;operation&quot;:&quot;update&quot;,        &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},        &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1424},        &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:132},        &quot;meta&quot;:{          &quot;type&quot;:&quot;attribute_change&quot;,          &quot;attribute_name&quot;:&quot;code&quot;,          &quot;entity_type&quot;:&quot;Asset&quot;,          &quot;entity_id&quot;:1424,          &quot;field_data_type&quot;:&quot;text&quot;,          &quot;old_value&quot;:&quot;Cypress test asset for Webhooks deliveries&quot;,          &quot;new_value&quot;:&quot;Revised test asset for Webhooks deliveries&quot;        },        &quot;created_at&quot;:&quot;2021-02-22 18:04:39.198641&quot;,        &quot;attribute_name&quot;:&quot;code&quot;,        &quot;session_uuid&quot;:null,      },      {        &quot;id&quot;:&quot;170.141.1&quot;,        &quot;event_log_entry_id&quot;:480851,        &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,        &quot;operation&quot;:&quot;update&quot;,        &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},        &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1424},        &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:132},        &quot;meta&quot;:{          &quot;type&quot;:&quot;attribute_change&quot;,          &quot;attribute_name&quot;:&quot;description&quot;,          &quot;entity_type&quot;:&quot;Asset&quot;,          &quot;entity_id&quot;:1424,          &quot;field_data_type&quot;:&quot;text&quot;,          &quot;old_value&quot;:null,          &quot;new_value&quot;:&quot;Some other *description*&quot;        },        &quot;created_at&quot;:&quot;2021-02-22 18:04:39.212032&quot;,        &quot;attribute_name&quot;:&quot;description&quot;,        &quot;session_uuid&quot;:null,      },    ]  }}",
    "url": "/e7890fc8/",
    "relUrl": "/e7890fc8/"
  },
  "15": {
    "id": "15",
    "title": "最初のプロジェクトの作成後",
    "content": "最初のプロジェクトの作成後ここでは、Flow Production Tracking Toolkit を使用して最初のプロジェクトを設定および実行した後の作業について説明します。ここには、よくある質問、トピック、役に立つドキュメントが掲載されています。Toolkit へようこそToolkit へようこそ! このドキュメントを読んでいるということは、Flow Production Tracking Toolkit を使用して最初の Flow Production Tracking Toolkit プロジェクトのインストールに成功したことになります。この段階では、上記のスクリーンショットのような画面や、いくつかのアプリケーション ランチャーが設定されたプロジェクト ページが表示されているはずです。ここでは、Maya、Nuke、または他のアプリケーションを起動してみてください。ファイルとアセットを管理するための詳細な機能を含む Flow Production Tracking メニューが表示されているはずです。では次に何をしましょうか? Toolkit は、環境設定とその仕組みに関して優れた柔軟性を発揮します。このドキュメントでは、Flow Production Tracking Toolkit を使用して最初のプロジェクトを完成したら実行すべきいくつかの推奨手順について説明します。基本設定このセクションには、一連の調整項目と、設定すると便利な項目が含まれます。最初の Toolkit プロジェクトをセットアップしたら、すべてを正しく機能させるためにたくさんの項目を少しずつ調整することになるでしょう。このセクションでは、それらのさまざまな手順について説明します。その中には設定ファイルの編集や現時点の「具体的な調査」が含まれます。何か質問がありましたら、サポート サイトにアクセスしてサポートを依頼してください。アプリケーション パスをセットアップする最初のプロジェクトをセットアップして、Maya、Motionbuilder、または Nuke のいずれかの起動ボタンをクリックすると、次のようなエラー メッセージが表示される可能性があります。Toolkit プロジェクト設定には、起動可能なさまざまな実行可能ファイルへのパスが保存されています。上記のメッセージが表示された場合は、このパスがスタジオのセットアップと一致していない可能性があります。 この場合、異なるバージョンのアプリケーションが起動されていることもあります。たとえば、既定では Maya 2015 へのパスが設定されていますが、スタジオで Maya 2014 を使っている場合などです。この場合、このパスも変更する必要があります。既定の設定では、このようなパスはすべて、paths.yml と呼ばれる 1 つのファイルに保存されています。パスを変更するためには、ディスク上のプロジェクト設定を特定し、paths.yml ファイルが見つかるまで設定フォルダを移動します。このファイルを開いて、パスに必要な変更を加えます。ファイルを保存したら、Flow Production Tracking Toolkit 内のプロジェクトを終了して、このプロジェクトを再びクリックする必要があります (ただし、アプリケーション全体を再起動する必要はありません)。その他の資料アプリケーションの詳細については、次のトピックを参照してください。  Toolkit アプリケーション ランチャー  コマンドライン引数を渡すFlow Production Tracking 統合Toolkit は Flow Production Tracking と統合し、特別なツールキット アクション メニュー アイテムを UI のさまざまな部分に追加することで従来のインタフェースを拡張します。これにより、データに作用する Toolkit アプリケーションまたはカスタム ツールを Flow Production Tracking から直接起動できるようになります。Flow Production Tracking サイトとの統合の詳細については、『管理者ガイド』の「ブラウザの統合」のセクションを参照してください。Flow Production Tracking UI にパブリッシュを追加するToolkit をインストールしたら、通常は Flow Production Tracking UI レイアウトに微調整を加える必要があります。ファイルをパブリッシュすると、Flow Production Tracking Toolkit は パブリッシュ エンティティ を作成するため、ショットやアセットなどのキー アセットに Publishes タブ を簡単に追加できます。このためには、管理者ユーザとしてログインする必要があります。アセットまたはショットを選択し、 [デザイン モード] (Design Mode) を選択して開始します。ここで、タブ上の小さな三角形のメニューをクリックし、[新しいタブを追加] (Add New Tab) アクションを選択します。これでダイアログ UI が表示されます。[パブリッシュ] (Publishes) タブを呼び出し、 [パブリッシュ ファイル] (Published File) エンティティと関連付けられていることを確認します。ここで [保存] (Save) をクリックして変更内容を保存します。設定がすべて完了しました。注: 新しいタブを作成すると、Flow Production Tracking は取り込むいくつかの既定のフィールドを選択します。パブリッシュ用にいくつかのフィールドを追加する場合があります。このためには、新しいパブリッシュ タブの下に表示されるスプレッドシートの右上隅にある小さなプラス ボタンをクリックします。次のフィールドを追加することをお勧めします。  [説明] (Description): このパブリッシュの変更に関する説明が表示されます  [作成者] (Created By): パブリッシュを作成したユーザ  [作成日] (Date Created): パブリッシュが作成された日付レイアウトを変更する場合は、後でページを忘れずに保存してください。複数のオペレーティング システムPython が見つからないことを通知するメッセージがドキュメントのこのセクションへのリンクとともに表示される場合があります。Toolkit は、Python と呼ばれる言語を使用してスクリプトと機能を実行します。Flow Production Tracking Toolkit には完全な Python がインストールされているため、通常はこのことを心配する必要はありません。Flow Production Tracking Toolkit を使用して新しい Toolkit プロジェクトをセットアップすると、既定では、プロジェクトは Flow Production Tracking Toolkit にバンドルされた Python を使用するようにセットアップされます。ただし、場合によっては、Toolkit に Python の使用を明示的に指示する必要があります。これは次の場合に発生します。  すべての Python の既定値が自動的に設定されない、古いバージョンの Flow Production Tracking Toolkit を使用する場合。  Flow Production Tracking Toolkit をディスク上の標準の場所以外にインストールしている場合。  手動または複雑な Toolkit プロジェクト セットアップを実行している場合。Python へのパスは設定ファイルに保存されており、手動で編集することができます。正しいファイルを探すためには、最初にプロジェクト設定に移動します。ここで、interpreter_ から始まる 3 つのファイルを探します。Linux、Windows、および Mac (「Darwin」)用の Python インタプリタへのパスが含まれています。これらのファイルには、3 つのオペレーティング システム用の Python の場所がそれぞれ含まれます。ここで、使用するオペレーティング システム用の Python の場所を手動で追加する必要があります。ファイルが空の場合、古いバージョンの Flow Production Tracking Toolkit を使用していることを示しています。このような場合は、既定の Python のパスで空のファイルを更新します。既定のパスは次のとおりです。  Macosx (Darwin): /Applications/Shotgun.app/Contents/Frameworks/Python/bin/python  Windows: C: Program Files Shotgun Python python.exe  Linux: /opt/Shotgun/Python/bin/python標準の場所以外に Flow Production Tracking Toolkit をインストールしたり、独自の Python の場所を使用したりする場合は、ファイル内のこのパスが有効な Python インストールをポイントしていることを確認してください。バージョンは v2.6 以上(Python 3 以外)を指定する必要があります。UI ベースのアプリケーションとツールを実行する場合は、指定した Python に PyQt または PySide がインストールされており、QT v4.6 以降にリンクされていることを確認してください。複数のオペレーティング システムで Toolkit を実行するために、プロジェクト セットアップ ウィザードの実行時にすべての任意のプラットフォームへのパスを指定する必要があることにも注意してください。パスをまだ指定しておらず、別のオペレーティング システムをストレージ パスまたは設定場所に追加する場合は、サポート サイトにアクセスしてサポートを依頼してください。次のステップこの時点で、Flow Production Tracking プロジェクト(またはテスト プロジェクト)用に既定の Flow Production Tracking セットアップが動作しているはずです。アプリケーションが起動し、コンテキスト メニュー アクションとパブリッシュが Flow Production Tracking に表示され、任意のオペレーティング システム プラットフォームすべてで処理が行われています。このセクションでは、次の作業、つまり既定の設定を取り込んで、スタジオ パイプラインの全体と機能するように調整するプロセスについて説明します。Toolkit には柔軟性があり、高度にカスタマイズ可能で、たくさんのドキュメントが用意されています。開始前にすべてのアクションを確認するために、数分間を費やしてさまざまなウォークスルー ビデオを視聴することをお勧めします。このビデオでは、Flow Production Tracking Toolkit の操作、Maya や Nuke などのアプリケーション内での動作について説明しています。また、パブリッシュ、バージョン管理、読み込みなどの基本的なコンセプトについても説明します。Toolkit プロジェクトの構造新しい Toolkit プロジェクトを作成する場合、いくつかの主要な場所があります。  Flow Production Tracking Toolkit とその環境設定はローカル マシンにインストールされます (必要に応じて、アプリケーションと環境設定の両方を共有ストレージに配置することができます)。  Toolkit プロジェクトがテクスチャ、ファイル、レンダリングなどを保存するデータ領域です。通常この領域は、他のユーザとデータを共有するために共有ストレージ上にありますが、これには例外があります。ユーザ作業領域をローカル(ユーザのみの)ストレージ上に指定し、Perforce 統合などで外部システムを使用してコンテンツを配布する場合です。  Toolkit の環境設定は、コード、アプリ、Core API などを完全に独自にバンドルしています。通常、これは共有ストレージに格納されており、すべてのユーザが環境設定に簡単にアクセスできます。ディスク上のプロジェクト設定にはいくつかの異なる項目が含まれています。次のセクションでは、プロジェクト設定フォルダのさまざまな部分について説明します。コマンド ライン アクセスFlow Production Tracking Toolkit を使用する場合と同様に、端末またはシェルからも Toolkit にアクセスできます。ディスク上に作成した各プロジェクトには、API セッションやアプリケーションの起動など、たくさんの機能にコマンド ライン ベースでアクセスする特別な tank コマンドが用意されています。プロジェクト設定に移動すると、設定のルートに tank と tank.bat コマンドが表示されます。オプションを使用せずにこれらのコマンドを実行すると、現在の環境設定でサポートされるすべてのコマンドがリスト表示されます。次のような便利なコマンドもあります。  tank shell: tk api アクセスでインタラクティブな Python シェルを起動します  tank core: このプロジェクトの Core API に更新があるかどうかを確認します  tank updates: この設定のアプリまたはエンジンに更新があるかどうかを確認しますtank コマンドの実行内容の詳細については、詳細な技術ドキュメントを参照してください。Toolkit を管理する方法主要な設定ファイルconfig フォルダにはいくつかの主要な設定ファイルが含まれます。Toolkit には、アプリケーションの起動時に必要なすべての構造がディスク上に用意され、事前に設定が完了するようディスク上にフォルダを自動的に作成するフォルダ作成システムが付属します。この設定は上記の schema フォルダ内にあります。このフォルダにアクセスすると、パブリッシュ、作業ファイル、レンダリングなど、設定可能なファイルへのさまざまなパスを簡単に定義できる Toolkit の 「テンプレート システム」 があります。これは上記の templates.yml ファイルに保存されています。プロジェクト設定のこれら 2 つを組み合わせると、既存のパイプラインで認識されるディスク上の場所にデータを書き込むために Toolkit が使用するさまざまなアプリを調整できます。詳細については、高度なドキュメントを参照してください。  フォルダの設定  ファイルシステム テンプレートToolkit の基本設定では、一連のアプリとエンジンが既に設定されています。この設定は env フォルダ内に格納されています。上記のファイル システム設定ファイルでディスク上のリソースの 格納場所 を定義する場合、そのアプリとエンジンを含む環境設定はパイプラインの 動作内容 を定義します。Core API プラットフォーム各プロジェクト設定で一連のアプリとエンジンが使用されます。このアプリとエンジンの環境設定は環境設定内の env フォルダに格納されています。Toolkit は、このアプリとエンジンの実行に必要なコードのさまざまなバージョンを自動的にダウンロードおよび管理します。このコードは install フォルダ内に配置されます。環境設定、アプリ、およびエンジンはすべて、Toolkit Core プラットフォーム上で動作します。新しいプロジェクトの場合、これも install フォルダに保存されます。基本的に、プロジェクト設定は完全な自己完結型で、Toolkit の実行に必要なすべてのパーツは 1 つの場所に格納されています。また、各プロジェクトは独立しており、1 つのプロジェクトを更新しても別のプロジェクトには影響しません。テクニカル ノート: 共有 Toolkit Core を使用する(クリックして展開)その他の資料さらに、Flow Production Tracking Toolkit の概念と「概要」を説明した技術ドキュメントもあります。最初に Toolkit の操作を簡単に把握したら、自社固有のニーズに合わせて Toolkit を調整する方法について理解できるこのドキュメントを確認することをお勧めします。Flow Production Tracking Toolkit の概念の説明Toolkit コミュニティToolkit にはパイプライン エンジニアと TD のコミュニティがあります。当社は、Toolkit と組み合わせて強力で柔軟性に優れたパイプライン環境を展開できるようにコードを積極的に共有するコミュニティの作成に取り組んでいます。質問がある場合や過去の投稿や会話を確認する場合は、コミュニティにアクセスしてください。",
    "url": "/c3b662a6/",
    "relUrl": "/c3b662a6/"
  },
  "16": {
    "id": "16",
    "title": "Linux で Flow Production Tracking Toolkit/ブラウザ統合の起動に失敗する",
    "content": "Linux で Flow Production Tracking Toolkit/ブラウザ統合の起動に失敗するLinux で Flow Production Tracking Toolkit を初めて実行すると、次のいずれかのエラー メッセージが表示される場合があります。この場合、特定のエラーに合わせて次の手順を実行して問題が解決されるかどうかを確認します。問題が解決しない場合は、サポート サイトにアクセスしてサポートを依頼してください。目次  OPENSSL_1.0.1_EC または HTTPSConnection に関連する問題  libffi.so.5 に関連する問題  証明書検証の失敗に関連する問題  互換性のない Qt バージョンOPENSSL_1.0.1_EC または HTTPSConnection に関連する問題エラーimporting '/opt/Shotgun/Resources/Python/tk-framework-desktopstartup/python/server/resources/python/dist/linux/cryptography/_Cryptography_cffi_36a40ff0x2bad1bae.so': /opt/Shotgun/Resources/Python/tk-framework-desktopstartup/python/server/resources/python/dist/linux/cryptography/_Cryptography_cffi_36a40ff0x2bad1bae.so: symbol ECDSA_OpenSSL, version OPENSSL_1.0.1_EC not defined in file libcrypto.so.10 with link time referenceAttributeError: 'module' object has no attribute 'HTTPSConnection'解決策OpenSSL をインストールする必要があります。このためには、管理者として次のコマンドを実行します。$ yum install openssllibffi.so.5 に関連する問題エラーBrowser Integration failed to start. It will not be available if you continue.libffi.so.5: cannot open shared object file: No such file or directory解決策libffi をインストールする必要があります。このためには、管理者として次のコマンドを実行します。yum install libffilibffi をインストールしても問題が継続する場合は、次の symlink を作成して Flow Production Tracking Toolkit を再起動してください。sudo ln -s /usr/lib64/libffi.so.6.0.1 /usr/lib64/libffi.so.5上記の手順で成功したユーザもいますが、問題が解決しなかったユーザもいます。最新バージョンの Flow Production Tracking Toolkit には、現在調査している Web ソケット サーバとの依存関係がいくつか追加されています。証明書検証の失敗に関連する問題考えられるエラーBrowser Integration failed to start. It will not be available if you continue.Error: There was a problem validating if the certificate was installed.certutil: function failed: SEC_ERROR_BAD_DATABASE: security library: bad database.解決策コンピュータに Google Chrome をインストールしている場合は、Google Chrome を起動してから Flow Production Tracking Toolkit を再起動します。問題が解決しない場合は、サポート サイトにアクセスしてサポートを依頼してください。Chrome がインストールされていない場合は、端末を開いて、次のコマンドを実行します。ls -al $HOME/.pki/nssdbここで何か見つかった場合は、サポートまでご連絡ください。チケットに次のログ ファイルの内容を添付してください。~/.shotgun/logs/tk-desktop.log何も見つからなかった場合は、次のコードを入力します。$ mkdir --parents ~/.pki/nssdb$ certutil -N -d &quot;sql:$HOME/.pki/nssdb&quot;パスワードは入力しないでください。これで、Flow Production Tracking Toolkit が正しく起動されるようになります。互換性のない Qt バージョン考えられるエラー互換性のない Qt ライブラリ(バージョン 0x40805)とこのライブラリ(バージョン 0x40807)を混在させることができない解決策多くの場合、互換のない Qt ライブラリをロードするオーバーライドが実行されると発生します。このエラーが発生しないようにするには、次のコマンドを使用して環境を修正します。unset QT_PLUGIN_PATH",
    "url": "/9207f027/",
    "relUrl": "/9207f027/"
  },
  "17": {
    "id": "17",
    "title": "ローカル ファイル リンクを使用できず、Chrome から Toolkit アプリケーションを起動できない",
    "content": "ローカル ファイル リンクを使用できず、Chrome から Toolkit アプリケーションを起動できない概要Flow Production Tracking のアクション メニューで Toolkit アプリケーションのリストが表示されなかったり、Flow Production Tracking Toolkit が動作していてもローカル ファイル リンクを使用するときにエラーが発生したりする場合があります。 これは Chrome での Flow Production Tracking Toolkit のブラウザ統合のトラブルシューティングに関するガイドです。皆さんの役に立つことを願っています。Firefox のための個別のガイドがあります。  問題を診断する  証明書問題をすばやく修正する方法  すべてのプラットフォームの ERR_CERT_COMMON_NAME_INVALID または ERR_SSL_SERVER_CERT_BAD_FORMAT を修正する  Windows で ERR_CERT_AUTHORITY_INVALID を修正する問題を診断するFlow Production Tracking Toolkit は動作していますか?もちろん、そうだと思います。既に確認済みだと思いますが、念のためお尋ねしました。:)Flow Production Tracking Toolkit の起動後に Chrome を再起動しましたか?Flow Production Tracking Toolkit が証明書を登録する前に Chrome を起動した場合(Flow Production Tracking Toolkit を初めて起動した場合にのみ発生し、その後は問題になりません)、Chrome は期限切れの証明書のコピーを使用し、Flow Production Tracking Toolkit への接続を拒否します。すべてのタブを閉じても Chrome が終了するとは限らないため、アドレス バーに chrome://restart と入力して[Enter]キーを押すことをお勧めします。これにより、Chrome に関連するすべてのプロセスを終了し、Chrome を再起動させます。ファイアウォール ソフトウェアを使用していますか?ファイアウォール ソフトウェアが localhost またはポート 9000 との接続を妨げていないことを確認します。Chrome が証明書を拒否していますか?Chrome が証明書を受け入れていることを確認するには、https://localhost:9000 を参照します。これは、ローカル ファイル リンクを使用して Toolkit アプリケーションを起動するために Flow Production Tracking Web サイトがアクセスを試みるアドレスです。通常、次のメッセージが表示されます。または、次のいずれかのメッセージが表示された場合は、証明書の登録プロセスに問題があったことを示しています。 証明書問題をすばやく修正する方法この問題を回避する最も簡単な方法は、ADVANCED と Proceed to localhost (unsafe) をクリックすることです。これにより、Chrome は証明書を承認していることを把握でき、Flow Production Tracking Web サイトが Flow Production Tracking Toolkit と通信できるようになります。                    注: このため、Web ブラウザと Flow Production Tracking Toolkit 間の接続のみが有効になります。信頼設定は 2 つのアプリケーション間のトラフィック フローを許可しますが、インターネット上の他のサーバの信頼性を暗示しているわけではありません。残念なことに、問題を抱えたすべてのコンピュータにこのプロセスを繰り返し適用する必要があります。問題が解決されない場合、またはすべてのユーザに展開するには複雑すぎる場合は、次の手順を試すことをお勧めします。                        注: この手順は ERR_SSL_SERVER_CERT_BAD_FORMAT エラーには適用されません。以下の説明のとおりに証明書を再生成する必要があります。    すべてのプラットフォームの NET::ERR_CERT_COMMON_NAME_INVALID と ERR_SSL_SERVER_CERT_BAD_FORMAT を修正するChrome は自己署名証明書のセキュリティを定期的に更新しますが、ブラウザ統合がこの更新で壊れることがあります。残念ながら、このような問題を解決するには証明書の certificate_path を再生成するしかありません。証明書を再生成するには、Flow Production Tracking Toolkit のユーザ メニューの [詳細設定] (Advanced)セクションにある Regenerate Certificates オプションを選択します。(このオプションが表示されない場合は、ロック解除のために tk-desktop エンジンを更新してください。)証明書の再生成を確定すると、証明書を初めて生成したときのように一連のダイアログが表示されます。Windows と macOS で、Windows Certificate Store または macOS キーチェーンの更新を求めるプロンプトが 2 回表示されます。1 回目は古い証明書の削除のときで、2 回目は新しい証明書の登録のときです。Linux では、確認なしで登録されます。登録されると、Flow Production Tracking Toolkit が再起動されます。Flow Production Tracking Toolkit の準備が完了したら、Chrome が完全にシャットダウンしてその証明書キャッシュがクリアされるように、アドレス バーに chrome://restart と入力して Chrome を再起動することをお勧めします。コンピュータがインターネットに接続されておらず、更新をダウンロードできない場合は、サポート サイトにアクセスしてサポートを依頼してください。Windows で NET::ERR_CERT_AUTHORITY_INVALID を修正する特定の状況において、Windows で証明書の読み込みが成功した場合でも、証明書を必要とするアプリケーションがその証明書を使用できないことがあります。これは Windows の証明書ダイアログにアクセスすると確認できます。アクセスするには、[Windows]キーを押してから インターネット オプション と入力します。[インターネットのプロパティ] (Internet Properties)ダイアログで[コンテンツ] (Content)タブに切り替え、[証明書] (Certificates) ボタンをクリックします。最後に、[信頼されたルート証明機関] (Trusted Root Certification Authorities) をクリックし、localhost を探します。エントリが見つからない場合は、Windows ドメインまたはローカル コンピュータのグループ ポリシーに問題がある可能性があります。問題がある場合は、サポート チームに連絡することをお勧めします。ここで、組織の Windows コンピュータを管理するユーザに連絡し、自己署名証明書を信頼しないように Windows に指示しているグループ ポリシーがないかどうかを確認してもらうことをお勧めします。グループ ポリシーの問題を調査するコンピュータがドメイン上にある場合、管理者はこの StackExchange の投稿で説明されている手順を試してみてください。コンピュータがドメイン上にない場合は、管理者によってコンピュータがまだロックされている可能性があります。次の手順には Windows の管理者アカウントが必要です。[Windows]キーを押して、mmc と入力して[Enter]キーを押します。これにより、Microsoft 管理コンソールが起動します。このアプリケーションで、[ファイル] (File)メニューをクリックし、[スナップインの追加と削除] (Add/Remove Snap-In)を選択します。これにより、[スナップインの追加と削除] (Add/Remove Snap-In)ダイアログが表示されます。左側で、Group Policy Object Editor を探して選択し、[追加 &amp;gt;] (Add &amp;gt;)をクリックします。新しいダイアログが表示されたら、[終了] (Finish)をクリックして閉じます。最後に、[スナップインの追加と削除] (Add/Remove Snap-In)ダイアログで、[OK] をクリックします。最後に、メイン ダイアログの左側から [ローカル コンピュータ ポリシー/コンピューターの構成/Windows 設定/セキュリティ設定/公開キーのポリシー] (Local Computer Policy/Computer Configuration/Windows Settings/Security Settings/Public Key Policies)に移動します。選択したら、中央のペインで [証明書パス検証の設定] (Certificate Path Validation Settings) をダブルクリックします。次のダイアログ ボックスで、[これらのポリシーの設定を定義する] (Define these policy settings) の選択が解除されていることを確認します。選択されている場合は、[ユーザーが信頼するルート証明機関 (CA) が証明書の検証に使用されることを許可する(推奨)] (Allow user trusted root CAs to be used to validate certificates (recommended)) が選択されていることを確認します。完了後、OK をクリックすると、設定が保存されます。ここで、Chrome のすべてのウィンドウを閉じて、Chrome を再起動する必要があります。上述のとおりに chrome://restart を使用することをお勧めします。この操作は変更を有効にするために必要です。証明書リストを参照すると、localhost 証明書が表示されます。この変更後にブラウザ統合を使用して問題が発生した場合、または元の設定が正しい場合は、サポート チームまでご連絡ください。他の OS でのトラブルシューティング他の OS での Flow Production Tracking Toolkit 統合に問題がある場合は、この記事を更新してサポートできるように、サポート チームまでご連絡ください。",
    "url": "/95518180/",
    "relUrl": "/95518180/"
  },
  "18": {
    "id": "18",
    "title": "ローカル ファイル リンクを使用できず、Firefox から Toolkit アプリケーションを起動できない",
    "content": "ローカル ファイル リンクを使用できず、Firefox から Toolkit アプリケーションを起動できない概要Flow Production Tracking のアクション メニューで Toolkit アプリケーションのリストが表示されなかったり、Flow Production Tracking Toolkit が動作していてもローカル ファイル リンクを使用するときにエラーが発生したりする場合があります。これは Firefox での Flow Production Tracking Toolkit のブラウザ統合のトラブルシューティングに関するガイドです。皆さんの役に立つことを願っています。Chrome のための個別のガイドがあります。問題を診断するFlow Production Tracking Toolkit は動作していますか?もちろん、そうだと思います。既に確認済みだと思いますが、念のためお尋ねしました。:)ファイアウォール ソフトウェアを使用していますか?ファイアウォール ソフトウェアが localhost またはポート 9000 との接続を妨げていないことを確認します。Firefox が証明書を拒否していますか?Firefox が証明書を受け入れていることを確認するには、https://localhost:9000 を参照します。これは、ローカル ファイル リンクを使用して Toolkit アプリケーションを起動するために Flow Production Tracking Web サイトがアクセスを試みるアドレスです。通常、次のメッセージが表示されます。次のいずれかのメッセージが表示された場合は、証明書の登録プロセスに問題があったことを示しています。「安全な接続ではありません」というエラーを解決する方法証明書を受け入れられるように例外を Firefox ブラウザに追加する必要があります。https://localhost:9000 にアクセスしたばかりの場合は、[詳細] (Advanced)をクリックし、[例外を追加] (Add Exception)ボタンをクリックして例外を追加するのが最も簡単な方法です。ダイアログが表示されます。[証明書を取得] (Get Certificate)、[セキュリティ例外を承認] (Confirm Security Exception)の順にクリックします。 証明書を信頼できないというメッセージは無視します。証明書は認証局ではなく Flow Production Tracking Toolkit によって生成されているため、問題ありません。これで Flow Production Tracking サイトからローカル ファイル リンクにアクセスし、Toolkit アプリケーションを起動できるようになるはずです。例外を追加しても問題が解決しない場合は、サポート サイトにアクセスしてサポートを依頼してください。「安全な接続ができませんでした」というエラーを解決する方法[メニューを開きます] (Open Menu)ボタンをクリックして、[基本設定] (Preferences)を選択します。次に、左側で[詳細] (Advanced)を選択し、[証明書] (Certificates)、[証明書を表示] (View Certificates)の順に選択します。[サーバー証明書] (Servers)セクションで項目をクリックし、localhost と入力するか、または単に localhost:9000 という名前のエントリが表示されるまでスクロールします。このエントリを削除します。次に、[認証局証明書] (Authorities)タブに移動して localhost と再び入力します。もう一度、localhost エントリを持つ Autodesk セクションが表示されるまでスクロールします。localhost エントリを削除します。これが完了したら、[OK] をクリックして Firefox を再起動します。Firefox の再起動が完了したら、https://localhost:9000 にアクセスします。次のメッセージが表示されます。ここで、例外を追加するために上記の手順を実行する必要があります。これとは異なる画面が表示される場合は、サポート サイトにアクセスしてサポートを依頼してください。",
    "url": "/d4936105/",
    "relUrl": "/d4936105/"
  },
  "19": {
    "id": "19",
    "title": "ローカルな {% include product %} サイトで {% include product %} Desktop を使用しているときに CERTIFICATE_VERIFY_FAILED が表示される",
    "content": "ローカルな Flow Production Tracking サイトで Flow Production Tracking Toolkit を使用しているときに CERTIFICATE_VERIFY_FAILED が表示される使用例:Flow Production Tracking のローカル インストールを使用する場合、このエラーは次の 2 つのシナリオで発生する可能性があります。  Flow Production Tracking Toolkit にログインする場合  Toolkit AppStore からメディアをダウンロードする場合修正方法:この問題を解決するには、すべての有効な CA のリスト(ユーザ独自のリストを含む)が格納されているファイルを Flow Production Tracking API に提供する必要があります。通常は、最初に Python の certifi パッケージからこのファイルの新しいコピーをダウンロードして、ファイルの末尾に独自の CA を追加することをお勧めします。次に、すべてのユーザがアクセスできる場所に、このファイルを保存します。最後に、各コンピュータで、環境変数 SHOTGUN_API_CACERTS をこのファイルのフル パスに設定します(例: /path/to/my/ca/file.pem)。この操作を行うと、ローカル サイトで発生する CERTIFICATE_VERIFY_FAILED エラーが解決されます。Flow Production Tracking サイトに接続できる場合でも、Toolkit AppStore から更新をダウンロードできないときは、.pem ファイルに Amazon CA が含まれていないことが原因である可能性があります。この状況は通常、空のファイルから開始して、カスタム CA のみを追加した場合に発生します。上記のリンク先ファイルなどから開始した場合は、問題が発生しません。この情報は、ローカル インストールにのみ適用されることにご注意ください。ホスト サイトを使用しているときに、Windows 環境でこのエラーが発生する場合は、このフォーラムの投稿を参照してください。エラーが別の OS で発生している場合は、このドキュメントを参照してください。このエラーの原因の例:この問題は通常、HTTPS を使用するようにローカルサイトが設定されているにもかかわらず、ローカル サイトの証明書への署名に使用した認証局(これ以降、CA と表記)が認識されるように Toolkit が設定されていない場合に発生します。コミュニティの完全なスレッドを参照してください。",
    "url": "/413b6be4/",
    "relUrl": "/413b6be4/"
  },
  "20": {
    "id": "20",
    "title": "Flow Production Tracking in the Cloud",
    "content": "Flow Production Tracking in the CloudWhat is Flow Production Tracking in the Cloud?Flow Production Tracking Cloud is our default offering, hosted on AWS and built on top of Autodesk’s Cloud technology platform. Flow Production Tracking Cloud is the latest generation of our hosted service and is completely cloud based.Further ReadingAdministration documentation can be found here.",
    "url": "/af35baf6/",
    "relUrl": "/af35baf6/"
  },
  "21": {
    "id": "21",
    "title": "コミュニティで共有されている統合",
    "content": "コミュニティで共有されている統合以下に示すものは、Toolkit コミュニティのユーザが共有しているプロジェクトです。Flow Production Tracking の開発チームが作成したものではないため、保証は適用されませんが、質問にはお答えします。このリストに自分のプロジェクトを追加したいと思う方は、サポート サイトにアクセスしてサポートを依頼してください。エンジン            統合      エンジン      情報                        tk-katana      プロジェクト URL: https://github.com/robblau/tk-katana プロジェクト投稿者: Lightchaser Animation プロジェクト管理者:  プロジェクトの説明: Foundry の Katana 用の Flow Production Tracking エンジン                    tk-unreal      プロジェクト URL: https://docs.unrealengine.com/4.26/ja/ProductionPipelines/UsingUnrealEnginewithAutodeskShotgun/ プロジェクト投稿者: Epic Games プロジェクト管理者: プロジェクトの説明: Unreal Engine 用の Flow Production Tracking エンジン                    tk-substancepainter      プロジェクト URL: https://github.com/diegogarciahuerta/tk-substancepainter プロジェクト投稿者: Factor64 プロジェクト管理者: Diego Garcia Huerta プロジェクトの説明: Adobe の Substance Painter 用の Flow Production Tracking エンジン                    tk-substancedesigner      プロジェクト URL: https://github.com/diegogarciahuerta/tk-substancedesigner   プロジェクト投稿者: Factor64   プロジェクト管理者: Diego Garcia Huerta   プロジェクトの説明: Adobe の Substance Designer 用の Flow Production Tracking エンジン    詳細: Flow Production Tracking コミュニティ フォーラム                    tk-modo      プロジェクト URL: https://github.com/tremolo/tk-modo   プロジェクト投稿者: Lutz Pälike と Walking The Dog   プロジェクト管理者:   プロジェクトの説明: Foundry の Modo 用の Flow Production Tracking エンジン                    tk-clarisse      プロジェクト URL: https://github.com/diegogarciahuerta/tk-clarisse プロジェクト投稿者: Factor64 プロジェクト管理者: Diego Garcia Huerta プロジェクトの説明: 設定された装飾、ルック開発、ライティング、およびレンダリング用の完全にインタラクティブな CG ツールセット Clarisse iFX 用の Flow Production Tracking エンジン。                    tk-natron      プロジェクト URL: https://github.com/diegogarciahuerta/tk-natron プロジェクト投稿者: Factor64 プロジェクト管理者: Diego Garcia Huerta プロジェクトの説明: ノードをベースとする無償のオープンソース ソフトウェア アプリケーション Natron 用の Flow Production Tracking エンジン。                    tk-harmony      プロジェクト URL: https://github.com/diegogarciahuerta/tk-harmony プロジェクト投稿者: Factor64 プロジェクト管理者: Diego Garcia Huerta プロジェクトの説明: 業界をリードするアニメーション制作ソフトウェア Toon Boom Harmony 用の Flow Production Trackingエンジン。                    tk-cinema      プロジェクト URL: https://github.com/mikedatsik/tk-cinema プロジェクト投稿者: Mykhailo Datsyk  プロジェクト管理者: Mykhailo Datsyk  プロジェクトの説明: モデリング、アニメーション、レンダリングのためのデザイナー向けのツールセット Maxon Cinema 4D 用の Flow Production Tracking エンジン。 詳細: Flow Production Trackingコミュニティ フォーラム                    tk-krita      プロジェクト URL: https://github.com/diegogarciahuerta/tk-krita プロジェクト投稿者: Factor64 プロジェクト管理者: Diego Garcia Huerta プロジェクトの説明: デジタル ペインティングと 2D アニメーション向けの無償のオープンソース ラスター グラフィックス エディタである Kriat 用の Flow Production Tracking Engine 詳細: Flow Production Trackingコミュニティ フォーラム                    tk-blender      プロジェクト URL: https://github.com/diegogarciahuerta/tk-blender プロジェクト投稿者: Factor64 プロジェクト管理者: Diego Garcia Huerta プロジェクトの説明: Blender 用の Flow Production Tracking Engine。無償のオープンソース 3D コンピュータ グラフィックス ソフトウェアのツールセットで、アニメーション フィルム、ビジュアル エフェクト、アート、3D プリント モデル、モーション グラフィックス、インタラクティブ 3D アプリケーション、仮想現実(VR)、コンピュータ ゲームなどの作成に使用されます。 詳細: Flow Production Trackingコミュニティ フォーラム      アプリ            統合      エンジン      情報                        tk-maya-playblast      プロジェクト URL: https://github.com/basestudio/tk-maya-playblast   プロジェクト投稿者: BASE Studio   プロジェクト管理者:   プロジェクトの説明: Maya のプレイブラストをパブリッシュするアプリです。https://goo.gl/5oJTv0 を参照                    tk-multi-renderfarm      プロジェクト URL: https://github.com/baitstudio/tk-multi-renderfarm   プロジェクト投稿者: Bait Studio   プロジェクト管理者:   プロジェクトの説明: ファームに作業を送信するアプリです。https://goo.gl/ew6mkD を参照                    tk-shotgun-publishrenders      プロジェクト URL: https://github.com/janimation/tk-shotgun-publishrenders   プロジェクト投稿者:   プロジェクト管理者: Dave Sisk   プロジェクトの説明: このアプリは、既存のパブリッシュ ファイルまたはファイル シーケンスを検出するためにプロジェクトのディレクトリ構造を検索し、パブリッシュ ファイル オブジェクトがまだ存在しない場合は、パブリッシュ ファイルとして Flow Production Tracking にこのオブジェクトを登録します。                    nuke-getShotgunData      プロジェクト URL: https://github.com/RicardoMusch/nuke-getShotgunData   プロジェクト投稿者: Ricardo Musch   プロジェクト管理者: Ricardo Musch    プロジェクトの説明: Flow Production Tracking のデータを Nuke のテキスト ノードに取り込むのは少し厄介です。このノードは、スレート内のパイプやバーンインなど、さまざまな場所で使用できます。                    sb-shotgun-schema-introspection      プロジェクト URL: https://github.com/scottb08/sb-shotgun-schema-introspection   プロジェクト投稿者: Scott Ballard   プロジェクト管理者: Scott Ballard    プロジェクトの説明: Flow Production Tracking および Toolkit の開発者が Flow Production Tracking エンティティ、フィールド、および基盤となるスキーマに素早く移動して検査できるようにする、シンプルな Toolkit アプリです。                    foto-multi-namingconvention      プロジェクト URL: https://github.com/scottb08/foto-multi-namingconvention   プロジェクト投稿者: Griffith Observatory   プロジェクト管理者: Scott Ballard   プロジェクトの説明: Flow Production Tracking および Toolkit の開発者が Flow Production Tracking エンティティ、フィールド、および基盤となるスキーマに素早く移動して検査できるようにする、シンプルな Toolkit アプリです。                    tk-cpenv      プロジェクト URL: https://github.com/cpenv/tk-cpenv   プロジェクト投稿者: Dan Bradham   プロジェクト管理者: Dan Bradham   プロジェクトの説明: このアプリは、ソフトウェア プラグイン、プロジェクトの依存関係、環境変数を管理するモジュールを使用する cpiv ツールのサポートを追加します。   詳細: Flow Production Trackingコミュニティ フォーラム                    rtm-tk-hiero-shotgunDropper      プロジェクト URL: https://github.com/RicardoMusch/rtm-tk-hiero-shotgunDropper プロジェクト投稿者: Ricardo Musch プロジェクト管理者: Ricardo Musch  プロジェクトの説明: このアプリを使用すると、Flow Production Tracking から Hiero にバージョンとプレイリストをドロップできます。 詳細: Flow Production Trackingコミュニティ フォーラム      ",
    "url": "/58a557ee/",
    "relUrl": "/58a557ee/"
  },
  "22": {
    "id": "22",
    "title": "設定のステージングとロールアウト",
    "content": "設定のステージングとロールアウトこのドキュメントでは、プロダクション パイプラインに変更を安全に展開する方法に関するベスト プラクティスについて説明します。運用環境のコピーであるステージングのサンドボックスを作成する方法、このサンドボックスを更新する方法、テスト方法、最後に運用環境に変更を反映する方法について説明します。このドキュメントは、Toolkit の設定を管理するユーザのみが使用可能な機能について説明します。既定の設定については、『Flow Production Tracking統合管理者ガイド』を参照してください。はじめにこのドキュメントでは、Toolkit 設定を管理する方法について説明します。Toolkit には複数のユーティリティとツールが装備されているため、環境設定を管理し、安全なサンドボックス環境でアップグレードと変更をテストしてから、それらをプロダクション環境全体に適用できます。このドキュメントでは、以下の方法について説明します。  Toolkit Core API の安全なアップグレード方法  アプリとエンジンの更新方法  複数のプロジェクト間で設定を管理するためのさまざまな方法  プロダクションを中断せずにアップグレードと変更を安全にテストできるように、Toolkit の クローン 機能と プッシュ 機能にアクセスする方法  git ソース コントロールと Toolkit の連携方法設定管理の基本各 Toolkit プロジェクトには関連する 1 つ以上の環境設定があります。環境設定には、ファイル システムの場所(テンプレート)やエンジン アプリなど、プロジェクトで必要になるすべての設定が含まれています。Toolkit では各プロジェクトを個別に設定できます。つまり、異なるプロジェクトが安全に共存でき、あるプロジェクトをアップグレードしても他のプロジェクトには影響しないということです。大量のプロジェクトを作業していると、プロセスが複雑になることがありますが、このプロセスを簡単かつ安全に合理化できるいくつかの方法を用意しています。Flow Production Tracking の各プロジェクトには多くのパイプライン設定があります。プロジェクトを初めて Toolkit でセットアップする場合、primary と呼ばれるパイプライン設定が作成されます。Flow Production Tracking のパイプライン設定エンティティは、Toolkit 設定が格納されているディスク上の場所をポイントしています。多くの場合、プロジェクトの過程で環境設定に変更を加える必要があります。環境設定を調整したり、他のアプリやエンジンを追加したりする必要があります。また、新しいアプリ バージョンが頻繁にリリースされるため、できるだけ最新バージョンを使用することをお勧めします。primary プロジェクト設定は簡単にアップグレードできますが、これにはリスクがあります。この設定はプロジェクトのすべてのユーザが使用するため、問題が発生すると、すべてのユーザに影響を与えてしまいます。ある特定のグループのユーザだけがアクセスできるように、個別のバージョンの設定を作成するのが最適です。この安全な環境では、残りの制作環境に影響を与えることなく、アップグレード、設定変更、および開発を行うことができます。変更のテストが完了したら、安全かつ確実に変更をプライマリ環境設定に適用できます。このプロセスは 「クローン作成」 と呼ばれます。自分(および招待したその他のユーザ)のみがクローンにアクセスできるようにプライマリ環境設定のコピーを個別に作成するという操作です。ここでは、安全に変更を追加し、特に問題がなければ、この変更をプライマリ環境設定に適用することができます。環境設定のクローンを作成するToolkit をセットアップしてプロジェクトを設定したら、セットアップは次のようになります。studio インストールにはすべてのプロジェクトの Core API が格納されます。また、この studio の場所には、Toolkit に対応した Flow Production Tracking プロジェクトへのアクセスに使用できる tank コマンドと Toolkit Python API も含まれます。これに加え、各プロジェクトの設定フォルダもあります。このフォルダには当該プロジェクトのすべての設定が含まれます。この設定で特別に動作する tank コマンド(および Python API)も含まれます。この tank コマンドまたは API コードを使用している場合は、この設定のみを操作できます。新しいプロジェクトをセットアップすると、「 プライマリ 環境設定」が作成されます。これは Toolkit がプロジェクトに既定で使用する環境設定です。このプライマリ環境設定に加えて、プロジェクトに追加の環境設定を作成できます。これらの環境設定は共存でき、チーム全体に影響を与えずに、変更のテスト、アプリのアップグレード、または開発などを少しずつ個別に行う場合に役立ちます。追加の環境設定は、 クローン 作成と呼ばれる設定を新しい場所にコピーするプロセスによって作成されます。環境設定のクローンが作成されると、セットアップは次のように表示されます。スタジオ レベルの tank コマンドとプライマリ プロジェクト設定の tank コマンドに加えて、独自の tank コマンドを持つ新しいパイプライン設定を使用できるようになりました。この tank コマンドを実行すると、ステージング サンドボックスに格納された環境設定のみを操作できます。Maya のいくつかの新しい機能をテストする場合、クローン作成したサンドボックスにアクセスするだけです。./tank Shot xyz launch_maya を実行すると、Maya に表示される Flow Production Tracking メニューには、プライマリ環境設定ではなくステージング サンドボックス内の環境設定が反映されます。スタジオ レベルの tank コマンドは常にプライマリ環境設定を使用するため、クローン作成した環境設定にアクセスする唯一の方法は、その場所にアクセスして、そのフォルダに格納された tank コマンドを使用することです。Flow Production Tracking では、パイプライン設定のエントリに特定のユーザ セットを割り当てることができます。環境設定に関連付けられたユーザは、プライマリ設定のメニューに加えて、新しいメニュー エントリが表示されます。クローン作成した環境設定を作成するアップグレードを安全にテストできるステージング サンドボックスを作成するために、Flow Production Tracking でプロジェクトのパイプライン設定にアクセスし、プライマリ環境設定を右クリックします。設定のクローンを作成するためのオプションが表示されます。このオプションをクリックすると、この新しい環境設定を格納するディスク上のパスを指定するためのダイアログが表示されます。マルチ OS セットアップを実行している場合は、関連するすべてのプラットフォームにパスを入力してください。[OK]をクリックすると、Toolkit は設定をコピーしてクローンをセットアップします。また、クローンを作成したらすぐに Flow Production Tracking ユーザとこの設定が関連付けられるため、Flow Production Tracking 内に新しいメニュー項目が表示されます。ステージング サンドボックスの変更をプライマリに適用する関連する更新を適用して必要なテストを実行したら、tank push_configuration コマンドを実行してプロダクション環境に変更を反映することができます。これにより、ステージング サンドボックスで加えたすべての変更がプライマリ環境設定に転送されます。現在の環境設定は、push_configuration コマンドを実行するバックアップ フォルダに移動されます。間違って適用した場合、または適用に問題が発生した場合は、バックアップ フォルダ内のコンテンツを選択し、設定フォルダにコピーするだけでロールバックできます。既定では、このコマンドはファイル コレクションを対象のパイプライン設定の config フォルダにコピーします。UNIX を使用しており、詳細なアトミック更新が必要な場合は、push_configuration コマンドに --symlink フラグを追加することができます。これにより、対象のパイプライン設定の config フォルダがシンボリック リンクに変換されるため、現在実行中のセッションと設定の不一致が発生するリスクがなく、簡単にアップグレードできます。クローン作成した古い環境設定を更新する以前の開発サンドボックスまたはステージング サンドボックスをセットアップしているが、それが古いためそのコンテンツと最新のプロダクション環境を同期する必要がある場合は、プライマリ環境設定で push_configuration コマンドを実行します。tank push_configurationWelcome to the Flow Production Tracking Toolkit!For documentation, see https://developer.shotgridsoftware.comStarting Toolkit for your current directory '/tmp'- Using configuration 'Primary' and Core v0.14.52- Setting the Context to Empty Context.- Running command push_configuration...----------------------------------------------------------------------Command: Push configuration----------------------------------------------------------------------This command will push the configuration in the current pipeline configuration('Primary') to another pipeline configuration in the project.Your existing configuration will be backed up.The following pipeline configurations are available to push to: - [324] Staging Sandbox (/my/staging/sandbox)Please type in the id of the configuration to push to (ENTER to exit): 324Hold on, pushing config...Checking if there are any apps that need downloading...Push Complete!Your old configuration has been backed up into the following folder:/my/staging/sandbox/config.bak.20140108_093218プライマリ プロジェクト設定からステージング サンドボックスに適用する方法にご注目ください。プライマリ 環境設定の tank コマンドを実行しています。複数のサンドボックスをセットアップしている場合は、サンドボックス間にデータを適用することもできます。クローン作成した環境設定を削除するクローン作成した環境設定を削除する場合は、Flow Production Tracking のエントリを削除してディスクからフォルダを削除するだけです。最新のアプリとエンジンを取得するステージング サンドボックス(または他の環境設定)内で、利用可能なアプリ更新を確認するために tank updates コマンドを実行できます。このコマンドには、環境設定の特定の領域を確認する場合にのみ使用できる基本的なフィルタがあります。----------------------------------------------------------------------Command: Updates----------------------------------------------------------------------This command will go through your current configuration and check if there areany updates available. If there are updates, you will be asked if you want toperform an upgrade. If settings has been added to the new version that you areinstalling, you may be prompted to specified values for these.Running this command with no parameters will check all environments, enginesand app. This may take a long time. You can also run the updater on a subsetof your installed apps and engines.General syntax:&amp;gt; tank updates [environment_name] [engine_name] [app_name]The special keyword ALL can be used to denote all items in a category.Examples:Check everything:&amp;gt; tank updatesCheck the Shot environment:&amp;gt; tank updates ShotCheck all maya apps in all environments:&amp;gt; tank updates ALL tk-mayaCheck all maya apps in the Shot environment:&amp;gt; tank updates Shot tk-mayaMake sure the loader app is up to date everywhere:&amp;gt; tank updates ALL ALL tk-multi-loaderMake sure the loader app is up to date in maya:&amp;gt; tank updates ALL tk-maya tk-multi-loaderToolkit Core API をアップグレードするこのセクションでは、クローンのステージング サンドボックス設定を使用して Toolkit Core API を安全にアップグレードする方法について説明します。ステージング サンドボックスをまだ準備していない場合は、前のセクションの手順に従ってください。ステージング サンドボックスのクローンが共有スタジオ Core API を使用してパイプライン設定から作成された場合は、固有の Core API コードを使用するようにサンドボックスを更新することができます。これはコアの「ローカライズ」と呼ばれ、ステージング サンドボックスにアクセスして tank localize を実行します。このコマンドにより、スタジオ インストールからサンドボックスに Core API がコピーされるため、後で Core API の別のバージョンを実行およびテストすることができます。Toolkit の既定の動作は、コアを既定でローカライズすることです。事前に共有スタジオ コアを明示的に作成していない場合は、コアが既にローカライズされていると見なした方が間違いありません。cd /my/staging/sandbox./tank localizeWelcome to the Flow Production Tracking Toolkit!For documentation, see https://developer.shotgridsoftware.comStarting Toolkit for your current directory '/my/staging/sandbox'- Using configuration 'Staging Sandbox' and Core v0.14.52- Setting the Context to Empty Context.- Running command localize...----------------------------------------------------------------------Command: Localize----------------------------------------------------------------------This will copy the Core API in /mnt/software/shotgun/studio into the Pipelineconfiguration /my/staging/sandbox.Do you want to proceed [yn]yLocalizing Core: /mnt/software/shotgun/studio/install/core -&amp;gt; /my/staging/sandbox/install/coreCopying Core Configuration Files...Localizing Apps: /mnt/software/shotgun/studio/install/apps -&amp;gt; /my/staging/sandbox/install/appsLocalizing Engines: /mnt/software/shotgun/studio/install/engines -&amp;gt; /my/staging/sandbox/install/enginesLocalizing Frameworks: /mnt/software/shotgun/studio/install/frameworks -&amp;gt; /my/staging/sandbox/install/frameworksThe Core API was successfully localized.Localize complete! This pipeline configuration now has an independent API.If you upgrade the API for this configuration (using the 'tank core' command),no other configurations or projects will be affected.Core API をスタジオの場所で共有しなくなりますが、独自のバージョンを実行しています。ここで、ローカルの Tank コマンドを再び使用して、標準的な Core API アップグレードを実行することができます。cd /my/staging/sandbox./tank coreToolkit は新しいバージョンが利用可能かどうかを確認して、ダウンロードとインストールを通知します。Core API を更新したら、このインストールを必ずテストしてください。サンドボックスで tank コマンドを使用するか、Flow Production Tracking の特別なメニュー項目を使用して、いくつかのアプリを起動します。パイプラインの概要を確認し、必要に応じてテストを実行します。最後に、問題がなければ、スタジオ バージョンの Core API を更新します。一般的な Toolkit のセットアップでは、Core API はすべてのプロジェクト間で共有されるため、スタジオの場所にある tank コマンドの tank core コマンドを実行すると、すべてのプロジェクトの Core API が更新されます。プロジェクト ライフサイクルを管理する各 Toolkit プロジェクトには、当該プロジェクトのすべての設定を保持する独立した環境設定が含まれます。多くのプロジェクトを管理している場合は、多くの環境設定を管理する必要があることを意味します。このため Toolkit には、個別のプロジェクト向け、およびスタジオのライフサイクルと環境設定の発展向けに環境設定を扱うさまざまなツールと方法があります。このセクションでは、いくつかのベスト プラクティスを紹介し、環境設定のセットアップ方法に関する実際の手順について説明します。スタジオのニーズに応じて、さまざまなレベルの複雑性に分けられる場合があります。Toolkit には 3 つの異なる手法があるため、それぞれについて詳細に説明します。  最も簡単な方法は、新しいプロジェクトをセットアップするときに以前のプロジェクトから環境設定をコピーすることです。これは小規模なスタジオでプロジェクトの量が少ない場合に最適です。  プロジェクトの数が多く、同時に複数のプロジェクトを実行している場合、次のレベルの統合として、git バージョン コントロールをお勧めします。Toolkit は git をネイティブでサポートしており、git ベースのワークフローを実行すると、スタジオの環境設定を 1 つにまとめられ、その後この設定に加えたすべての変更がトラックされます。各プロジェクトは、必要に応じて環境設定の変更を安全に取り込むことができます。  大規模な設備を稼働している場合は、1 つの環境設定がスタジオ内で現在アクティブなすべてのプロジェクトに直接接続されるようなセットアップを検討してもよいかもしれません。環境設定に 1 箇所変更を加えると、すべてのプロジェクトに即座に影響します。次のセクションでは、さまざまな方法を詳細に説明します。以前のプロジェクトの環境設定を継承するこれは最も簡単な環境設定の管理方法です。Toolkit で最初にプロジェクトをセットアップする場合、既定の環境設定をダウンロードします。パイプライン設定やファイル システムの場所などが一致するように最初のプロジェクトをセットアップします。プロジェクトの実行中、実行しているアプリ バージョンを更新するには、tank updates などのコマンドを実行します。2 つ目のプロジェクトの場合、既定の環境設定を使用して開始しないときは、プロジェクト セットアップ手順で、新しいプロジェクトのスターターとして最初のプロジェクトの環境設定を選択します。つまり、最初のプロジェクトで実行したすべての変更、調整、および改良が、2 つ目のプロジェクトにも適用されます。3 つ目のプロジェクトの場合は 2 つ目のプロジェクトの環境設定を使用する、というように続きます。これは、時間の経過とともに環境設定を徐々に発展させることができる、非常に簡単な方法です。変更と改良は、その場その場でプロジェクトからプロジェクトへと受け継がれていきます。初めて setup_project コマンドを実行したとき、セットアップ プロセスで使用する環境設定の指定を求められたら[Enter]キーを押します。これで既定の環境設定のダウンロードおよびインストールが行われます。2 つ目のプロジェクトの場合、以前のプロジェクトの環境設定へのパスのリストが表示されます。これらのいずれかのパスを選択し、セットアップ プロセスで環境設定の指定を求められたら[Enter]キーを押します。これで新しいプロジェクトにこの環境設定がコピーされます。Welcome to the Flow Production Tracking Toolkit!For documentation, see https://developer.shotgridsoftware.com- Running command setup_project...----------------------------------------------------------------------Command: Setup project----------------------------------------------------------------------Welcome to the Flow Production Tracking Toolkit Project Setup!Connecting to Flow Production Tracking...Connecting to the App Store...------------------------------------------------------------------Which configuration would you like to associate with this project?You can use the configuration from an existing project as a template for thisnew project. All settings, apps and folder configuration settings will becopied over to your new project. The following configurations were found:   My very first project: '/mnt/software/shotgun/first_project/config'If you want to use any of the configs listed about for your new project, justtype in its path when prompted below.You can use the Default Configuration for your new project.  The defaultconfiguration is a good sample config, demonstrating a typical basic setup ofthe Flow Production Tracking Toolkit using the latest apps and engines. This will beused by default if you just hit enter below.If you have a configuration stored somewhere on disk, you can enter the pathto this config and it will be used for the new project.You can also enter an url pointing to a git repository. Toolkit will thenclone this repository and base the config on its content.[tk-config-default]: /mnt/software/shotgun/first_project/configgit ソース コントロールでのスタジオ設定最初の方法には制限事項があります。プロジェクト同士の接続は行われません。10 個のプロジェクトがあり、重要なバグ修正がリリースされたためすべてを更新する必要がある場合、各プロジェクトに手動でアクセスして tank updates コマンドを実行する必要があります。この問題を解決するには、マスター環境設定を作成して git ソース コントロールに保存する方法があります。新しいプロジェクトを作成した場合は、セットアップ プロジェクト ダイアログでこの git リポジトリへのパスを入力するだけで、Toolkit がクローンを作成してくれます。これですべてのプロジェクトが同じ「スタジオ マスター」環境設定に接続されます。プロジェクト設定にいくつかの適切な変更を加えた場合は、その変更をコミットしてスタジオ マスターに適用することができます。その後、他のプロジェクトはこの変更を簡単に取り込むことができます。また、git を使用してすべての変更履歴を保持することもできます。git とは基本的には、git 設定を保持する git リポジトリをセットアップするという考え方です。tank setup_project を実行する場合、このリポジトリに git URL を指定します(username@someserver.com:/studio_config.git など)。セットアップ プロセスでは、新しいプロジェクトがメインのスタジオ リポジトリに接続されたリポジトリになるようにリポジトリのクローンを作成します。接続後は、変更を適用および取得し、微調整のためにブランチで作業できます。スタジオの設定リポジトリをセットアップする何か操作する前に、スタジオの設定リポジトリを作成する必要があります。このセクションでは、既存の Toolkit 設定を取得してこの設定から git リポジトリを作成する方法について説明します。最初に git サーバにアクセスしてリポジトリを作成します。このプロセスは、設定によって異なる場合があります。GitHub などを使用している場合は、Web ブラウザを起動して github.com にアクセスします。サーバにアクセスできる場合は、git init --bare のようなコードを実行できます。ここで作成する git リポジトリは username@someserver.com:/studio_config.gitと呼ばれます。これで、リポジトリのシード設定に使用するプロジェクトの config フォルダを config.bak の場所に移動します。cd /project_configs/studio_configmv config config.bakスタジオ設定のベースにするプロジェクトの config の場所に初期化した git リポジトリのクローンを作成します。クローン作成コマンドを実行したら、git リポジトリにもなる空の config folder が作成されます。cd /project_configs/studio_configgit clone username@someserver.com:/studio_config.git configconfig.bak の場所から config フォルダにすべてのファイルをコピーします。完了したら、空の config.bak フォルダは削除できます。設定ファイルが git リポジトリ内に格納されるため、サーバに対してそのファイルの追加、コミット、および適用を実行する必要があります。その前に、Toolkit のいくつかのシステム ファイルを正しく処理するために下準備を実行する必要があります。config フォルダで .gitignore ファイルを作成し、以下の行を追加します。install_location.ymlpipeline_configuration.ymlこれで git はこれら 2 つのシステム ファイルを無視します。次に進んで残りのファイルを環境設定に追加し、コミットしてスタジオ リポジトリに適用します。git add --allgit commit -am &quot;initial commit of our studio config!&quot;git pushgit で新しいプロジェクトを作成する新しいプロジェクトを作成する場合は、セットアップ プロセスで使用する環境設定のパスの入力を求めるプロンプトが表示されたときに有効な git URL を指定するだけです。上記の例では、username@someserver.com:/studio_config.git と入力します。プロジェクト セットアップ プロセスの一環として、Toolkit は新しいプロジェクト設定の config フォルダにこのリポジトリのクローンを作成します。つまり、後でこの設定フォルダにアクセスし、git コマンドを実行できるということです。クローン作成されたパイプライン設定も git リポジトリのクローンを作成し、シームレスに動作します。プロジェクトに変更を加えるプライマリ設定を変更する場合は、config フォルダにアクセスし、git diff、git commit、および git push を実行するだけです。これにより、プロジェクト設定のクローン作成元のスタジオ設定に変更が適用されます。プロジェクトを最新バージョンに更新するスタジオ レベルの環境設定を更新していくつか変更し、この変更をプロジェクトに取り込む場合は、config フォルダにアクセスして git pull を実行するだけです。重要: 実行が終了したら、変更した環境設定に必要なすべてのアプリ バージョンがシステムに表示されるように tank cache_apps を実行してください。git の高度な利用方法: ブランチToolkit の既定の動作として、新しいプロジェクトの作成時に単純なクローン操作が実行されます。プロジェクトには git master ブランチを使用します。高度なセットアップでは、プロジェクトのプライベートに特定の設定の変更を保存し、他のプロジェクトとその変更を共有しない場合など、プロジェクトの作成後に git ブランチをセットアップできます。その後、このブランチにコミットします。スタジオ設定に適用する変更は、プロジェクトのローカル マスター ブランチと統合してから適用することができます。git の高度な利用方法: バッチ展開Toolkit はパイプライン設定エンティティを介して Flow Production Tracking サイト向けの異なる環境設定すべてのリストを保持するため、このリストを繰り返して処理し、各項目に git pull コマンドを実行して、すべてのプロジェクトでバッチ更新を効率的に実行できます。この機能は、現在 Toolkit に組み込まれているものではありませんが、Python および Flow Production Tracking Python API を使用してスクリプト化することができます。インクルードを使用したグローバル設定上記の git ベースの方法では、git を介して接続された個別のプロジェクト設定を処理します。更新はプロジェクト全体に自動的に反映されないため、取り込んで適用する必要があります。完全な一括管理の場合、環境設定は必ず 1 つの場所に格納され、1 つの変更がプロジェクトのグループにすぐに反映されるため、Toolkit 設定の @include 機能を使用する必要があります。これにより、各プロジェクト設定で実際の環境設定が格納されている一元的な場所をポイントするようにリファレンスを作成することができます。@include 構文を使用すると、複数のファイルを 1 つに連結できます。たとえば、ファイル /tmp/stuff.yml を使用する場合は、次のコンテンツが含まれます。# paths to mayamaya_windows: 'C: Program  Files Autodesk Maya2012 bin maya.exe'maya_mac: '/Applications/Autodesk/maya2012/Maya.app'maya_linux: 'maya'# a configured toolkit appfile_manager:  allow_task_creation: true  file_extensions: []  hook_copy_file: default  hook_filter_publishes: default  hook_filter_work_files: default  hook_scene_operation: default  launch_at_startup: false  launch_change_work_area_at_startup: false  location: {name: tk-multi-workfiles, type: app_store, version: v0.4.8}  saveas_default_name: scene  saveas_prefer_version_up: false  sg_entity_type_filters: {}  sg_entity_types: [Shot, Asset]  task_extra_display_fields: []  template_publish: null  template_publish_area: null  template_work: null  template_work_area: null上記のとおり、複数の異なるレベルでインクルードの定義を作成できます。上の例ではアプリの定義を 1 つと文字列の値を 3 つ設定しています。これらは環境ファイルから参照できます。includes: ['/tmp/stuff.yml']engines:  tk-maya:    # First all our app definitions    apps:        # normally, we would have the entire set of configuration parameters at this point.        # because we are using an include, we can reference an entire sub-section of configuration        # using the @ keyword:        tk-multi-workfiles: '@file_manager'        # alternatively, for simple values, we can use them as parameter values for apps:        tk-maya-launcher:          mac_path: '@maya_mac'          linux_path: '@maya_linux'          windows_path: '@maya_windows'          location: {name: tk-multi-launchapp, type: app_store, version: v0.2.19}    # and after the apps section follows specific configuration options for the engine    location: {name: tk-maya, type: app_store, version: v0.4.1}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: Flow Production Tracking File Manager...}    template_project: null    use_sgtk_as_menu_name: falseさらに、複数のインクルード ファイルを相互に読み取ることができます。同じインクルード定義が 2 つの異なるファイルに存在する場合は、最新の読み込みファイルが優先されます。上記の環境例は、次のように拡張できます。includes:    # first include a global config file which contains all the studio level app definitions    - '/studio/configurations/studio_apps.yml'    # now we can include an include containing overrides, for example based on project type.    # if the global config contains an entry named file_manager and the vfx_apps.yml contains    # the same, the vfx_apps definition will be used.    - '/studio/configurations/vfx_apps.yml'engines:  tk-maya:        apps:        tk-multi-workfiles: '@file_manager'    location: {name: tk-maya, type: app_store, version: v0.4.1}    use_sgtk_as_menu_name: false上記の方法を使用すると、スタジオの既定値セットを指定し、それをプロジェクト タイプの既定値によってオーバーライドして、さらにそれを特定のプロジェクト設定でオーバーライドできます。 上記の例で示すようにアプリ レベルで実行したり、または次のセクションに示すようにエンジン レベルで実行したりできます。グローバル設定のセットアップ時のベスト プラクティスグローバル設定にはいくつかのセットアップ方法があります。セットアップの推奨ベスト プラクティスでは、エンジンごとに環境設定を分割します。各環境ファイルは完全に空で、個別のファイルで定義されるエンジン(およびアプリ)を参照します。これにより、エンジンを 1 つずつ簡単に調整および再設定できます。このインクルード ファイルは標準的な形式で、エンジンに基づいた名前がそれぞれのファイルに付けられます。たとえば、Maya エンジンを使用する場合、インクルード ファイルにはエンジンとそのアプリのみが含まれます。その上位エントリには maya という名前だけが付けられます。maya:    apps:      tk-maya-breakdown:        hook_multi_update: default        hook_scan_scene: default        location: {name: tk-maya-breakdown, type: app_store, version: v0.2.13}      tk-multi-loader2:        action_mappings:          Maya Scene: [reference, import]          Photoshop Image: [texture_node]          Rendered Image: [texture_node]        actions_hook: '{self}/tk-maya_actions.py'        entities:        - caption: Assets          entity_type: Asset          filters:          - [project, is, '{context.project}']          hierarchy: [sg_asset_type, code]        filter_publishes_hook: '{self}/filter_publishes.py'        location: {name: tk-multi-loader2, type: app_store, version: v1.0.6}        menu_name: Load        publish_filters: []        title_name: Loader      [... additional app entries here ...]    debug_logging: true    location: {name: tk-maya, type: app_store, version: v0.3.10}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: Flow Production Tracking File Manager...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}    - {app_instance: tk-multi-workfiles, name: Flow Production Tracking Save As...}    - {app_instance: tk-multi-publish, name: Publish...}    template_project: shot_work_area_maya    use_sgtk_as_menu_name: false# each include file has a framworks section containing all the frameworks needed for# all apps in the fileframeworks:  tk-framework-shotgunutils_v1.x.x:    location: {name: tk-framework-shotgunutils, type: app_store, version: v1.0.8}スタジオで Maya のみをセットアップすることはほとんどなく、さまざまな部門やタイプで異なるアプリを多数使用しているかと思います。それぞれに対して Maya インクルード ファイルをセットアップして、ファイル階層で整理することをお勧めします。これらの各ファイルでは、上記のファイルのように上位エントリとして maya が指定されます。各プロジェクトには数多くの環境ファイルが含まれています。この環境ファイルはそれぞれエンジンのインクルードのリストで、この特定の環境とエンジンやアプリの一連のセットアップを関連付けています。スタジオで 1 つ(または複数)の既定のプロジェクト設定をセットアップすると、すべてにインクルードがこのように含まれるため、実際のアプリとエンジンのペイロードがインクルード ファイル内に完全に含まれ、グローバル ファイル内にも含まれます。グローバル インクルード ファイルに変更を加えると、すべてのプロジェクトに影響します。このセットアップを使用すると、環境ファイルは次のような形式になります。includes:         - '/studio/configurations/maya/asset.yml'    - '/studio/configurations/nuke/asset.yml'    - '/studio/configurations/houdini/generic.yml'engines:  tk-maya: '@maya'  tk-nuke: '@nuke'  tk-houdini: '@houdini'# we don't need any frameworks here because there are no apps or engines definedframeworks: null上記のセットアップを分割し、いくつかのプロジェクト固有のエントリを定義する場合は、環境ファイル自身で @maya をアプリとエンジンの一連の定義で置き換えるだけです。グローバル設定を管理するグローバル設定の管理は通常の設定の管理よりも複雑です。多数のプロジェクトを効果的に組み合わせて 1 つのファイル構造に統合しているため、プロジェクトから tank updates コマンドを実行し、アプリ バージョンを更新すると、他のすべてのプロジェクトに影響します。ここに記載された注意を参考にして作業を進めてください。さらに、クローン作成の対象はプロジェクト設定であり、これにはインクルードしか含まれていないため、標準的なクローン作成ワークフローをすぐに使用することはできません。安全なテストとメンテナンスのために、ソース コントロール(git など)にグローバル設定を保存して、特別なテスト プロジェクトの個別のテスト領域で更新することをお勧めします。品質管理上問題がなければ、変更を確定し、実際のグローバル設定に取り込みます。",
    "url": "/60762324/",
    "relUrl": "/60762324/"
  },
  "23": {
    "id": "23",
    "title": "Configurations does not point to a valid bundle on disk!",
    "content": "Configurations does not point to a valid bundle on disk!使用例Flow Production Tracking Toolkit を初めてインストールするときに、プロジェクトを開くと、ファイル パスの後にこのエラーが表示されることがあります。修正方法プロジェクトのパイプライン設定エンティティが、Windows の設定のパス ... Flow Production Tracking Configurations を指しています。これが正しいパスでない可能性があるため、最初の手順として、このパスが存在することを確認するか、パスを修正してください。また、このパスの場所にアクセスできない一元管理セットアップからアクセスしようとしている可能性もあります。この場合は、分散セットアップに切り替えると便利です。関連リンクコミュニティの完全なスレッドを参照してください。",
    "url": "/84bb455b/",
    "relUrl": "/84bb455b/"
  },
  "24": {
    "id": "24",
    "title": "Connecting Your Studio With Your AWS VPC",
    "content": "Connecting Your Studio With Your AWS VPCYou can connect your studio networks with AWS using one of many options, described in detail in this Amazon Virtual Private Cloud Connectivity Options whitepaper.Some of the common options our clients have used include:VPN ConnectionUsing a VPN appliance - AWS-managed or client-managed - your studio can establish a secure connection between your data center (or offices) to your AWS private VPC.AWS Direct ConnectAWS Direct Connect creates a dedicated link between your studio and your AWS VPC. This will help segregate your studio’s network traffic to your private AWS VPC from general internet traffic.",
    "url": "/de0ef1a3/",
    "relUrl": "/de0ef1a3/"
  },
  "25": {
    "id": "25",
    "title": "タスク/ステップがファイル名の一部としては存在しているのにコンテキストで見つからないのはなぜですか?",
    "content": "タスク/ステップがファイル名の一部としては存在しているのにコンテキストで見つからないのはなぜですか?Toolkit でフォルダを作成すると、エンティティに対するパスが登録され、検索を実行できるようになります。これは、パスを指定することによって正しいコンテキストを決定できることを意味します。Toolkit はスキーマから生成されたフォルダに対してのみレジストリを作成するので、templates.yml ファイルでのみ定義されているファイル名やフォルダを考慮しません。スキーマに Task フォルダがない場合、Toolkit がファイルのタスクを知る必要があっても、パスだけではタスクを解決できない状況になる可能性があります。例次の既定のスキーマ構造を取ります。Asset および Step フォルダはフォルダ作成プロセス中に登録されます。次のようなテンプレートを使用してファイル パスを生成した場合:assets/{sg_asset_type}/{Asset}/{Step}/work/maya/{task_name}_{name}.v{version}.{maya_extension}`生成されたパスからコンテキストを見つけようとすると、タスクの名前がファイル パスにあるにもかかわらず、確立できるのは Asset と Step のみで、Taskを確立することはできません。解決策ほとんどのワークフローでは、スキーマに Step フォルダがあり、Task フォルダがないことは問題ありません。通常は、Workfiles アプリを使用して、実行するタスクを選択してからファイルを選択し、シーン ファイルを開きます。UI で選択したタスクは、開いたファイルのパスからコンテキストを把握しようとするのではなく、コンテキストを駆動するために使用されます。ただし、次のような場合は、パスからコンテキストを取得できることが重要になります。  当社の自動コンテキスト切り替え機能を使用する場合。この機能を使用すると、Toolkit はユーザーが(Workfiles アプリを介さずに)ソフトウェアのネイティブの開くダイアログでファイルを開いたことを検出し、それに応じて現在のコンテキストを切り替えることができます。  特定のファイルのコンテキストを知る必要があるスタンドアロン プ​​ロセスで API を使用する場合。このような場合の解決策は、スキーマに Task フォルダを導入するか、自動コンテキスト切り替え機能を使用しないことです。API スクリプトの場合は、プロセスに必要なコンテキスト情報が既に存在し、この検索を実行する必要がないことを確認します。",
    "url": "/a10dadb2/",
    "relUrl": "/a10dadb2/"
  },
  "26": {
    "id": "26",
    "title": "貢献ガイド",
    "content": "貢献ガイド当社では、開発状況を可能な限り公開するための取り組みとして、開発者向けドキュメントを クリエイティブ コモンズ ライセンス の公開リポジトリに作成することを決定しました。このドキュメントをより良いものにするための提案がある場合は、ぜひリポジトリの改善についてのプル リクエストをお送りください。プル リクエストを受け入れるためには、以下のいずれかのコントリビューター契約書に署名していただく必要があります。  個人のコントリビューター契約書  会社のコントリビューター契約書上記のいずれかの契約書を提出していただくと、README の手順に従って変更を提出することができます。",
    "url": "/92b042bd/",
    "relUrl": "/92b042bd/"
  },
  "27": {
    "id": "27",
    "title": "複数のストレージ ルートを使用するように設定を変更するにはどうすればいいですか?",
    "content": "複数のストレージ ルートを使用するように設定を変更するにはどうすればいいですか?既定の設定では、単一のローカル ストレージのルートが使用されます(つまり、すべてのプロジェクト ファイルは /sgtk/projects のような単一のルート ポイントに保存されます)。プロジェクト ファイルの一部を保存する新しいストレージ ルートを追加することができます。これは、ディスク スペースが不足した場合やストレージ メディアを高速化する場合に一般的な方法です。「secondary」という名前の別のルートを追加する場合があるとします。必要な手順は次のとおりです。Flow Production Tracking でローカル ストレージを追加する  Flow Production Tracking で、[管理者] (Admin)&amp;gt; [サイト基本設定] (Site Preferences)ページに移動します  [ファイル管理] (File Management)セクションを開きます  [[+] ローカル ファイル ストレージを追加] ([+] Add Local File Storage)をクリックします  名前(「secondary」)と関連するすべてのプラットフォーム上のストレージ ルートへのパスを入力します。特定のプラットフォームを使用していない場合は、空白のままにすることができます。  ページの上部または下部にある[ページを保存] (Save Page)ボタンをクリックします新しいルートをパイプライン設定に追加するToolkit は、config/core/roots.yml ファイルのパイプライン設定で使用されるローカル ストレージに関する情報をキャッシュします。Flow Production Tracking で作成したばかりの新しい secondary ストレージ ルートを追加するには、このファイルを次のように編集します。primary: {    linux_path: /mnt/hgfs/sgtk/projects,    mac_path: /sgtk/projects,    windows_path: 'z: sgtk projects'}secondary: {    linux_path: /mnt/hgfs/sgtk/secondaries,    mac_path: /sgtk/secondaries,    windows_path: 'z: sgtk secondaries'}                    注: tk-core v0.18.141 までは、roots.yml で定義されているルートの名前は SG で定義されているローカル ストレージの名前と一致する必要はありません。roots.yml 定義に shotgun_storage_id: &amp;lt;id&amp;gt; キー/値ペアを含めることで、接続を明示的に定義できます。例:secondary: {    linux_path: /mnt/hgfs/sgtk/secondaries,    mac_path: /sgtk/secondaries,    windows_path: 'z: sgtk secondaries'    shotgun_storage_id: 123}現在、ストレージ ID を照会するには、API 呼び出しを使用する必要があります。    新しいローカル ストレージ ルートを使用するようにスキーマを修正する新しいストレージ ルートを定義し、Toolkit にそのルートを指定しました。ディレクトリ構造内での使用方法を決める必要があります。ここで、アセットのすべての作業は secondary ストレージに、ショットのすべての作業は primary ストレージに保存されると仮定します。config/core/schema でスキーマを次のようにセットアップできます。config/core/schema/project.yml# the type of dynamic contenttype: &quot;project&quot;# name of project root as defined in roots.ymlroot_name: &quot;primary&quot;config/core/schema/secondary.yml# the type of dynamic contenttype: &quot;project&quot;# name of project root as defined in roots.ymlroot_name: &quot;secondary&quot;フィルタ内のルートを参照するすべての YAML ファイルも修正する必要があります。たとえば、セカンダリ フォルダの下のどこかに asset.yml がある場合は、セカンダリ フォルダの値と照らし合わせてプロジェクトを除外するようにフィルタを更新する必要があります。filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$secondary&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }使用するルートを指定するようにテンプレート パスを更新する最後に、使用するストレージ ルートを指定するように config/core/templates.yml ファイルで定義されたパスを更新1し、必要に応じて他のパスを更新します。テンプレート パスはスキーマと非常に密な関係にあるので、一致させる必要があります。スキーマで定義されたパスと正しく一致しない定義済みテンプレート パスを使用すると、エラーが発生します。たとえば、secondary ストレージのすべてのアセット作業を使用するため、テンプレート パス maya_asset_work を更新するには、次のように修正します。maya_asset_work:    definition: '@asset_root/work/maya/{name}.v{version}.ma'    root_name: 'secondary'config/core/templates.yml ファイル内の各テンプレート パスをこれと同じように修正します。各ストレージ(「primary」または「secondary」)で正しい root_name を指定します。                    注: 既定のストレージルートを使用するテンプレートには root_name を指定する必要はありません。既定のルートは、roots.yml ファイルで default: true を指定することによって示されます。roots.yml で既定値が明示的に定義されていない場合は、ルート primary が既定値と見なされます。    1 新しい値が設定されると、以前の値を使用して作成された古いファイルに Toolkit からアクセスできなくなるため、パスの更新が最適な方法ではない場合があります(テンプレート パスの変更後は Toolkit で古い作業ファイルは表示されません)。これが問題になる場合は、新しい場所を設定した新しいテンプレート(houdini_shot_publish_v2 など)を作成し、この新しいバージョンを使用するようにアプリをアップグレードすることができます。すべてのアプリがこのようなフォールバックの考え方に対応しているわけではありませんが、古いファイルを認識できるアプリもあります。アプリは Flow Production Tracking 内のパブリッシュと常にリンクされているため、これはパブリッシュに影響しません。",
    "url": "/9ea9dd4e/",
    "relUrl": "/9ea9dd4e/"
  },
  "28": {
    "id": "28",
    "title": "Critical! Could not update Flow Production Tracking with folder data.",
    "content": "TankError: Could not create folders on disk. Error reported: Critical! Could not update Flow Production Tracking with folder data.使用例オートデスクでは一元管理設定を使用して、既存のプロジェクトに Linux のサポートを追加していますが、ファイルシステムの設定に問題があります。以下の作業は完了しています。  対応するルートを roots.yml に追加する  パイプライン設定(install_location.yml など)に Linux パスを追加する  ソフトウェア エンティティの Linux パスを追加するFlow Production Tracking Toolkit は正常に起動しますが、プログラムを起動しようとすると、次のように表示されます。TankError: Could not create folders on disk. Error reported: Critical! Could not update Shotgun with folder data. Please contact support. Error details: API batch() request with index 0 failed.  All requests rolled back.API create() CRUD ERROR #6: Create failed for [Attachment]: Path /mnt/cache/btltest3 doesn't match any defined Local Storage.同様に、Tank フォルダやその他のコマンドを実行しようとすると、同じエラーが出力されます。必要なすべての場所に Linux パスが追加されているはずです。データベースの同期に問題があるか確認してください。tank synchronize_folders を実行すると、特に次のように出力されます。  The path is not associated with any Flow Production Tracking object.修正方法サイト基本設定 &amp;gt; ファイル管理で、Flow Production Tracking のローカル ストレージに Linux のパスを追加します。関連リンクコミュニティの完全なスレッドを参照してください。",
    "url": "/904fdaf9/",
    "relUrl": "/904fdaf9/"
  },
  "29": {
    "id": "29",
    "title": "API を使用してパブリッシュを作成するにはどうすればいいですか?",
    "content": "API を使用してパブリッシュを作成するにはどうすればいいですか?オートデスクの sgtk API には、Flow Production Tracking で PublishedFiles エンティティを登録するための便利なメソッドが用意されています。また、独自の API が付属している Publish アプリもあります。Publish API は最終的にコア sgtk API メソッドを使用して PublishedFile を登録しますが、カスマイズ可能な、コレクション、検証、およびパブリッシュに関するフレームワークも用意されています。Publish API ドキュメントだけでなく、パイプライン チュートリアルにも、独自のパブリッシュ プラグインを記述する例が記載されています。register_publish() API メソッドを使用する未処理の Flow Production Tracking API 呼び出しを使用して Flow Production Tracking でパブリッシュ レコードを作成することは可能ですが、Toolkit の便利なメソッドを使用することをお勧めします。パブリッシュを作成する Toolkit アプリはすべて、sgtk.util.register_publish()と呼ばれる API ユーティリティ メソッドを使用しています。基本的に、このメソッドは Flow Production Tracking で新しい PublishedFile エンティティを作成し、ツールキットの概念を使用してその作業を容易にするよう試行します。 以下の行に従ってコードを実行する必要があります。# Get access to the Toolkit APIimport sgtk# this is the file we want to publish.file_to_publish = &quot;/mnt/projects/proj/seq_abc/shot_123/comp/foreground.v034.nk&quot;# alternatively, for file sequences, we can just use# a standard sequence token# file_to_publish = &quot;/mnt/projects/proj/seq_abc/shot_123/comp/renders/v034/foreground.%04d.exr&quot;# The name for the publish should be the filename# without any version number or extensionname = &quot;foreground&quot;# initialize an API object. If you have used the Toolkit folder creation# to create the folders where the published file resides, you can use this path# to construct the API object. Alternatively you can create it from any Flow Production Tracking# entity using the sgtk_from_entity() method.tk = sgtk.sgtk_from_path(file_to_publish)# use the file to extract the context. The context denotes the current work area in Toolkit# and will control which entity and task the publish will be linked up to. If you have used the Toolkit# folder creation to create the folders where the published file resides, you can use this path# to construct the context.ctx = tk.context_from_path(file_to_publish)# alternatively, if the file you are trying to publish is not in a location that is# recognized by toolkit, you could create a context directly from a Flow Production Tracking entity instead:ctx = tk.context_from_entity(&quot;Shot&quot;, 123)ctx = tk.context_from_entity(&quot;Task&quot;, 123)# Finally, run the publish command.# the third parameter (file.nk) is typically the file name, without a version number.# this makes grouping inside of Flow Production Tracking easy. The last parameter is the version number.sgtk.util.register_publish(  tk,  ctx,  file_to_publish,  name,  published_file_type=&quot;Nuke Script&quot;,  version_number=34)上記の基本的なコードに加えて、入力可能なオプションがいくつかあります。パラメータの完全なリストとその機能については、Core API のドキュメントを参照してください。                    ヒント: Toolkit アプリ内からコードを実行している場合は、self.sgtk を介して sgtk インスタンスを、self.context を使用してコンテキストを取得することができます。コードがアプリに含まれていないにもかかわらず、Toolkit 統合が組み込まれているソフトウェア内で実行される場合は、次のコードを使用して現在のコンテキストおよび sgtk インスタンスにアクセスすることができます。import sgtkcurrentEngine = sgtk.platform.current_engine()tk = currentEngine.sgtkctx = currentEngine.context    ",
    "url": "/ed4bcc20/",
    "relUrl": "/ed4bcc20/"
  },
  "30": {
    "id": "30",
    "title": "Linux で Flow Production Tracking Toolkit のデスクトップ/ランチャー アイコンをセットアップするにはどうすればいいですか?",
    "content": "Linux で Flow Production Tracking Toolkit のデスクトップ/ランチャー アイコンをセットアップするにはどうすればいいですか?現在の Flow Production Tracking Toolkit インストーラはショートカットと起動のエントリを自動的に作成しないため、インストール後に手動で作業する必要があります。手順は簡単ですが、使用する Linux の種類によって手順が異なる場合があります。Flow Production Tracking Toolkit インストーラを実行すると、Flow Production Tracking Toolkit の実行可能なファイルは /opt/Shotgun folder 内に格納されます。実行可能ファイルの名前は Flow Production Tracking です。インストーラはアイコンを配置しません。Flow Production Tracking Toolkit エンジンの github リポジトリからダウンロードしてください。アイコンをダウンロードして、実行可能ファイルのパス(/opt/Shotgun/Shotgun)を指定したら、必要なデスクトップまたはメニューのランチャーを手動で作成してください。この操作のプロセスは Linux のバージョンによって異なりますが、通常、Desktop を右クリックして適切なメニュー オプションを選べば、デスクトップ ランチャーを作成できます。",
    "url": "/d82ab5ce/",
    "relUrl": "/d82ab5ce/"
  },
  "31": {
    "id": "31",
    "title": "プロジェクト間のワークフロー",
    "content": "プロジェクト間のワークフローベスト プラクティスFlow Production Tracking のプロジェクト間ワークフローを使用すると、複数のプロジェクトにわたってアセットを再利用、共有、および使用することができます。アセットを再利用する最も一般的な方法は、単一の「アセット ライブラリ」プロジェクトをソース プロジェクトとして使用することです。単一の「ライブラリ」プロジェクトを使用してシンプルに保つことをお勧めしますが、Flow Production Tracking では任意のアクティブなプロジェクト間でアセットをリンクすることもできます。アセットを再利用するには、主に 2 つの方法があります。より迅速なアプローチは、ソースアセットをそのまま再利用することです(直接参照)。ただし、プロジェクトとパイプラインに基づいて制限事項が適用されるため、ソース アセットをプロジェクトにコピーすることもできます(複製またはフォーク)。  直接参照: ソース アセットをそのまま再利用します。アセットが変更された場合は、バージョンを保持するか、最新バージョンに更新することができます。  複製またはフォーク: 別のプロジェクトからソース アセットを読み込んで(ソースへの接続を解除して)、そのソース アセットをベースに構築するか、コントロールを取得して現在のプロジェクトに保存します。プロジェクト間/ライブラリ プロジェクトのワークフローこのチュートリアルでは、Flow Production Tracking Toolkit を使用して複数のプロジェクトでアセットを再利用し、スタジオのアーティストが簡単にアクセスできるアセット ライブラリを構築する方法について説明します。この機能を実行するには、3 つの主要な手順があります。  プロジェクト間でリンクされた Flow Production Tracking アセット: [リンクされたプロジェクト] (Linked Projects)フィールドを使用して、アセットとプロジェクト間をリンクします  アセットをシーンにロード/参照設定する: ローダーのダイナミック タブを使用します  アセットを最新に維持するScene Breakdown アプリを使用します手順 1: アセットをリンクするアセットを再利用するには、まず、ソース アセットを使用する他のプロジェクトを Flow Production Tracking に認識させます。再利用している元のアセットを含むソース プロジェクトから、[アセット] (Assets)ページに移動します。[リンクされたプロジェクト] (Linked Projects)フィールドを[アセット] (Assets)ページに追加します(まだ表示されていない場合)。次に、アセットを再利用するプロジェクトを指定します。**詳細なドキュメントは、こちらから参照してください。手順 2: アセットをロードする[リンクされたプロジェクト] (Linked Projects)フィールドを介してアセットが適切にリンクされると、Loader で単純かつ動的なタブを使用して、リンクされ、再利用されたアセットをスタジオに提供することができます。これにより、アーティストやクリエイティブ チームは、複数のプロジェクトでアセットを簡単に再利用できます。アセットが適切にリンクされたら、以下を実行します。  コンテンツ作成ソフトウェア(Maya、Houdini、Alias など)を起動する  作業シーンを開くか保存してコンテキストを設定する  シーン コンテキストを設定したら、Flow Production Tracking メニューからローダーを起動する  これで、[アセット - リンク済み] (Assets - Linked)タブが表示され、プロジェクト間でアセットのパブリッシュ ファイルにアクセスできるようになります。設定内のローダーにこのタブを追加する詳細な手順については、こちらを参照してください。ここから、コンテンツ作成ソフトウェアのローダー アクションを利用して、読み込み(アセットを複製またはフォークしてソースへの接続を切断する場合)や、アセットの参照(現在のバージョンやこのアセットの後続のすべてのバージョンに継続的に接続する場合)を実行できます。手順 3: これらのアセットを更新するソースへの接続を維持してアセットを参照する場合、そのソース アセットの更新と変更を確認することができます。このシナリオでは、他のチームがソース アセットを繰り返し使用し続ける一方で、最新バージョンが必要になることがよくあります。設定で Scene Breakdown 2 アプリを使用すると、現在シーン内にあるすべてのリファレンス項目を表示できます。これらの参照のいずれかが更新されると、Scene Breakdown は競合を表示し、変更内容に関するパブリッシュ ファイルのノートを共有し、最新バージョンまたはパブリッシュ ファイルの他のバージョンに更新できるようになります。注: アセットの更新は、高度な設定を使用する場合にのみ適用されます。スタジオで基本設定を使用している場合、この Scene Breakdown アプリにアクセスすることはできません。",
    "url": "/0d2b28cd/",
    "relUrl": "/0d2b28cd/"
  },
  "32": {
    "id": "32",
    "title": "カスタム ブラウザ プロトコルを使用してアプリケーションを起動する",
    "content": "カスタム ブラウザ プロトコルを使用してアプリケーションを起動するコンテンツ  プロトコルを登録する          Windows 上でプロトコルを登録する      macOS 上でプロトコルを登録する      Linux 上でプロトコルを登録する      アクション メニュー アイテム(AMI)の極めて実用的な使用方法は、ローカル コンピュータ上でアプリケーションまたはスクリプトを 1 つのバリアントで実行することです。これを機能させるには、ブラウザと実行するスクリプトまたはアプリケーションとの間に接続をセットアップする必要があります。このリンクはカスタム ブラウザ プロトコルと呼ばれます。たとえば、ユーザがクリックすると、[foo]アプリケーションが起動するようなリンクをセットアップするとします。プリフィックスに「http」ではなく、「foo」などのカスタム プロトコルを指定する必要があります。理想的には、次のようなリンクが必要です。foo://some/info/hereオペレーティング システムにはプロトコルの処理方法を通知する必要があります。既定では、「http」は既定の Web ブラウザで処理され、「mailto」は既定のメール クライアントで処理されると、現在のすべてのオペレーティング システムは認識しています。アプリケーションがインストールされると、OS に登録され、特定のプロトコルでそのアプリケーションを起動するよう OS に指示する場合があります。たとえば、RV をインストールした場合、アプリケーションは rvlink:// を OS に登録し、RV がすべての rvlink:// プロトコル要求を処理して RV にイメージまたはシーケンスを表示するように指示します。そのため、ユーザが Flow Production Tracking と同じように rvlink:// で始まるリンクをクリックすると、オペレーティング システムはこのリンクで RV を起動することを認識し、アプリケーションはこのリンクを解析して処理方法を認識できます。RV が URL と「rvlink」プロトコルのプロトコル ハンドラとしてどのように機能するかについては、RV のユーザ マニュアルを参照してください。プロトコルを登録するWindows 上でプロトコルを登録するWindows でプロトコル ハンドラを登録するには、Windows レジストリを変更します。レジストリ キーは一般的に次のようになります。HKEY_CLASSES_ROOTfoo(Default) = &quot;URL:foo Protocol&quot;URL Protocol = &quot;&quot;shellopencommand (Default) = &quot;foo_path&quot; &quot;%1&quot;ターゲット URL は次のようになります。foo://host/path...                    注: 詳細については、http://msdn.microsoft.com/en-us/library/aa767914(VS.85).aspx を参照してください。    Windows QT/QSetting の例開発しているアプリケーションが QT (または PyQT/PySide)フレームワークを使用して記述されている場合は、QSetting オブジェクトを利用してレジストリ キーの作成を管理できます。アプリケーションがレジストリ キーを自動的にセットアップする場合のコードは次のようになります。// cmdLine points to the foo path.//Add foo to the Os protocols and set foobar to handle the protocolQSettings fooKey(&quot;HKEY_CLASSES_ROOT  foo&quot;, QSettings::NativeFormat);mxKey.setValue(&quot;.&quot;, &quot;URL:foo Protocol&quot;);mxKey.setValue(&quot;URL Protocol&quot;, &quot;&quot;);QSettings fooOpenKey(&quot;HKEY_CLASSES_ROOT  foo  shell  open  command&quot;, QSettings::NativeFormat);mxOpenKey.setValue(&quot;.&quot;, cmdLine);Flow Production Tracking AMI を介して Python スクリプトを開始する Windows の例ローカルで動作する AMI の多くは、Python インタプリタを介して単純な Python スクリプトを開始することができます。これにより、単純なスクリプトに加えて、GUI (PyQT、PySide、または選択した GUI フレームワーク)を使用したアプリも実行することができます。この目標のために役立つ実例を見てみましょう。手順 1: カスタム「Flow Production Tracking」プロトコルをセットアップするWindows レジストリ エディターを使用します。[HKEY_CLASSES_ROOT Flow Production Tracking]@=&quot;URL:Flow Production Tracking Protocol&quot;&quot;URL Protocol&quot;=&quot;&quot;[HKEY_CLASSES_ROOT Flow Production Tracking shell][HKEY_CLASSES_ROOT Flow Production Tracking shell open][HKEY_CLASSES_ROOT Flow Production Tracking shell open command]@=&quot;python&quot;&quot;sgTriggerScript.py&quot;&quot;%1&quot;このセットアップでは、最初の引数がスクリプト sgTriggerScript.py で、2 番目の引数が %1 である python インタプリタを起動するための Flow Production Tracking:// プロトコルが登録されます。%1 が、ブラウザでクリックされた URL または呼び出された AMI の URL に置き換えられることを理解することが重要です。これが Python スクリプトの最初の引数になります。                    情報: Python インタプリタと Python スクリプトへのフル パスが必要となる場合があります。適宜調整してください。    手順 2: Python スクリプトで受信 URL を解析するスクリプト内で、指定された最初の引数である URL を取得し、AMI が呼び出されたコンテキストを把握するためにそのコンポーネントまで解析します。次のコードに、これを行う方法を示す簡単なスクリプトの例を示しています。Python スクリプトimport sysimport pprinttry:    from urlparse import parse_qsexcept ImportError:    from urllib.parse import parse_qsdef main(args):    # Make sure we have only one arg, the URL    if len(args) != 1:        sys.exit(&quot;This script requires exactly one argument&quot;)    # Make sure the argument have a : symbol    if args[0].find(&quot;:&quot;) &amp;lt; 0:        sys.exit(&quot;The argument is a url and requires the symbol ':'&quot;)    # Parse the URL    protocol, fullPath = args[0].split(&quot;:&quot;, 1)    # If there is a querystring, parse it    if fullPath.find(&quot;?&quot;) &amp;gt;= 0:        path, fullArgs = fullPath.split(&quot;?&quot;, 1)        action = path.strip(&quot;/&quot;)        params = parse_qs(fullArgs)    else:        action = fullPath.strip(&quot;/&quot;)        params = &quot;&quot;    # This is where you can do something productive based on the params and the    # action value in the URL. For now we'll just print out the contents of the    # parsed URL.    fh = open('output.txt', 'w')    fh.write(pprint.pformat((protocol, action, params)))    fh.close()if __name__ == '__main__':    sys.exit(main(sys.argv[1:])) 注: このスクリプトは、Python 3 および Python 2 と互換性があります。手順 3: Flow Production Tracking インタフェースをカスタム プロトコルと接続し、最終的にスクリプトと接続する最後に、URL 値が Flow Production Tracking になる shotgrid://processVersion の AMI を作成します。この AMI は任意のエンティティ タイプに割り当てることができますが、この例ではバージョン エンティティを使用します。バージョン ページに移動し、バージョンを右クリックして、メニューから AMI を選択します。これにより、ブラウザで shotgrid:// URL が開かれ、登録されたカスタム プロトコルを介してスクリプトにリダイレクトされます。スクリプトと同じフォルダにある output.txt ファイルの内容が、次のようになります。('processVersion', {'cols': ['code',           'image',           'entity',           'sg_status_list',           'user',           'description',           'created_at'],  'column_display_names': ['Version Name',                           'Thumbnail',                           'Link',                           'Status',                           'Artist',                           'Description',                           'Date Created'],  'entity_type': ['Version'],  'ids': ['6933,6934,6935'],  'page_id': ['4606'],  'project_id': ['86'],  'project_name': ['Test'],  'referrer_path': ['/detail/HumanUser/24'],  'selected_ids': ['6934'],  'server_hostname': ['my-site.shotgrid.autodesk.com'],  'session_uuid': ['9676a296-7e16-11e7-8758-0242ac110004'],  'sort_column': ['created_at'],  'sort_direction': ['asc'],  'user_id': ['24'],  'user_login': ['shotgrid_admin'],  'view': ['Default']})考えられるバリエーションAMI で URL の // の後にあるキーワードを変更することで、同じ shotgrid:// プロトコルを維持したままスクリプト内の action 変数の内容を変更し、単一のカスタム プロトコルのみを登録することができます。これにより、action 変数の内容とパラメータの内容に基づいて、スクリプトが意図された動作を把握できます。この方法を使用することで、アプリケーションの起動、FTP などのサービスを介したコンテンツのアップロード、データのアーカイブ、電子メールの送信、または PDF レポートの生成を行うことができます。macOS 上でプロトコルを登録するmacOS BigSur および Monterey でプロトコルを登録するには、アプリケーションまたはスクリプトを実行するように設定された .app バンドルを作成する必要があります。手順 1: AppleScript スクリプト エディタまず、AppleScript スクリプト エディタで次のスクリプトを記述します。on open location this_URL    do shell script &quot;sgTriggerScript.py '&quot; &amp;amp; this_URL &amp;amp; &quot;'&quot;end open location デバッグのヒント: エラーをキャッチしてポップアップに表示すると、エラーをサイレント エラーにせずに Python スクリプトを実行したときに問題が発生したかどうかを確認できます。次に、エラーを試すために AppleScript に追加できるスニペットの例を示します。on open location this_URL	try		do shell script &quot;/path/to/script.py '&quot; &amp;amp; this_URL &amp;amp; &quot;'&quot;	on error errStr		display dialog &quot;error&quot; &amp;amp; errStr	end tryend open location   ヒント: tcsh などの特定のシェルから Python を確実に実行するには、do シェル スクリプトを次のように変更します。do shell script tcsh -c  &quot;sgTriggerScript.py '&quot; &amp;amp; this_URL &amp;amp; &quot;' &quot;。スクリプト エディタで、この短いスクリプトを_アプリケーション バンドル_として保存します。手順 2: info.plist ファイルを編集する保存したアプリケーション バンドルを見つけて、Open Contents を選択します。次に、info.plist ファイルを開き、次のコードを plist dict に追加します。&amp;lt;key&amp;gt;CFBundleIdentifier&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;com.mycompany.AppleScript.ShotGrid&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;CFBundleURLTypes&amp;lt;/key&amp;gt;&amp;lt;array&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;CFBundleURLName&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;ShotGrid&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;CFBundleURLSchemes&amp;lt;/key&amp;gt;&amp;lt;array&amp;gt;&amp;lt;string&amp;gt;ShotGrid&amp;lt;/string&amp;gt;&amp;lt;/array&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/array&amp;gt;次の 3 つの文字列を変更することもできます(オプション)。com.mycompany.AppleScript.ShotGridShotGridShotGrid3 番目の文字列はプロトコル ハンドラです。そのため、URL は次のようになります。shotgrid://somethingBigSur を使用している場合は、info.plist ファイル内の次の行を_削除_する必要があります。この行は、NSAppleEventsUsageDescription と NSSystemAdministrationUsageDescription の間にあります。BigSur より古いバージョンを使用している場合は、この手順をスキップして、次の手順 3 に進みます。	&amp;lt;key&amp;gt;NSAppleMusicUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your music to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSCalendarsUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your calendars to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSCameraUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your camera to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSContactsUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your contacts to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSHomeKitUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your HomeKit Home to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSMicrophoneUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your microphone to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSPhotoLibraryUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your photos to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSRemindersUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your reminders to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSSiriUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to Siri to run.&amp;lt;/string&amp;gt; 手順 3: .app バンドルをアプリケーション フォルダに移動する最後に、.app バンドルを Mac のアプリケーション フォルダに移動します。このバンドルをダブルクリックすると、プロトコルがオペレーティング システムに登録されます。Flow Production Tracking で AMI をクリックするか、shotgrid:// で始まる URL をクリックすると、.app バンドルがそれに応答して URL を Python スクリプトに渡す、というようなデータ フローになります。この時点で、Windows の例で使用したものと同じスクリプトを使用でき、同じことができるようになります。                    情報: Monterey のトラブルシューティングの詳細については、このコミュニティの投稿を参照してください。    Linux 上でプロトコルを登録する次のコードを使用します。gconftool-2 -t string -s /desktop/gnome/url-handlers/foo/command 'foo &quot;%s&quot;'gconftool-2 -s /desktop/gnome/url-handlers/foo/needs_terminal false -t boolgconftool-2 -s /desktop/gnome/url-handlers/foo/enabled true -t bool次に、次の場所にあるグローバル既定値にローカル GConf ファイルの設定を使用します。/etc/gconf/gconf.xml.defaults/%gconf-tree.xmlこの変更は GNOME 設定でのみ行われますが、KDE でも機能します。Firefox と GNU IceCat は、不明なプレフィックス(foo:// など)を検出したときに、実行しているウィンドウ マネージャに関係なく gnome-open に従います。そのため、KDE の Konqueror のような他のブラウザは、このシナリオでは機能しません。Ubuntu でアクション メニュー アイテムのプロトコル ハンドラをセットアップする方法については、https://askubuntu.com/questions/527166/how-to-set-subl-protocol-handler-with-unity を参照してください。",
    "url": "/af0c94ce/",
    "relUrl": "/af0c94ce/"
  },
  "33": {
    "id": "33",
    "title": "sgtk.env.project.tk-nuke.tk-multi-workfiles2 Failed to create File Open dialog!",
    "content": "data_handler_cache error message: ERROR sgtk.env.project.tk-nuke.tk-multi-workfiles2 Failed to create File Open dialog!使用例:このエラーは、Nuke などのアプリを起動したときに発生します。data_handler_cache の get_children メソッドに関するスタック トレースの最後にエラーが発生して、tk-multi-workfiles2 の[File Open]ダイアログ ボックスが障害状態になり、操作できなくなりました。原因は、dict 値が予期されていたのに、文字列値が渡されたことです。スタック全体は次のようになります。2020-12-07 09:42:03,571 [7192 ERROR sgtk.env.project.tk-nuke.tk-multi-workfiles2] Failed to create File Open dialog!Traceback (most recent call last):  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles work_files.py&quot;, line 115, in _show_file_dlg    self._dialog_launcher(dlg_name, app, form)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install core python tank platform engine.py&quot;, line 1822, in show_dialog    dialog, widget = self._create_dialog_with_widget(title, bundle, widget_class, *args, **kwargs)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install core python tank platform engine.py&quot;, line 1684, in _create_dialog_with_widget    widget = self._create_widget(widget_class, *args, **kwargs)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install core python tank platform engine.py&quot;, line 1658, in _create_widget    widget = derived_widget_class(*args, **kwargs)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles file_open_form.py&quot;, line 46, in __init__    FileFormBase.__init__(self, parent)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles file_form_base.py&quot;, line 64, in __init__    self._my_tasks_model = self._build_my_tasks_model()  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles file_form_base.py&quot;, line 134, in _build_my_tasks_model    bg_task_manager=self._bg_task_manager)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles my_tasks my_tasks_model.py&quot;, line 57, in __init__    bg_task_manager=bg_task_manager  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles entity_models extended_model.py&quot;, line 74, in __init__    **kwargs  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-framework-shotgunutils v5.5.0 python shotgun_model shotgun_entity_model.py&quot;, line 70, in __init__    self._load_data(entity_type, filters, hierarchy, fields)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-framework-shotgunutils v5.5.0 python shotgun_model shotgun_model.py&quot;, line 367, in _load_data    self._create_item  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install core python tank log.py&quot;, line 503, in wrapper    response = func(*args, **kwargs)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-framework-shotgunutils v5.5.0 python shotgun_model data_handler.py&quot;, line 266, in generate_child_nodes    for data_item in self._cache.get_children(unique_id):  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-framework-shotgunutils v5.5.0 python shotgun_model data_handler_cache.py&quot;, line 129, in get_children    for item in cache_node[self.CACHE_CHILDREN].itervalues():AttributeError: 'str' object has no attribute 'itervalues'エラーの原因キャッシュに問題が発生したため、キャッシュを削除して修正する必要があります(次のセクションを参照)。修正方法キャッシュの場所と削除方法については、こちらの手順に従ってください。全体を削除することはできますが、そうすると、すべてをダウンロードする必要が生じて、次回に Desktop を再起動するときに遅延が生じます。ルート キャッシュ フォルダ内にある Flow Production Tracking サイトに由来する名前の付いたフォルダを削除することをお勧めします。この場合も若干の再構築が行われますが、それほど時間はかかりません。コミュニティの完全なスレッドを参照してください。",
    "url": "/aaac055f/",
    "relUrl": "/aaac055f/"
  },
  "34": {
    "id": "34",
    "title": "開発の概要",
    "content": "開発の概要Python APIFlow Production Tracking ソフトウェアは、Python ベースの API を使用して Flow Production Tracking にアクセスし、他のツールと連携します。API は CRUD パターンに従い、Flow Production Tracking サーバで作成、読み取り、更新、および削除のアクションを実行できます。各リクエストは単一のエンティティ タイプに従って動作し、アクションに応じて、フィルタ、返される列、ソート情報、およびいくつかの追加オプションを定義できます。  コード リポジトリ  ドキュメント  フォーラムイベント トリガ フレームワークFlow Production Tracking イベント ストリームにアクセスする場合の望ましい方法として、イベント テーブルを監視し、新しいイベントを取得し、イベントを処理して、また同じ手順を繰り返します。このプロセスを成功させるためには多くの要素が必要ですが、それらの中には、適用すべきビジネス ルールに直接関係しないものがあります。フレームワークの役割は、退屈な監視タスクをビジネス ロジックの実装作業から分離することです。フレームワークはサーバ上で動作し、Flow Production Tracking のイベント ストリームを監視するデーモン プロセスです。イベントが見つかったら、デーモンはイベントを一連の登録済みのプラグインに渡します。各プラグインは、意図したとおりにイベントを処理できます。  コード リポジトリ  ドキュメントアクション メニュー アイテム フレームワークAPI 開発者は、エンティティ単位でコンテキスト メニュー項目をカスタマイズできます。たとえば、Versions ページから複数のバージョンを選択して右クリックし、(たとえば) PDF レポートを作成します。これらを ActionMenuItems (AMIs)と呼びます。  ドキュメント  サンプル コード リポジトリ",
    "url": "/1e047003/",
    "relUrl": "/1e047003/"
  },
  "35": {
    "id": "35",
    "title": "開発",
    "content": "開発Toolkit を使用した開発に基づくクイック アンサーのコレクションです。  ソフトウェアを起動する前に環境変数を設定するにはどうすればいいですか?  カスタム スクリプトで認証とログイン資格情報を使用するにはどうすればよいですか?  as_template_fields() でコンテキスト内に存在する値が見つからない  Maya で Toolkit アプリを起動するシェルフ ボタンを追加するにはどうすればいいですか?  Shotgun のイベント デーモンを使用してさまざまな Toolkit コア モジュールをロードするにはどうすればいいですか?  API を使用して Toolkit の設定をプログラムによって更新するにはどうすればいいですか?  API を使用してパブリッシュを作成するにはどうすればいいですか?",
    "url": "/16654f1f/",
    "relUrl": "/16654f1f/"
  },
  "36": {
    "id": "36",
    "title": "開発",
    "content": "開発Toolkit とは何か?Toolkit とは、パイプライン統合の基盤となるプラットフォームのことです。たとえば、Maya で Flow Production Tracking Panel アプリを使用している場合や、Flow Production Tracking Create から Publish アプリを起動している場合は、Toolkit プラットフォーム上に構築されたツールを使用しています。Toolkit を使用して開発するには、どうしたらよいですか?Toolkit を使用して開発する場合は、複数の方法を使用できます。  フックと呼ばれるカスタム コードを記述して、既存のアプリ、エンジン、またはフレームワークの動作を拡張します。  独自のアプリ、エンジン、またはフレームワークを作成します。  または、API を利用する独自のスタンドアロン スクリプトを記述します。これらのいずれかの操作を行うには、Toolkit API の使用方法を理解することが重要です。Flow Production Tracking 全体には、3 つの主な API があります  Flow Production Tracking Python API  Flow Production Tracking REST API  Flow Production Tracking Toolkit APIToolkit API は、Flow Production Tracking Python API または REST API と一緒に使用するように設計された Python API です。これらの API の代わりに使用することはできません。Toolkit API にはいくつかのラッパー メソッドが含まれていますが、一般には、Flow Production Tracking サイトのデータにアクセスする必要がある場合、Flow Production Tracking Python API または REST API を代わりに使用します。Toolkit API は主に、ファイル パスの統合と管理を行います。一部の Toolkit アプリおよびフレームワークには、独自の API も含まれています。これらの記事では、Toolkit を使用した開発方法について説明します。",
    "url": "/a1cfe87c/",
    "relUrl": "/a1cfe87c/"
  },
  "37": {
    "id": "37",
    "title": "Direct Connect",
    "content": "Direct ConnectAWS Direct Connect is a service from AWS that allows you to establish a dedicated connection from your on-premise data center (or offices) to AWS. Direct Connect will allow you to create a dedicated link between your network and one of the AWS Direct Connect locations.Leveraging AWS Direct Connect ensure that you will benefit from the best experience possible when using the isolation feature set, optimizing reliability and performance for all your access points across the globe.",
    "url": "/0de47d40/",
    "relUrl": "/0de47d40/"
  },
  "38": {
    "id": "38",
    "title": "Flow Production Tracking AWS Direct Connect Onboarding",
    "content": "Flow Production Tracking AWS Direct Connect OnboardingIntroductionAWS Direct Connect (DX) is used to establish private connectivity between AWS and an on-prem facility. DX provides a private, high bandwidth network connection between your network and AWS Virtual Private Cloud (VPC) and bypasses the public internet. AWS has established 100 Direct Connect locations globally and leverages the AWS Partner Network to extend the footprint.Review of Shogun Configuration in AWSCustomer Types  Customer already has AWS Direct Connect dedicated connection  Customer has equipment and network presence in an AWS Direct Connect location  Customer does not have equipment or presence in an AWS Direct Connect locationSetup Options  Request a dedicated Direct Connect connection through AWS Console          Provision the required connectivity yourself      Work with Direct Connect Partner to help establish a dedicated connection to AWS equipment        Request a hosted Direct Connect connection through AWS Direct Connect PartnerCriteria to Determine Setup PathIf you answer “yes” to the following, then request a dedicated Direct Connect connection through the AWS Console (Option 1a):  Do you already have equipment and presence in an AWS Direct Connect location?  Do you know the process for requesting a cross-connect within the Direct Connect location facility?  Are you looking for any one of the following - 1Gbps, 10Gbps port, or a dedicated connection?If you answer “yes” to the following, then request a dedicated Direct Connect connection through the AWS Console and select a Partner to assist (Option 1b):  Are you planning to use AWS Direct Connect to connect to other AWS resources outside of Flow Production Tracking?  Do you have the time and resources to complete the setup?  Are you looking for any one of the following - 1Gbps, 10Gbps port, or a dedicated connection?If you answer “yes” to the following, then you should work with an AWS Direct Connect Partner to request a hosted Direct Connect connection (Option 2):  Are you already working with an AWS Direct Connect Partner?  Do you want a Partner to facilitate the setup?  Are you looking for a port less than 1Gbps or a hosted connection?Disclaimer:  All options are valid and the criteria are just a guide to help simplify the selection process. You can still pick any option based on more specific criteria.Setup DirectionsRequest through AWS Console - Option 1 (a and b)  Create a Connection in the AWS Console  Download the LOA-CFA. The LOA is the authorization to connect to AWS and is required to establish the cross-network connection.  (Option 1a only) Request cross-connects at AWS Direct Connect locations. Find contact information here.  (Option 1b only) Reach out to an AWS Partner and share the LOA with them.  Once the dedicated connection is provisioned into your account, set up logical connectivity (Virtual Interfaces).Request through AWS Direct Connect Partner - Option 2  Reach out to an AWS Partner. The criteria for choosing an AWS Partner are:          AWS Region      Providers      If you are already working with an AWS Direct Connect Partner        If hosted connection, accept a hosted connection. More information can be found here.  Once the hosted connection is provisioned into your account, set up logical connectivity (Virtual Interfaces).FAQHow long should it take to set up AWS Direct Connect?Short Answer - It depends. A lot of factors go into the time it takes to set up AWS Direct Connect. The timeline can vary from a few days to a few months. Some of the factors include current infrastructure, location of equipment, providers, partners, and more. If you are looking to expedite the process, consider using an AWS Direct Connect Partner who is geographically nearby.Further questions about AWS Direct Connect?AWS Direct Connect FAQsVPNA site-to-site VPN can be used as an alternative to AWS Direct Connect. Learn more about AWS VPN here.AWS Documentation &amp;amp; Resources  What is AWS Direct Connect?  Direct Connect User Guide  re:Invent 2018 - 400 level Deep Dive on Direct Connect  AWS Direct Connect Locations  AWS Direct Connect Partners",
    "url": "/8233001e/",
    "relUrl": "/8233001e/"
  },
  "39": {
    "id": "39",
    "title": "Flow Production Tracking Toolkit のブラウザ統合を無効にするにはどうすればいいですか?",
    "content": "Flow Production Tracking Toolkit のブラウザ統合を無効にするにはどうすればいいですか?ブラウザの統合を無効にするには、次の簡単な 2 つの手順を実行します。      次のテキスト ファイルを作成または開く     Windows: %APPDATA% Flow Production Tracking preferences toolkit.ini Macosx: ~/Library/Preferences/ShotGrid/toolkit.ini Linux: ~/.ShotGrid/preferences/toolkit.ini            次のセクションを追加する     [BrowserIntegration] enabled=0      ブラウザ統合の設定方法に関する詳細については、『管理者ガイド』を参照してください。別の方法Toolkit のパイプライン設定を引き継いだ場合は、代わりに tk-Flow Production Tracking エンジンを環境から削除し、アクションがロードされないようにすることができます。",
    "url": "/1bb3f6ad/",
    "relUrl": "/1bb3f6ad/"
  },
  "40": {
    "id": "40",
    "title": "ファイルシステムの設定",
    "content": "動的ファイルシステムの設定このガイドでは、Toolkit パイプライン構成を変更してプロダクションのフォルダ構造とファイル命名をカスタマイズする方法について学びます。このガイドについてパイプラインを管理する上で最も難しいことの 1 つは、作成される無数のファイルをトラックすることです。Toolkit のパイプラインはファイルシステム管理を自動化します。すなわち、Flow Production Tracking のデータおよび設定されたフォルダ構造に基づいてフォルダを作成し、標準の命名規則に従って正しい場所に自動的にファイルを書き込みます。そのためアーティストはコンテンツ作成に集中できます。パイプライン設定には、既定のフォルダのセットとファイル命名規則がありますが、プロダクションではそれらをカスタマイズすることがよくあります。このガイドは、それらのカスタマイズに必要な知識を提供します。既定の設定では、アセットは asset_type/asset/pipeline_step のようなフォルダ構造で管理されます。このガイドでは、「Set」と呼ばれるカスタム エンティティを使用して、各アセットが使用されるプロダクション セット別にアセットを整理します。最初に Flow Production Tracking でカスタム エンティティを設定し、それを使用して特定のセット用に作成されたアセットを管理します。その結果、フォルダ構造は set/asset_type/asset/pipeline_step のようになります。セットによってアセットを整理することの背景にある考え方を、例を挙げて説明してみましょう。たとえば、いくつかのシーンがガレージで発生し、別のシーンがダイニング ルームで発生するプロジェクトがあるとします。このセットアップでは、「wrench」、「oilcan」、「workbench」などのアセットのファイルは「garage」フォルダに整理され、「plate」、「winebottle」、または「tablecloth」は「dining_room」フォルダに整理されます。この例では、ダイニング ルームに肉汁たっぷりの「filet」アセットが適切に配置されていることを確認します。さらに、プロジェクトのファイル命名テンプレートも編集し、アセットの Maya ワーク ファイルにセットがそれぞれの名前で含まれるようにします。動的に生成されるファイル名により、ダイニング ルームのファイルを他のセットで使用されるファイルと区別できるようになります。このガイドの次の 3 つの手順  Flow Production Tracking で、「Set」とよばれるカスタム エンティティを作成します。これは、アーティストが作成しているダイニング ルームの要素と関連付けるために使用します。  フォルダのスキーマを編集します。これによって、Toolkit はフォルダ構造内の現在のセットに基づいて動的に名前が付けられたフォルダを含めることができます。  アセット ワーク ファイルの命名に使用されるテンプレートを編集します。これによって、Toolkit はファイル名に関連付けられたセットの名前を含めることができます。前提条件このガイドを使用するには、以下が必要です。  アクティブな Flow Production Tracking サイト。少なくとも 1 つのアセットが作成されたプロジェクトが必要です。アセットにはモデル タスクが必要です。  Flow Production Tracking サイトを使用してアセットを管理する方法の基本的な理解。  システムにインストールされた Flow Production Tracking Toolkit。  指定したプロジェクトのクローン作成されたパイプライン設定、または「設定の基本操作」ガイドを参照して、この演習で作成された設定のクローンを作成します。  YAML の基本的な知識。  パイプライン設定を保存するファイルシステムに最適になるように設定された読み取りおよび書き込み権限。  Toolkit がプロダクション ファイル システムに対して読み取りおよび書き込みを行えるように適切に設定された読み取りおよび書き込み権限。  Maya の有効なサブスクリプション。Maya の 30 日間無償体験版を入手してください。注: このガイドは、tk-config-default2 パイプラインの設定に基づいています。設定が変更されている場合は、YAML 設定のファイル、フォルダ、およびブロックの場所がここに記載されている内容と異なる可能性があります。ファイル スキーマとテンプレートについてToolkit パイプライン設定のスキーマとテンプレートを使用すると、Flow Production Tracking データを利用してディスク上のプロダクション ファイルを管理できます。既定の設定のスキーマには、Shot、Sequence、Asset、Asset Type などのエンティティが含まれています。その他の Level、Episode、Season などのエンティティ、または今回使用する Set などのカスタム エンティティを追加できます。Toolkit プラットフォームではスキーマを使用してフォルダ構造を動的に構築できます。これは、実際のプロダクション ファイルシステムを構築するときのテンプレートとして使用されるプロダクション フォルダ構造のミニチュア バージョンです。スキーマはフォルダの動的作成のための明示的なガイドで、YAML ファイルを使用して動的に作成されるフォルダのルールを定義します。既定の設定には、アセットとショットの両方のパイプラインのフォルダ作成をサポートする事前設定されたスキーマが含まれています。作成している新しい Set エンティティのサポートを追加するために、アセット フォルダ構造の作成をサポートするスキーマの部分 /assets/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt; を変更します。テンプレートを使用すると、Flow Production Tracking のデータとスキーマ構造の情報を使用して作成したファイルに動的に名前を付けて保存することができます。既定の設定には、パイプラインのニーズに合わせて編集できる一連のスタータ テンプレートが用意されています。Flow Production Tracking 統合の基本設定にファイルシステム管理は含まれません。プロジェクトのファイルシステム管理を設定するには、プロジェクトに高度な設定が必要です。最初のガイドの「設定の基本操作」で、高度なセットアップ プロセスについて説明しています。実習を開始スキーマとテンプレートをカスタマイズすることで、ダイニング ルームのセットの作成時に生成されるファイルを動的に管理できます。それらのファイルとはすなわち、食器一式、蒸し上がったフィレ ミニヨン、Penfolds Grange Hermitage 1951 のワイン、ポテト グラタン、レモン ガーリック風味のアスパラガスなどです。ダイニング ルームのセットで使用されるアセットは「Dining Room」という Set エンティティに関連付けられ、より簡単に管理できるようになります。Set は 既定の設定に標準装備されたエンティティ タイプではないため、カスタム エンティティを有効にし、それに「Set」という名前を付けてから、これを使用するようにスキーマおよびテンプレートを拡張する必要があります。カスタム エンティティを有効にする手順 1: ブラウザで Flow Production Tracking サイトを開きます。アバターをクリックして、[管理者] (ADMIN)&amp;gt; [サイト基本設定] (Site Preferences)の順にクリックします。結果のページで[エンティティ]（Entities）セクションを展開します。Flow Production Tracking で利用可能なエンティティのタイプのリストが表示されます。下図のリストの一番上には、現在の Flow Production Tracking サイト用に構成されているいくつかのエンティティ タイプが示されています。これらのエンティティ タイプの下には、設定も有効化もされていないいくつかのカスタム エンティティがあります。カスタム エンティティ タイプをどれか選択して設定し、有効にします。手順 2: 矢印を選択してグレー表示の無効なカスタム エンティティの設定を開きます。[はい、カスタム エンティティを使用します…] (Yes, use Custom Entity…)の横のラジオ ボタンをオンにし、[表示名] (Display name)を Set に変更し、ウィンドウの上部にスクロールして[変更を保存] (Save Changes)を選択します。これによって、カスタム エンティティが Flow Production Tracking でアクティブになり、表示名が Set になります。エンティティのシステム名は CustomEntity01 のままなので、基本的にここではカスタム エンティティの別名を作成していることになります。この例では、CustomEntity01 を使用していますが、別のカスタム エンティティを使用することもできます。選択したカスタム エンティティのシステム名をメモしておいてください。アセットをセットに関連付けるデータ フィールドを追加します。アセット エンティティにデータ フィールドを追加すると、アセットを新しいエンティティにリンクできます。アーティストがダイニング ルーム用に作成したアセットは、Dining Room セット エンティティに関連付けられます。手順 3: ページ上部の[プロジェクト] (Projects)ドロップダウンを選択して、この実習に使用するプロジェクトを開きます。手順 4: プロジェクト メニュー バーで[アセット] (Assets)を選択し、[アセット] (Assets)ページに移動します。[アセット] (Assets)メニューで、[フィールド] (Fields)&amp;gt; [アセット フィールドの管理…] (Manage Asset Fields…)を選択します。このアクションはアセット フィールド管理者を表示します。[+ 新しいフィールドを追加] (+ Add a new field)を選択します。新しいフィールドのパラメータを選択します。[新しいフィールド名] (New Field Name)に「Set」と入力します。[一般] (GENERAL)メニューの[フィールド タイプ] (Field Type)で、[エンティティ] (Entity)を選択し、[タイプを制限] (Restrict the type)までスクロールダウンして、Set を選択します。[次へ]（Next）を選択します。このガイドでは、[現在のプロジェクトのみ] (Only the current project)に適用し、[フィールドを作成] (Create Field)を選択します。Flow Production Tracking は新しいフィールドを設定します。変更が適用されたら、[完了]（Done）を選択します。[ダイニング ルーム] (Dining Room)の Set エンティティを作成する手順 5: アセットの新しい Set フィールドを選択して、「Dining Room」と入力します。すると、「一致するものが見つかりません。「Dining Room」を作成」というメッセージが表示されます。[「Dining Room」を作成]を選択します。[セットを作成] (Create Set)を選択します。アセットの Set フィールドに Dining Room を追加したことにより、Dining Room セット エンティティとの関連付けが生成されます。手順 6: filet アセットのモデル タスクを自分自身に割り当てて、テスト目的で簡単に見つけられるようにします。スキーマを設定するこれで、Set カスタム エンティティが有効になり、「Dining Room」と呼ばれる Set エンティティが作成され、Asset エンティティがダイニング ルームのセットにリンクされました。Flow Production Tracking サイトにすべての要素が配置されたので、フォルダ構造の変更を開始できます。アーティストがタスクでの作業を開始すると、Toolkit は関連付けられた Flow Production Tracking のデータを使用してファイルシステムに作成するフォルダを決定します。パイプライン設定のスキーマに基づいて、新しいフォルダが作成され、自動的に名前が付けられます。次に、アーティストがプロダクション パイプラインを実行する際に Toolkit が動的に生成するフォルダ構造を定義します。これは、スキーマを編集することで実行されます。アクティブなプロダクションの設定に影響を与えないように、クローン作成された設定でテストすることをお勧めします。クローン作成プロセスでは設定のコピーが作成され、安全な環境で編集してからライブ設定に変更をプッシュすることができます。設定のクローン作成の詳細については、『設定のステージングとロールアウト』ドキュメントを参照してください。手順 7: パイプライン設定に移動します。スキーマ フォルダ &amp;lt;pipeline_configuration_root&amp;gt;/config/core/schema にドリル ダウンして、project フォルダを開きます。現在のスキーマは、次のようになります。&amp;lt;project&amp;gt;/assets/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt;このフォルダ構造の動的作成をサポートします。the_other_side/assets/prop/filet/model代わりに次のような構造にします。the_other_side/assets/Dining-Room/Prop/filet/modelこれを実現するには、スキーマを次のように設定します。&amp;lt;project&amp;gt;/assets/&amp;lt;CustomEntity01&amp;gt;/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt;Set エンティティは CustomEntity01 として表されます。Flow Production Tracking で CustomEntity01 に Set という表示名を付けましたが、この構成では常にそのシステム名 CustomEntity01 でこれを参照します。スキーマが YAML ファイルを使用する方法スキーマには静的フォルダと動的フォルダを含めることができます。スキーマに「assets」という名前の静的フォルダがある場合、それはプロダクション ファイルシステム内の「assets」という名前の単一のフォルダに対応します。一方、スキーマには「asset」という名前の動的フォルダがあり、これはプロジェクト内の各アセットに対する単一のフォルダを表します。すべての動的フォルダには、その隣に、フォルダと同じ名前の YAML ファイル(たとえば asset/ および asset.yml)があり、スキーマ フォルダに基づいてプロダクション フォルダを生成するためのルールが定義されています。Set エンティティの新しいフォルダと YAML ファイルを作成します。スキーマには、Flow Production Tracking が追跡するさまざまなエンティティに関連するフォルダを含む project フォルダがあります。Flow Production Tracking が Set 内のアイテムをトラックできるようにするために、新しいアセット エンティティ CustomEntity01 を追加します。これらのアイテムはアセットなので、アセットの下のフォルダと YAML ファイルを編集します。繰り返しますが、目標は asset_type/asset/step フォルダ構造から set/asset_type/asset/step に移動することです。そこで、スキーマ内のセットを表すフォルダを、対応する YAML ファイルと共に追加します。カスタム エンティティにはシステム名を使用する必要があるので、CustomEntity01/ フォルダと CustomEntity01.yml を作成します。手順 8: スキーマの project/assets フォルダ内に CustomEntity01 フォルダを追加します。手順 9: 以下の内容で、CustomEntity01 フォルダの隣に CustomEntity01.yml という名前のファイルを作成します。type: &quot;shotgun_entity&quot;name: &quot;code&quot;entity_type: &quot;CustomEntity01&quot;filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }YAML ファイルは、CustomEntity01 フォルダに付ける名前を Toolkit に指示します。この場合は、タイプ Flow Production Tracking_entity のフォルダを作成しています。これは、Flow Production Tracking クエリに対応していることを意味します。entity_type フィールドは Flow Production Tracking の CustomEntity01 エンティティをクエリするように指示し、name フィールドはエンティティのどのフィールドをクエリするのかを指示します。この場合は CustomEntity01 から code フィールドを取得します。filters フィールドは、この動的フォルダを作成する必要があるケースを制限します。手順 10: asset_type/ と asset_type.yml を CustomEntity01 フォルダに移動します。フォルダ構造を Dining-Room/Prop/filet のようにしたいので、asset_type フォルダは階層内の CustomEntity01 フォルダよりも下ににする必要があります。asset_type/ と asset_type.yml を CustomEntity01 フォルダに移動します。asset.yml ファイルを編集します。filters フィールドは、特定の時点でどのエンティティにフォルダを作成するかを制限します。現在の状態では、asset.yml のフィルタ フィールドは次のようになります。filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }アセットのフォルダを作成するときは、正しいプロジェクト フォルダと正しいasset_type フォルダが選択されていることを確認する必要があります。セットのフォルダを追加したので、3 番目のフィルタを追加します。追加しないと、次のようなフォルダとなり、これはもちろん正しくありません。assets/Dining-Room/Prop/spoonassets/Garage/Prop/spoonassets/Classroom/Prop/spoonこれを防ぐために、3 番目のフィルタを追加します。これにより、アセットのフォルダは正しいセットのフォルダにのみ作成されるようになります。手順 11: asset.yml の filters フィールドを次のように変更します。filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }    - { &quot;path&quot;: &quot;sg_set&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$CustomEntity01&quot; ] }フォルダ作成のテストこれで、アセットを Set カスタム エンティティで整理するためにスキーマが正しく修正されました。それでは、テストしてみましょう。フォルダは、Toolkit パイプライン ワークフローのいくつかの時点で作成されます。  アプリケーション ランチャー： ユーザがタスクの DCC を起動するたびに、Toolkit はそのタスクのディレクトリを作成します(まだ作成されていない場合)。Toolkit ではまず最初に DCC の起動を行う傾向があるので、通常はこの方法でディレクトリが作成されます。これは、Flow Production Tracking の右クリック メニュー、または Flow Production Tracking Toolkit あるいは Create アプリで実行できます。  Flow Production Tracking メニュー: タスク用のフォルダを作成する最も直接的な方法は、Flow Production Tracking で右クリックして[フォルダを作成] (Create Folders)メニュー項目を選択することです。  Toolkit API: Toolkit API を介して直接ディレクトリ作成ロジックを起動できます。この方法によって、Toolkit をカスタム ランチャーにプラグインしたり、Flow Production Tracking で作成される Shot のディレクトリを自動的に作成するためのワークフローのイベント トリガとして使用することができます。  tank コマンド: Flow Production Tracking のメニュー項目と同様、tank folders ターミナル コマンドからもタスク用のフォルダを作成できます。tank コマンドでテストします。手順 12: filet アセットで tank folders を実行します。ターミナルで、以下を実行します。&amp;gt; cd &amp;lt;pipeline_configuration_root_folder&amp;gt;&amp;gt;  ./tank Asset Filet folders出力の要約:----------------------------------------------------------------------Command: Folders----------------------------------------------------------------------Creating folders, stand by...The following items were processed: - /Users/michelle/Documents/Shotgun/projects/the_other_side. . . - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/ - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/model - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/model/publish. . .In total, 23 folders were processed.最終的な構造が期待した構造と一致し、Toolkit が非常にスマートになり、「Dining」と「Room」の間にダッシュが追加されています。/the_other_side/assets/Dining-Room/Prop/Filet/modelファイルを読み書きするための Toolkit テンプレートフォルダ構造を設定したので、次のステップでテンプレートを編集します。プロダクション ファイルに適切な名前を付け、作成後に正しいフォルダに配置します。Toolkit アプリがテンプレートを使用する方法まず、Flow Production Tracking でアセットをセットに関連付ける方法を作成しました。すなわち CustomEntity01 がセットを表すようにして、Asset エンティティにアセットとセットの間のリンクを表すリンク フィールドを追加しました。アセットとセット間の関係を確立したら、その関連付けを使用するようにフォルダ スキーマを設定し、すべてのアセットのフォルダをその関連付けられたセットのフォルダ内に配置します。次に、ファイルに動的に名前を付ける方法を作成し、Toolkitアプリ でファイルを自動的に管理できるようにします。アーティストがプロジェクト内のタスクを実行し始めると、必要なフォルダ構造が生成されます。その後、Workfiles アプリの[File Save]アクションを開始すると、ファイルに自動的に名前が付けられます。Toolkit の Workfiles アプリを通じてアクセスされるテンプレートは、そのファイルに名前を付けるために使用されます。Nuke Write ノードや Houdini Mantra ノードなどのレンダリング アプリは、パブリッシュ ファイル用のパブリッシャー アプリと同様に、テンプレートを使用してレンダリングされたファイルに名前を付けて保存します。Workfiles の[File Open]アクションを使用してファイルにアクセスすると、テンプレートを使用してロードする適切なファイルが検索されます。Publisher、Loader、および Nuke Studio Export の各アプリも、テンプレートを使用してファイルを検索および管理します。アーティストはファイル名や場所を気にする必要はありません。Toolkit がテンプレートおよび実行されているタスクに基づいてそれらをすべて管理します。テンプレートは設定ファイル /&amp;lt;pipeline_configuration_root&amp;gt;/config/core/templates.yml によって管理されます。最後の 2 つのガイドでは、作業環境に固有の設定を管理および作成しました。スキーマとテンプレートの設定は config/core フォルダに格納されており、環境に固有のものではありません。すべてのテンプレートは単一のファイルに格納されますが、それらはさまざまな環境設定ファイルのアプリ設定で、このファイルから参照されます。たとえば、template_work は、ワークファイルに使用する templates.yml のテンプレートを指定する Workfiles アプリの設定です。ワークファイルが構成されている環境およびエンジンに応じて、この設定を使用して maya_shot_work テンプレートまたは templates.yml の houdini_asset_work テンプレートを参照することができます。手順 13: パイプライン設定で config/core/templates.yml を開きます。このファイルは 3 つのセクションに分かれています。  キー: トークンのセット({version}、{Asset} など)。テンプレートを構築するために使用されます。テンプレートが使用されると、実際の値に置き換えられます。各キーには、必須の名前とタイプ、およびオプションのパラメータがあります。  パス: キーを使用してディスク上のフォルダおよびファイルへのパスを表す名前付き文字列。paths セクションのテンプレートは検証済みで、実際にディスク上に存在する必要があります。  文字列: パス セクションと似ていますが、これらは任意のテキストのテンプレートです。パス セクションの項目は検証済みで、ディスク上の実際のパスと対応している必要がありますが、Toolkit ワークフローで参照するテキスト データを格納するために文字列を使用できます。Set エンティティのテンプレート キーを追加する最初に行うことは、エンティティのシステム名を使用して、Set エンティティの新しいキーを定義することです。手順 14: 適切なインデントを使用し、templates.yml の keys セクションに次の行を追加します。       CustomEntity01:           type: strテンプレートを修正するToolkit がファイルを読み書きする場所はテンプレートが定義するので、ここで定義するパスがスキーマで定義されているフォルダ構造と一致することが重要です。最終的に、プロダクション ファイルは現在作成しているファイルシステムに配置されます。そこで、スキーマに定義した新しいフォルダ構造に合わせて、アセット関連のテンプレートをすべて変更します。次に、Maya のアセット ステップで作業ファイルのテンプレートを変更し、ファイル名にそのセットも含めるようにします。既定の設定では、該当のテンプレートは maya_asset_work で、ここから開始します。Maya でアセットベースのワークファイルに maya_asset_work というテンプレートを使用するのは、既定の設定の規約です。これが正しいテンプレートであることを確認するには、asset_step 環境で、tk-maya エンジンの tk-multi-workfiles2 の template_work 設定の値を確認します(Github にあります)。手順 15: templates.yml を開いて、maya_asset_work を検索します。   maya_asset_work:        definition: '@asset_root/work/maya/{name}.v{version}.{maya_extension}'maya_asset_work の definition 値は @asset_root で始まります。@ 記号は、@asset_root の値が他の場所で定義されていることを意味します。先頭の @ 記号は、templates.yml に含めることを意味しません。この処理は、環境設定ファイルで実行されます。統合ごと、アプリごと、環境ごとに異なる設定を使用できるので、templates.yml 内のさまざまな場所でパスの最初の部分が使用される可能性があります。構成は、単一の変数を使用して共通のパス ルートを格納し、テンプレート内でその変数を参照できるように設定されます。共通ルートを参照できる場合は、パス生成設定の各インスタンスを変更する必要はありません。既定の設定には、@shot_root、@sequence_root、および @asset_root の 3 つの共通ルート変数があります。@asset_root を変更します。この変更はすべてのアセット関連のテンプレートに影響します。ファイルシステム スキーマのパスと一致するようにテンプレートを編集します。手順 16: templates.yml の paths セクションの上部にある asset_root を検索します。既定の設定では、次のようになります。asset_root: assets/{sg_asset_type}/{Asset}/{Step}スキーマの変更に一致するように asset_root パスに CustomEntity01 を追加します。asset_root: assets/{CustomEntity01}/{sg_asset_type}/{Asset}/{Step}ファイル名にセットを追加するスキーマの変更を反映するようにファイルのフォルダ構造を変更したため、ファイルの読み込み/書き出しは適切な場所で行われます。では、Maya のアセット ワークファイル テンプレートのファイル名を変更して、そのセットも含めるようにします。maya_asset_work テンプレート定義をもう一度見つけます。現在の状態では、ファイル名は以下です。{name}.v{version}.{maya_extension}{name} テンプレート キーは、Workfiles アプリの[File Save]アクションでのユーザ入力を表す特別なキーです。ユーザの入力は含まれず、現在のセットとアセットだけで構成されるようにテンプレートを変更します。手順 17: maya_asset_workテンプレート定義を次のように変更します。    maya_asset_work:        definition: '@asset_root/work/maya/{CustomEntity01}_{Asset}.v{version}.{maya_extension}'このアクションにより、ファイル名に Dining-Room エンティティの適切な名前を使用できます。結果は次のようになります。Dining-Room_Filet.v1.mbtemplates.yml が変更され、プロダクション フォルダ構造に新しいセット フォルダが反映され、Maya のアセット タスクのワークファイルにセットの名前が含まれるようになりました。変更をテストしましょう。テストの実行手順 18: Flow Production Tracking Toolkit から Maya を起動します。Maya で、[ShotGrid] &amp;gt; [ファイルを開く] (File Open)に移動し、表示されるダイアログで、Flow Production Tracking で Set を指定したアセットのタスクを選択します。[+ 新しいファイル] (+New File)を選択します。単純な 3D オブジェクトを作成するか、[ShotGrid] &amp;gt; [ファイルを保存] (Save File)を使用してファイルを保存することができます。成功しました!テンプレートの新しい設定を使用して、[File Save]ダイアログボックスにプレビュー：Dining-Room_scene.v001.maが表示されていることに注意してください。Work Area: Workfiles がファイルを保存するパスとして …/ShotGrid/projects/the_other_side/assets/Dining-Room/Prop/Filet/model/work/maya を表示します。高度なトピック例を拡張するこの例では 1 つのテンプレートを変更しましたが、ファイルシステムの設定については他にもさまざまな操作を実行できます。現実の例では、すべてのアセット関連のファイルを同じファイル命名規則に従うように変更します。他のエンティティ(Season、Episode、Level など)に基づいて変更を加えたり、ユーザ フォルダを作成したり、正規表現で操作した Flow Production Tracking のデータに基づいてフォルダに名前を付けたりすることができます。Toolkit のすべてのフォルダおよびスキーマ オプションについては、『ファイル システム設定リファレンス』を参照してください。パス キャッシュフォルダ作成時に、ディスク上のフォルダと Flow Production Tracking エンティティの間にマッピングが作成されます。これらのマッピングは Flow Production Tracking の FilesystemLocation エンティティとして保存され、ユーザのマシンの SQLite データベースにキャッシュされます。パス キャッシュの機能とその使用方法の詳細については、このドキュメントを参照してください。その他のリソース  『ファイル システム設定リファレンス』  Toolkit 設定紹介のウェビナー ビデオ",
    "url": "/56b441c6/",
    "relUrl": "/56b441c6/"
  },
  "41": {
    "id": "41",
    "title": "設定を編集する",
    "content": "パイプライン設定を編集するこのガイドを読み終えると、以下に関する基本的な知識を習得できます。  特定の Toolkit アプリの構成設定を見つける  設定を編集する  構成設定によって拡張できるその他の機能を調べるこのガイドについてこのガイドでは、プロジェクト パイプラインの要求に応じて、既存のパイプライン設定内の設定を編集する方法について説明します。最初のガイドの「設定の基本操作」では、パイプライン設定を編集するための準備方法について説明しました。プロジェクトに対して編集可能な設定を作成する方法を理解していない場合は、「設定の基本操作」を参照してから、先へ進んでください。Flow Production Tracking Toolkit では、既定の設定を拡張することにより、パイプラインのワークフロー内のタスクをカスタマイズできます。カスタマイズの例としては、ユーザが Toolkit の機能を操作する方法を変更するために、いくつかのソフトウェア パッケージに含まれている Toolkit アプリのボタンを有効または無効に切り替えるだけという簡単なものがあります。Toolkit には独自の設定を行う機能があるため、カスタム ワークフローの作成、反復タスクや日常的なタスクの自動化、フックの変更、および Toolkit プラットフォーム上に構築されたカスタム ツールの追加といった作業を、スマートに、かつ短時間で行うことができます。ただし、Toolkit にアクセスするには Flow Production Tracking ソフトウェアの統合が必要であり、衣服を洗うなどの日常的なタスク向けのリリースはまだ実現していません。このガイドの演習では、Flow Production Tracking ソフトウェア統合内のアクションをコントロールする構成設定の見つけ方、設定の配置場所、および設定の編集方法について説明します。具体的には、[+New Task]ボタンの動作を管理する Workfiles アプリの設定を編集することにより、アーティストが Maya 内のプロジェクトで作業しているときに新しいタスクを作成できないようにします。このドキュメントの使い方このガイドを使用してパイプライン設定を編集するには、以下が必要です。  アクティブな Flow Production Tracking サイト。  1 つ以上のアセットを含むプロジェクト。最初のガイドで作成した the_other_side プロジェクトにアセットを追加できます。プロジェクトのアセットを作成する方法については、「設定の基本操作」ガイドを確認してください。  指定したプロジェクトのパイプライン設定、または「設定の基本操作」ガイドを参照して、この演習で作成された設定を使用します。  パイプライン設定を保存するファイルシステムに最適になるように設定された読み取りおよび書き込み権限。  システムにインストールされた Flow Production Tracking Toolkit。  Maya の有効なサブスクリプション。Maya の 30 日間無償体験版はこちらから取得してください。                    注: このガイドは tk-config-default2 パイプライン設定をベースにしています。設定が変更されている場合は、YAML 設定のファイル、フォルダ、およびブロックの場所がここに記載されている内容と異なる可能性があります。    Workfiles アプリについてWorkfiles アプリは、Flow Production Tracking ソフトウェア統合のファイル管理を行い、作業ファイルの参照、オープン、および保存機能へのアクセスをコントロールします。[+New Task]ボタンをクリックすると Workfiles アプリのアクションが実行され、Flow Production Tracking に移動しなくてもタスクを追加することができます。設定は環境単位のファイルに分割されています。これにより、ユーザはパイプライン内のステージごとに機能を管理して、ユーザがファイルを作成、命名、保存する、タスクを実行する、または特定の機能を実行するタイミングをコントロールすることができます。これは Workfiles アプリのすべての機能に関係し、任意のアプリまたはエンジンの設定を変更する場合にも適用されます。詳細については、このドキュメントの末尾にある「高度なトピック」を参照してください。設定ファイルの概要作業しているプロジェクトのパイプライン設定が保存されている場所を見つけるには、Flow Production Tracking のパイプライン設定リストを使用します。保存場所がわかっている場合は、手順 5 に進んでください。パイプライン設定を見つける手順 1: この演習で使用するプロジェクトを管理している Flow Production Tracking サイトを開きます。手順 2: [プロジェクト] (Projects)ページから Flow Production Tracking サイトを選択してプロジェクトにアクセスします。手順 3: 右上にあるアバターを選択して、[管理者] (ADMIN)メニューを表示し、下にスクロールして[既定のレイアウト] (Default Layouts)&amp;gt; [パイプラインの設定] (Pipeline Configuration)&amp;gt; [パイプライン設定リスト] (Pipeline Configuration List)を選択します。手順 4: [パイプライン設定リスト]  (Pipeline Configuration List)が表示されたら、列見出しの右端にある[+]記号を選択して、列をもう 1 つ追加します。ドロップダウン リストで、オペレーティング システムに該当するパスを選択します。新しいフィールドにパスが表示されます。手順 5: 端末またはファイル マネージャで、プロジェクトのパイプライン設定が保存されているフォルダを参照して、開きます。Toolkit 設定のルート フォルダには、cache、config、および install の 3 つのサブフォルダがあります。config フォルダおよびその中のネストされたフォルダを開くと、サブフォルダとファイルがいくつか表示されます。env フォルダには、アーティストの作業環境をサポートする統合の設定が保存されています。これらの環境を利用することにより、パイプラインのステージごとに設定をカスタマイズすることができます。既定の設定には事前に定義された環境セットが用意されていますが、使用しているパイプラインで詳細な環境セットが必要な場合は、これらを変更できます。手順 6: env フォルダを開きます。Toolkit は YAML ファイルを使用して機能を設定します。YAML が設定の言語として選択された理由は、Toolkit 内のファイルを、読み取りやすく、軽量で、カスタマイズが容易になる方法でフォーマットすることが可能だからです。YAML の詳細については、こちら を参照してください。設定は、識別子、エンジン、アプリ、およびフレームワークを提供する、ネストされた YAML ファイルで構成されています。これは、影響を与えるアクションを制御するための特定のコード バンドルに導くための、ある種のロードマップです。設定ファイルを編集するFlow Production Tracking Toolkit を使用すると、さまざまなソフトウェア パッケージ内に統合されたアプリを変更できます。Workfiles アプリの機能の例としては、[+New Task] ボタンがあります。ユーザはこのボタンをクリックして、[File Open]ダイアログ ボックスに新しいタスクを追加できます。既定では、この機能はプロジェクトのすべてのフェーズで、すべてのユーザに対して有効になっています。ただし、スタジオでこの機能を制限したい場合があります。たとえば、特定の命名規則がある場合や、タスクの作成をプロジェクトのプロダクション管理チームに限定する場合などです。この場合は、アーティストが Maya で作業するパイプライン内のすべてのポイントで、[+New Task]ボタンを無効にします。Maya のプロジェクトに対して[+New Task]ボタンを無効にする手順 7: Flow Production Tracking Toolkit を開きます。手順 8: 設定を編集するプロジェクトを選択します。手順 9: Flow Production Tracking Toolkit から Maya を起動します。Flow Production Tracking メニューが完全にロードされるまで待ちます。インターネット接続速度が遅い場合は、この間に設定を行いましょう。つまり、適度な量のクリームを入れて一杯の完璧なエスプレッソを作るようなものです。Maya と Flow Production Tracking が完全にロードされると、[File Open]ダイアログ ボックスが自動的に開きます。Flow Production Tracking Toolkit から Maya を起動すると、Maya は project 環境になり、Toolkit ワークフローの設定はファイル config/env/project.yml によって制御されます。既定の設定で識別される環境は、project、sequence、shot、shot_step、asset、asset_step です。手順 10: [File Open]ダイアログ ボックスの左側のペインで[Assets]タブを選択します。検索結果に表示されたフォルダ内のいずれかのアセットを選択します。[+New Task]ボタンが有効になります。[+New Task]ボタンをコントロールする設定を特定するToolkit のパイプライン設定は、パイプラインに対するユーザのニーズに合わせて環境をカスタマイズする場合に使用します。パイプライン設定では、プロジェクトのパイプラインに対するニーズに合わせて、既定の Flow Production Tracking の統合の設定を必要なだけオーバーライドできます。この構造により、設定は軽量化され、Flow Production Tracking の主要コード内の既定値と異なる設定のみを追加することができます。この演習では、Workfiles アプリの[+New Task]ボタンをオフにしますが、その前にこのボタンをコントロールする構成設定を特定する必要があります。手順 11: [Project (プロジェクト名)]の横にある[File Open]ウィンドウの上部にある [&amp;gt;] を選択します。この参照ボックスには、[File Open]ウィンドウの機能をコントロールする構成設定の詳細が表示されます。Toolkit の一部のアプリには、アプリに使用される設定と、既定の設定を表示する参照ボックスがあります。[Location:]に注目してください。識別子は tk-multi-workfiles2 です。これは、Workfiles アプリを作成するコードのバンドルの識別子です。パイプライン設定を検索する場合、この名前でアプリの設定の配置場所を識別します。Flow Production Tracking の統合で使用可能な機能に関するすべての構成設定、アプリ、エンジンについては、「アプリとエンジンの概要」ページを参照してください。[Configuration:]見出しの下で、この特定の環境の設定を探します。                    注: my_tasks_filters の設定の後に、launch_at_startup の設定があります。この設定に注意することは重要です。この設定がプロジェクト環境内の[File Open]設定の既定の設定になります。この設定は、Flow Production Tracking Toolkit から Maya を起動したときに、[File Open]ダイアログが自動的に開くことを示します。    [Setting allow_task_creation]まで下にスクロールします。この設定の既定値は[True]です。この値の場合、ユーザは Maya プロジェクト環境内から新しいタスクを作成できます。設定を検索する際に、考慮すべき点がいくつかあります。  実行しているソフトウェア アプリケーション。  作業を行っているファイル、および作業している環境。これはアプリの参照ボックスに表示されています。  特定の設定の名前。これはアプリの参照ボックス、または「アプリとエンジンの概要」ページに表示されています。  拡張する YAML ファイル。設定の配置場所を示す識別子およびロードマップの詳細は、YAML ファイルに記述されています。  YAML ファイル内の拡張する特定のブロック。これはロードマップで識別されています。  YAML ファイル内で使用されている識別子および記号、  および現在のプロジェクトの設定の保存場所(これが最も重要)。設定は、パイプライン設定内の複数の場所で利用できます。配置場所を判別するには、設定を反映させるソフトウェア統合、および変更を反映させるパイプライン プロセス内の場所を考慮します。allow_task_creation の値の設定場所を特定する手順 12: メインの Maya ウィンドウを前面に表示します。手順 13: Maya ウィンドウの右上にある[ShotGrid]メニュー項目を特定します。ヒント: メニューが表示されない場合は、一部のメニュー項目が非表示になっていることを示す[»]が表示されています。[»]を選択して Flow Production Tracking メニューを表示するか、Maya ウィンドウの幅を広げます。手順 14: メニューの右上にある[ShotGrid] &amp;gt; [Project the_other_side] &amp;gt; [Work Area Info…]を選択します。[Work Area Info]ダイアログ ボックスには、現在の作業領域の内容と詳細が表示されます。この情報には、ユーザが作業している環境、および設定が配置されてい環境設定ファイルのパスが含まれています。手順 15: [Your Current Work Area]ダイアログ ボックスの下部にある[Environment]タブを選択します。最初の項目は、使用されているエンジンを識別します。このエンジンは、特定のソフトウェア アプリケーションに Flow Production Tracking ツールを統合する機能を制御します。このエンジンには、各ソフトウェア統合に固有のロジックが保持されています。ウィンドウに表示される 2 番目の項目は、現在のプロジェクト環境の配置場所のパスを示します。最後の 2 つのフォルダは config/env/ と、その後の project.yml です。project.yml ファイルは、現在の環境の設定の保存場所を案内するロードマップの起点となります。手順 16: お気に入りのテキスト エディタで project.yml を開きます。description: Apps and Engines when launching with a project only context.################################################################################includes:- ./includes/frameworks.yml- ./includes/settings/tk-3dsmaxplus.yml- ./includes/settings/tk-desktop.yml- ./includes/settings/tk-flame.yml- ./includes/settings/tk-houdini.yml- ./includes/settings/tk-mari.yml- ./includes/settings/tk-maya.yml- ./includes/settings/tk-motionbuilder.yml- ./includes/settings/tk-nuke.yml- ./includes/settings/tk-photoshopcc.yml- ./includes/settings/tk-shell.yml- ./includes/settings/tk-shotgun.yml################################################################################# configuration for all engines to load in a project contextengines:  tk-3dsmaxplus: &quot;@settings.tk-3dsmaxplus.project&quot;  tk-desktop: &quot;@settings.tk-desktop.project&quot;  tk-flame: &quot;@settings.tk-flame.project&quot;  tk-hiero: &quot;@settings.tk-nuke.hiero.project&quot;  tk-houdini: &quot;@settings.tk-houdini.project&quot;  tk-mari: &quot;@settings.tk-mari.project&quot;  tk-maya: &quot;@settings.tk-maya.project&quot;  tk-motionbuilder: &quot;@settings.tk-motionbuilder.project&quot;  tk-nuke: &quot;@settings.tk-nuke.project&quot;  tk-nukestudio: &quot;@settings.tk-nuke.nukestudio.project&quot;  tk-photoshopcc: &quot;@settings.tk-photoshopcc.project&quot;  tk-shell: &quot;@settings.tk-shell.project&quot;  tk-shotgun: &quot;@settings.tk-shotgun.project&quot;################################################################################# reference all of the common frameworksframeworks: &quot;@frameworks&quot;project.yml 内の説明の下に、includes、engines、および frameworks という 3 つのセクションがあります。includes セクションには、設定内の他の YAML ファイルを参照するファイル ポインタのリストが示されています。既定の設定のアーキテクチャでは、ファイルを常に軽量化するために、ファイルをネストし、ポインタを使用するという方法も採用しています。includes に沿ってファイルを順に移動していくと、探している構成設定にたどり着きます。これはロシアのマトリョーシカ人形と似ています。人形を開くと、その中に次の人形が入っています。このようにして、最終的に適切な構成設定が見つかります。すべてのエンジンが tk-&amp;lt;name of software application&amp;gt; として識別されています。Maya の設定に反映させたいため、求めている識別子は tk-maya になります。project.yml ファイルの includes: セクションの下で、./includes/settings/tk-maya.yml の行を探します。この行は、Maya エンジンの設定をコントロールする設定 tk-maya が、includes フォルダ内の settings フォルダ内でネストされていることを示します。engines: セクションで tk-maya 値を探します。tk-maya: &quot;@settings.tk-maya.project&quot;@ は、値が、インクルードされたファイルから取得されていることを示します。settings および project の参照は、プロジェクトの設定であることを示します。これらは既定の設定内の命名規則であり、ユーザを案内するガイドとして役立ちます。この行全体は、インクルードされたファイル内の settings.tk-maya.project ブロックを探して、Maya エンジン tk-maya の構成設定を探すようユーザに指示しています。Flow Production Tracking Toolkit は YAML ファイル内で単純な用語を使用して、設定の名前や、設定に到達するためのパスを示します。Maya の[File Open]参照ボックスを調べて気づいたように、[+New Task]ボタンの実行方法をコントロールするコード バンドルは tk-multi-workfiles2 で識別されます。Toolkit のバンドルは、YAML ファイル内でこれらの識別子を使用して参照されています。「tk-multi-workfiles2」は、Workfiles アプリのコード バンドルの識別子です。[+New Task]ボタンは、Workfiles アプリの機能です。tk-maya.yml での Workfiles アプリの検索手順 17: ファイル ブラウザ内で、env/includes/settings フォルダを参照して、tk-maya.yml を開きます。手順 18: project.yml からのインクルードの内容に沿って、tk-maya.yml ファイル内で settings.tk-maya.project を検索します。特に行いたいのは、特定のプロジェクトのプロジェクト環境内で[+New Task]ボタンを無効にすることです。プロジェクト環境内で作業しながら、このプロジェクトの設定を操作し、場所の情報を取得しました。# projectsettings.tk-maya.project:  apps:    tk-multi-about:      location: &quot;@apps.tk-multi-about.location&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-multi-shotgunpanel: &quot;@settings.tk-multi-shotgunpanel&quot;    tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;  menu_favourites:  - {app_instance: tk-multi-workfiles2, name: File Open...}  location: &quot;@engines.tk-maya.location&quot;settings.tk-maya.projects の下に、tk-multi-workfiles2 アプリの設定が次のように表示されています。tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;@ 記号は、tk-multi-workfiles2 の値がインクルードされたファイルから取得されていることを示します。tk-maya.yml の上部にある includes セクションに、以下のように表示されています。includes:...- ./tk-multi-workfiles2.yml現在のファイル config/env/includes/settings と同じディレクトリ内にある tk-multi-workfiles2.yml ファイル内で settings.tk-multi-workfiles2.launch_at_startup を検索します。手順 19: tk-multi-workfiles2.yml ファイルを開いて、settings.tk-multi-workfiles2.launch_at_startup を検索します。# launches at startup.settings.tk-multi-workfiles2.launch_at_startup:  launch_at_startup: true  entities:Maya 参照ボックスが示すように、allow_task_creation 設定には true の既定値があります。ベスト プラクティスとして、パイプライン設定には既定の設定が反映されていません。これにより、簡易形式が可能になり、既定のコードと異なる設定のみが設定に追加されます。設定が明示的に指定されていない場合は、この設定にアクセスするすべての呼び出しが既定値を受け取ります。Toolkit が設定を読み取って環境を構築するときに、この環境内で実行されているアプリ、エンジン、およびフレームワークはこのプロジェクトのパイプライン構成設定を使用し、設定の内容に基づいてすべての既定の設定をオーバーライドします。手順 20: tk-multi-workfiles2.yml の settings.tk-multi-workfiles2.launch_at_startup: の下に allow_task_creation を追加して、その値を false に設定します。# launches at startup.settings.tk-multi-workfiles2.launch_at_startup:  allow_task_creation: false  launch_at_startup: true  entities:注: Toolkit の既定の構成設定は、特定の設定を見つけやすいようにアルファベット順に編成されています。この規則に従うことにより、設定の内容が増えた場合でも作業を簡単に行うことができます。手順 21: ファイルを保存します。設定を再ロードする手順 22: Maya の[File Open]ダイアログ ボックスで参照ボックスを開き、[Reload Engines and Apps]を選択します。これにより、構成設定が再ロードされます。変更を表示する手順 23: [File Open]ダイアログ ボックスに移動して、アセットを選択します。[+New Task]ボタンが表示されないことに注目してください。これで、Workfiles アプリの構成設定を変更して、プロジェクト環境内のボタンの動作を変更できました。この設定はプロジェクト環境内で変更しただけなので、別の環境で作業を開始した場合は、[+New Task]ボタンの設定は引き続き有効になります。実際のプロダクションでも同様の変更を行うには、ここで行った変更を すべて の環境に反映する必要があります。環境を変更する手順 24: アセットの検索結果の下にあるフォルダを開いて、作業するアセットを選択します。手順 25: [+New File]を選択します。[+New File]を選択することにより、新しいアセットの作業が始まり、asset_step環境が Maya にロードされます。アーティストがアセット タスクを選択して、新しいファイルを作成するか、既存のファイルを開くと、asset_step 環境が自動的にロードされて、パイプラインのこのステージ用に設定されたツールおよび機能が表示されます。作業している環境を見つける手順 26: Maya メニューの右上で[ShotGrid]を選択します。Art, Asset Text Overlay には、作業中であること、および現在の環境が示されます。手順 27: [Art, Asset Text Overlay] &amp;gt; [Work Area Info…]を選択して、現在の作業領域に含まれているパラメータを表示します。手順 28: 下部にある[Environment]タブを選択します。設定がパイプライン設定内のどこに配置されているのかを判別するために必要な情報が、環境ごとに表示されます。アーティストが新しいタスクを追加できないようにするには、アーティストが作業する環境ごとに[+New Task]ボタンを無効にする必要があります。各環境に上記と同じ手順を使用して、設定を適切に編集します。注: 各環境は独立していて、プロジェクトには専用の設定があります。また、プロジェクトがロードされるときにソフトウェアの統合によってパイプライン設定から読み取られるのは、特定のソフトウェアの設定のみです。これでパイプライン設定の編集と、アプリの設定の変更が完了しました。ここから先は、楽しみながら作業できます。Flow Production Tracking Toolkit 環境で実行できるすべての機能について学習しましょう。次に、これから調べる高度なトピックをいくつか示します。高度なトピックこのガイドでは、単一のエンジン(tk-maya)および単一の環境(project)内のアプリの構成設定に単純な変更を加えました。また、Toolkit が環境別に整理されていることも学習しました。各環境はソフトウェアの実装ごとに一意であり、プロジェクトとタスクによって環境が絞り込まれるため、パイプライン内の定義されたポイントでアーティストが特定の機能を使用できるように設定することが可能です。このガイドで行った単純な変更を一般化して、Toolkit のパイプライン設定を詳細にカスタマイズすることができます。他のエンジンWorkfiles アプリのシステム名は tk-multi-workfiles2 です。名前内の multi は、このアプリがマルチ アプリであることを意味します。マルチ アプリはソフトウェアに依存しています。マルチ アプリの機能および関数は、Maya、Nuke、Houdini、または他の任意のサポート対象アプリのいずれで実行されているかにかかわらず、同じです。すべてのソフトウェア パッケージで Workfiles 内のタスク作成を無効にする場合は、すべてのエンジン(tk-nuke、tk-houdini など)にこのガイドの手順を実行します。他の環境プロジェクト環境でのタスク作成は無効になりましたが、実際のスタジオ環境では、アーティストが作業しているすべての環境でタスク作成を無効にしたい場合があります。そのためには、このガイドの手順に従いますが、project.yml から開始しないで、asset_step.yml、shot_step.yml などから開始します。カスタム環境を作成する既定の設定には、project、sequence、shot、shot_step、asset、および asset_step という、パイプラインに関する一連の定義済みの手順が付属しています。ただし、スタジオによっては、パイプラインのステージごとに異なる構成設定が必要な場合があります(asset_step_rig、asset_step_model、shot_step_anim、shot_step_light など)。Toolkit はカスタム環境をサポートしています。詳しくは、『環境設定リファレンス』の「カスタム環境」セクションを参照してください。ビデオのリソース  Toolkit 設定の概要(SIGGRAPH 2018 Developer Day で収録)  既定の設定の概要ウェビナーアプリの構成設定の変更に関する学習は以上です。次は、Toolkit の構成にアプリを追加してみましょう。",
    "url": "/37f575b8/",
    "relUrl": "/37f575b8/"
  },
  "42": {
    "id": "42",
    "title": "Attempted to communicate without completing encryption handshake",
    "content": "[ERROR] Attempted to communicate without completing encryption handshake使用例:Flow Production Tracking Toolkit のブラウザ統合を起動して実行するときに問題が発生しました。Flow Production Tracking Toolkit を起動すると、Web サーバが実行されていることが通知されます。[    INFO] WebSocketServerFactory (TLS) starting on 9000[    INFO] Starting factory…その後に、エラーが表示されないデバッグ レコードがロードされます。Flow Production Tracking サイトにログインすると、次のように表示されます。[ INFO] Connection accepted.プロジェクトを右クリックすると、Flow Production Tracking がアクションを取得していることが示され、次のログ出力が表示されます。[    INFO] Connection accepted.[   ERROR] Attempted to communicate without completing encryption handshake.[   ERROR] Attempted to communicate without completing encryption handshake.[    INFO] Connection closed.[   DEBUG] Reason received for connection loss: [Failure instance: Traceback (failure with no frames): : Connection to the other side was lost in a non-clean fashion: Connection lost.Flow Production Tracking でプロジェクトを開くと、次のログ出力が生成されます。[    INFO] Connection accepted.[   ERROR] Attempted to communicate without completing encryption handshake.[   ERROR] Attempted to communicate without completing encryption handshake.[   ERROR] Attempted to communicate without completing encryption handshake.[   ERROR] Attempted to communicate without completing encryption handshake.[ WARNING] dropping connection to peer tcp4:127.0.0.1:52451 with abort=True: WebSocket closing handshake timeout (peer did not finish the opening handshake in time)[    INFO] Connection closed.[   DEBUG] Reason received for connection loss: [Failure instance: Traceback (failure with no frames): : Connection to the other side was lost in a non-clean fashion: Connection lost.修正方法:プロキシ バイパス リストに shotgunlocalhost.com を追加します。このエラーの原因の例:プロキシ設定コミュニティの完全なスレッドを参照してください。",
    "url": "/2fa5964e/",
    "relUrl": "/2fa5964e/"
  },
  "43": {
    "id": "43",
    "title": "VPC Endpoints",
    "content": "VPC EndpointsComing soon.",
    "url": "/8a9c5baf/",
    "relUrl": "/8a9c5baf/"
  },
  "44": {
    "id": "44",
    "title": "環境設定リファレンス",
    "content": "環境設定リファレンスはじめにToolkit パイプラインの中心にあるのは環境設定です。Toolkit パイプライン設定内の環境構成ファイルでは、さまざまな DCC 内で使用可能な Toolkit アプリを定義し、それぞれの設定をカスタマイズできます。このドキュメントは環境設定ファイルの構造と機能についての完全なリファレンスです。ここでは、プロジェクト内のさまざまなワークフローを設定するための Toolkit の**「環境」の概念、環境設定の構成、ファイル参照、そしてどのようなカスタマイズが行えるかを確認する方法について説明します。                    注: このドキュメントは環境設定ファイルのリファレンスとして使用しますが、『パイプライン設定の編集に関する Toolkit の基本ガイド』には、構成設定を編集するステップバイステップの手順が例として記載されています。    環境についてFlow Production Tracking Toolkit プラットフォームは、一般的に使用されるコンテンツ作成ソフトウェアのための完全にカスタマイズ可能な統合セットを提供するため、これを使用してスタジオのパイプラインを構築できます。プロジェクトの構成において、統合されているソフトウェア パッケージはどれか、そのそれぞれで利用可能な Toolkit アプリはどれかを指定し、さらに各アプリのオプションを指定することにより、スタジオのニーズに合わせてアーティストのワークフローを構築できます。しかし、スタジオのパイプラインでは、さまざまなタイプのアーティストが異なるワークフローを使用するのが一般的です。簡単な例として、アセットを扱うアーティストの場合は Mari などのテクスチャ ペイント ソフトウェアを利用可能にし、ショットを扱うアーティストの場合は Nuke などの合成ソフトウェアを利用可能にします。ソフトウェア パッケージの他にも、異なるアーティストに対して、同じ Toolkit アプリで異なる設定を使用することができます。たとえば、ショットのアーティストとアセットのアーティストの両方が Workfiles アプリを使用することがありますが、ショットのアーティストは Shot エンティティ、アセットのアーティストは Asset エンティティに関連付けられているファイルにのみナビゲートできるように制限することができます。プロジェクト内でこれらの個別のワークフローをサポートするために、Toolkit はアプリとエンジンの構成を環境上で分離しています。環境には、一連のソフトウェア パッケージの統合とその設定が含まれています。それらのすべてには、特定の共通するコンテキストがあります。上記の例では、アセットを扱うアーティストはアセットの手順の環境で作業し、ショットを扱うアーティストはショットの手順の環境で作業しています。環境はそれぞれ独立して構成されているため、プロジェクト内で異なるワークフローを使用できます。Toolkit の既定の設定に関するメモToolkit での環境設定の構築には多くの自由が与えられています。このドキュメントは利用可能なすべてのオプションのリファレンスで、実際のパイプラインのニーズに最も適した選択をするのに必要な知識を得ることができます。またこのドキュメントでは、既定の設定と呼ばれる、パイプライン設定の出発点として選択された特別な設定についても説明します。パイプラインをカスタマイズする準備が整ったら、最初の手順はプロジェクト用の編集可能なパイプライン設定を作成することです。これらの選択は単なる規則であり、Toolkit のワークフローにハードコードされているわけではありませんが、既定の設定を例として参照すると、パイプラインのカスタマイズを開始した後に使用できる機能や、独自の設定を構築するためのベスト プラクティスについて学ぶことができます。また、新しい Toolkit ユーザが既定の設定を出発点として参照すれば、Toolkit の規則について知るのにも役立ちます。このドキュメントでは、Toolkit の環境設定の一般的な機能と、既定の設定における特定の選択とを常に区別します。既定の設定の環境構成の詳細については、README ファイルを参照してください。ファイルの場所パイプライン設定内の config/ ディレクトリには、カスタマイズ対象のすべてのファイルとフォルダが含まれています。config/ には、cache、core、および env の 3 つのサブディレクトリがあります。env ディレクトリには環境設定ファイルが保持されるため、このドキュメントでは config/env 内のファイルを参照します。既定の設定では、config/env/ に次のファイルが表示されます。asset.ymlasset_step.ymlproject.ymlsequence.ymlshot.ymlshot_step.ymlこれらの各ファイルは環境に対応しています。異なるファイルを含めることで、各環境を別々に設定できます。Toolkit が現在の環境を判断する仕組みToolkitは pick_environment というコア フックを使用し、現在のコンテキストに基づいて特定の時点で使用する環境ファイルを決定します。pick_environment フックの戻り値は環境設定ファイルに対応しています。たとえば、pick_environment が shot_step を返した場合、Toolkit は config/env/shot_step.yml を使用して Toolkit 環境を設定します。カスタム環境上記の環境設定ファイルは、既定の設定で提供されます。ただし、スタジオによっては、異なる環境や追加の環境を採用することがあります。たとえば、スタジオによっては、パイプラインのステージごとに異なる構成設定が必要な場合があります(asset_step_rig、asset_step_model、shot_step_anim、shot_step_light など)。 その場合、利用可能な環境を完全にカスタマイズできます。これを行うには、目的の環境設定ファイルを config/env ディレクトリに追加します。次に、pick_environment コア フックをオーバーライドして、新しい環境をいつ使用するかを定義するロジックを追加します。基本構造Toolkit の設定ファイルは YAML で記述されます。バンドル(アプリ、エンジン、またはフレームワーク)の一般的な設定の構成は次のとおりです。bundle_name:  setting1: value  setting2: value  complex_setting:    sub_setting1: value      Sub_setting2: value  location:    type: descriptor_type    descriptor_setting1: value    descriptor_setting2: valueこの構成を説明するために、非常に単純な例を示します。単一のエンジンがあり、その中に単一のアプリケーションが定義されている環境です。以下は、この設定の project.yml の内容です。engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4エンジン ブロックすべての環境設定ファイルは engines ブロックで始まります。ここに、その環境用に定義されているすべてのエンジンがネストされています。この例では、単一のエンジン tk-maya のみが定義されています。apps と location の 2 つの設定がリストされています。location はすべてのバンドルに必要な特別な設定です。apps 設定はエンジンに定義されたすべてのアプリのリストで、それぞれ独自の設定があります。この場合、エンジンに対して定義されるアプリは 1 つのみです(tk-multi-workfiles2)。ロケーション ディスクリプタすべての Toolkit バンドルには location 設定があり、これをバンドルの**「ディスクリプタ」と呼びます。ディスクリプタは、特定のバンドルの入手元、およびそのタイプに応じて直接アクセスするかローカルにキャッシュするかを Toolkit に指示します。Toolkit バンドルを入手できる場所の例としては、Flow Production Tracking App Store、GIT リポジトリ、ディスク上のパス、または Flow Production Tracking サイトにアップロードされた zip ファイルなどがあります。これらには、それぞれ対応するディスクリプタ タイプがあり、そのタイプに固有の設定があります。以下に、上記の例の tk-maya エンジンのディスクリプタをもう一度示します。    location:        type: app_store        name: tk-maya        version: v0.9.4これはタイプ app_store のディスクリプタで、指定されたバンドルを Flow Production Tracking App Store から入手するよう Toolkit に指示します。タイプ app_store のディスクリプタの設定は name と version です。対照的に、スタジオでカスタム バンドルをアクティブに開発している場合、たとえば特定のワークフロー用の Toolkit アプリを作成している場合は、ディスク上のパスから直接入手することができます。この場合、以下に示すようにタイプ dev のディスクリプタを使用します。    location:        type: dev        path: /path/to/appdev ディスクリプタは app_store ディスクリプタとは設定が異なります。他の設定を使用することもできますが、ディスク上のアプリの場所を参照する path 設定を使用して簡単にセットアップすることができます。利用可能なすべてのディスクリプタ タイプとその設定に関する詳細は、Toolkit Core API ドキュメントの「ディスクリプタ」セクションを参照してください。アプリ ブロックアプリは Toolkit のユーザ ツールであり、各アプリは他のアプリから独立して実行できます。パイプラインのニーズに基づいてどのアプリを使用するかを選択できます。エンジン ブロック内の apps 設定は、特定のエンジンで使用できるアプリを定義します。以下に、上記の例の apps 設定をもう一度示します。engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8単一のアプリ、tk-multi-workfiles2 アプリが定義されていることがわかります。現在のところ、単一の設定、すなわちディスクリプタのみが定義されています。project 環境の tk-maya エンジンで他のアプリを利用できるようにするには、ここで追加します。ここでは、エンジンに Panel、tk-multi-shotgunpanel、および About アプリ、tk-multi-about を追加します。例の project.yml ファイルは次のようになります。engines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4ここでは、いくつかの重要な注意事項があります。  既定の設定ではバンドルがアルファベット順にリストされ、この例ではその規則に従います。  ファイルが長くなり始めていますが、構成設定はまだ追加していません。  他のエンジンや他の環境でこれらと同じアプリを使用していることが想像できます。たとえば、Panel、About アプリ、Workfiles アプリの 3 つのすべてのアプリが、異なるエンジン(Houdini、Nuke、Photoshop など)および異なる環境(asset_step や shot_step)で実行されている可能性があります。設定内の異なる場所で共通のアプリ設定を定義することは、変更が必要なときに、それぞれの場所で変更が必要になることを意味します。最後の 2 つの問題を軽減するために、Toolkit 設定はインクルードをサポートします。インクルード「インクルード」を使用すると、あるファイルのセクションを構成内の別のファイルで参照できます。インクルードを使用すると、構成設定を一箇所で設定し、複数の環境で使用できます。インクルードは次の 2 つの部分で構成されます。  includes リスト: キーが includes で、インクルードするすべてのファイルのリストを値に持つ YAML 辞書。  構成設定内のリファレンス。@ 記号で始まり、インクルード ファイルから参照するセクションの名前をポイントする名前が付けられています。上記の例を具体化するために、すべてのエンジンのロケーション ディスクリプタを保持する単一のファイルを作成しているとします。そのファイルを includes サブフォルダに置き、engine_locations.yml という名前を付けます。engine_locations.yml の内容は以下のようになります。config/env/includes/engine_locations.yml:engines.tk-maya.location:  type: app_store  name: tk-maya  version: v0.9.4engines.tk-nuke.location:  type: app_store  name: tk-nuke  version: v0.11.5...このファイルはすべてのエンジンの場所に対する単一のソースとして機能し、すべての環境設定から参照することができます。このインクルード ファイルを使用した場合、この例は次のようになります。config/env/project.yml:includes:- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location: @engines.tk-maya.locationここでは、tk-maya エンジンの location 設定の値が、インクルードされる YAML ファイルのキーを参照していることがわかります。                    注: この例では、既定の設定の規則に従い、すべてのエンジンの場所を config/env/includes/engine_locations.yml ファイルに含めています。    アプリの場所を示すために、2 番目のインクルード ファイルを追加することができます。実際には、これは既定の設定によって行われます。例を拡張してみましょう。config/env/includes/app_locations.yml:apps.tk-multi-about.location:  type: app_store  name: tk-multi-about  version: v0.2.8apps.tk-multi-shotgunpanel.location:  type: app_store  name: tk-multi-shotgunpanel  version: v1.6.3apps.tk-multi-workfiles2.location:  type: app_store  name: tk-multi-workfiles2  version: v0.11.8config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.locationインクルードされた engine_locations.yml ファイルから tk-maya エンジンのディスクリプタを取得し、インクルードされた app_locations.yml ファイルから tk-maya エンジン用に定義された各アプリのディスクリプタを取得します。                    注: 既定の設定では、この例では示されていない 2 番目のネスト レベルを使用しています。単なるディスクリプタ以上の設定を持つすべてのアプリまたはエンジンは、includes/settings に設定ファイルがあります(例: includes/settings/tk-maya.yml、includes/settings/tk-multi-workfiles2.yml)。エンジン設定ファイルには、アプリ設定ファイルからのアプリ設定が含まれ、環境設定ファイルにはエンジン設定ファイルからの設定が含まれています。既定の設定の構造の詳細については、README ファイルを参照してください。構成設定の変更に関する詳細な手順については、『構成設定の編集に関する Toolkit の基本ガイド』を参照してください。    スパース構成すべての Toolkit バンドルには、使用可能な構成設定のセットがあり、それぞれの設定に既定値があります。Toolkit は**「スパース構成」を許可します: 構成設定が環境設定ファイル(またはそこに含まれるファイル)で明示的に指定されていない場合、バンドルの既定値が使用されます。この例では、location 以外にアプリの設定を指定していません。したがって、設定の現在の状態では、3 つのアプリはすべての設定に既定値を使用します。それでは、どの構成設定が利用可能であるかを知るにはどうすれば良いでしょうか。                    注: Toolkit の構成がスパース構成であることは必須ではありませんが、既定の設定はスパース構成です。    利用可能な構成設定を検出するスパース構成では、単に設定ファイルを見ただけでは、どの構成設定がアプリに使用できるかをすぐに判断することはできません。アプリで利用可能な構成設定を確認する場合、2 つの選択肢があります。  アプリのドキュメント: 各アプリには独自のドキュメント ページがあり、それぞれのページに「設定オプション」セクションがあります。このセクションでは、アプリで使用可能なすべての構成設定が、それぞれの説明と既定値と共に一覧表示されています。たとえば、Workfiles ドキュメント ページを参照することができます。アプリとエンジンのページには、すべてのアプリとエンジンのドキュメント ページが一覧表示されています。  マニフェスト: すべての Toolkit バンドルは、そのルート ディレクトリに info.yml というファイルを含んでいます。このファイルをバンドルの**「マニフェスト」と呼び、バンドルで利用可能なすべての設定を、それぞれの説明と既定値と共に定義します。マニフェストは、バンドルの独自のキャッシュ(パイプライン設定内の install/app_store/tk-multi-workfiles2/v0.11.8/info.yml など)、または Github (ここでは Workfiles の場合の例を示します)にあります。構成設定を修正する既定値の設定を変更するには、パイプライン設定の適切な環境で、適切なブロックに構成を追加し、その値を設定します。例に戻って、プロジェクト環境で Maya が起動されると tk-multi-workfiles2 が自動的に起動するように設定してみましょう。アプリのマニフェストを見ると、アプリの起動時に Workfiles UI を起動するかどうかを制御する launch_at_startup 設定があり、その既定値が False であることがわかります。そこで、launch_at_startup オプションを追加して True に設定します。project.yml ファイルは次のようになります。config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        launch_at_startup: True        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.locationtk-multi-workfiles2 の設定がインクルード ファイルからのものである場合は、そのファイルでこの変更を行います。その他の参考情報  Toolkit の基本ガイド: パイプライン設定を編集する  Toolkit の基本ガイド: アプリを追加する  アニメーション パイプラインのチュートリアル  ディスクリプタのリファレンス ドキュメント  ウェビナー: Toolkit の管理  ファイル システム設定リファレンス  既定の設定の環境構成に関する README",
    "url": "/487a9f2c/",
    "relUrl": "/487a9f2c/"
  },
  "45": {
    "id": "45",
    "title": "EOF occurred in violation of protocol",
    "content": "SSLError: [Errno 8] _ssl.c:504: EOF occurred in violation of protocol使用例Desktop から Nuke 10.5 を開くと、次の SSL エラーが表示されます。[13:57.14] ERROR: Shotgun Error: [ERROR tk-nuke] App /media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2 failed to initialize. It will not be loaded.Traceback (most recent call last):File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank/platform/engine.py”, line 2792, in __load_appsapp.init_app()File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/app.py”, line 26, in init_appself._tk_multi_workfiles = self.import_module(“tk_multi_workfiles”)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank/platform/bundle.py”, line 462, in import_moduleself.__module_uid, None, python_folder, (&quot;&quot;, “”, imp.PKG_DIRECTORY)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/init.py”, line 11, infrom . import tk_multi_workfilesFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/init.py”, line 14, infrom .file_open_form import FileOpenFormFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/file_open_form.py”, line 19, infrom .actions.file_action_factory import FileActionFactoryFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/actions/file_action_factory.py”, line 19, infrom .interactive_open_action import InteractiveOpenActionFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/actions/interactive_open_action.py”, line 17, infrom .open_file_action import OpenFileActionFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/actions/open_file_action.py”, line 22, infrom …work_area import WorkAreaFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/work_area.py”, line 19, infrom .user_cache import g_user_cacheFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/user_cache.py”, line 203, ing_user_cache = UserCache()File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/user_cache.py”, line 32, in initself._current_user = sgtk.util.get_current_user(self._app.sgtk)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank/util/login.py”, line 125, in get_current_user“HumanUser”, filters=[[“login”, “is”, current_login]], fields=fieldsFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 882, in find_oneadditional_filter_presets=additional_filter_presets)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 1003, in findadditional_filter_presets)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 1072, in _construct_read_parametersparams[“paging”] = {“entities_per_page”: self.config.records_per_page,File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 471, in records_per_pageself._records_per_page = self._sg.server_info.get(“api_max_entities_per_page”) or 500File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 763, in server_inforeturn self.server_caps.server_infoFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 778, in server_capsself._server_caps = ServerCapabilities(self.config.server, self.info())File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 833, in inforeturn self._call_rpc(“info”, None, include_auth_params=False)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank/authentication/shotgun_wrapper.py”, line 63, in _call_rpcreturn super(ShotgunWrapper, self)._call_rpc(*args, **kwargs)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 3302, in _call_rpcencoded_payload, req_headers)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 3442, in _make_callreturn self._http_request(verb, path, body, req_headers)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 3496, in _http_requestresp, content = conn.request(url, method=verb, body=body, headers=headers)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 2192, in requestcachekey,File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 1845, in _requestconn, request_uri, method, body, headersFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 1750, in _conn_requestconn.connect()File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 1399, in connectself.key_password,File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 109, in _ssl_wrap_socketssl_version=ssl_version,File “/usr/local/Nuke10.5v7/lib/python2.7/ssl.py”, line 381, in wrap_socketciphers=ciphers)File “/usr/local/Nuke10.5v7/lib/python2.7/ssl.py”, line 143, in initself.do_handshake()File “/usr/local/Nuke10.5v7/lib/python2.7/ssl.py”, line 305, in do_handshakeself._sslobj.do_handshake()SSLError: [Errno 8] _ssl.c:504: EOF occurred in violation of protocolこれは、Nuke バージョン 11 または 12 では発生しません。修正方法表示されている問題の原因は、Nuke 10.x が TLS 1.2 に準拠していないことです。ソフトウェアは TLS に準拠している必要があります。関連リンクコミュニティの完全なスレッドを参照してください。",
    "url": "/4947c1f4/",
    "relUrl": "/4947c1f4/"
  },
  "46": {
    "id": "46",
    "title": "Nuke Studio でのエピソード ワークフロー",
    "content": "Nuke Studio でのエピソード ワークフロー概要および準備作業この記事では、Nuke Studio または Hiero で tk-hiero-export アプリを使用してエピソード ワークフローを起動および実行する方法について説明します。この方法が 1 つだけではないことに注意してください。目的のワークフローごとに方法は若干異なります。この例では、次のように仮定します。  目標は、Episode &amp;gt; Sequence &amp;gt; Shot という 3 つの層からなる階層を設定することです。  ファイル システム設定ガイドに記載された手順を参照して完了します。  Episode エンティティ タイプを使用します(CustomEntity02 ではありません。両方とも同じ方法で機能することができ、名前だけが異なります)。  Sequence エンティティに episode というエンティティ フィールドがあります。  Nuke Studio を使用しますが、プロセスは Hiero と同じです。  Toolkit プロジェクトの既定の設定から開始します。開始する前に決定しなければならないことがもう 1 つあります。それは、Episode の解決方法です。すぐに使える Flow Production Tracking Hiero/Nuke Studio の書き出しプロセスにより、Nuke Studio プロジェクトの内容に基づいて、Flow Production Tracking サイトに Sequence および Shot エンティティが作成されます。Toolkit を使用して Maya で作業する場合のように、アセットやタスクが既に作成されていると想定される場合と異なり、Nuke Studio では Episodes Sequences または Shots が既に作成されていると想定されません。そのため、Nuke Studio では Episode の定義方法をユーザが決定する必要があります。ここで使用できるオプションはいくつかあります。  Flow Production Tracking でエピソードをあらかじめ作成し、エピソードのコンテキストで機能するように Nuke Studio Toolkit の統合を設定します。こうすることで、書き出すときに、現在のシーンのコンテキストから Episode エンティティを取得することができます。  Episode エンティティがまだ作成されていないと想定して、Nuke Studio のタグ付け機能を利用してシーケンスにエピソード名をタグ付けし、書き出すときに Episode を解決します。使用しているワークフローに適した別の方法が存在する可能性があります。たとえば、Nuke Studio のシーケンス名やショット名の一部からエピソード名を抽出する(例: シーケンス「ep1_s01」から「ep1」を取り出す)などの方法があります。または、書き出しアプリの hiero_customize_export_ui.py フックを使用して、書き出しとエピソードをリンクするための GUI を追加することができます。この例では、2 番目のオプションである、シーケンスのタグ付けによる解決策を使用します。この手順の目的は、階層の 3 つのレイヤ(Episode &amp;gt; Sequence &amp;gt; Shot)を実装することです。Sequence エンティティ タイプを Episodes エンティティ タイプで単に置き換えるプロセス(Episode &amp;gt; Shot)の方が簡単です。このシナリオについては、このガイドの最後の方で簡単に説明しますが、残りの説明を参照して理解を深めることをお勧めします。スキーマとテンプレート前述のとおり、この例では、スキーマとテンプレートが更新されていることを前提としています。templates.yml 内の hiero_plate_path および hiero_render_path パスの値も更新されていて、正しい部分にエピソード キーが格納されていることを確認します。フックと設定Flow Production Tracking 書き出しプロセスを取得して Episode を正しく処理するには、書き出しフックの一部を変更する必要があります。この記事では、ユーザがフックの概要について理解していて、基本的な実装のオーバーライドに慣れていると想定しています。エピソードを有効にするのに役立つ書き出しフックは 2 つあります。  hiero_get_shot.py  hiero_resolve_custom_strings.py注: hiero_translate_template.py という 3 番目のフックがあります。この例ではこのフックを使用しませんが、シーケンスをエピソードで置き換えて、2 つのレイヤからなる階層を維持することのみを行う場合は、このフックが必要になります。これについては、記事の最後で少し詳しく説明します。エピソードを検索して、Flow Production Tracking でこれに該当するエントリを作成できるように、hiero_get_shot.py を変更します。また、Nuke Studio がパス内の {Episode} キーに指定する値を取得できるように、hiero_resolve_custom_strings.py を変更します。次に、このステップの詳細を示します。1.エピソード フィールドの追加テンプレートに Episode というキーが追加されたため、tk-hiero-export アプリにその解決方法を指定する必要があります。&amp;lt;pipeline_configuration&amp;gt;/config/env/includes/settings/tk-hiero-export.yml ファイル内の custom_template_fields を次のように変更します。 settings.tk-hiero-export:      custom_template_fields: [{keyword: Episode, description: The episode name}]   ... {Episode}こうすると、 という名前の有効な書き出しトークンが Hiero エクスポータに追加されます。2. hiero_get_shot フックhiero_get_shot.py フックを使用して、書き出しプロセスにエピソード名を検索し、Flow Production Tracking で Episode を作成する方法を指定する必要があります。既定バージョンのフック(hiero_get_shot.py)は、Flow Production Tracking から TrackItem と同じ名前を持つ Shot を返します。Nuke Studio シーケンス項目と同じ名前を持つ Sequence に Shot をリンクする必要もあります。Sequence または Shot が Flow Production Tracking 内になければ、フックによって作成されます。別の階層レベルが追加されるため、Episode が存在しなければこれも作成するようにフックに指示する必要があります。また、Sequence は Episode にリンクされているため、Sequence を検索するコード(get_shot_parent() メソッド)にこれを関連付ける必要があります。環境設定のフック フォルダ内に hiero_get_shot.py ファイルを作成し、hook_get_shot: '{config}/hiero_get_shot.py' を tk-hiero-export.yml 設定に追加します。次のようになります。 settings.tk-hiero-export:      custom_template_fields: [{keyword: Episode, description: The episode name}]      hook_get_shot: '{config}/hiero_get_shot.py' hiero_get_shot.py次に、 フックのコード全体を示します。作成したフックにこのコードを追加します。from sgtk import Hookclass HieroGetShot(Hook):    &quot;&quot;&quot;    Return a  Flow Production Tracking  Shot dictionary for the given Hiero items    &quot;&quot;&quot;    def execute(self, task, item, data, **kwargs):        &quot;&quot;&quot;        Takes a hiero.core.TrackItem as input and returns a data dictionary for        the shot to update the cut info for.        &quot;&quot;&quot;       # get the parent entity for the Shot       parent = self.get_shot_parent(item.parentSequence(), data, item=item)       # shot parent field       parent_field = &quot;sg_sequence&quot;       # grab shot from  Flow Production Tracking        sg = self.parent.shotgun       filter = [           [&quot;project&quot;, &quot;is&quot;, self.parent.context.project],           [parent_field, &quot;is&quot;, parent],           [&quot;code&quot;, &quot;is&quot;, item.name()],        ]       # default the return fields to None to use the python-api default       fields = kwargs.get(&quot;fields&quot;, None)       shots = sg.find(&quot;Shot&quot;, filter, fields=fields)       if len(shots) &amp;gt; 1:           # can not handle multiple shots with the same name           raise StandardError(&quot;Multiple shots named '%s' found&quot;, item.name())       if len(shots) == 0:           # create shot in            shot_data = {               &quot;code&quot;: item.name(),               parent_field: parent,               &quot;project&quot;: self.parent.context.project,           }           shot = sg.create(&quot;Shot&quot;, shot_data, return_fields=fields)           self.parent.log_info(&quot;Created Shot in  Flow Production Tracking : %s&quot; % shot_data)       else:           shot = shots[0]       # update the thumbnail for the shot       upload_thumbnail = kwargs.get(&quot;upload_thumbnail&quot;, True)       if upload_thumbnail:           self.parent.execute_hook(               &quot;hook_upload_thumbnail&quot;,               entity=shot,               source=item.source(),               item=item,               task=kwargs.get(&quot;task&quot;)           )       return shot    def get_episode(self, data=None, hiero_sequence=None):        &quot;&quot;&quot;        Return the  episode for the given Nuke Studio items.        We define this as any tag linked to the sequence that starts        with 'Ep'.        &quot;&quot;&quot;       # If we had setup Nuke Studio to work in an episode context, then we could       # grab the episode directly from the current context. However in this example we are not doing this but here       # would be the code.       # return self.parent.context.entity       # stick a lookup cache on the data object.       if &quot;epi_cache&quot; not in data:           data[&quot;epi_cache&quot;] = {}       # find episode name from the tags on the sequence       nuke_studio_episode = None       for t in hiero_sequence.tags():           if t.name().startswith('Ep'):               nuke_studio_episode = t               break       if not nuke_studio_episode:           raise StandardError(&quot;No episode has been assigned to the sequence: %s&quot; % hiero_sequence.name())       # For performance reasons, lets check if we've already added the episode to the cache and reuse it       # Its not a necessary step, but it speeds things up if we don't have to check  for the episode again       # this session.       if nuke_studio_episode.guid() in data[&quot;epi_cache&quot;]:           return data[&quot;epi_cache&quot;][nuke_studio_episode.guid()]       # episode not found in cache, grab it from  Flow Production Tracking        sg = self.parent.shotgun       filters = [           [&quot;project&quot;, &quot;is&quot;, self.parent.context.project],           [&quot;code&quot;, &quot;is&quot;, nuke_studio_episode.name()],       ]       episodes = sg.find(&quot;Episode&quot;, filters, [&quot;code&quot;])       if len(episodes) &amp;gt; 1:           # can not handle multiple episodes with the same name           raise StandardError(&quot;Multiple episodes named '%s' found&quot; % nuke_studio_episode.name())       if len(episodes) == 0:           # no episode has previously been created with this name           # so we must create it in            epi_data = {               &quot;code&quot;: nuke_studio_episode.name(),               &quot;project&quot;: self.parent.context.project,           }           episode = sg.create(&quot;Episode&quot;, epi_data)           self.parent.log_info(&quot;Created Episode in  Flow Production Tracking : %s&quot; % epi_data)       else:           # we found one episode matching this name in , so we will resuse it, instead of creating a new one           episode = episodes[0]       # update the cache with the results       data[&quot;epi_cache&quot;][nuke_studio_episode.guid()] = episode       return episode    def get_shot_parent(self, hiero_sequence, data, **kwargs):        &quot;&quot;&quot;        Given a Hiero sequence and data cache, return the corresponding entity        in  Flow Production Tracking  to serve as the parent for contained Shots.        :param hiero_sequence: A Hiero sequence object        :param data: A dictionary with cached parent data.        .. note:: The data dict is typically the app's `preprocess_data` which maintains the cache across invocations of this hook.                        &quot;&quot;&quot;         # stick a lookup cache on the data object.         if &quot;parent_cache&quot; not in data:             data[&quot;parent_cache&quot;] = {}                 if hiero_sequence.guid() in data[&quot;parent_cache&quot;]:             return data[&quot;parent_cache&quot;][hiero_sequence.guid()]                 episode = self.get_episode(data, hiero_sequence)                 # parent not found in cache, grab it from  Flow Production Tracking                  sg = self.parent.shotgun filter = [             [&quot;project&quot;, &quot;is&quot;, self.parent.context.project],             [&quot;code&quot;, &quot;is&quot;, hiero_sequence.name()],             [&quot;episode&quot;, &quot;is&quot;, episode],             ]                 # the entity type of the parent.         par_entity_type = &quot;Sequence&quot;                 parents = sg.find(par_entity_type, filter)         if len(parents) &amp;gt; 1:             # can not handle multiple parents with the same name             raise StandardError(                 &quot;Multiple %s entities named '%s' found&quot; % (par_entity_type, hiero_sequence.name())                 )                     if len(parents) == 0:             # create the parent in              par_data = {                 &quot;code&quot;: hiero_sequence.name(),                 &quot;project&quot;: self.parent.context.project,                 &quot;episode&quot;: episode,                 }                         parent = sg.create(par_entity_type, par_data)             self.parent.log_info(                 &quot;Created %s in  Flow Production Tracking : %s&quot; % (par_entity_type, par_data)                )        else:             parent = parents[0]                         # update the thumbnail for the parent         upload_thumbnail = kwargs.get(&quot;upload_thumbnail&quot;, True)                 if upload_thumbnail:             self.parent.execute_hook(                 &quot;hook_upload_thumbnail&quot;, entity=parent, source=hiero_sequence, item=None             )                     # cache the results         data[&quot;parent_cache&quot;][hiero_sequence.guid()] = parent         return parent シーケンスを取得する上記のコードを使用して、get_shot_parent() メソッドを変更しました。Sequence を検索して作成するときに、新しい get_episode() メソッドから Episode が返されるようになりました。Flow Production Tracking データベース内に既存の Sequence があることを確認するときに、episode&amp;lt;/code&amp;lt; field でフィルタされるようになりました。Sequence を作成すると、シーケンスの episode フィールドに get_episode() から返された Episode が入力されます。エピソードを取得するエピソードを取得するには、どのようにしますか。get_episode() メソッド コードは get_shot_parent() メソッドと非常によく似ていますが、Sequence でなく Episode を取得するように変更されています。このガイドでは、タグを使用して Nuke Studio でエピソードを割り当てています。たとえば、Nuke Studio で「Ep01」というタグを作成できます。作成したら、Nuke Studio でこのタグをシーケンスに適用します。高度な get_episode() メソッドは、Nuke Studio 内のシーケンス項目に適用されるすべてのタグを参照します。先頭に文字列「Ep」が付いているタグが見つかった場合は、これがエピソード名を定義するタグと見なされます。このメソッドを実行すると、Flow Production Tracking 内で一致する Episode が検索されて、返されます。まだ存在しない場合は、作成されます。この情報もキャッシュされるため、コストのかかる検索呼び出しを再実行する必要はありません。エピソードを別の方法(コンテキストから取得する、またはシーケンス名やショット名の最初のセクションを取得するなど)で取得する場合は、この方法のロジックを使用します。ショットを取得するhiero_get_shot フックの主な目的は、Flow Production Tracking のショット データを返すことです。実際は、ショットを取得するためのロジックを変更する必要はありません。変更する必要があるのは、Sequence で親を取得する方法のみです。カスタム フィールドを使用して Shot と Episode のリンクも行う場合は、その実行メソッド内のコードを変更する必要があります。parent[“episode”] のように Sequence から Episode にアクセスし、作成呼び出し内でこれをショットにリンクします。3.Hiero_resolve_custom_strings.py引き継ぐ必要がある 2 番目のフックは hiero_resolve_custom_strings.py です。このフックによって、Nuke Studio の書き出し用パスを解決することができます。ここでも、フック フォルダ内にフックを作成し、tk-hiero-export.yml ファイルに設定 hook_resolve_custom_strings: {config}/hiero_resolve_custom_strings.py を追加する必要があります。ステップ 1 で追加したカスタム キー {Episode} がこのフックに渡され、書き出し用アプリは解決されたフォルダ名が返されると予測しますフックは、渡されたキーが {Episode} であるかどうかを確認する必要があります。キーが条件を満たす場合は、hiero_get_shot.py フック内の get_episode() メソッドを再利用して、Episode エンティティを取得します。Episode が取得されたら、コードはエピソードの名前を抽出して、フォルダを生成できます。次に、このフックのコード全体を示します。from sgtk import Hookclass HieroResolveCustomStrings(Hook):    &quot;&quot;&quot;Translates a keyword string into its resolved value for a given task.&quot;&quot;&quot;    # cache of shots that have already been pulled from     _sg_lookup_cache = {}    def execute(self, task, keyword, **kwargs):        &quot;&quot;&quot;        The default implementation of the custom resolver simply looks up        the keyword from the  shot dictionary.        For example, to pull the shot code, you would simply specify 'code'.        To pull the sequence code you would use 'sg_sequence.Sequence.code'.        &quot;&quot;&quot;        if keyword == &quot;{Episode}&quot;:            episode_entity = self.parent.execute_hook_method(                &quot;hook_get_shot&quot;,                &quot;get_episode&quot;,                data=self.parent.preprocess_data,                hiero_sequence=task._item.parentSequence(),            )            # hard coded to return the name of the episode            # if however your folder for the episode in the schema, is not just made up from the code field            # you need to get it to return what ever string value the folder would normally be created with.            return episode_entity['code']        shot_code = task._item.name()        # grab the shot from the cache, or the get_shot hook if not cached        sg_shot = self._sg_lookup_cache.get(shot_code)        if sg_shot is None:            fields = [ctf['keyword'] for ctf in self.parent.get_setting('custom_template_fields')]            sg_shot = self.parent.execute_hook(                &quot;hook_get_shot&quot;,                task=task,                item=task._item,                data=self.parent.preprocess_data,                fields=fields,                upload_thumbnail=False,            )            self._sg_lookup_cache[shot_code] = sg_shot        self.parent.log_info(&quot;_sg_lookup_cache: %s&quot; % (self._sg_lookup_cache))        if sg_shot is None:            raise RuntimeError(&quot;Could not find shot for custom resolver: %s&quot; % keyword)        # strip off the leading and trailing curly brackets        keyword = keyword[1:-1]        result = sg_shot.get(keyword, &quot;&quot;)        self.parent.log_debug(&quot;Custom resolver: %s[%s] -&amp;gt; %s&quot; % (shot_code, keyword, result))        return result スキーマのエピソード フォルダの名前が code フィールド以外から生成されている場合は、ここでこの名前を置き換える必要があります。より適切で、複雑な方法は、templates.yml で episode_root テンプレートを追加して、このテンプレートからフィールドを取得することです。この方法の場合、スキーマ内のエピソード フォルダの名前を変更したときでも、返されたフォルダ名はスキーマと常に一致します。コードは次のようになります。ctx = tk.context_from_entity(&quot;Episode&quot;, episode_entity[id])my_template = tk.templates[&quot;episode_root&quot;]fields = my_template.get_fields(ctx.filesystem_locations[0])return fields[&quot;Episode&quot;] まとめ以上です。後は、変更内容が適切に機能するかテストするだけです。Nuke Studio を起動し、プロジェクトを作成し、シーケンスや映像を入力したので、書き出しプロセスをテストすることができます。まず、エピソード タグを作成します。Ep で開始するシーケンスのタグを検索するフックがコーディングされているため、タグに Ep… という名前を付ける必要があります。シーケンスにタグを追加します。完了したら、タグの付いたシーケンスからショットを書き出します。構造の書き出しの階層がスキーマの階層と一致することを確認します。一致しない場合は、構造を更新しなければならない可能性があります。[書き出し] (export)をクリックすると、Flow Production Tracking サイト内にエピソード、シーケンス、およびショットが作成され、ディスク上にフォルダ構造が作成されます。この方法で問題が生じた場合は、Nuke Studio スクリプト エディタまたは Flow Production Tracking のログ(tk-nukestudio.log)で、発生した可能性のあるエラーがないか確認してください。これでこのガイドは完了です。もちろん、これはエピソードを処理する複数の方法の中の 1 つにすぎません。ご使用のスタジオに最適な方法および構造を特定するのは、ユーザの役割です。エピソードのシーケンスを切り替える上で簡単に説明したように、エピソード/ショットの既定のシーケンス/ショット階層を単に切り替える場合は、エピソード名のソースとして Nuke Studio のシーケンス項目を使用することができます。      エピソード/ショット構造を使用するスキーマおよびテンプレートを設定します。        上記のような既定の hiero_get_shot.py フックを引き継ぎます。ただし、今回は parent_field 変数の値を sg_episode に変更し(ショット エンティティ内にエピソード フィールドがあることを確認します)、par_entity_type variable value to Episode。        hiero_translate_template.py フックを引き継いで、フック ファイル内のマッピングを変更します。   mapping = {   &quot;{Episode}&quot;: &quot;{sequence}&quot;,   &quot;{Shot}&quot;: &quot;{shot}&quot;,   &quot;{name}&quot;: &quot;{clip}&quot;,   &quot;{version}&quot;: &quot;{tk_version}&quot;,} Nuke Studio のシーケンス キー値を使用して、エピソード キーが解決されます。  ヒント: これらの変更を行う前に Hiero/Nuke Studio プロジェクトを開いておいた場合、または変更中にテストする場合は、書き出しパスをリセットしなければならない可能性があります。書き出しダイアログを開くと、Nuke Studio は書き出しツリーをキャッシュに格納するため、スキーマに対する変更を再ロードする場合は、更新ボタンをクリックしてツリーを再構築する必要があります。",
    "url": "/459f67b7/",
    "relUrl": "/459f67b7/"
  },
  "47": {
    "id": "47",
    "title": "Failed to change work area - Error during execution of MEL script",
    "content": "Failed to change work area - Error during execution of MEL script使用例ネットワークにアクセスできないフリーランス専用の新しいパイプライン設定を作成するときに、新しいルート名を作成して、別のパスを指すように指定しました。プロダクション パイプライン設定には、ファイル サーバを指すルート パスが含まれています。ところが、Maya で tk-multi-workfiles を使用して新しいファイルを作成すると、次のエラーが発生します。Failed to change work area - Error during execution of MEL script: file: C:/Program files/Autodesk/Maya2019/scripts/others/setProject.mel line 332: New project location C: VetorZero work Shotgun-workflow_completo sequences Seq_001 SH_010 ANIM maya is not a valid directory, project not created.Calling Procedure: setProject, in file “C: Program Files Shotgun c” set project(“C: Vetorzero work SHOTGUN-workflow_completo sequences Seq_001 SH_010 ANIM maya”)フォルダは作成されましたが、「maya」フォルダは作成されませんでした。修正方法フォルダ「maya」が誤って削除されていないか確認します。このエラーは、エラーが発生した場合に表示されています。関連リンクコミュニティの完全なスレッドを参照してください。",
    "url": "/4f00a298/",
    "relUrl": "/4f00a298/"
  },
  "48": {
    "id": "48",
    "title": "API",
    "content": "APIregisterCallbacksプラグインのイベント処理エントリ ポイントをフレームワークに伝えるために使用する、すべてのプラグインのグローバル レベル関数。registerCallbacks(reg)  reg: 呼び出す関数をフレームワークに伝えるために使用する Registrar。RegistrarRegistrar はプラグインの操作方法をフレームワークに伝えるために使用するオブジェクトです。これは、registerCallbacks 関数に渡されます。アトリビュートlogger「getLogger」を参照してください。メソッドgetLoggerプラグイン内からメッセージをログに記録するために使用する python Logger オブジェクトを取得します。setEmails(*emails)このプラグインまたはそのコールバックのいずれかで問題が発生した場合に、エラーや重要な通知を受け取る電子メールを設定します。設定ファイルで指定されている既定のアドレスに電子メールを送信する場合(既定)reg.setEmails(True)電子メールを無効にする場合(エラー メッセージが表示されないため、この設定は推奨しません)reg.setEmails(False)特定のアドレスに電子メールを送信する場合reg.setEmails('user1@domain.com')またはreg.setEmails('user1@domain.com', 'user2@domain.com')registerCallback(sgScriptName, sgScriptKey, callback, matchEvents=None, args=None, stopOnError=True)このプラグインのエンジンにコールバックを登録します。  sgScriptName: Flow Production Tracking スクリプト ページから取得したスクリプトの名前。  sgScriptKey: Flow Production Tracking スクリプト ページから取得したスクリプトのアプリケーション キー。  callback: __call__ メソッドを使用する関数またはオブジェクト。「exampleCallback」を参照してください。  matchEvents: コールバックに渡すイベントのフィルタ。  args: フレームワークをコールバックに戻す任意のオブジェクト。  stopOnError: ブール型。このコールバックの例外は、このプラグイン内のすべてのコールバックによるイベントの処理を停止します。既定値は True です。sgScriptName は、Flow Production Tracking のプラグインを特定するために使用します。任意の名前を任意の数のコールバックで共有することも、1 つののコールバックに 1 つのみにすることもできます。sgScriptKey は、Flow Production Tracking のプラグインを特定するために使用し、指定した sgScriptName の適切なキーである必要があります。指定したコールバック オブジェクトは、フィルタに一致するイベントの処理が必要な場合に呼び出されます。呼び出し可能なオブジェクトを実行することはできますが、ここでクラスを使用することは推奨しません。__call__ メソッドを操作する関数やインスタンスを使用するほうが妥当です。matchEvent 引数は、登録されているコールバックが関係するイベントを指定するフィルタです。matchEvents が指定されていない場合、または None が指定されている場合、すべてのイベントがコールバックに渡されます。それ以外の場合、matchEvents フィルタの各キーはイベント タイプです。各値は使用可能なアトリビュート名のリストです。matchEvents = {    'Shotgun_Task_Change': ['sg_status_list'],}複数のイベント タイプやアトリビュート名を指定できます。matchEvents = {    'Shotgun_Task_Change': ['sg_status_list'],    'Shotgun_Version_Change': ['description', 'sg_status_list']}指定したアトリビュート名のイベント タイプをフィルタすることができます。matchEvents = {    '*': ['sg_status_list'],}また、特定のイベント タイプの任意のアトリビュート名をフィルタすることもできます。matchEvents = {    'Shotgun_Version_Change': ['*']}以下のように指定することもできますが、何も指定しない場合と同じようにしか機能しないため、実際には指定しても無意味です。matchEvents = {    '*': ['*']}「_New」や「_Retirement」などのフィールド固有でないイベント タイプと照合する場合には、リストを指定するのではなく、None という値を渡します。matchEvents = {    'Shotgun_Version_New': None}args 引数は、イベント フレームワーク自体では使用されません。変更せずにコールバックに戻されるだけです。                    注: args 引数のポイントは、registerCallbacks 関数で時間のかかる処理を行い、イベント処理時に戻り値を渡せるようにすることです。    args 引数の別の使用方法として、dict などの一般的な可変値を複数のコールバックに渡してデータを共有するように指定できます。stopOnError 引数は、このコールバックの例外によってプラグインのすべてのコールバックのイベント処理を停止するかどうかを伝えます。既定では True ですが、False に切り替えることもできます。イベントの処理を停止しない場合でも、エラーの通知メールが送信されます。コールバックごとに設定するため、重要なコールバックをユーザによって True または False にすることができます。コールバックRegistrar.registerCallback によって登録するプラグイン エントリ ポイントは通常、次のようなグローバル レベル関数です。exampleCallback(sg, logger, event, args)  sg: Flow Production Tracking の接続インスタンス。  logger: Python logging.Logger オブジェクトがあらかじめ設定されています。  event: 処理する Flow Production Tracking イベント。  args: コールバックの登録時に指定する args 引数。                    注: オブジェクト インスタンスで __call__ メソッドとしてコールバックを使用できますが、ユーザの演習のみに使用するものとしておきます。    ",
    "url": "/b04a53ae/",
    "relUrl": "/b04a53ae/"
  },
  "49": {
    "id": "49",
    "title": "環境設定",
    "content": "環境設定以下のガイドは、スタジオの Flow Production TrackingEvents を設定する場合に役に立ちます。ShotGridEvents のほとんどの設定は、shotgunEventDaemon.conf ファイルによって制御されます。このファイルには、必要に応じて修正できるいくつかの設定があります。それらの設定にはほとんどのスタジオで正常に機能する既定値がありますが、いくつかの設定は構成する必要があります(具体的には、ShotGridEventDaemon を Flow Production Tracking サーバに接続するための Flow Production Tracking サーバの URL、スクリプト名、およびアプリケーション キー)。                    注: Windows の場合: Windows ユーザは、環境設定ファイル内のすべてのパスを Windows 用に変更する必要があります。ログを含むすべてのパスを、単純化のために 1 つの場所に保持することをお勧めします。このドキュメントでは、Windows のパスについて説明する際に、C: shotgun shotgunEvents を参照する傾向があります。    shotgunEventDaemon.conf を編集するShotGridEvents をインストールしたら、次に shotgunEventDaemon.conf ファイルをテキスト エディタで開き、スタジオのニーズに合わせて設定を変更します。ほとんどのスタジオでは既定値をそのまま使用できますが、一部の設定には既定値がなく、デーモンを実行する前にユーザが設定する必要があります。必須のアイテムは次のとおりです。  Flow Production Tracking サーバの URL  Flow Production Tracking に接続するためのスクリプト名とアプリケーション キー  Flow Production TrackingEventDaemon を実行するためのプラグインへのフル パス必要に応じて、SMTP サーバおよび電子メール固有の設定を指定して、エラーに対する電子メール通知を設定することもできます。これはオプションですが、設定することを選択した場合は、電子メール セクションですべての設定値を指定する必要があります。また、デーモンでパフォーマンスの問題が発生した場合のトラブルシューティングに役立つオプションのタイミング ログのセクションもあります。タイミング ログを有効にすると、個別のログ ファイルにタイミング情報が入力されます。Flow Production Tracking 設定[ShotGrid] セクションの下で、既定のトークンを server、name、および key の正しい値に置き換えます。これらは、Flow Production Tracking に接続する標準 API スクリプトに指定した値と同じである必要があります。例server: https://awesome.shotgunstudio.comname: Flow Production TrackingEventDaemonkey: e37d855e4824216573472846e0cb3e49c7f6f7b1プラグイン設定実行するプラグインを検索する場所を Flow Production TrackingEventDaemon に指示する必要があります。[plugins] セクションで、既定のトークンを paths の正しい値に置き換えます。複数の場所を指定できます (デーモンを使用する複数の部門またはリポジトリがある場合に役立つことがあります)。この値は、読み取り可能な既存のディレクトリへのフル パスである必要があります。例paths: /usr/local/shotgun/ShotGridEvents/plugins初めて起動する場合、/usr/local/shotgun/ShotGridEvents/src/examplePlugins ディレクトリにある logArgs.py プラグインを使用してテストを行うことをお勧めします。これを指定したプラグイン フォルダにコピーし、テストに使用します。shotgunEventDaemon.conf の場所既定では、デーモンは Flow Production TrackingEventDaemon.py と同じディレクトリおよび /etc ディレクトリで shotgunEventDaemon.conf ファイルを検索します。conf ファイルを別のディレクトリに配置する必要がある場合は、現在のディレクトリから別のディレクトリへの symlink を作成することをお勧めします。                    注: 何らかの理由で上記の手順が機能しない場合、設定ファイルの検索パスは shotgunEventDaemon.py スクリプトの下部にある _getConfigPath() 関数に配置されます                        注: Windows の場合/etcは Windows に存在しないため、環境設定ファイルは Python ファイルと同じディレクトリに配置する必要があります。    デーモンをテストするデーモンはバックグラウンドで実行されるためテストが困難な場合があります。デーモンの動作を確認するための明確な方法はありません。幸い、ShotGridEventDaemon には、デーモンをフォアグラウンド プロセスとして実行するオプションがあります。最低限必要な設定が完了したので、次にデーモンをテストして、どのように動作するかを確認します。                    注: ここで使用される既定値では、ルート アクセスが必要になる場合があります(たとえば、/var/log ディレクトリに書き込む場合など)。この例では、sudo を使用してこの問題に対応しています。    $ sudo ./ShotGridEventDaemon.py foregroundINFO:engine:Using Flow Production Tracking version 3.0.8INFO:engine:Loading plugin at /usr/local/shotgun/ShotGridEvents/src/examplePlugins/logArgs.pyINFO:engine:Last event id (248429) from the Flow Production Tracking database.スクリプトを起動すると、上記の行が表示されます(一部の詳細は実際とは明らかに異なる場合があります)。エラーが発生した場合、フォアグラウンドで実行することを選択したため、スクリプトは終了します。先に進めなくなると、いくつかの一般的なエラーが以下に表示されます。logArgs.py プラグインは、単に Flow Production Tracking で発生したイベントを取り込み、ロガーに渡すだけです。これは、スクリプトが実行されていてプラグインが機能していることを確認する簡単な方法です。多忙なスタジオでは、メッセージが高速で流れていることに気付くかもしれません。そうでない場合は、Web ブラウザで Flow Production Tracking サーバにログインし、値をいくつか変更するか、何かを作成します。変更を適用して生成したイベントのタイプに対応するログ ステートメントが、ターミナル ウィンドウに出力されます。                    注: logArgs.py ファイルには、適切な値を入力する必要のある変数があります。ログを正しく機能させるには、shotgunEventDaemon.conf ファイルで使用された値と同じ値が含まれるように ‘$DEMO_SCRIPT_NAMES$’ および ‘$DEMO_API_KEY$’ を編集する必要があります。    ログ ファイルに何も記録されていない場合は、ShotGridEventDaemon.conf のログ関連設定を調べて、logging 値が情報レベルのメッセージを記録するように設定されていること、logging: 20また、logArgs プラグインも情報レベルのメッセージを表示するように設定されていることを確認します。registerCallbacks() メソッドの最後に、読み込む必要のある行があります。reg.logger.setLevel(logging.INFO)すべてが正常だと仮定し、ShotGridEventDaemon プロセスを停止するには、ターミナルに &amp;lt;ctrl&amp;gt;-c と入力し、スクリプトの終了を確認します。デーモンを実行するテストがすべて成功したと仮定し、バックグラウンドで目的どおりにデーモンを実行できるようになりました。$ sudo ./ShotGridEventDaemon.py start出力はなく、ターミナルでユーザにコントロールが返されます。2 つの方法で、すべてが適切に実行されていることを確認できます。最初に、実行中のプロセスを調べて、これがその 1 つであるかどうかを確認します。$ ps -aux | grep shotgunEventDaemonkp              4029   0.0  0.0  2435492    192 s001  R+    9:37AM   0:00.00 grep shotgunEventDaemonroot            4020   0.0  0.1  2443824   4876   ??  S     9:36AM   0:00.02 /usr/bin/python ./ShotGridEventDaemon.py start返された 2 行目から、デーモンが実行されていることが分かります。最初の行は、今実行したコマンドに一致します実行していることは分かりますが、機能していること、そしてプラグインが想定した通りに動作していることを確認するために、ログ ファイルを調べて、出力があるかどうかを確認できます。$ sudo tail -f /var/log/shotgunEventDaemon/shotgunEventDaemon2011-09-09 09:42:44,003 - engine - INFO - Using Flow Production Tracking version 3.0.82011-09-09 09:42:44,006 - engine - INFO - Loading plugin at /usr/local/shotgun/ShotGrid/src/plugins/logArgs.py2011-09-09 09:42:44,199 - engine - DEBUG - Starting the event processing loop.Web ブラウザに戻り、エンティティに変更を加えます。次に、ターミナルに戻って出力を探します。次のように表示されます。2011-09-09 09:42:44,003 - engine - INFO - Using Flow Production Tracking version 3.0.82011-09-09 09:42:44,006 - engine - INFO - Loading plugin at /usr/local/shotgun/ShotGrid/src/plugins/logArgs.py2011-09-09 09:42:44,199 - engine - DEBUG - Starting the event processing loop.2011-09-09 09:45:31,228 - plugin.logArgs.logArgs - INFO - {'attribute_name': 'sg_status_list', 'event_type': 'Shotgun_Shot_Change', 'entity': {'type': 'Shot', 'name': 'bunny_010_0010', 'id': 860}, 'project': {'type': 'Project', 'name': 'Big Buck Bunny', 'id': 65}, 'meta': {'entity_id': 860, 'attribute_name': 'sg_status_list', 'entity_type': 'Shot', 'old_value': 'omt', 'new_value': 'ip', 'type': 'attribute_change'}, 'user': {'type': 'HumanUser', 'name': 'Kevin Porterfield', 'id': 35}, 'session_uuid': '450e4da2-dafa-11e0-9ba7-0023dffffeab', 'type': 'EventLogEntry', 'id': 276560}出力の正確な詳細は実際とは異なりますが、プラグインが想定した通り、イベントをログ ファイルに記録したことが分かります。ここでも、ログ ファイルに何も記録されていない場合は、ShotGridEventDaemon.conf のログ関連設定を調べて、logging 値が情報レベルのメッセージを記録するように設定されていること、また、logArgs プラグインも情報レベルのメッセージを表示するように設定されていることを確認します。ログの記録に関する注意事項ログ ローテーションは Flow Production Tracking デーモンの機能であることに注意してください。ログは毎日深夜にローテーションされ、プラグインごとに 10 個のファイルが毎日保持されます。一般的なエラー次に、発生する一般的なエラーとその解決方法をいくつか示します。解決方法が何も見つからない場合は、サポート サイトにアクセスしてサポートを依頼してください。無効なパス: $PLUGIN_PATHS$shotgunEventDaemon.conf ファイル内のプラグインへのパスを指定する必要があります。権限が拒否されました: ‘/var/log/shotgunEventDaemon’デーモンは書き込み用にログ ファイルを開けませんでした。sudo を使用してデーモンを実行するか、shotgunEventDaemon.conf の logPath および logFile 設定によって指定されたログ ファイルに書き込む権限を持つユーザとして実行する必要があります。(既定の場所は /var/log/shotgunEventDaemonで、通常はルートが所有します。ImportError: shotgun_api3 という名前のモジュールがありませんFlow Production Tracking API がインストールされていません。現在のディレクトリ内に保存されているか、PYTHONPATH 内のディレクトリに保存されているかを確認してください。sudo として実行する必要があり、PYTHONPATH が正しく設定されている場合は、sudo によって環境変数がリセットされることに注意してください。sudoers ファイルを編集して PYTHONPATH を保持するか、sudo -e(?) を実行することができます環境設定ファイルの設定のリストデーモンの設定次に、一般的なデーモンの操作設定を示します。pidFilepidFile は、デーモンが実行中にそのプロセス ID を保存する場所です。デーモンの実行中にこのファイルが削除された場合、次のパスがイベント処理ループを通過した後に、完全にシャットダウンされます。このフォルダはあらかじめ作成されていて、書き込み可能である必要があります。ファイルには任意の名前を付けることができますが、実行しているプロセスと一致する既定の名前を使用することを強くお勧めします。pidFile: /var/log/shotgunEventDaemon.pideventIdFileeventIdFile は、デーモンが最後に処理された Flow Production Tracking イベントの ID を保存する場所を参照します。これにより、デーモンは最後にシャットダウンされたときに停止した場所を取得できるため、イベントが見逃されることはありません。最後のデーモンのシャットダウン以降のイベントを無視する場合は、デーモンを開始する前にこのファイルを削除します。これにより、デーモンは起動時に作成された新しいイベントのみを処理します。このファイルは、の各 プラグインの最後のイベント ID を記録し、この情報を pickle 形式で保存します。eventIdFile: /var/log/shotgunEventDaemon.idlogModeログ記録モードは、次の 2 つの値のいずれかに設定できます。  0 = メイン ログ ファイルのすべてのログ メッセージ  1 = エンジン用の 1 つのメイン ファイル、プラグインごとに 1 つのファイル値が 1 の場合、エンジン自体によって生成されたログ メッセージは、logFile 構成の設定で指定されたメイン ログ ファイルに記録されます。プラグインによってログに記録されたメッセージは、plugin.&amp;lt;plugin_name&amp;gt; という名前のファイルに保存されます。logMode: 1logPathログ ファイルを配置するパス(メイン エンジンとプラグインの両方のログ ファイル)。メイン ログ ファイルの名前は、以下の logFile 設定によってコントロールされます。logPath: /var/log/shotgunEventDaemon                    注: shotgunEventDaemon には、このディレクトリの書き込み権限が必要です。一般的なセットアップでは、デーモンはマシンの起動時に自動的に実行されるように設定され、その時点でルート権限が与えられます。    logFileメイン デーモン ログ ファイルの名前。ログ記録は、毎日深夜にローテーションされるログ ファイルを 10 個まで保存するように設定されています。logFile: shotgunEventDaemonloggingログ ファイルに送信されるログ メッセージのしきい値レベル。この値はメインのディスパッチ エンジンの既定値で、プラグインごとにオーバーライドできます。この値は、単に Python のロギング モジュールに渡されます。よく使われる値は次のとおりです。  10: デバッグ  20: 情報  30: 警告  40: エラー  50: 極めて重要logging: 20timing_logこの値を on に設定してタイミングの記録を有効にすると、タイミング情報を含む個別のログ ファイルが生成され、デーモンのパフォーマンスの問題のトラブルシューティングが簡単になります。各コールバックの呼び出しに対して提供されるタイミング情報は次のとおりです。  event_id コールバックをトリガしたイベントの ID  created_at イベントが Flow Production Tracking で作成されたときの ISO 形式のタイムスタンプ  callback 起動されたコールバックの plugin.callback 形式の名前  start コールバック処理の開始の ISO 形式のタイムスタンプ  end コールバック処理の終了の ISO 形式のタイムスタンプ  duration DD:HH:MM:SS.micro_second 形式のコールバック処理時間  error コールバックが失敗したかどうかを示します。値は False または True のいずれかになります。  delay イベントの作成からコールバックによる処理の開始までの DD:HH:MM:SS.micro_second 形式の遅延時間。conn_retry_sleepFlow Production Tracking への接続が失敗した後、接続が再試行されるまでの待機時間(秒単位)。これにより、ネットワークの中断、サーバの再起動、アプリケーションのメンテナンスなどが可能になります。conn_retry_sleep = 60max_conn_retriesエラー レベルのメッセージがログに記録される前に接続を再試行する回数です(この下に電子メール通知が設定されている場合は、電子メールが送信される可能性があります)。max_conn_retries = 5fetch_interval各イベントのバッチ処理が完了した後に、新しいイベントを要求するまでの待機時間(秒単位)。通常、この設定は調整する必要はありません。fetch_interval = 5Flow Production Tracking 設定Flow Production Tracking インスタンスに関連する設定は次のとおりです。server接続先の Flow Production Tracking サーバの URL。server: %(SG_ED_SITE_URL)s                    注: 既定値はありません。環境変数 SG_ED_SITE_URL を Flow Production Tracking サーバの URL ( https://awesome.shotgunstudio.com)に設定します    nameFlow Production Tracking EventDaemon が接続する必要がある Flow Production Tracking スクリプト名。name: %(SG_ED_SCRIPT_NAME)s                    注: 既定値はありません。環境変数 SG_ED_SCRIPT_NAME を Flow Production Tracking サーバのスクリプト名( shotgunEventDaemon)    key上記で指定したスクリプト名の Flow Production Tracking アプリケーション キー。key: %(SG_ED_API_KEY)s                    注: 既定値はありません。環境変数 SG_ED_API_KEY を上記のスクリプト名(0123456789abcdef0123456789abcdef01234567)のアプリケーション キーに設定します。    use_session_uuidFlow Production Tracking インスタンス内のすべてのイベントから、プラグインによって生成されたイベントに伝播する session_uuid を設定します。これにより、プラグインの結果として発生した更新を Flow Production Tracking UI に表示できるようになります。use_session_uuid: True  Flow Production Tracking この機能には、サーバ v2.3+ が必要です。  Flow Production Tracking この機能には、API v3.0.5+ が必要です。                    注: Flow Production Tracking UI は、元のイベントを生成したブラウザ セッションの更新のみをライブで表示します。同じページを開いている他のブラウザ ウィンドウでは、更新がライブで表示されません。    プラグイン設定pathsフレームワークがロードするプラグインを検索する完全なパスのカンマ区切りリスト。相対パスは使用しないでください。paths: /usr/local/shotgun/plugins                    注: 既定値はありません。値をプラグイン ファイルの場所(Windows では /usr/local/shotgun/shotgunEvents/plugins または C: shotgun shotgunEvents plugins)に設定する必要があります    電子メール設定ユーザが常にログをテーリングすることはなく、アクティブな通知システムを使用することがわかっているので、これらはエラー報告に使用されます。レベル 40 (ERROR) より上のエラーは、すべての設定が下に提供されている場合、電子メールで報告されます。電子メール アラートを送信するには、これらの値をすべて入力する必要があります。serverSMTP 接続に使用するサーバ。ユーザ名とパスワードの値は、SMTP 接続の資格情報を提供するためにコメント解除することができます。サーバが認証を使用しない場合は、username と password の設定をコメント アウトする必要があります。server: smtp.yourdomain.com                    注: 既定値はありません。smtp.yourdomain.com トークンを SMTP サーバのアドレス(smtp.mystudio.com).    usernameSMTP サーバで認証を必要とする場合は、この行をコメント解除し、SMTP サーバに接続するために必要なユーザ名を持つ環境変数 SG_ED_EMAIL_USERNAME を設定していることを確認します。username: %(SG_ED_EMAIL_USERNAME)spasswordSMTP サーバで認証を必要とする場合は、この行をコメント解除し、SMTP サーバに接続するために必要なパスワードを持つ環境変数 SG_ED_EMAIL_PASSWORD を設定していることを確認します。password: %(SG_ED_EMAIL_PASSWORD)sfrom電子メールで使用する必要がある開始アドレスです。from: support@yourdomain.com                    注: 既定値はありません。support@yourdomain.com を有効な値(noreply@mystudio.com).    toこれらのアラートを送信する必要がある電子メール アドレスのカンマ区切りリスト。to: you@yourdomain.com                    注: 既定値はありません。you@yourdomain.com を有効な値(shotgun_admin@mystudio.com).    subjectイベント フレームワーク Flow Production Tracking によって送信されたアラートを並べ替えるのに役立つ電子メールの件名の接頭語。subject: [SG]",
    "url": "/ed5161c4/",
    "relUrl": "/ed5161c4/"
  },
  "50": {
    "id": "50",
    "title": "サンプル プラグイン",
    "content": "サンプル プラグインソース コードには、サンプル プラグインのフォルダがあります。このページには、作業を開始するユーザのためのいくつかの簡単なサンプルが含まれています。このコードはコピーと貼り付けによって実行できます(注: script_name と script_key の値をインストールに合わせて更新する必要があります)。まず、ここに SG イベント コードを記述するテンプレートがあります。1. コード テンプレート新規プラグインを開始するには、これをコピーして貼り付けます&quot;&quot;&quot;Necessary Documentation of the codeAuthor: YouTemplate Author: Andrew Britton&quot;&quot;&quot;def registerCallbacks(reg):    # This takes the form of:    #    matchEvents = {'Shotgun_Entity_EventType': ['list', 'of', 'field', 'names', 'you', 'need', 'sg_custom_field']}    # the 'id' is always returned, in addition to any fields specifically requested by your callback    matchEvents = {        'Shotgun_Task_Change': ['content']    }    # script_name and script_key are defined by you whenever you create a SG script    # the entry_function_call refers to the function that performs the work of the event plugin    reg.registerCallback('script_name', 'script_key', entry_function_call, matchEvents, None)# This gives you#    shotgun handle = sg#    a logger object... please use this instead of python print, especially if you respect your time and your fellow developers#    an event object... this is the metadata that describes what's happening with the particular event.#        some very good information comes from the event['meta'] object, below is the example event['meta'] data from the subject renamer plugin#              {#                &quot;type&quot;: &quot;attribute_change&quot;,#                &quot;attribute_name&quot;: &quot;subject&quot;,#                &quot;entity_type&quot;: &quot;Note&quot;,#                &quot;entity_id&quot;: 2,#                &quot;field_data_type&quot;: &quot;text&quot;,#                &quot;old_value&quot;: &quot;My Note Subject&quot;,#                &quot;new_value&quot;: &quot;2017-05 May-09 - My Note Subject&quot;#              }def entry_function_call(sg, logger, event, args):    # Now do stuff    pass   2. ノートの件名の名前変更New エンティティ イベントを使用するこれは単純ですが、Shotgun_Entity_New イベントを捕捉するという複雑な処理も実行できるので、開始点として優れています…import timefrom pprint import pprintdef registerCallbacks(reg):    matchEvents = {        'Shotgun_Note_New': ['*'],    }    reg.registerCallback('script_name', 'script_key', Function_Name, matchEvents, None)def Function_Name(sg, logger, event, args):    # Waiting here should allow the entity to be fully created            #     and all the necessary attributes to be added to the NOTE entity    time.sleep(1)    current_date = time.strftime(&quot;%Y-%m %b-%d&quot;)    asset_id = event['meta']['entity_id']    asset_type = event['meta']['entity_type']    asset = sg.find_one(asset_type, [['id', 'is', asset_id]], ['subject'])    if asset['subject'] is None:        current_name = current_date + ' - ' + event['project']['name'] + ' - ' + event['user']['name']    else:        current_name = current_date + ' - ' + asset['subject']    # Modify ALL notes except those in 'Software Development'    if event['project'] == None:        logger.info('Updated Note ID is #%d, and is being prepended with &quot;%s&quot;', asset_id, current_date)        logger.info(event)        sg.update(asset_type, asset_id, {'subject': current_name})        return    if event['project']['id'] != 116:        logger.info('Updated Note ID is #%d, and is being prepended with &quot;%s&quot;', asset_id, current_date)        logger.info(event)        sg.update(asset_type, asset_id, {'subject': current_name})    else:        logger.info('Dates are not prepended for notes in project id 116 - Software Development')        returnsleep の呼び出しが、関数本体の最初の行であることに注意してください。この理由は、new イベントの処理方法に関係があります。  SG で新しいエンティティを作成すると、そのエンティティにはまだ形式はありません。つまり、使い慣れたエンティティを完全に定義するために必要なアトリビュートのすべてが設定されていません。実際、この例では、SG が subject イベントを発行する場合に、Shotgun_Note_New アトリビュートがノート エンティティ上に存在するという保証さえもできません。  必要なすべてのアトリビュートを追加するために、SG は次に一連の Shotgun_Note_Change イベントをパブリッシュします。このイベントでは、SG はそれぞれの単一のアトリビュートをエンティティに追加し、必要に応じてこれらのアトリビュートの値を更新します。  これは、さまざまなイベントが作成されることを意味します。つまり、2 つの異なるアトリビュートが存在する必要があり、コードに sleep の側面を記述していない場合、すべての Shotgun_Note_Change イベントと内部メタデータを調べて、新しいアトリビュートが追加され、値が設定されたイベントのみを検索する必要があります。これは面倒なプロセスであり、作成時にノートごとに 1 つのイベントを効果的に見つけるために数多くの Shotgun_Note_Change イベントを処理します。  この問題に対する解決策は、Shotgun_Entity_New を利用してスクリプトを短時間スリープ状態にすることです。スリープ状態の最後に、SG はエンティティに必要なすべてのアトリビュートを更新し、必要な任意のフィールドに対して同じエンティティを再クエリーできます。2. フィールド削除の警告ノートの生成、エンティティとしてのフィールドの操作、エンティティの廃棄イベント&quot;&quot;&quot;Create a Note when a field is deletedAuthor: Andrew Britton&quot;&quot;&quot;def registerCallbacks(reg):    &quot;&quot;&quot;    fn: registerCallbacks    @brief required function. It connects to the event daemon and calls the trashedFieldWarning Function.    It runs every time a field is deleted (retired)    @param[in] reg variable that is required by shotgun event daemon plugins    @return none    &quot;&quot;&quot;    matchEvents = {        'Shotgun_DisplayColumn_Retirement': ['*']    }    reg.registerCallback('script_name', 'script_key',                         trashedFieldWarning, matchEvents, None)def CreateNote(sg, logger, event):    constants = {'note header': ':: FIELD DELETION :: '}    def GetListOfPipelineUsers():        pipeline_users = sg.find('Group', [['code', 'is', 'People_Who_Need_to_Know']], ['code', 'users', 'addressings_to',                                                                         'sg_ticket_type', 'sg_priority'])        return pipeline_users[0]['users']    def CreateToolsNote():        # Note to members of the pipeline group        # Body text = CreateNoteRequestText()        # Date Created = event['event']['created_at']        # Created By = event['user']['id']        # Project = Software Development['id']        # Subject = ':: Field Delete Warning :: ' + event['entity']['name']        note_data = {            'project': {'type': 'Project', 'id': 'ID OF PROJECT WHERE YOU WANT THE NOTE REPORTED TO'},            # ex: 'project': {'type': 'Project', 'id': 2},            'content': CreateNoteRequestText(),            'created_at': event['created_at'],            'created_by': event['user'],            'addressings_to': GetListOfPipelineUsers(),            'subject': constants['note header'] + event['meta']['display_name']        }        sg.create('Note', note_data)    def CreateNoteRequestText():        OUT = ''        # Tool Name = event['entity']['name']        # sg_assigned_to = members of the pipeline group        # Description = linked Ticket decription        # Project = decided in GUI        # sg_sg_request_ticket = event['entity']['id']        # task_template = Software task template        # Software Projects = defined in GUI        OUT = '::FIELD DELETION WARNING:: n'        OUT += ':: A Field was deleted :: n'        OUT += ':: It was called %s :: n'%event['meta']['display_name']        return OUT    logger.info('::WARNING:: A FIELD has been deleted')    CreateToolsNote()def trashedFieldWarning(sg, logger, event, args):    &quot;&quot;&quot;    fn: finalizeTasksFromShot    @brief Function to create and send a warning note, via SG, whenever a field is deleted    event['entity']['id'] yields the id of the current entity that was caught by the plugin as having been changed.    ie. this is the id of the field that was just deleted    @param[in] sg defines the Shotgun handle to access the database    @param[in] logger sets logging messages to the shotgun event daemon    @param[in] event the collection of shots that have changed    @param[in] args useless variable for this particular function    @return none    &quot;&quot;&quot;    if event['meta']['entity_type'] == 'DisplayColumn':        logger.info('This DisplayColumn was deleted %s', event['meta']['display_name'])    if event['event_type'] == 'Shotgun_DisplayColumn_Retirement':        logger.info('The incoming event call is for deleting a field from an entity. Field name: %s', event['meta']['display_name'])    # logger.info(' TEST ')    # logger.info('Deleted Field ID is #%d, and is called: %s', event['entity']['id'], event['entity']['name'])    CreateNote(sg, logger, event)これは非常に単純なスクリプトです。削除されたフィールドをチェックする場合、特別なロジックはありません。フィールドが削除されると、ノートが作成され、それを必要とするユーザのグループに送信されます。ある部署では、グループ ID を「programmers」グループに設定し、ノートのプロジェクト ID を「development」プロジェクトに設定しています。",
    "url": "/34048d1e/",
    "relUrl": "/34048d1e/"
  },
  "51": {
    "id": "51",
    "title": "インストール",
    "content": "インストール以下のガイドは、スタジオの Flow Production TrackingEvents をセットアップする場合に役に立ちます。動作環境デーモンは、Python がインストールされ、Flow Production Tracking サーバにネットワーク アクセスできる任意のマシン上で実行できます。Flow Production Tracking サーバ上で実行する必要は ** ありません** 。実際、ホストされているバージョンの Flow Production Tracking を使用している場合、これはオプションではありません。ただし、必要に応じて Flow Production Tracking サーバ上で実行することもできます。そうでなければ、任意のサーバで実行できます。  Python v2.6、v2.7 または 3.7  Flow Production Tracking Python API          Python 3.7 以降には v3.1.0 以降を使用します(注: Python 2 はサポートされなくなりました)。      いずれの場合も、最新の Python API バージョンを使用し、この依存関係を継続して更新することを強くお勧めします。        Flow Production Tracking サーバへのネットワーク アクセスFlow Production Tracking API のインストールPython が既にマシンにインストールされている場合は、Flow Production Tracking Python API をインストールして、Flow Production Tracking イベント デーモンが Flow Production Tracking サーバに接続するために使用できるようにする必要があります。これを実行するにはいくつかの方法があります。  Flow Production Tracking イベント デーモンと同じディレクトリに配置する  PYTHONPATH 環境変数によって指定されたフォルダのいずれかに配置するFlow Production Tracking API が正しくインストールされているかをテストするには、ターミナル ウィンドウで以下を確認します。$ python -c &quot;import shotgun_api3&quot;出力は表示されません。次のような出力が表示される場合は、PYTHONPATH が正しく設定されているか、Flow Production Tracking API が現在のディレクトリに配置されていることを確認する必要があります。$ python -c &quot;import shotgun_api3&quot;Traceback (most recent call last):File &quot;&amp;lt;string&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;ImportError: No module named shotgun_api3ShotGridEvents のインストールShotGridEvents のインストール先は、ユーザが自由に選択できます。ここでも、Python と Flow Production Tracking API がコンピュータにインストールされ、Flow Production Tracking サーバへのネットワーク アクセス権がある限り、任意の場所から実行することができます。ただし、スタジオにとって論理的な場所にインストールすることが自然です。/usr/local/shotgun/shotgunEvents などは論理的であるため、ここからは、これを例として使用します。ソースとアーカイブは、https://github.com/shotgunsoftware/shotgunEvents の GitHub で入手できます。                    注: Windows の場合: Windows サーバを使用している場合は C: shotgun shotgunEvents を使用できますが、このドキュメントでは Linux パスを使用します。    ソースのクローンの作成git がコンピュータにインストールされている場合にソースを取得する最も簡単な方法は、プロジェクトのクローンを作成することです。この方法では、コミットされた更新を簡単に取り込んで、常に最新のバグ修正と新機能を手に入れることができます。$ cd /usr/local/shotgun$ git clone git://github.com/shotgunsoftware/shotgunEvents.git                    警告: GitHub から更新を取得する前に、構成、プラグイン、および shotgunEvents に加えた変更を必ずバックアップして、何も失われないようにしてください。または、自分でプロジェクトをフォークして、自分自身で変更のリポジトリを維持することもできます。)    アーカイブのダウンロードコンピュータに git がない場合、またはソースのアーカイブをダウンロードするだけの場合は、次の手順を実行します。  https://github.com/shotgunsoftware/shotgunEvents/ にアクセスします。  希望の形式でソースをダウンロードします。  コンピュータ上に保存します。  /usr/local/shotgun フォルダにファイルを解凍します。  /usr/local/shotgun/shotgunsoftware-shotgunEvents-xxxxxxx フォルダの名前を /usr/local/shotgun/shotgunEvents に変更します。アーカイブを /usr/local/shotgun に抽出します。.tar.gz アーカイブの場合:$ tar -zxvf shotgunsoftware-shotgunEvents-v0.9-12-g1c0c3eb.tar.gz -C /usr/local/shotgun.zip アーカイブの場合:$ unzip shotgunsoftware-shotgunEvents-v0.9-12-g1c0c3eb.zip -d /usr/local/shotgun次に、GitHub によって割り当てられたディレクトリ名を shotgunEvents に変更します。$ mv shotgunsoftware-shotgunEvents-1c0c3eb shotgunEvents次のように表示されます。$ ls -l /usr/local/shotgun/shotgunEventstotal 16-rw-r--r--  1 kp  wheel  1127 Sep  1 17:46 LICENSE-rw-r--r--  1 kp  wheel   268 Sep  1 17:46 README.mkddrwxr-xr-x  9 kp  wheel   306 Sep  1 17:46 docsdrwxr-xr-x  6 kp  wheel   204 Sep  1 17:46 srcインストール要件requirements.txt ファイルはリポジトリのルートに配置されています。必要なパッケージをインストールするには、これを使用する必要があります$ pip install -r /path/to/requirements.txtWindows の場合Windows システムでは、次のいずれかが必要です。  PyWin32 がインストールされている Python  アクティブな PythonActive Python には Flow Production Tracking イベント デーモンと Windows のサービス アーキテクチャを統合するために必要な PyWin32 モジュールが付属しています。次のコマンドを実行して、デーモンをサービスとしてインストールすることができます(C: Python27_32 python.exe は Python 実行可能ファイルへのパスですが、必要に応じて調整が必要です)。&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py installまたは、以下を使用して削除します。&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py removeサービスの開始と停止は、通常のサービス管理ツールを使用するか、次のコマンド ラインを使用して実行できます。&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py start&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py stopほとんどの場合、システムの管理者ユーザとしてリストされている各コマンドを実行していることを確認する必要があります。それには、cmd アプリケーションを右クリックして[管理者として実行]を選択します。                    注: ネットワーク上の Windows にデーモンをインストールした場合、またはネットワーク上の場所からログやその他のリソースを読み書きするように設定した場合は、サービスのプロパティを編集して、サービスを実行するユーザをローカル マシン アカウントからネットワーク リソースへのアクセス権を持つドメイン アカウントに変更する必要があります。    ",
    "url": "/7c203655/",
    "relUrl": "/7c203655/"
  },
  "52": {
    "id": "52",
    "title": "プラグイン",
    "content": "プラグインの概要プラグイン ファイルは、環境設定ファイルで指定されたプラグイン パス内の .py ファイルです。コードのダウンロード先の src/examplePlugins フォルダには、サンプル プラグインがいくつか用意されています。これらは、生成された特定のイベントを検索して処理し、Flow Production Tracking インスタンスの他の値を変更するための独自のプラグインを構築する方法の簡単な例を示します。プラグインを更新するたびにデーモンを再起動する必要はありません。デーモンは、プラグインが更新されたことを検出して自動的に再ロードします。プラグインがエラーを生成しても、デーモンがクラッシュすることはありません。プラグインは、再度更新されるまで無効になります(修正した場合も同様に動作するようリクエスト中)。その他のプラグインは引き続き実行され、イベントが処理されます。デーモンは、中断されたプラグインが正常に処理された最後のイベント ID を追跡します。プラグインが更新(および修正)されると、デーモンはプラグインを再ロードし、プラグインが終了した時点からイベントを処理しようとします。すべて正常に実行されると、デーモンは現在のイベントまでのプラグインを捕捉し、すべてのプラグインを通常のものとして使用してイベントを処理し続けます。Flow Production Tracking イベント処理プラグインは、コールバック登録関数と任意の数のコールバックという 2 つの主要な部分で構成されます。registerCallbacks 関数フレームワークによってロードするには、プラグインは少なくとも次の関数を実装する必要があります。def registerCallbacks(reg):    passこの関数は、イベントを処理するために呼び出す関数をイベント処理システムに通知するために使用されます。この関数は、1 つの引数を取る必要があり、それは Registrar オブジェクトです。Registrar には非常に重要なメソッドが 1 つあります: Registrar.registerCallbackFlow Production Tracking イベントを処理する必要がある関数ごとに、Registrar.registerCallback を、適切な引数で 1 回ずつ呼び出します。関数は必要な数だけ登録できます。また、ファイル内のすべての関数をイベント処理コールバックとして登録する必要はありません。コールバックシステムに登録されるコールバックは、次の 4 つの引数を取る必要があります。  追加情報について Flow Production Tracking にクエリーする必要がある場合の Flow Production Tracking 接続インスタンス。  レポートに使用する必要がある Python Logger オブジェクト。エラー メッセージと極めて重要なメッセージは、設定された任意のユーザに電子メールで送信されます。  処理する Flow Production Tracking イベント。  コールバックの登録時に渡される args 値。(Registrar.registerCallback を参照)                    警告: プラグインでは必要なすべての処理を実行できますが、例外がフレームワークに戻った場合、問題のあるコールバック(および含まれているすべてのコールバック)が存在するプラグインは、ディスク上のファイルが変更されるまで非アクティブ化されます(読み取り: 修正)。    ログ記録イベント プラグインで print 文を使用することはお勧めしません。Python 標準ライブラリの標準ロギング モジュールを使用することをお勧めします。ロガー オブジェクトは、さまざまな関数に提供されます。def registerCallbacks(reg):    reg.setEmails('root@domain.com', 'tech@domain.com') # Optional    reg.logger.info('Info')    reg.logger.error('Error') # ERROR and above will be sent via email in default configおよびdef exampleCallback(sg, logger, event, args):    logger.info('Info message')イベント フレームワークがデーモンとして実行されている場合、これはファイルに記録されます。それ以外の場合は stdout に記録されます。堅牢なプラグインの構築デーモンは Flow Production Tracking に対してクエリーを実行しますが、find() コマンドが失敗した場合に再試行する機能が組み込まれているため、デーモン自体には一定の堅牢性があります。https://github.com/shotgunsoftware/shotgunEvents/blob/master/src/shotgunEventDaemon.py#L456プラグインにネットワーク リソース(Flow Production Tracking または他のリソース)が必要な場合は、独自の再試行メカニズムや堅牢性を提供する必要があります。Flow Production Tracking アクセスの場合、デーモンの内容を確認して、プラグインにその機能を提供できるヘルパー関数またはクラスを作成することができます。Flow Production Tracking Python API は既にネットワークの問題に対してあるレベルの再試行を実行できますが、数分間実行される Flow Production Tracking のメンテナンス ウィンドウのタイミングにぶつかったり、ネットワーク障害が発生した場合、これでは十分ではない場合があります。https://github.com/shotgunsoftware/python-api/blob/master/shotgun_api3/shotgun.py#L1554プラグインの機能に応じて、イベントの処理中に問題が発生した場合に追跡を続けるために登録することもできます。registerCallback 関数の stopOnError 引数を参照してください。https://github.com/shotgunsoftware/shotgunEvents/wiki/API#wiki-registerCallback                    注: プラグインは停止しませんが、失敗した試行は再試行されません。    ",
    "url": "/3d05c112/",
    "relUrl": "/3d05c112/"
  },
  "53": {
    "id": "53",
    "title": "技術の詳細",
    "content": "技術的な概要イベント タイプトリガを登録して通知するイベント タイプは、通常、次の Shotgun_[entity_type]_[New|Change|Retirement|Revival] 形式を使用します。以下に、この形式の例をいくつか示します。Shotgun_Note_NewShotgun_Shot_NewShotgun_Task_ChangeShotgun_CustomEntity06_ChangeShotgun_Playlist_RetirementShotgun_Playlist_Revivalエンティティの記録アクティビティには関連せず、アプリケーション動作のキー ポイントに関連するイベントに対しては、これらの通常の形式とは異なるものが使用されます。CRS_PlaylistShare_CreateCRS_PlaylistShare_RevokeSG_RV_Session_Validate_SuccessShotgun_Attachment_ViewShotgun_Big_QueryShotgun_NotesApp_Summary_EmailShotgun_User_FailedLoginShotgun_User_LoginShotgun_User_LogoutToolkit_App_StartupToolkit_Desktop_ProjectLaunchToolkit_Desktop_AppLaunchToolkit_Folders_CreateToolkit_Folders_Delete    このリストはすべてを網羅しているわけではありませんが、糸口にしてください。Flow Production Tracking サイトのアクティビティやイベントのタイプに関する詳細を確認したい場合は、他のエンティティ タイプの他のグリッド ページのようにフィルタや検索が可能な EventLogEntries のページを参照してください。サムネイルのイベント ログ エントリエンティティの新しいサムネイルをアップロードすると、`Type` == `Shotgun_&amp;lt;Entity_Type&amp;gt;_Change` でイベント ログ エントリが作成されます(例: Shotgun_Shot_Change)。  ‘is_transient’ フィールドの値は true に設定されています。    { &quot;type&quot;: &quot;attribute_change&quot;,&quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: null, &quot;new_value&quot;: 11656, &quot;is_transient&quot;: true}        サムネイルが使用できるようになると、‘is_transient’ フィールドの値が false に設定された新しいイベント ログ エントリが作成されます。    { &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: null, &quot;new_value&quot;: 11656, &quot;is_transient&quot;: false}        サムネイルをもう一度更新すると、次のような新しいイベント ログ エントリが取得されます。    { &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: 11656, &quot;new_value&quot;: 11657, &quot;is_transient&quot;: true}{ &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: null, &quot;new_value&quot;: 11657, &quot;is_transient&quot;: false}        添付ファイルのサムネイルがプレースホルダのサムネイルである場合、‘old_value’ フィールドは null に設定されることに注意してください。プラグインの処理順序各イベントは常に同じ予測可能な順序で処理されるため、プラグインやコールバックが共依存している場合は、処理を支障なく整理することができます。環境設定ファイルで、1 つまたは複数のプラグインの場所を含む paths 設定を指定します。リスト内での順番が早い場所ほど、含まれているプラグインが早く処理されます。プラグイン パス上の各プラグインは、アルファベットの昇順で処理されます。                    注: 内部処理として、ファイル名がリストに登録されてソートされます。    最終的に、プラグインによって登録された各コールバックが登録順に呼び出されます。最初に登録されたコールバックが、最初に実行されます。1 つまたは複数のコールバックと同じプラグインで状態を共有する必要がある機能を保持することをお勧めします。状態を共有する状態を共有する必要がある複数のコールバックに設定できる多くのオプションがあります。  グローバル変数。これは適切ではありません。使用しないでください。  読み込んだモジュール。状態の情報を保持します。適切ではありませんが、単純なグローバル変数よりは適しています。  Registrar.registerCallback を呼び出すときに args 引数で渡される可変値。設計の状態オブジェクト、または dict のような単純な関数。推奨します。  オブジェクト インスタンスで __call__ などのコールバックを使用して、コールバック オブジェクトの初期化時に共有状態オブジェクトをいくつか指定します。最も強力な方法ですが、最も複雑な方法でもあります。上記の args 引数メソッドと比較すると、煩雑になる場合があります。イベント バックログフレームワークの仕様により、すべてのプラグインは、対象のすべてのイベントそれぞれを例外なく 1 回のみ処理します。必ずこのように処理されるように、フレームワークは各プラグインの未処理イベントのバックログを保存し、各プラグインが提供された最後のイベントを記憶します。バックログが発生する可能性のある状況は、以下のとおりです。イベント ログ エントリ シーケンスのずれによるバックログFlow Production Tracking で発生する各イベント(フィールド更新、エンティティの作成、エンティティの廃棄など)には、そのイベント ログ エントリの一意の ID 番号が割り当てられます。ID 番号シーケンスにずれが生じることがあります。このようなずれは、大規模なデータベース トランザクションが完了していない場合など、さまざまな理由で発生する可能性があります。イベント ログ シーケンスにずれが生じると、「不明」なイベント ID はバックログに記録され、後で処理されます。これにより、イベント デーモンは、時間がかかるデータベース トランザクションの終了後に、このようなイベントを処理できます。トランザクションが失敗した場合やページ設定の変更を元に戻した場合など、イベント ログ シーケンスのずれを埋められない場合もあります。この場合、5 分のタイムアウト後に、イベント ログ エントリの ID 番号の割り当て待機は停止され、バックログから削除され、「バックログのイベント ID 番号のタイムアウト時間が経過しました」というメッセージが表示されます。イベント シーケンスのずれが初めて発生し、既にタイムアウト時間が経過したと判断された場合、「イベント番号は割り当てられません: 無視されます」というメッセージが表示され、そもそもバックログに記録されません。プラグイン エラーによるバックログ通常の操作中、フレームワークは常に各プラグインによって処理された最後のイベントをトラッキングします。何らかの理由でプラグインが処理に失敗した場合、以降のイベントの処理は停止されます。バグの修正などによってプラグインを修正すると、フレームワークは、修正されたプラグインに保存された最後のイベントでイベントの処理を開始します。これにより、修正されたプラグインが、エラーが発生してから修正するまでの過去に発生したイベントなど、すべてのイベントを確実に処理できます。エラーがかなり前に発生した場合は、多くのイベントをやり直す必要があり、修正したプラグインが、正常に機能していた他のプラグインの処理に追い付くまでにしばらく時間がかかる可能性があります。修正したプラグインが遅れを取り戻している間、他のプラグインはこれらのイベントを無視し、同じプラグインで 1 つのイベントが 2 回処理されないようにします。その場合、「イベント X は古いイベントです。最後に処理されたイベントは(Y)です」というメッセージが表示されます。これはデバッグ メッセージです。無視しても問題ありません。このメッセージの表示を回避する正式な方法はありません。フレームワークの仕様により、すべてのプラグインそれぞれは、すべてのイベントを 1 回のみ処理します。ただし、Python とその pickle データ形式に慣れている場合は、デーモンを停止し、Python インタプリタ/インタラクティブ シェルで .id ファイルを開き、pickle モジュールで内容をデコードし、保存されている ID を削除して内容を編集します。このようにして、作成されているバックログを省略できます。この操作はサポートされていないため、ご自身の責任において行ってください。この操作を行う場合は、まず .id ファイルを適切にバックアップしてください。",
    "url": "/af5c969c/",
    "relUrl": "/af5c969c/"
  },
  "54": {
    "id": "54",
    "title": "イベント駆動型トリガを記述する",
    "content": "Flow Production Tracking イベント フレームワークこのソフトウェアは、Rodeo Fx と Oblique のサポートを受けて Patrick Boucher により開発されました。現在は、ShotGridソフトウェアのオープンソース イニシアティブの一部になっています。このソフトウェアは、LICENSE ファイルまたはオープン ソース イニシアチブの Web サイトにある MIT ライセンスの下で提供されます。目次:  概要  フレームワークの利点  イベント駆動型トリガを書き込む          使用例      イベント駆動型トリガの仕組み      EventLog のポーリングとトリガの比較      イベント タイプ      トランザクションと欠落の可能性があるイベント      概要Flow Production Tracking イベント ストリームにアクセスする場合の望ましい方法として、イベント テーブルを監視し、新しいイベントを取得し、イベントを処理して、また同じ手順を繰り返します。このプロセスを成功させるためには多くの要素が必要ですが、それらの中には、適用すべきビジネス ルールに直接関係しないものがあります。フレームワークの役割は、退屈な監視タスクをビジネス ロジックの実装作業から分離することです。フレームワークはサーバ上で動作し、Flow Production Tracking のイベント ストリームを監視するデーモン プロセスです。イベントが見つかったら、デーモンはイベントを一連の登録済みのプラグインに渡します。各プラグインは、意図したとおりにイベントを処理できます。デーモンは次を処理します:  1 つまたは複数の指定したパスからプラグインを登録する。  クラッシュするプラグインを非アクティブ化する。  プラグインがディスク上で変更された場合に再ロードする。  Flow Production Tracking のイベント ストリームを監視する。  最後に処理されたイベント ID とバックログを記憶する。  デーモンの起動時に、最後に処理されたイベント ID から開始する。  接続エラーを検出する。  必要に応じて、stdout、ファイル、または電子メールに情報を記録する。  コールバックによって使用される Flow Production Tracking への接続を作成する。  登録されたコールバックにイベントを渡す。プラグイン ハンドル:  任意の数のコールバックをフレームワークに登録する。  フレームワークによって提供された 1 つのイベントを処理する。フレームワークの利点  スクリプトごとに 1 つではなく、すべてのスクリプトに対して単一の監視メカニズムのみを扱います。  ネットワークおよびデータベースのロードを最小限に抑えます(多くのイベント処理プラグインにイベントを提供するただ 1 つのモニタ)。イベント駆動型トリガを書き込む注: イベント駆動型トリガの詳細については、https://github.com/shotgunsoftware/shotgunEvents にあるオートデスクのドキュメントを参照してください。Flow Production Tracking は、Flow Production Tracking で行われるすべてのアクションについてイベント ログ エントリを作成します。これらのイベントは Flow Production Tracking サイトだけでなく、Flow Production Tracking API からも確認できます。Flow Production Tracking にイベントの詳細な履歴が表示されるだけでなく、独自のイベント リスナー スクリプトを作成して EventLog をポーリングし、関心のある特定のイベントに対処することができます。独自のスクリプトでパイプラインの他の内部スクリプトを実行したり、Flow Production Tracking API を使用して Flow Production Tracking の他の情報を更新したりできます。使用例イベント駆動型トリガの使用例をいくつか示します。  ショットの「Layout」タスクのステータスが「最終(Final)」としてマークされると、自動的に「Animation」タスクのステータスを「開始の準備完了(Ready to Start)」に設定して、アニメータがショットで作業を開始することを把握できるようにする。  新しいショットが Flow Production Tracking で作成されるたびにファイルシステム上で適切なショット フォルダを作成する。  「保留中(On Hold)」の場合にショットに割り当てるアーティストを通知する。  アセットの作成が完了したらフォルダを読み取り専用にする。  バージョンが Flow Production Tracking のレビューに追加されたら、関連するバージョン(テイク)の情報をデイリー システムにコピーする。  シーンのショットが 25 個になったら、シーンの説明フィールドの 3 番目の文字と同じ文字で始まる任意の引用をツイートする。イベント駆動型トリガの仕組み次に、Flow Production Tracking で生成される EventLogEntries を簡単な図で説明します。スクリプトは API を使用して、指定後に発生したイベントのリストを取得します。次に、各イベント タイプ(ShotGrid_Task_Change など)を調べて、イベント駆動の対象であるかを確認します。候補のイベントが見つかると、イベントの詳細をさらに調べます(変更されたフィールドや変更された値など)。このときに API を使用してエンティティの詳細情報を要求することもできます)。イベントがイベント駆動の対象だと判断されると、スクリプトはそのイベントに従い、Flow Production Tracking API、パイプラインの他のコード、またはその両方を使用するかにかかわらず、実行する必要があるコードを実行します。チェックするイベントがなくなると、プロセスを繰り返し、API を使用して先ほどチェックした後に発生したイベントのリストを取得します。EventLog のポーリングとトリガの比較Flow Production Tracking はイベント情報を絶えず提供し続けます。ユーザはその情報をすべて確認し、任意のイベントに対してのみ操作を実行できます。これは、Flow Production Tracking 自体でトリガをコントロールするよりも次のような利点があります。  柔軟性: トリガ スクリプトは Flow Production Tracking とは関係なく実行することができます。このため、スクリプトは任意の方法で Flow Production Tracking とパイプラインの両方とやり取りできます。何の制約も受けずに任意のルールとアクションを定義します。Flow Production Tracking 側では、指定したイベント トリガについて何も把握する必要はありません。Flow Production Tracking に必要なのは、EventLogEntries を生成し続けることです。それ以外のことはすべてユーザが管理します。  リモート: スクリプトは、Flow Production Tracking サーバにネットワーク アクセスできる任意の場所から実行できます。スクリプトの実行に必要なのは API アクセスだけです。  多様性: 複数のスクリプトを同時に実行できます。それぞれの部門でニーズは異なるため、異なるイベントを待機します。すべてのトリガが同じスクリプトから実行されなければならない、というような制限はありません。トリガを個別の論理的スクリプトに分割できる場合もあります。ポーリングのクエリーは非常に軽量であるため、パフォーマンスにはほとんど影響しません。  説明責任: スクリプトで Flow Production Tracking を変更した場合は、このスクリプトによる変更内容を正確に記録する独自のイベントも生成されます。イベント タイプすべての内部イベント タイプは、Shotgun_[entity_type]_[New|Change|Retirement] の形式に従います。例として、Shotgun_Shot_New と Shotgun_Asset_Change があります。詳細については、イベント タイプのドキュメントを参照してください。トランザクションと欠落の可能性があるイベントFlow Production Tracking はトランザクションで破壊的データベース クエリーを実行し、トランザクション終了時に EventLog にのみ書き込みます。このため、「ID の最大値」メソッドを使用すると、イベントを見落としてしまう可能性があります。ただし、GitHub サイトのイベント トリガ フレームワークには、この状況を処理できるコードがあります。",
    "url": "/0d8a11d9/",
    "relUrl": "/0d8a11d9/"
  },
  "55": {
    "id": "55",
    "title": "Features Description",
    "content": "Isolation Feature SetThis section describes in detail each of the Isolation Features.To get the onboarding process started, go to Onboarding Process.To start the setup for any of the Isolation features, go to the Setup section.In This Section  Media Isolation  Media Traffic Isolation  Media Replication",
    "url": "/82f8da29/",
    "relUrl": "/82f8da29/"
  },
  "56": {
    "id": "56",
    "title": "ファイルシステム設定のリファレンス",
    "content": "ファイル システム設定のリファレンスこのトピックの内容:  はじめに  パート 1: フォルダ作成構文          クエリー フォルダ      複数のフォルダ      親フォルダを使用して作成する      オプション フィールド      正規表現トークンの一致      例      リスト フィールド フォルダ      パイプライン ステップ フォルダ                  パイプライン ステップごとの異なるファイル システム レイアウト                    詳細設定: 親を指定する      タスク フォルダ                  詳細設定: 親を指定する                    作業スペースと遅延フォルダ作成      現在のユーザ フォルダ      静的フォルダ      シンボリック リンク      ファイルとフォルダを無視する      I/O と権限をカスタマイズする                  フックに渡されるデータ          独自のフォルダ作成指示をフックに渡す          カスタム設定を静的フォルダに追加する                    フォルダの作成方法の簡単なカスタマイズ        パート 2: ファイル システム テンプレートを設定する          キー セクション                  例: 英数字の名前          例: バージョン番号          例: 立体視          例: イメージ シーケンス          例: エイリアスを使用して 2 つのフィールドに version という名前を付ける          例: タイムスタンプ          例: マッピング          例: 2 つの有効な値を使用した文字列フィールド          例: 値を無効にする          例: 文字列のサブセット                    パス セクション      文字列セクション      テンプレートでオプション キーを使用する        高度な質問とトラブルシューティング          新しいエンティティ タイプをファイル構造に追加するにはどうしたら良いですか?                  「エピソード &amp;gt; シーケンス &amp;gt; ショット」の階層に必要なフィールド                          エピソード              シーケンス              ショット              エピソード              Toolkit テンプレート定義                                          構造内でブランチをセットアップするにはどうしたら良いですか?      カスタム パイプライン ステップを作成するにはどうしたら良いですか?      このドキュメントは、Flow Production Tracking Toolkit のファイル システム中心の環境設定に関する完全なリファレンスです。テンプレート システムの仕組みと利用可能なオプションについて説明します。また、フォルダ作成の設定に追加できるすべてのパラメータについても説明します。このドキュメントは、Toolkit の設定を管理するユーザのみが使用可能な機能について説明します。詳細については、『Flow Production Tracking 統合管理者ガイド』を参照してください。はじめにこのドキュメントでは、サンプルを含むファイル システムに関連した Toolkit の設定の一部を設定する方法について説明します。Toolkit は多くのファイルとディレクトリを処理します。パスの統合方法とその意味を表す方法として Toolkit の設定を活用することができます。通常、ファイル システムへのアクセスには、完全に異なる 2 つの方法があります。フォルダの作成: Flow Production Tracking でオブジェクトを作成したら、作業開始前にディスク上にフォルダを作成する必要があります。これは、ショットを表すフォルダをディスク上に作成するという簡単な作業の場合もあれば、ショットで作業する各ユーザがディスク上の個別の領域で作業できるよう、ユーザ固有の作業サンドボックスをセットアップするといった複雑な作業の場合もあります。  Toolkit はアプリケーションの起動時にフォルダを自動的に作成し(ショット BECH_0010 の Maya を起動する場合など)、Maya の起動前にフォルダが作成されるようにします。フォルダが存在しない場合はすぐに作成されます。フォルダは、API メソッド、シェルの tank コマンド、および Flow Production Tracking の[フォルダを作成] (Create Folders)メニューを使用して作成することもできます。一連の特別な設定ファイルによってこのフォルダ作成プロセスが制御されます。これについては、次のセクションの「パート 1」で説明します。作業の表示と保存: 作業中、ディスク上の標準的な場所からファイルを開いてそこに保存する必要があります。通常、このファイルの場所は作業開始前に作成されたフォルダ構造内になります。  フォルダ構造を作成すると、この構造を使用してディスク上の主要な場所を特定できます。これらの場所はテンプレートと呼ばれます。たとえば、maya_shot_publish と呼ばれるテンプレートを定義することで、ショットのパブリッシュ済み Maya ファイルを参照できます。その後、Toolkit アプリがこのテンプレートを使用します。パブリッシュ アプリはこのテンプレートを使用してファイルの書き込み先をコントロールし、また作業ファイルアプリはテンプレートを使用して、どこからファイルを開くかを把握することができます。Toolkit の環境設定内では、各アプリが使用するテンプレートを制御できます。Toolkit で使用される主なファイルの場所はすべて 1 つのテンプレート ファイルで定義されるため、概要を簡単に表示できます。パート 1: フォルダ作成構文フォルダ設定は Flow Production Tracking のエンティティをディスク上の場所にマッピングします。1 つの設定ファイルを使用するのではなく、環境設定が、設定された各ユニットのテンプレートとして機能する「ミニ ファイル システム」の形式になります。これはスキーマ設定と呼ばれています。Toolkit のフォルダ作成が実行されると、フォルダとファイルがこの「ミニ ファイル システム」から、その対象場所にコピーされます。動的な動作を作成することができます。たとえば、フォルダで Flow Production Tracking のショットを表し、そのフォルダの命名方法を制御することができます。具体的には、Flow Production Tracking のいくつかのフィールドからそのフォルダの名前を取り込み、フォルダの作成前に文字列変換を実行できます。上図はスキーマ設定を示しています。Toolkit のフォルダ作成を実行すると、Flow Production Tracking のエンティティとディスク上のフォルダ間の接続が確立されます。Toolkit はそのフォルダ スキーマ設定を使用して、ディスク上に一連のフォルダを生成します。各フォルダは Flow Production Tracking に Filesystem Location エンティティとして登録されます。これは、Flow Production Tracking データ(ショットやアセット名など)と設定がディスクの実際のフォルダおよび Flow Production Tracking に「ベイク処理」されていると考えることができます。環境設定は常に「project」という名前のフォルダから始まります。これは Flow Production Tracking に接続されているプロジェクトを常に表し、プロジェクトの Toolkit の名前に置き換えられます。このレベルよりも下にあるのは静的フォルダです。たとえば、フォルダ作成ツールが sequences フォルダを自動的に作成します。sequences フォルダ内を確認すると、sequence フォルダと sequence.yml ファイルがあります。Toolkit がフォルダと同じ名前の YAML ファイルを検出すると、この yaml ファイルの内容を読み取り、任意の動的な動作を追加します。この場合、sequence.yml ファイルにはプロジェクト フォルダ配下の構造が含まれます。この構造は次の 3 種類の項目で構成されます。  通常のフォルダとファイル: 対象の場所に単純にコピーされます。  YAML ファイルを含むフォルダ(フォルダと同じ名前): これは動的コンテンツを表します。たとえば、shot と shot.yml があるとします。フォルダを作成する場合、この shot フォルダは数多くのフォルダの生成に使用されるテンプレートになり、1 つのショットに対して 1 つのフォルダが生成されます。  name.symlink.yml という名前のファイルは、フォルダの処理中にシンボリック リンクを生成します。シンボリック リンクについてはこのドキュメントの後半で説明します。YAML ファイルで表される動的な設定セットアップは次のモードをサポートしています。      Flow Production Tracking クエリー フォルダ: Flow Production Tracking データベース クエリーに基づく動的なフォルダ名です。たとえば、このモードを使用すると、プロジェクト内のすべてのショットにフォルダを作成できます。        Flow Production Tracking リスト フィールド フォルダ: Flow Production Tracking リスト フィールドに基づいた動的なフォルダ名。たとえば、このモードを使用すると、Flow Production Tracking のアセット エンティティにある Flow Production Tracking リスト フィールド「Asset Type」のすべての値にフォルダを作成できます。        遅延フォルダ: 2 番目のフォルダ作成パスが Toolkit API のフォルダ作成メソッドを介して要求された場合にのみ実行されます。通常はアプリケーション(Maya など)の起動時に実行されます。通常、このメソッドはアプリケーションの起動直前に Toolkit のさまざまなアプリケーション ランチャーによって実行されます。        現在のユーザ フォルダ: 現在のユーザを表す特別なフォルダ。  ここで各モードの詳細を見ていきましょう。クエリー フォルダFlow Production Tracking クエリーに対応した動的なフォルダの場合、yaml ファイルに次の構文を使用します。# the type of dynamic contenttype: shotgun_entity# the Flow Production Tracking entity type to connect toentity_type: Asset# the Flow Production Tracking field to use for the folder namename: code# Flow Production Tracking filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std Flow Production Tracking API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]   動的なコンテンツの type フィールドの値を shotgun_entity に設定します。  entity_type フィールドは、データの取得元の Flow Production Tracking エンティティ(「Asset」、「Shot」、「Sequence」、「CustomEntity02」など)に設定する必要があります。      name フィールドは、Flow Production Tracking のデータに基づいて各フォルダに付与される名前です。    上記の例のように、1 つのフィールドを使用できます(name: code など)。  括弧内に複数のフィールド(name:&quot;{asset_type}_{code}&quot; など)を使用できます。  他にリンクされたエンティティのフィールドを追加する場合は、標準の Flow Production Tracking ドット シンタックス(name: &quot;{sg_sequence.Sequence.code}_{code}&quot; など)を使用できます。  filters フィールドは Flow Production Tracking クエリーです。比較的すぐ後に、Flow Production Tracking API 構文があります。これはディクショナリのリストで、各ディクショナリには、path、relation、および values の各キーを指定する必要があります。$syntax の有効値は、Flow Production Tracking エンティティ(ディレクトリ階層上位に sequence.yml がある場合はプロジェクトの &quot;$project&quot; と &quot;$sequence&quot; など)に対応した親フォルダです。Flow Production Tracking エンティティ リンクの場合、$syntax ({ &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } など)を使用すると、環境設定内の親フォルダを参照できます。この詳細については、以下の例で説明します。複数のフォルダ複数のフォルダを一度に作成する式を作成するには、名前の定義にスラッシュを含めます。# the type of dynamic contenttype: shotgun_entity# the Flow Production Tracking entity type to connect toentity_type: Asset# the Flow Production Tracking field to use for the folder namename: &quot;{sg_asset_type}/{code}&quot;# Flow Production Tracking filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std Flow Production Tracking API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ] この種類のパスのファイル システム テンプレートを作成する場合(詳細については、このドキュメントのパート 2 を参照)、_last_folder は Flow Production Tracking のエンティティを表します。上の例は、次のテンプレートなどを使用して表すことができます。asset_step_folder: assets/{asset_type}/{Asset}/{Step}{asset_type} および {Asset} はいずれも文字列のテンプレート キーとして定義されていて、指定されたパスのコンテキストを決定する場合のコンテキストの計算には、{Asset} トークンが使用されます。親フォルダを使用して作成するFlow Production Tracking では、Flow Production Tracking データ構造内にネストがあります。このネストは、親子関係やその逆の関係と見なされます。たとえば、シーケンスは通常、ファイル システム内のショットの親です。同様に、ショットは通常、シーケンスの子です。                    注: このファイルシステムのネスト関係は、Flow Production Tracking 階層とは独立しており、この 2 つの間に関連性はありません。それぞれまったく個別に設定されています。    shotgun_entity タイプ フォルダは、親が作成されるとフォルダ作成プロセスが再帰的な処理を行って子も作成されるようにするかどうかを制御するためのオプション フラグをサポートします。フラグは特定の固定値のみを指定できる設定で、この場合は「true」または「false」です。このフラグを追加するには、次の例を使用します。# recurse down from parent foldercreate_with_parent: true 前述のとおり、この設定はオプションで、既定では false に設定されています。true に設定すると、Toolkit は検出した子エンティティのフォルダを作成します。この例を続けるために、親シーケンスの作成時にショットが作成されるように、ショットの create_with_parent を true に設定します。                    注: 既定の設定は false です。つまり、シーケンスのフォルダを作成しても、ショット フォルダは自動的に作成されません。また、設定を true にするにはこのフラグを追加する必要があります。false が既定の動作のため、shotgun_entity フォルダに false を指定するフラグはありません。    オプション フィールド通常、フォルダ名({code}_{sg_extra_field} など)を定義する場合、Toolkit で Flow Production Tracking のすべてのフィールドに値を指定する必要があります。たとえば、sg_extra_field が空の場合、エラー メッセージが生成されます。設定する場合、設定しない場合があるフィールドについては、オプションとすることができます。つまり、Toolkit は、値がある場合はこのフィールドを追加し、値が空でエラーでない場合はこのフィールドを除外します。{code}[_{sg_extra_field}] のように角括弧を使用してオプション フィールドを定義します。これで次のフォルダ名が生成されます。  code が BECH_0010 で、sg_extra_field が extra の場合、フォルダ名は BECH_0010_extra になります。  code が BECH_0010 で、sg_extra_field が空の場合、フォルダ名は BECH_0010 になります。                    注: オプション フィールドを使用できるのは、スキーマのフォルダ名の一部を定義するときだけです。フォルダ全体をオプションとすることはできません。    正規表現トークンの一致Toolkit では、正規表現を使用して、Flow Production Tracking フィールド名の一部を抽出できます。これにより、Flow Production Tracking の値でフォルダの作成を制御できる単純な式を作成できます。たとえば、Flow Production Tracking 内のすべてのアセットに、3 文字のプリフィックスとその後に続くアンダースコア(AAT_Boulder7 など)が名前として付けられている場合、この名前を 2 つのファイルシステム フォルダのレベルに分割できます(例: AAT/Boulder7)。# the type of dynamic contenttype: shotgun_entity# the Flow Production Tracking entity type to connect toentity_type: Asset# Extract parts of the name using regular expressionsname: &quot;{code:^([^_]+)}/{code^[^_]+_(.*)}&quot;# Flow Production Tracking filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std Flow Production Tracking API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]構文は、テンプレート システム内の subset トークンと似ています。Flow Production Tracking フィールド名の後にコロンを追加し、その後に正規表現を配置します。正規表現で定義されたすべてのグループ(() で囲まれたセクションなど)が、値を抽出するために使用されます。正規表現内に複数のグループがある場合は、結合されます。たとえば、次の式は、オブジェクトを作成したユーザのイニシャルを抽出します。 {created_by.HumanUser.code:^([A-Z])[a-z]* ([A-Z])[a-z]*}例次の一連の例では、filters 構文の使用方法について説明します。現在のプロジェクトに属している、処理中のショットをすべて検出するには、次の構文を使用します。Flow Production Tracking ショットのエンティティには、ショットをプロジェクトに接続するプロジェクトと呼ばれるリンク フィールドがあります。現在のプロジェクトに関連付けられたショットのフォルダだけを作成するようにしてください。設定ファイル システム上位にプロジェクト レベルがあるため、$syntax を使用してこのレベルを参照すると、Toolkit はこの Flow Production Tracking エンティティ リンクのリファレンスを自動的に作成します。$syntax の有効値は、Flow Production Tracking エンティティ(ディレクトリ階層上位に sequence.yml がある場合はプロジェクトの &quot;$project&quot; と &quot;$sequence&quot; など)に対応した親フォルダであることを忘れないでください。entity_type: Shotfilters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;status&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;ip&quot; ] }ツリーの上位にシーケンス フォルダがあり、このシーケンスに属するすべてのショットにフォルダを作成する場合、次のようなフィルタを作成できます。entity_type: Shotfilters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] }すべてのアセットを検出するには、次の構文を使用します。entity_type: Assetfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]リスト フィールド フォルダFlow Production Tracking リスト フィールド フォルダは、Flow Production Tracking のアセット タイプごとに 1 つのフォルダを作成する場合などに役立ちます。アセット タイプは Flow Production Tracking のリスト フィールドで、このフォルダの設定タイプにより、このアセット タイプのリストに反映されるファイル システムのレイヤを定義できます。                    注: フォルダをディスク上に作成したら、関連付けられたデータの値(アセット タイプなど)を変更しないことを強くお勧めします。    Flow Production Tracking リスト フィールドのすべての項目に対応する動的なフォルダを作成する場合は、yaml ファイルで次の構文を使用します。# the type of dynamic contenttype: &quot;shotgun_list_field&quot;# the Flow Production Tracking entity type to connect toentity_type: &quot;Asset&quot;# only create for values which are used in this project.# this is optional and will be set to false if not specified.skip_unused: false# by default, list fields are only created if they are needed by a child entity node# by setting the create_with_parent parameter to true you ensure that list field# nodes are always createdcreate_with_parent: false# the Flow Production Tracking field to use for the folder namefield_name: &quot;{sg_asset_type}_type&quot;  動的コンテンツの type フィールドの値を shotgun_list_field に設定します。  entity_type フィールドは、データの取得元の Flow Production Tracking エンティティ(「アセット」、「シーケンス」、「ショット」など)に設定する必要があります。      field_name フィールドは、データの取得元の Flow Production Tracking フィールドに設定し、リスト タイプ フィールドにする必要があります。動的なコンテンツとともに静的な文字列を追加する場合は、field_name: &quot;{sg_asset_type}_type&quot; という式を使用することができます。この式の例にはテキストとテンプレート キーが含まれます。    オプションの skip_unused パラメータを指定すると、使用しないリスト タイプ フィールドの値に対してディレクトリが作成されなくなります(上記の「オプション フィールド」セクションで説明)。                    注: このパラメータを True に設定すると、フォルダ作成能力が低下する可能性があります。また、現在のカリング アルゴリズムは不完全なため、関連するエンティティに複雑なフィルタが適用されている場合には機能しません。      オプションの create_with_parent パラメータを指定すると、子エンティティ レベル ノードを現在処理していなくても、list_field ノードを強制的に作成します(上記の「親フォルダを使用して作成する」セクションを参照)。パイプライン ステップ フォルダパイプライン ステップ フォルダは、Flow Production Tracking のパイプライン ステップを表します。パイプライン ステップはステップとも呼ばれています。# the type of dynamic contenttype: &quot;shotgun_step&quot;# the Flow Production Tracking field to use for the folder name. This field needs to come from a step entity.name: &quot;short_name&quot;ここで、前述の Flow Production Tracking エンティティで使用したように名前の式を使用できます。Flow Production Tracking エンティティ フォルダ設定が検出されるまで、ノードは親や祖親などを探します。このエンティティ フォルダはステップに関連付けられ、エンティティのタイプを使用して、作成するステップが決定されます。                    注: パイプライン ステップの上位フォルダを作成する場合は、単純に Flow Production Tracking エンティティ ノードを使用して関連するタイプをステップに設定します。    既定では、ステップ フォルダは特定のエンティティに関連するすべてのステップを自動的に作成します。たとえば、5 つのステップ(レイアウト、アニメーション、エフェクト、ライティング、コンポジット)が指定されたショットのフォルダ作成がトリガされると、この 5 つのステップのステップ フォルダ(レイアウト、アニメーション、エフェクト、ライティング、コンポジット)が自動的に作成されます。ただし、次の構文を使用すると、この処理をオフにすることができます。# recurse down from parent foldercreate_with_parent: false環境設定にこの設定を追加すると、ショット フォルダの作成時にステップ フォルダが作成されなくなります。その代わり、タスクでフォルダを作成した場合にのみステップ フォルダが作成されるようになります。これは、ユーザ サンドボックスと作業開始直前に作成される他の構造を設定する場合に役立ちます。パイプライン ステップごとの異なるファイル システム レイアウトライトおよび合成にフォルダを 1 つと、それ以外のステップにフォルダを 1 つ設定するとします。パイプライン ステップごとに異なるファイル システム レイアウトを指定する場合は、filter 句を環境設定に追加します。このフィルタを使用すると、特定のステップの環境設定に含まれるパイプライン ステップの範囲を指定できます。この例では、step_lightcomp.yml と step.yml の 2 つの設定ファイルを作成できます。最初のファイルでは、次のようにフィルタを追加します。filters: [ { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;in&quot;, &quot;values&quot;: [ &quot;Light&quot;, &quot;Comp&quot;  ] } ] 上記の構文は、タイプ Light または Comp のステップ フォルダが作成された場合にのみ使用されます。その他のファイルの場合には次のようなルールを作成します。filters: [ { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;not_in&quot;, &quot;values&quot;: [ &quot;Light&quot;, &quot;Comp&quot;  ] } ]これで各フォルダ内のサブ構造を個別に定義できます。詳細設定: 親を指定するフォルダ作成の一環として、Toolkit はパイプライン ステップとエンティティ(「ショット」や「アセット」など)を関連付ける必要があります。このために、既定ではフォルダ ツリーを検索し、見つけた最初の Flow Production Tracking エンティティ フォルダを選択します。たとえば、階層 Sequence &amp;gt; Shot &amp;gt; Step にアクセスすると、ステップ フォルダが、通常は任意のショットと自動的に関連付けられます。ただし、Sequence &amp;gt; Shot &amp;gt; Department &amp;gt; Step など、プライマリ エンティティよりも下の階層のエンティティの場合、既定では、Toolkit がステップと部門レベルを強制的に関連付けます。この場合、Toolkit に検索場所を明示的に指示する必要があります。そのためには、ステップ設定に次のコードを追加します。associated_entity_type: Shotタスク フォルダタスク フォルダは、Flow Production Tracking のタスクを表します。既定では、タスク フォルダがその親とともに作成されることはありません。たとえば、タスク ノードが関連付けられたショットでフォルダ作成がトリガされても、タスク フォルダは自動的に作成されません。その代わり、タスク フォルダは、タスク(Flow Production Tracking のタスクの起動など)でフォルダ作成を実行した場合にのみ作成されます。# the type of dynamic contenttype: &quot;shotgun_task&quot;# the Flow Production Tracking field to use for the folder name. This field needs to come from a task entity.name: &quot;content&quot; ただし、次の構文を使用することで、親エンティティとともにタスクが作成されるようにすることができます。# recurse down from parent foldercreate_with_parent: trueステップと同様に、フォルダ設定で動作するタスクをフィルタする場合は、必要に応じて filter パラメータを指定することもできます。ここでも、前述の Flow Production Tracking エンティティで使用したように、名前の式を使用できます。動的コンテキストと静的コンテキストの両方を持つ名前を作成できるように、静的テキストが動的コンテンツとともに使用されます。name: &quot;task_{content}&quot;Flow Production Tracking エンティティ フォルダ設定が検出されるまで、ノードは親や祖親などを探します。このエンティティ フォルダはタスクに関連付けられ、作成するタスク フォルダの決定に使用されます。詳細設定: 親を指定するフォルダ作成の一環として、Toolkit はタスクとエンティティ(ショットやアセットなど)を関連付ける必要があります。このために、既定ではフォルダ ツリーを検索し、見つけた最初の Flow Production Tracking エンティティ フォルダを選択します。たとえば、階層 Sequence &amp;gt; Shot &amp;gt; Task にアクセスすると、タスク フォルダが、通常は任意のショットと自動的に関連付けられます。ただし、Sequence &amp;gt; Shot &amp;gt; Department &amp;gt; Task, など、プライマリ エンティティよりも下の階層のエンティティの場合(ショットよりも下)、Toolkit は既定で、タスクと部門レベルを強制的に関連付けます。この場合、前のセクションのステップを使用した更新方法と同じように、Toolkit に検索場所を明示的に指示する必要があります。そのためには、タスク設定に次のコードを追加します。associated_entity_type: Shot作業スペースと遅延フォルダ作成遅延フォルダ作成は、2 つ目のフォルダ作成パスが Toolkit API の create folders メソッドのオプションである engine パラメータを介して要求された場合にのみ実行されます。通常、このメソッドはアプリケーションの起動直前に Toolkit のさまざまなアプリケーション ランチャーによって実行されます。ほとんどのフォルダ タイプが遅延フラグをサポートします。既定の設定は false です。遅延フォルダ作成を true にするには、次のフラグを追加します。# only create this folder when tk.create_filesystem_structure is# called with tk-maya, tk-nuke or any-custom-string.defer_creation: [&quot;tk-maya&quot;, &quot;tk-nuke&quot;, &quot;any-custom-string]# create this folder when any application launches, but not when normal folder# creation runsdefer_creation: trueこのフラグにより、フォルダ作成を 2 つに分割できます。1 つ目は最初の「グローバル」パスで実行し、もう 1 つのパスは後で実行します。通常、2 つ目のパスはエンジンの起動に関連付けられているため(既定値が false のために自動的には実行されない)、ユーザはエンジンの起動直前にフォルダを作成できます。これにより、次の主要な 2 つのワークフローが可能になります。  ワークスペース: アプリケーション固有のフォルダ セットアップです。フォルダはアプリケーションの起動直前に作成できます。  一般的なワークフローでは、ショットに必要なものとアーティストがそれを処理する方法に応じて、Houdini、Maya、および他のエンジンを必要とするパイプライン ステップを指定します。本来、アーティストはこのパイプライン ステップに対して、maya/、houdini/、および他のディレクトリを作成できますが、任意のショットのアーティストが Maya でしか作業しない場合、Houdini と他のエンジンの空のフォルダは不要になります。そのため、個別のエンジンの起動時までフォルダ作成を遅延させ、アーティストが Houdini を使用しない場合、houdini/ フォルダはこのショットで作成されません。  ユーザ フォルダ:ユーザ フォルダはアプリケーションの起動直前に作成されます。ユーザ フォルダ設定の構成(上述)は、既定では遅延するように設定されています。  これは、Flow Production Tracking で割り当てられたユーザに基づいてユーザ フォルダを作成するのではなく、エンジンの起動時に現在のユーザのフォルダを作成できるように実行されます。たとえば、ショットで作業を開始して Maya を起動すると、(Flow Production Tracking のユーザ名に基づいて)ユーザ名のフォルダが作成されるため、他のユーザの作業を邪魔することはありません。ヒント: アプリケーション(Maya など)の起動時に通常の静的なフォルダを作成するには、フォルダと同じ名前の yaml 設定ファイルを作成して、次のコードを追加するだけです。# type of contenttype: &quot;static&quot;# only create this folder for mayadefer_creation: &quot;tk-maya&quot;# type of contenttype: &quot;static&quot;# only create this folder when tk.create_filesystem_structure is# called with any-custom-string.defer_creation: &quot;any-custom-string&quot; 現在のユーザ フォルダ現在のユーザ フォルダは特別な構造をしており、別のユーザの作業領域をセットアップできます。一般的なシナリオとして、ある部門の複数のアーティストが同じショットに対して作業している場合があります。ユーザ フォルダを使用することにより、アーティストは自分の作業ファイルを独自のディレクトリに保存し、作業ファイル アプリでこのファイルをフィルタリングできるようになります。この場合、設定ファイルに次のオプションを含める必要があります。# the type of dynamic contenttype: &quot;user_workspace&quot;name: &quot;login&quot;  type フィールドの値を user_workspace に設定します。  name フィールドはユーザ フォルダに付与される名前です。これは Flow Production Tracking のユーザ(Flow Production Tracking の HumanUser)から取得したフィールドを組み合わせて構成する必要があります。  上記の例のように、1 つのフィールドを使用できます(name: login など)。  括弧内に複数のフィールドを使用できます(name: &quot;{firstname}_{lastname}&quot; など)。  他にリンクされたエンティティのフィールドを追加する場合は、標準の Flow Production Tracking ドット シンタックス(name: &quot;{sg_group.Group.code}_{login}&quot; など)を使用できます。現在のユーザ フォルダは、既定では遅延フォルダとして作成されます。つまり、2 つ目のフォルダ作成パスが、Toolkit API の create folders メソッドで、オプションの engine パラメータを介して要求された場合にのみ実行されます。静的フォルダ静的フォルダ(およびファイル)は最も簡単なタイプです。このフォルダを設定構成に追加すると、フォルダ作成プロセスの実行時にこのフォルダが自動的にコピーされます。既定の設定の静的フォルダの例をいくつか示します(https://github.com/shotgunsoftware/tk-config-default/tree/master/core/schema/project)。(静的フォルダには対応する YAML ファイルがないことに注意してください)。多くの場合、静的フォルダでこれ以上の機能は必要ありませんが、Toolkit は静的フォルダの高度な機能をさらにいくつかサポートしています。静的フォルダを作成するかどうかを判断するための動的な条件を定義することができます。たとえば、編集タイプのパイプライン ステップでのみ作成される特別な静的フォルダについて設定するとします。この場合、yaml 設定ファイルを静的フォルダの次に追加し、拡張子は「yml」で同じ名前を付ける必要があります。次に、以下の構文を使用します。# the type of dynamic contenttype: &quot;static&quot;# pick one of the Flow Production Tracking folders that are above this folder# in the folder hierarchy. In this case it is a parent folder# named step that we want to look at when deciding if this# static folder should be created or not.constrain_by_entity: &quot;$step&quot;# we can now define constraints for this step. Constraints are simple# Flow Production Tracking queries, following the same syntax as the other Flow Production Tracking filters# shown in previous sections.# In our example, if the parent step matches the constraints given# in the filter below, the static folder will be created. If not,# it (and its children) will be ignored by the folder creation process.constraints:    - { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;edit&quot; ] } 既定では、静的フォルダはその親フォルダとともに自動的に作成されます。これが理想の動作とは異なる場合、静的フォルダがその親とともに作成されないように指示する特別なフラグを追加できます。# do not recurse down automaticallycreate_with_parent: falseシンボリック リンク動的フォルダ作成の一部としてシンボリック リンク(symlink)を作成することができます。artwork という名前のシンボリック リンクを作成する場合は、artwork.symlink.yml という名前のスキーマ設定でファイルを作成します。これはシステムによってシンボリック リンク要求として識別され、全体にコピーされる代わりに処理されます。artwork.symlink.yml ファイルには少なくとも target キーが含まれている必要があります。# Example of a .symlink.yml file# A target parameter is required.target: &quot;../Stuff/$Project/$Shot&quot;# Additional parameters will be passed to the hook as metadata# so you can for example include permission hints or other stuff# that you may need for advanced customizationadditional_param1: abcadditional_param2: def ターゲット パラメータに $Asset、$Shot、または $Project などの $EntityType トークンが含まれている場合、このエンティティ(アセット、ショット、プロジェクトなど)を表すフォルダの名前による解決が試行されます。Toolkit はこの値のファイルシステム ツリーを検索し、ツリーの上位で定義されていない場合は、エラーが報告されます。リスト フィールド(アセットのアセット タイプなど)は、$Asset.sg_asset_type のようなエンティティ タイプを含む構文で表されます。以下に例を示します。# Example of a .symlink.yml file# A target parameter is required.target: &quot;../renders/$Project/$Asset.sg_asset_type/$Asset&quot;symlink の作成は(すべての入力/出力(I/O)のように)フックを処理するフォルダ内で実行されます。特別な symlink アクションがシステムからフックに渡され、symlink の名前、完全に解決されたターゲット、およびこの要求とともに定義ファイル内に含まれる YAML メタデータを受け取ります。上記の artwork の例の場合、次のようにショットの下にフォルダを作成します。 {'action': 'symlink',  'path': '/mnt/projects/chasing_the_light/Sequences/AA/AA001/artwork'  'target': '../Stuff/chasing_the_light/AA001',  'metadata': {'target': '../Stuff/$Project/$Shot', 'additional_param1': 'abc', 'additional_param2': 'def'}  }ファイルとフォルダを無視するスキーマ スキャフォールドに格納されたファイルは、フォルダ作成の一環として対象領域にコピーされます。たとえば、このコピー プロセスはコア フックで処理されるため、プロジェクトまたはスタジオごとに権限の取り扱いをカスタマイズできます。                    注: この種の取り扱いの詳細は「簡単なカスタマイズ」の「I/O と権限をカスタマイズする」セクションに記載されています。多数のフォルダ設定を処理する process_folder_creation コア フック (https://github.com/shotgunsoftware/tk-core/blob/master/hooks/process_folder_creation.py#L62-L71)があります。このフックに chmod 呼び出しを追加して(mkdir を使用する際の権限の設定も可能)、作成するフォルダの権限を設定できます。    場合によっては、フォルダ作成の一環としてコピーされないように、特定のファイルとフォルダを除外するのに便利です。たとえば、Git または SVN にフォルダ作成設定を保存している場合、ショットまたはアセットの各フォルダにコピーしない .git フォルダと .svn フォルダを作成します。コピーしたくないファイルがある場合、ignore_files という名前のファイルをプロジェクト設定内の config/core/schema フォルダに配置できます。このファイルには、コピーしないようにファイルを定義する glob スタイル パターンを含める必要があります。各パターンは 1 行ずつ指定する必要があります。# This is a good example of a standard ignore_files file.svn                # no svn temp files to be copied across at folder creation time.git                # no git temp files to be copied across at folder creation time.DS_Store           # no mac temp files to be copied across at folder creation timeまた、ワイルドカードを使用することもできます。たとえば、拡張子が TMP のファイルをすべて除外する必要がある場合は、ファイルに *.tmp の行を追加するだけです。# This is a good example of a standard ignore_files file.svn                # no svn temp files to be copied across at folder creation time.git                # no git temp files to be copied across at folder creation time*.tmp           # no files with tmp extension to be copied across at folder creation timeI/O と権限をカスタマイズする多くの場合、ショットとアセットのフォルダは特別な権限とパラメータを使用して作成する必要があります。これはフォルダ作成中に権限を少しずつ設定するという簡単な作業であることも、適切な資格情報、グループ、および権限を使用してフォルダを作成する特別なフォルダ作成サーバにリモート要求を送信するという複雑な作業であることもあります。また、ファイル システムのツリー内にある各レベルのフォルダに対し、通常は異なる権限を指定する必要があります。たとえば、作業領域フォルダはすべてのユーザに対して書き込み可能にし、ショット フォルダには厳格な権限を指定する必要があります。Toolkit では 1 つのフックでフォルダ作成をカスタマイズできます。これは process_folder_creation.py という名前のコア フックです。フォルダ作成 API の呼び出しはフォルダ設定をトラバースし、作成するフォルダを特定するため、作成できる項目のリストが生成されます。この項目にはファイルとフォルダの両方が含まれます。フォルダ作成の最後の手順として、このリストは実際のフォルダの処理を取り扱うフックに渡されます。既定の process_folder_creation コア フックは、ここで確認できます(https://github.com/shotgunsoftware/tk-core/blob/master/hooks/process_folder_creation.py#L62-L71)。フックに渡されるデータフォルダ作成フックはフォルダ作成要求ごとに 1 回だけ実行されます。すべてのフォルダ作成データはリストのフックに渡されます。通常、フックはこのデータを繰り返して処理し、Core API から渡されるパラメータに従ってフォルダを作成します。リスト内のデータは常に深さ優先再帰で、最上位のフォルダとファイルから始まり、段階的に深い階層へとトラバースします。次に、フックに渡されるデータの例を示します。    [         {'action': 'entity_folder',      'entity': {'id': 88, 'name': 'Chasing the Light', 'type': 'Project'},      'metadata': {'root_name': 'primary', 'type': 'project'},      'path': '/mnt/projects/chasing_the_light'},         {'action': 'folder',      'metadata': {'type': 'static'},      'path': '/mnt/projects/chasing_the_light/sequences'},         {'action': 'entity_folder',      'entity': {'id': 32, 'name': 'aa2', 'type': 'Sequence'},      'metadata': {'entity_type': 'Sequence',                   'filters': [{'path': 'project',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04c90&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'path': '/mnt/projects/chasing_the_light/sequences/aa2'},         {'action': 'entity_folder',      'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'},         {'action': 'copy',      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'source_path': '/mnt/software/tank/chasing_the_light/config/core/schema/project/sequences/sequence/shot/sgtk_overrides.yml',      'target_path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87/sgtk_overrides.yml'},         {'action': 'create_file',      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'content': 'foo bar',      'target_path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87/automatic_content.txt'},         {'action': 'symlink',      'path': '/mnt/projects/chasing_the_light/Sequences/AA/AA001/artwork'      'target': '../Stuff/chasing_the_light/AA001',      'metadata': {'target': '../Stuff/$Project/$Shot', 'additional_param1': 'abc', 'additional_param2': 'def'}      },        ]このデータはディクショナリのリストです。各ディクショナリには action と呼ばれるキーがあります。このキーは要求された I/O 項目のタイプを示します。フォルダ作成フックを実装している場合は、次のさまざまなアクションのサポートを追加する必要があります。  entity_folder: Flow Production Tracking エンティティと関連付けられたディスク上のフォルダです。  folder: ディスク上のフォルダです。  copy: 元の場所から対象の場所にコピーする必要があるファイルです。  create_file: ディスク上に作成する必要があるファイルです。  symlink: シンボリック リンクを作成する必要があります。各アクションにはさまざまなディクショナリ キーがあります。たとえば、entity_folder アクションには、接続先のエンティティの詳細を含む entity key があります。create_file には、コピーするファイルや場所をフックに通知する source_path と target_path のキーがあります。また、すべての actions には metadata と呼ばれるキーもあります。このキーは、スキーマ セットアップの関連する設定ファイルから取得された YAML 設定データを表します。上記の例は、Flow Production Tracking フォルダの metadata キーにスキーマ設定内でセットアップされるすべてのフィルタと命名情報がどのように含まれるかについて示しています。たとえば、上記の例のショット フォルダのメタデータは次のとおりです。    {'action': 'entity_folder',      'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'} これは shot.yml スキーマ設定ファイルに対応しています。# Copyright (c) 2013 Flow Production Tracking Software Inc.## CONFIDENTIAL AND PROPRIETARY## This work is provided &quot;AS IS&quot; and subject to the Flow Production Tracking Toolkit# Source Code License included in this distribution package. See LICENSE.# By accessing, using, copying or modifying this work you indicate your# agreement to the Flow Production Tracking Toolkit Source Code License. All rights# not expressly granted therein are reserved by Flow Production Tracking Software Inc.# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the Flow Production Tracking field to use for the folder namename: &quot;code&quot;# the Flow Production Tracking entity type to connect toentity_type: &quot;Shot&quot;# Flow Production Tracking filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std Flow Production Tracking API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ] 注: 動的トークン $sequence は、実行中に実際のオブジェクトに解決されます。独自のフォルダ作成指示をフックに渡すToolkit で必要になるさまざまな設定指示とは別に、スキーマ設定の一部として独自の設定項目を定義することもできます。この項目は上述の metadata キーを使用してフックに渡され、フォルダ作成を制御するために使用されます。たとえば、スキーマ設定に次の構造があるとします。# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the Flow Production Tracking field to use for the folder namename: &quot;code&quot;# the Flow Production Tracking entity type to connect toentity_type: &quot;Shot&quot;# Flow Production Tracking filters to apply when getting the list of itemsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ]# user settingsstudio_permissions_level: &quot;admin&quot; この場合、フォルダ作成フックを使用して渡されるデータは次のようになります。    {'action': 'entity_folder',      'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity',                   'studio_permissions_level': 'admin'},      'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'} ここで、特別なパラメータ studio_permissions_level はフックに渡され、ファイル権限の制御などのために使用されます。また、このメソッドを使用すると、任意の複雑なデータ構造を渡すこともできます。この一般的な例として、非常に詳細なレベルでの権限の制御があります。カスタム設定を静的フォルダに追加する通常、フォルダ スキーマ設定内にフォルダを作成したけれども、対応する YAML ファイルがない場合、Toolkit はこのフォルダが静的で、作成されるだけだと見なします。カスタム設定のメタデータと静的フォルダを関連付ける場合は、static タイプの YAML 設定ファイルを作成する必要があります。たとえば、プロジェクト ルートの下に静的フォルダ assets があり、アセットをグループ化してカスタム設定のメタデータを追加するとします。このためには、次の assets.yml ファイルを作成します。type: staticstudio_permissions_level: &quot;admin&quot;フックに渡される設定データには次のコードが含まれます。{'action': 'folder', 'metadata': {'studio_permissions_level': 'admin', 'type': 'static'}, 'path': '/mnt/projects/chasing_the_light/assets'},任意の複雑なデータはこの方法で YAML 設定ファイルからフックに渡すことができます。フォルダの作成方法の簡単なカスタマイズ簡単なフォルダ作成フックは次のようになります。    class ProcessFolderCreation(Hook):            def execute(self, items, preview_mode, **kwargs):            &quot;&quot;&quot;     The default implementation creates folders recursively using open permissions.         This hook should return a list of created items.         Items is a list of dictionaries. Each dictionary can be of the following type:         Standard Folder     ---------------     This represents a standard folder in the file system which is not associated     with anything in Flow Production Tracking. It contains the following keys:         * &quot;action&quot;: &quot;folder&quot;     * &quot;metadata&quot;: The configuration yaml data for this item     * &quot;path&quot;: path on disk to the item         Entity Folder     -------------     This represents a folder in the file system which is associated with a     Flow Production Tracking entity. It contains the following keys:         * &quot;action&quot;: &quot;entity_folder&quot;     * &quot;metadata&quot;: The configuration yaml data for this item     * &quot;path&quot;: path on disk to the item     * &quot;entity&quot;: Flow Production Tracking entity link dict with keys type, id and name.         File Copy     ---------     This represents a file copy operation which should be carried out.     It contains the following keys:         * &quot;action&quot;: &quot;copy&quot;     * &quot;metadata&quot;: The configuration yaml data associated with the directory level     on which this object exists.     * &quot;source_path&quot;: location of the file that should be copied     * &quot;target_path&quot;: target location to where the file should be copied.         File Creation     -------------     This is similar to the file copy, but instead of a source path, a chunk     of data is specified. It contains the following keys:         * &quot;action&quot;: &quot;create_file&quot;     * &quot;metadata&quot;: The configuration yaml data associated with the directory level     on which this object exists.     * &quot;content&quot;: file content     * &quot;target_path&quot;: target location to where the file should be copied.         &quot;&quot;&quot;                # set the umask so that we get true permissions            old_umask = os.umask(0)            folders = []            try:                    # loop through our list of items                for i in items:                        action = i.get(&quot;action&quot;)                        if action == &quot;entity_folder&quot; or action == &quot;folder&quot;:                        # folder creation                        path = i.get(&quot;path&quot;)                        if not os.path.exists(path):                            if not preview_mode:                                # create the folder using open permissions                                os.makedirs(path, 0777)                            folders.append(path)                        elif action == &quot;copy&quot;:                        # a file copy                        source_path = i.get(&quot;source_path&quot;)                        target_path = i.get(&quot;target_path&quot;)                        if not os.path.exists(target_path):                            if not preview_mode:                                # do a standard file copy                                shutil.copy(source_path, target_path)                                # set permissions to open                                os.chmod(target_path, 0666)                            folders.append(target_path)                        elif action == &quot;create_file&quot;:                        # create a new file based on content                        path = i.get(&quot;path&quot;)                        parent_folder = os.path.dirname(path)                        content = i.get(&quot;content&quot;)                        if not os.path.exists(parent_folder) and not preview_mode:                            os.makedirs(parent_folder, 0777)                        if not os.path.exists(path):                            if not preview_mode:                                # create the file                                fp = open(path, &quot;wb&quot;)                                fp.write(content)                                fp.close()                                # and set permissions to open                                os.chmod(path, 0666)                            folders.append(path)                        else:                        raise Exception(&quot;Unknown folder hook action '%s'&quot; % action)                finally:                # reset umask                os.umask(old_umask)                return folders パート 2: ファイル システム テンプレートを設定するToolkit テンプレート ファイルは Toolkit 設定のハブの 1 つです。プロジェクトごとにこのようなファイルが必ず 1 つあり、パイプライン設定内の config/core フォルダ内に格納されています。このファイルには テンプレート の定義とその キー が含まれます。キーは定義された動的フィールドです。これには、名前、バージョン番号、スクリーン解像度、ショット名などを指定できます。キーには型が設定されるため、キーに文字列または整数などを定義できます。また、キーにはフォーマットを設定することもできるため、文字列に含められるのは英数字のみと定義したり、すべての整数にゼロを 8 個追加する必要があると定義したりできます。テンプレートは動的なパスです。テンプレートは shots/{shot}/publish/{name}.{version}.ma のように表示されます。このテンプレートはショットの Maya パブリッシュを表し、括弧のフィールドはキーを表します。テンプレート ファイルは、キー、パス、文字列の 3 つのセクションに分かれています。キー セクションキーはフィールドで許容される値を定義します。テンプレート設定ファイルでは、キーは次の形式で定義されます。key_name:   type: key_type   option: option_value   option: option_value キーのタイプは、str、int、または sequence のいずれかです。str キーは値が文字列のキーで、int キーは値が整数のキーで、sequence キーは値が整数の列のキーです。タイプの指定とは別に、追加オプションを指定することもできます。オプションは次のとおりです。      default: default_value: 値が何も指定されない場合に使用される値です。Toolkit API を使用して一連のフィールド値をパスに解決する場合などに使用できます。        choices: [choice1, choice2, etc]: このキーの有効値を列挙します。        exclusions: [bad1, bad2, etc]: このキーに禁止されている値を列挙します。キーのタイプが sequence の場合、フレームの仕様値はこの設定で無効にできません。        length: 12: このキーは正確な長さに指定する必要があります。        alias: new_name: このキーを使用するテンプレートが key_name の代わりに使用する名前を指定します。たとえば、バージョン番号に 2 つのコンセプトがあり、その 1 つはクライアントの希望に応じてゼロを 4 個追加し、もう 1 つは内部的な処理方法が理由でゼロを 3 つ追加するとします。この場合、両方のキーに「version」という名前を付けようとしますが、キー名は固有である必要があるため不可能です。この場合、エイリアスを作成することができます。詳細については、以下の例を参照してください。        filter_by: alphanumeric: キーのタイプが文字列の場合にのみ動作します。このオプションを指定すると、英数字の値(通常は ASCII 文字の a-z、A-Z、および 0-9 ですが、入力データが Unicode の場合は他の文字列も含めることが可能)を含む文字列のみが有効値であると見なされます。        filter_by: alpha: キーのタイプが文字列の場合にのみ動作します。このオプションを指定すると、英字値(通常は ASCII 文字の a-z と A-Z ですが、入力データが Unicode の場合は他の文字列も含めることが可能)を含む文字列のみが有効値であると見なされます。        filter_by: '^[0-9]{4}_[a-z]{3}$': キーのタイプが文字列の場合にのみ動作します。検証マスクとして正規表現を定義できます。上記の例で 4 桁のキーを指定する必要がある場合などは、アンダースコアとその後に 3 つの小文字を指定します。        format_spec: &quot;04&quot;: キーのタイプが int または sequence の場合、int または sequence の番号にはゼロまたはスペースが追加されます。例のように「04」を指定すると、ゼロが追加されて長さが 4 桁になります(例: 0003)。「03」を指定すると、ゼロが追加されて長さが 3 桁になります(例: 042)。「3」を指定すると、スペースが追加されて長さが 3 桁になります(例:” 3”)。キーのタイプがタイムスタンプの場合、format_spec は strftime と strptime の規則に従います。        strict_matching: true: キーのタイプが整数の場合にのみ動作します。この設定は、フィールドが正しくフォーマット化された番号のみに一致することを表しています。たとえば、「003」と指定して strict_matching を true に設定すると、「002」、「12345」、および「042」は一致しますが、「00003」または「2」は一致しません。一致の厳密性を緩めるには、strict_matching を false に設定します。既定の動作は厳密な一致を採用します。        shotgun_entity_type: shotgun_field_name オプションと組み合わせて使用すると、コンテキストで Flow Production Tracking の値を直接クエリーできます。これにより、ファイル名で使用するフォルダ構造で表示されていないフィールドの値を使用できます。        shotgun_field_name: shotgun_entity_type と組み合わせた場合にのみ使用します。        abstract: フィールドが抽象的であることを示します。抽象フィールドは、パターンでイメージ シーケンス(%04d)または立体視(%V)などのパスを定義する必要がある場合に使用されます。抽象フィールドには既定値が必要です。        subset と subset_format: 指定した入力文字列のサブセットを抽出し、それをキーの値にします。それにより、完全なユーザ名からイニシャルのキーを作成したり、すべてのショット名の最初の 3 文字を保持するキーを作成できます。  テンプレート キーの技術的な詳細については、「API リファレンス」を参照してください。例: 英数字の名前既定値が「comp」で英数字を使用する名前です。name:    type: str    default: &quot;comp&quot;    filter_by: alphanumericnuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{name}.v{version}.nk 例: バージョン番号002、102、034、12341 などの番号と一致するバージョン番号version:    type: int    format_spec: &quot;03&quot; 002、102、034、12341 だけでなく、0002、2、0102 などの番号とも一致するバージョン番号version:    type: int    format_spec: &quot;03&quot;    strict_matching: false 例: 立体視一般的な立体視のセットアップです。視野は L または R のいずれかですが、ソフトウェアで使用する場合、一般的な抽象化方法で %V として参照されることが多くなります。%V は、実際にはファイル名ではなくファイルのコレクションを指し、abstract フラグを設定します。抽象フィールドには、抽象的な表現が要求された場合に取得される既定値を指定する必要があります。eye:    type: str    choices: [&quot;L&quot;, &quot;R&quot;, &quot;%V&quot;]    default: &quot;%V&quot;    abstract: truenuke_shot_render_stereo: sequences/{Sequence}/{Shot}/{Step}/work/images/{Shot}_{name}_{eye}_v{version}.{SEQ}.exr例: イメージ シーケンスイメージ シーケンスは定義によって抽出され、特に指定しない限り、既定値は %0Xd に設定されます。以下のシーケンスの仕様は、0001、1234、および 12345 などのフレーム番号を識別します。SEQ:    type: sequence    format_spec: &quot;04&quot;nuke_shot_render_stereo: sequences/{Sequence}/{Shot}/{Step}/work/images/{Shot}_{name}_{channel}_{eye}_v{version}.{SEQ}.exr 例: エイリアスを使用して 2 つのフィールドに version という名前を付ける「version」という名前のキーを要求するコードで使用できるバージョン番号を 2 つ定義します。これは、2 つの Toolkit アプリの両方に version フィールドが必要だが、これらの version フィールドを個別にフォーマット化するという場合に役立ちます。nuke_version:    type: int    format_spec: &quot;03&quot;    alias: versionmaya_version:    type: int    format_spec: &quot;04&quot;    alias: version# nuke versions are using numbers on the form 003, 004, 005# the nuke publish app requires a field called {version}# however {nuke_version} is a valid replacement for {version}# because it has an alias definednuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{name}.v{nuke_version}.nk# maya versions are using numbers on the form 0004, 0005, 0006maya_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{maya_version}.ma 例: タイムスタンプ既定値が現在のローカル時間に設定され、YYYY-MM-DD-HH-MM-SS にフォーマット化されるタイムスタンプです。now:    type: timestamp    format_spec: &quot;%Y-%m-%d-%H-%M-%S&quot;    default: now 既定値が現在の UTC 時間に設定され、YYYY.MM.DD にフォーマット化されるタイムスタンプです。year_month_day:    type: timestamp    format_spec: &quot;%Y.%m.%d&quot;    default: utc_now 既定値が 9:00:00 に設定され、HH-MM-SS にフォーマット化されるタイムスタンプです。nine_am_time:    type: timestamp    format_spec: &quot;%H-%M-%S&quot;    default: &quot;09-00-00&quot; 例: マッピングこれは、Flow Production Tracking フィールドをファイル名に追加する場合などに役立ちます。ファイル名にユーザ名を含めるには、次の定義を使用します。current_user_name:    type: str    shotgun_entity_type: HumanUser    shotgun_field_name: loginnuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{current_user_name}_{name}.v{version}.nkToolkit アプリで context.as_template_fields() メソッドを使用してすべてのコンテキスト フィールドを設定すると、上位レベルの Shot、Sequence、および Step が自動的に設定されます。また、shotgun_entity_type が定義されたすべてのフィールド(上記の current_user_name フィールドなど)もスキャンします。Flow Production Tracking エンティティがコンテキストで定義されている場合は、この値が自動的に解決されるようになります。現在のユーザはコンテキストで常にトラックされ、上記の例では、ショット、シーケンス、ステップのフィールドからデータを取得することもできます。その理由は、このフィールドが上位レベルのパスとコンテキストとして定義されているためです。ただし、フィールドのアセット エンティティを参照しようとしても、Toolkit がデータ取得元の Flow Production Tracking のアセットを把握できないため、上記の例では機能しません。例: 2 つの有効な値を使用した文字列フィールド多くの場合、スタジオでは ASCII とバイナリの Maya ファイルを保存する必要があるプロジェクトを使用します。この場合、2 つの有効値を含む文字列の値は次のようになります。maya_file_extension:    type: str    choices: [&quot;ma&quot;, &quot;mb&quot;]                     注: 既定のアプリは、templates.yml で定義された内容に応じて .ma または .mb を使用します。そのため、たとえば、プロジェクトで .ma の代わりに .mb を保存するように作業ファイル アプリを変更する場合は、この 3 つのテンプレート(ショット用)を変更できます。    maya_shot_work:  '@shot_root/work/maya/{name}.v{version}.ma'maya_shot_snapshot:  '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'maya_shot_publish:  '@shot_root/publish/maya/{name}.v{version}.ma'代わりに .mb で終了すると、アプリは Maya バイナリとして保存します。maya_shot_work:  '@shot_root/work/maya/{name}.v{version}.mb'maya_shot_snapshot:  '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.mb'maya_shot_publish:  '@shot_root/publish/maya/{name}.v{version}.mb' 詳細については、以下の「パス セクション」を参照してください。例: 値を無効にする値「assets」が許可されていない文字列フィールドです。これは、たとえば、すべてのアセットが格納された 1 つの「assets」フォルダとともにプロジェクトのすべてのシーケンスを格納するフォルダを含むフォルダが 2 つある場合に役立ちます。project |--- sequence1 |--- sequence2 |--- sequence3  --- assets assets フォルダが単なる別のシーケンスではないことを Toolkit が正しく理解できるように、「assets」はシーケンス テンプレートの有効な値ではないと定義することができます。sequence:    type: str    exclusions: [&quot;assets&quot;] 上記の exclusions フィールドにより、正しく解決される 2 つのテンプレートを定義できます。sequence_work_area: {sequence}/{shot}/workasset_work_area: assets/{asset}/work 例: 文字列のサブセット次の例では、前の例を拡張して、ユーザのイニシャルを使用してファイル名のプレフィックスを作成する方法について説明します。user_initials:    type: str    shotgun_entity_type: HumanUser    shotgun_field_name: login    subset: '([A-Z])[a-z]*  ([A-Z])[a-z]*'    subset_format: '{0}{1}'nuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{user_initials}_{name}.v{version}.nk パス セクションパス セクションは作業の保存場所を指定します。すべてのパスは少なくとも名前と定義から構成されます。定義は、括弧内に設定したキー名とパスを表すキー設定されていない値を混在させたものです。たとえば、ショットの作業ファイルの定義は次のようになります。shot_work: sequences/{Sequence}/{Shot}/{Step}/work/{Shot}.v{version}.ma キーであるシーケンス、ショット、ステップ、およびバージョンは、同じテンプレート ファイル内に定義されます。                    注: 文字列キーの名前が、関連する Flow Production Tracking エンティティが格納された動的なスキーマ フォルダのエンティティ タイプと一致する場合、このフォルダ名はトークンで置き換えられます。たとえば、{Sequence} テンプレート キーのタイプが上記のスニペットのように「string」で、スキーマで「sequence」という名前の動的フォルダを使用し、それに対応した sequence.yml ファイルで、タイプが shotgun_entity になるように定義し、Flow Production Tracking の「Sequence」エンティティ タイプに接続するとします。Toolkit は、テンプレート キーがこの動的フォルダのエンティティ タイプに対応することを認識します(両方ともシーケンスであるため)。そのため、Toolkit は生成されたフォルダ名(つまり問題となっている固有のシーケンスの名前)を取得し、テンプレート キーに置き換えます。    この形式は任意のアトリビュートを定義する必要がある場合に必要です。現在、唯一のオプション属性は root_name で、複数のルートを持つプロジェクトでパスのプロジェクト ルートを指定するために使用されます。複数のルートは、プロジェクト ファイルの一部を格納する新しいストレージ ルートを追加する場合に使用します。root_name: name_of_project_rootたとえば、次のようになります。shot_work:  definition: sequences/{Sequence}/{Shot}/{Step}/work/{Shot}.v{version}.ma  root_name: primary プライマリ ルートではなく別のストレージ ルートを使用する場合は、上記の形式を使用する必要があります。この例では、このシンプルな形式を使用することで、すべてのエントリのプライマリ ルートを使用することを意味しています。文字列セクション文字列は、単純な形式で指定できる名前と定義を含める必要があるという点でパスに似ています。string_name: string_definition文字列定義は、ファイル システム パスではなく文字列に解決されるキー名とその他の値で構成されるテンプレートです。Flow Production Tracking でパブリッシュに使用する名前を指定する場合、次のようになります。maya_publish_sg_name: &quot;Maya  publish,  {name},  v{version}&quot;同じファイル内で、キー名として名前とバージョンを定義しています。テンプレートでオプション キーを使用するテンプレートのオプション キーが便利な理由は数多くあります。{SEQ} がレンダリング イメージのオプションである場合が一般的なケースの 1 つです。次の例では、/path/to/render/shot.101.exr (および 102 や 103 など)のように、フレーム番号で構成される一連の exr を設定できます。QuickTime ムービーにも、/path/to/render/shot.qt のように同じテンプレートを使用できます。より一般的なケースとしては、立体視イメージをレンダリングする場合があります。スタジオで使用する変換が left eye: file.LFT.exr, right eye: file.RGT.exr, stereo image: file.exr? の場合、{eye} をオプションにすることができます。オプション セクションは角括弧を使用して定義できます。shot_work: sequences/{Shot}/work/{Shot}.[v{version}.]ma オプション セクションには 1 つ以上のキーが含まれている必要があります。オプション セクションのキーに値を設定せずにパスを解決すると、定義内にこのセクションが存在しなかったかのようにパスが解決されます。上記の例は、1 つの定義に 2 つのテンプレートがベイク処理されていると見なすことができます。shot_work: sequences/{Shot}/work/{Shot}.v{version}.mashot_work: sequences/{Shot}/work/{Shot}.ma フィールドのディクショナリにパスすると、Toolkit は値に応じて適切なバージョンのテンプレートを選択します。&amp;gt;&amp;gt;&amp;gt; template = tk.templates[&quot;shot_work&quot;]&amp;gt;&amp;gt;&amp;gt; template.apply_fields({&quot;Shot&quot;:&quot;ABC_123&quot;, &quot;version&quot;: 12}/project/sequences/ABC_123/work/ABC_123.v12.ma&amp;gt;&amp;gt;&amp;gt; template.apply_fields({&quot;Shot&quot;:&quot;ABC_123&quot;}/project/sequences/ABC_123/work/ABC_123.ma 高度な質問とトラブルシューティング新しいエンティティ タイプをファイル構造に追加するにはどうしたら良いですか?Flow Production Tracking サイトでフィーチャ アニメーションとショートを作成し、エピソード作品の賞を獲得したとします。ここで、Toolkit にエピソード ワークフローを組み込む方法について説明します。最初に、こちらの手順に従って、Flow Production Tracking でエピソード作品の階層をセットアップします。                    注: Toolkit でのネスト関係(Flow Production Tracking のプロジェクト階層からは完全に独立)を再確認するには、上記の「親フォルダを使用して作成する」セクションを参照してください。    追加の参考資料:  エピソード エンティティはどのように動作するのですか?  エンティティ階層をカスタマイズする「エピソード &amp;gt; シーケンス &amp;gt; ショット」の階層に必要なフィールドEpisode については、任意のカスタム エンティティを使用する(サイト基本設定 &amp;gt; [エンティティ] (Entities))か、または Flow Production Tracking 7.0.7.0 で利用可能になった正式なエピソード エンティティを使用するかを選択できます。Flow Production Tracking 7.0.7.0 以前(2017 より前)に登録している場合、「TV Show」テンプレートはエピソードに CustomEntity02 を使用します。CustomEntity02 以外のエンティティや正式なエピソード エンティティを使用する場合でも、Flow Production Tracking および Toolkit は柔軟に対応しています。両方の場合について説明します。この演習のために、プロジェクト階層更新を使用してエピソードを取り込む方法の例として、エピソード(CustomEntity02)と正式なエピソード エンティティを使用します(いずれかを使用)。最初に、プロジェクトの 「エピソード &amp;gt; シーケンス &amp;gt; ショット」の階層を正しくセットアップするために、次のフィールドが Flow Production Tracking 内にあることを確認します。エピソードa) 正式なエピソード エンティティを使用する: 「エピソード」エンティティは、プロジェクト テンプレートからテレビ番組プロジェクトを作成する場合に使用されるエンティティです。またはb) カスタム エンティティを使用する:CustomEntity02 は、プロジェクト テンプレートからテレビ番組プロジェクトを作成する場合に使用されるカスタム エンティティです。前述のとおり、別のカスタム エンティティを有効にして、CustomEntity02 の代わりに使用できます。有効にしたエンティティで必ずすべての CustomEntity02 を置き換えてください。シーケンスエピソード エンティティにリンクされた、エピソード(sg_episode)と呼ばれる単一のエンティティ リンクが必要です。正式な Episode エンティティを使用CustomEntity02 を使用ショットシーケンス エンティティにリンクされたシーケンス(sg_sequence)と呼ばれる 1 つのエンティティ フィールドです。これは Flow Production Tracking のテレビ番組プロジェクト テンプレートの一部として既に存在しています。正式な Episode エンティティを使用CustomEntity02 を使用Toolkit スキーマ定義階層が次のようになっているとします({} 内のフォルダは Flow Production Tracking の名前に基づいて動的に名前が付けられます)。- {project_name} - shots episode.yml - {episode_name} sequence.yml - {sequence_name} shot.yml - {shot_name} ... …エピソードconfig/core/schema/project/shots フォルダに、episode という名前のフォルダを作成し、それに対応する episode.yml ファイルを、同じフォルダ内に次の内容で作成します。正式な Episode エンティティを使用# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the Flow Production Tracking field to use for the folder namename: &quot;code&quot;# the Flow Production Tracking entity type to connect toentity_type: &quot;Episode&quot;# Flow Production Tracking filters to apply when getting the list of items# this should be a list of dicts, each dict containing # three fields: path, relation and values# (this is std Flow Production Tracking API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]CustomEntity02 を使用# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the Flow Production Tracking field to use for the folder namename: &quot;code&quot;# the Flow Production Tracking entity type to connect toentity_type: &quot;CustomEntity02&quot;# Flow Production Tracking filters to apply when getting the list of items# this should be a list of dicts, each dict containing # three fields: path, relation and values# (this is std Flow Production Tracking API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ] これにより、このプロジェクト内にすべてのエピソードのフォルダを作成するよう Toolkit に指示されます。シーケンスconfig/core/schema/project/shots/episode フォルダに、sequence という名前のフォルダを作成し、それに対応する sequence.yml ファイルを、同じフォルダ内に次の内容で作成します。# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the Flow Production Tracking field to use for the folder namename: &quot;code&quot;# the Flow Production Tracking entity type to connect toentity_type: &quot;Sequence&quot;# Flow Production Tracking filters to apply when getting the list of items# this should be a list of dicts, each dict containing # three fields: path, relation and values# (this is std Flow Production Tracking API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_episode&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$episode&quot; ] } ]` これにより、ディレクトリ ツリー内に上記のようにエピソードにリンクされたすべてのシーケンスのフォルダを作成するよう Toolkit に指示されます。ショットconfig/core/schema/project/shots/episode/sequence フォルダに、shot という名前のフォルダを作成し、それに対応する shot.yml ファイルを、同じフォルダ内に次の内容で作成します。# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the Flow Production Tracking field to use for the folder namename: &quot;code&quot;# the Flow Production Tracking entity type to connect toentity_type: &quot;Shot&quot;# Flow Production Tracking filters to apply when getting the list of items# this should be a list of dicts, each dict containing # three fields: path, relation and values# (this is std Flow Production Tracking API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ]` これにより、ディレクトリ ツリー内に上記のようにシーケンスにリンクされたすべてのショットのフォルダを作成するよう Toolkit に指示されます。完了後、スキーマには以下の内容が反映されます。Toolkit テンプレート定義スキーマでエピソードを使用していることを Toolkit に知らせるには、上のキー セクションで新しいキーを作成して定義する必要があります。正式な Episode エンティティを使用keys:    ...    Episode:        type: str    ... 次に、以下のテンプレート パスで shot_root テンプレートと、ショット階層内にある他のテンプレート パスを更新し、{Episode} を適切な場所に挿入してディレクトリ構造内のエピソードを指定することで、エピソード階層を一致させます。...    paths:        shot_root: shots/{Episode}/{Sequence}/{Shot}/{Step}        … CustomEntity02 を使用keys:    ...    CustomEntity02:        type: str    ...次に、以下のテンプレート パスで shot_root テンプレートと、ショット階層内にある他のテンプレート パスを更新し、{CustomEntity02} を適切な場所に挿入してディレクトリ構造内のエピソードを指定することで、エピソード階層を一致させます。...    paths:        shot_root: shots/{CustomEntity02}/{Sequence}/{Shot}/{Step}        … これがエピソード &amp;gt; シーケンス &amp;gt; ショットの基本的なワークフローに関するすべての作業です。構造内でブランチをセットアップするにはどうしたら良いですか?これは、パイプライン ステップごとに異なるファイル システム レイアウトに関連しています。具体的には、構造にブランチを追加する場合に関連します。たとえば、「パイプライン ステップ A」に 1 つの構造を指定し、他のすべてのパイプライン ステップに別の構造を指定するとします。パイプラインに別の種類のアセット タイプを追加して、その新しいアセット タイプを Vehicle に設定するとします。Vehicle のファイル構造を変更して、「geoprep」や「lookdev」など、パイプライン ステップごとに異なるフォルダを指定し、このパイプライン ステップ フォルダごとに別のフォルダを作成します。この更新と同様に、現在のアセットの作成方法は同じままです。この新しいフローに対応するようパイプラインを更新する方法について説明します。手順 1: スキーマを修正する最初に、新しいアセット タイプを使用した場合の、フォルダ構造の表示方法を反映するよう、スキーマを修正します。  スキーマでこの新しいアセット タイプ vehicle の新しいブランチを作成します。  asset/ と asset.yml と同じレベルで、asset_vehicle/ フォルダと asset_vehicle.yml を追加します。  この YAML ファイルにもフィルタ設定があります。vehicle 以外の すべてのアセットに適用されるように asset.yml 内のフィルタを修正してから、タイプ vehicle のアセット_のみに_ 適用されるよう、asset_vehicle.yml を修正します。これらのフィルタの例については、こちらを参照してください。      これで asset と asset_vehicles を表す 2 つのフォルダが作成されました。これらのアセット(geoprep や lookdev など)に対して作成するすべてのフォルダを、asset_vehicle の下に追加します。    これらのアセットのファイルを保存およびパブリッシュする場合は、保存およびパブリッシュしたファイルのファイル パスを定義するテンプレートを、core/templates.yml 内に作成します。たとえば、maya_asset_work に加えて、maya_asset_work_vehicle という名前のテンプレートを作成すると、その定義は vehicle アセットの Maya 作業ファイルを保存するテンプレート化されたパスになります。手順 2: 新しい環境ファイルを作成するこの時点で、新しいアセット タイプのディレクトリ構造が作成されており、ファイルを保存およびパブリッシュする新しいフォルダ構造内の場所を定義したテンプレートがあります。ここで、この新しいテンプレートを使用するタイミングを Toolkit に指示する必要があります。このためには、新しい環境ファイルを作成します。  env/asset_vehicle_step.yml と呼ばれる env/asset_step.yml のコピーを作成します。env/asset_vehicle_step.yml が新しいテンプレートを使用しない限り、この 2 つのファイルは同一です。maya_asset_work_vehicle で maya_asset_work のすべてのインスタンスを置き換えます。作成した他の vehicle テンプレートでも同じ操作を実行します。  最後に、新しい環境を選択するタイミングを Toolkit に指示する必要があります。そのためには、pick_environment コア フックを変更し、コンテキスト内のアセットのタイプが vehicle の場合に、asset_vehicle または asset_vehicle_step を返すようにします。これで、この新しいタイプのアセット(vehicle)を使用する場合、Toolkit はその環境設定を使用するため、それに応じたファイル システム構造にファイルを保存およびパブリッシュします。カスタム パイプライン ステップを作成するにはどうしたら良いですか?Flow Production Tracking 7.0.6.0 で、管理者メニューを使用したパイプライン ステップの管理が導入されました。この機能を使用すると、パイプライン ステップにカスタム フィールドを簡単に追加できます。専門家のヒント: 多くの場合、パイプライン ステップでカスタム フィールドを使用するほうが、カスタム エンティティを作成してそのパイプライン ステップを管理するよりもパイプラインの整理に役立ちます。",
    "url": "/82ff76f7/",
    "relUrl": "/82ff76f7/"
  },
  "57": {
    "id": "57",
    "title": "Python API で発生する SSL: CERTIFICATE_VERIFY_FAILED の問題の解決",
    "content": "Python API で発生する SSL: CERTIFICATE_VERIFY_FAILED の問題の解決Python API は、API にバンドルされ、マシンに格納されている証明書のリストを利用して、Flow Production Tracking で使用されているさまざまな Web サービスに接続します。ただし、新しい認証局がリリースされた場合は、これらが Python API または OS にバンドルされていないことがあります。オートデスクの Python API には、2019 年 2 月 21 日時点の証明書の最新コピーが付属していますが、最新バージョンの API を使用している場合でも、API がこれらの証明書を使用して Amazon S3 にアップロードするのを妨害するバグが存在します。背景情報については、この AWS に関するブログの投稿を参照してください。状況を一時的に修正するには、次の解決策を試してください。                    注: これらは一時的な回避策です。オートデスクでは長期的な解決策を模索しています。    推奨される解決策Windows 証明書ストアに必要な CA 証明書を追加します。Windows 7 ユーザがこの解決策を使用する場合は、最初に PowerShell 3.0 にアップグレードするか、certutil を使用して必要な証明書を追加しなければならない可能性があります。      [スタート]を右クリックしてから、[Windows PowerShell (管理者)]を左クリックして、昇格された PowerShell を起動します。        次のコマンドを PowerShell ウィンドウに貼り付けて、[Return]キーを押して実行します。     $cert_url = &quot;https://www.amazontrust.com/repository/SFSRootCAG2.cer&quot; $cert_file = New-TemporaryFile Invoke-WebRequest -Uri $cert_url -UseBasicParsing -OutFile $cert_file.FullName Import-Certificate -FilePath $cert_file.FullName -CertStoreLocation Cert: LocalMachine Root            サムプリント 925A8F8D2C6D04E0665F596AFF22D863E8256F3F を保持している追加証明書の詳細が表示されたら操作は完了しているので、PowerShell を閉じることができます。  代わりの解決策Python API を使用している場合      Python API v3.0.39 にアップグレードします。        a. SHOTGUN_API_CACERTS を /path/to/shotgun_api3/lib/httplib2/cacerts.txt に設定します。    または    b. スクリプトを更新し、Shotgun オブジェクトをインスタンス化するときに ca_certs=/path/to/shotgun_api3/lib/httplib2/cacerts.txt を設定します。  Toolkit を使用している場合      Toolkit の展開方法に応じて、tank core コマンドを使用するか、パイプライン設定の core/core_api.yml ファイルを更新して、最新バージョンの Toolkit API にアップグレードします。        https://github.com/certifi/python-certifi/blob/master/certifi/cacert.pem にある証明書の最新リストをダウンロードします。        SHOTGUN_API_CACERTS をこのファイルの保存場所に設定します。ただし、接続を作成するときに、Python API のように Toolkit から ca_certsca_certs パラメータを指定することはできません。  Python API または Toolkit を更新できない場合      https://github.com/certifi/python-certifi/blob/master/certifi/cacert.pem にある証明書の最新リストをダウンロードします。        SSL_CERT_FILE 環境変数をこのファイルの保存場所に設定します。  ",
    "url": "/c593f0aa/",
    "relUrl": "/c593f0aa/"
  },
  "58": {
    "id": "58",
    "title": "Folder creation aborded",
    "content": "Failed to create folders: Folder creation aborded使用例現在は、Web インタフェースで新しいプロジェクトを作成してから、Flow Production Tracking Toolkit を使用して一元管理セットアップとして Toolkit を設定します。ただし、アセット名を編集しようとしても、機能は停止している(アーティストはファイルを開いて、Maya などの CCD で編集することができない)ため、「Failed to create folders」というエラーが返されます。Flow Production Tracking から、Tank コマンドを再実行してアセットを登録解除し、再登録して修正するよう求められますが、どこで実行する必要があるかは不明です。修正方法プロジェクトに対して高度なセットアップ ウィザードを実行した場合、この操作を実行するオプションは意図的に削除されています。ただし、必要に応じてプロジェクトを再セットアップすることができます。エラー メッセージに記載された Tank コマンドを実行する必要があります。tank.bat Asset ch03_rockat_drummer unregister_folderstank.bat はユーザがセットアップした設定のルートにあります。場所が不明な場合は、こちらのトピックが検索する際に役立ちます。関連リンクコミュニティの完全なスレッドを参照してください。",
    "url": "/25a37fc0/",
    "relUrl": "/25a37fc0/"
  },
  "59": {
    "id": "59",
    "title": "The Frame Server has encountered an error",
    "content": "The Frame Server has encountered an error使用例SG Desktop から Nuke を起動すると、「The Frame Server has encountered an error」というエラー メッセージが表示され、作業を続行できます。完全なエラーは、次のとおりです。The Frame Server has encountered an error.Nuke 12.1v5, 64 bit, built Sep 30 2020.Copyright (c) 2020 The Foundry Visionmongers Ltd. All Rights Reserved.Loading - init.pyTraceback (most recent call last):File “/Applications/Nuke12.1v5/Nuke12.1v5.app/Contents/Resources/pythonextensions/site-packages/foundry/frameserver/nuke/workerapplication.py”, line 18, infrom util import(asUtf8, asUnicode)ImportError: cannot import name asUtf8cannot import name asUtf8修正方法このエラーは、設定にまだ dev パスが含まれている場合に発生することがあります。関連リンクコミュニティの完全なスレッドを参照してください。",
    "url": "/2f35b796/",
    "relUrl": "/2f35b796/"
  },
  "60": {
    "id": "60",
    "title": "Getting Started",
    "content": "Isolation Feature Set - Getting StartedWant to learn more about the isolation features? See About the Isolation Feature Set for more details about what is in store for you. The Isolation feature set is available to clients with an active Flow Production Tracking subscription. Before starting, please be sure to complete your subscription purchase.To get the onboarding process started, go to Onboarding Process.To start the setup for any of the Isolation features, go to the Setup sectionIn This Section  About the Isolation Feature Set  Client Responsibilities  Onboarding Process  Planning Your Setup",
    "url": "/0f6d8a60/",
    "relUrl": "/0f6d8a60/"
  },
  "61": {
    "id": "61",
    "title": "はじめに",
    "content": "はじめにFlow Production Tracking Toolkit には、スタジオのパイプラインを作成するための高度にカスタマイズ可能な一連のツールが用意されています。アーティストは、コンテンツ作成ソフトウェアから移動しなくても、Flow Production Tracking から情報にアクセスし、他のユーザと作品を共有できます。これらのガイドは、実践的な演習を通して、独自の Toolkit パイプラインを設定できるように設計されています。Flow Production Tracking Toolkit アプリを使用すると、プロジェクト用の編集可能な設定を生成したり、既存のアプリの設定を変更したり、さまざまなアーティストの環境に Toolkit アプリを追加してカスタム パイプラインを設計したりできます。各ガイドは以前のガイドを基に作成されていますが、記載されている手順はどこから読み進めてもかまいません。",
    "url": "/3c5b69aa/",
    "relUrl": "/3c5b69aa/"
  },
  "62": {
    "id": "62",
    "title": "ERROR 18:13:28.365:Hiero(34236) Error! タスク タイプ",
    "content": "ERROR 18:13:28.365:Hiero(34236): Error! タスク タイプ使用例:config_default2 に更新した後、nuke_studio が初期化されません。Nuke 12.0 Studio では、スクリプト エディタでエラーは発生しませんが、Nuke 11.1v3 では次のエラーが発生します。ERROR 18:13:28.365:Hiero(34236): Error! Task type tk_hiero_export.sg_shot_processor.ShotgunShotProcessor Not recognisedロールバック後にエラーが発生しなかった場合も、tk-nuke エンジンは初期化されず、Flow Production Tracking で何もロードされません。コミュニティの投稿に完全なログが含まれているので、詳細を確認できます。エラーの原因Nuke Studio の起動として処理されず、標準的な Nuke の起動として処理されている可能性があります。Nuke Studio ソフトウェア エンティティとパスが定義されていて、引数が -studio に設定されています。引数は --studio に設定する必要があります。修正方法ソフトウェア エンティティの引数を -studio に設定する必要があります。コミュニティの完全なスレッドを参照してください。",
    "url": "/8edc0d13/",
    "relUrl": "/8edc0d13/"
  },
  "63": {
    "id": "63",
    "title": "Houdini Flow Production Tracking 統合が起動しないのはなぜですか。",
    "content": "Houdini Flow Production Tracking 統合が起動しないのはなぜですか。ここでは、Flow Production Tracking の統合で Houdini が起動しない場合に見られる、最も一般的な理由について説明します。この場合、Houdini は Flow Production Tracking Toolkit、Flow Production Tracking の Web サイト、または tank コマンドからエラーなしで起動します。ただし、Houdini が起動すると、Flow Production Tracking メニューまたはシェルフは表示されません。この問題は、HOUDINI_PATH 環境変数がオーバーライドされていて、Flow Production Tracking がその環境変数に基づいて起動スクリプト パスを渡そうとしているために発生することがよくあります。Houdini を Flow Production Tracking から起動すると、起動アプリケーション ロジックは Flow Production Tracking ブートストラップ スクリプト パスを HOUDINI_PATH 環境変数に追加します。ただし、Houdini に houdini.env ファイルがあると問題が発生する可能性があります。このファイルがあると、ユーザーは Houdini がロードされたときに存在する環境変数を設定できますが、ファイルに定義されている値によって現在のセッションの既存の環境変数が上書きされます。これを修正するには、その変数の新しい定義に既存の HOUDINI_PATH 環境変数を含めます。たとえば、houdini.env ファイルに既に次のように記述されている場合:HOUDINI_PATH = /example/of/an/existing/path;&amp;amp;次のように、ファイルに定義されているパスの終端に $HOUDINI_PATH; と追加して保存する必要があります。HOUDINI_PATH = /example/of/an/existing/path;$HOUDINI_PATH;&amp;amp;これにより、Houdini の起動時に Flow Production Tracking の設定値が維持されます。                    注意: Windows では、問題が発生する原因が $HOUDINI_PATH にあることがわかりました。この変数によって Shotgun の統合へのブートストラップが数回試行され、次のようなエラーが表示されます。Toolkit bootstrap is missing a required variable : TANK_CONTEXTこのエラーが表示される場合は、代わりに %HOUDINI_PATH% を使用してください。    問題が解決しない場合は、サポート チームに問い合わせて問題の診断を依頼してください。",
    "url": "/eecfb05b/",
    "relUrl": "/eecfb05b/"
  },
  "64": {
    "id": "64",
    "title": "概要",
    "content": "",
    "url": "/",
    "relUrl": "/"
  },
  "65": {
    "id": "65",
    "title": "Windows で Flow Production Tracking Toolkit をサイレント インストールするにはどうすればいいですか?",
    "content": "Windows で Flow Production Tracking Toolkit をサイレント インストールするにはどうすればいいですか?Flow Production Tracking Toolkit インストーラをサイレントで実行するには、次の方法で Flow Production Tracking Toolkit インストーラを起動します。ShotgunInstaller_Current.exe /Sインストール フォルダも指定する場合は、引数 /D を使用して起動します。ShotgunInstaller_Current.exe /S /D=X: path to install folder.                    注: 引数 /D は最後の引数として指定する必要があります。パスの中にスペースがある場合でも、&quot; は使用しないでください。    ",
    "url": "/3a27b3da/",
    "relUrl": "/3a27b3da/"
  },
  "66": {
    "id": "66",
    "title": "アプリを追加する",
    "content": "アプリを追加するこのガイドを読み終えると、Toolkit の設定管理ツールに関する知識を短時間で得ることができます。次の内容について学習します。  アクティブなパイプライン設定のコピーを安全に作成する  設定にアプリを追加する  特定の環境でこのアプリを使用するために必要な設定を追加する  変更をアクティブな設定にプッシュするこのガイドについてこのガイドでは、既存のパイプライン設定に Flow Production Tracking Toolkit アプリを追加する方法について説明します。設定管理ツールに関する知識を短時間で得ることができます。ここで追加するアプリは、Flow Production Tracking Python コンソール アプリです。Maya には独自の Python コンソールがありますが、Toolkit アプリには Maya コンソールにない機能がいくつか用意されています。このガイドでは、「パイプライン設定を編集する」ガイドで作成したパイプライン設定を利用します。このガイドをまだ完了していない場合は、既存のパイプライン設定を使用してアプリを追加してください。このドキュメントの使い方このガイドを使用して Toolkit アプリをインストールするには、以下が必要です。  アクティブな Flow Production Tracking サイト。  指定したプロジェクトのパイプライン設定、または「設定の基本操作」ガイドを参照して、この演習で作成された設定を使用します。  パイプライン設定の保存先のファイルシステムに最適になるように設定された読み取りおよび書き込み権限。  システムにインストールされた Flow Production Tracking Toolkit。  Maya の有効なサブスクリプション。Maya の 30 日間無償体験版はこちらから取得してください。                    注: このガイドは tk-config-default2 パイプライン設定をベースにしています。設定が変更されている場合は、YAML 設定のファイル、フォルダ、およびブロックの場所がここに記載されている内容と異なる可能性があります。    Flow Production Tracking Toolkit アプリについてToolkit アプリの仕組みパイプライン設定で参照されているアプリは、さまざまな場所から取得できます。既定の設定の標準アプリは、Flow Production Tracking アプリ ストアから取得されています。パイプライン設定内のファイルを使って、Flow Production Tracking 統合からアプリにアクセスする方法を指定します。これはたとえば Toolkit に、「アドレス帳にある Python コンソール アプリのアドレスを調べることはできますか」と尋ねるようなものです。パイプライン設定ファイルは Toolkit に、特定のアプリで利用されているコードのバンドルの検索場所を指示します。Toolkit アプリの「アドレス」は既定の設定の config/env/includes/app_locations.yml ファイルにリストされていて、コードの検索方法を指定します。これらの「アドレス」は記述子といいます。Flow Production Tracking の統合には、アプリのコード バンドルの検索方法だけでなく、アプリの使用環境も指示する必要があります。以下に、アプリのインストール方法と、Flow Production Tracking の統合にアプリの使用場所を指示する方法について、概念を示します。また、設定を拡張し、記述子を検索するよう Toolkit に要求して、アプリの使用場所を Flow Production Tracking に指示する手順についても説明します。このガイドでは、次の手順について詳細に説明します。  追加するアプリの記述子を判別します。  アプリの記述子の追加先となるアクティブなパイプライン設定をコピーします。  アプリの記述子が設定に含まれているかどうかを確認して、含まれていない場合は追加します。  YAML ファイルを正しくフォーマットします(インデントにはタブでなく、スペースを使用します)。  アプリの使用環境を判別します。  これらの環境内で、Flow Production Tracking にアプリの使用を許可する設定を追加します。  新しい設定をテストします。  拡張した設定を有効にします。Python コンソール アプリの場所の記述子を見つける手順 1: 「アプリとエンジンの概要」ページを開いて、Maya の Flow Production Tracking Python コンソールの情報を検索します。タイトルを選択します。こうすると、アドレス帳に必要なすべての情報を含む、アプリの情報が表示されます。システム名は主要な識別子です(tk-multi-pythonconsole)。最新バージョンも必要です( v1.1.2)。Maya のプロジェクト環境内に Python コンソール アプリが含まれていないことを確認する手順 2: Maya を起動し、Flow Production Tracking メニューから、[ShotGrid] &amp;gt; [プロジェクト the_other_side] (Project the_other_side)を選択して、プロジェクト環境内にある、このプロジェクトで使用可能なアプリのリストを表示します。設定を拡張するプロダクションで使用している設定を編集するには、まずコピーを作成してから、そのコピーを編集します。この方法で編集すると、有効な設定に影響を与えることなく、テストのための安全なスペースを確保してから、設定を有効にすることができます。ステージング サンドボックスを作成すると、現在プロダクションで使用しているパイプライン設定のコピーを使用して再生できます。サンドボックス内で設定のコピーを変更し、変更内容をテストしてから、変更をプロダクションにプッシュして有効にします。パイプライン設定のクローンを作成すると、コピーを作成し、コピーを使用して再生できるサンドボックスを構築してから、新しい設定を有効なプロダクションにプッシュするプロセスが自動化されます。アプリを追加するパイプライン設定のクローンを作成する[パイプラインの設定] (Pipeline Configuration)リストに移動します。手順 3: Flow Production Tracking を開き、右上にある[管理者] (Admin)メニュー(アバター) &amp;gt; [既定のレイアウト] (Default Layouts) &amp;gt; [パイプラインの設定] (Pipeline Configuration) &amp;gt; [パイプライン設定リスト] (Pipeline Configuration List)を選択します。この操作を行うと、Flow Production Tracking サイトのすべてのパイプライン設定の詳細なリストが表示されます。手順 4: [パイプライン設定リスト] (Pipeline Configuration List)が表示されたら、列見出しの右端にある[+]記号を選択して、[プロジェクト] (Projects)列を追加します。プロジェクトの設定の配置場所を確認する手順 5: オペレーティング システムに該当する[パス] (Path)フィールドを追加します。設定ファイルのパスが表示されます。手順 6: [プライマリ] (Primary)行項目の横にある空のスペース内で右クリックして、コンテキスト メニューから[この設定のクローンを作成…] (Clone this Configuration…)を選択します。手順 7: [パイプライン設定リスト] (Pipeline Configuration List)内の設定およびディレクトリ内のファイルに、それぞれ「Primary Clone Config 2」および「the_other_side_clone2」という名前を付けます。[OK]をクリックします。Flow Production Tracking によって設定内のすべてのファイルおよびフォルダがコピーされ、アプリのキャッシュが作成されるまで待ちます。この時間を利用して、エスプレッソの完璧なショットと一緒に、軽く、ふわっとした、口の中でとろけるクロワッサンを作成するアプリを使用しましょう。完了すると、クローンが作成された設定の情報を使用して[パイプライン設定リスト]が更新され、ローカルな config フォルダに新しい設定が追加されます。                    注: [ユーザ制限] (User Restrictions)の下にユーザ名が追加されています。Flow Production Tracking は、この設定を作成したユーザのみが新しい設定にアクセスできるよう、自動的に制限します。この設定を編集し、テストして、最終的に使用するユーザを追加することができます。ただし、Flow Production Tracking の柔軟性を高めて、詳細なコントロールを可能にする方法がもう 1 つあります。    クローン作成された設定にプロジェクトを関連付ける手順 8: Flow Production Tracking Toolkit を開いて、クローン作成した設定を作成する対象となったプロジェクトを選択します。右上にある下矢印を選択して、このプロジェクトに関連付けられた設定を表示し、直前に作成した[Primary Clone Config 2]を選択します。これで、Flow Production Tracking Toolkit がこのプロジェクトでクローン作成した設定を使用するようになりました。パイプライン設定を編集する手順 9: クローン作成した設定を、ファイルシステム上の、この設定を作成するときに指定したパス内で検索します。config/env/includes/app_locations.yml ファイルを表示します。app_locations.yml ファイルは既定の設定のアドレス帳です。このファイルには、アプリの記述子がリストされています。このファイルはアプリの配置場所を示しているため、ユーザはこのファイルを基にアプリの設定を作成することができます。使用するアプリがアドレス帳で参照されていない場合は、Toolkit に検索場所を指示する必要があります。Toolkit にアプリの検索場所を指示する手順 10: ファイル内で pythonconsole を検索します。プロジェクトで既定の設定を使用した場合は、Python コンソール アプリの記述子がこのファイル内にリストされます。この記述子は、作業開始時に調べた Maya アプリのリスト内にある記述子と一致する必要があります。アプリのバージョンが、Maya アプリのリスト内にあったバージョンと一致することを確認します。apps.tk-multi-pythonconsole.location:	type: app_store	name: tk-multi-pythonconsole	version: v1.1.2                    注: 別の設定を使用している場合は、その記述子をファイルに追加しなければならいことがあります。    すべてのアプリおよびエンジンに記述子があります。記述子の仕組みと type: の設定方法の詳細については、Core API ドキュメントの記述子に関するセクションを参照してください。Toolkit に記述子を使用するよう指示するMaya のプロジェクト環境内で作業している場合は、記述子を使用して Python コンソール アプリを特定し、このアプリを使用するよう Toolkit に指示する必要があります。手順 11: クローン作成した設定内にある config/env/project.yml ファイルを開き、tk-maya エンジンの設定を検索します。# configuration for all engines to load in a project contextengines:  tk-3dsmaxplus: &quot;@settings.tk-3dsmaxplus.project&quot;  tk-desktop: &quot;@settings.tk-desktop.project&quot;  tk-flame: &quot;@settings.tk-flame.project&quot;  tk-hiero: &quot;@settings.tk-nuke.hiero.project&quot;  tk-houdini: &quot;@settings.tk-houdini.project&quot;  tk-mari: &quot;@settings.tk-mari.project&quot;  tk-maya: &quot;@settings.tk-maya.project&quot;  tk-motionbuilder: &quot;@settings.tk-motionbuilder.project&quot;  tk-nuke: &quot;@settings.tk-nuke.project&quot;  tk-nukestudio: &quot;@settings.tk-nuke.nukestudio.project&quot;  tk-photoshopcc: &quot;@settings.tk-photoshopcc.project&quot;  tk-shell: &quot;@settings.tk-shell.project&quot;  tk-shotgun: &quot;@settings.tk-shotgun.project&quot;@settings を使用する tk-maya: “@settings.tk-maya.project” 行は、設定がインクルードされたファイルに含まれていることを示します。tk-maya は Maya エンジンを識別し、project は環境を識別します。YAML ファイルFlow Production Tracking Toolkit パイプライン設定は YAML ファイル内で単純な用語を使用して、アプリやエンジンの場所、およびこれらの設定を識別します。この特定のブロックの各要素は、次のとおりです。  settings は、既定の設定で、設定フォルダの参照として選択された内容を表します。  project は、既定の設定で、プロジェクト環境の参照として選択された内容を表します。  tk-maya は、Maya 用の Toolkit エンジンの識別子です。  @ は、設定値がインクルードされたファイルから取得されたことを示すために使用される Toolkit 用語です。YAML ファイルは Flow Production Tracking の統合の窓口であり、パイプラインの要求を満たす作業環境を簡単に設定できるようにします。設定における Toolkit バンドルの参照方法Flow Production Tracking の統合のコードは、アプリ、エンジン、およびフレームワークのバンドルに整理されています。これらのバンドルは、tk-maya、tk-multi-pythonconsole のような記述子を使用して、Toolkit の YAML ファイル内で参照されています。YAML の各バンドルに対応するブロックには、識別されたバンドルへのアクセス方法や利用方法をコントロールする設定が含まれています。Python コンソールの設定の配置場所既定の設定のこの特定のブロックに含まれている「tk-maya.project」は、プロジェクト環境内の Maya エンジンの識別子です。ここで目標とするのは、Python コンソール アプリのコード バンドルをプロジェクト環境内の Maya エンジンに追加することです。使用された用語を基に判断すると、tk-maya.yml が、プロジェクト環境の設定が配置されている YAML ファイルの名前であることは確実です。tk-maya.yml ファイル内の settings.tk-maya.projectで apps を検索します。手順 13: ファイルを検索するには、includes セクションの engines の上で tk-maya.yml を探します。./includes/settings/tk-maya.yml手順 14: クローン作成した設定内の config/env/includes/settings/tk-maya.yml をテキスト エディタで開き、settings.tk-maya.project を検索します。手順 15: 次の行の下に場所の記述子を追加します。settings.tk-maya.project:  apps:about アプリの tk-multi-about: をガイドとして使用して、場所の記述子を追加し、ファイルを保存します。                    注: YAML ファイルが、タブでなくスペースを使用して正しくフォーマットされていることを確認してください。    # projectsettings.tk-maya.project:  apps:    tk-multi-about:      location: &quot;@apps.tk-multi-about.location&quot;    tk-multi-pythonconsole:      location: &quot;@apps.tk-multi-pythonconsole.location&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-multi-shotgunpanel: &quot;@settings.tk-multi-shotgunpanel&quot;    tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;Screening Room、Flow Production Tracking Panel、および Workfiles2 アプリの場所識別子は別のインクルードされたファイルにリストされていて、About アプリとアクセス方法が異なります。これらのアプリには追加設定があるため、情報整理しておくために、これらのアプリはインクルードされた設定フォルダに分割して配置されています。                    注: python コンソール アプリは既に既定の設定に存在しますが、これまでに設定に追加したことがないアプリを追加する場合、またはアプリのバージョンを変更し、中央設定を使用している場合は、追加の手順が必要になります。端末を開いて、クローン作成した設定の保存場所を参照します。クローン作成した設定のルート フォルダから、次のコマンドを実行します。Linux または Mac の場合:./tank cache_appsWindows の場合:tank.bat cache_appsこれにより、設定内のアプリ、エンジン、フレームワークがスキャンされ、それらがすべてダウンロードされたことが確認されます。    Maya で変更内容を表示する手順 16: Flow Production Tracking Toolkit を開いて、作業しているプロジェクトを選択し、クローン作成された設定を使用していることを確認します。青いバーが表示され、プロジェクトの名前の下に、作成したクローンの名前が示されます。                    注: プライマリを使用している場合は、青いバーは表示されず、設定の名前は表示されません。    手順 17: Desktop から Maya を起動して、メニュー [ShotGrid] &amp;gt; [プロジェクト] (Project) &amp;gt; […]を選択します。次の場合:  直前に編集した、クローン作成した設定を使用している場合  クローン作成した設定が正しく拡張された場合  拡張したファイルを保存した場合  プロジェクトにクローン作成した設定を関連付けるよう選択した場合  Flow Production Tracking Toolkit から Maya を再起動した場合Maya で Python コンソール アプリを使用できるようになります。プロダクションに変更をプッシュするPython コンソール アプリが正しく追加されたことを確認したら、変更を有効にすることができます。手順 18: 端末を開いて、クローン作成した設定の保存場所を参照します。クローン作成した設定のルート フォルダから、次のコマンドを実行します。Linux または Mac の場合:./tank push_configurationWindows の場合:tank.bat push_configurationプロンプトに従って、プロジェクトのプライマリ設定(変更のプッシュ先の設定)の ID を入力します。$ lscache		config		install		tank		tank.bat$ ./tank push_configurationWelcome to the Flow Production Tracking Toolkit!For documentation, see https://developer.shotgridsoftware.comStarting Toolkit for your current path'/Users/michelle/Documents/Shotgun/configs/the_other_side_clone2'- The path is not associated with any Shotgun object.- Falling back on default project settings.- Running as user 'Michelle'- Using configuration 'Primary Clone Config 2' and Core v0.18.159- Setting the Context to Project the_other_side.- Running command push_configuration...----------------------------------------------------------------------Command: Push configuration----------------------------------------------------------------------This command will push the configuration in the current pipeline configuration('Primary Clone Config 2') to another pipeline configuration in the project.By default, the data will be copied to the target config folder. If pass a--symlink parameter, it will create a symlink instead.Your existing configuration will be backed up.The following pipeline configurations are available to push to: - [1] Primary (/Users/michelle/Documents/Shotgun/configs/the_other_side)Please type in the id of the configuration to push to (ENTER to exit):クローン作成した設定のプッシュ先に指定できるパイプライン設定のリストが表示されます。設定を更新しているプロジェクトのプライマリ パイプライン設定の ID を入力します。                    注: このガイドの「手順 3」に示した Flow Production Tracking の[パイプラインの設定] (Pipeline Configuration)ページにも、パイプライン設定の ID が表示されています。プロジェクト ID を検索するには、設定リストに移動して、ID 列を追加します。    ID を入力した後、Flow Production Tracking は以下の処理を行います。  プライマリ設定をバックアップする  クローン作成した設定をコピーする  クローンされた設定のコピーにプロジェクトを関連付けて、クローンをそのまま残す  プライマリ設定の保存場所を表示する  ダウンロードしてキャッシュに入れなければならないアプリがあるかどうかを確認するPlease type in the id of the configuration to push to (ENTER to exit): 1Hold on, pushing config…Your old configuration has been backed up into the following folder:/Users/michelle/Documents/Shotgun/configs/the_other_side/config.bak.20190118_111627Checking if there are any apps that need downloading…Push Complete!プライマリ設定で行った変更を表示する手順 19: Flow Production Tracking Toolkit の右上にある矢印をクリックして、[CONFIGURATION]リスト内の[Primary]を選択します。手順 20: Desktop から Maya を起動して、メニュー[ShotGrid] &amp;gt; [プロジェクト] (Project) &amp;gt; […]を参照して、Flow Production Tracking Python コンソールを検索します。Python コンソール アプリが、選択されたプロジェクトのプロジェクト環境に追加されました。2 番目のガイドの「設定を編集する」で、各環境は独立していて、プロジェクトには専用の設定があること、およびプロジェクトをロードするときに、ソフトウェアの統合によってパイプライン設定から設定が収集されることを説明しました。Python コンソールを環境内で使用できるように設定するには、app_locations.yml ファイル内で場所の記述子を参照するようこの環境に指示する必要があります。この場合、Python コンソール アプリを使用可能にするパイプラインの任意のポイントで、「Python コンソール アプリをここで使用する」ように設定する必要があります。高度なトピックFlow Production Tracking 開発者のコミュニティToolkit の素晴らしい点の 1 つに、Toolkit アプリを誰でも作成できることがあります。また、アプリの所有権を維持したり、Flow Production Tracking コミュニティ内でアプリを共有して Flow Production Tracking ツールに追加したりできます。Flow Production Tracking コミュニティ ページで共有可能な便利なアプリを作成した場合は、サポート サイトにアクセスしてサポートを依頼してください。標準的な Toolkit アプリや、愛情のこもった Flow Production Tracking コミュニティで作成されたアプリについては、ShotGrid-dev Google グループで活発に議論されています。Flow Production Tracking コミュニティの貢献度が高まるにつれて、知識やツールの基盤も拡大しています。設定の拡張方法を調べるプロジェクトで使用する設定を選択するときにおわかりになったように、Python コンソール アプリは Flow Production Tracking Toolkit のドロップダウンから使用できます。パイプラインに追加するアプリを使用している環境がある場合は、少し推理を働かせて、このアプリを設定に追加するのに必要な情報を見つけることができます。アプリが使用されている環境内の設定ファイルを調べると、アプリの場所の記述子および設定の追加方法がわかります。Desktop アプリはプロジェクト環境内で開くため、project.yml ファイル内で tk-desktop を検索します。config/env/project.yml を開きます。注: engine ブロック内の tk-desktop は、インクルードされた内容を指します。includes:  - ./includes/settings/tk-desktop.ymlengines:  tk-desktop: &quot;@settings.tk-desktop.project&quot;インクルードの内容に従って、config/env/includes/settings/tk-desktop.yml を開き、settings.tk-desktop.project ブロックを検索します。このブロック内に、次の行が含まれています。apps:  tk-multi-pythonconsole:  location: &quot;@apps.tk-multi-pythonconsole.location&quot;これらのブロックに従い、プロジェクトの手順中に Python コンソール アプリが Desktop エンジンに追加されます。インクルードの内容に沿って ../includes/app_locations.yml に進み、apps.tk-multi-pythonconsole.location を検索します。次のようになっています。# pythonconsoleapps.tk-multi-pythonconsole.location:  type: app_store  name: tk-multi-pythonconsole  version: v1.1.2すべてのアプリ、エンジン、およびフレームワークに、特定のバンドルのアクセス場所を Toolkit に指示するための場所の記述子が設定されています。多くのアプリ記述子が app_locations.yml ファイルに含まれていますが、Python コンソール アプリで確認したように、これらの記述子が必要な場所で参照されていない可能性があります。すべての標準アプリおよびエンジンは、「アプリとエンジンの概要」ページにリストされています。任意のアプリを Flow Production Tracking でサポートされている適切なソフトウェア統合に追加したり、独自のアプリケーションを Toolkit ツールに追加したりできます。サポートされているすべてのソフトウェア アプリケーションは、統合の「アプリとエンジンの概要」ページにもリストされています。探しているアプリが見つからない場合は、自分で作成できます。これを機会に、他の Flow Production Tracking ユーザにこの機能の必要性が広まる可能性があります。また、新しいアプリを共有することで、Flow Production Tracking コミュニティに恩返しができます。次のガイドでは、会社の構成方法に合わせて制作用フォルダの構成をカスタマイズする方法について学習します。",
    "url": "/4d147fb2/",
    "relUrl": "/4d147fb2/"
  },
  "67": {
    "id": "67",
    "title": "Flow Production Tracking 統合管理者ガイド",
    "content": "Flow Production Tracking 統合管理者ガイドはじめにこのドキュメントは、管理者向けの Flow Production Tracking 統合ガイドです。ユーザ ガイド、管理者ガイド、開発者ガイドのうちの 1 つです。ユーザ ガイドは、日常のワークフローで Flow Production Tracking の統合を必要とするエンド ユーザとしてのアーティストを対象としています。また、開発者ガイドは、機能を拡張するための Python コードを記述するユーザを対象にしたテクニカル ドキュメントです。この統合管理者ガイドは、これら 2 つのドキュメントの中間に位置するものです。Flow Production Tracking を統合するユーザ、ソフトウェア バージョンを管理するユーザ、パブリッシュ ファイルのストレージを決定するユーザを対象にしています。標準的なパイプライン設定Toolkit セットアップの中心はパイプライン設定です。つまり、インストールしたアプリからソフトウェア バージョンに至るまですべてを管理したり、ときにはプロダクションのディレクトリ構造とファイル名をセットアップするためのテンプレートを格納する YAML ファイル セットです。パイプライン設定は高度にカスタマイズ可能ですが、2 つの開始点が用意されています。基本設定すぐに利用可能な統合機能は、環境設定ファイルをセットアップまたは変更しなくても実行できるように設計されています。すぐに利用可能な統合機能を使用する場合は、管理が必要なものは何もありません。Toolkit が内部でパイプライン設定を暗示的に使用します。このパイプライン設定は基本設定と呼ばれています。基本設定によって、すべてのサポート対象ソフトウェア パッケージで Panel、Publisher、Loader の 3 つの Toolkit アプリを利用できるようにしたり、Flow Production Tracking のソフトウェア エンティティを参照して Flow Production Tracking Toolkit に表示するソフトウェア パッケージを決定します。基本設定にはファイルシステム ロケーション サポートが含まれていません。プロジェクトですぐに利用可能な統合機能を使用すると、Desktop を起動するたびに基本設定のコピーが自動的に更新されるため、常に最新バージョンの統合が使用されます。こちらでリリース ノートにサブスクライブしたり、こちらで Github の基本設定を参照することができます。既定の設定これは高度なプロジェクト設定を開始するための既定の開始点です。これには、ファイルシステムのロケーション サポートと、さまざまな Toolkit アプリとエンジンが含まれています。Github の既定の設定は、こちらで参照できます。既定の設定の構造の詳細については、パイプライン設定の config/env/README.md ファイルを参照するか、こちらの Github で参照してください。                    注: 古い設定構造を使用するには統合の v1.1 リリースでは、効率性と分かりやすさを最大限に高め、基本設定の構造とより適合するように、既定の設定の構造を再調整しました。従来の既定の設定に基づいてプロジェクトを作成することもできます。プロンプトが表示されたら[Legacy Default]を選択し、[Desktop Set Up Project]ウィザードで設定を選択します。    PublisherPublisher は、すぐに使用可能なワークフローとすべてのパイプライン設定間の移行を簡単に実行できるように設計されています。すぐに使用可能なセットアップでは、ファイルが所定の方法でパブリッシュされるため、テンプレートまたはファイル システム スキーマを定義する必要がありません。高度なセットアップでプロジェクトを設定し、すべてのパイプライン設定を完了したら、同じパブリッシュ プラグインがアプリ設定に導入されたテンプレートを認識し、パブリッシュ前に指定されたパブリッシュ場所に対してファイルのコピーを開始します。このため、すべてが設定されたプロジェクトに対して、環境ごとまたは DCC ごとにテンプレートベースの設定を必要に応じて導入できます。既定の設定は、テンプレートベースのワークフローが完全に設定されているため、Publish アプリでテンプレートを設定する方法の確認に使用できます。詳細については、Github の既定の設定にある tk-multi-publish2.yml ファイルを参照してください。Publisher 用のプラグインの作成の詳細については、開発者ガイドの Publisher に関するセクションを参照してください。ソフトウェアの起動を設定するシステムでホスト アプリケーションの Flow Production Tracking の自動検出を使用するのは簡単です。Flow Production Tracking Toolkit を起動し、プロジェクトを選択するだけで、アプリケーションの標準フォルダ内に格納されたサポート対象のすべてのソフトウェア パッケージのランチャーが Desktop に表示されます。ただし、このソフトウェアをより細かく管理するための強力なツールもご用意しています。アプリケーションが、特定のプロジェクト、グループ、または個別のユーザに対してのみ表示されるよう制限できます。バージョンを指定し、サイト全体で任意のソフトウェア パッケージを無効にして、ソフトウェア パッケージをまとめてグループ化できます。これらはすべて、Flow Production Tracking のソフトウェア エンティティを使用して管理されます。新しい Flow Production Tracking サイトを作成すると、既定のソフトウェア エンティティ セットが用意されます。サポート対象のホスト アプリケーションごとに 1 つのエンティティが設定されます。このエンティティを修正し、独自のエンティティを追加すると、ユーザの希望どおりに Desktop に表示されるソフトウェアを管理できます。Flow Production Tracking でソフトウェア エンティティを表示するには、画面の右上隅にあるプロファイル アイコンをクリックし、[管理者] (Admin)メニューを開いて、Software を選択します。ソフトウェア エンティティには次のフィールドがあります。  ソフトウェア名: Desktop のソフトウェアの表示名です。  [サムネイル] (Thumbnail): Desktop アイコン用にアップロードされるイメージ ファイルです。  [ステータス] (Status): ソフトウェアが利用できるかどうかをコントロールします。  [エンジン] (Engine): コンテンツ作成ツールの統合の名前です。  [製品] (Products): バリアントを含むソフトウェアパッケージの場合(HoudiniとHoudini FX)、ここではカンマ区切りリストを指定できます。手動モードではなく、自動検出モードの場合のみ有効です。  [バージョン] (Versions): 表示するソフトウェアの特定のバージョンです。ここではカンマ区切りリストを指定できます。手動モードではなく、自動検出モードの場合のみ有効です。  [グループ] (Group): Group フィールドの値が同じエンティティは、Desktop の 1 つのアイコンと Flow Production Tracking の 1 つのメニューにグループ化されます。たとえば、Houdini と Nuke を含む FX グループを作成することもできます。  グループの既定値: グループ内のいずれかのメンバーの Group Default が選択されている場合、このアイコンまたはメニュー項目をクリックすると、このソフトウェアが起動します。  [プロジェクト] (Projects): ソフトウェアを特定のプロジェクトに制限する方法です。  ユーザ制限: ソフトウェアを特定のユーザまたはグループに制限する方法です。  Linux/Mac/Windows のパス: ソフトウェアに対する OS 固有のパスを明示的に指定するためにこのフィールドを使用します。  Linux/Mac/Windows の引数: ソフトウェアの起動時にコマンドに追加するためのコマンドライン引数です。ここでは、これらのフィールドがどのように動作するかを学習するために、いくつかの使用方法を説明します。例: 同一アプリケーションのバージョンをグループ化する(自動検出)ファイルシステム上に、Maya 2016、Maya 2017、および Maya 2018 の 3 つの Maya のバージョンがあるとします。そして、これらすべてのバージョンをアーティストが利用できるようにしたいのですが、Desktop の 1 つのアイコンにすべてのバージョンがグループ化されている状態にしようと思います。これら 3 つのバージョンの Maya がファイルシステム上の標準の場所にインストールされている場合は自動的に実行されます。Desktop でプロジェクトを選択すると、ローカル マシンの標準的なアプリケーション ディレクトリをスキャンし、3 つのバージョンを探します。Flow Production Tracking で Maya ソフトウェア エンティティを既に指定しているため、特定のバージョンまたはパスを指定しなくても、Desktop 内で検出されたすべてのバージョンが表示されます。注意事項は次のとおりです。  Flow Production Tracking がソフトウェアを自動検出すると、1 つのソフトウェア エンティティですべてのバージョンのメニュー項目が生成されます。  パス フィールドの値を指定する必要はありません。ソフトウェア エンティティが自動検出モードの場合、アプリは標準の場所に格納されていると見なされます。すべてのバージョンが Desktop に表示されます。Maya の場合は 1 つのアイコンが表示され、ドロップダウン リストにすべての利用可能なバージョンが表示されます。アイコン自体をクリックすると、最新バージョンの Maya が起動します。例: 同一アプリケーションのバージョンをグループ化する(手動モード)これは標準の場所以外に Maya を格納している場合に最適です。独自のソフトウェア エンティティを作成し、Flow Production Tracking にソフトウェアの場所が分かるようにパスを指定するだけです。次のように設定することができます。注意事項は次のとおりです。  自動検出モードとは異なり、任意のソフトウェア パッケージのバージョンごとにソフトウェア エンティティがあります。  これをグループ化するには、Group フィールドと Group Default フィールドを使用します。Group で同じ値を共有するソフトウェア エンティティは Desktop で 1 つのアイコンのドロップダウンにグループ化されます。その名前には Group の値が使用されます。  このアイコン自体をクリックすると、Group Default を選択しているグループ内のソフトウェアが起動します。  ソフトウェア エンティティで Linux のパス、Mac のパス、または Windows のパスの いずれか に値を指定すると、このエンティティは手動モードに移行します。自動検出モードとは異なり、パス フィールドが空のときにソフトウェアが Desktop に 表示 されます。手動モードでは、ソフトウェア パッケージのパスが指定されており、そのファイルが指定されたパスに存在する場合、ソフトウェア パッケージは任意のオペレーティング システム上で のみ 表示されます。  上記の例では、Windows Path を指定していないため、Windows にインストールされている Desktop には、Maya のバージョンは 3 つとも表示されません。例: ユーザまたはグループ別に制限する上記の最後の例で、Maya 2018 をすべてのユーザに利用可能にする準備がまだできていないとします。しかし、TD、Dev、QA エンジニア、Tessa Tester が使用できるようにするには、どうしたら良いでしょうか。この場合には、User Restrictions フィールドを使用します。以下の例を参照してください。最後の例にいくつかの変更を加えました。  グループの既定値は Maya 2017 です。これをプロダクション バージョンにする場合、このボックスを選択して Maya のアイコンをクリックすると、このバージョンが起動します。  ユーザとグループの両方が受け入れられるように、User Restrictions フィールドにいくつかの値を追加しました。Dev と TD のグループと Tessa Tester ユーザを追加しました。これで、これらのユーザの Desktop にだけ Maya 2018 が表示されます。例: ソフトウェアのバージョンをプロジェクトごとに制限する複数のプロジェクトにわたってバージョンを細かく管理することが必要な場合があるかもしれません。プロジェクトを急いで仕上げなければならない場合に、新しいバージョンのソフトウェアの使用を制限していたが、それと同時に、その後継バージョンがリリースされ、評価が行えるようになったとします。このような場合は、ソフトウェア エンティティを次のようにセットアップすると良いかもしれません。重要な注意事項は次のとおりです。  任意の環境の Desktop で表示される Maya のバージョンを 1 つにするため、ここでは Group と Group Default の値を削除しています。  3 つすべてのバージョンの Software Name を「Maya」に設定しています。この方法では、すべてのプロジェクトでユーザに同一名のアイコンが表示されますが、アイコンにはここで設定した内容に応じて異なるバージョンが指定されます。  Maya 2016 の Status フィールドを Disabled に設定しています。このバージョンはもう使用しません。このフィールドですべてのプロジェクトのグローバル表示が切り替わります。  Maya 2017 と Maya 2018 の Projects に値を指定しています。Projects は制限事項として機能します。Maya 2017 が表示されるのは Chicken Planet プロジェクト のみ で、Maya 2018 は Chicken Planet II にしか表示されません。  ソフトウェア エンティティの Projects に値を指定すると、ソフトウェアは指定したプロジェクトでしか表示されなくなります。そのため、スタジオに Chicken Planet シリーズとは別のプロジェクトがある場合は、そのプロジェクトのソフトウェアを明示的に指定する必要があります。例: 独自のソフトウェアを追加する次のような理由がある場合、Flow Production Tracking Toolkit がシステムで自動検出したソフトウェア エンティティとは別に、新しいソフトウェア エンティティの追加が必要になる場合があります。  Desktop でユーザが利用可能なエンジンがないためにアプリケーションを作成する必要がある場合。  社内ソフトウェアやサードパーティのソフトウェアなど、オートデスクではまだ統合を用意していないソフトウェアを使用し、独自のエンジンを定義している場合。  ソフトウェアが標準の場所に格納されていないため、Flow Production Tracking とそのソフトウェアを手動で接続する場合(この場合は、上記の「同一アプリケーションのバージョンをグループ化する(手動モード)」に記載されています)。上記の場合、独自のソフトウェア エンティティを追加することができます。Software Name フィールドに値を指定する必要があります。ソフトウェアに社内のエンジンを使用する場合は、Engine フィールドにこのエンジンの名前を指定します。スタジオによっては、アーティストの利便性を考えて、Flow Production Tracking に統合されていないアプリを Desktop に追加すると良い場合があります。アーティストは Desktop からこのアプリを直接起動できます。バージョンと使用上の制限を管理するために、上記の設定をすべて使用することもできます。この場合、Engine フィールドは空の状態にしますが、Mac Path、Linux Path、Windows Path のいずれかのフィールドに値を指定する必要があります。パブリッシュ ファイル パスの解決を設定するファイルをパブリッシュすると、Publisher は Flow Production Tracking に PublishedFile エンティティを作成します。これには、Path と呼ばれるファイル/リンク フィールドが含まれます。その後、別のユーザがローダーを使用して独自の作業セッションにこのファイルをロードしようとします。Loader は複雑なロジックを使用して、有効なローカル パスをオペレーティング システム上の PublishedFile に解決します。Loader がパブリッシュ データをパスに解決する方法は、パブリッシュがローカル ファイル リンクまたは file:// URL に関連付けられているかどうかによって異なります。ローカル ファイル リンクを解決するパブリッシュするパスが Flow Production Tracking の[サイト基本設定] (Site Preferences)で定義されたローカル ストレージと一致する場合、ローカル ファイル リンクがパブリッシュ時に自動的に生成されます。パブリッシュがローカル ファイル リンクの場合は、そのローカル オペレーティング システムの表示が使用されます。ローカル ファイル リンクの詳細については、こちらを参照してください。ローカル ストレージで現在使用しているオペレーティング システムのパスを定義しない場合は、環境変数を使用すると、ローカル ストレージ ルートを指定できます。環境変数の名前は SHOTGUN_PATH_&amp;lt;WINDOWS|MAC|LINUX&amp;gt;_&amp;lt;STORAGENAME&amp;gt; の形式になります。そのため、「Renders」と呼ばれるストレージ ルートのパスを Mac で定義する場合は、環境変数 SHOTGUN_PATH_MAC_RENDERS を作成します。次の例を使用して詳細を確認してみましょう。  Flow Production Tracking サイトに「Renders」と呼ばれるストレージ ルートがあり、次のパスが指定されているとします。  Linux のパス: /studio/renders/  Windows のパス: S: renders       Mac のパス: &amp;lt;blank&amp;gt;        現在は Mac を使用しています。    パス /studio/renders/sq100/sh001/bg/bg.001.exr のパブリッシュをセッションにロードします。ローダーはパスを解析して /studio/renders/ がパスのストレージ ルートであると推定しますが、Mac 用のストレージ ルートは定義されていません。そのため、環境変数 SHOTGUN_PATH_MAC_RENDERS を探します。環境変数が見つかると、パスの /studio/renders とその値を置き換えます。注: 環境変数 SHOTGUN_PATH_MAC_RENDERS を定義して、ローカル ストレージ レンダリングで Mac のパスが設定されている場合は、ローカル ストレージの値が使用され、警告がログに記録されます。注: 現在のオペレーティング システムでどのストレージも解決できない場合は、PublishPathNotDefinedError が発生します。ファイルの URL を解決するローダーは file:// URL の解決もサポートします。パブリッシュ時、パブリッシュするパスがサイトのローカル ストレージのどれとも一致しない場合、パスは file:// URL として保存されます。ローカル ファイル リンクとは異なり、このパスはマルチ OS 表現に保存されず、作成元のオペレーティング システムで定義されるだけです。URL を作成したときとは異なるオペレーティング システムで file:// URL を解決しようとすると、Loader は一連の手法を使用して URL を有効なパスに解決しようとします。  最初に、SHOTGUN_PATH_WINDOWS、SHOTGUN_PATH_MAC、および SHOTGUN_PATH_LINUX の 3 つの環境変数を探します。これらの環境変数が定義されている場合は、メソッドがこの方法でパスを変換しようとします。たとえば、Windows で file:///prod/proj_x/assets/bush/file.txt を解決する場合、SHOTGUN_PATH_WINDOWS=P: prod と SHOTGUN_PATH_LINUX=/prod をセットアップして、パスの解決方法のヒントを示すことができます。  複数の環境変数を使用する場合は、複数のストレージを表現するために、上記の変数名構文にサフィックスを付けて拡張します。  レンダリングのストレージがある場合、たとえば、SHOTGUN_PATH_LINUX_RENDERS、SHOTGUN_PATH_MAC_RENDERS、および SHOTGUN_PATH_WINDOWS_RENDERS を定義して、レンダリング ストレージ内のデータを参照するようにパブリッシュされたすべての file:// URL に移行メカニズムを提供します。  その後、編集データのストレージもある場合は、SHOTGUN_PATH_LINUX_EDITORIAL、SHOTGUN_PATH_MAC_EDITORIAL、および SHOTGUN_PATH_WINDOWS_EDITORIAL を定義して、編集ストレージ ルートに移行メカニズムを提供します。これらの環境変数で標準化したら、環境変数を Flow Production Tracking のローカル ストレージに変換できます。ローカル ストレージを Flow Production Tracking のプリファレンスで定義すると、自動的に選択されるため、環境変数は不要になります。  上記に加えて、Flow Production Tracking のプリファレンスで定義したすべてのローカル ストレージも同様です。  ローカル ストレージが定義されているがオペレーティング システムが見つからない場合は、環境変数を使用して指定することができます。たとえば、Linux と Windows で定義された Renders と呼ばれるローカル ストレージがある場合は、SHOTGUN_PATH_MAC_RENDERS と呼ばれる環境変数を作成することにより、Mac をサポートするように拡張することもできます。この一般的な構文は SHOTGUN_PATH_&amp;lt;WINDOWS|MAC|LINUX&amp;gt;_&amp;lt;STORAGENAME&amp;gt; です。  一致するルートがない場合は、ファイル パスがそのまま返されます。次に例を示します。Linux で /projects/some/file.txt というファイルをパブリッシュしたため、Flow Production Tracking に file:///projects/some/file.txt という URL のパブリッシュが生成されました。Linux のパス /projects は Windows の Q: projects と同じであるため、フル パスは Q: projects some file.txt に変換されると考えられます。次のすべてのセットアップでこれを処理します。  一般的な環境ベースのオーバーライド:  SHOTGUN_PATH_LINUX=/projects  SHOTGUN_PATH_WINDOWS=Q: projects      SHOTGUN_PATH_MAC=/projects        「Projects」と呼ばれる Flow Production Tracking のローカル ストレージで次のパスを設定します。    Linux のパス: /projects  Windows のパス: Q: projects      Mac のパス: /projects        「Projects」と呼ばれる Flow Production Tracking のローカル ストレージで次の環境変数を使用します。    Linux のパス: /projects  Windows のパス:  Mac のパス: /projects  SHOTGUN_PATH_WINDOWS_PROJECTS=Q: projects注: Linux path と環境変数 SHOTGUN_PATH_LINUX_RENDERS が設定された Flow Production Tracking でローカル ストレージ Renders が定義されている場合は、ストレージが優先され、環境変数は無視され、警告がログに記録されます。一般的に、ローカル ストレージ定義は、環境変数よりも常に優先されます。高度な設定PublishedFile パスの解決を実行する基本的なメソッドの詳細については、開発者向けリファレンス ドキュメントを参照してください。高度なプロジェクト セットアップを使用している場合は、resolve_publish コア フックをカスタマイズして、ローカル ファイル リンクと file:// URL 以外のサポートを追加できます。有効なカスタマイズは次のとおりです。  アップロード ファイルが関連付けられたパブリッシュは、コア フックによって適切なキャッシュの場所に自動的にダウンロードされ、パスが返されます。  カスタム URL スキーマ(perforce:// など)はローカル パスに解決できます。ブラウザの統合Flow Production Tracking Toolkit でのブラウザ統合とは、Flow Production Tracking Web アプリケーションの右クリック コンテキスト メニューを使用して、Toolkit アプリおよびランチャーにアクセスすることを指します。上に例が示されているこのメニューには、さまざまなエンティティ タイプに対して設定されたアクションが含まれています。プロジェクトのパイプライン設定が複数ある場合、アクションはパイプライン設定別に整理されます。ブラウザ統合により、Flow Production Tracking のコンテキストを認識する Maya や Nuke などのコンテンツ作成ソフトウェアをブラウザから直接起動できるようになります。ブラウザ統合の簡単な歴史長年にわたり、Flow Production Tracking Toolkit のブラウザ統合は複数の方法を取ってきました。技術とセキュリティ要件が進歩するにつれて、ブラウザ統合を実装するためのアプローチも進歩してきました。Java アプレット(廃止済み)最初は、Flow Production Tracking の Web アプリケーションからローカル デスクトップへのアクセスを提供する Java アプレットとして実装されました。Java アプレットが悪用可能なセキュリティ リスクとして認識されるにつれて、Java アプレットは衰退し、廃止を余儀なくされました。ブラウザ プラグイン(廃止済み)廃止された Java アプレットと置き換えられたのは、NPAPI を利用して Flow Production Tracking Web アプリケーションからローカル デスクトップにアクセスするブラウザ プラグインでした。NPAPI もセキュリティ リスクとして認識されるようになったため、主要な Web ブラウザは NPAPI の使用をブロックし始めました。そのため、ブラウザ プラグインは廃止を余儀なくされました。Flow Production Tracking Toolkit を介した Websocket v1 (旧バージョン)Flow Production Tracking Toolkit アプリ内で Websocket サーバをホストすることも、Flow Production Tracking Web アプリケーションからローカル デスクトップと通信するアプローチでした。この方法は現在も使用できます。この Websocket サーバの RPC API の最初の実装では、以前の Java アプレットとブラウザ プラグインのために開発されたものと同じ基盤技術が使用されていました。サーバが Flow Production Tracking から要求を受け取ると、関連付けられたプロジェクトのパイプライン設定の tank コマンドが使用され、アクション メニューに表示されるコマンドのリストが取得されました。Flow Production Tracking Toolkit を介した Websocket v2Websocket サーバの RPC API のバージョン 2 では、Toolkit アクションの取得、キャッシュ、および実行に使用される基盤メカニズムが変更されています。この変更により、以前のブラウザ統合の実装に関連する多くのパフォーマンス上の問題が解決され、アクション メニューの視覚的構成が改善されました。また、すぐに利用可能な Flow Production Tracking 統合のサポートも追加されました。これにより、Toolkit を明示的に設定しなくても動作するようになりました。これがブラウザ統合の現在の実装です。環境設定エンティティ タイプごとにユーザに提示されるアクションをコントロールするには、プロジェクトのパイプライン設定で YAML 環境ファイルを変更します。最初にカスタマイズを試みるときに、いくつかの点について理解し、検討する必要があります。どのエンジン設定を使用するかFlow Production Tracking Web アプリ内の Toolkit アクションを管理する Toolkit エンジンは tk-shotgun であるため、このエンジンの設定によりアクション メニューに表示される内容がコントロールされます。上記の tk-config-basic の例では、2 つのアプリが設定されており、多数のエンジン コマンドがメニュー アクションに変換されています。Toolkit アプリによって、アクション メニューに含まれるコマンドが登録されます。これにはローカル システム上の各ソフトウェア パッケージを起動するコマンドなどがあり、Flow Production Tracking サイトにあるソフトウェア エンティティのリストに対応しています。その結果、メニュー アクションのリストは次のようになります。ブラウザ統合コードにより、ユーザのシステムで Houdini、Maya、Nuke、および Photoshop のインストールが検出されたため、それぞれの統合を起動するためのメニュー アクションが作成されました。特定の環境設定ファイルでは、その環境のエンティティにソフトウェアのランチャーを表示するために、ソフトウェア エンティティの エンジン が必要になります。そのため、この例では、tk-houdini、tk-maya、tk-nuke、および tk-photoshopcc エンジンのすべてが、このスニペットの取得元であるファイルに含まれている必要があります。たとえば、このエンティティのランチャーのリストから Maya を削除する場合は、環境設定ファイルから tk-maya エンジン ブロックを削除するだけです。また、Publish アプリの Publish… コマンドもメニューに含まれています。どの YML ファイルを使用するか2 つの方法のいずれかを使用できます。1 つはプライマリ環境設定(config/env/*.yml)で、環境設定の pick_environment.py コア フックによってコントロールします。もう 1 つは、tk-config-default によって採用された config/env/shotgun_&amp;lt;entity_type&amp;gt;.yml ファイルを使用する旧式の方法です。標準環境ファイルを使用する場合、ブラウザの統合では pick_environment コア フックが使用され、指定されたエンティティのアクション メニューに使用される環境設定ファイルが決定されます。最も単純なケースでは、環境はエンティティ タイプに対応します。たとえば、ショットを右クリックした場合、結果のアクション メニューは config/env/shot.yml の tk-shotgun ブロックで設定されます。より複雑なロジックを使用するように pick_environment フックをカスタマイズすることができます。標準環境ファイルに tk-shotgun エンジンが設定されておらず、shotgun_&amp;lt;entity_type&amp;gt;.yml ファイルが存在する場合はフォールバックが発生します。これにより、エンティティ固有の環境ファイルを利用する従来の設定でブラウザの統合を行うことができます。ヒント: tk-config-default2 によるブラウザ ランチャーからのソフトウェアの削除Flow Production Tracking ブラウザからソフトウェアを起動する設定の更新方法は、tk-config-default と tk-config-default2 で異なります。tk-config-default2 では、更新は config/env/includes/settings/tk-shotgun.yml に適用する必要があります。tk-config-default では、更新は config/env/shotgun_task.yml に適用されていました。たとえば、ブラウザ上でアセットから起動するときに、オプションのリストから Mari を削除してみましょう。まず、config/env/asset.yml に移動し、tk-shotgun エンジン ブロックがどのように @settings.tk-shotgun.asset を参照しているかを確認します。@ の記号は、設定の値がインクルードされたファイルのものであることを示します。つまり、env/includes/settings/tk-shotgun.yml に移動して更新する必要があることを意味します。env/includes/settings/tk-shotgun.yml で、エンティティごとのブロックの状態を確認します。たとえば、最初にアセットが次のようになっているとします。&amp;lt;a name=&quot;asset&quot;&amp;gt;&amp;lt;/a&amp;gt;# assetsettings.tk-shotgun.asset:  apps:    tk-multi-launchapp: &quot;@settings.tk-multi-launchapp&quot;    tk-multi-launchmari: &quot;@settings.tk-multi-launchapp.mari&quot;    tk-multi-launchmotionbuilder: &quot;@settings.tk-multi-launchapp.motionbuilder&quot;    tk-multi-publish2: &quot;@settings.tk-multi-publish2.standalone&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-shotgun-folders: &quot;@settings.tk-shotgun-folders&quot;    tk-shotgun-launchfolder: &quot;@settings.tk-shotgun-launchfolder&quot;  location: &quot;@engines.tk-shotgun.location&quot;ブラウザでアセットのオプション リストから Mari を削除するには、Mari の行を削除します(tk-multi-launchmari: &quot;@settings.tk-multi-launchapp.mari&quot;)。&amp;lt;a name=&quot;asset&quot;&amp;gt;&amp;lt;/a&amp;gt;# assetsettings.tk-shotgun.asset:  apps:    tk-multi-launchapp: &quot;@settings.tk-multi-launchapp&quot;    tk-multi-launchmotionbuilder: &quot;@settings.tk-multi-launchapp.motionbuilder&quot;    tk-multi-publish2: &quot;@settings.tk-multi-publish2.standalone&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-shotgun-folders: &quot;@settings.tk-shotgun-folders&quot;    tk-shotgun-launchfolder: &quot;@settings.tk-shotgun-launchfolder&quot;  location: &quot;@engines.tk-shotgun.location&quot;次に、Flow Production Tracking ブラウザで特定のソフトウェアを起動する機能を削除したいエンティティ(Shot など)ごとに同じ手順を実行します。ファイルを保存したら、1 分待ってからブラウザをハード リフレッシュして設定を有効にする必要があります。キャッシングブラウザの統合には堅牢なキャッシング メカニズムがあるため、可能な限りすばやくメニュー アクションをユーザに表示することができます。Toolkit をブートストラップしてエンジン コマンドのリストを取得するプロセスに時間がかかることがあるため、この機能が必要です。キャッシュはいつ無効になるかWebsocket サーバの RPC API は、キャッシュされたデータがまだ有効かどうかを判断するために、2 つのものを確認します。YAML ファイルの変更時刻と、サイトのソフトウェア エンティティの内容です。指定された環境設定内のいずれかの YAML ファイルが、キャッシュ データが書き込まれた後に変更されている場合、必要なデータが再キャッシュされ、新しいデータが Flow Production Tracking Web アプリケーションに返されます。同様に、データがキャッシュされた後に Flow Production Tracking のソフトウェア エンティティ上のフィールドが変更された場合、Toolkit はブートストラップされ、新しいデータがキャッシュされます。キャッシュ ファイルはディスク上のどこにあるかキャッシュ ファイルの場所は、オペレーティング システムによって異なります。OS X: ~/Library/Caches/Shotgun/&amp;lt;site_name&amp;gt;/site.basic.desktop/tk-desktopWindows: %APPDATA% Shotgun &amp;lt;site_name&amp;gt; site.basic.desktop tk-desktopLinux: ~/.shotgun &amp;lt;site_name&amp;gt; site.basic.desktop tk-desktopフック メソッドbrowser_integration.py フックは、次のフック メソッドを提供する tk-framework-desktopserver に含まれています。  get_cache_key: このメソッドは、指定した設定の URI、プロジェクト エンティティ、およびエンティティ タイプに使用されるキャッシュ エントリのキーを決定します。既定の実装では、設定の URI およびエンティティ タイプが組み合わされます。  get_site_state_data: このメソッドを使用すると、Flow Production Tracking からクエリーされた追加データを、キャッシュ内データの有効性をテストするために使用されるハッシュに含めることができます。既定では、サイト上にあるすべてのソフトウェア エンティティの状態が使用されますが、ハッシュに追加データを含める場合は、このフック メソッド内で実装することができます。  process_commands: このメソッドは、Flow Production Tracking Web アプリケーションに返されるコマンドをカスタマイズまたは変更する場所を提供します。このメソッドに提供されるデータ構造は、各ディクショナリが単一のメニュー アクションを表す、ディクショナリのリストです。データは必要に応じて変更、除外、またはリストに追加することができ、Toolkit アクションを要求するメニューに直ちに反映されます。ログブラウザ統合のログは、Toolkit の標準のログの場所にあります。関連するログ ファイルは tk-desktop.log と tk-shotgun.log です。また、Google Chrome を使用している場合は、ブラウザの開発者コンソールで関連するログ出力を利用できることがあります。トラブルシューティングWeb アプリケーションとローカル デスクトップとの通信は複雑な性質を持つため、途中で障害が発生する可能性があります。以下に、障害の例とそのような状況になったときに最初にとるべき手順についての提案をいくつか示します。アクション メニューにFlow Production Tracking Toolkit を開くかインストールしてこのメニューを有効にすると表示されるこれは、次の 3 つのうちのいずれかを意味する可能性があります。      Flow Production Tracking Toolkit が現在、ローカル マシン上で実行されていない。これは明らかなことに思えますが、間違いなく再確認する価値があります。        Chrome または Python の Websocket サーバが接続を拒否したため、Flow Production Tracking Web アプリケーションが Flow Production Tracking Toolkit と通信できなくなった。この状況は、要求時に接続を続行できる自己署名証明書に関連している可能性が高いです。多くの場合、これらの証明書を最初から再生成することで問題が解決します。再生成は、次に示すように Flow Production Tracking Toolkit からトリガできます。    Flow Production Tracking Toolkit の Websocket サーバが起動に失敗した。この状況は、Websocket サーバの問題のあるリリースが一般に公開された場合にほぼ限定され、非常にまれです。この場合、エラーを説明するログが tk-desktop.log に記録されます。このログを Flow Production Tracking のサポート チームに送信してください。アクション メニューにアクションが表示されないこのエンティティ タイプに対してアクションが予想されている場合、これは設定上の問題があることを示しています。考えられる問題はいくつかあります。      tk-shotgun エンジンは正しい YAML 環境ファイルで設定されているものの、その環境設定内にアプリが存在しない。この場合、このエンティティ タイプに対してアクションが存在しないことが意図されている可能性があります。        tk-shotgun エンジンが正しい YML 環境ファイルで設定されていて、アプリが存在するにもかかわらず、アクションがメニューに表示されない。これは、アプリが初期化に失敗したことが原因の可能性があります。この場合、問題を説明する情報が tk-shotgun.log と tk-desktop.log に記録されています。        このエンティティ タイプに対応する環境に、tk-shotgun の環境設定が含まれていない。この場合の最終的な結果は、このリストの 1 番と同じです。この場合、パイプライン設定の pick_environment フックを確認することでこのエンティティ タイプに対してどの環境がロードされているかを判断でき、そこで tk-shotgun の環境設定を確認できます。        ディスクに空のメニュー アクション リストがキャッシュされています。キャッシュを強制的に再生成するには、次のいくつかの方法の中から選択できます。          プロジェクトの環境設定で YAML ファイルの変更時刻を更新します。こうすると、次回に Flow Production Tracking からメニュー アクションが要求されたときに、メニュー アクションの再キャッシュがトリガされます。注目する必要があるのは、これによってプロジェクトで作業している すべて のユーザに対して再キャッシュがトリガされることです。      Flow Production Tracking サイトで、いずれかのソフトウェア エンティティのフィールド値を更新します。この場合の動作は、上記の YAML ファイルの変更時刻を更新した場合と同じですが、Flow Production Tracking サイトの_すべて_のプロジェクトで、すべてのユーザのキャッシュされたデータが無効になります。ソフトウェア エンティティは非プロジェクト エンティティであるため、すべてのプロジェクトで共有されます。いずれかのソフトウェア エンティティのデータが変更された場合は、すべてのプロジェクトが影響を受けます。      問題の影響を受けるホストのキャッシュ ファイルを削除できます。キャッシュを削除しても、通常は問題ありません。各ホストにキャッシュがローカルに保存されているため、この特定のシステム上のデータが最初から再キャッシュされるだけです。キャッシュは、Flow Production Tracking のキャッシュ場所にある SQLite ファイル(&amp;lt;site-name&amp;gt;/site.basic.desktop/tk-desktop/shotgun_engine_commands_v1.sqlite)に格納されます。      Toolkit: アクションを取得中…がメニュー アクションと置き換わらないこれにはいくつかの可能性があります。      Websocket サーバがまだキャッシング アクションを完了していない。プロジェクトの環境設定が大幅に更新された後に初めてアクションが取得される場合、プロセスの完了に時間がかかることがあります。時間を置いてから、tk-desktop.log の内容を確認して、処理がまだ行われているかどうかを確認してください。        Websocket サーバが応答に失敗し、その後も応答しない。このような状況はまれですが、tk-desktop.log を確認してアクションの要求の結果として追加の処理が行われていないことが明らかになった場合は、Flow Production Tracking サポートに連絡して関連するログ データを提供してください。        ユーザが複数の Flow Production Tracking サイトで作業している。Flow Production Tracking Toolkit が 1 つのサイトに対して認証されているときに、2 番目の Flow Production Tracking サイトからメニュー アクションを要求すると、Flow Production Tracking Toolkit を再起動して新しいサイトにログインするかどうかを尋ねられます。この要求が無視されると、2 番目のサイトはメニュー アクションのリストを受け取らなくなります。  Toolkit 環境設定ファイルプロキシ サーバを使用している場合、最初のログイン画面のいくつかの値を事前に指定する場合や、ブラウザベースのアプリケーション ランチャーと Flow Production Tracking Toolkit を統合する方法を調整する場合は、toolkit.ini と呼ばれる特別な設定ファイルを使用します。Flow Production Tracking Toolkit の実行にこのファイルは必要ありません。必要になるのは、その動作を設定する必要がある場合のみです。Toolkit は、次の順序で複数の場所にあるファイルを検索します。  ファイル パスをポイントする SGTK_PREFERENCES_LOCATION という名前の環境変数。  Flow Production Tracking Toolkit プリファレンス フォルダ内: (このファイルは次の場所に既定では存在しません。自分で作成する必要があります。)          Windows: %APPDATA% Shotgun Preferences toolkit.ini      macOS: ~/Library/Preferences/Shotgun/toolkit.ini      Linux: ~/.shotgun/preferences/toolkit.ini      SGTK_PREFERENCES_LOCATION 環境変数オプションを使用すると、コンピュータ上またはネットワーク上のどこにでも設定ファイルを保存できます。toolkit.ini は現在の標準ファイル名です。_ を使用する場合は、「_従来の場所config.ini」セクションを確認してください。設定ファイルの例については、こちらを参照してください。このサンプル ファイルは config.ini と呼ばれていますが、名前を toolkit.ini に変更できます。このファイルで環境変数とハードコードされた値を使用すれば、Windows 上に存在する変数 USERNAME を介し、既定のユーザ名などを選択してユーザに候補を表示することもできます。従来の場所(廃止済み)toolkit.ini は現在の標準ファイル名ですが、以前は config.ini ファイルを同じ目的で使用していました。toolkit.ini と config.ini の内容は同じです。config.ini は、次の廃止された場所を使用する場合に検索されます。  ファイルをポイントする SGTK_DESKTOP_CONFIG_LOCATION という名前の環境変数  次のパス:          Windows: %APPDATA% Flow Production Tracking Toolkit config config.ini      macOS: ~/Library/Caches/Shotgun/desktop/config/config.ini      Linux: ~/shotgun/desktop/config/config.ini      プロキシ設定スタジオがプロキシ経由でインターネットにアクセスしている場合、インターネットへのアクセス時にこのプロキシの使用を Toolkit に指示する必要があります。そのためには、プロキシを http_proxy 設定の値に指定します。http_proxy: &amp;lt;proxy_server_address&amp;gt;ローカル ホスト サイトで Flow Production Tracking Toolkit を実行するFlow Production Tracking サイトの URL の最後が shotgunstudio.com または shotgrid.autodesk.com でない場合は、ローカルの Flow Production Tracking サイトを実行していることを示します。この場合、サイトと Flow Production Tracking との統合の準備が完了していない可能性があり、開始前に Flow Production Tracking チームによる何らかの調整が必要になる場合があります。この場合は、サポートいたしますのでチケットを送信してください。ローカル ホスト サイトでアプリ ストアに接続するプロキシ経由でインターネットにアクセスできるローカルの Flow Production Tracking サイトを使用している場合は、ローカルの Flow Production Tracking Web サイトではなく、HTTP プロキシを設定してアプリ ストアにアクセスすると便利です。そのためには、次の行を toolkit.ini に追加するだけです。app_store_http_proxy: &amp;lt;proxy_server_address&amp;gt;この &amp;lt;proxy_server_address&amp;gt; は開発者ドキュメントに記載されている規則に従う文字列です。プロジェクトごとにこの設定を上書きする必要がある場合は、プロジェクトのパイプライン設定の config/core/shotgun.yml に上書きします。オフライン使用のシナリオ一般的な使用方法の場合、Flow Production Tracking Toolkit は起動時に Desktop アプリ自体、tk-desktop エンジン、および基本設定の更新を自動的に確認します。しかし、オフラインで、またはインターネットから完全に切断されたマシンで統合を実行する場合もあります。次のセクションでは、それぞれのシナリオに対処する方法について説明します。ShotGridCreateこのドキュメントで概説されているオフライン使用シナリオを解決するアプローチは、Flow Production Tracking Create で提供される統合機能にも適用されます。Flow Production Tracking Toolkit の動作を調整するために使用されるさまざまな環境変数(SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS など)は、Flow Production Tracking Create を使用する場合でも、Flow Production Tracking Toolkit と同じように適用されます。オフライン時に統合を実行するシナリオ: Flow Production Tracking の統合を実行したいと考えていますが、インターネットに接続していません。ローカルに Flow Production Tracking をインストールしています。解決方法  一時的にインターネットに接続できる場合は、Flow Production Tracking Toolkit をダウンロードします。Flow Production Tracking Toolkit には一連の統合があらかじめパッケージ化されており、サポートされているすべての DCC 向けの Flow Production Tracking の統合に必要なアプリとエンジンがあらかじめすべてバンドルされています。Flow Production Tracking Toolkit を起動すると自動的にアップグレードが検索されますが、Flow Production Tracking App Store に接続できない場合は、ローカルに存在する最新のバージョンが実行されます。知っておきたい情報  Flow Production Tracking サイトにアクセスしないと実行できない Toolkit 操作(パブリッシュの登録など)があります。そのため、この解決策はローカルにホストされたサイトでのみ機能します。  更新はローカル マシンにダウンロードされます。  接続と切断を切り替える場合、Desktop に加えて Maya や Nuke などのアプリ内統合でも、接続されているときの起動時にアップグレードがダウンロードされます。手動ダウンロードで更新を管理するシナリオ: アーティストのワークステーションがインターネットから切断されているため、Desktop の自動アップデートを使用することができません。それでも更新を入手したいと考えていますが、1 台のオンライン マシンから更新をダウンロードし、個別のアーティストまたは一元化された場所に手動で転送する必要があります。解決方法  インターネットに接続されたワークステーションで Flow Production Tracking Toolkit を実行します。起動時に、最新のアップグレードが自動的にダウンロードされます。  オプション 1: 共有 Desktop バンドル  バンドル キャッシュを、すべてのマシンがアクセスできる共有場所にコピーします。  オフライン マシンの SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS 環境変数がこの場所を指すように設定します。  オフライン マシンで Desktop が起動すると、バンドル キャッシュにある利用可能な最新のアップグレードが取得されます。  オプション 2: ローカル配置  各ローカル マシンの適切なバンドル キャッシュの場所に、更新されたバンドル キャッシュを配布します。知っておきたい情報  オプション 1 では、SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS に定義されている場所から Toolkit コードがロードされます。この場所が共有ストレージにある場合は、多数の小さなファイルをロードするために十分なパフォーマンスがあることを確認してください。  Windows のセットアップの場合、当てはまらないことが多々あります。その場合は、代わりにオプション 2 をお勧めします。更新をロックするDesktop の自動更新は常に最新の状態を保つために役立ちますが、プロジェクトや、場合によってはサイト全体をフリーズしたり、特定のバージョンにロックして更新を防ぐことが必要な場合もあります。単一のプロジェクトの更新をフリーズするシナリオ: プロジェクトがもうすぐ完了するため、Flow Production Tracking の統合の更新プログラムが自動的にダウンロードされないようにフリーズしたいと考えています。解決方法  プロジェクトをロックするバージョンを決定します。統合のリリース ノートはこちらでご覧いただけます。  Flow Production Tracking で、ロックするプロジェクトのパイプライン設定エンティティを作成し、次のフィールドを入力します(この例では、v1.0.36 の統合を使用するように環境設定をロックしています)。  名前: Primary  プロジェクト: ロックするプロジェクト  プラグインの ID: basic.*      記述子: sgtk:descriptor:app_store?name=tk-config-basic&amp;amp;version=v1.0.36    このプロジェクトでは、誰が Flow Production Tracking Toolkit を起動しても v1.0.36 が使用されるようになります。プロジェクトで作業を開始する新しいユーザも v1.0.36 を取得することになります。知っておきたい情報  更新はローカル マシンにダウンロードされます。  次にインターネットに接続しているときに Desktop を起動すると、基本設定の v1.0.36 と関連するすべてのコードがマシンにダウンロードされます。  basic.* は、基本設定のすべてのプラグインがこのオーバーライドを取得することを意味します。たとえば、Nuke と Maya の統合のみをフリーズする場合は、basic.maya, basic.nuke を指定します。  テストするには、このパイプライン設定エンティティの複製を作成し、User Restrictions フィールドに自分のユーザ名を追加します。これにより、自分のみが使用できるようにエンティティが制限され、他のユーザには影響を与えなくなります。この複製した環境設定から Maya などのソフトウェアを起動して、予想される統合バージョンが実行されていることを確認することができます。既知の問題  Flame 統合のネームスペースは basic.flame であり、basic.* の一部であることが暗示されています。しかし Flame 統合は、実際には基本設定に含まれていません。そのため、プロジェクトに Flame を使用してこのオーバーライドを実装すると、Flame 統合が機能しなくなります。  解決策は、Flame 専用の追加のパイプライン設定オーバーライドを作成することです。  名前: Primary  プロジェクト: ロックするプロジェクト(すべてのプロジェクトの場合はなし)  プラグインの ID: basic.flame  記述子: sgtk:descriptor:app_store?name=tk-config-flamepluginサイトの更新をフリーズするシナリオ: 更新を行いたくありません。スタジオ内のすべてのプロジェクトで、何がダウンロードされ、使用されているかを完全にコントロールしたいと考えています。解決方法  上記の例の手順に従い、Project フィールドを空白のままにします。Project フィールドにオーバーライドがない場合、このパイプライン設定エンティティは、「サイト」のプロジェクト、つまりプロジェクト外で Desktop によって使用されるサイト設定を含む、すべてのプロジェクトに適用されます。知っておきたい情報  これは、「サイト設定をロックする」場合に使用するワークフローです。これによりすべてがロックされます。また、Desktop メニューから高度なプロジェクト設定に進むことができます。  v1.2.3 などを使用するようサイト全体をロックする場合でも、別の環境設定を使用するよう個々のプロジェクトをロックできます。既知の問題  Flame が影響を受けることがあります。解決策については、上記のシナリオの「既知の問題」のセクションを参照してください。1 つ以外のすべてのプロジェクトの更新をフリーズするシナリオ: 自動更新を許可するテスト プロジェクトを除いて、サイト内のすべてのプロジェクトをロックしたいと考えています。解決方法  上記のセクションで説明したように、サイトの更新をフリーズします。  例外にするプロジェクトのパイプライン設定エンティティに、次のフィールド値を設定します。  名前: Primary  プロジェクト: ロック_しない_プロジェクト  プラグインの ID: basic.*  記述子: sgtk:descriptor:app_store?name=tk-config-basic知っておきたい情報  プロジェクトの[記述子] (Descriptor)フィールドでバージョン番号が省略されていることに注目してください。これは、プロジェクトが基本設定の最新リリースをトラッキングすることを意味します。ロックされたサイトを安全に更新する  シナリオ: v1.0.0 にロックされており、v2.0.0 へのアップグレードを予定していますが、スタジオに配置する前にまず新しいバージョンをテストしたいと考えています。*解決方法  Flow Production Tracking でパイプラインの設定エンティティを右クリックし、[選択した項目を複製] (Duplicate Selected)を選択して複製します。  クローン作成した設定に「update test」という名前をつけて、自分を[ユーザ制限] (User Restrictions)フィールドに割り当てます。  このパイプライン設定を使用するようになります。  テストするバージョンを指すように記述子を変更します。  テストに参加させるユーザは、[ユーザ制限] (User Restrictions)フィールドに追加して招待できます。  問題なくテストが完了したら、そのバージョンを使用するようにメインのパイプライン設定を更新するだけです。  ユーザが Desktop または DCC を再起動すると、更新が取得されます。パイプラインの設定を引き継ぐ環境設定をセットアップすることなく、すぐに利用可能な Flow Production Tracking の統合の基本セットを入手することができます。このドキュメントでは、すぐに利用可能な統合を使用して行うことができる管理の種類について説明します。この基本セットアップは、幅広いカスタマイズをサポートできるように Flow Production Tracking Toolkit プラットフォーム上に組み込まれています。Desktop では、Toolkit プロジェクト セットアップ ウィザードに従って、カスタマイズ可能な、プロジェクト用の完全なパイプライン設定を作成できます。以下の各セクションでは、セットアップ方法が分からない場合に備えて、適正な既定値が設定された例と提案を含むウィザードの各手順を詳細に説明します。Desktop からセットアップ ウィザードを起動するプロジェクトに移動すると、Desktop 右底部のユーザ メニューにメニュー項目「Advanced Project Setup…」があります。このメニュー項目をクリックして、Toolkit セットアップ ウィザードを起動します。設定タイプを選択する新しいプロジェクトの設定を開始する場合、まずは 使用する設定テンプレート を決定します。基本的に、設定テンプレートは、プロジェクトの実行に必要なすべての設定、ファイル システム テンプレート、アプリ、およびロジックが設定された完全なプロジェクト設定です。  これが最初のプロジェクトである場合は、Flow Production Tracking の既定値を使用して開始してみてください。  プロジェクトおよび以前のプロジェクトの環境設定を既に設定している場合は、既存のプロジェクトをベースにして新しいプロジェクトを作成することで既定値を簡単に再利用できます。  高度なワークフローの場合は、外部の環境設定または git リポジトリに保存されている環境設定を使用することができます。既定の環境設定これは既定の Toolkit VFX 設定で、通常、セットアップを開始するのにぴったりの出発点です。3dsmax、Flame、Houdini、Nuke、Mari、Maya、Motionbuilder、および Photoshop のセットアップが付属し、ディスク上に簡単で分かりやすいフォルダ構造が作成されます。環境設定には数多くの異なる項目があります。  ファイル システムのセットアップ  ディスク上のキーの場所を特定するためのテンプレート セット  ワークフローに関連付けられた設定済みのエンジンとアプリのセットファイル システムの概要標準設定で Flow Production Tracking のアセットとショットを処理します。パイプラインのステップごとに項目を分割します。パイプラインのステップは部門に似ています。各パイプラインのステップには、サポート対象のさまざまなアプリケーションの作業領域とパブリッシュ領域があります。ショット構造は次のようになります。アプリケーションとワークフロー環境設定には次のコンポーネントが含まれます。  Maya、Mari、Nuke、3dsmax、Flame、Houdini、Photoshop、および Motionbuilder のサポート  Flow Production Tracking アプリケーション ランチャー  パブリッシュ、スナップショット作成、バージョン管理  Nuke カスタム書き込みノード  Flow Production Tracking との統合  数多くのその他のツールとユーティリティ上記のアプリとは別に、環境設定のインストール後に追加のアプリとエンジンを簡単にインストールできます。既存のプロジェクトをベースにして新しいプロジェクトを作成するこれは以前のプロジェクトのすべての既定値と設定を使用して新しいプロジェクトを作成する、簡単で便利な方法です。Toolkit が、古いセットアップの環境設定を単純に新しいプロジェクトにコピーします。これは環境設定を展開する簡単で実用的な方法です。新しいプロジェクトはすべて古いプロジェクトをベースにすることになります。パイプライン設定の展開と管理の方法に関するドキュメントについては、こちらを参照してください。プロジェクトの設定を管理するgit の設定テンプレートを使用するプロジェクトの環境設定をソース コントロールに接続したままにする場合はこのオプションを使用します。リモート git または github リポジトリに URL を指定すると、セットアップ プロセスで URL がクローン作成されます。これは github だけでなく、すべての git リポジトリで動作します。リポジトリのパスの最後が .git で終わるようにしてください。Toolkit が git セットアップとして処理します。プロジェクト設定は git リポジトリであるため、変更をマスター リポジトリだけでなく、他のプロジェクトにも反映することができます。github ベースの環境設定を使用すると、複数の Toolkit プロジェクトを簡単に同期できます。詳細はこちらでご確認ください。プロジェクトの設定を管理するWindows 上で実行している場合は、使用するマシンに git をインストールして、PATH からアクセスできるようにしておく必要があります。Linux と Mac OS X の場合、通常は既定でインストールされます。設定テンプレートを参照するフォルダとしてまたは zip 圧縮された zip ファイルとしてディスク上に環境設定がある場合は、このオプションを使用します。他のユーザが環境設定を電子メールで送信してきたり、過去のすべてのプロジェクトを参照するマスター設定をディスク上で管理したりする場合は、これが役に立ちます。通常、これはエキスパート オプションであるため、別のプロジェクトの環境設定を使用するか、アプリ ストアの既定の環境設定のいずれかを使用することをお勧めします。ストレージをセットアップするそれぞれの Toolkit プロジェクトでは、すべてのファイルとデータがディスク上の 1 つ以上の共有ストレージの場所に書き込まれます。たとえば、環境設定には、テクスチャを保存するストレージ、レンダリングを保存するストレージ、シーン ファイルを保存するストレージが必要です。通常、これらのストレージは、Flow Production Tracking のサイト基本設定の_ファイル管理_タブでコントロールします。Toolkit セットアップ ウィザードに、設定に必要な各ストレージのルートを Flow Production Tracking のローカル ストレージにマップするよう求めるメッセージが表示されます。必要なルートおよびその説明(設定の roots.yml ファイルで定義)が左側に表示されます。右側には、既存の Flow Production Tracking ローカル ストレージのリストが表示されます。必要なルートごとにストレージを選択します。Flow Production Tracking に現在の OS のパスが設定されていない場合は、入力します。定義されていない他のオペレーティング システムのパスを追加することもできます。既存のパスはロックされるため、このストレージ パスを利用している可能性のある他のプロジェクトに誤って影響が及ぶことはありません。ウィザードのマッピング ページで、必要な各ルートがマッピングされていること、および各マッピングが有効なことを確認します。新しいローカル ストレージを作成するには、ウィザードを使用するか、またはストレージ選択リストの最後にある +New 項目を選択します。ローカル ストレージの名前および現在の OS のパスを入力するよう求められます。プロジェクトをセットアップしたら、Toolkit は各ストレージ場所の新しいプロジェクトごとにフォルダを作成します。たとえば、プライマリ ストレージの場所が /mnt/projects である場合、The Edwardian Cry と呼ばれるプロジェクトの場所は /mnt/projects/the_edwardian_cry になります。環境設定でプライマリ ストレージ以外のストレージも使用している場合、それぞれのストレージの最後が the_edwardian_cry フォルダになります。通常、プライマリ ストレージ場所は /mnt/projects または   studio projects のような場所です。一般的に、この場所には、プロジェクトごとにグループ化されたプロジェクト データが既に保存されています。これは多くの場合、共有ネットワーク ストレージ上にあります。プロジェクト フォルダ名を選択するここではプロジェクトのディスク名を選択します。このフォルダは、環境設定によって必要となる、さまざまなストレージすべてにおいて作成されます。ほとんどの環境設定については UI に簡単なプレビューが表示されます。これはプライマリ ストレージのプレビューのみですが、マルチルート設定を使用している場合は、追加のストレージも表示されます。Toolkit は Flow Production Tracking の名前に基づいて既定のプロジェクト名を表示します。ユーザのセットアップに適した名前を作成するために自由に修正できます。環境設定の場所を選択する最後に、設定ファイルを格納するディスク上の場所を決定してください。Toolkit は、以前のプロジェクトと同じディスク上の場所にすべて格納できるように、以前のプロジェクトに基づいた場所を表示します。スタジオ内でこの設定を必要とするすべてのユーザがアクセスできるように、通常、設定ファイルは共有ストレージまたはディスク上に格納されます。このプロジェクトに複数のオペレーティング システムを使用する場合は、必要なすべてのパスを入力してください。すべてのパスがディスク上の同じ場所を表す必要があります。多くの場合、Mac OS X と Linux では同じパスですが、Windows では異なります。これが最初のプロジェクトになる場合は、一般的に、今後のパイプラインのすべての環境設定を保存するディスク上の共有領域を決定します。通常、これはスタジオで共有するソフトウェアやソフトウェア設定を保存する場所です。場所は /mnt/software/shotgun のようになります。これは、スタジオのネットワークやファイル命名規則によって異なる場合があります。初めて環境設定をセットアップする場合、スタジオで使用するすべてのプラットフォームのパスをセットアップします。これにより、後ですべてのマシンからアクセスできる環境を簡単に作成できます。たとえば、プロジェクト名が Golden Circle の場合、入力可能なパスは次の 3 つです。linux:   /mnt/software/shotgun/golden_circlemacosx:  /servers/production/software/shotgun/golden_circlewindows:   prod software shotgun golden_circle設定完了後の作業最初の環境設定が完了したら、マニュアルの「次のステップ」に移動し、ニーズに合わせて Toolkit を設定および調整する方法を確認します。最初のプロジェクトの作成後高度な機能サイレント インストールWindows ネットワーク上では、Flow Production Tracking Toolkit インストーラの .exe を実行するときに「/S」引数を使用するとサイレント インストールを実行できます。その後、実行可能ファイルのショートカットのコピーを起動フォルダに格納することが可能です。",
    "url": "/8085533c/",
    "relUrl": "/8085533c/"
  },
  "68": {
    "id": "68",
    "title": "統合",
    "content": "RV の統合Flow Production Tracking Integration、Screening Room for RV、Flow Production Tracking Review など、機能セットに違いがあるいくつかの Flow Production Tracking 統合に加え、RV には Nuke および Maya 向けの統合ツールが付属しています。以下の最初の 2 つのドキュメントでは、Nuke と Maya の統合のインストールとワークフローについて説明し、最後の 2 つのドキュメントではさまざまな Flow Production Tracking の統合について説明します。どちらを使用するかについてはこれらのドキュメントを参照してください。",
    "url": "/268002fe/",
    "relUrl": "/268002fe/"
  },
  "69": {
    "id": "69",
    "title": "Invalid LUT selected",
    "content": "error Invalid LUT selected : Gamma2.2使用例:ACES カラー管理プロジェクトで作業しているときに、既定の Toolkit パブリッシュを使用すると、エラー Invalid LUT selected : Gamma2.2 が発生して失敗します。エラーの原因Nuke の Toolkit パブリッシュに QuickTime を作成するアプリ tk-multi-reviewsubmission が含まれていて、このアプリで既定で作成される QT は Nuke 標準カラー モデルで機能します。修正方法ACES (ICIO モデルを想定)を使用しているため、tk-multi-reviewsubmission アプリでカラー スペース設定を変更するには、設定を引き継いで codec_settings.py フックに追加するだけで済みます。コーデックは基本設定によって異なりますが、この例では Output - sRGB Codecを使用しています。そのため、codec_settings.py フック内のセットアップに適した場所に設定 settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot; を追加します。(ここではすべての場所に追加しました)        settings = {}        if sys.platform in [&quot;darwin&quot;, &quot;win32&quot;]:            settings[&quot;file_type&quot;] = &quot;mov&quot;            if nuke.NUKE_VERSION_MAJOR &amp;gt;= 9:                # Nuke 9.0v1 changed the codec knob name to meta_codec and added an encoder knob                # (which defaults to the new mov64 encoder/decoder).                                  settings[&quot;meta_codec&quot;] = &quot;jpeg&quot;                settings[&quot;mov64_quality_max&quot;] = &quot;3&quot;                settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;            else:                settings[&quot;codec&quot;] = &quot;jpeg&quot;                settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;        elif sys.platform == &quot;linux2&quot;:            if nuke.NUKE_VERSION_MAJOR &amp;gt;= 9:                # Nuke 9.0v1 removed ffmpeg and replaced it with the mov64 writer                # https://help.thefoundry.co.uk/nuke/9.0/#appendices/appendixc/supported_file_formats.html                settings[&quot;file_type&quot;] = &quot;mov64&quot;                settings[&quot;mov64_codec&quot;] = &quot;jpeg&quot;                settings[&quot;mov64_quality_max&quot;] = &quot;3&quot;                settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;            else:                # the 'codec' knob name was changed to 'format' in Nuke 7.0                settings[&quot;file_type&quot;] = &quot;ffmpeg&quot;                settings[&quot;format&quot;] = &quot;MOV format (mov)&quot;                settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;        return settingsこれで問題がなければ、Nuke でパブリッシュするときに、QT は ACES と互換性のあるカラースペースで作成されるようになります。コミュニティで完全なスレッドを参照してください。",
    "url": "/749984aa/",
    "relUrl": "/749984aa/"
  },
  "70": {
    "id": "70",
    "title": "Knowledge",
    "content": "Generic KnowledgeIn This Section  Connecting Your Studio With Your AWS VPC  Flow Production Tracking AWS Direct Connect Onboarding  S3  VPC / IAM / Security Group  Direct Connect  Private Link  VPC Endpoints  AWS Knowledge",
    "url": "/540597cc/",
    "relUrl": "/540597cc/"
  },
  "71": {
    "id": "71",
    "title": "Learn",
    "content": "Flow Production Tracking Isolation - LearnThis section will host a learning curriculum for Flow Production Tracking Isolation features n the near future.",
    "url": "/da5a2d10/",
    "relUrl": "/da5a2d10/"
  },
  "72": {
    "id": "72",
    "title": "Maya で context.task を出力すると、空の「None」になる",
    "content": "Maya で context.task を出力すると、空の「None」になる使用例Maya で context.task を出力すると empty “None” になりますが、別のステップ/タスクで別のレイアウト ファイルを試すと、context.task の詳細が表示されます。Open &amp;gt; Layout &amp;gt; new file をナビゲートするときに context.task の詳細を出力することもできますが、[File Save]を使用してファイルを保存すると、context.task は「None」になります。修正方法動作しないショットの 1 つに対してフォルダの登録解除を試して、フォルダの作成を再実行します。関連リンクコミュニティの完全なスレッドを参照してください。",
    "url": "/38c4e054/",
    "relUrl": "/38c4e054/"
  },
  "73": {
    "id": "73",
    "title": "Maya で Toolkit アプリを起動するシェルフ ボタンを追加するにはどうすればいいですか?",
    "content": "Maya で Toolkit アプリを起動するシェルフ ボタンを追加するにはどうすればいいですか?Maya で Toolkit アプリを起動するシェルフ ボタンを Maya に追加するのは非常に簡単です。次に、Loader アプリを起動するカスタム シェルフ ボタンの追加方法の例を示します。                    注: これは、Toolkit が現在の Maya セッションで有効であることが前提です。このコード例では Toolkit をブートストラップしません。    Maya でスクリプト エディタを開き、次の Python コードを貼り付けます。 import maya.cmds as cmds# Define the name of the app command we want to run.# If your not sure on the actual name you can print the current_engine.commands to get a full list, see below.tk_app = &quot;Publish...&quot;try:    import sgtk    # get the current engine (e.g. tk-maya)    current_engine = sgtk.platform.current_engine()    if not current_engine:        cmds.error(&quot;Flow Production Tracking integration is not available!&quot;)    # find the current instance of the app.    # You can print current_engine.commands to list all available commands.    command = current_engine.commands.get(tk_app)    if not app:        cmds.error(&quot;The Toolkit app '%s' is not available!&quot; % tk_app)    # now we have the command we need to call the registered callback    command['callback']()except Exception, e:    msg = &quot;Unable to launch Toolkit app '%s': %s&quot; % (tk_app, e)    cmds.confirmDialog(title=&quot;Toolkit Error&quot;, icon=&quot;critical&quot;, message=msg)    cmds.error(msg)このコードを選択して、カスタム シェルフにドラッグします。カスタム シェルフ ボタンの使用方法に関する詳細については、Maya ドキュメントを参照してください。上部の tk_app と call_func の各変数を修正して、Maya で有効な Toolkit アプリを起動するには、このコード サンプルを使用できる必要があります。",
    "url": "/dba779a5/",
    "relUrl": "/dba779a5/"
  },
  "74": {
    "id": "74",
    "title": "Media Isolation",
    "content": "Media IsolationMedia Isolation allows your studio to retain ownership and control of the media and attachments that you upload to Flow Production Tracking. With Media Isolation, all the content that you upload to Flow Production Tracking is stored in your studio’s private S3 Bucket. Access to the media is provided to the Flow Production Tracking services only, using AWS AssumeRole keyless Security Token Service.Client-Owned S3 BucketStoring media and attachments in an S3 bucket that you own means that you remain the legal owner of these artifacts, allowing you to comply with your company’s security and legal policies. Your studio retains control of asset storage and access, access that you can revoke at will.More about AccessWhen using Flow Production Tracking to upload and download media it is transferred directly to / from AWS S3 without transiting through Autodesk infrastructure. Flow Production Tracking will only access media in two situations:  The Flow Production Tracking Transcoding service will get read/write access once, soon after upload, when transcoding the media. See Ephemeral Transcoding for details.  When the Flow Production Tracking service generates S3 Links to your sources and transcoded media.This is rendered possible by leveraging AWS AssumeRole keyless Security Token Service. When setting up Media Isolation, an AWS Role allowing Flow Production Tracking to access your media for the action listed above is created, and the Flow Production Tracking service is allowed to assume that role.Flow Production Tracking Support staff do not have access to your S3 Bucket under any circumstances.CostsWhen activating Media Isolation the following costs, previously covered by Autodesk, become the responsibility of the client:  S3 Costs. All the S3 storage costs will be assumed by the customer. See Media Isolation for more details about how to reduce costs.  S3 Bandwidth. Bandwidth out of the S3 bucket will be assumed by the customer.What Media Isolation is not providingActivating Media Isolation doesn’t guarantee that the access to your Flow Production Tracking site or media takes place within a closed network.",
    "url": "/a3c0e676/",
    "relUrl": "/a3c0e676/"
  },
  "75": {
    "id": "75",
    "title": "Media Replication",
    "content": "Media ReplicationFlow Production Tracking is compatible with the S3 Cross-Region replication feature, allowing your users located in different regions to read from the region closer to them in order to reduce latency and increase throughput. Replication to one region is currently supported.Pre-requisitesMedia Isolation is required in order to elect Media Replication.Configuration by usersWhen using Media Replication, each user can customize which region data is read from. A user can either specify the region to use, or use automatic mode. In automatic mode Flow Production Tracking selects the replica determined by the user’s IP address using IP ranges specified in the Isolation Preferences.How it worksFlow Production Tracking can be configured to read from up to two different buckets. Using the AWS S3 Replication feature, you can configure replication between buckets in different regions, and then consume media from the region closest to your users. It is important to underline that media is always uploaded to the main bucket.Following AWS service level agreement, S3 guarantees the replication of 99.99% of the object within 15 minutes.Replication DelayA small amount of time, typically under 15 minutes, is required before replication happens. The replication time depends on the size of the object to replicate. In order to alleviate that replication delay, Flow Production Tracking will, for a small period of time, generate links from to object in the source bucket instead of the replica. The duration of this transitional state is configurable in the Isolation Preferences.CostsActivating the Media Replication feature can increase your AWS costs considerabibly. Before activating, be aware that:  Your S3 cost linked to Flow Production Tracking usage will more or less double, because the media is now stored in two regions.  You will be charged for the transfer cost between the source and the destination region. See AWS S3 CRR and the destination region for more details.Next StepsSee Media Replication Setup for setup instructions.",
    "url": "/0221297e/",
    "relUrl": "/0221297e/"
  },
  "76": {
    "id": "76",
    "title": "Media Traffic Isolation",
    "content": "Media Traffic Isolation using AWS PrivateLink for Amazon S3                    Disclaimer: This documentation is provided solely as an example. It explains how to set up your Flow Production Tracking Isolation environment so that it can be connected to Flow Production Tracking cloud infrastructure. Please adapt it to your studio security requirements as needed. As Flow Production Tracking has no visibility on your AWS Account, ensuring that this account is secure is a client responsibility.    The media traffic isolation feature allows your users to access media in your AWS S3 bucket privately (not transiting over the public Internet). Please note that if you have a multi-region setup and that leverages the Flow Production Tracking Transcoding service there may still be instances where media transits across the public Internet. Reach out to our support team for more details.Media Isolation activation is a pre-requisite to enable this feature. If you haven’t done so already, see Media Isolation.Set up a VPC in your S3 bucket AWS regionYou will need to deploy a VPC with the required VPC endpoint. We provide a private VPC CloudFormation templates as starting points. This template create the necessary VPC, subnets and VPC endpoint.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL to https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-vpc-s3-privatelink.yml  Click Next  Set a stack name. Eg. Flow Production Tracking-vpc  Choose network ranges that doesn’t conflict with your studio network and set subnet CIDR values accordingly  Set your S3 bucket name  Click Next  Click NextSet up access from your site network to your AWS VPCOptions provided by AWS:  AWS Site-to-Site VPN  AWS Direct Connect                    Note: If Direct Connect is chosen, we recommend testing with a simpler / faster solution in the meantime to validate your Isolation setup. You can then replace that solution with Direct Connect once it is available.    Add an S3 endpoint to your VPC                    Note: This step should only be performed if the CloudFormation template was not used.    Simply add an com.amazonaws.us-west-2.s3 Interface VPC Endpoint to your existing VPC. Make sure the associated security group allow traffic from your site network.Add the VPC to your S3 bucket policyIn order for the S3 VPC endpoint to communicate with your S3 bucket your bucket policy must allow access from the S3 endpoint’s VPC. You can find instructions on how to configure the policy in the Fine Tuning step.ValidationTest the S3 VPC endpointUse the endpoint URL to list objects in your bucket using AWS CLI. In the following example, replace the VPC endpoint ID vpce-1a2b3c4d-5e6f.s3.us-east-1.vpce.amazonaws.com and bucket name my-bucket with appropriate information.    aws s3 --endpoint-url https://bucket.vpce-1a2b3c4d-5e6f.s3.us-east-1.vpce.amazonaws.com ls s3://my-bucket/Configure site to use your S3 VPC endpointYou can test by adding a temporary entry to the S3 Configuration site preference on your site.The complete entry will look like the following:{​​​​​​​​   &quot;&amp;lt;S3_CONFIG_NAME&amp;gt;&quot;: {​​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​,   &quot;&amp;lt;S3_CONFIG_NAME_WITH_S3_VPC_ENDPOINT&amp;gt;&quot;: {​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;,     &quot;s3_interface_vpc_endpoint_dns_name&quot;: &quot;vpce-1234567-5e6f.s3.us-east-1.vpce.amazonaws.com&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​After the configuration has been updated on your site, navigate to the /admin/speedtest route of your Flow Production Tracking site. Select the new S3_CONFIG_NAME_WITH_S3_VPC_ENDPOINT and start the test to confirm that all the upload/download tests work as intended.Once it has been verified to work correctly, add the value from s3_interface_vpc_endpoint_dns_name to the main S3 configuration S3_CONFIG_NAME and your current setup should be using Media Traffic Isolation.Erase the S3_CONFIG_NAME_WITH_S3_VPC_ENDPOINT entry from the S3 Configuration to clean up your configurations.Next StepsSee Media Replication to activate the Media Replication Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/2ab85e3e/",
    "relUrl": "/2ab85e3e/"
  },
  "77": {
    "id": "77",
    "title": "Media Traffic Isolation - S3 Proxy",
    "content": "                    Deprecated: The preferred way is to use S3 Private Link instead of a S3 proxy, see Media Traffic Isolation    Media Traffic Isolation using an S3 proxy (DEPRECATED)                    Disclaimer: This documentation is provided solely as an example. It explains how to set up your Flow Production Tracking Isolation environment so that it can be connected to Flow Production Tracking cloud infrastructure. Please adapt it to your studio security requirements as needed. As Flow Production Tracking has no visibility on your AWS Account, ensuring that this account is secure is a client responsibility.    The media traffic isolation feature allows your users to access media in your AWS S3 bucket privately (not transiting over the public Internet). Please note that if you have a multi-region setup and that leverages the Flow Production Tracking Transcoding service there may still be instances where media transits across the public Internet. Reach out to our support team for more details.Media Isolation activation is a pre-requisite to enable this feature. If you haven’t done so already, see Media Isolation.Set up a VPC in your S3 bucket AWS region                    Disclaimer: Before starting, decide whether your S3 proxy will be privately accessible within your VPC or publicly accessible via the Internet and choose the relevant templates in the following instructions.    You will need to deploy a VPC with the required VPC endpoints. We provide both private VPC and public VPC CloudFormation templates as starting points. These template create the necessary VPCs, subnets and VPC endpoints.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL depending upon your desired configuration          Private VPC (default):https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-vpc.yml      Public VPC:https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-public-vpc.yml        Click Next  Set a stack name. Eg. shotgun-vpc  Choose network ranges that doesn’t conflict with your studio network and set subnet CIDR values accordingly  Set your S3 bucket name  Click Next  Click NextSet up access from your site network to your AWS VPCOptions provided by AWS:  AWS Site-to-Site VPN  AWS Direct Connect                    Note: If Direct Connect is chosen, we recommend testing with a simpler / faster solution in the meantime to validate your Isolation setup. You can then replace that solution with Direct Connect once it is available.    Add an S3 endpoint to your VPC                    Note: This step should only be performed if the CloudFormation template was not used when configuring Media Isolation.    Set up S3 proxyYou will need to deploy an S3 proxy in your VPC to forward traffic to the S3 VPC endpoint. We provide both private and public S3 proxy CloudFormation templates as starting points for this purpose. These will create the necessary Elastic Container Service (ECS) cluster and other resources to run the S3 proxy on AWS Fargate behind an AWS Application Load Balancer (ALB).Make the Docker image available from a private AWS ECR repository  Create a new Elastic Container Registry (ECR) repository  Name the repository s3-proxy  Upload the s3-proxy Docker image to the newly created ECR repository          Install Docker on your workstation      Follow the docker login instructions shown by clicking the View push commands button      Run the following commands, substituting the ECR endpoint in the example for yours:        docker pull quay.io/shotgun/s3-proxy:1.0.6docker tag quay.io/shotgun/s3-proxy:1.0.6 627791357434.dkr.ecr.us-west-2.amazonaws.com/s3-proxy:1.0.6docker push 627791357434.dkr.ecr.us-west-2.amazonaws.com/s3-proxy:1.0.6                    Create S3 proxy CloudFormation stackCreate a new stack in AWS Console using either the private or public CloudFormation template.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL depending upon your desired configuration          Private S3 proxy (default):https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-s3-proxy.yml      Public S3 proxy:https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-s3-proxy-public.yml        Click Next  Set a stack name up to 32 characters in length. Eg. shotgun-s3-proxy  Set the parameters that do not have default values with those used when creating the ECR repository, VPC and S3 bucket previously  Click Next  Accept I acknowledge that AWS CloudFormation might create IAM resources  Click NextConfigure HTTPSFlow Production Tracking requires that the S3 proxy be accessed via HTTPS, therefore the AWS ALB handling requests for your newly created S3 proxy stack must be configured to accept HTTPS requests.  Create a DNS entry pointing to your S3 proxy, depending upon whether public or private          Private S3 proxy (default):                  Go to the EC2 Load Balancers dashboard, select your S3 proxy’s ALB and make a note of the DNS name          Add a DNS CNAME record pointing to the DNS name of the ALBEg. s3-proxy.mystudio.com. 300 IN CNAME s3proxy-12R1MXX0MFFAV-2025360147.us-east-1.elb.amazonaws.com.                    Public S3 proxy:                  Go to the AWS Global Accelerator dashboard and make a note of the DNS name associated with your S3 proxy’s accelerator          Add a DNS CNAME record pointing to the DNS name of the Global AcceleratorEg. s3-proxy.mystudio.com. 300 IN CNAME a48a2a8de7cfd28d3.awsglobalaccelerator.com.                      Obtain an SSL certificate for your chosen URL, we recommend using AWS Certificate Manager (ACM) for this  Configure HTTPS for the S3 proxy by adding a new HTTPS listener to the AWS ALB          Go to the EC2 Load Balancers dashboard, select your S3 proxy’s ALB and click on the Listeners tab      Click Add listener      Select HTTPS from the Protocol dropdown menu      Click Add action -&amp;gt; Forward to…      Select your S3 proxy’s target group from the Target group dropdown menu      Select the Security policy you’d like to use. Eg. TLS-1-2-Ext-2018-06 (See AWS documentation for more information)      Select the SSL certificate you’d like to use from ACM or import a new certificate      Click Save      Add S3 proxy VPC to S3 bucket policyIn order for the S3 proxy to communicate with your S3 bucket your bucket policy must allow access from the S3 proxy’s VPC. You can find instructions on how to configure the policy in the Fine Tuning step.ValidationTest the S3 proxyTry to access your S3 proxy using the ping route. Eg. https://s3-proxy.mystudio.com/pingConfigure your test site to use the S3 proxy  Navigate to the Site Preferences menu within Flow Production Tracking and expand the Isolation section  Set S3 Proxy Host Address to the S3 proxy url. Eg. https://s3-proxy.mystudio.com then click Save changes  Confirm that you are still able to access existing media  Attempt to upload new mediaNext StepsSee Media Replication to activate the Media Replicaton Traffic Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/85124db5/",
    "relUrl": "/85124db5/"
  },
  "78": {
    "id": "78",
    "title": "Media Traffic Isolation",
    "content": "Media Traffic IsolationCommunication between your client systems and S3 bucket targets a number of AWS network endpoints and data traverses the open Internet by default. Media Traffic Isolation allows you to limit the number of network endpoints used to transfer data to and from your S3 bucket and optionally restrict access to your AWS VPC or a defined set of public address scopes.ConfigurationAn S3 interface VPC endpoint is deployed within your VPC; which is then used as the endpoint for all S3 communication.How it worksFlow Production Tracking can be configured to use an S3 interface VPC endpoint to communicate with your S3 bucket. Deploying the S3 VPC endpoint within your VPC makes it possible to isolate traffic from the public Internet completely, or to allow more tightly controlled access from the Internet to your media.CostsActivating the Media Traffic Isolation feature will increase your AWS costs. Before activating, be aware that:  There are costs associated with running the S3 interface VPC Endpoint. See AWS PrivateLink pricing for more details.Next StepsSee Media Traffic Isolation for setup instructions.",
    "url": "/58919eae/",
    "relUrl": "/58919eae/"
  },
  "79": {
    "id": "79",
    "title": "Nuke や Maya などを Flow Production Tracking Toolkit から起動したが、Flow Production Tracking のメニューにエントリが表示されない",
    "content": "Nuke や Maya などを Flow Production Tracking Toolkit から起動したが、Flow Production Tracking のメニューにエントリが表示されないFlow Production Tracking メニューに表示されるアクションはコンテキストに応じて設定されます。つまり、利用可能なアクションのリストは、現在のコンテキストによって異なる可能性があります。コンテキストが間違っているためにアプリが表示されない可能性があります。例Flow Production Tracking Toolkit からアプリケーションを起動すると、既定ではプロジェクト環境が表示されます。この環境は、config/env/project.yml に格納されたパイプライン設定内の設定ファイルによって管理されます。ユーザーの作業のほとんどはこの環境では行わないため、多くのアプリでは操作用に設定されていません。既定の Maya プロジェクト アクション:Flow Production Tracking Workfiles アプリを使用すると、作業するアセット、ショット、またはタスクを選択できます。これにより、新しい適切な環境をロードし、多くのアプリで Flow Production Tracking メニューのメニュー項目を有効にできます。既定の Maya アセット タスク アクション:環境が正しいにもかかわらずアクションが表示されない場合は、関連するログを調べ、エラーがないかどうかを確認します。完全な出力を取得するには、デバッグ ログを有効にしなければならない可能性があります。",
    "url": "/901110e2/",
    "relUrl": "/901110e2/"
  },
  "80": {
    "id": "80",
    "title": "Migration",
    "content": "MigrationOnce everything is configured and properly tested with the migration test site, it’s now time to migrate your production site to use the isolation features.Test migrationAsk the Flow Production Tracking team to start the migration process in support ticket/slack.  Flow Production Tracking will clone your production site database to your migration test site.  You will do a first sync of the media from Flow Production Tracking’s S3 bucket to your bucket. Flow Production Tracking will provide the exact instructions.  You can now test your site to be sure your existing media is available.Final migrationThe second test is to definitly migrate your site to use your own S3 bucket.  You will do a second sync of the media from Flow Production Tracking’s S3 bucket to your bucket.  Flow Production Tracking will reconfigure your hosted site with media isolation. Some media will be missing until the final media sync is completed.  You will do a final media sync.",
    "url": "/09699c82/",
    "relUrl": "/09699c82/"
  },
  "81": {
    "id": "81",
    "title": "{% include product %} Desktop の起動時に、モジュール「tank」にアトリビュート「support_url」がないというエラーが発生する",
    "content": "Flow Production Tracking Toolkit の起動時に、モジュール「tank」にアトリビュート「support_url」がないというエラーが発生する問題バージョンのアップグレード後に Flow Production Tracking Toolkit を起動すると、次のメッセージが表示されます。Flow Production Tracking Toolkit Error:Error: module 'tank' has no attribute 'support_url'原因記述子のバージョンが、新しい Flow Production Tracking Toolkit バージョン 1.7.3 と互換性がありません。「support_url」は tk-core v0.19.18 で導入されました。解決方法この問題を解決するには次の手順を実行します。  Flow Production Tracking Web サイトの[パイプライン設定リスト]ページにアクセスします。  記述子フィールドに、新しい Flow Production Tracking デスクトップ バージョンと互換性のない古いバージョンが含まれているかどうかを確認します。関連リンク  ナレッジベースのサポート記事",
    "url": "/2c67d8b6/",
    "relUrl": "/2c67d8b6/"
  },
  "82": {
    "id": "82",
    "title": "ModuleNotFoundError",
    "content": "ModuleNotFoundError使用例分散設定の場合に、エンジンの外部で tk.templates コマンドにアクセスするために tk-shell ブートストラップすると、このエラーが表示されます。このドキュメント(パート 4)に従って、インストール フォルダから sgtk v0.19.18 を読み込むと、次のエラーが発生します。Traceback (most recent call last):  File &quot;.../_wip/sgtk_bootstrap.py&quot;, line 9, in &amp;lt;module&amp;gt;    import sgtk  File &quot;L:/_tech/sgtk_sandbox/install/core/python sgtk __init__.py&quot;, line 16, in &amp;lt;module&amp;gt;    import tank  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank __init__.py&quot;, line 58, in &amp;lt;module&amp;gt;    from . import authentication  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication __init__.py&quot;, line 33, in &amp;lt;module&amp;gt;    from .shotgun_authenticator import ShotgunAuthenticator  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication shotgun_authenticator.py&quot;, line 13, in &amp;lt;module&amp;gt;    from .sso_saml2 import (  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication sso_saml2 __init__.py&quot;, line 15, in &amp;lt;module&amp;gt;    from .core.errors import (  # noqa  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication sso_saml2 core __init__.py&quot;, line 15, in &amp;lt;module&amp;gt;    from .sso_saml2_core import (  # noqa  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication sso_saml2 core sso_saml2_core.py&quot;, line 19, in &amp;lt;module&amp;gt;    from Cookie import SimpleCookieModuleNotFoundError: No module named 'Cookie'修正方法この問題は、Python 3 を使用した場合に発生することがあります(旧バージョンの Python はサポートが終了しました)。関連リンクコミュニティで完全なスレッドを見る",
    "url": "/d8981e04/",
    "relUrl": "/d8981e04/"
  },
  "83": {
    "id": "83",
    "title": "パイプライン設定を新しい場所に移動するにはどうすればいいですか?",
    "content": "パイプライン設定を新しい場所に移動するにはどうすればいいですか?                    注: このドキュメントのコンテンツは一元管理設定のセットアップにのみ適用されます。分散設定は個々のクライアント マシンにローカルにキャッシュされ、Toolkit によって自動的に管理されます。    パイプライン設定を新しい場所に簡単に移動するには、tank move_configuration コマンドを使用します。これにより、ファイルを移動したり、Flow Production Tracking を更新したり、新しい場所を指すように設定ファイルを更新したりします。 またこのコマンドは、1 つのオペレーティング システムで場所を移動するだけの場合や、以前は特定のオペレーティング システムを使用していなかったがこれから追加する場合などにも役立ちます。Toolkit は、移動する項目、追加する項目、またはそれ以外の項目を検出し、適用前に確認できるように実行内容が表示されます。  tank move_configuration コマンドを使用  パイプライン設定を手動で移動する                    注意: ローカライズされたコアを持つ設定を移動していて、このパイプライン設定に埋め込まれた Toolkit コアを使用する他のプロジェクトがある場合(つまり、他の設定がこれを共有コアとして使用している場合)は、このパイプライン設定の新しい場所を指すようにこのプロジェクトの設定ファイルを手動で更新する必要があります。このファイルは次の場所に格納されています。  /path/to/pipeline_configuration/install/core/core_Darwin.cfg  /path/to/pipeline_configuration/install/core/core_Linux.cfg  /path/to/pipeline_configuration/install/core/core_Windows.cfg    タンク move_configuration コマンドを使用:    $ cd /sgtk/software/shotgun/scarlet    $ ./tank move_configuration    Welcome to the Flow Production Tracking Toolkit!    For documentation, see https://developer.shotgridsoftware.com/d587be80/?title=Integrations+User+Guide    Starting Toolkit for your current path '/sgtk/software/shotgun/scarlet'    - The path is not associated with any Flow Production Tracking object.    - Falling back on default project settings.    - Using configuration 'Primary' and Core v0.15.22    - Setting the Context to Scarlet.    - Running command move_configuration...    ----------------------------------------------------------------------    Command: Move configuration    ----------------------------------------------------------------------    Syntax: move_configuration linux_path windows_path mac_path    This will move the location of the given pipeline configuration.    You can also use this command to add a new platform to the pipeline    configuration.    Current Paths    --------------------------------------------------------------    Current Linux Path:   '/mnt/hgfs/sgtk/software/shotgun/scarlet'    Current Windows Path: 'z: sgtk software shotgun scarlet'    Current Mac Path:     '/sgtk/software/shotgun/scarlet'    You typically need to quote your paths, like this:    &amp;gt; tank move_configuration &quot;/linux_root/my_config&quot; &quot;p: configs my_config&quot;    &quot;/mac_root/my_config&quot;    If you want to leave a platform blank, just just empty quotes. For example, if    you want a configuration which only works on windows, do like this:    &amp;gt; tank move_configuration &quot;&quot; &quot;p: configs my_config&quot; &quot;&quot;例:    $ cd /sgtk/software/shotgun/scarlet    $ ./tank move_configuration &quot;/mnt/hgfs/sgtk/software/shotgun/scarlet_new&quot; &quot;z: sgtk software shotgun scarlet_new&quot; &quot;/sgtk/software/shotgun/scarlet_new&quot;    Welcome to the Flow Production Tracking Toolkit!    For documentation, see https://developer.shotgridsoftware.com/d587be80/?title=Integrations+User+Guide    Starting toolkit for path '/sgtk/software/shotgun/scarlet'    - The path is not associated with any Flow Production Tracking object.    - Falling back on default project settings.    - Using configuration 'Primary' and Core v0.15.22    - Setting the Context to Scarlet.    - Running command move_configuration...    ----------------------------------------------------------------------    Command: Move configuration    ----------------------------------------------------------------------    Current Paths    --------------------------------------------------------------    Current Linux Path:   '/sgtk/software/shotgun/scarlet'    Current Windows Path: 'z: sgtk software shotgun scarlet'    Current Mac Path:     '/sgtk/software/shotgun/scarlet'    New Paths    --------------------------------------------------------------    New Linux Path:   '/mnt/hgfs/sgtk/software/shotgun/scarlet_new'    New Windows Path: 'z: sgtk software shotgun scarlet_new'    New Mac Path:     '/sgtk/software/shotgun/scarlet_new'    The configuration will be moved to reflect the specified path changes.    Note for advanced users: If your configuration is localized and you have other    projects which are linked to the core API embedded in this configuration,    these links must be manually updated after the move operation.    Are you sure you want to move your configuration? [Yes/No] yes    Copying '/sgtk/software/shotgun/scarlet' -&amp;gt; '/sgtk/software/shotgun/scarlet_new'    Copying /sgtk/software/shotgun/scarlet/cache...    Copying /sgtk/software/shotgun/scarlet/config...    Copying /sgtk/software/shotgun/scarlet/config/core...    Copying /sgtk/software/shotgun/scarlet/config/core/hooks...    Copying /sgtk/software/shotgun/scarlet/config/core/schema...    Copying /sgtk/software/shotgun/scarlet/config/env...    Copying /sgtk/software/shotgun/scarlet/config/env/includes...    Copying /sgtk/software/shotgun/scarlet/config/hooks...    Copying /sgtk/software/shotgun/scarlet/config/icons...    Copying /sgtk/software/shotgun/scarlet/install...    Copying /sgtk/software/shotgun/scarlet/install/apps...    Copying /sgtk/software/shotgun/scarlet/install/apps/app_store...    Copying /sgtk/software/shotgun/scarlet/install/core...    Copying /sgtk/software/shotgun/scarlet/install/core/python...    Copying /sgtk/software/shotgun/scarlet/install/core.backup...    Copying /sgtk/software/shotgun/scarlet/install/core.backup/20150518_143244...    Copying /sgtk/software/shotgun/scarlet/install/core.backup/20150518_143940...    Copying /sgtk/software/shotgun/scarlet/install/engines...    Copying /sgtk/software/shotgun/scarlet/install/engines/app_store...    Copying /sgtk/software/shotgun/scarlet/install/frameworks...    Copying /sgtk/software/shotgun/scarlet/install/frameworks/app_store...    Updating cached locations in /sgtk/software/shotgun/scarlet_new/config/core/install_location.yml...    Updating Flow Production Tracking Configuration Record...    Deleting original configuration files...    All done! Your configuration has been successfully moved.パイプライン設定を手動で移動する                    重要: パイプライン設定をまだ移動していない場合は、上記の 組み込み tank コマンドを使用して自動的に移動することを強くお勧めします。    既に手動で移動を開始したが正しく動作しない場合は、新しい場所に移動されたパイプライン設定で Toolkit が引き続き動作するようにするために、変更が必要な内容を以下に示します。      パイプライン設定を新しい場所に移動します。     $ mv /sgtk/software/shotgun/scarlet /mnt/newserver/sgtk/software/shotgun/scarlet_new            Toolkit でパイプライン設定が格納されている場所を見つけられるように install_location.yml を編集します。     $ vi /mnt/newserver/sgtk/software/shotgun/scarlet_new/config/core/install_location.yml        適用可能なプラットフォームすべてで、パイプライン設定の新しい場所を示すようにこのファイル内のパスを更新します。プラットフォームを使用していない場合は、空の文字列 '' を入力します。     # Flow Production Tracking Toolkit configuration file # This file was automatically created by setup_project # This file reflects the paths in the primary pipeline # configuration defined for this project. Windows: 'Y: sgtk software shotgun scarlet_new' Darwin: '/mnt/newserver/sgtk/software/shotgun/scarlet_new' Linux: '' # End of file.            Flow Production Tracking でこのプロジェクトに対応する PipelineConfiguration エンティティを特定し、上記の変更と一致するように、[Mac のパス] (Mac Path)、[Windows のパス] (Windows Path)、[Linux のパス] (Linux Path)の各フィールドの値を修正します。  これでパイプライン設定が新しい場所から予想どおりに機能するようになりました。                    注: SG Desktop を使用している場合、プロジェクトから移動して、この新しい場所のパイプライン設定をリロードするためにプロジェクト アイコンを再びクリックする必要があります。    ",
    "url": "/18e34e3c/",
    "relUrl": "/18e34e3c/"
  },
  "84": {
    "id": "84",
    "title": "プロジェクト ディレクトリを新しいローカル ストレージのルートに移動するにはどうすればいいですか?",
    "content": "プロジェクト ディレクトリを新しいローカル ストレージのルートに移動するにはどうすればいいですか?                    注意: プロジェクトの途中でプロジェクトの場所を移動すると、Flow Production Tracking Toolkit の範囲を超えて問題が発生する可能性があります。安易に実行しないように注意してください。    必要に応じて、プロジェクト ファイル(シーン ファイルやレンダリングなど)を 新しいルート ストレージ場所に移動することがあります(たとえば /mnt/smalldrive から /mnt/bigdrive/foo へ)。このためには、単一ルート設定またはマルチルート設定を使用します。たとえば、「asset_storage」という名前のストレージを移動するとします。  古い場所から新しい場所にプロジェクト ファイルをコピー(または移動)します。  Flow Production Tracking で、[管理者] (Admin) &amp;gt; [サイト基本設定] (Site Preferences)ページに移動して、[ファイル管理] (File Management)セクションを開きます。   各プラットフォームでプロジェクト ファイルの新しいストレージへのパスを設定して、「primary」と言う名前のローカル ファイル ストレージを更新します。特定のプラットフォームを使用していない場合は、空白のままにします。  ページの上部または下部にある[変更を保存] (Save Changes)ボタンをクリックします。  Flow Production Tracking で保存したばかりの新しいパスの値と一致するようにプロジェクト設定の config/core/roots.yml ファイルを更新します。Toolkit はパブリッシュ パスをストレージ ルートの相対パスとして保存します。そのため、古いストレージ ルートを使用すると、パスはその前提に基づいて展開されていました。[asset_storage]/assets/Character/betty =&amp;gt; /mnt/smalldrive/assets/Character/betty新しいストレージ ルートの定義を使用すると、パスは次のように展開されます。[asset-storage]/assets/Character/betty =&amp;gt; /mnt/bigdrive/foo/assets/Character/bettyこれで、Flow Production Tracking や Toolkit 内の他のパブリッシュ情報の更新を心配する必要はありません。                    警告: 上記の手順では、既存のストレージ ルートのパスを変更していると想定しています。既存のストレージを破棄するか、新規のストレージを作成する場合は、すべてのフォルダを再登録して PublishedFiles エンティティを再公開する必要があります。    参考情報シーン ファイルで古いパスを指定している場合は、自分でパスを更新するか、パスが適切に解決されるようにシンボリック リンクを作成する必要があります。バージョンこの変更の影響を受ける[ムービーのパス] (Path to Movie)フィールドまたは[フレームのパス] (Path to Frames)フィールドに情報を持つバージョン エンティティを Flow Production Tracking で使用する場合、これらのフィールドも新しい場所をポイントするように更新する必要があります。これらのフィールドは、メディアへの絶対パスを含む文字列フィールドであるためです。",
    "url": "/9aaa493a/",
    "relUrl": "/9aaa493a/"
  },
  "85": {
    "id": "85",
    "title": "Cannot find procedure “MTsetToggleMenuItem”",
    "content": "Cannot find procedure “MTsetToggleMenuItem”関連するエラーメッセージ:通常のスプラッシュ画面が表示されてから、ウィンドウ全体がロードされる直前までの間に Maya がクラッシュする。  Cannot find procedure “MTsetToggleMenuItem”修正方法:Maya を起動する前に before_app_launch フックでパスの一部が誤って削除されたために、Maya の起動時にエラーになる可能性があります。この場合、Python インストールを PTHONPATH に追加すると、Maya 2019 によるプラグイン パスの検索を防止することができます。このエラーの原因の例:ユーザにはいくつかの問題がありました。このフックにより、C: Python27 が PYTHONPATH として設定され、この PYTHONPATH を使用してワークステーションが実際にインストールされたためです。コミュニティの完全なスレッドを参照してください。",
    "url": "/74106124/",
    "relUrl": "/74106124/"
  },
  "86": {
    "id": "86",
    "title": "App store does not contain an item named my-app",
    "content": "ERROR: App store does not contain an item named my-app修正方法:これは、カスタム アプリの場所の記述子に関係します。このドキュメントを参照してください場所については、パス ディスクリプタを使用して my-app を設定します。詳細についてはこちらを参照してください。このエラーの原因の例:tk-multi-snapshot が Maya に表示されないため、tank validate を使用しようとすると、カスタム アプリを検証するときに、このアプリがアプリ ストアにないことを示すエラーが表示されます。コミュニティの完全なスレッドを参照してください。",
    "url": "/226a0069/",
    "relUrl": "/226a0069/"
  },
  "87": {
    "id": "87",
    "title": "環境変数 NUKE_PATH を設定すると Nuke 統合の起動に失敗するのはなぜですか?",
    "content": "環境変数 NUKE_PATH を設定すると Nuke 統合の起動に失敗するのはなぜですか?当社の統合では Nuke の起動時に NUKE_PATH 環境変数が設定され、Nuke の起動プロセス中にブートストラップ スクリプトが実行されます。before_launch_app.py フックを実行する前に NUKE_PATH を明示的に定義するのは tk-multi-launchapp です。起動プロセス中に os.environ['NUKE_PATH'] = &quot;/my/custom/path&quot; などを使用してこの環境変数を設定している場合、Flow Production Tracking の統合は開始されません。これは、起動スクリプトのパスを環境変数から削除したためです。この機能を tank.util で使用すると、Toolkit ブートストラップへのパスを維持しながら、パスが環境変数 NUKE_PATH またはその先頭に追加されます。tank.util.append_path_to_env_var(&quot;NUKE_PATH&quot;, &quot;/my/custom/path&quot;)または、prepend_path_to_env_var() を使用してパスを先頭に追加できます。",
    "url": "/fc2af72c/",
    "relUrl": "/fc2af72c/"
  },
  "88": {
    "id": "88",
    "title": "オフラインでの使用と自動更新のオフ",
    "content": "オフラインでの使用と自動更新のオフ  自動更新          自動更新の対象となる部分      自動更新の対象ではない部分        統合オフラインを実行する          初期設定      更新を管理する        自動更新をオフにする          プロジェクト レベルまたはサイト レベルで更新をオフにする      1 つ以外のすべてのプロジェクトの更新をオフにする      アップグレード      自動更新自動更新の対象となる部分既定では、Flow Production Tracking Toolkit は更新の有無を自動的に確認し、更新がある場合はローカル マシンにインストールします。次の 2 つのコンポーネントの更新が検索されます。  tk-framework-desktopstartup: Flow Production Tracking Toolkit の起動を支援するフレームワーク。  tk-config-basic: 既定のサイト設定。この設定は、Flow Production Tracking Toolkit で使用する必要があるアプリン、エンジン、フレームワークのバージョン、およびコア バージョンのマニフェストとして機能します。設定を更新すると、これらのコンポーネントも更新される可能性があります。検索された更新はダウンロードされ、ユーザのローカル キャッシュに保存されます。元の Flow Production Tracking Toolkit インストール ファイルは変更されません。アプリケーションとして機能する Flow Production Tracking Create には、Flow Production Tracking Toolkit とは別の独自の更新メカニズムがあります。このメカニズムについては、ここでは説明しません。ただし、Flow Production Tracking Create に用意されている統合機能の動作は同様であり、tk-config-basic を自動更新して同じユーザ キャッシュに格納する動作も行います。自動更新の対象ではない部分      サイト設定を引き継いだ場合、tk-config-basic の新しい更新は検索されません。詳細については、後述します。        既定のサイト設定を使用していないプロジェクト(Toolkit の詳細設定ウィザードが実行されているプロジェクト)の設定は、自動更新されません。        Flow Production Tracking Toolkit にバンドルされた Python や Qt などのリソースは自動更新されません。 これらのパーツを更新する必要がある場合は、新しい Flow Production Tracking Toolkit インストーラがリリースされることがあります。  統合オフラインを実行する初期設定スタジオでインターネット アクセスが制限されている場合や、インターネットにアクセスできない場合は、必要なすべてのパーツがローカルにキャッシュされていることを確認する必要があります。Flow Production Tracking Create または Flow Production Tracking Toolkit をダウンロードするには、インターネットに接続できるマシンが 1 台必要になります。Flow Production Tracking Toolkit には、基本的な統合の実行に必要なすべての依存関係が事前にパッケージ化されています。Flow Production Tracking Create にも依存関係がバンドルされていますが、「更新を管理する」に記載されている手順に従うことも必要になります。いずれかを起動すると自動的に更新が検索されますが、Flow Production Tracking App Store に接続できない場合は、ローカルに存在する最新のバージョンが実行されます。インストーラにバンドルされたコンポーネントは最新でない可能性があるため、Flow Production Tracking Toolkit をインストールした後に、以下の「更新を管理する」の手順に従うことをお勧めします。                    注: ネットワーク設定によっては、更新にアクセスできない場合でも、オンラインで更新を探すことができない場合があります。この場合、環境変数 SHOTGUN_DISABLE_APPSTORE_ACCESS を &quot;1&quot; に設定すると、検索の試行を停止することができます。                        注: その後も、Flow Production Tracking サイトに接続可能である必要があります。オフラインという用語は、Autodesk App Store に接続して更新をダウンロードできない状態を意味します。    更新を管理するtk-framework-desktopstartup コンポーネントを更新するには、最新バージョンをダウンロードし、ディスク上の場所を指すように環境変数 SGTK_DESKTOP_STARTUP_LOCATION を設定する必要があります(これは Flow Production Tracking Toolkit にのみ適用されます)。tk-config-basic コンポーネントの場合は、依存関係があるため、少し面倒です。  インターネットに接続されたワークステーションで Flow Production Tracking Toolkit または Flow Production Tracking Create を実行します。これらを起動すると、最新のアップグレードが自動的にダウンロードされます。(このマシンで SHOTGUN_DISABLE_APPSTORE_ACCESS が設定されていないことを確認してください。)  バンドル キャッシュを、すべてのマシンがアクセスできる共有場所にコピーします。  オフライン マシンの SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS 環境変数がこの場所を指すように設定します。  オフライン マシンで Flow Production Tracking Toolkit または Flow Production Tracking Create が起動すると、バンドル キャッシュにある利用可能な最新のアップグレードが取得されます。                    警告: ネットワーク設定によっては、更新にアクセスできない場合でも、オンラインで更新を探すことができない場合があります。この場合、環境変数 SHOTGUN_DISABLE_APPSTORE_ACCESS を &quot;1&quot; に設定すると、検索の試行を停止することができます。    自動更新をオフにするプロジェクトまたはサイト レベルで更新をオフにする                    注: 可能であれば、新しい機能やバグ修正をインストールし忘れることがないよう、自動更新を有効にしておくことをお勧めします。    統合の自動更新をオフにするには、次の手順を実行します。  引き続き使用するバージョンを決定します。統合リリースはこちらにあります。      Flow Production Tracking で、プロジェクトまたはグローバル ページのいずれかにパイプライン設定エンティティを作成し、次のフィールドを入力します(この例では、v1.0.36 の統合を使用するように環境設定をロックしています)。          名前: Primary      プロジェクト: すべてのプロジェクトで更新をオフにする場合は、空のままにします。特定のプロジェクトのみをロックする場合は、特定のプロジェクトを選択します。      プラグインの ID: basic.*      記述子: sgtk:descriptor:app_store?name=tk-config-basic&amp;amp;version=v1.0.36                Flow Production Tracking Toolkit を起動します。プロジェクト フィールドを空のままにした場合、Flow Production Tracking Toolkit はこのバージョンを使用するように切り替わります(まだ切り替わっていない場合)。        プロジェクトを設定した場合は、設定したプロジェクトのみが影響を受け、Flow Production Tracking Toolkit の[バージョン情報] (About)ウィンドウは変更されません。    [オプション] tk-framework-desktopstartup のバージョンをロックするには、最新バージョンをダウンロードし、ディスク上の場所を指すように環境変数 SGTK_DESKTOP_STARTUP_LOCATION を設定する必要があります(これは Flow Production Tracking Toolkit にのみ適用されます)。大部分の機能は、以前の手順でロックできる環境設定によってコントロールされます。ただし、「自動更新の対象となる部分」セクションに記載されているように、コンポーネントも更新され、環境設定とは別に処理されます。これは Flow Production Tracking Toolkit にのみ適用されます。知っておきたい情報  環境設定のリリースを手動でダウンロードする必要はありません。Flow Production Tracking Toolkit を起動するか、プロジェクトを開始すると、自動的に処理されます。  basic.* は、基本設定のすべてのプラグインがこのオーバーライドを取得することを意味します。たとえば、Nuke と Maya の統合のみをフリーズする場合は、basic.maya、basic.nuke を指定します。  テストするには、このパイプライン設定エンティティの複製を作成し、User Restrictions フィールドに自分のユーザ名を追加します。これにより、自分のみが使用できるようにエンティティが制限され、他のユーザには影響を与えなくなります。この複製した環境設定から Maya などのソフトウェアを起動して、予想される統合バージョンが実行されていることを確認することができます。      プロジェクト フィールドを空白のままにすると、「サイト設定」が適用されます。 Flow Production Tracking Toolkit はプロジェクト外で動作するため、サイト設定が使用されます。Flow Production Tracking Toolkit でプロジェクトを選択すると、プロジェクト設定もロードされます。    Flame 統合のネームスペースは basic.flame であり、basic.* の一部であることが暗示されています。 しかし Flame 統合は、実際には基本設定に含まれていません。そのため、プロジェクトに Flame を使用してこのオーバーライドを実装すると、Flame 統合が機能しなくなります。 解決策は、Flame 専用の追加のパイプライン設定オーバーライドを作成することです。          名前: Primary      プロジェクト: ロックするプロジェクト(すべてのプロジェクトの場合はなし)      プラグインの ID: basic.flame      記述子: sgtk:descriptor:app_store?name=tk-config-flameplugin      1 つ以外のすべてのプロジェクトの更新をオフにする上記の例の手順に従ってすべてのプロジェクトの更新をオフにした場合に、特定のプロジェクトの更新を有効にするには、次の操作を実行します。  上記のセクションで説明したように、サイトの更新をオフにします。  例外にするプロジェクトのパイプライン設定エンティティに、次のフィールド値を設定します。          名前: Primary      プロジェクト: ロックしないプロジェクト      プラグインの ID: basic.*      記述子: sgtk:descriptor:app_store?name=tk-config-basic  [記述子] (Descriptor)フィールドでバージョン番号を省略すると、プロジェクトは基本設定の最新リリースをトラックします。      アップグレード設定を更新する場合は、すべてのユーザに展開する前に、新しいバージョンをテストしなければならないことがあります。  Flow Production Tracking でパイプラインの設定エンティティを右クリックし、[選択した項目を複製] (Duplicate Selected)を選択して複製します。  クローン作成した設定に「update test」という名前をつけて、自分を[ユーザ制限] (User Restrictions)フィールドに割り当てます。  このパイプライン設定を使用するようになります。  テストするバージョンを指すように記述子を変更します。  テストに参加させるユーザは、User Restrictions フィールドに追加して招待できます。  問題なくテストが完了したら、そのバージョンを使用するようにメインのパイプライン設定を更新するだけです。  ユーザが Flow Production Tracking Toolkit を再起動し、現在開いているソフトウェアと実行中の Flow Production Tracking の統合を再起動すると、更新が選択されます。",
    "url": "/b31ed3ef/",
    "relUrl": "/b31ed3ef/"
  },
  "89": {
    "id": "89",
    "title": "Onboarding Process",
    "content": "Onboarding ProcessLeveraging the isolation features requires adopters to become AWS users. In order to ensure that this joint venture between Autodesk, AWS, and our clients is as streamlined as possible, we decided to work closely with AWS to define a cooperative onboarding process that would meet client expectations for a premium offering.Autodesk will provide dedicated resources during the onboarding process to help you on this journey.To start the on-boarding process for any of the Isolation features, please fill out this short survey, before proceeding with your setup.Onboarding Process OverviewDuring the onboarding process, you’ll have direct access to Autodesk resources who will support you during the implementation.Setup / Test / Activation:	Iterative installation process where you connect your AWS resources to Flow Production Tracking, and activate the isolation features.Onboarding ResourcesFlow Production Tracking Community: The Flow Production Tracking Isolation Community forum can be used to ask questions that can be answered by either Flow Production Tracking Experts or other isolation features users. This should be your first stop when asking general questions about isolation features, during setup and beyond.Dedicated Microsoft Teams team: During the onboarding, you will be given access to a Microsoft Teams team. Your Flow Production Tracking leaders will be available for quick feedback, answers, and ad-hoc meetings to help you progress as fast as possible with your Flow Production Tracking Isolation setup. This channel will be available only for the onboarding period.Flow Production Tracking Support: A Flow Production Tracking Support ticket will be used to track your onboarding at a higher level. Once your Flow Production Tracking Isolation setup is complete, follow-up support tickets can be opened with the support team as needed.Next StepsOnce the onboarding process is started, you can start thinking about your setup",
    "url": "/f66c5afa/",
    "relUrl": "/f66c5afa/"
  },
  "90": {
    "id": "90",
    "title": "その他の統合",
    "content": "その他の統合Flow Production Tracking の API を使用することで、多数のサードパーティのパッケージと統合することができます。ただし、Flow Production Tracking とすぐに統合できるものもあります。CinesyncCinesync では、複数の場所から再生を同時に同期できます。Flow Production Tracking の統合により、バージョンのプレイリストを作成し、Cinesync で再生して、セッション時に作成したノートを Flow Production Tracking に送信できます。詳細については、http://www.cinesync.com/manual/latest を参照してください。DeadlineFlow Production Tracking と Deadline の統合により、すべてのサムネイル、フレームへのリンク、および他のメタデータとともにレンダリングしたバージョンが Flow Production Tracking に自動的に送信されます。詳細については、https://docs.thinkboxsoftware.com/products/deadline/5.2/User%20Manual/manual/shotgunevent.html を参照してください。RushDeadline との統合とほぼ同じように、Flow Production Tracking と Rush の統合により、すべてのサムネイル、フレームへのリンク、および他のメタデータとともにレンダリングしたバージョンが Flow Production Tracking に自動的に送信されます。詳細については、https://seriss.com/rush-current/index.html を参照してください。Subversion (SVN)内部で使用される、軽量で柔軟性に優れた Flow Production Tracking の統合では、Flow Production Tracking でリビジョンをトラックし、チケットとリリースにリンクすることができます。また、外部ウェブ SVN リポジトリ ビューアと統合できるように Trac にもリンクできます。これは SVN にポストコミット フックを追加することで実行できます。このフックは、コミットからいくつかの ENV 変数を取得し、さまざまなフィールドに設定して Flow Production Tracking でリビジョン エンティティを作成する Flow Production Tracking API スクリプトです。スタジオのニーズに合わせて修正し、API を使用しているだけなので、ローカルまたはホストされたインストールで使用することができます。詳細については、https://subversion.apache.org/docs を参照してください。",
    "url": "/f0ee6c48/",
    "relUrl": "/f0ee6c48/"
  },
  "91": {
    "id": "91",
    "title": "The path `&lt;PATH&gt;` is already associated with {% include product %} entity `&lt;ENTITY&gt;`",
    "content": "Database concurrency problems: The path &amp;lt;PATH&amp;gt; is already associated with Flow Production Tracking entity &amp;lt;ENTITY&amp;gt;関連するエラーメッセージ:  Database concurrency problems: The path &amp;lt;PATH&amp;gt; is already associated with Flow Production Tracking entity &amp;lt;ENTITY&amp;gt;.  Could not resolve row id for path!例:このエラーは、Toolkit ユーザがフォルダの作成を試みたときに発生します。次に、完全なエラーを示します。ERROR: Database concurrency problems: The path'Z: projects SpaceRocks shots ABC_0059' is already associated withShotgun entity {'type': 'Shot', 'id': 1809, 'name': 'ABC_0059'}. Please re-runfolder creation to try again.エラーの原因FilesystemLocation エンティティが既に含まれているフォルダに対してこのエンティティを作成しようとしているときに発生します。修正方法不正な FilesystemLocation エンティティをクリアします。エラーのある FilesystemLocation エンティティのセットに絞り込むことができた場合は、これらを削除するだけで済みます。通常はプロジェクトのすべてのパスが損なわれているため、すべてのパスを削除する必要があります。  FilesystemLocation エンティティをクリアする方法: 理想的なのは、tank unregister_folders を実行できることです。これらすべてをクリアするには、tank unregister_folders --all を実行します。(tank unregister_folders のすべてのオプションでは、引数を指定しないで実行するだけで、使用上の注意事項が出力されます。)  ただし、データベースは既に不安定な状態になっているため、この方法が機能しないか、部分的にしか機能しない場合があります。コマンドを実行したら、Flow Production Tracking の FilesystemLocations に戻って、削除予定の内容が実際に削除されていることを確認します。削除されていない場合は、不適切なエンティティを選択し、手動でごみ箱に移動します。この時点で、Flow Production Tracking の FilesystemLocations はクリーンな状態ですが、アーティストのローカル キャッシュには変更が反映されていない可能性があります。最後の手順では、各ユーザのマシンのローカル キャッシュを実際に同期します。この操作を行うには、tank synchronize_folders --full を実行する必要があります。これらの手順をすべて実行すると、パスのキャッシュは適切な状態になり、エラーは表示されなくなります。関連リンク  問題のあるコード  パス キャッシュとは何ですか? ファイルシステムの場所とは何ですか?コミュニティの完全なスレッドを参照してください。",
    "url": "/3636e362/",
    "relUrl": "/3636e362/"
  },
  "92": {
    "id": "92",
    "title": "Windows パスが長すぎるためのエラー",
    "content": "Windows パスが長すぎるためのエラー(256 文字を超過)厳然たる事実Windows のパス名に関する既定の制限である 255/260 文字は、非常に低い値です。この制限に関する Microsoft の情報についてはこちらを、詳細な技術情報についてはこちらを参照してください。エラーこのエラー自体はさまざまな方法で現れますが、通常は SG Desktop が設定を初めてロードして、バンドル キャッシュに項目をダウンロードしている間に発生します。Windows 10 の最新バージョンでエラーはわずかに改善されたように見えますが、多少意味不明なところがあります。次に、表示されるエラーの例をいくつか示します。[ WARNING] Attempt 1: Attachment download of id 3265791 from https://xxxxx.shotgunstudio.com failed: [Error 206] The filename or extension is too long: 'C:  Users  xxxxx  AppData  Roaming  Shotgun  bundle_cache  tmp  0933a8b9a91440a2baf3dd7df44b40ce  bundle_cache  git  tk-framework-imageutils.git  v0.0.2  python  vendors  osx  lib  python2.7  site-packages  pip  _vendor  requests  packages  urllib3  packages  ssl_match_hostname'[ WARNING] File 'c: users xxxxx appdata local temp ab35bd0eb2b14c3b9458c67bceeed935_tank.zip' could not be deleted, skipping: [Error 32] The process cannot access the file because it is being used by another process: 'c:  users  xxxxx  appdata  local  temp  ab35bd0eb2b14c3b9458c67bceeed935_tank.zip'ERROR sgtk.core.descriptor.io_descriptor.downloadable] Failed to download into path C: Users xxxxx AppData Roaming Shotgun bundle_cache tmp 123456789012a34b567c890d1e23456: Failed to download sgtk:descriptor:shotgun?entity_type=PipelineConfiguration&amp;amp;field=uploaded_config&amp;amp;id=38&amp;amp;version=123456 from https://xxxxx.shotgunstudio.com. Error: Failed to download from 'https://xxxxx.shotgunstudio.com' after 5 retries. See error log for details.. Attempting to remove it.WARNING sgtk.core.util.shotgun.download Attempt 4: Attachment download of id 1182 from https://xxxxx.shotgunstudio.com failed: [Errno 2] No such file or directory: 'C:  Users  xxxxx  AppData  Roaming  Shotgun  bundle_cache  tmp  dd2cc0804122403a87ac71efccd383ea  bundle_cache  app_store  tk-framework-desktopserver  v1.3.1  resources  python  build  pip  _vendor  requests  packages  urllib3  packages  ssl_match_hostname  _implementation.py'WARNING sgtk.core.util.filesystem File 'c: users xxxxx appdata local temp 08f94bfe9b6d43e7a7beba30c192a43c_tank.zip' could not be deleted, skipping: [Error 32] The process cannot access the file because it is being used by another process: 'c:  users  xxxxx  appdata  local  temp  08f94bfe9b6d43e7a7beba30c192a43c_tank.zip'ERROR sgtk.core.descriptor.io_descriptor.downloadable] Failed to download into path C: Users xxxxx AppData Roaming Shotgun bundle_cache tmp dd2cc0804122403a87ac71efccd383ea: Failed to download sgtk:descriptor:shotgun?entity_type=PipelineConfiguration&amp;amp;field=sg_uploaded_config&amp;amp;id=1&amp;amp;version=1182 from https://xxxxx.shotgunstudio.com. Error: Failed to download from 'https://xxxxx.shotgunstudio.com' after 5 retries. See error log for details.. Attempting to remove it.ERROR sgtk.core.bootstrap.cached_configuration Failed to install configuration sgtk:descriptor:shotgun?entity_type=PipelineConfiguration&amp;amp;field=sg_uploaded_config&amp;amp;id=1&amp;amp;version=1182. Error: Failed to download into path C: Users xxxxx AppData Roaming Shotgun bundle_cache tmp dd2cc0804122403a87ac71efccd383ea: Failed to download sgtk:descriptor:shotgun?entity_type=PipelineConfiguration&amp;amp;field=sg_uploaded_config&amp;amp;id=1&amp;amp;version=1182 from https://xxxxx.shotgunstudio.com. Error: Failed to download from 'https://xxxxx.shotgunstudio.com' after 5 retries. See error log for details.. Cannot continue.このエラーが発生する理由Windows では、Flow Production Tracking Toolkit はデータを %APPDATA% フォルダ(通常は C: Users jane AppData Roaming Shotgun)に保存します。標準の default2 Toolkit 設定を使用しているときは、ユーザ名が極端に長い場合を除いて、ほとんどの場合問題ありません。ただし、独自のアプリ、エンジン、またはフレームワークを作成する場合は、この問題が発生するリスクが高くなります。特に、(オートデスクと同様に)コードとの依存関係をバンドルしていて、バンドル内のディレクトリ ツリーの階層が深い場合はリスクが高くなります。問題の回避策この問題を解決するには、通常、環境変数 $SHOTGUN_HOME を C: SG のような非常に短い値に設定します。これにより、SG Desktop は C: Users jane AppData Roaming Shotgun でなく、C: SG にデータを保存するようになるため、文字数が節約されます。制限内に収まるよう維持するには、通常はこの方法で十分です。環境変数については、こちらを参照してください。将来の可能性こちらに記載されているように、レジストリを更新することにより、新しいバージョンの Windows 10 でこの問題を軽減できる可能性があります。ただし、longPathAware の設定を利用することを指定するには、SG Desktop のマニフェスト ファイルを更新する必要もあります。私は Mac ユーザであるため、この内容が役に立つかどうかは分かりません。コミュニティで完全なスレッドを参照してください。",
    "url": "/aed84d1f/",
    "relUrl": "/aed84d1f/"
  },
  "93": {
    "id": "93",
    "title": "パフォーマンスのトラブルシューティング",
    "content": "パフォーマンスのトラブルシューティングToolkit の使用速度が低下することがあります。速度が低下する理由はさまざまです。サーバ速度やインターネット接続などのクライアント側インフラストラクチャの問題、Toolkit や Flow Production Tracking が高いパフォーマンスで実行されるように設定されていない設定ベースの問題、さらに最適化を行う余地があるコード上の問題などがあります。次に、チェック項目のクイック リストを示します。これらのチェック項目については、以下で詳細に説明します。  アプリ、エンジン、フレームワーク、コア、Flow Production Tracking Toolkit が最新であることを確認します。  一般的な用途のときに、デバッグ ログが無効になっていることを確認します。  必要なフォルダのみを作成し、フォルダ数を制限して、実際に必要な場合に限りフォルダが作成されるようにします。スキーマにフォルダを追加しすぎると、速度が低下します。  サーバにユーザ キャッシュを保存する、速度が低下することがあります。ユーザの Flow Production Tracking キャッシュをリダイレクトするには、ローカル ドライブ上の場所を指定するように Flow Production Tracking_HOME の環境変数を設定します。  アーティストが必要としていないコンテンツを除外するように、作業ファイルおよびローダー アプリを設定します。ステータスを基準とするフィルタを実行して、エンティティ リストを短くし、アーティストの現在のタスクに関連するエントリが表示されるようにします。  カスタム フックの有無を調べて、追加のオーバーヘッドがないか確認します。次に、適切な方法と、速度が低下する一般的なシナリオを示します。このリストは、まだすべてを網羅するものではありません。新しいパターンが見つかったときに、適宜追加されます。このガイドを参照しても、現在発生している問題の根本的な原因が見つからない場合は、サポート チケットをお送りください。担当チームがサポートいたします。目次:  一般的なお勧めの方法          キャッシュの場所      最新の状態を保つ      一元管理設定と分散設定      デバッグ        ソフトウェアの起動速度が遅い          診断      問題が発生するタイミング(起動前または起動後)      ログを調べる      ソフトウェアの起動速度が低下する一般的な原因        [File Open]、[File Save]、Loader アプリのいずれかで速度が低下する場合  フォルダ作成速度が低下する          I/O 使用量を制御する      フォルダを登録する      一般的なお勧めの方法キャッシュの場所Flow Production Tracking Toolkit は、データをユーザのホーム ディレクトリにキャッシュ します。このキャッシュには、さまざまな SQLite データベース、およびキャッシュされたアプリと設定を含めることができます。通常、ユーザのホーム ディレクトリはマシンのローカル ハード ドライブに保存されますが、スタジオでは、ネットワーク上のストレージにこれらをリダイレクトすることが一般的に行われています。この方法の場合、パフォーマンスが低下することがあります。特に大きな影響を受けるのが、ブラウザの統合やフォルダの作成/検索に使用される SQLite データベースです。ユーザ ディレクトリがサーバ上の場所に保存されている場合は、ShotGrid_HOME の環境変数 を使用して、Flow Production Tracking Toolkit のキャッシュのパスを再設定することをお勧めします。ShotGrid_HOME 環境変数は、データおよびその他の項目の高速検索に使用されるバンドル キャッシュ、サムネイル、SQLite データベースなど、Toolkit がさまざまなデータをキャッシュする場所を設定する際に使用されます。デバッグFlow Production Tracking Toolkit でデバッグ ログを有効にして、さまざまなプロセスから詳細な出力を取得することができます。このようにすると、問題を診断するときに非常に便利です。ただし、デバッグ設定は、通常の日常的な用途のときは有効にならないように設計されています。ログの出力量が増えると、パフォーマンスが大幅に低下することがあります。パフォーマンスの問題が発生した場合、特に、特定のマシンやユーザに限定された問題が発生する場合は、最初にデバッグ ログが無効になっていることを確認してください。最新の状態を保つパフォーマンスの問題が発生した場合は、コア、アプリ、エンジン、およびフレームワークが最新状態になっていることを確認します。新しいリリースで修正プログラムや最適化が既に提供されていることがあります。一元管理設定と分散設定Toolkit の詳細設定は、一元管理設定と分散設定の 2 つの方法で行うことができます。主な違いは、一元管理設定は通常、スタジオのネットワーク ストレージに配置されていて、すべてのユーザがアクセスできることです。一方、分散設定は一般にクラウド内に保存されていて、ユーザ単位でローカルにキャッシュされます。この 2 つの方法の違いはパフォーマンス以外にもありますが、パフォーマンスに関しては長所と短所の両面があります。次の表に、純粋にパフォーマンスの観点から見た長所と短所を示します。                   利点      欠点                  一元管理設定      - 初期設定プロセスが完了すると、必要なすべてのものが既にダウンロードされていて、すべてのユーザが使用できる状態になっています。      - 一元管理設定は通常、ネットワーク ストレージに保存されるため、Toolkit の一般的な用途のときにパフォーマンスが低下することがあります。                     - 将来の更新は、一元管理された場所に 1 回ダウンロードするだけで済みます。      - Toolkit の設定には多数の小さなファイルが含まれています。多数の小さなファイルにメタデータ操作を行うと、処理速度が大幅に低下し、サーバの負荷が増大することがあります。また、Toolkit を使用する読み取り操作と、サーバの一般的な用途における読み取り操作の負荷が増大すると、設定をすばやく読み取ることができなくなって、Toolkit のパフォーマンスが低下することがあります。              分散設定      - キャッシュされたアプリ、エンジン、フレームワーク、およびコアは、他のローカルにキャッシュされた設定と共有できるような方法で保存されます。つまり、複数のプロジェクトを今後ロードするときに、これらが同じ依存関係を共有していれば、キャッシュ速度が上がる可能性があります。      - 分散設定はユーザ単位でローカルにキャッシュする必要があります。この操作を行うには、通常、設定、および必要なすべてのアプリ、エンジン、フレームワーク、コアをダウンロードします。                     - これらはローカル ハード ドライブ上のユーザ キャッシュに保存されるため、通常はサーバ速度よりもパフォーマンスが向上します。つまり、最初のキャッシュ以降のパフォーマンスは一元管理設定よりも高くなります。      - このプロセスはシーンの背後でシームレスに行われますが、これらをダウンロードする初期コストがかかります。                            - 新しいバージョンの依存関係を指定するように設定を更新するたびに、設定と新しい依存関係の両方をキャッシュする必要があります。      手短に言えば、ストレージは低速だが妥当な速度のインターネット接続を使用している場合は、分散設定が最適な設定になる可能性がありますが、サーバ ストレージのパフォーマンスが高く、インターネットのパフォーマンスが低い場合は、一元管理設定が適している可能性があります。                    注: 分散設定に興味はあっても、マシンごとに依存関係をダウンロードすることについて懸念を抱いている場合は、バンドル キャッシュのみを一元管理して、すべてのユーザで共有することができます。    分散設定を使用している場合、ユーザはキャッシュ内にまだ保存されていないデータのみダウンロードする必要があります。ユーザがデータをダウンロードすると、他のユーザもそのデータを利用できるようになります。このようにするには、各マシンの共有場所を指定するように、ShotGrid_BUNDLE_CACHE_PATH の環境変数を設定します。ソフトウェアの起動速度が遅いMaya、Nuke、Houdini などのソフトウェアを起動するときに、Flow Production Tracking を使用しない場合に比べて起動時間が長くなることがあります。Flow Production Tracking を使用しない場合に比べて起動時間が長くなるのは通常のことですが、これらの時間が許容できないレベルまで増大することがあります(ソフトウェアによって異なりますが、通常は起動時間が 1 分未満であると予測しています)。ソフトウェアの起動には多くのプロセスが関係しているため、この問題を診断するのは面倒なことがあります。診断最初に行う必要があるのは、この問題が発生する場合の条件を特定することです。  Flow Production Tracking を使用しないで起動したときに低速になりますか? - 明らかなことかもしれませんが、Flow Production Tracking を使用して起動した場合のみ問題が発生することを確認することが重要です。  起動方法に関係なく低速ですか? つまり、SG Desktop から起動した場合と、ブラウザ統合を使用して SG サイトから起動した場合で違いはありますか? - Flow Production Tracking サイトから起動したときに低速になり、SG Desktop から起動したときに低速にならない場合は、ブラウザ統合に問題があるか、ディスク上にフォルダを作成するときに問題が発生している可能性があります。プロジェクト以外のコンテキストから起動した場合は、ディスク上に作成されるフォルダ数が増える可能性があるため、時間がかかることがあります。また、ソフトウェアが起動されるたびに、必要なフォルダの有無を確認することも重要です。  すべてのプロジェクトで発生しますか? - 問題が発生しないプロジェクトがある場合は、設定方法に固有の問題である可能性があります。  1 日の特定の時点で発生しますか? - 1 日の特定の時点で発生する場合は、1 日の特定の時間帯にサーバ使用量が増大しているなど、インフラストラクチャに対する要求が増加している可能性があります。  使用しているすべてのマシン/OS で発生しますか? - 特定のマシンの速度が低下する場合、問題の原因は Toolkit の外部にある可能性があります。ただし、最初の手順として、このマシンに Toolkit のキャッシュを作成することをお勧めします。ソフトウェアおよび Python パッケージごとに異なるバージョンの OS が付属していて、特定のバンドルでパフォーマンスの問題が発生することがあります。特に、Windows で Samba (SMB)共有を使用している場合に、パフォーマンスの問題が発生するケースが見られます。このような問題の修正プログラムはありませんが、これを使用する場合にこの問題を認識することが大事です。この問題が特定の OS、Python パッケージ、またはソフトウェア バージョンに限定されていると判断される場合は、サポート チームに問い合わせてさらに調査するよう依頼してください。  すべてのユーザで発生しますか? - 上記と同様に、同じマシンを使用している別のユーザでは、この問題が発生しないことがあります。この場合は、まずユーザのローカル Flow Production Tracking キャッシュをクリアします。また、通常のプロダクションでの用途に対してデバッグ ログが有効になっていないことを確認してください。パフォーマンスが低下しなくなります。  起動速度の低下は特定のアプリ/ソフトウェアに特有のものですか、それともすべてのアプリ/ソフトウェアで起動速度が異常に低下しますか? - 特定のソフトウェアの起動速度が低下する場合は、設定に問題がある可能性があります。起動の前後に実行されるようにカスタム フックが設定されていて、パフォーマンス低下の原因となっている可能性があるかどうかを確認することをお勧めします。起動時に使用される一般的なフックは before_app_launch.py、app_launch.py、およびコア フックの engine_init.py です。ときどき、新しいバージョンのソフトウェアがリリースされ、Toolkit の統合の起動速度が突然大幅に低下することもあります。このような場合は、サポートに問い合わせて、この問題が認識されているかどうか、および既知の修正プログラムがあるかどうかを確認する必要があります。使用しているソフトウェア(パッチ/サービス パックが適用可能な場合は、これらを含む)のバージョン番号、および実行している Toolkit エンジンとコアのバージョンをお知らせください。問題が発生するタイミング(起動前または起動後)上記の手順を行っても原因を絞り込むことができなかった場合は、次に、起動プロセスのどの段階で速度が低下するのかを確認します。Toolkit を介してソフトウェアを起動している場合は、一般に起動プロセスを 2 段階のプロセスにまとめることができます。最初の手順では、いくつかの初期操作を実行します。たとえば、ソフトウェアの起動に必要な情報を収集したり、コンテキストからフォルダを自動的に作成し、その後でソフトウェアを実際に起動したりします。次に、起動プロセスの 2 番目の手順が行われ、ソフトウェアの起動後に Toolkit の統合が起動されます。通常は、ログを調べなくても、プロセスの最初の手順と 2 番目の手順のどちらでパフォーマンスの問題が発生しているのかを確認できます。  そのためには、ソフトウェアのスプラッシュ画面を観察して、この画面の起動時間が長いかを確認します。スプラッシュ画面の起動時間が長い場合は、問題が最初の手順で発生している可能性があります。  また、ソフトウェアの起動時間が比較的短いにもかかわらず、初期化が終了して Flow Production Tracking メニューが表示された後に速度が低下することがあります。この場合は、2 番目の手順で問題が発生しています。この情報を把握しておくと、この次の作業でログを確認する際に役立ちます。ログを調べる起動の最初の手順または 2 番目の手順のどちらで問題が発生しているのかを確認したら、調査対象のログを特定することができます。ログはエンジンごとに分かれているため、問題が起動前の段階で発生している可能性がある場合は、SG Desktop から起動しているのか、それとも SG サイトから起動しているのかに応じて、tk-desktop.log または tk-ShotGrid.log を調べる必要があります。次に、デバッグ ログを有効にする必要があります。                    注: デバッグ ログが既に有効になっている場合は、上記のとおり、これが動作低下の原因になっていることがあるため、デバッグ ログを有効にしないでテストしてください。    デバッグ ログを有効にしたら、既存のログをクリアして、起動プロセスを再現する必要があります。ログ内のタイムスタンプを使用して、時間が急に変化している行を確認します。たとえば、フォルダの作成中に、時間が 5 秒間突然変化している行がいくつかあります。2019-05-01 11:27:56,835 [82801 DEBUG sgtk.core.path_cache] Path cache syncing not necessary - local folders already up to date!2019-05-01 11:28:01,847 [82801 INFO sgtk.env.asset.tk-shotgun.tk-shotgun-folders] 1 Asset processed - Processed 66 folders on disk.時間が急に変化している場所を特定したら、そのログの行を調べると、その段階で何が起こっていたのかを把握することができます。たとえば、フォルダの作成中や、Flow Production Tracking の接続の取得中に問題が発生していることがあります。ただし、ログを参照するのは面倒な作業であり、内容に意味があるとは限らないため、サポートに問い合わせて、この作業のサポートを依頼することができます。ソフトウェアの起動速度が低下する一般的な原因            インターネットの速度低下      Toolkit のほぼあらゆる使用状況において Flow Production Tracking サイトに接続して通信する必要がありますが、インターネットの速度が低下すると、この動作が影響を受けます。この場合は通常、ソフトウェアの起動だけでなく、他の状況においても、速度に関する問題が発生します。ただし、接続速度が低下するのではなく、接続が不安定になる場合は、起動時にパフォーマンスの問題が生じる可能性があります(大量の Flow Production Tracking 通信がプロセスを通して行われるためです)。              サーバ アクセス速度の低下      この問題は確実に起動時間に影響します。一元管理設定を使用している(設定が中央サーバに保存されている)場合は、設定ファイルを読み取るときに大量の I/O が発生することがあります。特に、ソフトウェアを起動すると、起動時の状況に応じてフォルダが作成されます。つまり、フォルダが作成されているかどうかが確認され、作成されていなければ作成されます。              フォルダの作成      上記のように、フォルダ作成が速度低下の一般的な原因になることがあります。詳細については、以下のフォルダ作成時のパフォーマンスに関するトラブルシューティングを参照してください。      [File Open]、[File Save]、Loader アプリのいずれかで速度が低下する場合最初に、問題となっているアプリの速度が低下する状況を絞り込んで、特定します。  アプリを起動するときに速度が低下しますか、それともタブ間で移動するときに低下しますか?          アプリは現在、極端に多くの情報を表示するように設定されている可能性があります。[マイ タスク] (My Tasks)タブやその他のタブは、リスト内の不要なエンティティ除外するように設定できます。たとえば、[保留中] (On Hold) (hld)や[最終] (Final) (fin)などの特定のステータスを持つタスクを除外できます。このようにすると、パフォーマンスが向上するだけでなく、アーティストは自分が必要としている情報のみを表示することができます。Loader アプリと Workfiles アプリの両方を除外できます。Workfiles には現在、フィルタに関する特定のドキュメント セクションが用意されていませんが、階層設定中にフィルタを適用することができます。      File Open アプリの階層を、この階層が展開されるまでサブ項目のロードを遅らせるように設定することもできます。これが既定の設定になっていますが、古い設定を使用している場合は、この設定を使用するように移行することができます。      デバッグ ログが有効になっていないことを確認します。デバッグ ログが有効になっていると、追加の I/O が大量に発生するため、速度が低下することがあります。これらのアプリには、大量のデバッグ出力が含まれています。        ファイルを開く、保存する、または新規作成するときに速度が低下しますか?          シーンの操作やアクションのフックを引き継いで処理したかどうか、およびこれらの関数の前後に速度低下の原因となるカスタム動作が行われているかどうかを確認します。      ファイルを作成するときや、保存するときに、Workfiles はこのコンテキストに必要なすべてのフォルダが作成されていることを確認します。パフォーマンスの問題が発生する一般的な原因は、フォルダの作成です。      フォルダ作成速度が低下するフォルダの作成は多くの要素で構成されていて、問題が発生したときに処理速度が低下する原因となることがあります。フォルダの作成では、次の処理が行われます。  ローカル パス キャッシュを同期する  設定のスキーマを読み取る  状況に応じて作成する必要があるパスのリストを生成する  ローカルに保存されたパス レジストリと比較してパスを確認する  SG サイトとローカルな場所の両方に新しいパスが登録されていない場合は、登録を試みる  フォルダの登録の有無に関係なく、このフォルダがディスク上に実際にあるかどうかを確認し、存在しない場合は作成するつまり、フォルダを作成すると、ディスクの I/O 使用量が大幅に増えるとともに、ローカル データベースへの書き込みと SG サイトとの通信が必要になります。I/O 使用量を制御する多数の小規模な読み取り/書き込み操作を処理するときに、ストレージの速度や効率が低下することがあるため、インフラストラクチャの効率化に役立つ手順を行うと、フォルダ作成の処理時間を短縮できます。ただし、できるだけ負荷を軽減するために Toolkit 設定側で試行できる手順があります。最初に行うのは、この状況、および作業中の環境にとって重要なフォルダのみが作成されるように制限することです。たとえば、Maya でタスクやショットを操作している場合は、特定のショットおよびソフトウェアのフォルダのみを確認して、作成することが理想的です。基本的に、作品を保存およびパブリッシュするのに最低限必要なフォルダを作成するようにします。親フォルダを使用して作成するスキーマ フォルダに適用できる  create_with_parent設定があります。これを true に設定すると、フォルダが親フォルダであるときにそのフォルダが作成されるようになります。この設定を true に設定するときは、多数のフォルダが確認および作成されるという状況にならないように注意してください。例シーケンス/ショットのフォルダ階層がある場合に、親のシーケンスを使用して作成するようにショット フォルダを設定すると、シーケンス フォルダを作成するときはいつでも関連するすべてのショットが確認され、これらのフォルダが作成されるようになります。状況によってはこの方法が便利なことがありますが、多数のフォルダの確認と作成が一度に行われることがあります。このシナリオで、タスクまたはショットの作業ファイル内に新しいファイルを作成すると、ショットの親となるシーケンス フォルダが作成され、作業中のショットだけでなく、この子となるすべてのショット フォルダが作成されます                    注: ステップ スキーマ フォルダの設定は、既定で true になっています。    作成の遅延defer_creation 設定により、特定のエンジンが実行されている場合に限ってフォルダが作成されるように制限することで、フォルダの作成時期を調整することができます。カスタム名を使用し、sgtk API を使用してこの名前のフォルダが作成されるようにすることもできます。例場合によっては、一連のフォルダの作成時期をパブリッシュ段階に限定する必要があります。この場合は、カスタム名を maya_publish という遅延キーワードに設定し、その後で API を使用してこのキーワードをエンジン名として持つフォルダを作成することができます。スキーマ内のフォルダは次のようになります。# the type of dynamic contenttype: &quot;static&quot;# defer creation and only create this folder when Photoshop startsdefer_creation: &quot;publish&quot;その後、次のようなスクリプトを使用してフォルダを作成します。sgtk.create_filesystem_structure(entity[&quot;type&quot;], entity[&quot;id&quot;], engine=&quot;publish&quot;)拡張された例フォルダを遅延することにした場合、プロジェクトのルートに動的でないフォルダが複数あれば、通常はこれらを 1 回のみ作成する必要があります。たとえば、「editorial」および「reference」フォルダが既定の設定のスキーマのルートに配置されている場合は、通常、プロジェクトの開始時にこれらのフォルダを 1 回だけ作成しなければならないことがありますが、既定では、フォルダ作成を行うたびにこれらのフォルダの有無が確認されます。この動作を制限するには、これらのフォルダの yml ファイルを作成して遅延キーワードを設定し、フォルダの作成が特定のエンジンで実行された場合、またはキーワードが渡された場合のみ、これらのフォルダが作成されるようにします。遅延キーワードを tk-shell に設定して、tank folders のような tank コマンドを使用してフォルダ作成を実行することができます。これは、これらのフォルダ作成が tank コマンドを介して実行された場合に限り実行されることを意味します。tank コマンドは、プロジェクトを初めて設定するときに Toolkit 管理者が実行することができます。また、上の例のようなカスタム キーワードを使用してフォルダ作成を実行する、小規模なスクリプトを記述することもできますフォルダを登録するフォルダ作成プロセス中にフォルダが登録されるため、後でコンテキストを調べる際に登録されたパスを使用することができます。上記のように、この処理中に、レジストリが保存されている一元的な場所である Flow Production Tracking サイトと通信する必要があります。ただし、ツールによる高速検索を有効にするために、これらのレジストリもローカルにキャッシュされます。SQLite データベースローカルなパス キャッシュは SQLite データベースを使用してデータを保存します。ネットワーク上のストレージにデータベースが保存されている場合は、データベースに対する読み取りおよび書き込みのパフォーマンスが大幅に低下することがあります。初期同期プロジェクトに多数のフォルダが登録されている場合は(進行中のプロジェクトに新しいユーザが参加する場合など)、状況に応じて、ローカル キャッシュをゼロから生成しなければならないことがあります。この処理には非常に長い時間がかかることがあるため、このようなプロジェクトにはこの処理が 1 回だけ行われるように効率化されました。以降の同期では、ローカル キャッシュとサイトのレジストリの間の差分のみが取得されます。ユーザがプロジェクトを操作する頻度が少なく、セッションの合間に多数のフォルダが作成されている場合は、すべてのデータをキャッシュする間の待ち時間が非常に長くなることがあります。この場合にユーザが使用してきた方法の 1 つは、ローカル キャッシュの最新と見なされるバージョンをユーザのマシンに転送することでした。                    注意: この方法は、プロジェクトに極めて多数のフォルダが作成されている場合に限って必要となります。    この更新プロセスは、コア フック cache_location.py を使用して自動的に実行できます。このフックを使用してキャッシュの場所を設定できますが、場所を変更しなくても、このフックを使用して path_cache.db ファイルの特定のバージョンを一元管理された場所からユーザの既定の場所にコピーして、負担のかかる完全同期を不要にすることができます。一元的に保存されたパス キャッシュを定期的に更新するには、他のユーザのキャッシュから手動でコピーすることができますが、通常はスクリプトを使用して定期的に転送します。                    警告: cache_location.py フックを使用するとキャッシュの場所を設定できますが、すべてのユーザに単一の場所を指定する設定は避けてください。1 つまたは複数のプロセッサがデータベースを同時に編集しようとすると、データベースがロックされることがあります。    ",
    "url": "/396dd133/",
    "relUrl": "/396dd133/"
  },
  "94": {
    "id": "94",
    "title": "パイプライン統合コンポーネント",
    "content": "パイプライン統合コンポーネントここでは、Toolkit プラットフォームのコンポーネントのリファレンス ドキュメントを示します。",
    "url": "/162eaa4b/",
    "relUrl": "/162eaa4b/"
  },
  "95": {
    "id": "95",
    "title": "パイプライン統合",
    "content": "パイプライン統合Flow Production Tracking のパイプライン統合により、アーティストは Flow Production Tracking データを使用できるようになります。一般的なコンテンツ作成ソフトウェア内のカスタマイズ可能な UI を使用すれば、アーティストは自分のタスクに関する情報の表示、ノートの参照や追加、およびチームメンバーとのファイルの共有を設定なしで行うことができます。パイプライン統合は Flow Production Tracking Toolkit プラットフォーム上に構築されます。開発者は Toolkit API を使用して機能を拡張したり、カスタム Toolkit アプリを作成したりできます。このセクションでは、Flow Production Tracking パイプラインの管理作業を開始するときに役立つ学習資料について説明します。パイプラインの設定とプロダクション ファイル システムの管理に関するガイド、基本的な vfx パイプラインの構築に関するチュートリアル、および独自のパイプライン ツールを作成するためのリソースが示されています。",
    "url": "/e058fbea/",
    "relUrl": "/e058fbea/"
  },
  "96": {
    "id": "96",
    "title": "アニメーション パイプラインのチュートリアル",
    "content": "アニメーション パイプラインのチュートリアルこのチュートリアルは、アニメーションや視覚効果用のシンプルで一般的なパイプラインの作成について説明します。このチュートリアルに従うと、外観加工を介してモデリングのアセットをプロダクション シーンに転送するのに必要なすべての処理を提供するパイプラインを作成できます。このパイプラインの対象となるワークフローの大部分は、Flow Production Tracking に組み込まれた統合機能を使用して、設定なしですぐに作業することができます。パイプラインの中の、スタジオがカスタム ソリューションを作成する頻度が高い部分については、このチュートリアルで、Toolkit プラットフォームを使用してアーティスト ワークフローをカスタマイズするプロセスを紹介します。次に、このチュートリアルで作成されるパイプラインの概要を示します。    パイプラインの概要パイプラインの概要分かりやすくするため、使用するデジタル コンテンツ作成(DCC)ソフトウェアは最小構成で Maya と Nuke に限定しています。また、パイプラインの工程で渡されるデータは、Maya ASCII ファイル、Alembic キャッシュ、およびレンダリング イメージ シーケンスに限定されます。                    注: このチュートリアルで使用される単純なパイプラインはプロダクションのテストを受けていません。Flow Production Tracking ベースのパイプラインの作成例としてのみ使用してください。    前提条件      作業用の Flow Production Tracking プロジェクト - このチュートリアルでは、Flow Production Tracking を使用してプロダクション データのトラッキングや管理を行った経験があることが前提となります。        Flow Production Tracking 統合の概要 - Flow Production Tracking には統合機能が付属していて、手動設定が不要な、単純なプロダクション ワークフローがいくつか用意されています。このチュートリアルで説明されている手動設定やカスタマイズについて調べる前に、これらのワークフローの機能や範囲について理解する必要があります。Flow Production Tracking 統合の詳細については、こちらを参照してください。        Maya と Nuke の経験 - このチュートリアルは、Maya および Nuke を使用して単純なパイプラインを作成することを目的としています。Flow Production Tracking の統合機能をカスタマイズするには、これらのパッケージの基本について理解する必要があります。        Python の操作に関する知識 - このチュートリアルでは、Python で記述された「フック」を使用して、Flow Production Tracking 統合の機能を変更する必要があります。        YAML に関する知識 - 作成しているパイプラインの設定のほとんどは、YAML ファイルを変更して処理されます。  その他のリソース      Flow Production Tracking サポート サイト        Flow Production Tracking 統合                  ユーザ ガイド                    管理者ガイド                    開発者用ガイド            プロジェクトの作成とセットアップこのチュートリアルでは、Flow Production Tracking で新しいプロジェクトを作成して、プロダクション開始の準備に合わせて設定する必要があります。ここで、すべての必要な Flow Production Tracking エンティティが所定の場所にあり、正しくリンクされていることを確認します。このチュートリアルの場合、アセット、シーケンス、ショット、およびタスクの各エンティティが必要で、既定で新しいプロジェクトで使用できる必要があります。作成する項目は次のとおりです。      2 つのアセット:                  ティーポット キャラクタ                    テーブル プロップ                  シーケンス 1 つ        作成したシーケンスにリンクしたショット 1 つ        パイプラインの手順ごとのタスク  次に、Flow Production Tracking で設定したプロジェクト エンティティのスクリーンショットを示します。    ティーポットとテーブル アセット    シーケンスにリンクされたショット    タスクソフトウェア ランチャー次に、Maya および Nuke を Flow Production Tracking Toolkit 内で起動できることを確認する必要があります。Desktop で、これらの各パッケージのアイコンをクリックして起動できることを確認します。各パッケージの適切なバージョンが起動していることを確認します。Desktop にアプリケーションが表示されない場合、または予期したバージョンが起動しない場合は、ソフトウェア エンティティを使用して Flow Production Tracking で起動を手動で設定しなければならない可能性があります。    Flow Production Tracking で定義された規定のソフトウェア エンティティソフトウェア エンティティは、プロダクションで使用する DCC パッケージを操作する場合に使用されます。既定では、標準のインストール場所でこれらのパッケージが検索され、Desktop を使用して起動できるようになります。複数のバージョンがインストールされている場合、または標準以外の場所にインストールされている場合は、Flow Production Tracking の対応するソフトウェア エンティティのエントリを更新して、アーティストの起動環境を整理しなければならない可能性があります。ソフトウェア エンティティの詳細と、適切に設定する方法については、『統合管理者ガイド』を参照してください。DCC が予期通りに起動した場合は、次のセクションに進んでください。環境設定環境設定(設定)は、プロジェクトに関するアーティスト ワークフローを定義します。このワークフローでは、アーティストが起動している DCC に含める Flow Production Tracking 統合、プロジェクトのフォルダ構造の定義方法、およびアーティストがデータを共有するときに作成されるファイルやフォルダの命名規則を指定します。既定では、すべての新しいプロジェクトは基本的な Flow Production Tracking 統合を使用するように設定されています。この統合は、多数の既製のソフトウェア パッケージを使用してアーティスト間でファイルを共有するための、基本的なワークフローを提供します。次のセクションでは、プロジェクトのパイプライン環境設定(設定)を引き継いで、スタジオに合わせてカスタマイズする方法の概要を示します。プロジェクトの設定を引き継ぐFlow Production Tracking Toolkit (以下、「Desktop」)を使用して、プロジェクトの設定を引き継ぎます。Desktop 内で右マウス ボタンをクリックするか、または右下のユーザ アイコンをクリックして、ポップアップ メニューを表示します。[高度なプロジェクト設定…] (Advanced project setup…)オプションを選択し、ウィザードに従ってプロジェクトの設定をローカルにインストールします。次の図に、必要な手順を示します。また、『統合管理者ガイド』の「パイプラインの設定を引き継ぐ」に記載されている手順に従うこともできます。    Desktop のポップアップ メニューで[高度なプロジェクト設定] (Advanced project setup…)を選択する    [Flow Production Tracking の既定値] (Flow Production Tracking Default)設定タイプを選択する初めて Flow Production Tracking プロジェクトをセットアップする場合は、プロジェクト データのストレージ場所を定義するためのプロンプトも表示されます。それ以外の場合は、既存の格納場所を選択することができます。    新しいストレージを作成します。    新しいストレージに名前を付けます。このストレージはプロジェクト固有のものではなく、サイト全体で使用されることに注意してください。    使用するオペレーティング システム上でこのストレージにアクセスするパスを設定します。[サイト基本設定] (Site Preferences)の[ファイル管理] (File Management)セクションで、Flow Production Tracking サイトのストレージを表示および編集できます。これらの設定の詳細については、こちらを参照してください。格納場所が選択されたので、その場所にある新しいプロジェクトのディレクトリ名を選択します。    プロジェクト ファイルを配置するフォルダの名前を入力する。このチュートリアルでは中央設定を使用します。[分散設定] (Distributed Setup)オプションは、さまざまなメリットを提供する代替オプションを提供します。これは、高速共有ストレージのないスタジオで役に立つ場合があります。さまざまな設定の長所と短所の詳細については、「Toolkit の管理」のプレゼンテーションを参照してください。サイト全体にわたるストレージとは異なり、この設定はプロジェクトごとに異なるため、ここで選択するディレクトリが設定の保存に直接使用されます。    現在のオペレーティング システムに対して選択した設定パスをメモする。上記の画面で選択したフォルダに設定がインストールされます。このチュートリアルを通して、このフォルダに含まれている設定の内容を調べ、変更します。上記の画面で[セットアップを実行] (Run Setup)をクリックすると、Desktop は設定に必要なすべてのコンポーネントのダウンロードとインストールを開始します。このインストール処理には数分かかる場合があります。完了したら、プロジェクト全体の設定のローカル コピーが作成されます。次の手順では、このローカル コピーを変更します。Desktop インストールのチュートリアルで指定された設定場所は、Flow Production Tracking のプロジェクトの[パイプラインの設定] (Pipeline Configurations)ページに記録されています。    Flow Production Tracking のパイプラインの設定エンティティ次のセクションに備えて、このフォルダの内容を理解しておいてください。設定の構成単純なパイプラインの作成プロセスを開始する前に、パイプライン設定の構成方法とその仕組みについて理解しておく必要があります。次の図に、設定の主な構成要素とその目的を示します。設定とその管理の詳細については、「高度な Toolkit 管理」の記事を参照してください。    プロジェクト スキーマこのチュートリアルで作成する単純なパイプラインでは、既定の設定で提供されるプロジェクト スキーマを使用します。config/core/schema フォルダを参照すると、Toolkit アプリがディスクにファイルを書き込むときに作成される構造を把握できます。プロジェクト ディレクトリ構造の設定方法については、「ファイル システム設定のリファレンス」のドキュメントを参照してください。テンプレートこのチュートリアルでは、既定のパイプラインの設定で定義されたテンプレートも使用します。config/core/templates.yml ファイルを開いて、入出力ファイルをディスク上のパスにマップするためにアプリで使用されるテンプレートを確認できます。テンプレート化システムの詳細については、「ファイル システム設定のリファレンス」のドキュメントを参照してください。フックこのチュートリアルの大部分では、アーティスト ワークフローをカスタマイズするためにアプリのフックを変更します。カスタマイズの詳細を調べる前に、フックの内容、その仕組み、および格納先についての基本を理解する必要があります。管理ドキュメントの「フック」セクションを参照してください。このチュートリアルの手順を進める中で、Toolkit アプリのいずれかで定義されたフックを「引き継ぐ」ように要求されます。アプリのフックを引き継ぐプロセスは簡単です。この操作を行うように要求されるたびに、次に示す手順を実行するだけです。      設定のインストール フォルダ内で、オーバーライドするフックを含むアプリの場所を特定します。このアプリの hooks サブディレクトリを検索して、オーバーライドするフック ファイルの場所を特定します。        設定の上位にある hooks ディレクトリにフックをコピーします(必要に応じて名前を変更します)。      ファイルが設定の hooks フォルダに格納されたら、変更を加えて、コードをカスタマイズすることができます。対応するアプリがこの新しい場所を参照するように設定するには、追加手順が必要です。この手順については、チュートリアルの後半で説明します。パイプラインを作成するこの時点で、パイプラインの作成を開始する準備ができています。Flow Production Tracking にプロジェクトが設定されていて、Desktop を介して Maya および Nuke を起動することや、プロジェクトの設定をコントロールすることができます。また、設定の構造の基本を理解していて、アーティスト ワークフローを具体的に作成する作業を開始することができます。次のセクションでは、パイプラインの各手順について説明します。すぐに使用できる機能を示し、Flow Production Tracking 統合のカスタマイズ プロセスを紹介します。これらのセクションが終了するころには、単純な、機能をすべて備えた、エンドツーエンドのプロダクション パイプラインが作成されています。また、アーティストがプロダクション作業で行う手順についても理解できるでしょう。                    注: このチュートリアルのすべてのコードと設定は、tk-config-default2 レポジトリ の pipeline_tutorial ブランチにあります。ファイルの保管場所や、コードの追加場所などについてのヒントが必要な場合は、このブランチを参照してください。    モデリング ワークフローシンプルなパイプラインの最初の手順はモデリングです。このセクションでは、プロジェクト内でティーポット アセットの最初の繰り返しを作成します。作成した繰り返しは、ディスクのプロジェクトのフォルダ構造内に保存してからパブリッシュします。最初に Flow Production Tracking Toolkit から Maya を起動します。Maya が完全にロードされると、[ファイルを開く] (File Open)ダイアログ ボックスが表示されます。このダイアログ ボックスで、プロジェクト内にある既存の Maya ファイルを参照できます。また、Flow Production Tracking 統合で認識される新しいファイルを作成することができます。[アセット] (Assets)タブを選択して、ティーポットのモデリング タスクにドリル ダウンします。このタスクのアーティスト作業ファイルはまだないため、[+ New File]ボタンをクリックします。    このボタンをクリックすると、新しい空の Maya セッションが作成されて、現在の作業コンテキストがティーポット アセットのモデル タスクに設定されます。                    注: このチュートリアルを使用している場合はいつでも、Maya または Nuke の Flow Production Tracking メニューを介して Flow Production Tracking Panel を起動することができます。このパネルでは、DCC を終了しなくても、プロジェクト データを表示できます。現在の作業コンテキスト、およびこのコンテキスト内の最近のアクティビティが表示されます。フィードバック用のノートをパネルに直接追加することもできます。詳細については、Flow Production Tracking パネルのドキュメントを参照してください。    次に、ティーポットをモデリングするか、提供されたティーポットをダウンロードして読み込みます。    ティーポット モデルに問題がなければ、[ShotGrid] &amp;gt; [ファイルを保存…] (File Save…)メニュー アクションを選択します。このダイアログ ボックスで、ファイルを指定した名前、バージョン、タイプで保存するよう求められます。    このダイアログ ボックスで完全な保存パスを指定するよう求められないことに注意してください。これは、maya_asset_work テンプレートに保存するようにアプリが設定されているためです。このテンプレートは、既定では次のように定義されます。@asset_root/work/maya/{name}.v{version}.{maya_extension}アプリがフル パスを入力するのに必要なのは、トークン化されたフィールド {name}、{version}、および {maya_extension} のみです。テンプレートの @asset_root の部分は、次のように定義されます。assets/{sg_asset_type}/{Asset}/{Step}上記の新しいファイルを作成したときに設定した、現在の作業コンテキストが与えられている場合、ここに示したトークン化されたフィールドは、Toolkit プラットフォームによって自動的に推定できます。また、ダイアログ ボックスの下部に、記述するファイル名およびパスのプレビューが表示されます。プロジェクトの設定を引き継ぐときに定義したプライマリ ストレージおよびプロジェクト フォルダが、テンプレート パスのルートに配置されます。[保存] (Save)ボタンをクリックして、ティーポット モデルを保存します。この時点において重要なのは、アーティストが作業ファイルを開く手順、および保存する手順は、パイプラインのどの段階においても、ここで完了したのと同じ手順になることです。[File Open]および[File Save]ダイアログ ボックスは、Workfiles アプリに含まれています。この「マルチ」アプリは、Flow Production Tracking 統合でサポートされているすべての DCC で実行され、すべてのアーティストに一貫性のあるワークフローを提供します。次の手順では、ティーポットにいくつかの変更を行います。ふたのジオメトリはモデルの残りの部分から独立しているため、後でリギングすることができます。    作業内容に問題がなければ、[ShotGrid] &amp;gt; [ファイルを保存…] (File Save…)メニュー アクションをもう一度実行します。今度は、ダイアログ ボックスの既定のバージョン番号が 2 になります。ファイルのバージョンは自動的に増分するため、アーティストは完了した作業の完全な履歴を維持することができます。[保存] (Save)ボタンをクリックします。    ティーポット モデルをバージョン 2 に保存したら、チュートリアルのこのセクションの最後の手順に進むことができます。ティーポット モデルの準備ができたので、モデルをパブリッシュして、サーフェスの作成やリギングを実行できるようにする必要があります。パブリッシュするには、[ShotGrid] &amp;gt; [パブリッシュ…] (Publish…)メニュー アクションをクリックします。[アプリのパブリッシュ] (Publish App)ダイアログ ボックスが表示されます。    このダイアログ ボックスには、パブリッシュされる内容を表す項目がツリー表示されます。ツリーには、パブリッシュ対象の項目を表すいくつかのエントリと、パブリッシュ操作中に実行されるアクションを表すいくつかのエントリが含まれています。ダイアログ ボックスの左側には、現在の Maya セッションを表す項目が表示されます。その下に、[Flow Production Tracking にパブリッシュ] (Publish to Flow Production Tracking)子アクションが表示されます。[すべてのセッション ジオメトリ] (All Session Geometry)を表す追加項目が、現在のセッションの子項目として表示されます。[Flow Production Tracking にパブリッシュ] (Publish to Flow Production Tracking)子アクションも表示されます。                    注: [すべてのセッション ジオメトリ] (All Session Geometry)項目が表示されない場合は、Maya で Alembic 書き出しプラグインが有効になっていることを確認してください。    ツリーの左側の項目をクリックして、Publish アプリを調べます。操作を行う項目を選択すると、パブリッシュする内容の説明を入力できます。また、右側のカメラ アイコンをクリックして、項目に関連付けられるスクリーンショットを作成することもできます。準備ができたら、右下の[パブリッシュ] (Publish)ボタンをクリックして、現在の作業ファイルとティーポット ジオメトリをパブリッシュします。完了したら、Flow Production Tracking でティーポット アセットを参照し、パブリッシュが正常に完了したことを確認できます。    上の図に、ティーポット モデルを含む、パブリッシュされた Alembic ファイルが示されています。また、Maya セッション ファイルのパブリッシュも示されています。これらのパブリッシュは、パブリッシュ アプリのツリー表示内の項目に対応します。[File Save]ダイアログ ボックスを使用して作成された作業ファイルと同様に、これらの 2 つのパブリッシュの出力パスはテンプレートによって制御されます。次に、これらのテンプレートの内容を示します(アプリに対してこれらのテンプレートが設定される場所については、後で示します)。Maya セッションのパブリッシュ:@asset_root/publish/maya/{name}.v{version}.{maya_extension}このテンプレートは、既定では作業ファイル テンプレートと非常に似ています。唯一の違いは、フォルダが publish であることです。アセットのパブリッシュ:@asset_root/publish/caches/{name}.v{version}.abcこのテンプレートは、Maya セッションのパブリッシュ テンプレートに似ていますが、ファイルは caches フォルダに書き込まれます。[ファイルを保存] (File Save)ダイアログと異なり、パブリッシュするときに、名前、バージョン、またはファイル拡張子の値を指定する必要はありません。これは、パブリッシャーが作業ファイルのパスからこれらの値を取得するように既定で設定されているためです。パブリッシャーは作業テンプレートを介してこれらの値を内部で抽出し、パブリッシュ テンプレートに適用します。この概念は、Toolkit プラットフォームに関して重要であると同時に、パイプライン ステップの出力を別のステップの入力に接続するためにテンプレートをどのように使用するのかという点においても重要です。これについては、以降のセクションで詳細に説明します。ディスクのファイルを参照して、これらが正しい場所に作成されていることを確認します。お疲れ様でした。最初にパブリッシュされたティーポットの繰り返しが正常に作成されました。テーブル プロップのモデリング タスクからテーブルのモデルをパブリッシュする際に、学習した内容を使用できるかどうかを確認します。結果は以下のようになります。    次に、サーフェス作成ワークフローについて説明します。サーフェス作成ワークフローこのセクションでは、モデリング セクションで学習した内容を基に作成します。Loader アプリを使用して、前のセクションで作成したティーポット モデルをロードする方法について学習します。また、ティーポットのシェーダをパブリッシュするために Publish アプリをカスタマイズする方法についても学習します。Desktop から Maya を起動して開始します。前のセクションの作業を行った後も Maya が開いている場合、再起動する必要はありません。Maya が開いたら、[ShotGrid] &amp;gt; [ファイルを開く…] (File Open…)メニュー項目を使用して作業ファイル アプリを開きます。モデリング セクションと同様に、[アセット] (Assets)タブを使用して、ティーポット アセットのタスクにドリル ダウンします。今回は、サーフェス作成タスクを選択して、[+ New File]をクリックします。    ティーポットのサーフェス作成タスクの作業が開始しました。右側のプロダクション コンテキスト内で作業していることを確認する最も簡単な方法は、Flow Production Tracking メニューの最初のエントリを調べることです。    次に、ティーポット モデルを新しいサーフェス作成作業ファイルにロードする必要があります。このためには、Maya の [ShotGrid] &amp;gt; [ロード…] (Load…)メニュー項目を使用して、Loader アプリを起動します。    Loader アプリのレイアウトは作業ファイル アプリと似ていますが、今は作業ファイルを参照して開くのではなく、パブリッシュされたファイルを参照してロードします。[Assets]タブでティーポットのキャラクタを参照して、前のセクションで作成したティーポットのパブリッシュを表示します。Maya シーンおよび Alembic キャッシュ パブリッシュが表示されます。Alembic キャッシュ パブリッシュを選択して、ダイアログ ボックスの右側にその詳細を表示します次に、Alembic キャッシュ パブリッシュの[アクション] (Actions)メニューで、[参照を作成] (Create Reference)項目をクリックします。ローダーは既定で開いたままになるため、追加のアクションを実行できますが、ローダーを閉じて続行することもできます。モデリング タスクからティーポット パブリッシュを示す参照が作成されていることが、Maya に表示されます。    次に、ティーポットに単純なプロシージャ シェーダを追加します。    パイプライン作成時のシェーダ管理は時間がかかり、複雑な作業になる場合があります。これは通常、スタジオに対して非常に固有な作業になります。付属の Maya 統合で、すぐに使用できるシェーダまたはテクスチャ管理が処理されないのは、これが理由です。[ShotGrid] &amp;gt; [ファイルを保存…] (File Save…)メニュー アクションを使用して、現在のセッションを保存してから続行します。カスタム シェーダ パブリッシュこの単純なパイプラインの目的に合わせて、サーフェス作成ステップで Maya シェーダ ネットワークを追加のパブリッシュ項目として書き出すように、Publisher アプリをカスタマイズします。チュートリアルの後半では、下流工程の参照時にシェーダが Alembic ジオメトリ キャッシュに再接続できるスピード重視のソリューションを作成します。                    注: 追加するカスタマイズは、明らかに、非常に単純かつ不安定です。より堅牢なソリューションを作成する場合は、サーフェス キャラクタの代替表現と、テクスチャ マップとして外部イメージを使用するというアセット管理の側面を考慮することになります。この例は、実際のソリューションを作成する際の第一歩として使用してください。                        注: パブリッシャー プラグインの作成方法の詳細については、こちらを参照してください。    Maya コレクタをオーバーライドする最初に、Publish アプリのコレクション ロジックを修正する必要があります。パブリッシャーには、アプリ内でパブリッシュおよび表示する項目を「収集」するためのロジックを定義する、コレクタ フックが設定されています。構成されたアプリの設定は、プロジェクトの環境設定内のこのファイルに含まれています。env/includes/settings/tk-multi-publish2.ymlこのファイルでは、すべてのアーティスト環境内での Publish アプリの使用方法を定義します。ファイルを開き、Maya セクション、特にアセット ステップの設定を検索します。これは、次のようになります。    コレクタの設定は、パブリッシャーの収集ロジックが配置されるフックを定義します。既定では、値は次のようになります。collector: &quot;{self}/collector.py:{engine}/tk-multi-publish2/basic/collector.py&quot;この定義には 2 つのファイルが含まれます。フックの設定に複数のファイルが表示されている場合は、フックが継承されています。最初のファイルには、インストールされた Publish アプリのフック フォルダに対して評価する {self} トークンが含まれています。2 番目のファイルには、現在のエンジン(この場合はインストールされた Maya エンジン)のフック フォルダに対して評価する {engine} トークンが含まれています。要約すると、この値は、Maya 固有のコレクタが Publish アプリのコレクタを継承することを示しています。これは、パブリッシャー設定の一般的なパターンです。Publish アプリのコレクタ フックには、実行中の DCC に関係なく、便利なロジックが含まれているためです。DCC 固有のロジックは、この基本ロジックから継承され、現在のセッションに固有の項目を収集するように拡張されます。                    注: アセットのステップ環境のコレクタ設定のみが変更されているため、ショット ステップなどの他のコンテキストで作業しているアーティストには、修正が認識されません。このようなアーティストは、付属している既定の Maya コレクタを使用し続けます。    「環境設定」セクションでは、フックの引き継ぎ方法について学習しました。カスタマイズ プロセスを開始するには、まず、設定内の Maya エンジンのコレクタ フックを引き継ぎます。    上図に、その方法を示します。まず、プロジェクト設定の hooks フォルダ内にフォルダ構成を作成します。こうすると、後で他の DCC に合わせて同じフックをオーバーライドできるため、コレクタ プラグインに名前空間が提供されます。次に、インストール フォルダから新しいフック フォルダ構造に Maya エンジンのコレクタフックをコピーします。これで、設定内に、次のパスを持つ Maya コレクタのコピーが作成されました。config/hooks/tk-multi-publish2/maya/collector.py次に、新しいフックの場所を指すように、publish2 設定ファイルを更新します。現在のコレクタ設定には、次の値が含まれています。collector: &quot;{self}/collector.py:{config}/tk-multi-publish2/maya/collector.py&quot;{config} トークンをメモします。このパスは、プロジェクト設定内のフック フォルダに解決されるようになっています。コレクタの新しいコピーは、アプリ自体によって定義されたコレクタから継承されます。                    注: この時点でパブリッシュする場合、パブリッシュ ロジックは新しい場所から単にコピーおよび参照されているコレクタとまったく同じになります。    お好きな IDE またはテキスト エディタでコレクタのコピーを開いて、process_current_session メソッドの場所を特定する必要があります。このメソッドは、現在の DCC セッション内のパブリッシュ項目をすべて収集します。新しいパブリッシュ タイプが収集されるため、このメソッドの下部に移動して、以下の行を追加します。self._collect_meshes(item)これが、現在のセッションにあるすべてのメッシュを収集する際に追加する、新しいメソッドです。このメソッドは、(後で作成される)シェーダ パブリック プラグインが作用するメッシュ項目を作成します。渡される項目は、メッシュ項目の親となるセッション項目です。                    注: これは、既存のパブリッシュ プラグインを変更するための、対象が非常に限定されたアプローチです。パブリッシャーの構造とその可動部分の詳細については、開発者向けドキュメントを参照してください。    ここでは、ファイルの末尾に、次の新しいメソッド定義を追加します。    def _collect_meshes(self, parent_item):       &quot;&quot;&quot;       Collect mesh definitions and create publish items for them.       :param parent_item: The maya session parent item       &quot;&quot;&quot;       # build a path for the icon to use for each item. the disk       # location refers to the path of this hook file. this means that       # the icon should live one level above the hook in an &quot;icons&quot;       # folder.       icon_path = os.path.join(           self.disk_location,           os.pardir,           &quot;icons&quot;,           &quot;mesh.png&quot;       )       # iterate over all top-level transforms and create mesh items       # for any mesh.       for object in cmds.ls(assemblies=True):           if not cmds.ls(object, dag=True, type=&quot;mesh&quot;):               # ignore non-meshes               continue           # create a new item parented to the supplied session item. We           # define an item type (maya.session.mesh) that will be           # used by an associated shader publish plugin as it searches for           # items to act upon. We also give the item a display type and           # display name (the group name). In the future, other publish           # plugins might attach to these mesh items to publish other things           mesh_item = parent_item.create_item(               &quot;maya.session.mesh&quot;,               &quot;Mesh&quot;,               object           )                     # set the icon for the item           mesh_item.set_icon_from_path(icon_path)           # finally, add information to the mesh item that can be used           # by the publish plugin to identify and export it properly           mesh_item.properties[&quot;object&quot;] = objectコードにはコメントが付いていて、実行される機能を把握できるようになっています。重要なのは、現在のセッション内のいずれかの最上位メッシュに対して、メッシュ項目を収集するためのロジックが追加されたことです。ただし、この時点でパブリッシャーを実行する場合は、項目ツリーにメッシュ項目が表示されません。これは、これらに作用するパブリッシュ プラグインが定義されていないためです。次に、これらのメッシュ項目にアタッチされ、下流工程で使用できるようにこれらのパブリッシュを処理する、新しいシェーダ パブリッシュ プラグインを記述します。                    注: 上記のコードに、メッシュ項目のアイコンを設定するための呼び出しが含まれる可能性があります。このため、指定したパスの設定にアイコンを追加する必要があります。    config/hooks/tk-multi-publish2/icons/mesh.pngシェーダ パブリッシュ プラグインを作成する次の手順では、新たに収集されたメッシュ項目を、メッシュのシェーダをディスクに書き出してパブリッシュできるパブリッシュ プラグインに接続します。そのためには、新しいパブリッシュ プラグインを作成する必要があります。このリンクに従ってこのフックのソース コードを表示し、hooks/tk-multi-publish2/maya フォルダに保存して、publish_shader_network.py という名前を付けます。                    注: このプラグインには、Toolkit プラットフォームおよびパブリッシュ コードを初めて使用する場合に使用するコードが多数含まれています。今のところ、これについて悩む必要はありませんこのチュートリアルの進行状況や、パブリッシャーの機能に対する理解度に応じて行われる操作については、時間をかけて調査し、内容を理解するようにしてください。今は、ファイルを作成し、ファイルの目的が、シェーダ ネットワークのディスクへの書き込みを処理することであることを理解しておきます。    シェーダをパブリッシュできるようになる前の最後のステップでは、新しいシェーダ パブリッシュ プラグインで定義されたテンプレートと設定を追加します。settings プロパティに、このプラグインで定義された設定が表示されます。    @property    def settings(self):       &quot;”” … &quot;””       # inherit the settings from the base publish plugin       plugin_settings = super(MayaShaderPublishPlugin, self).settings or {}       # settings specific to this class       shader_publish_settings = {           &quot;Publish Template&quot;: {               &quot;type&quot;: &quot;template&quot;,               &quot;default&quot;: None,               &quot;description&quot;: &quot;Template path for published shader networks. &quot;                              &quot;Should correspond to a template defined in &quot;                              &quot;templates.yml.&quot;,           }       }       # update the base settings       plugin_settings.update(shader_publish_settings)       return plugin_settingsこのメソッドは、プラグインの設定インタフェースを定義します。シェーダ ネットワークをディスクに書き込む場所をプラグインに指示するには、「パブリッシュ テンプレート」の設定が必要です。パブリッシャーの設定に新しいパブリッシュ プラグインを追加して、テンプレートの設定を含めます。これは、コレクタを引き継ぐ前に修正されたのと同じ設定ブロックです。これは、次のファイルで定義されます。env/includes/settings/tk-multi-publish2.yml設定は次のようになります。    最後に、設定内で新しい maya_shader_network_publish テンプレートを定義する必要があります。このファイルを編集して、次の内容を追加します。config/core/templates.ymlアセット関連の Maya テンプレートが定義されているセクションを見つけて、新しいテンプレート定義を追加します。定義は次のようになります。    これで終了です。シェーダをパブリッシュするメッシュを検索するように、Publish アプリのコレクタ フックが上書きされました。収集されたシェーダ項目にアタッチする新しいパブリッシュ プラグインが実装されました。また、シェーダ ネットワークがディスクに書き込まれる新しいパブリッシュ テンプレートが定義および設定されました。                    注: 設定のカスタマイズ中に Maya を終了しても、問題はありません。単に Maya を再起動し、[ファイルを開く] (File Open)ダイアログ ボックスを使用すれば、サーフェス作成作業ファイルを開くことができます。次の再ロード ステップはスキップできます。    Flow Production Tracking 統合を再ロードするカスタマイズを試すには、Maya セッション内で統合を再ロードする必要があります。このためには、[ShotGrid] &amp;gt; (タスク名) &amp;gt; [作業領域の情報…] (Work Area Info…)メニュー アクションをクリックします。    この操作を行うと、現在のコンテキストに関する情報を示す Work Area Info アプリが起動します。設定を変更しながら統合を再ロードするための便利なボタンもあります。このボタンをクリックして、アプリおよびエンジンを再ロードしてから、ダイアログ ボックスを閉じます。    シェーダ ネットワークをパブリッシュするこれで、プロジェクトの設定を変更した場合の結果を確認できるようになりました。Flow Production Tracking メニューから Publish アプリを起動します。Publish Shaders プラグインがアタッチされている、収集されたティーポット メッシュ項目が表示されます。    作業の説明を入力し、サーフェス ティーポットのサムネイルを取り込んで、パブリッシュされたファイルに関連付けます。最後に、パブリッシュをクリックして、ティーポット シェーダをディスクに書き出して、このファイルをパブリッシュとして Flow Production Tracking に登録します。完了すると、セッションのパブリッシュ プラグインによって、作業ファイルが次に使用可能なバージョンに自動的に保存されます。これが、Flow Production Tracking 統合でサポートされているすべての DCC の既定の動作です。これで、Flow Production Tracking 内のティーポット アセットを参照して、すべてが予測どおりに機能したことを確認できるようになりました。    お疲れ様でした。パイプラインが正常にカスタマイズされ、ティーポットのシェーダがパブリッシュされました。学習した内容を使用して、テーブル プロップのサーフェス作成タスクからシェーダをパブリッシュできるかどうかを確認します。結果は以下のようになります。    次に、リギング ワークフローについて説明します。リギング ワークフロー現在、Flow Production Tracking に付属している Workfile アプリおよび Publish アプリを使用すると、作業ファイルを開く(または作成する)、保存する、パブリッシュする操作を極めて快適に行うことができます。また、上流工程からパブリッシュをロードする Loader アプリを使用する機会もありました。学習した内容を使用して、次のタスクを完了します。      Flow Production Tracking Toolkit から Maya を起動する        ティーポット アセットのリギング ステップで、新しい作業ファイルを作成する        モデリング ステップでティーポット Alembic キャッシュ パブリッシュをロード(参照)する        開け閉めするティーポットのふたをリギングする(単純にする)        ティーポットのふたを保存してパブリッシュする  最終的には、Flow Production Tracking で次のようになります。    次に、アーティストが上流工程の変更をワークフロー内でどのように処理するのかを見てみましょうモデリング作業ファイルを開いて、ティーポット モデルに何らかの変更を加えます。次に、更新された作業をパブリッシュします。結果は次のようになります。    ティーポットのリギング ステップで、作業ファイルを再び開きます([ShotGrid] &amp;gt; [ファイルを開く…] (File Open…]を使用)。[ShotGrid] &amp;gt; [シーンの詳細情報…] (Scene Breakdown…) メニュー アクションを起動します。この操作を行うと、Breakdown アプリが起動し、作業ファイル内で参照した上流工程のパブリッシュがすべて表示されます。この場合は、上流工程のティーポット モデルのみがあります。次のように表示されます。    アプリは参照ごとに、2 つのインジケータのいずれかを表示します。参照されたパブリッシュが最新バージョンであることを示す緑のチェックと、新しいパブリッシュが公開されていることを示す赤の「x」です。この場合は、新しいパブリッシュが公開されていることがわかります。参照されたティーポット Alembic キャッシュ項目を選択して(または下部にある[すべての赤を選択] (Select All Red)ボタンをクリックして)、[選択項目を更新] (Update Selected)をクリックします。Maya 参照がティーポット Alembic キャッシュの最新の繰り返しに更新されます。ファイル内に新しいモデルが含まれているのを確認できるはずです。    新しいモデルについて考慮する必要があるリギング ステップを調整して、変更をパブリッシュします。次のセクションでは、ショットのコンテキスト内で作業します。次に、ショットのレイアウトについて説明します。レイアウト ワークフローこのセクションでは、プロジェクトのために作成したショット内で作業を開始します。以前のセクションで作成したアセットをロードし、ショットを作成します。次に、パブリッシャーを再びカスタマイズし、今回はショット カメラをパブリッシュします。まず、以前のセクションで学習した内容に基づいて、次のタスクを完了します。      Flow Production Tracking Toolkit から Maya を起動する        ショットのレイアウト ステップで新しい作業ファイルを作成する(ヒント: ローダー内の[Shots]タブを使用する)        ティーポットのリギング ステップでティーポットのパブリッシュをロード(参照)する        テーブルのモデル ステップでティーポットのパブリッシュをロード(参照)する  ここで、テーブルに置かれたティーポットを含む、単純なシーンをブロックします。camMain という名前のシーンにカメラを追加して、いくつかのフレームをアニメートし、ショットのカメラ移動を作成します。    ショットのレイアウトに問題がなければ、[ShotGrid] &amp;gt; [ファイルを保存…] (File Save…)メニュー アクションを使用してファイルを保存します。先に進んで、この時点でパブリッシュする場合は、Maya セッション全体のみがパブリッシュ可能な項目として表示されます。簡単なカスタマイズを追加する場合、およびパイプラインの柔軟性を高めるためにカスタマイズする場合は、他のパッケージに簡単に読み込むことができるファイル形式にスタンドアロン カメラをパブリッシュします。これにより、カメラを一度作成すれば(通常はレイアウト内)、アニメーション、ライト、および合成など、他のすべてのパイプラインの手順でこのカメラを直接使用できるようになります。カメラを収集するシェーダのパブリッシュと同様に、最初にコレクタ フックをカスタマイズします。Maya のコレクタ フックをすでに引き継いで、アセット ステップで設定してあります。この設定を、ショットのパイプライン ステップに合わせて更新する必要があります。そのためには、パブリッシャーの設定ファイルを修正し、Maya ショット のステップ コレクタ設定を編集します。    ショットのコンテキスト内でタスクを実行している場合は、カスタム コレクタ ロジックが実行されます。次のステップでは、カスタムのカメラ コレクション ロジックを追加します。カスタム コレクタ フックを開き、サーフェス作成セクションでメッシュを収集するための呼び出しを追加した、process_current_session メソッドの最下部に、次のメソッド呼び出しを追加します。self._collect_cameras(item)次に、ファイルの末尾にメソッド自体を追加します。    def _collect_cameras(self, parent_item):       &quot;&quot;&quot;       Creates items for each camera in the session.       :param parent_item: The maya session parent item       &quot;&quot;&quot;       # build a path for the icon to use for each item. the disk       # location refers to the path of this hook file. this means that       # the icon should live one level above the hook in an &quot;icons&quot;       # folder.       icon_path = os.path.join(           self.disk_location,           os.pardir,           &quot;icons&quot;,           &quot;camera.png&quot;       )       # iterate over each camera and create an item for it       for camera_shape in cmds.ls(cameras=True):           # try to determine the camera display name           try:               camera_name = cmds.listRelatives(camera_shape, parent=True)[0]           except Exception:               # could not determine the name, just use the shape               camera_name = camera_shape           # create a new item parented to the supplied session item. We           # define an item type (maya.session.camera) that will be           # used by an associated camera publish plugin as it searches for           # items to act upon. We also give the item a display type and           # display name. In the future, other publish plugins might attach to           # these camera items to perform other actions           cam_item = parent_item.create_item(               &quot;maya.session.camera&quot;,               &quot;Camera&quot;,               camera_name           )           # set the icon for the item           cam_item.set_icon_from_path(icon_path)           # store the camera name so that any attached plugin knows which           # camera this item represents!           cam_item.properties[&quot;camera_name&quot;] = camera_name           cam_item.properties[&quot;camera_shape&quot;] = camera_shapeここでも、コードにはコメントが付いていて、実行される機能を把握できるようになっています。現在のセッション内のすべてのカメラに対してカメラ項目を収集するロジックを追加しました。ただし、以前と同様に、この時点でパブリッシャーを実行する場合は、項目ツリーにカメラ項目が表示されません。これは、これらに作用するパブリッシュ プラグインが定義されていないためです。次に、これらの項目にアタッチされ、下流工程で使用できるようにこれらのパブリッシュを処理する、カメラ パブリッシュ プラグインを記述します。                    注: 上記のコード内に、カメラ項目のアイコンを設定するための呼び出しが含まれる可能性があります。このため、指定したパスの設定にアイコンを追加する必要があります。    config/hooks/tk-multi-publish2/icons/camera.pngカスタム カメラ パブリッシュ プラグイン次の手順では、新たに収集されたメッシュ項目を、メッシュのシェーダをディスクに書き出してパブリッシュできるパブリッシュ プラグインに接続します。そのためには、新しいパブリッシュ プラグインを作成する必要があります。このリンクに従ってこのフックのソース コードを表示し、hooks/tk-multi-publish2/maya フォルダに保存して、publish_camera.py という名前を付けます。カメラ パブリッシュの設定最後に、ショット ステップで Publish アプリの設定を更新する必要があります。設定ファイルを編集して、新しいプラグインを追加します。env/includes/settings/tk-multi-publish2.yml設定は次のようになります。    新しいプラグインの settings メソッドで定義されているとおりに、ファイルに 2 つの設定が追加されています。シェーダ プラグインと同様に[テンプレートをパブリッシュ] (Publish Template)設定があり、そこでカメラ ファイルが書き込まれる場所を定義できます。カメラの設定は、プラグインが作用するカメラを制御する、カメラに関する文字列のリストのことです。何らかのタイプのカメラ命名規則があり、この設定によって、規則に一致しないカメラのパブリッシュ項目が、ユーザに対して表示されなくなるはずです。上図では、パブリッシュ用の camMain カメラのみが表示されます。cam* などのワイルドカード パターンを使用した場合も、追加したプラグインの実装は機能します。変更をテストする前の最終ステップでは、新しいカメラ パブリッシュ テンプレートの定義を追加します。config/core/templates.yml ファイルを編集し、Maya ショット テンプレートのセクションにテンプレートの定義を追加します。    この時点で、新しいプラグインを使用してカメラをパブリッシュする準備が整っています。Work Area Info アプリを使用して統合を再ロードしてから、パブリッシャーを起動します。    図に示されているように、新しいカメラ項目が収集され、パブリッシュ プラグインがアタッチされます。先に進んで、[パブリッシュ] (Publish)をクリックしてディスクにカメラを書き込み、Flow Production Tracking に登録します。                    注: Alembic 書き出しと同様、カメラのパブリッシュ プラグインでは FBX 書き出しプラグインをロードする必要があります。カメラのパブリッシュ プラグイン項目が表示されない場合は、FBX プラグインがロードされていることを確認し、パブリッシャーを再起動してください。    Flow Production Tracking では次のように表示されます。    これで操作は終了しました。次に、アニメーションについて説明します。アニメーション ワークフローここまでの手順で、Publish アプリのみをカスタマイズすることにより、カスタム ファイル タイプ/コンテンツをディスクに書き込み、他のパイプライン ステップにこれらを共有しました。このセクションでは、Loader アプリの設定をカスタマイズし、ラウンド トリップを完了してカスタム パブリッシュの読み込み/参照を実行できるようにします。以前のセクションで学習した内容に基づいて、次の作業を完了します。      Flow Production Tracking Toolkit から Maya を起動する        ショットのアニメーション ステップで新しい作業ファイルを作成する        ショットのレイアウト ステップで Maya セッションのパブリッシュをロード(参照)する                      注: レイアウト セッションのパブリッシュ ファイルに、このカメラが含まれていました。堅牢なパイプラインでは、カメラを明示的に非表示にするか、またはセッションのパブリッシュから除外して、独立したカメラ パブリッシュ ファイルを実際のカメラ定義の 1 つに設定できるようにします。先に進んで、参照によって含まれているカメラを削除または非表示にします。    カスタム カメラ ローダー アクションカメラのパブリッシュを読み込む/参照するように Loader アプリをカスタマイズするには、アプリの設定ファイルを編集する必要があります。設定内のファイルのパスは、次のようになります。config/env/includes/settings/tk-multi-loader2.ymlMaya のアプリが設定されているセクションを見つけて、action_mappings 設定のアクション リストに次の行を追加します。FBX Camera: [reference, import]カスタム カメラ パブリッシュ プラグインでは、カメラをディスクに書き込む際に Maya の FBXExport mel コマンドを使用しました。Flow Production Tracking にファイルを登録する際に使用したパブリッシュ タイプは FBX Camera でした。設定に追加された行は、ローダーに対して、タイプ FBX Camera の任意のパブリッシュの reference および import アクションを表示するように指示します。これらのアクションは、Loader アプリの tk-maya-actions.py フックで定義されています。これらのアクションは、Maya が参照できる、または読み込むことができる任意のファイル タイプを処理するように実装されています。カスタム プラグインによって生成された .fbx ファイルはこのカテゴリに分類されるため、これが、パブリッシュされたカメラをロードできるようにするために必要な唯一の変更になります。アプリの設定は次のようになります。    ここで、Work Area Info アプリを使用して統合を再ロードし、新しい設定を選択してから、レイアウト内のパブリッシュされたカメラを参照します。    新しいパブリッシュ タイプでフィルタしてから、カメラの参照を作成します。ローダーを閉じると、新たな参照カメラを使用して、前のセクションで作成したカメラの移動を再生できるようになります。次に、何らかの動作を行うようにティーポット モデルをアニメートします(単純なものにしてください)。    アニメーションがうまく作成されたら、以前のセクションと同じように作業ファイルを保存してパブリッシュします。次に、照明について説明します。照明ワークフローこのセクションでは、以前のセクションでパブリッシュしたすべてのものを組み合わせて、ショットをレンダリングします。このためには、ティーポット アセットのサーフェス作成ステップでパブリッシュ済みのシェーダをロードするように Loader アプリをカスタマイズします。最初に、以前のセクションで学習した内容に基づいて、次の作業を完了します。      Flow Production Tracking Toolkit から Maya を起動する        ショットの照明ステップで新しい作業ファイルを作成する        ショットの照明ステップで Maya セッションのパブリッシュをロード(参照)する        ショットのレイアウト ステップでカメラ パブリッシュをロード(参照)する  カスタム シェーダのローダー アクションサーフェス作成手順でパブリッシュしたシェーダをロードするには、前のセクションで説明した tk-maya-actions.py フックを引き継ぐ必要があります。インストール場所から設定にこのフックをコピーします。    このフックは、指定されたパブリッシュに対して実行できるアクションのリストを生成します。Loader アプリは、付属の統合でサポートされている DCC ごとに、このフックの異なるバージョンを定義します。サーフェス作成ワークフロー セクションでパブリッシュされたシェーダは単なる Maya ファイルであるため、書き出されたカメラと同様に、既存のロジックを変更しなくても、ローダーから参照することができます。必要な変更は、シェーダをファイル内で参照した後に、シェーダを適切なメッシュに接続するための新しいロジックをアクション フックに追加することだけです。アクション フックの末尾(このクラスの外部)に次のメソッドを追加します。    def _hookup_shaders(reference_node):       &quot;&quot;&quot;       Reconnects published shaders to the corresponding mesh.       :return:       &quot;&quot;&quot;       # find all shader hookup script nodes and extract the mesh object info       hookup_prefix = &quot;SHADER_HOOKUP_&quot;       shader_hookups = {}       for node in cmds.ls(type=&quot;script&quot;):           node_parts = node.split(&quot;:&quot;)           node_base = node_parts[-1]           node_namespace = &quot;:&quot;.join(node_parts[:-1])           if not node_base.startswith(hookup_prefix):               continue           obj_pattern = node_base.replace(hookup_prefix, &quot;&quot;) + &quot; d*&quot;           obj_pattern = &quot;^&quot; + obj_pattern + &quot;$&quot;           shader = cmds.scriptNode(node, query=True, beforeScript=True)           shader_hookups[obj_pattern] = node_namespace + &quot;:&quot; + shader       # if the object name matches an object in the file, connect the shaders       for node in (cmds.ls(references=True, transforms=True) or []):           for (obj_pattern, shader) in shader_hookups.iteritems():               # get rid of namespacing               node_base = node.split(&quot;:&quot;)[-1]               if re.match(obj_pattern, node_base, re.IGNORECASE):                   # assign the shader to the object                   cmds.select(node, replace=True)                   cmds.hyperShade(assign=shader)ここで、_create_reference メソッドの末尾に次の 2 行を追加して、シェーダ フック ロジックを呼び出します。    reference_node = cmds.referenceQuery(path, referenceNode=True)    _hookup_shaders(reference_node)&amp;lt;/td&amp;gt;新しい参照が作成されると、必ずこのコードが実行されるため、ファイル内にシェーダが既に存在する場合に新しいジオメトリを参照すると、シェーダが割り当てられます。同様に、ジオメトリが既に存在するときにシェーダを参照した場合も、このコードが機能します。                    注: このフック ロジックは非常に力任せであるため、プロダクション対応パイプラインを実装するときに考慮する必要がある名前空間やその他の Maya 関連の微妙な動作は、適切に処理されません。    最後に、次のファイルを編集して、ショットのローダー設定が新しいフックを指すようにします。config/env/includes/settings/tk-multi-loader2.ymlそれと同時に、Maya シェーダ ネットワーク パブリッシュ タイプと参照アクションを関連付けます。ローダーの設定は次のようになります。    ここで、Work Area Info アプリを使用して統合を再ロードし、新しい設定を選択してから、サーフェス内のパブリッシュされたシェーダを参照します。ティーポット シェーダ ネットワーク パブリッシュに対する参照を作成します。    ここで、テーブル シェーダ ネットワークをロードします。Maya でハードウェア テクスチャリングが有効になっている場合は、アニメーション ステップ中にシェーダがメッシュ参照に自動的に接続されているはずです。    ここで、シーンにライトをいくつか追加します(単純なものにしてください)。    Maya レンダーをパブリッシュするショットをディスクにレンダリングします。                        注: ご覧のとおり、ティーポットとテーブル アセットのサーフェスには共に問題があります。このチュートリアルでは、これらが意図的かつ芸術的な選択肢であると想定します。これらの問題を解決する場合は、これらのアセットのサーフェス作成作業ファイルをロードして、シェーダを調整し、再びパブリッシュしてください。この操作を行う場合は、照明作業ファイル内の参照を忘れずに更新して、再度レンダリングしてください。これらの手順を実行する場合は、参照を再ロードした後に、詳細情報アプリが更新済みのシェーダを再接続しないことがあります。シェーダの参照をフックするようローダーを変更した経験に基づいて、ユーザは詳細情報アプリのシーン操作フックを更新し、必要なロジックを追加できるようになっています。このファイルの update メソッドを参照してください。    付属の Flow Production Tracking 統合は、ファイル内で定義されたレンダリング レイヤを調べて、イメージ シーケンスを収集します。レンダリングが完了したら、パブリッシャーを起動します。レンダリングされたシーケンスがツリー内の項目として表示されます。    先に進んで、セッションおよびレンダリングされたイメージ ファイル シーケンスをパブリッシュします。Flow Production Tracking では次のように表示されます。    次に、コンポジットについて説明します。コンポジット ワークフローチュートリアルのこの最終セクションでは、Nuke が提供する既定の統合をいくつか紹介します。以前のセクションで参照したアプリの他に、Flow Production Tracking 対応書き込みノードや、レビューのためにレンダーを他のユーザにすばやく送信するためのアプリについて学習します。最初に、次に示す手順を行って作業ファイルを準備します。      Flow Production Tracking Toolkit から Nuke を起動する        Maya と同様に、[ShotGrid] &amp;gt; [File Open]メニュー アクションを使用して、ショットのコンポジット ステップ内で新しい作業ファイルを作成します。  Loader アプリを使用して前のセクションでレンダリングおよびパブリッシュしたイメージ シーケンスをロードします。    Image および Rendered Image パブリッシュ タイプに対して定義されているアクションは、ノードの作成と読み取りです(タイプはファイル拡張子によって異なります)。このアクションをクリックして、Nuke セッション内で新しい Read ノードを作成します。Nuke プロジェクト設定の出力フォーマットが、レンダリングされたイメージと一致することを確認します。バックグラウンドとして使用する一定のカラーを作成して、読み取りノードと結合します。ビューアをアタッチしてコンポジットを表示します。    コンポジットに問題がなければ、[ShotGrid] &amp;gt; [ファイルを保存…] (File Save…)メニュー アクションを使用して、作業ファイルを保存します。次に、Nuke の左側メニューで Flow Production Tracking のロゴをクリックします。このメニューの Flow Production Tracking 対応書き込みノードの 1 つをクリックします。    Flow Production Tracking Write Node アプリは、現在の Flow Production Tracking のコンテキストに基づいて出力パスを自動的に評価する組み込みの Nuke 書き込みノードの上に、レイヤを配置します。    ディスクにイメージ フレームをレンダリングします。Nuke セッションをパブリッシュして、レンダリングされたイメージに作業ファイルを関連付けられるようになりました。既定では、パブリッシャーはレンダリングされたフレームを収集し、Flow Production Tracking にフレームを登録するプラグインをアタッチします。2 番目のプラグインは、レビュー提出と呼ばれる、バックグラウンドで実行される統合方法を使用して、フレームをアップロードします。このアプリは Nuke を使用して QuickTime を生成します。生成された QuickTime は、アップロードしたり、レビューしたりできます。    もう 1 つの便利な統合は、Quick Review アプリです。これは、QuickTime をすばやく生成して、レビューのために Flow Production Tracking にアップロードする出力ノードです。このアプリは、左側メニュー内の、Flow Production Tracking 書き込みノードの横にあります。    Quick Review ノードを作成してから、[Upload]ボタンをクリックして、ディスクへの入力のレンダリング、QuickTime の生成、レビューのための Flow Production Tracking への結果のアップロードを行います。フレームを提出する前に、いくつかの標準オプションが表示されます。    Flow Production Tracking の[メディア] (Media)タブを調べて、アップロードされた QuickTime を両方とも確認します。    Flow Production Tracking のメディアのレビューの詳細については、公式ドキュメントを参照してください。まとめおめでとうございます。これで完了です。このチュートリアルが、Flow Production Tracking 統合を使用して独自のカスタム パイプラインを作成する際の第一歩になるはずです。スタジオ固有のニーズに合わせて既定の統合を拡張する方法について理解できたことでしょう。質問したり、他のスタジオが Toolkit をどう使用しているかについて学習するには、shotgun-dev Google グループを使用してください。常に最新の投稿を読むことができるよう、サブスクライプすることをお勧めします。既定の統合では実現できない機能やワークフローがあると感じた場合は、独自のアプリをいつでも作成できます。最初のアプリの作成を開始する際に役立つ優れたドキュメントを次に示します。このチュートリアル、ShotGrid、または Toolkit プラットフォーム全般に関してさらに質問がある場合は、コミュニティに連絡してください。",
    "url": "/cb8926fc/",
    "relUrl": "/cb8926fc/"
  },
  "97": {
    "id": "97",
    "title": "Planning Your Setup",
    "content": "Planning Your SetupPick your optionsPick which features you want to activate  Media Isolation  Media Traffic Isolation  Media ReplicationAWS Account CreationBefore going further, you will require an AWS Account. If you don’t already have an AWS Account, create your AWS Account.Choose an AWS RegionChoose an AWS Region for your AWS S3 bucket and VPC. Which region to use? You should chose the a region that is the closest possible to your studio.If your company is located in different locations, consider enabling the media replication feature to reduce latency and improve performancePlan the VPC IP rangesPlan your AWS VPC and subnets IP ranges if you plan to use Media Traffic Isolation.IP Range Example            Region      VPC      Subnet 1      Subnet 2      Subnet 3                  ap-southeast-2      10.1.0.0/16      10.1.0.0/24      10.1.1.0/24      10.1.2.0/24      Plan how you will privately access your AWS VPCIf you plan to activate any of the Traffic Isolation feature, you will need a way to connect your AWS VPC and your network infrastructure. The main options are:  AWS Direct Connect  Other VPN solutionWe highly recommand you to leverage Direct Connect. Direct Connect guarantees the lowest latency possible to the Flow Production Tracking services, a consistent network experience, and allow you to leverage the optimization AWS is relying on to guarantee an optimal performance across the globe.Next StepWith your plan layed down, you are ready to start implementing the AWS building blocks that will allow you to activate the isolation features.See Media Isolation for activating the Media Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/7897b2e2/",
    "relUrl": "/7897b2e2/"
  },
  "98": {
    "id": "98",
    "title": "Private Link",
    "content": "Private LinkAWS PrivateLink is an AWS service that connects different AWS VPCs without going through the public internet.In conjunction with AWS Direct Connect, PrivateLink helps create a dedicated connection between your studio and Flow Production Tracking’s infrastructure.",
    "url": "/9da985a7/",
    "relUrl": "/9da985a7/"
  },
  "99": {
    "id": "99",
    "title": "urlopen error SSL CERTIFICATE_VERIFY_FAILED certificate verify failed (_ssl.c:726)",
    "content": "[ERROR publish_creation] &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;使用例Houdini 17.5 でデジタル アセット用のツールを開発するためにビルド Toolkit アプリを使用しているときに、パブリッシュ ファイルを登録するフックを実行するとします。スクリプトによって次のコードが実行されます。    args = {        &quot;tk&quot;: self.parent.tank,        &quot;context&quot;: self.parent.engine.context,        &quot;path&quot;: esto['operator'],        &quot;name&quot;: os.path.basename(esto['operator']),        &quot;version_number&quot;: 6,        &quot;published_file_type&quot;: &quot;Library item&quot;,    }    print 'sgtk: ', sgtk.__file__    sg_publish = sgtk.util.register_publish(**args)パブリッシュされたファイルは Flow Production Tracking に正しく登録されていますが、次のエラーが表示されます。---------------------------------------------------------------------------[ERROR publish_creation] &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;Traceback (most recent call last):  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank/util/shotgun/publish_creation.py&quot;, line 308, in register_publish    tk.shotgun.upload_thumbnail(published_file_entity_type, entity.get(&quot;id&quot;), no_thumb)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank_vendor/shotgun_api3/shotgun.py&quot;, line 2173, in upload_thumbnail    field_name=&quot;thumb_image&quot;, **kwargs)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank_vendor/shotgun_api3/shotgun.py&quot;, line 2263, in upload    tag_list, is_thumbnail)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank_vendor/shotgun_api3/shotgun.py&quot;, line 2383, in _upload_to_sg    result = self._send_form(url, params)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank_vendor/shotgun_api3/shotgun.py&quot;, line 3806, in _send_form    resp = opener.open(url, params)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 429, in open    response = self._open(req, data)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 447, in _open    '_open', req)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 407, in _call_chain    result = func(*args)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 1241, in https_open    context=self._context)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 1198, in do_open    raise URLError(err)URLError: &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;Traceback (most recent call last):  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/config/hooks/publish_digital_asset.py&quot;, line 66, in register_publishedfile    description='Alembic nodes.')  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank/log.py&quot;, line 503, in wrapper    response = func(*args, **kwargs)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank/util/shotgun/publish_creation.py&quot;, line 323, in register_publish    entity=entityShotgunPublishError: Unable to complete publishing because of the following error: &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;, although PublishedFile PIGS_libary_tool_hda_asasas_v017.hda (id: 114715) was created.---------------------------------------------------------------------------エラーの原因cacert.pem と、その場所を指す必須の環境変数 SHOTGUN_API_CACERTS が見つかりません。修正方法cacert.pem とその場所を指す環境変数 SHOTGUN_API_CACERTS を追加します。コミュニティの完全なスレッドを参照してください。",
    "url": "/02a75bb2/",
    "relUrl": "/02a75bb2/"
  },
  "100": {
    "id": "100",
    "title": "Python 3 Porting Best Practices",
    "content": "Python 3 Porting Best PracticesWhy the move to Python 3?There are a few compelling reasons to make the leap to Python 3.  Perhaps the most dramatic is the Python 2 end of life, which occurred on January 1, 20201. With the sunsetting of Python 2, all support for Python 2 ceases, meaning that even new security vulnerabilities found in Python 2 will not be addressed.Things to Consider Before StartingWhen considering moving to Python 3, it’s good to look at the requirements and application of your codebase to set expectations.  Obviously, any host applications your code runs in will help drive this decision.  Knowing whether you need to support many different Python interpreter versions and, if so, which ones, will be important information as you decide on the porting process that makes sense for you.Next, take an audit of what libraries your code depends on.  If any of these libraries do not have Python 3 compatible versions, you’ll need to find an alternative library, or fork the library to provide compatibility yourself. Both of these options could potentially be costly decisions and are important to consider early on.  Additionally, even libraries that do offer Python 3 compatible versions may not be drop-in replacements, and some libraries choose to fork for Python 3 support rather than maintain compatibility for both Python 2 and 3 as a single source.  We’ll discuss this in more depth in the “Porting Options” section below.Finally, it’s worth noting that while it is possible to continue to support Python versions older than 2.5 and Python 3 simultaneously2, this will make your life much harder.  Since Python 2.5 is very old and not used in modern DCC versions, this guide will work under the assumption that Python 2.5 and earlier will not be targeted.  If you do need to support older versions of Python, a branching approach as described in the “Porting Options” section below may be your best option.What’s Different in Python 3Python 3 comes with some slight syntax changes, changes to builtin functions, new features, and small behavior changes.  There are many great guides that enumerate these specific changes and provide examples.  Rather than dive into specifics here, the goal of this guide will be to describe the porting process from a higher-level perspective, with a few small deep dives where compatibility may be more complicated than just matching syntax.Porting OptionsFor most of us, porting our code to only support Python 3 is not yet an option.  Many DCCs still require Python 2 support, and this is unlikely to change overnight.  This means that in the real world, it will be a necessity to be able to support both Python 2 and 3.There are two major approaches to supporting Python 2 and 3 simultaneously.  We’ll discuss both of them briefly:BranchingIn this approach, a new Python 3 compatible branch of your code is maintained in parallel with the current (Python 2 compatible) branch.  This has the advantage of letting you write cleaner, easier to read Python 3 code, and allows you to fully leverage new features without needing branching logic to maintain Python 2 support.  It also means that when the time comes to drop support for Python 2, you’ll be left with a cleaner, more modern starting point in your Python 3 branch.  The obvious downside here is that maintaining two branches can be unwieldy and mean more work, especially if the Python 3 and Python 2 code starts to diverge as the Python 3 branch can leverage new features that can significantly change how your code looks (e.g. asyncio.)Cross-CompatibilityIn this approach, a single branch is maintained that uses the subset of syntax and builtins that are compatible with both Python 2 and 3.  This allows for a graceful transition from Python 2 to 3 without maintaining multiple branches of your code.  There are a few popular libraries designed to help with this approach, and it’s a commonly-used solution to the problem of transition from Python 2 to 3.  In addition to the reduced complexity compared to maintaining multiple branches, this approach also means you don’t need to change your code distribution mechanisms or worry about using the correct (Python 2 or 3) version of your code at import time.The two most commonly used libraries for this approach are future and six.futureThe future module is probably the most popular choice for Python 2 + 3 compatibility.  It backports many Python 3 libraries to Python 2, and aims to allow you to move your codebase to a pure Python 3 syntax.  Because it backports modules and works by shadowing builtins, it is slightly more invasive than six.  Given the variety of DCCs and unknown client code in VFX environments, future may be too invasive and in an environment like this may pose a greater risk of causing problems down the road.  For this reason, we will focus on using six instead.sixThe six module does not attempt to backport Python 3 modules, or allow you to write pure Python 3 syntax, but instead unifies renamed modules and changed interfaces inside the six.moves namespace.  This allows you to update imports and use six’s helper functions to write code that is both Python 2 and 3 compatible.Testing and LintingBlackThe porting process requires an examination of the entire python codebase, and introduces a fair amount of noise in the revision control history.  This makes it a good opportunity to take care of any other housekeeping that may have similar impacts.  We took this opportunity to apply black to our code.  This is not strictly necessary or directly related to Python 3 compatibility (unless your code is mixing tabs and spaces3), but given the reasons identified above, we decided this was a good opportunity to modernize our code formatting.TestsTest coverage was incredibly valuable during the porting process since it allowed us to quickly find problems that still needed to be addressed, and verify that large sections of code were working as expected without as much manual intervention.  In many cases, we found it worthwhile to increase test coverage as part of the porting process to ensure that Python 2/3 specific cases (e.g. unicode handling) were being addressed correctly.  This being said, we recognize that in many cases the realities of production mean that test coverage is sparse, and that adding tests to code that has little or no coverage may be too time consuming to be worthwhile as part of a project like adding Python 3 compatibility.  For those in this situation, there may still be some value in using coverage measurement tools and some more basic testing code during the porting process, as these tools can provide fast feedback on what code has been covered and what may still need attention.Porting ProcedureAutomated Porting using modernizepython-modernize is a tool that can be very useful for automatically generating Python 3 compatible code.  modernize usually produces runnable code with minimal human intervention, and because of this can be a great tool to get most of the way to Python 3 compatibility very quickly.  Of course, as an automated tool it does come with the drawbacks one would expect.  It frequently produces less readable and less efficient code (e.g. wrapping all iterables in a list() instantiation.)  In some cases, modernize can even introduce regressions that might be difficult to spot.  There are also some areas where you’ll find modernize is not much help at all, like when dealing with bytes and text.  Since these decisions require a bit more understanding of context, you’ll likely have to spend some time manually addressing the handling of strings in your code even if you do rely on modernize for the bulk of the compatibility work.The alternative to using an automated tool like modernize, of course, is to go through code manually to fix incompatibilities.  This can be tedious, but in our experience generally produces nicer looking code.For our process we went with a hybrid approach, using modernize with a select set of fixers, and doing some of the work manually.  We also broke the process into two stages; first doing a pure syntax compatibility and code formatting pass, and then doing a more manual Python 3 port.  Our process was as follows:In a branch:  Run modernize with the except, numliterals, and print fixers  python-modernize --no-diffs --nobackups -f except -f numliterals -f print -w .  Make sure the resulting code is Python 3 syntax compliant by compiling it with Python 3.  The goal here is not to have your code work in Python 3, but to ensure that the basic formatting and automatable syntax fixes are in place.  If your code does not successfully compile after this step, you’ll need to find the source of the problem and either add additional fixers to the above step, or manually fix the incompatibilities.  Ensure that any changes you make manually at this stage are syntax only and will not change the behavior of the code in Python 2.  python3 -m compileall .  Run black on the resulting codeThis branch should not change any behavior or functionality, and should not introduce regressions, so it is considered safe to merge at this point.  This helps keep the history easier to read, and means that the Python 3 compatibility branch and master will diverge less during the porting process, making for an easier merge once the work is done.In a new branch, the actual Python 3 port can now begin:  Search for method names that may require some work to deal with list/view/iterator differences between Python 2 and 3.  In Python 3 .values(), .items() and .keys() return an iterator or view instead of a list, so in cases where these methods are called the code should be able to handle both iterator and list returns, otherwise the result will need to be cast to a list.  Similarly, the filter() method returned a list in Python 2, but now returns an iterator.  Change calls from dict.iteritems() and dict.itervalues() to dict.items() and dict.values() if the returned collection won’t be too big.  In these cases, the resulting cleaner code at the cost of a slight performance hit in Python 2 is preferable.  In cases where the collection might contain thousands of items or more, use six.iteritems and six.itervalues instead.  If dict.iterkeys() was used, simply replace the code with something like for key in dictionary:, since this will iterate on keys in both Python versions.  Watch out that returning an iterator in Python 3 doesn’t change the semantics of the code however. If a method used to return dict.values(), you’ll need to wrap the call inside list(dict.values()) to ensure the method always returns a list in all versions on Python.  Search for str, basestring, unicode, open, pickle, encode, decode since these will be areas of the code that likely require some attention to handling of bytes and strings.  We used the coercion helper methods provided by six (e.g. ensure_string) where needed.  See the sections on bytes and pickle below.  Unless generating a super long range, xrange can be changed to range for simplicity, otherwise six.range can be used.  After committing the manual changes from above, run a full python-modernize and go through the diff manually.  Many of the resulting changes will be unwanted, as discussed above, however this is a good way to catch potential problems that were overlooked in the manual porting process.  python-modernize --no-diffs --nobackups -f default . -w &amp;amp;&amp;amp; git diff HEAD  Test the resulting code to find the remaining problems.  There are some incompatibilities that don’t have fixers (this is a good resource to look at to get an idea of what those changes entail), and it’s easy to overlook text/binary problems during the port process.We chose to use this process because we believe it allowed us to maintain a standard of more readable, efficient code than would have been automatically generated by using modernize on its own.GotchasBytes WoesPython 3 introduces a strict separation between binary and textual data.  This is a long-called-for addition that most see as an improvement, but for Python 2 + 3 compatible code it adds some headaches.  Since Python 2 does not enforce this separation, and Python 3 introduces new types to do so, code that deals with data and strings will likely need some attention.  For the most part this just means making sure that strings are encoded / decoded properly, for which the six.ensure_binary and six.ensure_text helper functions are invaluable.  See the examples below for common applications of these methods.  In some cases, however, this can be more complicated.  For an example of this, see the pickle section below.# base64.encodestring expects str in Python 2, and bytes in Python 3.# By using six.ensure_binary() we can ensure that the we always# pass it the correct type.base64.encodestring(six.ensure_binary(some_string))# In this example (from tk-multi-publish2), we get a list of files# from a QDropEvent in Pyside.  The  filenames are unicode, however# they're being passed to code that expects str.# In Python 2, this had looked like:if isinstance(category_type, unicode):                    category_type = category_type.encode(&quot;utf-8&quot;)# Using six, we can get the same behavior in Python 2, and ensure# compatibility with Python 3 with:category_type = six.ensure_str(category_type)The pickle PicklePickle in Python 3 returns a bytes object from dumps(), where previously it had returned a str.  Additionally, the output of pickle.dumps() in Python 3 contains  x00 bytes, which cannot be decoded. This is not a  problem if the data is being stored in a file, but if the pickled data is being stored in, for example, an environment variable, this can become problematic.  As a workaround, we found that by forcing pickle to use protocol 0, no 0 bytes were included, and the output is once again decodable.  This comes at the cost of the slightly less efficient and fewer-featured older protocol.# Dumping data to a pickle string:DUMP_KWARGS = {&quot;protocol&quot;: 0}# Force pickle protocol 0, since this is a non-binary pickle protocol.# See https://docs.python.org/2/library/pickle.html#pickle.HIGHEST_PROTOCOL# Decode the result to a str before returning.pickled_data = six.ensure_str(cPickle.dumps(data, **DUMP_KWARGS))# Loading data from a pickle string:LOAD_KWARGS = {&quot;encoding&quot;: &quot;bytes&quot;} if six.PY3 else {}data = cPickle.loads(six.ensure_binary(data), **LOAD_KWARGS)Regex  W flagIn Python 3, regular expression metacharacters match unicode characters where in Python 2 they do not.  To reproduce the previous behavior, Python 3 introduces a new re.ASCII flag, which does not exist in Python 2.  To maintain consistent behavior across Python 2 and 3, we wrapped re functions to include this flag across the board in Python 3.Dictionary OrderPrior to Python 3.7, dictionary order was not guaranteed.  As of Python 3.7, insertion order is preserved in dictionaries[11].  In practice, on Python 2.7 dictionary order was random but deterministic (though this was not guaranteed), on some versions of Python (including some version of Python 3) dictionary order is non-deterministic[10].  While code prior to Python 3.7 should not rely on dictionary key order being deterministic, there were instances where this assumption was made in our unit tests.  These tests broke in Python 3.7, and needed to be updated to ensure that dictionary key order was not relied upon.sys.platformIn Python 3.3+ sys.platform on Linux returns linux, where previously it had returned “linux” appended with the kernel major version (i.e. linux2).  Of course when testing for Linux it is easy enough to check sys.platform.startswith('linux').  We chose to centralize these tests and platform “normalization”, and introduced functions sgtk.util.is_windows(), sgtk.util.is_linux(), sgtk.util.is_macos(), as well as a sgsix.platform constant that contains a normalized platform string that can be used for consistent mapping to platform names across python versions.Notes            https://www.python.org/doc/sunset-python-2/ &amp;#8617;              https://docs.python.org/3/howto/pyporting.html#drop-support-for-python-2-6-and-older &amp;#8617;              https://portingguide.readthedocs.io/en/latest/syntax.html#tabs-and-spaces &amp;#8617;      ",
    "url": "/5583eab1/",
    "relUrl": "/5583eab1/"
  },
  "101": {
    "id": "101",
    "title": "Python API のベスト プラクティス",
    "content": "Python API のベスト プラクティスFlow Production Tracking Python API を使用するときのベスト プラクティスのリストを次に示します。パフォーマンス  スクリプトにとって不要なフィールドを要求しないでください。余分なフィールドを含めると、要求に不要なオーバーヘッドが追加されることがあります。  可能な限り具体的なフィルタを作成してください。可能な場合は、結果が戻ってきた後に API クエリーを解析するのではなく、API クエリーでフィルタすることをお勧めします。  部分一致フィルタよりも完全一致フィルタの方が適切に機能します。たとえば、「contains」よりも「is」の方が適切に動作します。制御とデバッグ  スクリプトごとに個別のキーを使用し、ツールごとに一意のキーとしてください。これは、デバッグでは重要です。  各スクリプトに所有者または管理者が存在すること、および [管理者] (Admin)メニューにある[スクリプト] (Scripts)ページの情報が最新であることを確認します。  API ユーザの読み取り専用権限グループを作成することを検討します。多くのスクリプトには読み取りアクセスのみが必要であるため、これらのグループを作成することで、誤って変更されることを防ぐことができます。  使用中のキーをトラックして、古いスクリプトが削除できるようにします。この操作を簡単にするために、一部のスタジオでは、API ラッパーで監査情報をスクリプト化しています。  エンティティ名とフィールドをチェックしてください。Flow Production Tracking にはフィールドごとに 2 つの名前があります。1 つは UI に使用される表示名(一意とは限らない)で、もう 1 つが API で使用される内部フィールド名です。表示名はいつでも変更することができるため、表示名からフィールド名を確実に予測できるわけではありません。フィールド名を確認するには、[管理者] (Admin)メニューのフィールド オプションに移動するか、https://developer.shotgridsoftware.com/python-api/reference.html?%20read#working-with-the-shotgun-schema で説明されている schema_read(), schema_field_read(), schema_entity_read() methods を使用します。デザイン  特に大きいスタジオでは、API 分離レイヤー(ラッパー)を使用することを検討してください。これにより、Flow Production Tracking API に変更が加えられてもツールに影響はありません。また、API アクセスのコントロール、デバッグの管理、監査のトラックなども実行できます。API 自体の変更は不要です。  最新バージョンの API を使用してください。バグ修正とパフォーマンスの改善が含まれています。  スクリプトが実行される場所に注意してください。スクリプトがレンダリング ファームで実行される場合、1 つの情報を要求するために 1 分間に数千回、Flow Production Tracking を呼び出すため、サイトのパフォーマンスに影響を与えることがあります。このようなケースでは、読み取り専用のキャッシング レイヤを導入し、不必要に繰り返される呼び出しを減らすことを検討してください。  スクリプトのイベント生成をオフにすることができます。これは、後でトラックする必要のないイベントを含む、実行頻度が高いスクリプトで最も役に立ちます。頻繁に実行されるスクリプトの場合、イベント ログが非常に大きくなるため、オフにすることを強くお勧めします。",
    "url": "/09b77cf4/",
    "relUrl": "/09b77cf4/"
  },
  "102": {
    "id": "102",
    "title": "API スクリプトの作成と管理",
    "content": "API スクリプトの作成と管理新しいスクリプトを作成するには、次の手順に従います。  [管理者] (Admin)メニューに移動して、[スクリプト] (Scripts)を選択します。  [+ スクリプト] (+ Scripts)ボタンを使用して新しいスクリプトを作成します。      アプリケーション キーから値を取得します。これを使用して Flow Production Tracking との接続を開始します。          注: API キーはパスワードのように扱われ、一度作成されると、Flow Production Tracking の Web アプリや API で再び表示することはできません。続行する前に、キーをコピーしておきます。        これで、スクリプト キーを使用して Flow Production Tracking に接続できるようになりました。スクリプトを使用して Flow Production Tracking に接続する方法の詳細については、API ドキュメントの「Flow Production Tracking メソッド」を参照してください。  ヒント: 何らかの理由で、スクリプトのアプリケーション キーをリセットする必要がある場合は、その操作を実行する新しい Flow Production Tracking スクリプト エンティティを作成する必要があります。最初に、既存のスクリプトの名前を “[My Script]—OLD” などの名前に変更してから削除します。新しいスクリプトを作成します。Flow Production Tracking で古いスクリプトの名前を変更するのは、各スクリプトに一意の名前が必要であるからです。新しいスクリプトを設定するタイミングスクリプトの処理はログに記録できます。個々のスクリプト キーの使用がきめ細かくなればなるほど、どのスクリプトがデバッグのための変更を行っているかを簡単にトラックできるようになります。個別のスクリプトを使用する方法は、Flow Production Tracking サイトの変更によって影響を受けるスクリプトおよびスクリプト管理者をトラックする際にもお勧めします。",
    "url": "/99105475/",
    "relUrl": "/99105475/"
  },
  "103": {
    "id": "103",
    "title": "Python API",
    "content": "Python APIここでは、Python API のリファレンス ドキュメントを紹介します。",
    "url": "/682204e9/",
    "relUrl": "/682204e9/"
  },
  "104": {
    "id": "104",
    "title": "API の概要",
    "content": "API の概要注: Flow Production Tracking API の詳細については、API ドキュメントを参照してください。Flow Production Tracking Python のアプリケーション プログラミング インタフェース(API)を使用すると、ユーザは独自のツールを Flow Production Tracking に簡単に統合することができます。これにより、自動プロセスの作成、数多くのサード パーティ ソフトウェア パッケージとの統合、スタジオ内の既存のツールとの通信が可能になります。スタジオごとにニーズが大きく異なるため、Flow Production Tracking API は最低限の強力な機能のみを提供し、ビジネス ロジックのほとんどはお客様が決定できます。API は、メディア＆エンターテインメント業界で広く使用される一般的なプログラミング言語である Python を使用して作成されています。Flow Production Tracking Python API は、Flow Production Tracking サイトで無料で使用できます。API は CRUD パターンに従うため、単一のエンティティ タイプに対して作成、読み取り、更新、および削除の操作をスクリプトで実行することができます。多くの操作には、フィルタ、返される列、およびソート結果を定義する機能が含まれています。Python API を使用した環境設定の概要ビデオスクリプト キーAPI を使用して Flow Production Tracking サーバと通信する場合、ユーザの資格情報を提供するか、スクリプト キーを使用して、スクリプトをサーバで認証できます。新しいスクリプト キーは、[管理者] (Admin)メニューに表示される[スクリプト] (Scripts)ページから生成することができます。ヒント: スクリプトは個別に登録し、それぞれに個別の API キーを設定します。これにより、各スクリプトとスクリプトで実行される操作をイベント ログよりも正確に監視できます。個人用アクセス トークン(PAT)スクリプト キーに加えて、Flow Production Tracking サイトと通信するために個人用アクセス トークン(PAT)も設定する必要があります。設定方法については、次のビデオ解説を参照してください。  個人用アクセス トークン(PAT)を設定する最初に行う一般的な作業https://github.com/shotgunsoftware/python-api で API をダウンロードします。最初に行う一般的な作業には、以下のようなものがあります。  バージョンを作成してショットにリンクする。これにより、レビュー用に新しいレンダラの送信を自動化できます。  サムネイルをアップロードする。これにより、サイト上のすべての要素に、手動で追加することなく最新のサムネイルを反映できます。  Flow Production Tracking と SVN などのコード リポジトリを統合する。これにより、Flow Production Tracking を利用してソフトウェア開発のプロジェクトを管理できます。API で実行できない操作  権限ルールへのアクセスまたは変更(セキュリティ上の理由による)  ページ設定の読み取りまたは変更  個々のページまたはウィジェットのフィルタまたはクエリー設定へのアクセス  UI の操作  条件付きフォーマット設定ルールの追加、編集または削除  クエリー フィールドの作成または編集アクション メニュー アイテム(AMI)Flow Production Tracking のインタフェース内から簡単に起動するスクリプトを作成するには、AMI を使用します。これらは、データの行を右クリックして表示するコンテキスト メニューに表示される、カスタマイズ可能なオプションです。クリックするとコンテキスト データ ダンプが Web サーバまたはカスタム ブラウザ プロトコル ハンドラに送信されます。ここでカスタム ビジネス ロジックを実行できます。エンティティごとに異なる AMI を設定することができ、プロジェクトまたは権限グループ別にそれらの項目へのアクセスを制限することができます。イベント トリガ デーモンFlow Production Tracking で(ユーザまたは API スクリプトにより)実行されるあらゆるアクションでイベントが生成されます。イベント デーモンを使用して、イベント ストリームを監視し、定義した条件に基づいて特定の API スクリプトを実行することができます。次に、いくつかの例を示します。  上流工程のタスクのステータスに基づいて、下流工程のタスクのステータスを自動的に変更する  値が変更された場合に関連する cut duration フィールドを再計算する  ショットが特定のステータスに設定されている場合、ファイルのパッケージ化と転送操作を実行する追加情報Flow Production Tracking API に関する詳細については、次の記事を参照してください。  GitHub から Flow Production Tracking API をダウンロードする  Flow Production Tracking API ドキュメント  Flow Production Tracking-dev リスト(公開)  Flow Production Tracking イベント デーモンのサンプル コード  イベント駆動型トリガを書き込む  Flow Production Tracking のスキーマ  API のベスト プラクティス投稿とコラボレーション世界中の人と共有したいと思うような優れたツールを Flow Production Tracking で作成したことはありませんか。それはすばらしいことです。オートデスクには、情報を共有したり、協力し合うことが大好きな開発者向けの、活発な開発者コミュニティがあります。以下のように参加できます。  Flow Production Tracking コミュニティに参加します。  GitHub にコードを投稿します(コードはパイプライン固有のものではなく、十分に立証されたものであり、.txt または .mdk 形式の README が必要です)。  リンクと説明を dev リストに投稿します。開発者コミュニティと Flow Production Tracking の開発者はその投稿をよく調べて、フィードバックを提供したり、良い点は高く評価します。当社は、絶えずお客様が提供するさまざまなツールや統合に感動し、刺激を受けています。ぜひお客様の実力をお見せください。",
    "url": "/b6636515/",
    "relUrl": "/b6636515/"
  },
  "105": {
    "id": "105",
    "title": "API ユーザの権限グループ",
    "content": "API ユーザの権限グループAPI ユーザに対して個別に権限グループを作成し、ユーザと同様に、スクリプトおよびキーにさまざまな権限レベルを設定することができます。API ユーザ ページにアクセスする[管理者] (Admin)メニューに移動し、[権限] (Permissions) &amp;gt; [スクリプト] (Scripts)を選択します。使用方法については、 を参照してください。API ユーザの権限グループを使用する方法初期の API 管理者を超える API 権限グループを作成すると、それらを API スクリプトに使用することができます。  [管理者] (Admin)メニューから、[スクリプト] (Scripts)を選択します。  [権限グループ] (Permission Group)列が表示されるので、適切な権限グループを選択します。例これはどのような目的で使用したら良いでしょうか。さまざまな用途が考えられますが、以下に 2 つの用途を示します。例 1: 完全な管理者権限を持たないスタジオ内のユーザに API キーを与える。例 2: 一方向の同期( データベースから該当ユーザの  データベースへ)を実行するための読み取り専用 API キーをパートナー スタジオに与え、制限されたエンティティ セットのみ公開する。例 3: プロジェクトごとに API スクリプトを制限する。  [管理者] (Admin)メニューから[権限 - スクリプト] (Permissions - Scripts)ページに移動し、新しいロールを作成します。 [割り当てられたプロジェクトのみを表示] (See Assigned Projects Only)の詳細権限が有効になっていることを確認します。また、その他の必要な権限を微調整することもできます(たとえば特定のエンティティ/フィールドに対する読み取りアクセス権のみを付与する場合など)。  [管理者] (Admin)メニューから[スクリプト] (Scripts)ページに移動します。[プロジェクト] (Projects)フィールドを公開します。ここで、スクリプトの範囲を制限するプロジェクトを入力することができます。  [権限グループ] (Permission Group)フィールドを使用して、手順 1 で作成した新しいスクリプトにスクリプトの権限を割り当てます。",
    "url": "/bbae2ca7/",
    "relUrl": "/bbae2ca7/"
  },
  "106": {
    "id": "106",
    "title": "Flow Production Tracking Toolkit を使用して Toolkit プロジェクトを再セットアップするにはどうすればいいですか?",
    "content": "Flow Production Tracking Toolkit を使用して Toolkit プロジェクトを再セットアップするにはどうすればいいですか?既にプロジェクト用に Toolkit 構成をセットアップしていて、最初からやり直す必要がある場合、以前のセットアップ構成を削除しない限り Flow Production Tracking Toolkit の詳細セットアップ ウィザードでプロジェクトを再セットアップすることはできません。これらの設定を手動で削除する手順は次のとおりです。  Flow Production Tracking でプロジェクトにリンクされているすべての PipelineConfiguration エンティティを削除します。  Flow Production Tracking の Project エンティティの Tank Name フィールドを空白の値に設定します。  ディスク上で対応するパイプライン設定ディレクトリをすべて削除します。  Flow Production Tracking Toolkit で、セットアップするプロジェクトを選択します。既にプロジェクトを表示していた場合は、プロジェクト リスト ビューに移動してから、もう一度プロジェクトに戻ります。  これでプロジェクト セットアップ プロセスを再び実行できます。別の方法コマンド ラインで tank setup_project コマンドを使用してプロジェクトをセットアップすることに慣れている場合は、コマンドの最後に --force 引数を追加します。これにより、上記の手動での手順に従わずに、以前にセットアップしたプロジェクトをセットアップできます。tank setup_project --force&quot;",
    "url": "/fb5544b1/",
    "relUrl": "/fb5544b1/"
  },
  "107": {
    "id": "107",
    "title": "Client Responsibilities",
    "content": "Client ResponsibilitiesBelow, we have outlined setup responsibilities between Autodesk and You.Isolation SetupYou are entirely responsible for the validity, security, and execution of the Isolation setup in Your AWS Account. Autodesk should not, under any circumstances, be granted access to Your AWS environment.Autodesk is available during the process for assistance, but the configuration of Isolation features in Your AWS Account is to be executed by You on Your own.Isolation feature set activation requires the Flow Production Tracking Support team’s intervention. Activation delays are to be expected and will depend on demand. You understand that an estimated period of 2-8 weeks is usually required to complete the setup necessary to implement the isolation feature set. The setup time is highly dependent on your cooperation, so please plan to dedicate resources for the setup before beginning the onboarding process.Autodesk does not guarantee any timeline for setup completion.Onboarding            Type      Description / Agreement      Responsibility      Available for Assistance                  AWS Knowledge      Acquiring the AWS-specific knowledge required to set up the isolation features.      You      N/A              S3      Setting up the S3 Bucket that will host Your media Securing access to the S3 Bucket. Additional high-availability measures (versioning, bucket replication, etc.)      You      Flow Production Tracking and *AWS              Closed VPC      Setting up DirectConnect/VPN, etc. to allow closed access to the VPC. Securing the VPC by putting the correct Security Groups in place.      You      *AWS              Media Isolation      Creating the S3 end-points. Deploying the S3 Proxy.      You      Flow Production Tracking and *AWS              Traffic Isolation      Creating VPCs. Creating Subnets.      You      Flow Production Tracking              Monitoring and Reliability      Maintaining uptime up to Autodesk standards. High availability and redundancy of Cloud Services. Metadata and database resiliency and redundancy. Maintaining Recovery Point Objective (RPO) for metadata and database.      Flow Production Tracking      N/A              Service Level Objective      Maintaining Flow Production Tracking target RPO and RTO (See Flow Production Tracking Security White Paper for more details).      Flow Production Tracking      N/A              Security and Governance      Maintaining the Flow Production Tracking Cloud Services that Isolation clients are interfacing with, so that they are meeting expectations in terms of security, vulnerability patching, scanning, auditing, etc. (See Flow Production Tracking Security White Paper for more details).      Flow Production Tracking      N/A      *You are solely responsible to seek or obtain any support services AWS may provide under any existing relationship between You and AWS. Autodesk teams are not parties to Your relationship with AWS and therefore not responsible or liable for any services or lack thereof provided by AWS to You.",
    "url": "/2f59bc69/",
    "relUrl": "/2f59bc69/"
  },
  "108": {
    "id": "108",
    "title": "Exception Review submission failed. Could not render and submit the review associated sequence.",
    "content": "Exception: Review submission failed. Could not render and submit the review associated sequence.使用例:Nuke の「Submit for publish」が機能していません、質問 1:上流に移動するにはどうしたらよいですか?「HookBaseClass」までは到達しますが、そこから進めません。現在、Nuke で作業内容をレビューするために送信すると、問題が発生します。Nuke の SG パブリッシュ GUI で次のエラーが発生します。Traceback (most recent call last):  File &quot;C: Users STEVE AppData Roaming Shotgun bundle_cache app_store tk-multi-publish2 v2.4.1 python tk_multi_publish2 api plugins publish_plugin_instance.py&quot;, line 282, in _handle_plugin_error    yield  File &quot;C: Users STEVE AppData Roaming Shotgun bundle_cache app_store tk-multi-publish2 v2.4.1 python tk_multi_publish2 api plugins publish_plugin_instance.py&quot;, line 198, in run_publish    self._hook_instance.publish(settings, item)  File &quot;C: Users STEVE AppData Roaming Shotgun bundle_cache app_store tk-nuke v0.12.5 hooks tk-multi-publish2 basic submit_for_review.py&quot;, line 272, in publish    raise Exception(&quot;Review submission failed. Could not render and &quot;Exception: Review submission failed. Could not render and submit the review associated sequence.また、次の例外も発生します。'sg_publish_data' was not found in the item's properties. Review Submission for 'path/to/sequences/AB/AB_001/comp/work/images/AB_001_comp_v002_output/AB_001_comp_v002_output.%04d.jpg' failed. This property must be set by a publish plugin that has run before this one.そのため、「publish_plugin_instance.py」内で以下を検索しています。_handle_plugin_error    yieldrun_publish    self._hook_instance.publish(settings, item)これらはローカルの Appdata フォルダ内にありますが、メイン インストールには含まれていません。そのため、この問題を解決するには、「submit_for_review.py」を参照する必要があると想定しています。このファイルを参照すると、「HookBaseClass」の上流にある項目の設定と情報を使用していることが分かります。「submit_for_review.py」内で「sg_publish_data」の設定場所を探すと、行 225 が見つかります。sg_publish_data = item.properties.get(&quot;sg_publish_data&quot;)質問 2「item.properties」は上流のどこで設定されていますか?Nuke collector.py に含まれている可能性がありますが、「sg_publish_data」はそこにはなく、「HookBaseClass」の子にもなっています。修正方法簡潔な回答:カスタム コードの追加や設定の大幅な変更を行わなかった場合は、レビュー用に送信している項目の Publish to Flow Production Tracking がオンになっていることを確認する必要があります詳細な回答:まず、パブリッシャー API のドキュメントについては、こちらを参照してください。この問題の解決に関連する概念のほとんどは、ここに記載されています。ただし、特定の問題については、ここで詳細に説明します。このような状況を経験することで、今後の問題のデバッグに役立てることもできます。上記スクリーンショットの ShorgunWrite1 項目の下に 2 つの plugins が表示されています。これらは、設定で定義されたプラグインに対応しています。これらのプラグインは順番に実行され、メモリ内の同じ項目に作用します。問題を見極めるには、これら 2 つのプラグインのコードを調べる必要があります。hook の設定を確認して、これらが有効な場所を特定することができます。最初のプラグインで確認しているのは tk-multi-publish2 の設定であるため、{self} は tk-multi-publish2 を表します。そのため、{self}/publish_file.pyは、tk-multi-publish2 アプリ フォルダ内にあります。ファイル システム上のアプリの場所は、app_locations.yml の設定方法によって異なりますが、何も変更していない場合は、バンドル キャッシュ フォルダ内にあります。必要に応じて、キャッシュの場所の確認方法を参照してください。2 番目のプラグインのフック パスは次のとおりです{engine}/tk-multi-publish2/basic/submit_for_review.pyNuke では tk-nuke エンジンを実行しているため、このパブリッシュ フックを見つけるには、tk-nuke でバンドル キャッシュの内容を調べる必要があります。コードの場所が分かったので、この場所を調べると、1 番目のプラグインには、2 番目のプラグインで使用されると予測される値が設定されていることが分かります。これら 2 つのプラグインを組み合わせるということは、パブリッシュされた(変更されない)内容をレビューするために送信するということです。そのため、ワークフローでは、まずソース ファイルをパブリッシュし、そこからレビューのための SG バージョンを作成します。このバージョンはパブリッシュにもリンクされます。1 番目のプラグインはファイルのパブリッシュを実行し、2 番目のパブリッシュで使用する項目に情報を格納します。継承についての指摘があったので、この点を明確にする必要がありました。このドキュメントで説明する内容は、設定によって制御されるフック継承に関するものです。ユーザにとって意味があると思われる Python 継承に関するものではありません。Python ファイルを参照すると、すべてのフックが HookBaseClass から継承されていることが分かります。ただし、設定のフック メカニズムを使用すると、基本的にこれらのベース フックを混合可能な要素と見なして結合し、コードを再利用するときに必要なすべての機能を取得することができます。tk-multi-publish2 設定で、この例を確認することができます。settings.tk-multi-publish2.nuke.shot_step:  collector: &quot;{self}/collector.py:{engine}/tk-multi-publish2/basic/collector.py&quot;ここで定義されたコレクタは、どの Python ファイルにも存在しません。このコレクタは、実際には tk-multi-publish2 の collector.py と tk-nuke の collector.py を組み合わせたものです。クイック修正で十分に対応できず、これらのフックを修正する必要がある場合は、「パブリッシュ ワークフローのカスタマイズ」のビデオを参照してください。作業を開始するには、このビデオを見るのが最適です。コミュニティの完全なスレッドを参照してください。",
    "url": "/1d15d7ad/",
    "relUrl": "/1d15d7ad/"
  },
  "109": {
    "id": "109",
    "title": "レビュー",
    "content": "レビューRV を最大限に活用する方法について説明します。RV とは、受賞歴のある一連のデジタル レビュー ツールのことで、コラボレーション ツールや多数の高度な統合機能を使用してデジタル メディアの再生、比較、変換を行うことができます。ノード グラフ、カスタム シェーダ、イベント処理、およびネットワークの詳細については、RV のリファレンス マニュアルを参照してください。NVIDIA SDI ビデオ デバイスをプレゼンテーション モード デバイスとして実装する方法については、RV-SDI マニュアルを参照してください。Maya および Nuke、さらには Flow Production Tracking 自身とのシームレスなワークフローについては、統合パッケージをご覧ください。",
    "url": "/61e62b21/",
    "relUrl": "/61e62b21/"
  },
  "110": {
    "id": "110",
    "title": "Could not resolve row id for path!",
    "content": "Could not resolve row id for path!関連するエラーメッセージ:  Could not resolve row id for path!  Database concurrency problems: The path &amp;lt;PATH&amp;gt; is already associated with Flow Production Tracking entity &amp;lt;ENTITY&amp;gt;.サンプルToolkit ユーザがフォルダを生成すると、「Could not resolve row id for path!」というエラーが表示されます。FileSystemLocation エンティティが作成されますが、場合によっては重複することがあり、その結果、多数の問題が発生する可能性があります。完全なエラーは次のようになります。Creating folders, stand by...ERROR: Could not resolve row id for path! Please contact support! trying toresolve path '  server nas_production CLICK 00_CG scenes Animation 01 001'.Source data set: [{'path_cache_row_id': 8711, 'path':'    server  NAS_Production  CLICK  00_CG  scenes  Animation  01  001','metadata': {'type': 'ShotGrid_entity', 'name': 'sg_scenenum', 'filters':[{'path': 'sg_sequence', 'values': ['$sequence'], 'relation': 'is'}],'entity_type': 'Shot'}, 'primary': True, 'entity': {'type': 'Shot', 'id':1571, 'name': '001_01_001'}}, {'path_cache_row_id': 8712, 'path':'    server  NAS_Production  CLICK  00_CG  scenes  Animation  01  001  Fx','metadata': {'type': 'ShotGrid_step', 'name': 'short_name'}, 'primary': True,'entity': {'type': 'Step', 'id': 6, 'name': 'FX'}}, {'path_cache_row_id':8713, 'path':'    server  NAS_Production  CLICK  00_CG  scenes  Animation  01  001  Comp',注: エラーはこれより大幅に長くなることがあります。エラーの原因このエラーは、Flow Production Tracking ([サイト基本設定] (Site Preferences) -&amp;gt; [ファイル管理] (File Management))とパイプライン設定の config/core/roots.yml で指定されているストレージ ルート間に不一致があること示しています。Windows を実行しているスタジオでは、大文字と小文字の不一致が原因でこのエラーが発生することがあります。これらのスタジオでパスの大文字と小文字は区別されませんが、オートデスクの設定では大文字と小文字が区別されます。E: Projects と E: projects のような単純な違いによって、このエラーが発生する可能性があります。シーンの背後で実行される動作このコードは、Flow Production Tracking によって作成されたパスに FilesystemLocation エンティティを作成し、Flow Production Tracking のストレージ ルートを使用してパスのルートを決定します。次に、ローカル キャッシュ内に同じエントリを作成し、データベース内の配置場所を決定する必要があります。ローカル キャッシュの場合は、roots.yml を使用してパスのルートを決定します。大文字と小文字が一致しないため、生成されたパスは Flow Production Tracking に入力されたパスと一致しません。この時点で、エラーが発生します。エラーが整然と発生しない場合は、特に不適切な状態になります。フォルダが作成され、FilesystemLocation エントリが作成されても、ローカル パス キャッシュでこれらが同期されることはなく、ストレージ ルートの不一致が原因で同期することもできなくなります。修正方法まず、[サイト基本設定] (Site Preferences)のストレージ ルート パスが config/core/roots.yml のパスと必ず一致するようにします。不一致を修正すると、以降のフォルダ作成呼び出しでエラーが解消されます。次に、不正な FilesystemLocation エンティティをクリアします。エラーのある FilesystemLocation エンティティのセットに絞り込むことができた場合は、これらを削除するだけで済みます。通常はプロジェクトのすべてのパスが損なわれているため、すべてのパスを削除する必要があります。  FilesystemLocation エンティティをクリアする方法: 理想的なのは、tank unregister_folders を実行できることです。これらすべてをクリアするには、tank unregister_folders --all を実行します。(tank unregister_folders のすべてのオプションでは、引数を指定しないで実行するだけで、使用上の注意事項が出力されます。)  ただし、データベースは既に不安定な状態になっているため、この方法が機能しないか、部分的にしか機能しない場合があります。コマンドを実行したら、Flow Production Tracking の FilesystemLocations に戻って、削除予定の内容が実際に削除されていることを確認します。削除されていない場合は、不適切なエンティティを選択し、手動でごみ箱に移動します。この時点で、Flow Production Tracking の FilesystemLocations はクリーンな状態ですが、アーティストのローカル キャッシュには変更が反映されていない可能性があります。最後の手順では、各ユーザのマシンのローカル キャッシュを実際に同期します。この操作を行うには、tank synchronize_folders --full を実行する必要があります。これらの手順をすべて実行すると、パスのキャッシュは適切な状態になり、エラーは表示されなくなります。関連リンク  問題のあるコード  パス キャッシュとは何ですか? ファイルシステムの場所とは何ですか?コミュニティの完全なスレッドを参照してください。",
    "url": "/da6b219a/",
    "relUrl": "/da6b219a/"
  },
  "111": {
    "id": "111",
    "title": "RV 開発の概要",
    "content": "RV 開発の概要RV コア リファレンスユーザ マニュアルユーザ マニュアルには、RV と RVIO の使用を開始するにあたって必要な基本情報、そしてコマンドラインと GUI の使用方法についての詳細が記載されています。また、パフォーマンスを最大化するのに役立つインストール時の注意事項とヒント、および LUT、RV ピクセル パイプライン、立体 3D、パッケージによる RV の拡張、RV とのネットワーク、そして RVLS メディア リスティング ユーティリティに関する詳細な情報が含まれています。  RV ユーザ マニュアル  質問とトラブルシューティングのフォーラムテクニカル リファレンス マニュアルリファレンス マニュアルは、RV をカスタマイズする方法を学ぶための基本情報を提供します。ここには、RV のパッケージ システムと Mu スクリプティング機能の概要が含まれています。ホット キーの変更、メニューの追加、カラー マネジメントのカスタマイズ、新しいウィジェットの作成、RV とパイプラインの統合についての知識が必要であれば、リファレンス マニュアルがその出発点になります。  テクニカル リファレンス マニュアル  RV 拡張フォーラムRV-SDI マニュアルこのマニュアルでは、NVIDIA SDI ビデオ デバイスをプレゼンテーション モード デバイスとして Tweak で実装する方法について説明します。プレゼンテーション モードと、それが RV とどのように関連しているのかについての詳細は、RV ユーザ マニュアルを参照してください。RV-SDI を使用するには、「rv」(または「rv.exe」)実行ファイルを実行します。「rvsdi」ライセンスが必要です。  RV-SDI マニュアルRV の統合RV/Nuke の統合RV に Nuke 統合ツールが付属するようになりました。このドキュメントでは、個別のセットアップまたはシステム全体のセットアップのインストール方法について説明し、RV/Nuke のワークフロー、ツール、概念、および使用法を示します。  RV-Nuke の統合ドキュメントRV/Maya の統合RV に Maya 統合機能が付属するようになりました。このドキュメントでは、RV/Maya パッケージのインストール方法について説明し、RV/Maya ワークフロー、プレイブラストを比較して整理する方法、およびレンダリングして編集、A/B 比較、レイアウトを行う方法を示します。  RV-Maya の統合ドキュメント",
    "url": "/7e1071f0/",
    "relUrl": "/7e1071f0/"
  },
  "112": {
    "id": "112",
    "title": "S3",
    "content": "S3Amazon S3 is an object storage service offered by AWS. It can be thought of as a highly durable storage space in the cloud. Flow Production Tracking uses S3 to store uploaded media and files.In order to use Flow Production Tracking isolation features, you will bring your own S3 bucket and configure Flow Production Tracking to use it for storage. Please refer to our S3 Bucket Setup article for details on how to do this.",
    "url": "/dfc0cc1b/",
    "relUrl": "/dfc0cc1b/"
  },
  "113": {
    "id": "113",
    "title": "Media Isolation",
    "content": "Media Isolation                    Disclaimer: The security of your S3 bucket is solely a client responsibility, and the integrity of your data will be at risk without it. We very strongly recommend securing your S3 bucket properly.    AWS Account CreationYou can quickly create your AWS Account.You should also contact your AWS contacts to get help with your AWS account setup.AWS CloudFormation templateIt’s possible to start from the Private S3 bucket AWS CloudFormation template and customize it for your needs for a faster deployment.                    Disclaimer: This template is provided as an example only. It is your responsibility to validate that running the template will result in the configuration/policy/security settings your studio requires.      Go the CloudFormation service in AWS Console  Select Template is ready  Set Amazon S3 URL to https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-s3-bucket.yml  Next  Set a stack name like Flow Production Tracking-s3-bucket  Set your S3 bucket name and your Flow Production Tracking site name  Next  Accept I acknowledge that AWS CloudFormation might create IAM resources  NextCORS ConfigurationCORS policy on your S3 bucket will be minimally configured, allowing only the required origin (your site) and methods, amongst other things.IAM RoleThe template will create an AWS Role with the following permissions on your bucket:  Allow Flow Production Tracking to access your S3 bucket.  Allow the Flow Production Tracking account to assume the role by setting the role Trust Relationship.Media Isolation ActivationPlease contact Flow Production Tracking support via the dedicated Microsoft Teams channel and provide the following information:  Flow Production Tracking IAM Role ARNFlow Production Tracking will allow your site to use your IAM role.Media Configuration SetupNavigate to your site’s site preferences and under the Isolation section, fill in the S3 Configuration preference with the following JSON:{​​​​​​​   &quot;&amp;lt;S3_CONFIG_NAME&amp;gt;&quot;: {​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​}​​Fields description            Field      Description                  S3_CONFIG_NAME      Unique name for the configuration. This will be selectable as a bucket later on.              BUCKET_REGION      Isolation bucket’s region              BUCKET_NAME      Isolation bucket’s name              BUCKET_PREFIX      The S3 prefix where the media is located on the isolation bucket              ROLE_ARN      AWS Role ARN that Flow Production Tracking can use to access the bucket. This must be the same role specified in the Initial Setup              S3_INTERFACE_VPC_ENDPOINT      Optional - This is only needed if Media Traffic Isolation is utilized.      Testing Media ConfigurationAfter the configuration has been updated on your site, navigate to the /admin/speedtest route of your Flow Production Tracking site. Select the new S3_CONFIG_NAME that was just set up previously and start the test to confirm that all the upload/download tests work as intended.Next StepsSee Media Traffic Isolation to activate the Media Traffic Isolation feature.See Media Replication to activate the Media Replication Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/439f0627/",
    "relUrl": "/439f0627/"
  },
  "114": {
    "id": "114",
    "title": "Media Replication",
    "content": "Media ReplicationDescriptionIt’s possible to add S3 replication between two S3 buckets in different regions and configure Flow Production Tracking to leverage it for faster access to media.Features  Support one replica bucket in another region leveraging the AWS S3 replication featureHow it worksWhen S3 bucket replication is activated, users will be able download media files from the replica S3 bucket.For each user, the S3 replication is activated by the Use S3 Replication field.            Value      Behavior                  no      Never use replica S3 bucket (default)              yes      Use replica S3 bucket when delay is over              auto      Use replica S3 bucket when delay is over and the client IP is in IP Adresses for S3 replication range      The IP Adresses for S3 replication preference can be edited in Site Preferences under the Isolation category.Limitations  Only one replica S3 bucket can be configured  Only downloading from the replica bucket is supported  Configurable delay for new media to be replicated before being made available to usersSetup steps  Create the replica S3 bucket in a new AWS region. See Media Isolation  Update your existing Flow Production Tracking role policy to allow Flow Production Tracking to also access the replica bucket  Setup the replication rules on the primary S3 bucket. See How do I add a replication rule to an S3 bucket?  Setup a VPC + Direct Connect + S3 proxy in the new AWS region if needed. See Media Traffic IsolationConfigure your siteTo configure S3 replication, you will need to add an additional entry to the “S3 Configuration” site preference.The complete entry may look something like the following:{​​​​​​​​   &quot;&amp;lt;S3_CONFIG_NAME&amp;gt;&quot;: {​​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;,     &quot;s3_interface_vpc_endpoint_dns_name&quot;: &quot;&amp;lt;S3_INTERFACE_VPC_ENDPOINT&amp;gt;&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​,   &quot;&amp;lt;S3_CONFIG_NAME_REPLICA&amp;gt;&quot;: {​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION_REPLICA&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME_REPLICA&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX_REPLICA&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;,     &quot;s3_interface_vpc_endpoint_dns_name&quot;: &quot;&amp;lt;S3_INTERFACE_VPC_ENDPOINT_REPLICA&amp;gt;&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​After the configuration has been updated on your site, navigate to the /admin/speedtest route of your Flow Production Tracking site. Select the new S3_CONFIG_NAME_REPLICA and start the test to confirm that all the upload/download tests work as intended.Update the following Site Preferences:  S3 Bucket for Replication - This should have the same value as S3_CONFIG_NAME_REPLICA from the S3 Configuration  S3 Replication Delay - Set this to something reasonable such as 60 seconds.FAQCopy existing mediaS3 replication only applies to media uploaded after the feature has been enabled. Existing media in the primary bucket must be copied to the replica bucket manually. You can simply use aws-cli sync or use Amazon S3 Batch Operations if you have a lot of media to achieve this.Next StepsSee Fine Tuning to finalize your setup and optimize costs and security.Go to Setup for an overview of the possible next steps.",
    "url": "/44623c83/",
    "relUrl": "/44623c83/"
  },
  "115": {
    "id": "115",
    "title": "統合ユーザ ガイド",
    "content": "統合ユーザ ガイド本書の内容:  はじめに  Desktop のスタートアップ          Desktop のインストール                  Desktop の新しいバージョンをインストールする                    セルフ ホスト環境またはプロキシ サーバの背後からログインする                  認証およびブラウザの統合                    システム トレイ      プロジェクト ブラウザ      コマンド ランチャー      コンソール        アプリケーションを起動する  Panel          概要      UI の詳細                  アクティビティ ストリーム          ノートの作成およびノートへの返信          ノート、バージョン、パブリッシュ、およびタスク          情報タブ          検索          アクション          現在の作業領域とホーム領域          現在の作業領域                      Publisher          概要      インタフェースのコンポーネントおよび概念      基本的なワークフロー                  コンテンツ作成ソフトウェア内でパブリッシュする          項目およびタスクをパブリッシュする                          コンテキスト              検証              複数ドキュメントのワークフロー                                スタンドアロン パブリッシュ          パブリッシュ タイプ                          スタンドアロン              3ds Max              Houdini              Maya              Nuke              Nuke Studio              Photoshop CC                                            Loader          概要      ツリー ビュー      ナビゲーション      パブリッシュを見る      1 つまたは複数のパブリッシュをシーンに取り込む      古いパブリッシュを操作する      関連付けられたレビュー        高度な機能  謝辞はじめにFlow Production Tracking の統合により、コンテンツ作成ツールに Flow Production Tracking を組み込むことができます。Flow Production Tracking を統合して使用することにより、ソフトウェアを素早く起動する、パネルを使って Flow Production Tracking に保管されたタスク関連のノートやデータをトラックする、パブリッシャーやローダーを使用してファイルをトラックし、シーンに取り込む、などの操作を行えるようになります。アーティストはタスクに関するすべての Flow Production Tracking データおよびプロジェクトに関するすべてのタスクに、アプリ内からアクセスすることができます。また、ノートへの返信、バージョンの再生、ファイルのパブリッシュ、同僚のパブリッシュ ファイルのロードを行うことができます。Flow Production Tracking 統合の最新の更新については、リリース ノートを参照してください。Desktop のスタートアップこの統合の中心となるのが、Flow Production Tracking Toolkit アプリです。このソフトウェア アプリケーションによって Flow Production Tracking がローカル マシンでも使用できるように拡張され、Flow Production Tracking データにアクセスしたり、アプリケーションを起動したり、自分のマシンからパイプライン統合ツールを直接実行したりといった操作を簡単に行うことができます。従来型ツールキットまたはカスタム設定を実行するFlow Production Tracking の統合は自動的にインストールされます。システムに精通しているクライアントが従来型のツールキット構成をインストールする必要がある場合、または Desktop Setup Wizard を使用してカスタム ツールキット設定をインストールする必要がある場合は、『管理者ガイド』でその方法を確認してください。Desktop のインストールFlow Production Tracking Toolkit は[アプリ] (Apps)メニューからダウンロードできます。プロンプトに従って、Desktop for Mac、Desktop for Windows、または Desktop for Linux のいずれをダウンロードするのかを選択します。Desktop の新しいバージョンをインストールするサポートされているすべてのオペレーティング システムで、現在のバージョンをアンインストールすることなく Flow Production Tracking Toolkit を更新できます。ただし、Flow Production Tracking デスクトップのバージョンを更新する前に、既存のセッションを終了してください。注: Windows の場合、バージョンの更新中に Desktop が実行されていると、バイナリ ロックが干渉してインストーラが停止することがあります。この場合、一部のファイルがすでにコピーされているため、不完全なインストールになります。この問題を解決するには、Desktop を終了して[再試行] (retry)を選択します。セルフ ホスト環境またはプロキシ サーバの背後からログインする注: ここに記載されているログインに関する内容は、セルフ ホスト環境の場合またはプロキシ サーバを使用している場合を想定しています。これは既定の動作ではありません。セルフ ホスト環境の場合またはプロキシ サーバを使用している場合に、Desktop を初めて開くと、証明書に関するプロンプトがブラウザに表示されます。このプロンプトが表示されるのは、Flow Production Tracking と Desktop アプリを接続するためです。証明書の設定に問題がある場合は、Firefox および Chrome およびその他のブラウザのトラブルシューティングのドキュメントを参照してください。セキュリティ証明書のリストは 1 回のみ更新する必要があります。Mac および Windows では証明書を求めるプロンプトが表示されますが、Linux では表示されません。証明書が設定されたら、Flow Production Tracking のサイトにログインする必要があります。プロキシを経由する場合は、追加設定をいくつか行う必要があります。詳細については、『管理者ガイド』を参照してください。認証およびブラウザの統合Desktop には、Flow Production Tracking Web アプリケーションとコンピュータの連携を実現するためのサービスが用意されています。このサービスを使用すると、ローカル ファイル リンクやソフトウェアの起動などの機能を実行できるようになります。セキュリティ上の理由から、ブラウザを使ってログインしたときと同じ Flow Production Tracking サイトに、同じユーザ名で Desktop にログインする必要があります。異なるユーザとしてログインするか、または異なるサイトにログインすると、アカウントを切り替えるように促すプロンプトが表示されます。アカウントを切り替えると、Desktop が再起動して、適切な資格情報を求めるプロンプトが表示されます。システム トレイアプリケーションが起動すると、システム トレイにアイコンとして表示されます。アプリのウィンドウを表示するには、このアイコンをクリックします。既定では、ウィンドウはシステム トレイに固定されるため、フォーカスを失ったウィンドウは自動的に非表示になります。ウィンドウを固定解除するには、ユーザ メニューで「Undock from Menu」を選択するか、ヘッダーをドラッグします。固定解除したウィンドウは通常のウィンドウのようになり、フォーカスを失っても非表示になることはなくなります。ウィンドウがドッキング解除されている場合は、[閉じる]ボタンをクリックして非表示にすることができます。再表示するには、システム トレイ アイコンをクリックします。プロジェクト ブラウザアプリの最初のメイン ビューはプロジェクト ブラウザです。ここに、Flow Production Tracking インスタンス内のすべてのプロジェクトが表示されます。最近アクセスしたプロジェクトが最初に表示されます。ウィンドウの右下付近に Flow Production Tracking アカウントのサムネイルが表示されます。このユーザ メニューからウィンドウのドッキングやドッキング解除を行ったり、他のウィンドウの上に常に表示したり、ログ コンソールを表示したりできます。ウィンドウの上部にある虫めがねアイコンをクリックして、検索ボックスを表示することができます。このボックスに入力すると、プロジェクトのリストがフィルタされて、入力している文字を含むプロジェクトのみが表示されます。プロジェクトをクリックすると、このプロジェクトのコマンド ランチャー ビューが表示され、プロジェクトで使用可能なツールを起動できるようになります。コマンド ランチャープロジェクトを選択すると、そのプロジェクトのコマンド ランチャーが表示されます。このウィンドウには、プロジェクトで使用可能なツールおよびアプリケーションが、ボタンとしてグリッド状に表示されます。ボタンをクリックするだけで、対応するアプリケーションを起動できます。コマンド ランチャーは、プロジェクト固有の環境で実行されます。Flow Production Tracking がコマンド ランチャーと統合されている場合は、使用可能なすべてのツールが Flow Production Tracking のメニューに表示されます。コンソールユーザ メニューからコンソールを起動できます。コンソールには、プロジェクトを起動してからのログが表示されます。エラーが発生した場合は、ここにエラーの詳細が表示されます。コンソールを右クリックすると、標準の編集メニューが表示され、テキスト全体の選択、選択内容のコピー、またはコンソール内のテキストのクリアを行うことができます。アプリケーションを起動するFlow Production Tracking Toolkit を起動してプロジェクトを選択すると、標準のアプリケーション フォルダ内でオペレーティング システムがスキャンされます。Desktop に、統合対象のすべてのアプリケーションのランチャーが表示されます。同じソフトウェアのバージョンが複数ある場合は、使用可能なすべてのバージョンを含むドロップダウン リストがランチャーに表示されます。ランチャー アイコン自体をクリックすると、最新バージョンが起動します。Maya や Nuke などのアプリケーションは Flow Production Tracking Toolkit からすぐに起動するか、Flow Production Tracking から直接起動することができます。いずれの方法でも、アプリケーション内から Flow Production Tracking の統合を使用することができます。制作スタジオでは通常、出荷設定のままで使用することはなく、さまざまな追加設定が必要になります。スタジオによっては、標準以外の場所にソフトウェアが配置されていたり、ネイティブにサポートされていないソフトウェア用の社内エンジンが使用されていたりすることがあります。このような場合は、Flow Production Tracking の Web アプリから簡単に設定できます。詳細については、『管理者ガイド』を参照してください。表示される予定のアプリが表示されない場合は、『管理者ガイド』の Flow Production Tracking Toolkit のソフトウェアの設定に関するセクションを参照してください。Panel概要Desktop または Flow Production Tracking からアプリケーションを起動すると、Flow Production Tracking Panel が表示されます。Flow Production Tracking Panel は、Maya や Nuke などのアーティスト用アプリケーション内で直接実行される、小型かつ軽量バージョンの Flow Production Tracking です。このパネルを使用すると、作業中のアプリケーションを終了することなく、Flow Production Tracking の情報にすばやくアクセスできます。また、現在のタスクに関する情報に簡単にアクセスしたり、Flow Production Tracking からアクティビティ ストリーム、ノート、タスク、バージョン、およびパブリッシュに瞬時にアクセスしたりできます。さらに、チーム内の他のメンバーから確認のために送信されたバージョンを再生したり、ノートへの返信、新しいタスクの作成、Flow Production Tracking サイトの検索を行ったりできます。UI の詳細Flow Production Tracking Panel はいくつかの主要な UI 要素で構成されています。上部には、ナビゲーションや検索用のボタンを含む ツールバー があります。ツールバーの右下にある 詳細エリア には、現在表示している項目の情報が表示されます。この詳細領域は設定可能であるため、カスタム フィールドを表示したい場合や、パイプラインに極めて重要なデータがある場合は、ここに簡単に表示することができます。最後に、複数の コンテンツ タブ があります。これらの要素に Flow Production Tracking のリストがすべて表示されるため、Flow Production Tracking Panel 内でのナビゲーションが容易になり、パブリッシュなどの項目の参照、バージョンの確認、または現在のフォーカスにリンクされているタスクに割り当てられているユーザの確認をすばやく行うことができます。統合でドッキングがサポートされているアプリケーションでは、Flow Production Tracking Panel が UI 内にシームレスにドッキングされた状態で表示されます。その他のアプリケーションでは、パネルは通常のウィンドウとして表示されます。次に、Flow Production Tracking Panel で使用できるさまざまなタブおよび機能の概要を示します。アクティビティ ストリームアクティビティ ストリームは、Flow Production Tracking 内のアクティビティ ストリームと同様に機能して、次のような参照先のオブジェクトの中、または周囲で発生した動作を表示します。  ノートを作成しているユーザ  レビューのために送信されているバージョン  パイプラインで作成されたパブリッシュアクティビティ ストリームから新しいノートを直接追加することも、既存のノートに返信することもできます。添付ファイルは自動的に表示され、添付ファイルをクリックすると、大きなプレビューが表示されます。ファイルをアップロードした後に、プレースホルダ アイコンが表示される可能性があることに注意してください。最後のサムネイルを表示するパネルが使用可能になったら、手動で更新します。ノートの作成およびノートへの返信ノートの作成やノートへの返信は、Flow Production Tracking Panel から簡単に行うことができます。アクティビティ ストリームまたはノートの詳細ページに移動して、create note や reply to note をクリックするだけです。ノートのテキストを入力するためのダイアログ ボックスが表示されます。ノートを特定のユーザに送信する場合は、@name の表記を使用できます。こうすると、ノートの TO フィールドにこのユーザが自動的に追加されます。ノート、バージョン、パブリッシュ、およびタスクノート、バージョン、パブリッシュ、およびタスクのタブはすべて同じように機能し、現在表示されている項目に関連付けられたデータが表示されます。項目をダブルクリックすると、この項目にフォーカスを設定できます。パブリッシュ に移動すると、このパブリッシュの依存関係を表示できます。この操作は、パイプラインで依存関係情報をトラッキングする場合に役立ち、アセットの相互接続方法に関する情報にすぐにアクセスできるようになります。情報タブ探している情報が他のタブに見つからない場合は、情報タブに移動してください。このタブにはフォーカスされているエンティティのほとんどの Flow Production Tracking フィールドが表示されていて、青のハイパーリンクをクリックすると、Flow Production Tracking の他の場所に移動できます。検索Flow Production Tracking 内の別の場所や別のオブジェクトにすばやく移動する場合は、組み込みの検索機能を使用します。この検索機能は、Flow Production Tracking Web アプリケーションのグローバル検索と似ています。まず、探している情報の名前または説明を入力します。3 文字以上を入力すると、結果が表示されます。アクションFlow Production Tracking Panel を使って Flow Production Tracking データを使用することにより、シーン内で操作を実行することもできます。ローダーと同様に、パネルにもアクション システムが用意されていて、メニューによってトリガされるコードのスニペットを、ブラウザ内のメニュー項目として簡単に登録することができます。詳細領域から、およびリストからアクションにアクセスできます。詳細領域のアクション ボタンには、Flow Production Tracking にすばやく移動して、現在のビューを更新するための便利な組み込み関数もいくつか含まれています。現在の作業領域とホーム領域左上のアイコンをクリックすると、現在の作業領域に移動できます。通常は、この領域が現在作業中のタスクになります。この領域を使用すると、ノートへのアクセスや、バージョンおよび現在の作業内容に関連するその他の情報の確認をすばやく行うことができます。Flow Production Tracking Panel の起動時に常にフォーカスが設定されるのも、この場所です。右上に、現在のユーザのサムネイルを表示するボタンがあります。このボタンをクリックすると、現在のユーザに関連付けられている情報の表示ページに移動します。この領域には、以下が含まれています。  自分が提出したすべてのパブリッシュおよびバージョン  自分に割り当てられているタスク  自分が参加している、または自分に関連しているノート(自分が割り当てられているタスクに関連付けられているノートなど)を含むすべての会話現在の作業領域タスクの作業を開始するときに、パネルを使用して現在の作業領域を設定できます。その後、作品をパブリッシュすると、その作品に Flow Production Tracking の現在のタスクが関連付けられます。Publisher概要アーティストは Publish アプリを使用して作品をパブリッシュすることにより、下流工程に関わるアーティストが自分の作品を使用できるようにすることができます。アーティストのコンテンツ作成ソフトウェア内における従来のパブリッシュ ワークフローと、ディスク上にある任意のファイルのスタンドアロン パブリッシュがサポートされます。コンテンツ作成ソフトウェアで作業し、基本的な Flow Production Tracking の統合を使用している場合、このアプリはアーティストがパブリッシュする項目を自動的に探して表示します。さらに高度な制作上のニーズがある場合は、アーティストのワークフローを操作するカスタム パブリッシュ プラグインを作成することもできます。次のセクションでは、パブリッシャーの UI および基本的な統合ワークフローについて説明します。スタジオ固有のニーズに合わせてパブリッシャーをカスタマイズする方法については、『パブリッシャー開発ガイド』を参照してください。インタフェースのコンポーネントおよび概念ローカル ファイルシステム上の任意の場所からファイルをドラッグ アンド ドロップします。参照ボタンを使用してファイル ブラウザを開き、パブリッシュする 1 つまたは複数のファイルを選択します。左側の項目ツリーに、パブリッシュされる項目が表示されます。最上位の項目には、作業ファイル内で生成されたレンダーやキャッシュなど、関連するサブ項目が含まれる場合があります。各項目の下に、パブリッシュ時に実行されるアクションを表す、1 つまたは複数のパブリッシュ タスクがあります。項目自体は、パブリッシュ ファイルに関連付けられる Flow Production Tracking コンテキストを示すコンテキスト ヘッダでグループ化されます。最上位項目が複数ある場合は、パブリッシュする項目や実行されるアクションの全体像を示す概要項目が表示されます。項目を選択すると、インタフェースの右側にその項目の詳細が表示されます。詳細には宛先のコンテキスト、およびパブリッシュのサムネイルや説明が含まれます。項目および任意のサブ項目の概要を含めることもできます。インタフェースの左下に、一連のツール ボタンがあります。これらのボタンは、次のとおりです。  [参照] (Browse): パブリッシュするファイルを参照する  [更新] (Refresh): パブリッシュ項目リストを更新する  [削除] (Delete): 選択した項目をリストから削除する  [展開] (Expand): リスト内のすべての項目を展開する  [折りたたむ] (Collapse): リスト内のすべての項目を折りたたむ  [ドキュメント] (Documentation): ワークフロー ドキュメントを開く中央にステータス ラベルがあります。このラベルは、パブリッシャーが検証を実行してパブリッシュ タスクを実行すると、更新されます。このラベルをクリックすると、進行状況の詳細オーバーレイが表示されます。右端には、[検証] (Validate)および[パブリッシュ] (Publish)ボタンがあります。[検証] (Validate)ボタンをクリックすると、すべてのおよびタスクに初期検証パスが実行されて、これらがパブリッシュ可能な状態になります。Publish ボタンをクリックすると、リスト内の項目のパブリッシュが開始されます。進行状況の詳細オーバーレイには、リスト内の項目の収集、検証、およびパブリッシュの出力が表示されます。ユーザは[クリップボードにコピー] (Copy to Clipboard)ボタンをクリックして、パブリッシュ ログを簡単に共有できます。検証またはパブリッシュ エラーが発生した場合は、ログ メッセージにアクション ボタンが追加され、これをクリックすることによりユーザに追加情報を案内したり、場合によってはエラーをただちに修正することもできます。基本的なワークフローパブリッシュ アプリの目的は、アーティストが自分の作品を他のアーティストにも使用できるようにすることです。Flow Production Tracking でファイルをパブリッシュすることは、パス、バージョン番号、アーティストの情報、関連する Flow Production Tracking コンテキストなど、パブリッシュするファイルの情報を含むレコードを Flow Production Tracking で作成することを意味します。Flow Production Tracking でファイルがトラックされている場合、他のユーザは Loader アプリを使用してそのファイルを利用することができます。基本的な Flow Production Tracking の統合には、パイプラインでパブリッシュ アプリを使用する方法が 2 つ用意されています。スタンドアロン パブリッシュ方式と、コンテンツ作成ソフトウェア内でパブリッシュする方式です。次のセクションでは、それぞれのシナリオのワークフローの概要を示します。コンテンツ作成ソフトウェア内でパブリッシュする基本的な Flow Production Tracking の統合では、3dsMax、Houdini、Maya、Nuke、Nuke Studio、Photoshop などのコンテンツ作成ソフトウェアのパブリッシュ ワークフローがサポートされています。コンテンツ作成ソフトウェアを使用してパブリッシャーを起動すると、パブリッシャーはパブリッシュする項目を自動的に検出しようとします。パブリッシュのために表示されている項目はソフトウェアおよびアーティストの作業ファイルの内容に応じて若干異なりますが、パブリッシュに関する基本的な概念は同じものが適用されます。次に、Nuke 内でパブリッシュする例を示します。項目およびタスクをパブリッシュするこのウィンドウの左側には、収集されたパブリッシュ項目が表示されています。3 つのパブリッシュ項目があります。作業ファイルが選択されていて、その下に 2 つの子項目があります。また、イメージ ファイル シーケンスおよび Alembic キャッシュがあります。これらの各項目には、Publish to Flow Production Tracking パブリッシュ タスクがアタッチされていて、このタスクを実行すると、Flow Production Tracking でパブリッシュ エントリの作成が処理され、個々のファイルまたはイメージ シーケンスがトラックされます。Nuke スクリプトを表す親項目には、Begin file versioning プラグインがアタッチされています。このプラグインは、作業ファイルのパスにバージョン番号が含まれていない場合に表示されます。このプラグインをオンにすると、このタスクを実行したときにファイル名にバージョン番号が挿入されます。この場合、ファイル名は bunny_010_0010.nk からbunny_010_0010.v001.nk に変更されます。こうすることで、アーティストの作業ファイルの履歴が維持されます。このタスクは既定でオフになっていて、実行する必要はありません。このタスクを有効にした状態で項目をパブリッシュすると、次に作業ファイルをパブリッシュするときはファイル名にバージョン番号が挿入されているため、このタスクは表示されなくなります。パブリッシュ タスクは必要に応じてオンまたはオフにすることができます。項目のチェックボックスにはサブタスクのオン/オフ状態が反映されていて、これらをコントロールします。たとえば、ある項目をオフにすると、そのすべてのタスクがオフになります。複数のタスクの中の 1 つをオフにすると、項目が半分オンの状態になります。特定のタイプのすべてのタスク(すべての Publish to Flow Production Tracking タスクなど)のオン/オフ状態を切り替えるには、Shift キーを押しながらチェックボックスをオンまたはオフにします。パブリッシュ タスクを選択すると、このタスクの実行内容に関する情報が表示されます。コンテキストNuke スクリプト項目の上に、Flow Production Tracking でパブリッシュされた項目に関連付けられるコンテキストの名前が表示されます。このコンテキストを変更するには、インタフェースの右側にある Task または Link フィールドを変更します。複数の項目をパブリッシュする場合は、それらが異なるコンテキストで表示されることがあります。パブリッシュ項目の左側にある 3 つの水平線を含むアイコンは、コンテキスト間で項目を移動するためのドラッグ ハンドルです。タスク エントリ フィールドの横に、ドロップダウン形式のメニュー ボタンも配置されています。このメニューで、ユーザが関心を持っている可能性のあるタスク グループをいくつか表示することができます。現在のユーザに割り当てられているタスク、現在のコンテキストに関連しているタスク(同じショットに割り当てられた別のタスクなど)、および最近参照されたタスクが表示されます。タスクまたはエンティティのリンクを検索するには、いずれかのフィールドをクリックするか、検索アイコンをクリックして関心のあるコンテキストの名前を入力します。一致するタスクまたはエンティティのリンクがフィールドに表示されたら、これをクリックするか、または目的のコンテキストに移動できます。各パブリッシュ項目のカメラ アイコンをクリックすることにより、Flow Production Tracking 内でパブリッシュのサムネイルとして使用する画面の一部を選択することができます。子項目があるシナリオの場合、既定では、子項目は親からサムネイルを継承します。子を選択してそのサムネイルをクリックすることにより、子項目のサムネイルをオーバーライドすることができます。Flow Production Tracking のパブリッシュ データに、入力した説明を含めることができます。サムネイルと同様に、説明は親項目から継承されますが、子の詳細エントリに新しい説明を入力して説明をオーバーライドすることができます。検証項目をパブリッシュする準備ができたら、[検証] (Validate)ボタンをクリックして、ファイルの状態を確認します。パブリッシュ項目を使用したときに、パブリッシュを予測どおりに完了できるようになります。すべての項目が正常に検証されると、右側に緑のチェックマークが表示されます。検証されていない項目には、警告アイコンが表示されます。パブリッシャーの下部にあるステータス ラベル領域にもこのステータスが表示されます。項目のアイコンまたはステータスのラベルをクリックすると、進行状況の詳細オーバーレイが開き、検証の必要な問題がハイライトされます。上記の例では、Nuke スクリプトが保存されませんでした。シナリオによっては、問題の解決策にユーザをすばやく誘導するため、または問題に関する詳細を取得するためのアクション ボタンが用意されています。ここには、Nuke の保存ダイアログを開くための[名前を付けて保存] (Save As)アクション ボタンが表示されています。検証問題が修正されたら、進行状況の詳細オーバーレイを閉じて、パブリッシュ項目ビューに戻ることができます。パブリッシュ タスクに関する警告またはエラーを解決している場合は、検証を必要な回数だけ実行できます。[パブリッシュ] (Publish)ボタンをクリックすると、アプリはリスト内の項目およびタスク間を移動して、それぞれに異なる検証パスを実行し、それからパブリッシュ ロジックを実行して Flow Production Tracking でのエントリ作成、サムネイルのアップロード、作業ファイルのバージョン引き上げなどを行います。項目ごとにパブリッシュの概要を作成し、必要なクリーンアップ作業を行うための仕上げパスも実行されます。プロセス全体の結果を後で確認するには、パブリッシャーの下部にあるステータス ラベルをクリックして、プロジェクトの詳細オーバーレイを表示します。また、パブリッシュ中に進行状況の詳細ビューを表示したままにして、パブリッシュが発生したときに出力を確認することもできます。上の図には、Flow Production Tracking で新たに作成されたパブリッシュ エントリにすばやく移動するための追加のアクション ボタンが表示されています。複数ドキュメントのワークフローPhotoshop や Nuke Studio などのコンテンツ作成ソフトウェアで複数ドキュメントのワークフローを使用している場合は、パブリッシュ項目リストに最上位項目が複数表示されます。展開してオンにできるのは、現在のドキュメントまたはアクティブなドキュメントのみです。パブリッシュするすべてのドキュメントをオンにするには、Shift を押したまま、オフになっている項目のチェックボックスの中の 1 つをクリックします。折りたたまれた項目を展開するには、下部のツールバーにある展開ボタンを使用します。複数の最上位項目がある場合は、リストの上部に概要項目が示されます。この項目を選択すると、パブリッシュ対象として選択されているすべての項目の概要の全体が表示されます。上の図には、4 つの項目と、4 つの異なるコンテキストで実行する合計 8 個のタスクが表示されています。必要に応じて、このビューのすべての項目のコンテキストおよび説明をオーバーライドできます。上の図には Upload for review タスクも表示されています。このタスクは Photoshop ワークフローに限定されません。レビュー可能なメディアとして、トランスコードして Flow Production Tracking にアップロードすることができるすべてのファイル タイプで使用できます。スタンドアロン パブリッシュPublish アプリは、コンテンツ作成ソフトウェア内から実行しなくてもかまいません。ここには、Flow Production Tracking Toolkit から直接起動できるパブリッシャーを示しています。スタンドアロン モードで起動すると、ファイルの参照またはドラッグ アンド ドロップを実行するための領域が表示されます。参照ボタンをクリックすると、標準のファイル ブラウザが開き、パブリッシュするファイルを選択できるようになります。ブラウザでファイルを選択するか、どこかの場所からファイル システムにファイルをドラッグ アンド ドロップすると、これらのファイルがパブリッシュ対象のファイルとして最上位に表示されます。前の例と同様に、パブリッシュするときに、各項目のコンテキストを選択し、説明を設定して、実行するタスクを識別することができます。パブリッシュ タイプ次のセクションでは、基本的な Flow Production Tracking の統合ごとに自動収集されるパブリッシュ タイプについて説明します。スタンドアロンスタンドアロンのワークフローでは、パブリッシュ対象のファイルが自動的に収集されません。ユーザがファイルをパブリッシュするには、ファイルのパスをインタフェースにドラッグするか、ファイルのパスを参照する必要があります。[パブリッシュ] (Publish)ボタンをクリックする前の任意の時点で参照またはドロップされたファイルが、パブリッシャーに受け入れられます。基本的な統合では、既知のファイル タイプを使用して Flow Production Tracking のパブリッシュ タイプと関連付けることにより、任意のファイル拡張子を使用することができます。ファイルの拡張子が認識されない場合は、MIME タイプのファイルが使用されます。認識されたイメージおよびビデオの MIME タイプがパブリッシュ可能になり、確認のためにアップロードするタスクがアタッチされます。基本的な統合では、ドロップされたフォルダ内にイメージシーケンスが含まれていることが前提となります。フォルダ内に認識されるイメージ シーケンスが見つかると、これらがすべてパブリッシュ対象項目として表示されます。シーケンスが見つからない場合は、パブリッシュ対象の項目が作成されません。3ds Maxパブリッシュ タイプに 3dsmax Scene を指定した場合は、現在の Max セッションがパブリッシュ対象として収集されます。収集されたセッションは、Loader を介して別の Max セッションに結合したり、参照したりできます。現在のセッションのプロジェクト フォルダを判別できる場合は、プロジェクトの export フォルダ内にあるすべてのファイルがパブリッシュ対象として表示されます。同様に、プロジェクトの preview フォルダ内にあるすべてのムービー ファイルがパブリッシュ可能になります。Houdiniパブリッシュ タイプに Houdini Scene を指定した場合は、現在の Houdini セッションがパブリッシュ対象として収集されます。収集されたセッションは、Loader を介して別の Houdini セッションに結合したり、参照したりできます。次のタイプのノードからディスクに書き込まれたファイルも自動的に収集されて、パブリッシュ項目として表示されます。  alembic  comp  ifd  opengl  wrenMayaパブリッシュ タイプに Maya Scene を指定した場合は、現在の Max セッションがパブリッシュ対象として収集されます。収集されたセッションは、Loader を介して別の Maya セッションに読み込んだり、参照したりできます。現在のセッションのプロジェクト ルートを判別できる場合は、プロジェクトの cache/Alembic フォルダ内にあるすべての Alembic ファイルがパブリッシュ対象として表示されます。同様に、プロジェクトの movies フォルダ内にあるすべてのムービー ファイルがパブリッシュ可能になります。Nukeパブリッシュ タイプに Nuke Script を指定した場合は、現在の Nuke セッションがパブリッシュ対象として収集されます。収集されたセッションは、Loader を介して別の Nuke セッションに読み込んだり、新しいセッションとして開いたりできます。次のタイプのノードからディスクに書き込まれたファイルも自動的に収集されて、パブリッシュ項目として表示されます。  Write  WriteGeoNuke Studioパブリッシュ タイプに NukeStudio Project を指定した場合は、開いているすべての Nuke Studio プロジェクトがパブリッシュ対象として収集されます。収集されたプロジェクトは、Loader を介して別の Nuke Studio セッション内で新しいプロジェクトとして開くことができます。Photoshop CCパブリッシュ タイプに Photoshop Image を指定した場合は、開いているすべての Photoshop ドキュメントがパブリッシュ対象として収集されます。収集されたドキュメントは、Loader を介して別の Photoshop セッション内で新しいレイヤとしてロードしたり、新しいドキュメントとして開いたりできます。LoaderFlow Production Tracking の Loader を使用すると、Flow Production Tracking にパブリッシュしたファイルの概要確認と参照をすばやく行うことができます。検索可能なツリー ビュー ナビゲーション システムを使用することで、探しているタスク、ショット、またはアセットにすばやく、簡単にアクセスすることができます。アクセスしたら、この項目のすべてのパブリッシュについての概要がローダーにサムネイルで表示されます。その後は、設定可能なフックを利用して、パブリッシュを参照したり、現在のシーンに簡単に読み込んだりできます。ディスク上のファイルまたはファイルのシーケンス(イメージのシーケンスなど)をそれぞれ表すパブリッシュが Flow Production Tracking に記録されます。パブリッシュは任意のアプリケーションで作成できますが、通常は Publisher で作成されます。パブリッシュを作成すると、別のユーザがそのパブリッシュをパイプラインでロードできるようになります。ローダーが関係するのは、この段階です。ローダーを使用すると、ファイル システム ブラウザを連想させる方法で、Flow Production Tracking 内に格納されたパブリッシュを参照することができます。概要ローダー アプリを使用すると、Flow Production Tracking にパブリッシュされたファイルをすばやく参照することができます。ローダ アプリには、タスク、ショット、またはアセットのサムネイルを簡単に表示できる検索可能なツリー ビュー ナビゲーション システムがあります。ツリー ビュー探しているショット、アセット、またはるタスクをすばやく見つけるには、左側のツリー ビューを使用します。探している項目の名前がわかっている場合は、検索領域にこの名前を入力して、検索フレーズと一致する項目のみをツリーに表示することができます。入力を開始するとすぐに、ツリーの周りに青いバーが表示されます。このバーが表示されると、ツリー全体を表示することができなくなり、検索フレーズに基づいてツリー内の項目の一部が表示されます。検索を開始すると、ツリー内のすべてのノードが自動的に展開されます。便利なように、ツリーを右クリックすると、ツリー内のすべてのノードを展開する、または折りたたむオプションが表示されます。ナビゲーションツリー ビューの上部には、3 つのナビゲーション ボタンがあります。ホーム ボタンをクリックすると、ローダーは現在の作業領域を表すショットまたはアセットに自動的に移動します。現在実行中の作業に関連する内容をすばやくロードする場合は、この方法が便利です。起動時にローダーに既定で表示されるのも、この場所です。ツリー ビューでさまざまな項目を選択すると、時間の経過と共に履歴が作成されます。この履歴内で移動するには、ブラウザと同様に、戻るボタンおよび進むボタンを使用します。パブリッシュを見るツリー内の項目を選択すると、UI の中央にあるパブリッシュ領域に使用可能なパブリッシュが表示されます。このビューの各項目は、一連のパブリッシュ内の最新の項目を表しています。したがって、例としてバージョン 15 のテクスチャが表示されている場合は、この項目のバージョン履歴にこれ以前の 14 個のバージョンが含まれています。パブリッシュだけでなく、ショット、シーケンス、アセット、または他の Flow Production Tracking エンティティ タイプを表すフォルダ アイコンも表示されます。オブジェクトのサムネイルがある場合は、フォルダの上部にサムネイルがオーバーレイされ、ナビゲーションをすばやく、視覚的に行うことができます。フォルダをダブルクリックすると、階層内のこのフォルダに移動できます。2 つの表示モードがあります。視覚的に参照して、テクスチャなどを検索する場合は、サムネイル モードが非常に便利です。リストをすばやく確認し、ズーム ハンドルを使用して即座にズーム インおよびズーム アウトすることができます。Nuke スクリプトや Maya ファイルのように、テクスチャほど視覚的な情報が多くないデータを参照する場合は、サムネイル ビューでなくリスト ビューを使用します。このモードでは一部の追加情報がコンパクトに表示されるため、多数の項目内ですばやくスクロールすることができます。特定のタイプの項目のみを表示する場合は、左下の フィルタ パネル を使用して、パブリッシュの表示/非表示をすばやく切り替えることができます。また、このリスト内の各タイプの横にある概要を参照して、現在選択されているツリー項目に対して検索されたパブリッシュ数をタイプごとに確認することもできます。1 つまたは複数のパブリッシュをシーンに取り込む項目をシーンに取り込む場合は、単にダブルクリックしてください。ローダーがパブリッシュに対して 既定のアクション を実行します。項目をシーンに追加する方法が複数あることがあります(たとえば、Maya では別の Maya ファイルを参照したり、このファイルをシーンに読み込んだりできます)。この場合は、[アクション] (Actions) ドロップダウン メニューをクリックするか、パブリッシュの任意の場所を右クリックして、使用可能なすべてのオプションを表示します。複数の項目をシーンに取り込む場合は、複数の要素を選択し、選択範囲内の任意の項目を右クリックして、 [アクション] (Actions) ポップアップ メニューを表示します。表示されるのは、選択範囲内のすべての項目に適用できるアクションのみであることに注意してください。パブリッシュでなく、ショットまたはアセット フォルダ オブジェクトを選択した場合は、Flow Production Tracking またはファイル システムでこの項目を表示するオプションが表示されます。古いパブリッシュを操作する右側の詳細ペインを開くと、選択したパブリッシュのすべてのバージョン履歴が表示されます。このバージョン履歴から旧バージョンをロードすることができます。この操作を行うには、メイン ビューでパブリッシュを操作する場合と同様に、バージョン履歴内でバージョンを選択し、アクション メニューを使用してロードします。関連付けられたレビューパブリッシュにレビュー バージョンが関連付けられている場合は、詳細ペインに再生ボタンが表示されます。このボタンをクリックすると、Web ページ内で Screening Room が起動し、ノートの確認や、バージョンへのノートの追加、および関連付けられたレビュー用 Quicktime の再生をすばやく行うことができます。高度な機能Flow Production Tracking のすべての統合は、高度にカスタマイズ可能で拡張可能なプラットフォームの上に構築されていて、ツールキットというパイプラインを作成するのに役立ちます。この機能にアクセスして設定する方法については、『管理者ガイド』を参照してください。謝辞  PySide のバグ修正版は Flow Production Tracking Toolkit と一緒に配布されtており、こちらから入手できます。  Big Buck Bunny - 画像提供: (CC) Blender Foundation (www.blender.org)特殊マークアップ「TANK_NO_HEADER」を追加して、ヘッダが不要だということをドキュメント作成システムに通知します。",
    "url": "/d587be80/",
    "relUrl": "/d587be80/"
  },
  "116": {
    "id": "116",
    "title": "Desktop に Python 3 を設定する",
    "content": "Flow Production Tracking Toolkit で Python 2 を既定の Python バージョンとして設定する                    警告: このトピックは、Flow Production Tracking Toolkit バージョン 1.7.3 を使用している場合にのみ有効です。新しいバージョンの Flow Production Tracking Toolkit を使用している場合、これらの手順は不要になりました。Python 2は、セキュリティ上の理由から、Flow Production Tracking Toolkit 1.8.0 のリリースに伴い 2023 年 1 月 26 日に削除されました。詳細については、こちらをご確認ください。      Windows  MacOS  CentOS 7WindowsWindows で、環境変数 SHOTGUN_PYTHON_VERSION を手動で 2 に設定する  Windows タスクバーで Windows アイコンをクリックし、[Windows システム ツール]を選択して、[コントロールパネル] &amp;gt; [システムとセキュリティ] &amp;gt; [システム]の順にナビゲートします。  ナビゲートしたら、[システムの詳細設定]を選択します。  [システムのプロパティ]ダイアログボックスで[環境変数]を選択します。  [環境変数]ウィンドウで[新規…]を選択します。  [変数名]に SHOTGUN_PYTHON_VERSION と入力し、[変数値]を 2 に設定します。  Flow Production Tracking Toolkit アプリケーションを再起動します。これで、Python 2 を実行するように Python のバージョンが更新されました。MacOSMacOS で、環境変数 SHOTGUN_PYTHON_VERSION を 2 に設定する  ~/Library/LaunchAgents/ の下に my.startup.plist という名前のプロパティ ファイルを作成します$ vi my.startup.plist  my.startup.plist に以下を追加して、保存します。&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;https://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt; &amp;lt;plist version=&quot;1.0&quot;&amp;gt; &amp;lt;dict&amp;gt;   &amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;   &amp;lt;string&amp;gt;my.startup&amp;lt;/string&amp;gt;   &amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt;   &amp;lt;array&amp;gt;     &amp;lt;string&amp;gt;sh&amp;lt;/string&amp;gt;     &amp;lt;string&amp;gt;-c&amp;lt;/string&amp;gt;     &amp;lt;string&amp;gt;launchctl setenv SHOTGUN_PYTHON_VERSION 2&amp;lt;/string&amp;gt;   &amp;lt;/array&amp;gt;   &amp;lt;key&amp;gt;RunAtLoad&amp;lt;/key&amp;gt;   &amp;lt;true/&amp;gt; &amp;lt;/dict&amp;gt; &amp;lt;/plist&amp;gt;      Mac を再起動すると、新しい環境変数が有効になります。        Flow Production Tracking Toolkit アプリケーションを再起動します。これで、Python 2 を実行するように Python のバージョンが更新されました。  CentOS 7CentOS 7 で、環境変数 SHOTGUN_PYTHON_VERSION を 2 に設定する  ~/.bashrc ファイルに以下を追加します。export SHOTGUN_PYTHON_VERSION=&quot;2&quot;  次のコマンドを実行して、OS を再起動します。$ sudo reboot   Flow Production Tracking Toolkit アプリケーションを再起動します。これで、Python 2 を実行するように Python のバージョンが更新されました。",
    "url": "/69833488/",
    "relUrl": "/69833488/"
  },
  "117": {
    "id": "117",
    "title": "ソフトウェアを起動する前に環境変数を設定するにはどうすればいいですか?",
    "content": "ソフトウェアを起動する前に環境変数を設定するにはどうすればいいですか?Flow Production Tracking Toolkit では、起動プロセス中にフックを使用して環境を設定し、カスタム コードを実行することができます。Nuke や Maya などのソフトウェアを Flow Production Tracking Toolkit またはブラウザ統合を使用して起動すると、tk-multi-launchapp が実行されます。このアプリには、ソフトウェアを起動し、Flow Production Tracking 統合が予測どおりに起動したことを確認するという役割があります。このプロセス内にフックを使用して公開されている 2 つのポイントがあり、そこでカスタム コードを実行することができます。before_app_launch.pybefore_app_launch.py フックは、ソフトウェアを起動する直前に呼び出されます。このフックを使用すると、起動されたソフトウェアに渡す任意のカスタム環境変数を完全に設定することができます。例:import osimport tankclass BeforeAppLaunch(tank.Hook):    def execute(self, app_path, app_args, version, engine_name, **kwargs):        if engine_name == &quot;tk-maya&quot;:            os.environ[&quot;MY_CUSTOM_MAYA_ENV_VAR&quot;] = &quot;Some Maya specific setting&quot;                    警告: Flow Production Tracking で設定された環境変数を完全に再定義しないよう注意してください。たとえば、NUKE_PATH (Nuke の場合)、または PYTHONPATH (Maya の場合)にパスを追加する必要がある場合は、既存の値を置き換えるのではなく、そこにパスを追加するようにしてください。このための便利な方法が提供されています。tank.util.append_path_to_env_var(&quot;NUKE_PATH&quot;, &quot;/my/custom/path&quot;)    カスタム ラッパースタジオによっては、環境変数の設定とソフトウェアの起動を処理するカスタム ラッパーが用意されている場合があります。このようなカスタム コードを使用して環境を設定する場合は、Software エンティティのパス フィールドが実行可能なラッパーを示すように指定すると、tk-multi-launchapp によって代わりに実行されます。                    警告: この方法を使用する場合は、Flow Production Tracking で設定された環境変数を保持するよう注意してください。そうしないと、統合が起動しなくなります。    ",
    "url": "/624f2593/",
    "relUrl": "/624f2593/"
  },
  "118": {
    "id": "118",
    "title": "Setup",
    "content": "Flow Production Tracking Isolation Feature Set - SetupIsolation the isolation features are independent of each other, and can be activated independently of each other. Media replication have as pre-requisite for Media Isolation to be implemented.The setup process will depend on which feature you want to activate for your site.In This Section  Planning your Setup  Media Isolation  Media Traffic Isolation  Media Replication  Isolation Fine Tuning  ActivationSetup OverviewUnderstand your responsibilitiesMake sure that you understand the client responsibilities and the implication of activating any of the Isolation feature.Start the onboarding processLeveraging the isolation features requires adopters to become AWS users. The features activation also requires Autodesk Support intervention. In order to ensure that this joint venture between Autodesk, AWS, and our clients is as streamlined as possible, we decided to work closely with AWS to define a cooperative onboarding process that would meet client expectations for a premium offering. Kick-start the onboarding process before going further.Planning your SetupBefore you start working on your setup, put a plan in place. Choose the features you need and get the required security/legal approval from your team to get started with the Isolation feature set.Media IsolationThis feature allow you to use a S3 Bucket owned by your studio to store media.Media Traffic IsolationThis feature allows for private routing of the media through the AWS Backbone and your studio network, isolating the media traffic from the public internet.Media ReplicationThis feature allows the media to be replicated between AWS Regions, for faster access in your world wide studios. Media Isolation is required.Fine TuningOnce the isolation features you need are activated, make sure that you everything is properly configured for security and cost-efficiency by reviewing this fine tuning guide.ActivationOnce everything is ready, it’s now time to migrate your production site to use the isolation features.",
    "url": "/8128c5fb/",
    "relUrl": "/8128c5fb/"
  },
  "119": {
    "id": "119",
    "title": "Flow Production Tracking Toolkit は Ubuntu のような Debian システムで動作しますか?",
    "content": "Flow Production Tracking Toolkit は Ubuntu のような Debian システムで動作しますか?現在、Flow Production Tracking Toolkit では Debian ベースのディストリビューションをサポートしていません。cpio を使用して RPM から Flow Production Tracking Toolkit を抽出し、そのライブラリの依存関係を維持して、うまく動作させようとしたクライアントが過去にいましたが、良い結果は得られませんでした。参考として、当社の開発グループで次のスレッドを確認することができます。Python 自体が多くのシステム レベル ライブラリの最上部に配置されているため、ライブラリの依存関係の明示的なリストはありません。現在、Debian をサポートする正式な予定はありません。Ubuntu 向けの開発を行うのには問題があります。変更ごとに追加オペレーティング システムの QA とサポートを更新する必要があり、これが大きな負担になります。Flow Production Tracking Toolkit を使用せずに Toolkit を手動で実行して有効にする場合(このドキュメントの説明を参照) - そのドキュメントのページから activate_shotgun_pipeline_toolkit.py スクリプトをダウンロードしてください。ガイドの手順 8 にある「クリックして Flow Production Tracking Toolkit アクティベーション パッケージをダウンロード」という見出しをクリックします。",
    "url": "/3830df9d/",
    "relUrl": "/3830df9d/"
  },
  "120": {
    "id": "120",
    "title": "アプリを開発する",
    "content": "独自のアプリを開発するはじめにこのガイドでは、Toolkit アプリの概要と作成方法、およびアプリ開発に関する基本事項について説明します。Flow Production Tracking Toolkit は Flow Production Tracking Software が管理するアプリとエンジンのコレクションであるだけでなく、カスタムのパイプライン ツールを迅速かつ簡単に作成するための開発プラットフォームも提供します。  Toolkit アプリとは何か?  独自のアプリを作成する手順:  開発サンドボックスを作成する  スターター アプリ リポジトリのフォークまたはダウンロード  アプリを環境設定に追加する  アプリを開発する          テンプレート スターター アプリの構造      環境設定      フレームワーク      変更を再ロードする        テストする  最初のリリースを準備する追加情報:  既存のアプリを変更する          支援する      Toolkit アプリとは何か?Toolkit アプリは、次のように定義されます。  Flow Production Tracking 統合の環境において、通常はエンドユーザによって実行されるツール。  通常、アプリにはユーザの操作をガイドするためのグラフィカル ユーザ インタフェースが備わっているが、必ずしも必要なわけではない。統合に登録されたコマンドとして使用可能なアプリもあり、ホスト ソフトウェアの Flow Production Tracking メニューからトリガできる。  他のプロセスやアプリと相互作用できる API/パブリック メソッドが含まれることがある。  複数のプラットフォームに対応することが可能で、ソフトウェアに依存しない。  これらの設定は、環境ごとに変更できます。  コンテキスト対応にすることができる。たとえば、ユーザが作業しているタスクをアプリが認識し、それに応じて動作するように設定できる。  Toolkit エンジンからのみ実行できる。Toolkit アプリは Toolkit エンジンによって初期化されます。エンジンは特定のソフトウェア環境内で実行するように設計されていて、この環境から Toolkit アプリを実行するインタフェースが提供されます。エンジンを使用すると、アプリでさまざまなソフトウェア環境を処理するという複雑な作業が不要になります。つまり、アプリに必要なことは目的を達成するための機能を提供することであり、ウィンドウのペアレント化の処理、ユーザのコンテキストのトラッキング、自分自身を起動するためのショートカットなどを提供する必要はありません。独自のアプリを作成するFlow Production Tracking Software によって維持およびリリースされるすべてのアプリとエンジンはオープン ソースであり、GitHub から入手できます。このセクションでは、スターター テンプレートを使用して新しいアプリを作成する方法について説明します。ユーザは GitHub と git のワークフローに精通していることが前提となりますが、ソース管理ソリューションとして git を使用していなくても、Toolkit の開発は可能です。パート 1: 開発サンドボックスを作成する他の作業を開始する前に、プロジェクト設定のクローンを作成して開発サンドボックスを設定することをお勧めします。これにより、個別の設定が作成され、プロダクション環境の他のユーザに影響を与えることなく、コードを開発して変更をテストできるようになります。パート 2: スターター アプリ リポジトリのフォークまたはダウンロードオートデスクは、独自のアプリを作成する際の第一歩として使用できるテンプレート スターター アプリを提供しています。このアプリを使用すると、ユーザ用に設定されたすべての標準的なツールキット定型コード、および基本的なサンプル GUI が使用できるようになります。このプラグインを使用するには、git リポジトリをフォークしてディスク上のローカル開発領域にクローンを作成します。この段階で git ソース コントロールを使用しない場合は、zip ファイルとして GitHub からファイルをダウンロードし、ローカルに解凍します(git リポジトリは後でいつでもセットアップできます)。いずれの場合も、目標となるのは、変更を開始できるよう、スターター アプリ コードのローカル コピーを作成することです。パート 3: アプリを環境設定に追加する「アプリを追加する」ガイドを参照することをお勧めします。このガイドには、環境設定にアプリを追加する詳細な方法が示されています。アプリを環境設定に追加する場合は、アプリの使用場所を考慮する必要があります。たとえば、Nuke だけで使用する場合、複数の異なるソフトウェアで使用する場合、または Flow Production Tracking Toolkit からスタンドアロンで使用する場合があります。アプリが依存するコンテキストについても考慮する必要があります。たとえば、ユーザが作業しているタスクがわかっている場合に限ってアプリを実行できるのか、または既知のプロジェクトに限定してアプリを実行できるのかを検討します。この情報がわかれば、アプリの設定を追加する必要がある YAML 環境ファイルおよびエンジンが決まります。現時点で不明な場合は、まず、プロジェクト環境の tk-shell エンジンにアプリの設定を追加することをお勧めします。こうすることにより、IDE からアプリを実行したり、一元管理設定が適用されている場合は tank コマンドを使用してコマンド ラインを介して実行することができます。これにより、開発にかかる時間が短縮されます。開始するには、アプリの場所に開発記述子を使用します。tk-multi-starterapp:  location:    type: dev    path: /path/to/source_code/tk-multi-starterapp開発記述子は、Toolkit に対して、指定された場所のディスクから直接アプリ コードをロードするよう指示します。これは、コードを常に変更する必要がある開発に最適です。後でプロダクション設定にアプリを追加する場合は、別の記述子を使用できます。アプリの環境への追加が完了すると、アプリを起動することができるようになります。アプリの起動方法は、エンジン、およびエンジン内で定義された環境によって異なります。パート 4: アプリを開発するこれで、アプリの開発を開始する準備ができました。テンプレート スターター アプリの構造テンプレート スターター アプリには、次の基本構造が含まれています。  app.py: アプリのエントリ ポイントとメニュー登録は app.py ファイルにあります。通常は、ここでクラスを設定し、必要な初期化およびメニュー項目の登録を行います。  info.yml: マニフェスト ファイルとも呼ばれます。このアプリをインストールするときに必要なさまざまな設定と、既定値(指定されている場合)がすべて定義されます。再利用可能なアプリが必要で、アプリ自体に値をハード コードしたくない場合には、それらの設定がしばしば役に立ちます。  python/app/dialog.py: このフォルダには、メイン アプリ ウィンドウを生成するロジックやイベント コールバックなどが格納されます。  python/app/ui: このフォルダには、自動的に生成された UI コードおよびリソース ファイルが格納されます。このフォルダを直接編集しないで、代わりに resources フォルダ内の Qt UI ファイルを編集してください。  resources/: リソース フォルダにある dialog.ui ファイルは Qt Designer ファイルです。これを開いて使用することで、アプリのルック アンド フィールをすばやく設計および定義することができます。変更の後、build_resources.sh スクリプトを実行して UI ファイルを Python コードに変換し、/python/app/ui/dialog.py として保存する必要があります。  style.qss: このファイルで UI の QSS (Qt スタイルシート)を定義できます。                    注: アプリに UI はなくてもかまいませんが、有効なアプリの最低限の要件はapp.py、 に Application クラスおよび info.yml が含まれていることです。    環境設定マニフェスト ファイル内に、アプリの設定を定義できる configuration セクションが含まれている必要があります。マニフェスト ファイル内で設定を定義すると、YAML 環境ファイル内のアプリにさまざまな値を設定できます。これは、アプリが配置されている環境に応じて動作を変更する必要がある場合に便利です。たとえば、ファイルを保存するときに使用するテンプレートを定義する設定が必要な場合があります。save_template:    type: template    default_value: &quot;maya_asset_work&quot;    description: The template to use when building the path to save the file into    allows_empty: Falseこの設定を作成すると、アプリ コード内にテンプレート名をハード コード化する必要がなくなり、代わりに info.yml 内で既定で定義された設定、または YAML 環境ファイルの設定でオーバーライドされた設定から値を取得できるようになります。template = app.get_setting(&quot;save_template&quot;)つまり、アプリが実行されている環境に応じて、異なるテンプレートを使用するようにアプリを設定できます。環境設定の詳細については、リファレンス ドキュメントを参照してください。フレームワークフレームワークを使用することがわかっている場合は、マニフェスト ファイルに追加できます。たとえば、アプリで Qt ウィジェットと Flow Production Tracking ユーティリティ フレームワークを使用する場合は、info.yml に以下を追加します。# the frameworks required to run this appframeworks:    - {&quot;name&quot;: &quot;tk-framework-shotgunutils&quot;, &quot;version&quot;: &quot;v2.x.x&quot;}    - {&quot;name&quot;: &quot;tk-framework-qtwidgets&quot;, &quot;version&quot;: &quot;v1.x.x&quot;}フレームワークの必要最小バージョンフレームワークに必要最低限のバージョンがある場合は、info.yml で minimum_version 設定を使用できます。# the frameworks required to run this appframeworks:    - {&quot;name&quot;: &quot;tk-framework-shotgunutils&quot;, &quot;version&quot;: &quot;v2.x.x&quot;}    - {&quot;name&quot;: &quot;tk-framework-qtwidgets&quot;, &quot;version&quot;: &quot;v1.x.x&quot;, &quot;minimum_version&quot;: &quot;v1.5.0&quot;}これにより、tk-framework-qtwidgets の v1.5.0 がアプリで使用できるようになります。使用できない場合、アプリは起動時にロードされず、コンソールにエラーが出力されます。アプリが tank updates を使用して更新されると、必要最小限のバージョンを満たしていない設定済みのフレームワークはアプリとともに自動的に更新されます。フレームワークとその効果的な利用の方法については、次のリンクを確認してください:  QT ウィジェット フレームワーク  Flow Production Tracking ユーティリティ フレームワーク変更を再ロードするMaya などのソフトウェア内でアプリをテストする場合に、設定に 1 つまたは複数の開発項目を追加するとすぐに、Toolkit は Flow Production Tracking メニューに[再ロードして再起動] (Reload and Restart)オプションを追加します。これをクリックすると、設定とコードが再ロードされ、エンジンが再起動されます。これによって、繰り返しの処理が高速化されます。すなわち、Maya を一度起動し、目的のコードまたは構成の変更を実行したら、[再ロードして再起動] (Reload and Restart)ボタンを押すだけで、変更が有効になります。                    注: UI が画面上でアクティブになっている場合は、これらは自動的に更新されず、メニューから UI を呼び出して再起動する必要があります。    パート 5: テストコードをテストする場合は、他のユーザを Flow Production Tracking の PipelineConfiguration エンティティの User Restrictions フィールドに追加することで、自分の開発サンドボックスに簡単に招待できます。ユーザを追加するとすぐに、Flow Production Tracking Create 内のメニューに関する新しいエントリ、ブラウザ アクション、および Flow Production Tracking Toolkit 内で設定を選択するオプションが表示されます。                    注: アプリ コードを表示するために必要なアクセス権がユーザにあることを確認してください。必要なアクセス権がない場合は、アプリがロードされません。    パート 6: 最初のリリースを準備するパート 3 では、開発記述子を使用してアプリを指すように設定しました。リリース済みのソフトウェアを安全かつ簡単にアップグレードできるようにするには、すべてのユーザがアプリにアクセスできること、およびバージョン管理が行われていることを確認する必要があります。Flow Production Tracking に付属しているすべてのアプリは、Toolkit App Store を使用して更新とリリースをトラックし、次のようなロケーション タグを持ちます:location:   name: tk-multi-setframerange   type: app_store   version: v0.1.7これにより、Toolkit (たとえば、tank updates コマンド)は更新が利用可能になる時期を確認し、設定を非常に安全な方法で更新および維持することができます。更新コマンドの実行中に新しいバージョンが利用可能になると、Toolkit はコードをダウンロードし、ディスク上のローカルな「バンドル キャッシュ」に配置し、ユーザがコードにアクセスできるようにします。アプリのリリースを取得するオプションがいくつか用意されています。  git および GitHub  Flow Production Tracking のアップロード  ローカル パスプロダクション設定内でアプリを追加し、必要に応じて記述子を使用するように切り替えます。git ベースの記述子git 記述子を使用する場合でも、変更が確実にトラックされるように、まずソース コントロールを使用することをお勧めします。Toolkit では、git (https://git-scm.com/)をそのまま使用できます。設定で tank updates を実行している場合は、アプリ ストアの記述子の場合と同様に、git リポジトリ内で最新リリースを検索して設定を更新できます。このための要件は、次のとおりです。  git リポジトリにアプリが 1 つだけ含まれている必要があります  git リポジトリの構造がスターター アプリ リポジトリと同じである必要があります。  タグを作成する場合は、セマンティック バージョニングを使用します。Toolkit はこれらのバージョン番号を使用して、どのバージョンが最新であるかを、規則 vX.Y.Z に従って判別します。git で最初のタグ(例:v1.0.0)を作成した後で、タグを指す git 記述子を使用するように環境を設定できます。その後、tank updates を実行します。新しいタグが作成されると、アップグレードするかを尋ねるメッセージが表示されます。これで、ワークフローは公式の App Store アプリで実行されるワークフローと同じになります。                    注意: git 記述子は一元管理設定と連携します。一元管理設定では、通常、管理者がアプリのキャッシュを実行し、すべてのユーザがアクセスできる一元的な場所に保存します。ただし、分散設定を使用している場合は、適切でない可能性があります。アプリはユーザごとにダウンロードされるため、それぞれのユーザが git をインストールするとともに、リポジトリを使用して認証し、コードにアクセスするように設定する必要があります。    既存のアプリを変更する場合によっては、空のスターター テンプレートから開始するのではなく、Flow Production Tracking Software の標準アプリの 1 つなどの既存のアプリに、マイナー機能を追加する必要があります。変更したバージョンのアプリを使用する場合は通常、ソース アプリを「トラック」し、定期的に変更とバグ修正を取得します。このような開発を行うときは、親コードを選択し、変更のいくつかを適用して、パイプラインにリリースします。リリースはアプリの基本バージョンと適用されたローカルの変更で効果的に構成されます。既存のバージョン番号にバージョン サフィックスを追加することを推奨します。これは Toolkit とシームレスに連携し、動作も比較的単純です。次のワークフローに実行の手順を示します。  親アプリをフォークして、自分専用のリポジトリを作成します。フォークを使用してすべての git タグを取得します。最新のタグは v0.2.12 と呼ばれ、マスター ブランチは基本的にこのタグのコンテンツと同じです。  変更を適用し、マスター ブランチにコミットします。これで、v0.2.12 に変更が加えられた状態になります。これをプロダクション構成にリリースするときは、タグを作成する必要があります。タグに v0.2.12.1 という名前を付け、コードが v0.2.12 に基づいていること、そしてこれが最初のリリースであることを示します。  誰かが変更部分にバグを見つけました。バグを修正し、タグを付けて v0.2.12.2 をリリースします。  親リポジトリではいくつかの重要なバグ修正がリリースされました。それらをリポジトリにプル ダウンします。親リポジトリで発生したリリースにより、現在の最新のタグは v0.2.15 です。変更をマスターとマージして、テストします。これで、基本的に親アプリ v0.2.15 が変更にマージされました。v0.2.15.1 にタグを付けます。上記のタグ付けスキームにより、Toolkit の更新が正しく実行され、フォーク内の各タグがどのコードに基づいているかを簡単に確認できるようになります。支援するプル リクエストを歓迎します。他のユーザにとっても有益と思われる変更を行った場合には、プル リクエストとしてフィードバックしていただくようお願いいたします。フィードバックは、アプリのメイン バージョンに反映させていただく場合があります。あるいは、ロードマップ ページに新しいアイデアに関する提案を追加してください。コミュニティで共有するアプリを作成したら、フォーラムですべてのユーザにお知らせください。",
    "url": "/2e5ed7bb/",
    "relUrl": "/2e5ed7bb/"
  },
  "121": {
    "id": "121",
    "title": "アプリをブートストラップおよび実行する",
    "content": "アプリをブートストラップおよび実行するこのガイドでは、カスタム コードの実行やアプリの起動を行えるように Toolkit エンジンを初期化するプロセス(別名、ブートストラップ)について説明します。ブートストラップは、Toolkit エンジンがまだ起動されておらず、API を使用する必要がある場合に役立ちます。たとえば、レンダー ファーム上で実行される処理スクリプトがあり、パスとコンテキストを処理するために Toolkit API を使用しなければならない場合があります。または、お気に入りの IDE から Toolkit アプリを実行できる機能が必要になる場合もあります。                    注: 分散設定を使用している場合は、Toolkit エンジンを初期化してから、Toolkit API メソッドを実行する必要があります。中央設定を使用している場合は、エンジンをブートストラップしなくても API を使用できます。ただし、ファクトリ メソッドを使用している場合は、sgtk を読み込むときに、プロジェクトに適した Core API のパスを手動で特定する必要があります。    要件  Python プログラミングの基礎についての理解。  高度な設定を使用するプロジェクト。まだ環境設定を行っていない場合は、「設定の開始」に従ってください。手順  ブートストラップ用の Toolkit API を読み込む  ログ記録  認証  エンジンをブートストラップする  アプリを起動する  完全なスクリプトパート 1: ブートストラップ用の Toolkit API を読み込むsgtk はどこから読み込む必要がありますか?「パスを生成してパブリッシュする」に従った場合は、sgtk の読み込み手順について学習しています。このガイドには、作業するプロジェクト設定から sgtk パッケージを読み込む必要があると記載されています。ブートストラップを実行する場合もこの説明は当てはまりますが、どの初期 sgtk パッケージを読み込むかは重要ではありません。どの Toolkit API でも、異なるプロジェクト設定へのブートストラップ操作を実行できるためです。ブートストラップ プロセスは、現在読み込まれている sgtk パッケージを、新しいプロジェクト設定の Toolkit API に入れ替えます。スタンドアロン Toolkit Core API をダウンロードするまず、tk-core にある sgtk API パッケージを読み込む必要があります。既存のプロジェクトからパッケージを読み込むことができますが、このパッケージを検索する作業は面倒なことがあります。推奨方法は、最新の Core API のスタンドアロン コピーをダウンロードし、このコピーをブートストラップの目的に限って使用することです。このコピーは、読み込み可能な便利な場所に保存する必要があります。追加するパスが、tk-core フォルダ内の python フォルダを指していることを確認してください。なぜなら、ここが sgtk パッケージが格納されている場所だからです。コード# If your sgtk package is not located in a location where Python will automatically look# then add the path to sys.path.import syssys.path.insert(0, &quot;/path/to/tk-core/python&quot;)import sgtkパート 2: ログ記録IDE またはシェルを使用してこのスクリプトを実行する場合は、通常、ログの出力を有効にする必要があります。ログの出力を有効にするには、LogManager().initialize_custom_handler() を実行する必要があります。このためにカスタム ハンドラを提供する必要はありません。カスタム ハンドラが提供されていない場合は、標準のストリームベース ログ ハンドラが設定されるためです。必要に応じて LogManager().global_debug = True を設定して、より詳細な出力を行うこともできます。つまり、付属のコードまたは作成したコード内のすべての logger.debug() 呼び出しが出力されるようになります。ログ記録はパフォーマンスに影響することがあるため、開発中に限ってデバッグ ログを有効にし、通常の操作中は、logger.info() メソッドの呼び出し回数を、表示するために必要な回数に制限する必要があります。import sgtk# Initialize the logger so we get output to our terminal.sgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing).sgtk.LogManager().global_debug = Trueパート 3: 認証Flow Production Tracking Toolkit が既に起動されている環境の外部で Toolkit API を使用するスクリプトを実行する場合は、常に認証する必要があります。したがって、ブートストラップを実行する前に、Flow Production Tracking サイトで Toolkit API を認証する必要があります。認証には、ユーザの資格情報またはスクリプトの資格情報を使用できます。  アプリの起動やユーザ入力が必要な一部のコードの実行など、ユーザ向けプロセス用にブートストラップを行う場合は、ユーザ認証が最適な方法です(既定では、オートデスクのすべての統合機能がユーザ認証を使用して動作します)。  スクリプトを記述して操作を自動化している場合に、認証対象のユーザが存在しないときは、スクリプト資格情報を使用する必要があります。認証は Flow Production TrackingAuthenticator クラスを使用して処理されます。次に、ユーザ認証とスクリプト認証の両方の例を示します。ユーザ認証# Import Toolkit so we can access to Toolkit specific features.import sgtk# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Optionally you can clear any previously cached sessions. This will force you to enter credentials each time.authenticator.clear_default_user()# The user will be prompted for their username,# password, and optional 2-factor authentication code. If a QApplication is# available, a UI will pop-up. If not, the credentials will be prompted# on the command line. The user object returned encapsulates the login# information.user = authenticator.get_user()# Tells Toolkit which user to use for connecting to Flow Production Tracking. Note that this should# always take place before creating an `Sgtk` instance.sgtk.set_authenticated_user(user)スクリプト認証# Import Toolkit so we can access to Toolkit specific features.import sgtk# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your Flow Production Tracking site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to Flow Production Tracking.sgtk.set_authenticated_user(user)パート 4: エンジンをブートストラップするセッション用の Toolkit API の認証が完了したので、ブートストラップ プロセスを開始できます。ブートストラップ API の詳細については、リファレンス ドキュメントを参照してください。高度なブートストラップ プロセスでは、基本的に次の手順を実行します。  Toolkit 設定フォルダを取得または検索します。  アプリやエンジンなどの設定の依存関係がバンドル キャッシュに格納されていることを確認します。これらの依存関係が存在せず、app_store または Flow Production Tracking などのクラウドベースの記述子が使用されている場合は、バンドル キャッシュにダウンロードされます。  現在ロードされている sgtk コアを、環境設定に適したコアに入れ替えます。  エンジン、アプリ、およびフレームワークを初期化します。                    注: 通常は、ブートストラップする際に、このエンジンを正常に実行するために必要なあらゆる要件に注意する必要があります。ただし、場合によっては、ブートストラップ プロセスに含まれない特定の設定要件があり、個別に処理しなければならないことがあります。    ブートストラップの準備ブートストラップを実行するには、まず ToolkitManager インスタンスを作成する必要があります。mgr = sgtk.bootstrap.ToolkitManager(user)  user が ToolkitManager のイニシャライザに渡されない場合、ShotgunAuthenticator().get_user() は内部的に呼び出され、現在認証されている Flow Production Tracking ユーザを返します。他の任意の HumanUser または ScriptUser を使用してブートストラップするには、ShotgunAuthenticator.create_session_user または ShotgunAuthenticator.create_script_user を使用して作成されたユーザを渡します。Toolkit でブートストラップを行うには、少なくともエンティティ、プラグイン ID、およびエンジンについての情報が必要になります。使用可能なすべてのパラメータとオプションについては、このガイドでは説明しません。リファレンス ドキュメントに記載されています。プラグイン IDプラグイン ID を定義するには、ブートストラップ メソッドを呼び出す前に文字列を ToolkitManager.plugin_id パラメータに渡します。このガイドでは、tk-shell エンジンをブートストラップするため、リファレンス ドキュメントに記載されている規則に従って、適切なプラグイン ID 名を指定する必要があります。mgr.plugin_id = &quot;basic.shell&quot;エンジンMaya や Nuke などのソフトウェアの外部にあるスタンドアロン Python 環境でアプリを起動したり、Toolkit コードを実行したりする場合は、tk-shell がブートストラップ先のエンジンになります。サポート対象ソフトウェア内で Toolkit アプリを実行する場合は、tk-maya または tk-nukeなどの適切なエンジンを選択します。このパラメータは、ToolkitManager.bootstrap_engine() メソッドに直接渡されます。以下のエンティティ セクションの例を参照してください。エンティティToolkitManager.bootstrap_engine() メソッドの entity パラメータを使用する目的は、コンテキスト、つまり、起動したエンジンの環境を設定することです。エンティティには、環境設定が機能する任意のエンティティ タイプを指定できます。たとえば、Project エンティティを指定した場合、エンジンはプロジェクトの環境設定を使用してプロジェクト コンテキスト内で起動します。同様に、(タスクが Asset にリンクされている) Task エンティティを指定して、エンジンが asset_step.yml 環境を使用して起動するように設定できます。この動作は既定の設定動作に基づいて決まり、選択した環境はコア フック pick_environment.py によってコントロールされます。したがって、コンテキストやその他のパラメータに基づいて異なる環境を選択するよう変更することができます。エンティティは、タイプと ID が最低限必要となる Flow Production Tracking エンティティ ディクショナリの形式で指定する必要があります。task = {&quot;type&quot;: &quot;Task&quot;, &quot;id&quot;: 17264}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=task)Project 以外のエンティティ タイプにブートストラップする場合は、パス キャッシュが同期していることを確認する必要があります。パス キャッシュが同期していない場合は、テンプレートの解決を試みる場合のように、環境をロードできないことがあります。ブートストラップする前に Sgtk インスタンスが存在しないため、Sgtk インスタンスを作成してからエンジンを起動するまでの間に、同期を実行するようブートストラップ プロセスに指示する必要があります。この操作を行うには、カスタム メソッドを指すように ToolkitManager.pre_engine_start_callback プロパティを設定します。このメソッドで、同期を実行できます。def pre_engine_start_callback(ctx):    '''    Called before the engine is started.    :param :class:&quot;~sgtk.Context&quot; ctx: Context into        which the engine will be launched. This can also be used        to access the Toolkit instance.    '''    ctx.sgtk.synchronize_filesystem_structure()mgr.pre_engine_start_callback = pre_engine_start_callback設定の選択ブートストラップする設定を明示的に定義するか、ブートストラップ ロジックを終了して適切な設定を自動検出することができます。設定が自動検出されない場合に備えて、フォールバック設定を行うこともできます。このガイドでは、プロジェクトに設定が既に行われていて、この設定が自動検出されると想定しています。ブートストラップするすべての ToolkitManager パラメータを設定して、ToolkitManager.bootstrap_engine() メソッドを呼び出すと、エンジンが起動し、エンジンのインスタンスにポインタが返されます。次に、コードの要約を示します。# Import Toolkit so we can access to Toolkit specific features.import sgtk# Initialize the logger so we get output to our terminal.sgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing).sgtk.LogManager().global_debug = True# Authentication################# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your Flow Production Tracking site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to Flow Production Tracking.# This is actually not necessary when using the ToolkitManager. The authenticated user will be set# before launching the engine.# sgtk.set_authenticated_user(user)# Bootstrap############ create an instance of the ToolkitManager which we will use to set a bunch of settings before initiating the bootstrap.mgr = sgtk.bootstrap.ToolkitManager(user)mgr.plugin_id = &quot;basic.shell&quot;project = {&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=project)パート 5: アプリを起動するエンジン インスタンスが作成されたので、Toolkit API を使用することができます。アプリの起動方法について説明する前に、エンジンを介して現在のコンテキスト、sgtk インスタンス、および Flow Production Tracking API インスタンスを管理できることにご注意ください。engine.contextengine.sgtkengine.shotgunこのガイドの最終的な目標はアプリの起動方法を示すことですが、この時点で上記のアトリビュートを利用して、コード スニペットをテストしたり、Toolkit API を利用するする自動化を行ったりできます。アプリを起動するエンジンが起動すると、環境用に定義されたすべてのアプリが初期化されます。次に、アプリによってエンジンにコマンドが登録されます。Maya などのソフトウェア内で実行されているコマンドは、通常、メニューにアクションとして表示されます。コマンドを検索する登録されたコマンドを最初に確認するには、Engine.commands プロパティを出力します。# use pprint to give us a nicely formatted output.import pprintpprint.pprint(engine.commands.keys())&amp;gt;&amp;gt; ['houdini_fx_17.5.360', 'nukestudio_11.2v5', 'nukestudio_11.3v2', 'after_effects_cc_2019', 'maya_2019', 'maya_2018', 'Jump to Screening Room Web Player', 'Publish...',...]このリストを使用して、登録されている実行可能なコマンドを確認できます。コマンドを実行する現在、標準化されたメソッドがないため、コマンドの実行方法はエンジンによって異なります。tk-shell エンジンの場合は、Engine.execute_command() という便利なメソッドを使用できます。このメソッドでは、上記のコマンド文字列名と、アプリのコマンドで渡されると予測されるパラメータのリストが使用されます。if &quot;Publish...&quot; in engine.commands:    # Launch the Publish app, and it doesn't require any arguments to run so provide an empty list.    engine.execute_command(&quot;Publish...&quot;,[])tk-shell エンジン内で実行していない場合は、登録されたコールバックを直接呼び出すようにフォールバックできます。# now find the command we specifically want to executeapp_command = engine.commands.get(&quot;Publish...&quot;)if app_command:    # now run the command, which in this case will launch the Publish app.    app_command[&quot;callback&quot;]()これで、アプリが起動されます。tk-shell エンジンを実行している場合は、ターミナル/コンソールに出力が表示されます。パート 6: 完全なスクリプト# Import Toolkit so we can access to Toolkit specific features.import sgtk# Initialize the logger so we get output to our terminalsgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing)sgtk.LogManager().global_debug = True# Authentication################# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your Flow Production Tracking site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to Flow Production Tracking.# This is actually not necessary when using the ToolkitManager. The authenticated user will be set# before launching the engine.# sgtk.set_authenticated_user(user)# Bootstrap############ create an instance of the ToolkitManager which we will use to set a bunch of settings before initiating the bootstrap.mgr = sgtk.bootstrap.ToolkitManager(user)mgr.plugin_id = &quot;basic.shell&quot;project = {&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=project)# Optionally print out the list of registered commands:# use pprint to give us a nicely formatted output.# import pprint# pprint.pprint(engine.commands.keys())if &quot;Publish...&quot; in engine.commands:    # Launch the Publish app, and it doesn't require any arguments to run so provide an empty list.    engine.execute_command(&quot;Publish...&quot;,[])",
    "url": "/3d8cc69a/",
    "relUrl": "/3d8cc69a/"
  },
  "122": {
    "id": "122",
    "title": "エンジンを開発する",
    "content": "独自のエンジンを開発するはじめにこのドキュメントでは、Toolkit エンジンの開発に関するいくつかの技術的詳細について簡単に説明します。目次:  Toolkit エンジンとは何か?  開始する前に必要な情報  エンジン統合へのアプローチ          Qt、PyQt/PySide および Python が含まれているホスト ソフトウェア      Qt および Python が含まれているが PySide/PyQt は含まれていないホスト ソフトウェア      Python が含まれているホスト ソフトウェア      Python が含まれていないが、プラグインを書き込むことができるホスト ソフトウェア      スクリプト機能を提供しないホスト ソフトウェア        Qt ウィンドウのペアレント化  起動動作  ホスト ソフトウェアの推奨機能リストToolkit エンジンとは何か?エンジンを開発する場合は、ホスト ソフトウェアと、エンジンにロードされている各種の Toolkit アプリおよびフレームワークの間で効果的にブリッジを確立します。エンジンを使用すると、ソフトウェア間の相違を抽象化することができるため、Python と Qt を使用してソフトウェアに依存しない方法でアプリを作成できるようになります。エンジンはファイルのコレクションのことで、構造としてはアプリに似ています。エンジンには engine.py ファイルがあり、このファイルはコアとなる Engine 基本クラス から派生している必要があります。その後、別のエンジンが内部の複雑さに応じてこの基本クラスの各種の側面を再実装します。通常、エンジンは次のサービスを処理または提供します。  メニュー管理。エンジンが起動され、アプリがロードされたら、エンジンは Flow Production Tracking メニューを作成し、このメニュー内にさまざまなアプリを追加する必要があります。  ログ メソッドは通常、ソフトウェアのログ/コンソールに書き込むよようにオーバーライドされます。  UI ダイアログおよびウィンドウを表示するためのメソッドです。これらのメソッドは通常、エンジンによる Qt の処理方法が既定の基本クラスの動作と異なる場合にオーバーライドされ、Toolkit アプリよって起動されるウィンドウと、基盤となるホスト ソフトウェア ウィンドウの管理設定をシームレスに統合します。  アプリによって登録されているすべてのコマンド オブジェクトを含む commands ディクショナリがあります。これは通常、メニュー項目が作成されるときにアクセスされます。  基本クラスは各種の初期化および破棄メソッドを公開します。これらのメソッドは、起動プロセスのさまざまなポイントで実行されます。メソッドをオーバーライドして、起動とシャットダウンの実行を制御できます。  起動時に tk-multi-launchapp によって、および自動ソフトウェア検出によって呼び出される起動ロジックです。エンジンは、sgtk.platform.start_engine() または sgtk.bootstrap.ToolkitManager.bootstrap_engine() メソッドを使用して、Toolkit プラットフォームにょって起動されます。このコマンドは、設定ファイルの読み込み、エンジンの起動、すべてのアプリのロードなどを実行します。エンジンの目的は、起動された後、アプリとの一貫した Python/Qt インタフェースを提供することです。すべてのエンジンは同じ基本クラスを実装するので、アプリは、エンジン上で UI を作成するメソッドなどを呼び出すことができます。これらのメソッドを実装して、ホスト ソフトウェア内で正常に動作するようにすることは、各エンジンの役割です。開始する前に必要な情報オートデスクは、最も一般に使用されるコンテンツ作成ソフトウェアを統合しています。さらに、Toolkit Community のメンバーが作成し、共有しているエンジンもあります。ただし、Toolkit エンジンがまだ組み込まれていないソフトウェアでは、パイプライン統合が必要になる場合があります。時間とリソースがあれば、使用したいが見つからないエンジンを作成することで、Toolkit Community に貢献していただくことができます。これはご自分にとっても有益です。コード作成を開始する前に、当社までお問い合わせください。約束することはできませんが、お客様の計画についてお話させてください。同じエンジンに興味がある、または同じエンジンを作成した経験を持つユーザが見つかる場合もあります。可能な限り、Toolkit を統合するソフトウェアの技術担当者または開発者と連絡を取れるようにしてください。これによって、作業を進めるときにどのような可能性や障害があるかについての洞察を得ることができます。開発の基本事項について当社とのコミュニケーション方法を確立できれば、エンジンについての具体的な内容について、会話や会議の場を設けて当社の誰とでも話をすることができます。Flow Production Tracking のコミュニティ フォーラムで、Toolkit Community のメンバーと直接やりとりすることができます。オートデスクは、新しい統合機能が作成されることを楽しみにお待ちしております。Toolkit Community に貢献していただき、心から感謝いたします。                    ヒント: 「独自のアプリを開発する」には、アプリを開発するための手順が記載されています。このガイドに記載されている原則は、このガイドの対象とならないエンジンを開発する場合にも適用されます。    エンジン統合へのアプローチホスト アプリの機能によっては、エンジン開発が多少複雑になる場合があります。このセクションでは、エンジン開発中に見られた、さまざまなレベルの複雑さについて説明します。Qt、PyQt/PySide および Python が含まれているホスト ソフトウェアこれは Toolkit を設定する最善の方法であり、Qt、Python、および PySide をサポートするホスト ソフトウェア上にエンジンを実装する方法は非常に簡単です。この例として適切なのは、Nuke エンジンまたは Maya エンジンなどです。統合とは、実際にはログ ファイル管理に接続して Flow Production Tracking メニューを設定するためのコードを記述することです。Qt および Python が含まれているが PySide/PyQt は含まれていないホスト ソフトウェアこのクラスのソフトウェアには Motionbuilder などがあり、比較的簡単に統合できます。ホスト ソフトウェア自身は Qt で記述され、Python インタープリタを含んでいるので、PySide または PyQt のバージョンをコンパイルし、エンジンとともに配布することができます。この PySide は Python 環境に追加されるため、Python を使用して Qt オブジェクトにアクセスすることが可能になります。一般に、PySide をコンパイルするときは、正常な動作を保証するために、ショット アプリケーションをコンパイルしたときに使用したものとまったく同じコンパイラ設定を使用する必要があります。Python が含まれているホスト ソフトウェアこのクラスのソフトウェアには、サードパーティの統合 Unreal などがあります。これらのホスト ソフトウェアには Qt 以外の UI が使用されていますが、Python インタープリタが組み込まれています。これは、Python コードを環境の内部で実行できることを意味しますが、既存の Qt イベント ループは実行されません。この場合、Qt と PySide をエンジンに組み込んで、Qt メッセージ ポンプ(イベント)ループを UI のメイン イベント ループに接続する必要があります。ホスト ソフトウェアには、これを正確に実行するための特殊なメソッドが含まれている場合があります。含まれていない場合は、Qt イベント ループがアイドル時呼び出しなどを介して定期的に実行されるように、調整する必要があります。Python が含まれていないが、プラグインを書き込むことができるホスト ソフトウェアこのクラスには、Photoshop と After Effects が含まれます。Python スクリプティングはありませんが、C++ プラグインを作成することができます。この場合、IPC レイヤを含むプラグインを作成し、起動時に Qt と Python を別のプロセスで起動するという方法がしばしば用いられます。セカンダリ プロセスが実行状態になると、IPC レイヤを使用してコマンドが送受信されます。通常、このタイプのホスト ソフトウェアは、エンジンのソリューションを機能させるために多くの労力を必要とします。                    ヒント: オートデスクは Photoshop および After Effects エンジンを使用して、Adobe プラグインを処理するフレームワークを実際に作成しました。どちらのエンジンも、ホスト ソフトウェアとの通信にフレームワークを利用しているため、残りの Adobe ファミリ用の他のエンジンを構築する作業が容易になります。    スクリプト機能を提供しないホスト ソフトウェアどんな方法でもホスト ソフトウェアにプログラムを介してアクセスできない場合は、そのホスト ソフトウェアのためのエンジンを作成することはできません。Qt ウィンドウのペアレント化一般に、ウィンドウのペアレント化には特別な注意が必要です。通常、PySide ウィンドウはウィジェット階層内に自然の親を持たないため、明示的に呼び出す必要があります。ウィンドウのペアレント化は、一貫性のあるエクスペリエンスを提供するために重要です。実装されていないと、Toolkit アプリ ウィンドウがメイン ウィンドウに隠れてしまい、非常に見にくくなることがあります。起動動作エンジンは、ソフトウェアの起動方法や統合の開始方法の処理も行います。このロジックは、tk-multi-launchapp がエンジンを使用してソフトウェアを起動するときに呼び出されます。この設定方法の詳細については、コア ドキュメントを参照してください。ホスト ソフトウェアの推奨機能リストToolkit エンジンは、次のようなホスト ソフトウェアの特性を活用できます。対応可能な項目が多いほど、エンジンのエクスペリエンスが向上します。  Python インタープリタ、Qt、PySide が組み込まれていること。  ソフトウェアの起動/初期化時にコードを実行する機能。  ソフトウェアを起動して実行しているときと、UI が完全に初期化されたときの 2 つの時点で、コードのアクセスと自動実行が可能であること。  ファイルシステムのインタラクションをラップする API コマンド: Open、Save、Save As、Add reference など。      UI 要素を追加するための API コマンド          カスタム Qt ウィジェットをパネルとしてアプリに追加する(バンドルされた PySide 経由が理想)      カスタム メニュー/コンテキスト メニュー項目の追加      ノードベース パッケージのカスタム ノード(インタラクションのための独自の UI を簡単な方法で統合可能)      選択した項目またはノードなどを取得するイントロスペクション        柔軟なイベント システム          「関心を引く」イベントがカスタム コードをトリガする場合がある        UI の非同期実行のサポート          たとえば、インタフェースをロックしないカスタム メニュー項目がトリガされたときにダイアログを表示する      カスタム UI ウィンドウが正しくペアレント化されるように、トップ レベル ウィンドウのハンドルを提供する      ",
    "url": "/be19bc87/",
    "relUrl": "/be19bc87/"
  },
  "123": {
    "id": "123",
    "title": "フレームワークを開発する",
    "content": "独自のフレームワークを開発するはじめにこのドキュメントでは、Toolkit のフレームワークの開発に関するいくつかの技術的詳細について簡単に説明します。目次:  Toolkit のフレームワークとは何か?  既製の Flow Production Tracking フレームワーク  フレームワークを作成する  フックからフレームワークを使用するToolkit のフレームワークとは何か?Toolkit のフレームワークは Toolkit アプリと非常によく似ています。主な違いは、フレームワークは単独で実行するものではなく、アプリまたはエンジンに読み込んで実行するものであるということです。このため、再利用可能なロジックを分離したまま、複数のエンジンおよびアプリで使用することができます。フレームワークの例として、再利用可能な UI コンポーネントのライブラリがあります。このライブラリに、プレイリスト ピッカー コンポーネントが含まれることがあります。アプリ内でこのフレームワークを読み込み、メイン アプリ UI にプレイリスト ピッカー コンポーネントを接続することができます。既製の Flow Production Tracking フレームワークFlow Production Tracking には、独自のアプリを作成するときに役立つことがある、既製のフレームワークがいくつか用意されています。Qt ウィジェットと Flow Production Tracking ユーティリティのフレームワークは、アプリ開発時に特に役立ちます。フレームワークを作成する独自のフレームワークを作成する場合、設定はアプリの作成とほぼ同じです。詳細については、「独自のアプリを開発する」を参照してください。フレームワーク パッケージのルートには、app.py ファイルでなく、Framework 基本クラスから派生したクラスを含む framework.py が配置されています。また、フレームワークはエンジンにコマンドを登録しません。代わりに、メソッドをフレームワーク インスタンス自体に直接格納するか、モジュールを python/ フォルダ内に格納することができます。たとえば、shotgunutils フレームワークは Python フォルダ内にモジュールを格納します。これらのモジュールにアクセスするには、フレームワークを読み込み、import_module() メソッドを使用してサブモジュールにアクセスします。API ドキュメントには、フレームワークの読み込み方法の例が示されています。フックからフレームワークを使用するこれは、フック間で共通のロジックをいくつか共有できるようにするためのフレームワークを作成する場合に便利です。アプリ/フレームワークがマニフェスト ファイル内で明示的に要求していない場合でも、Hook.load_framework() メソッドを介して、アプリやその他のフレームワークのフックでフレームを使用することができます。このメソッドを使用しても、コア フック内でフレームワークを使用することはできません。",
    "url": "/312b792f/",
    "relUrl": "/312b792f/"
  },
  "124": {
    "id": "124",
    "title": "パスを生成してパブリッシュする",
    "content": "パスを生成してパブリッシュするこのガイドでは、パイプライン統合を構築する際に使用される Flow Production Tracking Toolkit Python API の使用方法について説明します。このガイドの目的は、API の使用方法の基本的な例を紹介することです。このガイドを読み終えると、Toolkit API の読み込みや、パスの生成およびパブリッシュを実行できるようになります。要件  Python プログラミングの基礎についての理解。  高度な設定を使用するプロジェクト。まだ環境設定を行っていない場合は、「設定の基本操作」に従ってください。手順  sgtk を読み込む  sgtk インスタンスを取得する  コンテキストを取得する  フォルダを作成する  テンプレートを使用してパスを作成する  既存のファイルを検索して最新のバージョン番号を取得する  パブリッシュされたファイルを登録する  すべてを完全なスクリプトに統合するパート 1: sgtk を読み込むToolkit API は sgtk という Python パッケージに含まれています。各 Toolkit の設定には、tk-core の一部として提供される API の独自のコピーが含まれています。プロジェクトの設定で API を使用するには、使用する設定から sgtk パッケージを読み込む必要があります。別の設定から読み込むと、エラーが発生します。                    注: 場合によっては、tank パッケージが参照されることがあります。このパッケージ名は、同じ内容に対する従来の名前です。いずれの名前でも機能しますが、今後使用する正しい名前は sgtk です。    API を読み込むには、コアの Python フォルダのパスが sys.path 内に存在することを確認する必要があります。ただし、この例では、Flow Production Tracking Toolkit の Python コンソールでこのコードを実行することをお勧めします。これは、sgtk パッケージの正しいパスが sys.path に既に追加されていることを意味します。同様に、Flow Production Tracking の統合が既に実行されているソフトウェア内でこのコードを実行する場合は、パスを追加する必要はありません。Flow Production Tracking が既に起動されている環境でコードを実行する場合は、次のように記述するだけで API を読み込むことができます。import sgtkお気に入りの IDE でテストしている場合のように、Flow Production Tracking の統合の外部で API を使用する場合は、最初に API のパスを設定する必要があります。import syssys.path.append(&quot;/shotgun/configs/my_project_config/install/core/python&quot;)import sgtk                    注: 分散設定を使用している場合に、Toolkit がまだブートストラップされていない環境に sgtk を読み込むには、別の方法が必要になります。詳細については、ブートストラップ ガイドを参照してください。    パート 2: sgtk インスタンスを取得するToolkit API を使用するには、Sgtk クラスのインスタンスを作成する必要があります。Sgtk は、API のメイン インタフェースとして機能する sgtk パッケージ内のクラスです。Sgtk のインスタンスを作成すると、コンテキストの取得、フォルダの作成、テンプレートへのアクセスなどを実行できるようになります。API ドキュメントに示されているように、Sgtk のインスタンスを直接作成することはしないでください。次に、Sgtk インスタンスを取得するためのオプションをいくつか示します。      Flow Production Tracking 統合が既に実行されている環境内で(Flow Production Tracking から Maya を起動した場合は、Maya Python コンソールなどで) Python コードを実行している場合は、現在のエンジンから Sgtk インスタンスを取得できます。Engine.sgtk プロパティにはエンジンの Sgtk インスタンスが保持されます。したがって、Maya などで次のコマンドを実行できます。    # Get the engine that is currently running.current_engine = sgtk.platform.current_engine()# Grab the already created Sgtk instance from the current engine.tk = current_engine.sgtk        Sgtk インスタンスには、Engine.sgtk プロパティを通してアクセスできます。    注: Engine.sgtk プロパティを、パート 1 で読み込んだ sgtk パッケージと混同したり、同じであるとみなしたりしないでください。        sgtk.sgtk_from_entity(): エンジンがまだ起動されていない環境で実行している場合は、このメソッドを使用して、エンティティ ID に基づいて Sgtk インスタンスを取得することができます。指定した ID を持つエンティティは、sgtk API の読み込み元のプロジェクトに属している必要があります。このメソッドは、分散環境設定では機能しません。詳細については、ブートストラップ ガイドを参照してください。        sgtk.sgtk_from_path(): sgtk_from_entity() と同様ですが、環境設定のパス、またはプロジェクトのルート フォルダのパスやその内部(作業ファイルやショット フォルダなど)を使用することができます。このメソッドは、分散環境設定では機能しません。詳細については、ブートストラップ ガイドを参照してください。  このガイドでは、エンジンが既に起動されている環境でこのコードを実行していることが前提となっているため、オプション 1 を使用します。また、tk という名前の変数に Sgtk クラス インスタンスを格納します。Flow Production Tracking Python コンソールを使用している場合、tk 変数はグローバル変数として既に定義されています。これで、Sgtk インスタンスが作成され、API を使用する準備が整いました。パブリッシュ スクリプトは次のようになります。import sgtk# Get the engine that is currently running.current_engine = sgtk.platform.current_engine()# Grab the already created Sgtk instance from the current engine.tk = current_engine.sgtkパート 3: コンテキストを取得するコンテキストとは何か、なぜ必要なのか?Toolkit の多くの機能は、コンテキストに関するものです。つまり、自分が作業している対象を認識し、それに応じた対応を可能にします。Toolkit API を使用している場合に、コンテキストに対応する動作を実現するには、使用しているエンティティに関する重要な情報を保存する機能や、アプリまたは他のプロセスでこれらの情報を共有する機能が必要になります。たとえば、ユーザが作業しているタスクを Toolkit が認識している場合、Toolkit はユーザがパブリッシュしたファイルを Flow Production Tracking 内のこのタスクに自動的にリンクすることができます。Context クラスは、この情報のコンテナとして機能します。特に、Task、Step、entity (Shot または Asset など)、Project、および現在の HumanUser をクラスのインスタンス内に保存することができます。特定のセッションで、さまざまなコンテキスト オブジェクトを必要なだけ作成できます。ただし、エンジンがある場合は、現在の単一コンテキストという概念が存在し、エンジンはこのコンテキストを継続的にトラックします。このコンテキストは、ユーザが現在作業しているコンテキストです。アプリは、このコンテキストを使用する必要があります。後の手順では、コンテキストを使用して、ファイルの保存またはコピーに使用できるパスを解決します。コンテキストを取得するコンテキストを作成するには、コンストラクタ メソッド Sgtk.context_from_entity()、Sgtk.context_from_entity_dictionary()、またはSgtk.context_from_path() のいずれかを使用する必要があります。これらのメソッドにアクセスするには、tk 変数に格納されている、前の手順で作成した Sgtk インスタンスを使用します。                    注: パスのコンテキストを取得するには、フォルダを作成しておく必要があります。これについては、このガイドの次の手順で説明します。    ただし、新しいコンテキストを作成する代わりに、次のように、パート 2 で収集した現在のコンテキストをエンジンから取得することができます。context = current_engine.context後の手順では、このコンテキストを使用してショット上にあるタスクのファイル パスを解決するため、コンテキストに関連情報が含まれていることを確認する必要があります。コードが Toolkit アプリの一部として実行されていて、アプリが shot_step 環境でのみ実行されるよう設定されている場合は、現在のコンテキストが適切に取得されると想定しても安全面で問題はありません。ただし、このガイドからあいまいさを排除するために、Sgtk.context_from_entity() を使用して、Task (Shot に属している必要がある)からコンテキストを明示的に作成します。コンテキストを作成する場合は、操作に必要な最深のレベルを指定します。たとえば、タスクからコンテキストを作成し、残りのコンテキスト パラメータは Toolkit で解決されるようにすることができます。context = tk.context_from_entity(&quot;Task&quot;, 13155)コンテキスト インスタンスの表現を出力すると、次のようになります。print(repr(context))&amp;gt;&amp;gt; &amp;lt;Sgtk Context:   Project: {'type': 'Project', 'name': 'My Project', 'id': 176}  Entity: {'type': 'Shot', 'name': 'shot01_running_away', 'id': 1381}  Step: {'type': 'Step', 'name': 'Comp', 'id': 8}  Task: {'type': 'Task', 'name': 'Comp', 'id': 13155}  User: None  Shotgun URL: https://mysite.shotgunstudio.com/detail/Task/13155  Additional Entities: []  Source Entity: {'type': 'Shot', 'name': 'shot01_running_away', 'id': 1381}&amp;gt;タスクのみを指定した場合でも、他の関連情報が出力されます。パブリッシュ スクリプトは次のようになります。import sgtk# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work.context = tk.context_from_entity(&quot;Task&quot;, 13155)パート 4: フォルダを作成するToolkit は、プロジェクト エンティティに基づいて、ディスク上にフォルダ構造を動的に生成できます。これにより、2 つの目的が実現されます。  ディスク上に整理された構造が作成され、そこにファイルを配置することができます。  これにより、Toolkit は構造の把握、構造からのコンテキストの派生、およびファイルの配置場所の認識をプログラムを通して実行できるようになります。後の手順でパスを解決できるように、フォルダがディスク上に存在することを確認する必要があります。このためには、Sgtk.create_filesystem_structure() メソッドを使用します。tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])コンテキスト オブジェクトを使用して、フォルダを生成するタスクの ID を取得できます。これで、コードは次のようになります。import sgtk# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task, this Task must belong to a Shot for the future steps to work.context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the task.tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])これですべての準備作業が完了し、テンプレートを使用してパスを生成できるようになりました。パート 5: テンプレートを使用してパスを作成するパスを生成するToolkit 内のファイルの配置場所や検索場所を把握する必要がある場合は、テンプレートを使用してディスク上の絶対パスを解決できます。テンプレートとは、コンテキストおよびその他のデータを適用した場合にファイルシステムのパスに解決できる、本質的にトークン化された文字列のことです。テンプレートは、プロジェクトのパイプライン設定を使用してカスタマイズできます。テンプレートの目的は、ファイルの保存場所を解決するための標準化された方法を提供することです。最初に、生成するパスのテンプレート インスタンスを取得する必要があります。作成した Sgtk インスタンスを使用すると、Sgtk.templates アトリビュートを介して目的の Template インスタンスにアクセスできます。このアトリビュートは、キーがテンプレート名、値が Template インスタンスであるディクショナリです。template = tk.templates[&quot;maya_shot_publish&quot;]この例では、maya_shot_publish テンプレートを使用します。既定の設定では、未解決のテンプレート パスは次のようになります。'sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{version}.{maya_extension}'テンプレートは、実際の値に解決する必要があるキーで構成されています。コンテキストには、大部分のキーに関する十分な情報が含まれているため、これを使用して値を抽出することができます。fields = context.as_template_fields(template)&amp;gt;&amp;gt; {'Sequence': 'seq01_chase', 'Shot': 'shot01_running_away', 'Step': 'comp'}Context.as_template_fields() メソッドは、テンプレート キーを解決するための正しい値を含むディクショナリを提供します。ただし、すべてのキーの値が提供されるわけではありません。name、version、および maya_extension は含まれていません。maya_extension キーは、テンプレート キー セクションで既定値を定義します。そのため、この値を指定する必要はありませんが、既定値以外の値が必要な場合は指定することができます。name および version は残されます。名前を選択することが重要であるため、既定値をハード コード化したり、インタフェースのポップアップするなどして、ユーザに値を入力する機会を与えたりできます。ここでは、両方をハード コード化しますが、次の手順では、次に使用可能なバージョン番号を検索する方法について説明します。fields[&quot;name&quot;] = &quot;myscene&quot;fields[&quot;version&quot;] = 1これですべてのフィールドが設定されたので、Template.apply_fields() を使用してテンプレートを絶対パスに解決することができます。publish_path = template.apply_fields(fields)&amp;gt;&amp;gt; /sg_toolkit/mysite.shotgunstudio.com/my_project/sequences/seq01_chase/shot01_running_away/comp/publish/maya/myscene.v001.maフォルダが存在することを確認するフォルダの作成方法は以前に実行しましたが、場合によっては、すべてのフォルダが存在することを確認するための追加手順を実行する必要があります。たとえば、スキーマ内に存在しないフォルダがテンプレートによって定義されていて、元の create_filesystem_structure() 呼び出しで作成されなかった場合は、この追加手順が必要になることがあります。これを行うための便利なメソッドがいくつかあります。コードが Toolkit アプリまたはフックで実行されている場合は、Application.ensure_folder_exists() メソッドを使用できます。エンジンが存在する場合は、Engine.ensure_folder_exists() メソッドを使用できます。エンジンの外部でコードを実行している場合は、sgtk.util.filesystem.ensure_folder_exists() を使用できます。フォルダを作成する場合は、ファイルのフル パスではなく、フォルダのみを指定してください。os モジュールを読み込んで、os.path.dirname(publish_path) を実行し、ファイルのフル パスのフォルダ部分を抽出することができます。パスを使用してファイルを作成またはコピーするこの時点でパスが存在するため、このパスを使用して、このパスにファイルを保存するよう Maya に指示したり、別の場所からファイルをコピーしたりできます。このガイドにおいて、ディスク上のこの場所にファイルを実際に作成する動作を実行することは、重要ではありません。ファイルがパス上にない場合でも、パスをパブリッシュすることはできます。ただし、sgtk.util.filesystem.touch_file() を使用して、ディスク上に空のファイルを作成するよう Toolkit に指示することができます。作業を統合するimport sgtkimport os# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work.context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the task.tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])# Get a template instance by providing a name of a valid template in your config's templates.yml.template = tk.templates[&quot;maya_shot_publish&quot;]# Use the context to resolve as many of the template fields as possible.fields = context.as_template_fields(template)# Manually resolve the remaining fields that can't be figured out automatically from context.fields[&quot;name&quot;] = &quot;myscene&quot;fields[&quot;version&quot;] = 1# Use the fields to resolve the template path into an absolute path.publish_path = template.apply_fields(fields)# Make sure we create any missing folders.current_engine.ensure_folder_exists(os.path.dirname(publish_path))# Create an empty file on disk. (optional - should be replaced by actual file save or copy logic)sgtk.util.filesystem.touch_file(publish_path)次の手順では、ハード コード化しないで、次のバージョン番号を動的に処理します。パート 6: 既存のファイルを検索して最新のバージョン番号を取得するここで使用できるメソッドは 2 つあります。  この特定の例ではパブリッシュ ファイルを解決しているため、Flow Production Tracking API を使用して、PublishedFile エンティティで使用可能な次のバージョン番号をクエリーすることができます。  ディスク上のファイルをスキャンして、既に存在するバージョンを調べ、次のバージョン番号を抽出することができます。これは、作業しているファイルが Flow Production Tracking でトラックされていない場合(作業ファイルなどの場合)に役立ちます。最初の方法はこのガイドの例として最適ですが、どちらの方法にも使い道があるため、両方について説明します。Flow Production Tracking に次のバージョン番号を照会します。Flow Production Tracking API と summarize() メソッドを使用すると、同じ名前およびタスクを共有する PublishedFile エンティティの中で最大のバージョン番号を取得して、1 を追加することができます。r = sg.summarize(entity_type=&quot;PublishedFile&quot;,                 filters = [[&quot;task&quot;, &quot;is&quot;, {&quot;type&quot;:&quot;Task&quot;, &quot;id&quot;: context.task[&quot;id&quot;]}],                            [&quot;name&quot;,&quot;is&quot;, fields[&quot;name&quot;] + &quot;.ma&quot;]],                 summary_fields=[{&quot;field&quot;:&quot;version_number&quot;, &quot;type&quot;:&quot;maximum&quot;}])# Extract the version number and add 1 to it.# In scenarios where there are no files already this summary will return 0.# Apply the version number to the fields dictionary, that will be used to resolve the template into a path.fields[&quot;version&quot;] = r[&quot;summaries&quot;][&quot;version_number&quot;] + 1ファイル システム内で次のバージョン番号を検索します。Toolkit API を使用すると、既存ファイルのリストを収集し、そこからテンプレート フィールドの値を抽出して、次のバージョンを特定することができます。次の例では、作業ファイル テンプレートから最新バージョンを収集しています。作業ファイル テンプレートとパブリッシュ ファイル テンプレートのフィールドが同じである場合は、同じフィールドを使用して次のメソッドを 2 回呼び出し、パブリッシュ ファイルと作業ファイルの最新バージョンを調べ、2 つの組み合わせを使用するよう決定することができます。def get_next_version_number(tk, template_name, fields):    template = tk.templates[template_name]    # Get a list of existing file paths on disk that match the template and provided fields    # Skip the version field as we want to find all versions, not a specific version.    skip_fields = [&quot;version&quot;]    file_paths = tk.paths_from_template(                 template,                 fields,                 skip_fields,                 skip_missing_optional_keys=True             )    versions = []    for a_file in file_paths:        # extract the values from the path so we can read the version.        path_fields = template.get_fields(a_file)        versions.append(path_fields[&quot;version&quot;])    # find the highest version in the list and add one.    return max(versions) + 1# Set the version number in the fields dictionary, that will be used to resolve the template into a path.fields[&quot;version&quot;] = get_next_version_number(tk, &quot;maya_shot_work&quot;, fields)sgtk.paths_from_template() メソッドは、指定したテンプレートおよびフィールドと一致するディスク上のすべてのファイルを収集します。このメソッドは、ファイルのリストを検索して、ユーザに表示する場合にも便利です。いずれのオプションも使用できますが、シンプルさを維持するために、このガイドでは方法 1 のコードを使用します。パート 7: パブリッシュされたファイルを登録するパスが作成されたので、パブリッシュすることができます。この操作を行うには、ユーティリティ メソッド sgtk.util.register_publish() を使用します。Flow Production Tracking API の Flow Production Tracking.create() メソッドを使用して PublishedFile エンティティを作成することもできますが、Toolkit API を使用する方法を強くお勧めします。Toolkit API を使用すると、すべての必須フィールドが正しく指定および入力されていることを確認できます。# So as to match the Publish app's default behavior, we are adding the extension to the end of the publish name.# This is optional, however.publish_name = fields[&quot;name&quot;] + &quot;.ma&quot;version_number = fields[&quot;version&quot;]# Now register the publishsgtk.util.register_publish(tk,                           context,                           publish_path,                           publish_name,                           version_number,                           published_file_type = &quot;Maya Scene&quot;)この時点で、Publish アプリ にも独自の API が提供されることに注目してください。このアプリは基本的に同じ sgtk.util.register_publish() メソッドを使用していますが、コレクション、検証、およびパブリッシュを処理するフレームワークを提供することで、パブリッシュ プロセスに基づいて動作します。パート 8: 完全なスクリプト# Initialization# ==============import sgtkimport os# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work.context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the tasktk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])# Generating a Path# =================# Get a template instance by providing a name of a valid template in your config's templates.ymltemplate = tk.templates[&quot;maya_shot_publish&quot;]# Use the context to resolve as many of the template fields as possible.fields = context.as_template_fields(template)# Manually resolve the remaining fields that can't be figured out automatically from context.fields[&quot;name&quot;] = &quot;myscene&quot;# Get an authenticated Shotgun API instance from the enginesg = current_engine.shotgun# Run a Shotgun API query to summarize the maximum version number on PublishedFiles that# are linked to the task and match the provided name.# Since PublishedFiles generated by the Publish app have the extension on the end of the name we need to add the# extension in our filter.r = sg.summarize(entity_type=&quot;PublishedFile&quot;,                 filters = [[&quot;task&quot;, &quot;is&quot;, {&quot;type&quot;:&quot;Task&quot;, &quot;id&quot;: context.task[&quot;id&quot;]}],                            [&quot;name&quot;,&quot;is&quot;, fields[&quot;name&quot;] + &quot;.ma&quot;]],                 summary_fields=[{&quot;field&quot;:&quot;version_number&quot;, &quot;type&quot;:&quot;maximum&quot;}])# Extract the version number and add 1 to it.# In scenarios where there are no files already this summary will return 0.# Apply the version number to the fields dictionary, that will be used to resolve the template into a path.fields[&quot;version&quot;] = r[&quot;summaries&quot;][&quot;version_number&quot;] + 1# Use the fields to resolve the template path into an absolute path.publish_path = template.apply_fields(fields)# Make sure we create any missing folderscurrent_engine.ensure_folder_exists(os.path.dirname(publish_path))# Creating a file# ===============# This is the bit where you would add your own logic to copy or save a file using the path.# In the absence of any file saving in the example, we'll use the following to create an empty file on disk.sgtk.util.filesystem.touch_file(publish_path)# Publishing# ==========# So as to match publishes created by the Publish app's, we are adding the extension to the end of the publish name.publish_name = fields[&quot;name&quot;] + &quot;.ma&quot;version_number = fields[&quot;version&quot;]# Now register the publishsgtk.util.register_publish(tk,                           context,                           publish_path,                           publish_name,                           version_number,                           published_file_type = &quot;Maya Scene&quot;)                    ヒント: この時点でコードが少し長くなっているため、次の推奨手順で少し整理して、複数のメソッドに分割します。    終わりにこのガイドを参照するには、Toolkit API の使用方法の基本について理解しておくことをお勧めします。API には他にも多くの用途があります。詳細については、tk-core API を参照してください。また、オートデスクのフォーラムで、API に関する疑問点についてディスカッションし、回答を得ることができます。このガイドに関するフィードバックを送信することもできます。",
    "url": "/836446f3/",
    "relUrl": "/836446f3/"
  },
  "125": {
    "id": "125",
    "title": "統合開発者ガイド",
    "content": "統合開発者ガイドパネルパネルのアクションの例については、https://github.com/shotgunsoftware/tk-multi-shotgunpanel/tree/master/hooks を参照してください。表示内容を設定する詳細領域の値とリストは両方とも shotgun_fields フックから設定可能です。正確な値を表示するために、このフックをサブクラス化して実装を変更できます。システムをテンプレート化するフックはシンプルなテンプレート言語をサポートしているため、優れた柔軟性が得られます。また、Qt でサポートされている HTML サブセットもサポートしているため、表示される値の色、フォント サイズ、ウェイトなどをコントロールできますテンプレート言語は次のように機能します。      Flow Production Tracking の値は、{brackets} のように &amp;lt;b&amp;gt;Description:&amp;lt;/b&amp;gt; {description} で囲まれています。このテンプレートをレンダリングすると、{description} の部分が説明フィールドの値で置き換えられます。        値が空以外の場合にのみ表示される値にオプションの接頭辞または接尾辞を指定する場合、{[Prefix]sg_field[suffix]} 構文を使用できます。両方の値が追加されている場合、テンプレート {[Start: ]start_date} {[End: ]end_date} は Start: 12 July 2009 End: 14 July 2012 をレンダリングします。ただし、終了日を設定していない場合は Start: 12 July 2009 をレンダリングします。        一部の値が設定されていない場合はフォールバックを定義することができます。Flow Production Tracking のバージョンについては、プロデューサがアーティストの代わりにバージョンを送信するというワークフローをサポートするため、created_by フィールドが artist フィールドよりも優先されます。この場合、バージョンはプロデューサによって作成されますが、artist フィールドはアーティストに設定されます。ただし、いつもそういうわけではありません。アーティストが自分の作業を送信するパイプラインでは、アーティスト欄は空欄になります。バージョンを表示する場合、最初に artist フィールドを確認できるようにしておくと役立ちます。今回このフィールドは設定されていないため、created_by フィールドにフォールバックします。このようにするには、Created By: {artist|created_by} のように構文 {field1|field2} を使用します。{[Created By: ]artist|created_by} のようにオプション フィールドを組み合わせることができます。  このフックには次のメソッドが含まれます。リストに表示される項目を制御するget_list_item_definition() メソッドは、Flow Production Tracking のエンティティ タイプを考慮して、さまざまなリストの項目の外観を制御するディクショナリを返します。たとえば、top_left、top_right、および body といったキーを持つディクショナリを返します。{ &quot;top_left&quot;: &quot;&amp;lt;big&amp;gt;{code}&amp;lt;/big&amp;gt;&quot;, &quot;top_right&quot;: &quot;{updated_at}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}上部の細部領域を制御するget_main_view_definition() メソッドは、Flow Production Tracking のエンティティ タイプを考慮して、title キーと body キーを含むディクショナリを返します。これらの値は、詳細領域のオブジェクトの外観を次のように制御します。{ &quot;title&quot;: &quot;{type} {code}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}[情報] (Info)タブに表示されるフィールドを制御するget_all_fields() メソッドは、[情報] (Info)タブで任意のエンティティがレンダリングされる場合に表示するフィールドのリストを返します。アクションを設定するアクションは Flow Production Tracking のデータを操作するコードの小さなスニペットです。例を次に示します。  任意の Flow Production Tracking バージョンの RV を起動するアクション  任意のタスクに自分に割り当てることができるアクション  Maya リファレンスとして Maya に Flow Production Tracking パブリッシュをロードするアクションアクションの実際のペイロードは アクション フック で定義されます。アクションのロジックを定義したら、アプリ設定の Flow Production Tracking オブジェクトにこのアクションをマップすることができます。次に、このアクション マッピングの例を示します。action_mappings:  PublishedFile:  - actions: [reference, import]    filters: {published_file_type: Maya Scene}  - actions: [texture_node]    filters: {published_file_type: Rendered Image}  Task:  - actions: [assign_task]    filters: {}  Version:  - actions: [play_in_rv]    filters: {}上記の例では、reference、import、texture_node、assign_task、および play_in_rv といったアクションを使用します。次に、さまざまな Flow Production Tracking のオブジェクトと条件にこのアクションをマップします。たとえば import アクションは、タイプが「Maya Scene」であるすべてのパブリッシュに表示されるよう要求しています。オブジェクトがパネルにロードされると、上記のアクション設定が読み込まれ、分析されます。現在のオブジェクトに適したアクションのリストが決定され、generate_actions() フック メソッドが実行されます。この特定の Flow Production Tracking オブジェクトに対してアクションを実行できるかどうかをフック コードが判断できるように、この時点で指定したエンティティの Flow Production Tracking データがフックに渡されます。この方法により、各フックで表示前にチェックを実行できます。たとえば、play_in_rv フックはメディアをローカルで利用できる場合にのみ意味を持ちます。設定でセットアップされたアクション マッピングは指定した Flow Production Tracking エンティティで有効にするアクションをパネルに通知しますが、指定したオブジェクトに適していないと generate_actions() メソッドによって判断された場合は、すべてのアクションが表示されない可能性があります。generate_actions() メソッドから返されるアクションはアクション メニューに表示されます。ユーザがクリックすると、execute_acton() フック メソッドが呼び出されてアクションが実行されます。パネルがサポートするアプリケーションごとに、適切なアクションを実装するアクション フックがあります。たとえば Maya などの場合、既定のフックは reference、import、texture_node の各アクションを実装し、それぞれが特定の Maya コマンドを実行して現在の Maya シーンにパブリッシュを取り込みます。すべてのフックと同様に、アクションを完全にオーバーライドおよび変更できます。また、埋め込まれたフックに基づいたフックも作成できるため、たくさんのコードを複製しなくても、組み込みのフックに他のアクションを簡単に追加できます。パネルは Toolkit の第 2 世代のフック インタフェースを使用するため、柔軟性に優れています。このフックの形式は改善された構文を使用します。これは既定の構成設定で次のように表示されます。actions_hook: '{self}/tk-maya_actions.py'キーワード {self} は、フックのアプリの hooks フォルダを確認するように Toolkit に指示します。このフックをユーザが設定した実装でオーバーライドする場合は、値を {config}/panel/maya_actions.py に変更します。これにより、設定フォルダ内の hooks/panel/maya_actions.py と呼ばれるフックを使用するように Toolkit に指示します。詳細については、アプリに付属するフック ファイルを参照してください。フックは継承も活用します。つまり、フック内のすべての項目をオーバーライドすることなく、さまざまな方法で既定のフックを簡単に拡張または強化して簡単にフックを管理できます。第 2 世代のフック形式については、こちらで確認してください。フックの継承を使用すると、次のように既定のフックに他のアクションを追加できるようになります。import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_data, actions, ui_area):        &quot;&quot;&quot; Returns a list of action instances for a particular object. The data returned from this hook will be used to populate the  actions menu. The mapping between Flow Production Tracking objects and actions are kept in a different place (in the configuration) so at the point when this hook is called, the app has already established *which* actions are appropriate for this object. This method needs to return detailed data for those actions, in the form of a list of dictionaries, each with name, params, caption and description keys. Because you are operating on a particular object, you may tailor the output  (caption, tooltip etc) to contain custom information suitable for this publish. The ui_area parameter is a string and indicates where the publish is to be shown.  - If it will be shown in the main browsing area, &quot;main&quot; is passed.  - If it will be shown in the details area, &quot;details&quot; is passed. :param sg_data: Flow Production Tracking data dictionary with all the standard publish fields. :param actions: List of action strings which have been defined in the app configuration. :param ui_area: String denoting the UI Area (see above). :returns List of dictionaries, each with keys name, params, caption and description &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_data):        &quot;&quot;&quot; Execute a given action. The data sent to this be method will represent one of the actions enumerated by the generate_actions method. :param name: Action name string representing one of the items returned by generate_actions. :param params: Params data, as specified by generate_actions. :param sg_data: Flow Production Tracking data dictionary with all the standard publish fields. :returns: No return value expected. &quot;&quot;&quot;        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_data)これで、この新しいアクションを設定内のパブリッシュ タイプのセットにバインドできます。action_mappings:  PublishedFile:  - actions: [reference, import, my_new_action]    filters: {published_file_type: Maya Scene}  Version:  - actions: [play_in_rv]    filters: {}上記のようにフックの派生を利用すれば、カスタム フック コードには、管理と更新を簡単にするために実際追加するビジネス ロジックを含めるだけで構いません。パブリッシュパブリッシュ用に項目をアーティストに表示する方法やそれらの項目を処理する方法を制御するフックにより、Publish アプリを高度にカスタマイズすることができます。Publish アプリの開発者を対象とした完全なドキュメントは、Toolkit 開発者サイトで入手できます。Publish アプリの使用方法の詳細については、ユーザ ガイドを参照してください。ローダーロード アクションの例については、https://github.com/shotgunsoftware/tk-multi-loader2/tree/master/hooks を参照してください。高度な機能Flow Production Tracking Toolkit でツールを簡単に開発する独自のアプリを作成できることをご存じですか。各エンジンは、Python および PySide に基づく一貫性のあるインタフェースを公開しているため、Nuke、Photoshop、および 3dsmax で動作する 1 つのアプリを作成できます。Core API 機能を使用すれば、スタジオ用に大規模なパイプライン スタックを構築する必要がなくなり、代わりに開発リソースを制作上の問題解決に集中させることができます。当社の Toolkit を使用すると、プロジェクト間でツールを容易に再利用できます。命名規則やその他の要件が変化する場合には、アプリを再構成するだけで済みます。Toolkit に組み込まれた GIT と Github のサポートによってツールを安全に展開し、開発時にコードをすばやくホットロードしましょう。独自の開発サンドボックスで作業し、TD と早期採用者を招いてテストしてください。プロジェクトに関わるすべての人にコードを適用する必要はありません。",
    "url": "/93c6e555/",
    "relUrl": "/93c6e555/"
  },
  "126": {
    "id": "126",
    "title": "統合の修正を送信する方法",
    "content": "統合の修正を送信する方法Toolkit Community へのご協力を歓迎いたします。発見したバグに対する修正プログラムを作成した場合や、Toolkit に追加するべきと思われる機能を実装した場合は、下記のガイドラインに沿って適切なチャネルまでお送りください。お問い合わせ開発や修正が必要なものがある場合は、まずお話をお聞かせください。適切な方向に進むための、あるいは不要な作業を回避するための情報を提供できるかもしれません。最も重要なことは、ユーザの皆様が何を作成したいのか、Toolkit をどのように使用するのか、その成果に当社がどのように貢献できるのかについて、実際に話をさせていただくことです。Github からリポジトリをフォークするToolkit エンジン、アプリ、フレーム ワークコードのほとんどは Github で公開されています。変更しているリポジトリを Github からローカル環境にフォークしてみてください。変更を加える開発作業はブランチでローカルに行い、専用の環境で当社に提出できる状態になるまでテストしてください。既存のコードベースにスタイルを合わせるようにしてください。変更の内容は目的の範囲内に限定してください。たとえば、コード内の 3 行のバグを修正する場合に、ファイル全体に渡ってスペースの問題を修正することは避けてください。Toolkit に潜んでいる別の問題を引き起こしてしまう可能性があります。コメント作業の内容と、その理由についての詳細なコメントを忘れずに追加してください。他のユーザが後でこのリポジトリをフォークするときに、コードの内容と作成された理由について理解する必要が生じる場合があることにご注意ください。簡潔な内容とし、コメントは長すぎないようにしてください。:)テスト実際の環境や変数はユーザによってさまざまであり、スタジオで使用しているものとは一致しない場合があります。Toolkit は、そのような条件がユーザに及ぼす影響を最小限に抑えようとしますが、ユーザの環境によって状況が異なるのは当然のことです。次に例を示します。  コードは OS X、Windows、Linux で同じように動作しますか?  すべてのサポートされているバージョンのソフトウェアで動作しますか?  ターミナル、SG Desktop、ShotGrid、または独自のカスタム アプリのどこから起動していても同じように動作しますか?プル リクエストを作成する 準備ができたら、変更を Github にプッシュしてプル リクエストを作成します。プル リクエストは詳細に記述し、コードの実行内容と変更が必要な理由を含める必要があります。プル リクエストを書くときには、このコード領域に関する知識をほとんど持たないユーザのことを考慮してください。一般のユーザがプル リクエストを見て、丁寧な記述を読み、理解できる内容であることに満足するでしょう。次に行うこと当社は、プル リクエストを時間のあるときに短時間で見直します。通常は、コードまたはユースケースについてコメントしたり、質問したりすることがあります。リクエストをユーザに戻して、変更を依頼する場合があります。気を悪くなさらないでください。当社はユーザに対する貢献を大切にしていますが、技術的な内容については深い知識を持っています。日々コードに向き合っていますが、誰もが完璧なコードを一度で作成できるとは考えていません。レビュー後、承認されたプル リクエストは QA のキューに入れられ、リポジトリに統合されて、特定のタイミングでリリースされます。タイムラインはさまざまな要因によって異なります。しばらくお待ちいただく場合もあります。プル リクエストが却下される場合もあります。ここでも、気を悪くなさらないでください。ご協力に感謝します。却下されるのにはいくつかの要因があります。しかし、上記のガイドラインに従えば、おそらくそのような事態は回避できるでしょう。",
    "url": "/924c14e8/",
    "relUrl": "/924c14e8/"
  },
  "127": {
    "id": "127",
    "title": "カスタム スクリプトで認証とログイン資格情報を使用するにはどうすればよいですか?",
    "content": "カスタム スクリプトで認証とログイン資格情報を使用するにはどうすればよいですか?エラー メッセージスクリプトで次のようなエラーが表示された場合は、スクリプトと Flow Production Tracking サイトの通信が許可されていないことを意味します。tank.errors.TankError: Missing required script user in config '/path/to/your/project/config/core/shotgun.yml'ユーザ認証またはスクリプト認証が事前に行われていない場合、Toolkit は環境設定の shotgun.yml ファイルで定義された資格情報を確認するためにフォールバックします。shotgun.yml ファイル内で資格情報を定義することは、旧式の認証処理方法です。資格情報を shotgun.yml ファイル内で定義しないで、次に示すいずれかの方法を使用してください。ユーザ向けスクリプトスクリプトがユーザ向けの場合は、Sgtk インスタンスを作成する前に、先頭に以下を追加します。# Import the Toolkit API so we can access Toolkit specific features.import sgtk# Import the ShotgunAuthenticator from the tank_vendor.shotgun_authentication# module. This class allows you to authenticate either programmatically or, in this# case, interactively.from tank_vendor.shotgun_authentication import ShotgunAuthenticator# Instantiate the CoreDefaultsManager. This allows the ShotgunAuthenticator to# retrieve the site, proxy and optional script_user credentials from shotgun.ymlcdm = sgtk.util.CoreDefaultsManager()# Instantiate the authenticator object, passing in the defaults manager.authenticator = ShotgunAuthenticator(cdm)# Optionally clear the current user if you've already logged in before.authenticator.clear_default_user()# Get an authenticated user. In this scenario, since we've passed in the# CoreDefaultsManager, the code will first look to see if there is a script_user inside# shotgun.yml. If there isn't, the user will be prompted for their username,# password and optional 2-factor authentication code. If a QApplication is# available, a UI will pop-up. If not, the credentials will be prompted# on the command line. The user object returned encapsulates the login# information.user = authenticator.get_user()# print &quot;User is '%s'&quot; % user# Tells Toolkit which user to use for connecting to Flow Production Tracking. Note that this should# always take place before creating a Sgtk instance.sgtk.set_authenticated_user(user)## Add your app code here...## When you are done, you could optionally clear the current user. Doing so# however, means that the next time the script is run, the user will be prompted# for their credentials again. You should probably avoid doing this in# order to provide a user experience that is as frictionless as possible.authenticator.clear_default_user()QApplication が利用可能な場合は、次のような結果が得られます。                    注: ダウンロードした Toolkit API (sgtk パッケージ)を使用して別の環境設定にブートストラップする場合のように、環境設定に関連付けられていない Toolkit API を読み込む場合は、CoreDefaultsManager を作成しないでください。代わりに、既定のマネージャを渡さずに、ShotgunAuthenticator() のインスタンスを作成します。authenticator = ShotgunAuthenticator()    ユーザ向け以外のスクリプトレンダリング ファームやイベント ハンドラなど、スクリプトがユーザ向けではない場合は、Sgtk/Tank インスタンスを作成する前に、最初に以下を追加します。# Import Toolkit so we can access to Toolkit specific features.import sgtk# Import the ShotgunAuthenticator from the tank_vendor.shotgun_authentication# module. This class allows you to authenticate either interactively or, in this# case, programmatically.from tank_vendor.shotgun_authentication import ShotgunAuthenticator# Instantiate the CoreDefaultsManager. This allows the ShotgunAuthenticator to# retrieve the site, proxy and optional script_user credentials from shotgun.ymlcdm = sgtk.util.CoreDefaultsManager()# Instantiate the authenticator object, passing in the defaults manager.authenticator = ShotgunAuthenticator(cdm)# Create a user programmatically using the script's key.user = authenticator.create_script_user(    api_script=&quot;Toolkit&quot;,    api_key=&quot;4e48f....&amp;lt;use the key from your Flow Production Tracking site&amp;gt;&quot;)# print &quot;User is '%s'&quot; % user# Tells Toolkit which user to use for connecting to Flow Production Tracking.sgtk.set_authenticated_user(user)                    注: ユーザ向けのスクリプトのセクションの末尾で示したように、読み込んだ sgtk パッケージがスタンドアロンである場合や、環境設定から取得したものでない場合は、既定のマネージャを作成しないでください。また、create_script_user() メソッドに host kwarg を指定する必要があります。user = authenticator.create_script_user(    host=&quot;https://yoursite.shotgunstudio.com&quot;,    api_script=&quot;Toolkit&quot;,    api_key=&quot;4e48f....&amp;lt;use the key from your Shotgun site&amp;gt;&quot;)    ",
    "url": "/724152ce/",
    "relUrl": "/724152ce/"
  },
  "128": {
    "id": "128",
    "title": "プロジェクト間でアセットを共有するにはどうすればいいですか?",
    "content": "プロジェクト間でアセットを共有するにはどうすればいいですか?一般的に、アセット ライブラリとして使用されるプロジェクトが存在し、これには他のプロジェクトのショットにロードできるアセットが含まれています。アセット エンティティに[リンク プロジェクト] (Linked Projects)フィールドを導入することで、すべてのリンク プロジェクトを含む単一のタブをローダー アプリに追加できるようになりました。このためには、作業しているエンジンと環境のローダー設定でこのタブを定義する必要があります。このタブは複数の場所で更新する必要があります。- caption: Assets - Linked    entity_type: Asset    filters:      - [linked_projects, is, &quot;{context.project}&quot;]    hierarchy: [project.Project.name, sg_asset_type, code]tk-config-default2 に含まれている tk-multi-loader2.yml 設定ファイル の Alias エンジン設定を参照することができます。ここでは、これは既定の動作です。アセットに[リンク プロジェクト] (Linked Projects)フィールドを導入する前に、プロジェクト間の共有を実現する最初の方法は、特定のアセット ライブラリ プロジェクトのアセットをリストするタブをローダー アプリに追加することです。たとえば、ショットのステップ環境の Maya エンジンにこのタブを追加するには、次のスニペットを追加します。- caption: Asset Library    hierarchy: [project, sg_asset_type, code]    entity_type: Asset    filters:      - [project, is, {'type': 'Project', 'id': 207}]207 をライブラリ プロジェクトの ID と置き換えます。Maya のショットのステップ環境で作業している場合、このプロジェクトで使用可能なすべてのパブリッシュを表示する新しいタブが追加されます。他のエンジンのローダーにこのタブを追加する場合(Nuke や 3dsmax)、各エンジンで tk-multi-loader2 設定を変更する必要があります。他の環境でこの設定を有効にする場合は、アセットのステップ環境と設定する他の環境で同じ手順を実行する必要があります。手間が少しかかりますが、詳細に制御できるようになります。これらの設定を使用すると、ローダー アプリで特定されたプロジェクトのパブリッシュをリストするタブを表示できます。                    注: この最初の方法は、ローダー内でプロジェクトごとに異なるタブを識別する方法を提供するため、ここに含まれています。    Web ベースのプロジェクト間のアセット リンクの詳細については、プロジェクト間のアセット リンクに関するドキュメントを参照してください。",
    "url": "/2088a677/",
    "relUrl": "/2088a677/"
  },
  "129": {
    "id": "129",
    "title": "概要",
    "content": "Flow Production Tracking 開発プロダクション管理では、すべての個別の要素を同期させる必要があるため、多大な労力を必要とします。データに直接接続するには、Flow Production Tracking REST API または Python API を使用します。反復的なタスクを自動化するにはイベント トリガ フレームワーク、Flow Production Tracking の Web インタフェースからアプリを直接起動するにはアクション メニュー アイテムを使用します。独自のサービスまたは許可されたユーザ用のサービスを基に動作する、または一緒に動作するサービス、アプリケーション、モジュール、およびコンポーネントを独自に開発するには、Flow Production Tracking API を使用することをお勧めします。                    認証キー: オートデスクからユーザのみなさまにお願いしたいことは、API 情報を開示しないこと(および許可されたユーザに開示を許可しないこと)ことのみです。ユーザは API 情報に含まれている認証キーなどを使用することで、ログオンしなくても、サービスやその機能にアクセスできるようになります。また、ログオンすることなくサービスまたはその機能にアクセスできる権限を、API を使用して自分自身に与えることや、ユーザに与えることも行わないでください。    ",
    "url": "/6dfa5d53/",
    "relUrl": "/6dfa5d53/"
  },
  "130": {
    "id": "130",
    "title": "Migration Test Site",
    "content": "Flow Production Tracking Migration Test SiteActivating the isolation feature set is an intrusive procedure that can have an impact on the usability of your site. To prevent a production stopping event, we require clients to follow an approach where the configuration is first validated on a test site, before being applied to the production site.The Flow Production Tracking team will create a temporary site to be used as a Proof of Concept for your Flow Production Tracking Isolation deployment. Upon the successful completion of the setup process, your existing Flow Production Tracking site can be migrated to your Flow Production Tracking Isolation environment.If your Migration Test Site has not been created yet, please reach out to our Support team through your Zendesk ticket or your dedicated on-boarding Slack Channel.Next StepsOnce you have your test site, you can the implementation of the feature you need.See Media Isolation for activating the Media Isolation feature.See Web Traffic Isolation for activating the Web Traffic Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/0bbe0010/",
    "relUrl": "/0bbe0010/"
  },
  "131": {
    "id": "131",
    "title": "SSLHandshakeError CERTIFICATE_VERIFY_FAILED certificate verify failed",
    "content": "SSLHandshakeError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed使用例ローカル パケット検査を行うファイアウォールを使用して設定されたローカル ネットワークで、次のエラー メッセージが表示されます。SSLHandshakeError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)このエラーは、多くの場合、ネットワーク管理者が自身で作成した、Python からアクセスできない自己署名証明書を使用してファイアウォールを設定しているために発生します。他のアプリケーションとは異なり、Python は常に OS のキーチェーン内で証明書を検索するとは限らないため、ユーザ自身が指定する必要があります。修正方法Python API および Flow Production Tracking Toolkit が信頼できる認証局についての完全なリストが含まれているディスク上のファイルを指すように、環境変数 SHOTGUN_API_CACERTS を設定する必要があります。このような コピーは、Github の certifi パッケージの最新コピーからダウンロードできます。この操作が完了したら、このファイルの最後にある企業ファイアウォールの公開鍵を追加して、保存する必要があります。この操作が完了したら、環境変数 SHOTGUN_API_CACERTS をパスの場所(/opt/certs/cacert.pem など)に設定して、Flow Production Tracking Toolkit を起動します。関連リンクコミュニティで完全なスレッドを見る",
    "url": "/4528ba21/",
    "relUrl": "/4528ba21/"
  },
  "132": {
    "id": "132",
    "title": "WARNING Storage Root Primary Could Not Be Mapped to a SG Local Storage",
    "content": "WARNING: Storage Root Primary Could Not Be Mapped to a SG Local Storage使用例ドライブ ファイル ストリームを使用してプロジェクトをセットアップし、Google ドライブをプライマリ ストレージとして使用するよう試みているときに、ストレージ設定にアクセスすると、プロジェクト ウィザードによってコンソールに警告が表示されます。[WARNING] Storage root primary could not be mapped to a SG local storage[Continue]ボタンを押しても機能しません。修正方法この問題は、ストレージ名に誤字がある場合に発生することがあります。ストレージ名が、Google ドライブの名前と正確に一致していることを確認します。さらに、Google Drive を使用する場合は、重複したプロジェクトが表示されないように、常にファイルをローカルに保持する設定になっていることを確認します。関連リンクコミュニティの完全なスレッドを参照してください。",
    "url": "/a59c77b9/",
    "relUrl": "/a59c77b9/"
  },
  "133": {
    "id": "133",
    "title": "Cannot resolve template data for context",
    "content": "TankError: Cannot resolve template data for context使用例新しいプロジェクトで高度なプロジェクト設定を行っているときに、Flow Production Tracking Toolkit のスタンドアロンの Publisher アプリを使用して、作成した新しいアセット タスク用のイメージをいくつかパブリッシュするとします。この場合に、パブリッシュを検証するコンテキストを選択すると、次のエラーが表示されます。creation for %s and try again!&quot; % (self, self.shotgun_url))TankError: Cannot resolve template data for context ‘concept, Asset door-01’ - this context does not have any associated folders created on disk yet and therefore no template data can be extracted. Please run the folder creation for and try again!ターミナルで tank.bat Asset door-01 folders を実行すると、この問題が解決されました。ただし、以前のプロジェクトではこの問題が発生しませんでした。修正方法この原因として考えられるのは、最初に DCC を対象にしないで、新しいエンティティまたはタスクにスタンドアロン パブリッシュを初めて試みたことです。以前にこの問題が発生しなかったのは、スタンドアロン パブリッシャーを使用する前にソフトウェアでアセットの作業を開始していたため、フォルダの作成/同期が既に完了していたためです。ソフトウェアを(Toolkit を介して)起動すると、起動したときのコンテキストのフォルダが作成され、アプリを開くと、新しいファイルを開始したときのコンテキストのフォルダが作成されます。したがって、通常はフォルダを特に作成する必要はありません。スタジオでは通常、Flow Production Tracking でショットやアセットが追加された後に、手動でフォルダを作成することが一般的に行われています。この方法は「フォルダのスキーマ」の影響を受けるため、フォルダのスキーマがテンプレートと完全に一致しない場合は問題になることもあります。関連リンクコミュニティの完全なスレッドを参照してください。",
    "url": "/5cdbc2a3/",
    "relUrl": "/5cdbc2a3/"
  },
  "134": {
    "id": "134",
    "title": "TankError Tried to Resolve a Path From The Template",
    "content": "TankError: Tried to resolve a path from the template使用例 1SGTK の新しい設定をセットアップするときに、[File Open]ダイアログボックス(tk-multi-workfiles2)で新しいファイルを作成しようとすると、次のエラーが発生します。TankError: Tried to resolve a path from the template &amp;lt;Sgtk TemplatePath asset_work_area_maya:使用例 2特定のタスクで保存しようとすると、次のエラーが表示されます。TankError: Tried to resolve a path from the template &amp;lt;Sgtk TemplatePath nuke_shot_work:修正方法ケース 1: asset.yml ファイルを確認します。フィルタが見つからない可能性があります。 - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }ケース 2: この原因は、シーケンスの名前が変更されていて、FilesystemLocations がいくつか残り、Toolkit に混乱をもたらしたことです。修正:  Shotgun の古い FilesystemLocations を削除する  古い FilesystemLocations に関連するフォルダを Toolkit から登録解除する  Toolkit からフォルダを再登録する関連リンクこのコミュニティの全スレッドについては、こちら、このコミュニティ スレッド内の全スレッドについては、こちらを参照してください。",
    "url": "/ea55eac2/",
    "relUrl": "/ea55eac2/"
  },
  "135": {
    "id": "135",
    "title": "You are loading the Toolkit platform from the pipeline configuration located in",
    "content": "TankInitError: You are loading the Toolkit platform from the pipeline configuration located in使用例アプリからファイルをパブリッシュするコードを実行するときに、ファイルが別のプロジェクトに属している場合があります。TankInitError: You are loading the Toolkit platform from the pipeline configuration located in エラーを回避することは可能でしょうか?理想的なのは、パスからコンテキストを見つけて、これらのファイルを適切に登録できることです(これらのファイルが別のプロジェクトに属している場合も同様です)。修正方法次の関数を使用します。def get_sgtk(proj_name, script_name):    &quot;&quot;&quot; Load sgtk path and import module    If sgtk was previously loaded, replace include paths and reimport    &quot;&quot;&quot;    project_path = get_proj_tank_dir(proj_name)    sys.path.insert(1, project_path)    sys.path.insert(1, os.path.join(        project_path,        &quot;install&quot;, &quot;core&quot;, &quot;python&quot;    ))    # unload old core    for mod in filter(lambda m: m.startswith(&quot;sgtk&quot;) or m.startswith(&quot;tank&quot;), sys.modules):        sys.modules.pop(mod)        del mod    if &quot;TANK_CURRENT_PC&quot; in os.environ:        del os.environ[&quot;TANK_CURRENT_PC&quot;]    import sgtk    setup_sgtk_auth(sgtk, script_name)    return sgtk重要なのは、sys.modules からすべての sgtk 関連モジュールを削除して、環境から TANK_CURRENT_PC を削除することです。これは、「Shotgun のイベント デーモンを使用してさまざまな Toolkit コア モジュールをロードするにはどうすればいいですか?」に記載されています。関連リンクコミュニティの完全なスレッドを参照してください。",
    "url": "/a2befe6a/",
    "relUrl": "/a2befe6a/"
  },
  "136": {
    "id": "136",
    "title": "Isolation Features",
    "content": "Isolation Feature SetThe isolation feature set is an hybrid solution that satisfies strict security and legal requirements, while minimizing Flow Production Tracking System Admin specific required knowledge and maintenance. These features enable creative studios to confidently meet their supplier’s and studio’s highly stringent security, privacy, and performance requirements—from the cloud.Continue to About the isolation feature set for more details.Go to Setup if you are ready to activate the Isolation features.In This SectionGetting Started  About Isolation  Client Responsibilities  Onboarding Process  Planning your SetupFeatures Description  Media Isolation  Media Traffic Isolation  Media ReplicationSetup  Setup Overview  Media Isolation  Media Traffic Isolation  Media Replication  Isolation Fine Tuning  ActivationAWS Knowledge  Connecting Your Studio With Your AWS VPC  Flow Production Tracking AWS Direct Connect Onboarding  S3  VPC / IAM / Security Group  Direct Connect  Private Link  VPC Endpoints  AWS Knowledge",
    "url": "/f378a164/",
    "relUrl": "/f378a164/"
  },
  "137": {
    "id": "137",
    "title": "3ds Max Plus",
    "content": "3dsMax PlusFlow Production Tracking Engine for 3ds Max Plus は、3ds Max アプリケーションと Flow Production Tracking Toolkit の橋渡しを行います。エンジンは PySide とすべてのマルチ アプリをサポートします。つまり、3ds Max 内の標準的なアプリ(Maya や Nuke などで動作するのと同じアプリ)を実行できます。このエンジンは 3ds Max と Python API を使用します。サポート対象のアプリケーション バージョンこの項目はテスト済みです。次のアプリケーション バージョンで動作することが分かっています。2020 - 2023ドキュメントこのエンジンは、Max Plus の Python サポートを介して Flow Production Tracking Toolkit (Sgtk) と 3D studio Max を接続します。インストールと更新Flow Production Tracking Toolkit にこのエンジンを追加するProject XYZ にこのエンジンを追加するには、asset という名前の環境で次のコマンドを実行します。&amp;gt; tank Project XYZ install_engine asset tk-3dsmaxplus最新バージョンに更新するこの項目が既にプロジェクトにインストールされている場合に最新バージョンを取得するには、update コマンドを実行します。特定のプロジェクトに含まれている tank コマンドに移動し、そこでこのコマンドを実行します。&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updatesまたは Studio の tank コマンドを実行し、プロジェクトの名前を指定して、更新チェックを実行するプロジェクトを指定します。&amp;gt; tank Project XYZ updatesコラボレーションと発展Flow Production Tracking Toolkit にアクセスできる場合は、すべてのアプリ、エンジン、およびフレームワークのソース コードにも Github からアクセスできます。これらは Github を使用して格納および管理しています。これらの項目は自由に発展させてください。さらなる独立した開発用の基盤として使用したり、変更を加えたり(その際はプル リクエストを送信してください)、 いろいろと研究してビルドの方法やツールキットの動作を確認してください。このコード リポジトリには、https://github.com/shotgunsoftware/tk-3dsmaxplus からアクセスできます。特殊な要件上記の操作を行うには、Flow Production Tracking Toolkit Core API バージョン v0.19.18 以降が必要です。",
    "url": "/7112d6a1/",
    "relUrl": "/7112d6a1/"
  },
  "138": {
    "id": "138",
    "title": "3ds Max",
    "content": "3dsMaxFlow Production Tracking Engine for 3dsMax は、Flow Production Tracking Toolkit (Sgtk)アプリと 3dsMax を統合するための標準プラットフォームを提供します。軽量で操作性に優れており、メイン メニューに Flow Production Tracking のメニューを追加します。サポート対象のアプリケーション バージョンこの項目はテスト済みです。次のアプリケーション バージョンで動作することが分かっています。2020 - 2023ドキュメントFlow Production Tracking Engine for 3dsMax は、Flow Production Tracking Toolkit (Sgtk)アプリと 3dsMax を統合するための標準プラットフォームを提供します。軽量で操作性に優れており、メイン メニューに Flow Production Tracking のメニューを追加します。インストールと更新Flow Production Tracking Toolkit にこのエンジンを追加するProject XYZ にこのエンジンを追加するには、asset という名前の環境で次のコマンドを実行します。&amp;gt; tank Project XYZ install_engine asset tk-3dsmax最新バージョンに更新するこの項目が既にプロジェクトにインストールされている場合に最新バージョンを取得するには、update コマンドを実行します。特定のプロジェクトに含まれている tank コマンドに移動し、そこでこのコマンドを実行します。&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updatesまたは Studio の tank コマンドを実行し、プロジェクトの名前を指定して、更新チェックを実行するプロジェクトを指定します。&amp;gt; tank Project XYZ updatesコラボレーションと発展Flow Production Tracking Toolkit にアクセスできる場合は、すべてのアプリ、エンジン、およびフレームワークのソース コードにも Github からアクセスできます。これらは Github を使用して格納および管理しています。これらの項目は自由に発展させてください。さらなる独立した開発用の基盤として使用したり、変更を加えたり(その際はプル リクエストを送信してください)、 いろいろと研究してビルドの方法やツールキットの動作を確認してください。このコード リポジトリには、https://github.com/shotgunsoftware/tk-3dsmax からアクセスできます。特殊な要件上記の操作を行うには、Flow Production Tracking Toolkit Core API バージョン v0.19.18 以降が必要です。",
    "url": "/bb1266cb/",
    "relUrl": "/bb1266cb/"
  },
  "139": {
    "id": "139",
    "title": "After Effects",
    "content": "After EffectsFlow Production Tracking Engine for After Effects は、Flow Production Tracking と After Effects のワークフローを統合するプラットフォームを提供します。Flow Production Tracking Toolkit の標準エンジンで構成され、tk-framework-adobe (CEP)を使用します。有効にすると、[Flow Production Tracking Adobe パネル] (Flow Production Tracking Adobe Panel)というパネルが After Effects で使用できるようになります。現在の Flow Production Tracking コンテキストの情報とそのコンテキストにインストールされたアプリに登録されているコマンドが表示されます。サポート対象のアプリケーション バージョンこの項目はテスト済みです。次のアプリケーション バージョンで動作することが分かっています。2020 (v17.0) - 2023 (v23.6)最新のリリースでの動作は十分可能ですが、正式なテストはまだ完了していません。インタフェースの概要Flow Production Tracking の拡張パネルには、After Effects のネイティブ パネルと同じカラー パレットと基本レイアウトが使用されます。次の 5 つのコンポーネントで構成されます。  コンテキスト ヘッダ: 現在のコンテキストのサムネイルとフィールドです。  お気に入りシェルフ: 現在のコンテキストで最もよく使用するアプリを表示するように設計されています。  コマンド リスト: 現在のコンテキストのお気に入りではないすべてのコマンドです。  コンテキスト メニュー: 追加のコンテキスト関連コマンドとデバッグ ツールです。  ロギング コンソール: デバッグのログ出力を表示するコンソール オーバーレイです。インストールFlow Production Tracking Engine for After Effects のインストールには、Flow Production Tracking の他の統合と同じプロトコルを使用します。エンジンやアプリのインストールについては、「Toolkit を管理する」という記事を参照してください。また、統合の設定方法の例については、「Toolkit の既定の設定」を参照してください。拡張機能を有効にする拡張をインストールしたら、After Effects の拡張メニューから起動する必要があります。これは、1 回のみ実行する必要があります。それ以降は起動すると Flow Production Tracking 拡張パネルが After Effects のレイアウトに表示されるようになり、逐一有効にする必要はありません。一度有効にすると、それ以降の起動では、Flow Production Tracking 統合のブートストラップ時に、拡張パネルにロード画面が表示されます。通常、この画面は、現在のコンテキストが決定され、コマンドが表示されるまでの数秒間表示されます。インタフェースのコンポーネント以降のセクションでは、Flow Production Tracking と After Effects を統合した場合のコンポーネントについて説明します。コンテキスト ヘッダコンテキスト ヘッダは、現在の Flow Production Tracking コンテキストに関する情報を表示するカスタマイズ可能な領域です。コンテキストは現在アクティブなドキュメントによって決定されます。コンテキストがエンジンによって決定されると、ヘッダはコンテキストのサムネイル フィールドの詳細を表示するように更新されます。フィールド情報はフックで制御されます。フィールド表示のカスタマイズ方法については、「コンテキスト フィールド表示フック」を参照してください。また、コンテキストの切り替えは、Flow Production Tracking で[開く] (Open)が使用されていた場合にのみ認識されることにもご注意ください。お気に入りシェルフお気に入りシェルフは、Maya や Houdini のような他の Flow Production Tracking DCC 統合で利用できるお気に入りメニューと似ています。インタフェースのこのセクションはコンテキスト ヘッダのすぐ下にあるので、よく使用する Toolkit アプリが使いやすく、簡単に見つけられるようになります。シェルフにはお気に入りのコマンドがボタンで表示されます。マウスを上に重ねると、灰色から色付きに変化し、上部のラベルにその名前が表示されます。マウスを上に重ねると、ボタンの説明が表示されます。いずれかのボタンをクリックすると、実行する登録済みコマンドのコールバックがトリガされます。コマンドをお気に入りとして指定する方法については、下記の「shelf_favorites」セクションを参照してください。コマンド リストコマンド リストには、現在のコンテキストに登録されているその他の「標準」コマンドが表示されます。通常、パイプライン設定内にインストールされたアプリはここに表示される 1 つまたは複数のコマンドを登録します。コマンドがお気に入りとして識別されず、コンテキスト メニュー コマンドとしても識別されていない場合は、ここに表示されます。コマンド リスト ボタンは、お気に入りシェルフ内のボタンと同じように動作します。唯一異なる点は、アイコンの右側に完全な名前のリストとして表示されることです。コンテキスト メニューコンテキスト メニュー コマンドとして登録されているコマンドは、Flow Production Tracking 拡張パネルのコンテキスト メニューに表示されます。他のコマンド領域と同様に、このコマンドはコンテキストに応じて変化します。Jump to Flow Production Tracking や Jump to Filesystem などのコマンドは常にここから使用できます。ロギング コンソールロギング コンソールは、CEP JavaScript インタプリタと Toolkit の Python プロセスの両方のログ出力をすべて表示します。拡張機能に問題があり、サポートが必要な場合、ロギング コンソール出力は、Flow Production Tracking のサポート チームが問題をデバッグする際に非常に役立ちます。設定と技術の詳細次のセクションでは、貴社のパイプライン固有のニーズに合わせて統合を設定できるよう、統合の技術的な側面について少し説明します。PySideFlow Production Tracking Engine for After Effects は PySide を使用します。Pyside のインストールについては、Pyside をインストールする公式の手順を参照してください。CEP 拡張機能拡張機能自体はエンジンにバンドルされており、After Effects の初回起動時にエンジンが自動的にインストールします。拡張機能は、アーティストが使用するローカル マシンにある OS 固有の標準的な CEP 拡張ディレクトリにインストールされます。# Windows&amp;gt; C: Users [user name] AppData Roaming Adobe CEP extensions # OS X&amp;gt; ~/Library/Application Support/Adobe/CEP/extensions/After Effects が起動するたびに、エンジン ブートストラップ コードが、エンジンにバンドルされている拡張機能のバージョンとマシン上にインストールされているバージョンを比較します。つまり、新しいバージョンの拡張機能がバンドルされている場合は、エンジンを更新するとインストールされている拡張機能がバンドルされている新しいバージョンに自動的にアップデートされます。お気に入りを設定するお気に入りシェルフは、インストールしたアプリに登録されているコマンドを表示するように設定できます。表示するには、shelf_favorites 設定を環境設定の tk-aftereffects セクションに追加するだけです。次に例を示します。shelf_favorites:    - {app_instance: tk-multi-workfiles2, name: File Save...}    - {app_instance: tk-multi-workfiles2, name: File Open...}    - {app_instance: tk-multi-publish, name: Publish...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}設定の値は、環境設定にインストールされたアプリの 1 つで提供される、登録済みコマンドを識別するディクショナリのリストです。app_instance キーは特定のインストール済みアプリを識別し、name キーはこのアプリによって登録されたコマンドの表示名に一致します。上記の例では、4 つのお気に入りコマンドが表示されています。tk-multi-workfiles2 アプリのファイルの表示と保存のダイアログと、標準の Toolkit のパブリッシュとスナップショットのダイアログです。これら 4 つのコマンドはお気に入りシェルフに表示されます。環境変数デバッグをサポートするために、エンジンの既定値の一部を変更する環境変数のセットが用意されています。  SHOTGUN_ADOBE_HEARTBEAT_INTERVAL: Python ハートビート間隔(秒単位、既定は 1 秒)。  SHOTGUN_ADOBE_HEARTBEAT_TOLERANCE: 終了までのハートビートのエラー数(既定は 2)。この変数を設定すると、従来の環境変数  SGTK_PHOTOSHOP_HEARTBEAT_TOLERANCE が優先されます。  SHOTGUN_ADOBE_NETWORK_DEBUG: ログ出力時に追加のネットワーク デバッグ メッセージを含めます。この変数を設定すると、従来の環境変数  SGTK_PHOTOSHOP_NETWORK_DEBUG が優先されます。  SHOTGUN_ADOBE_PYTHON: エンジンの起動時に使用する Python の実行可能ファイルへのパス。設定しない場合は、システムの Python が使用されます。Photoshop が Flow Production Tracking Toolkit や tk-shell エンジンなどの Python プロセスから起動される場合、このプロセスで使用する Python は Photoshop との統合で使用されます。注: 追加の環境変数が Adobe のフレームワークに存在します。詳細については、「開発者用ドキュメント」を参照してください。コンテキスト フィールド表示フックエンジンには、パネルのコンテキスト ヘッダ セクションに表示されるフィールドを制御するフックがあります。フックには表示する内容をカスタマイズするためにオーバーライドできる 2 つのメソッドがあります。最初のメソッドは get_entity_fields() メソッドです。このメソッドは、現在の Flow Production Tracking コンテキストを表すエンティティ タイプを受け入れます。予想される戻り値は、表示するためにクエリーの必要があるエンティティのフィールドのリストです。エンジン自体はデータのクエリーを非同期に処理します。Flow Production Tracking からデータをクエリーすると、フックの 2 番目のメソッドが呼び出されます。この get_context_html() メソッドは、get_entity_fields() メソッドで指定されたクエリー フィールドが入力されたコンテキスト エンティティ ディクショナリを受け取ります。予想される戻り値は、クエリー対象のエンティティ フィールドを表示するためにフォーマット化された HTML を含む文字列です。これらのメソッドで必要とされる内容については、「既定のフックの実装」を参照してください。エンジンは、エンティティのサムネイルが使用可能であれば、それを常に表示します。映像フックの読み込みエンジンにはフックが付属し、それにより一部のファイル タイプの読み込み動作を制御することができます。PSD ファイルを、コンポジションではなく単一レイヤとして読み込むほうが良い場合もあります。このような状況では、その動作の仕方を上書きするためにフックが使用されることがあります。既定のフックの実装After Effects の APIAfter Effects API の詳細については、開発者用ドキュメントを参照してください。",
    "url": "/1eca509c/",
    "relUrl": "/1eca509c/"
  },
  "140": {
    "id": "140",
    "title": "Alias",
    "content": "AliasFlow Production Tracking Engine for Alias は、Flow Production Tracking アプリと Alias を統合するための標準プラットフォームを提供します。軽量で操作性に優れており、Alias のメニューに Flow Production Tracking のメニューを追加します。サポート対象のアプリケーション バージョンこの項目はテスト済みです。次のアプリケーション バージョンで動作することが分かっています。2020 - 2023最新のリリースでの動作は十分可能ですが、正式なテストはまだ完了していません。Python バージョンのサポート  重要: Alias Flow Production Tracking ツールキット エンジンの v2.1.5 のリリースでは、Python v2.7.x のサポートが廃止されました。Flow Production Tracking Toolkit v1.7.3 (以降)をダウンロードして、Python 3 が既定で使用されるようにしてください。旧バージョン旧バージョンに対する Python バージョンのサポートの詳細を確認してください。注記ローカルにインストールされたインタプリタが予期しない動作を引き起こす可能性があります。スタジオ環境でこの機能を使用する場合は、サポートにお問い合わせください。アプリ開発者向けの情報PySideFlow Production Tracking Engine for Alias には、Flow Production Tracking Toolkit に付属の PySide がインストールされており、必要に応じて有効になります。Alias プロジェクトの管理Flow Production Tracking Engine for Alias が起動すると、このエンジンの設定で定義された場所を Alias プロジェクトが参照するように設定されます。つまり、新しいファイルを開くと、このプロジェクトも変更される場合があります。ファイルに基づく Alias プロジェクトの設定方法に関連する詳細設定は、テンプレート システムを使用して設定ファイルで指定できます。tk-alias を使用するこの Flow Production Tracking の統合では、Alias アプリケーション ファミリ(Concept、Surface、AutoStudio)がサポートされます。Alias を開くと、Flow Production Tracking のメニュー(Alias エンジン)がメニュー バーに追加されます。ファイルの表示と保存[マイ タスク] (My Tasks)タブと[アセット] (Assets)タブを使用すると、割り当てられたすべてのタスクを表示して、アセットを参照できます。 右側では、これらのタブを使用してすべてのファイル、作業ファイル、またはパブリッシュ ファイルを表示します。これらのファイルは、左側で選択されているものに関連付けられています。パブリッシュ[パブリッシュ] (Publish)ダイアログを開き、ファイルを Flow Production Tracking にパブリッシュします。パブリッシュ ファイルは、下流工程でアーティストが使用します。詳細については、「Alias でパブリッシュする」を参照してください。 ローダーContent Loader アプリを開いて、Alias にデータをロードできます。詳細については、「Alias でロードする」を参照してください。シーンの詳細情報[詳細情報] (Breakdown)ダイアログが開き、参照される(WREF リファレンス)コンテンツのリストが表示され、シーン内で古くなっているものや Published File の別のバージョンを使用しているものが表示されます。詳細については、「Alias の Scene Breakdown」を参照してください。",
    "url": "/8229b689/",
    "relUrl": "/8229b689/"
  },
  "141": {
    "id": "141",
    "title": "Create",
    "content": "Flow Production Tracking CreateDesktop2 Engine は Flow Production Tracking Create アプリケーション内で実行されるエンジンです。Flow Production Tracking Create および Flow Production Tracking Web アプリケーションからブラウザ統合を介して DCC を起動する場合に使用します。tk-desktop2 エンジンは、Toolkit と Flow Production Tracking Create の統合をサポートします。Flow Production Tracking Create は、DCC の起動など、Toolkit のユーザが慣れている機能をサポートします。インストールと更新Flow Production Tracking Toolkit にこのエンジンを追加していますProject XYZ にこのエンジンを追加するには、asset という名前の環境で次のコマンドを実行します。&amp;gt; tank Project XYZ install_engine asset tk-desktop2Updating to the latest versionこの項目が既にプロジェクトにインストールされている場合に最新バージョンを取得するには、update コマンドを実行します。特定のプロジェクトに含まれている tank コマンドに移動し、そこでこのコマンドを実行します。&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updatesまたは、tank コマンドを実行し、プロジェクトの名前を指定して、更新チェックを実行するプロジェクトを指定します。&amp;gt; tank Project XYZ updatesコラボレーションと発展Flow Production Tracking Toolkit にアクセスできる場合は、すべてのアプリ、エンジン、およびフレームワークのソース コードにも Github からアクセスできます。これらは Github を使用して格納および管理しています。これらの項目は自由に展開できます。さらに独立した開発のベースとして使用したり、変更を加えたり(プルリクエストを送信して戻してください)、または機能を使い、どのように作られたのか、ツールキットがどのように機能するのかを確認することもできます。このコード リポジトリには、https://github.com/shotgunsoftware/tk-desktop2 からアクセスできます。特殊な要件上記の操作を行うには、Pipeline Toolkit Core API バージョン v0.19.1 以降が必要です。Flow Production Tracking 統合エラーを修正していますユーザに次のエラー メッセージが表示されます。統合の初期化に失敗しました。ValueError - Flow Production Tracking のローカル ホスト証明書データが無効です。サポートにお問い合わせください。このエラーメッセージは、Flow Production Tracking インスタンスが Flow Production Tracking Toolkit 統合を使用するように設定されていない場合に、Flow Production Tracking 機能にアクセスしようとしていることを示しています。ユーザが Flow Production Tracking Toolkit にアクセスしてエラー メッセージを表示しないようにするには、環境変数 SHOTGUN_CREATE_DISABLE_TOOLKIT_INTEGRATION を有効にします。この環境変数は、Create での Flow Production Tracking Toolkit の統合を完全に無効にします。誤ってこの環境変数を有効にした場合、無効にすると Flow Production Tracking Toolkit 統合が復元されます。",
    "url": "/969c1d7f/",
    "relUrl": "/969c1d7f/"
  },
  "142": {
    "id": "142",
    "title": "Tk-desktop console silently ignoring errors",
    "content": "Tk-desktop console silently ignoring errors使用例Toolkit アプリを開発している場合は、[Toggle debug logging]チェックボックスがオンになっていても、初期化時にアプリで発生したすべての例外は tk-desktop によって自動的に無視されます。問題が発生していることを把握するには、プロジェクトの設定をロードした後に登録済みのコマンドが表示されないことを確認する必要があります。修正方法Desktop がプロジェクトのアプリをロードするときに、このログが SG Desktop のメイン UI プロセスに渡されることはありません。ただし、tk-desktop.log への出力は引き続き取得されます。このファイルを調べて、例外がないか確認します。関連リンクコミュニティの完全なスレッドを参照してください。",
    "url": "/228e7940/",
    "relUrl": "/228e7940/"
  },
  "143": {
    "id": "143",
    "title": "Desktop",
    "content": "Desktoptk-desktop エンジンは Toolkit アプリケーションを簡単に実行できるアプリケーションです。これはシステム トレイ ベースのウィンドウで、Toolkit の開始、Toolkit のプロジェクトのセットアップ、プロジェクトのパイプラインへのアクセスを簡単に行うことができます。サイト設定とプロジェクト設定デスクトップ アプリケーションを起動すると、サイト設定用に tk-desktop エンジンが起動されます。この動作を無効にして、その環境の内容を制御することもできますが、通常はこの設定が自動的に管理されます。Toolkit の基本原則の 1 つは、プロジェクト同士を完全に分離できることです。これは通常、あるプロジェクトに対して行った変更が(配信間近の)他のプロジェクトに悪影響を与えないようにするために行います。このようにプロジェクトを分離するため、特定のプロジェクトのコマンドを実行する場合、デスクトップ エンジンはこのプロジェクト用に初期化された個別の Python インタプリタでコマンドを実行するようにします。プロジェクトをクリックすると、Python インタプリタはバックグラウンドで起動されます。この Python インタプリタは、プロジェクトが使用できるように設定されているため、起動時にこのプロジェクトの tk-desktop を初期化します。エンジンのこのインスタンスは起動するコマンドを GUI に通知します。コマンドをクリックすると、このバックグラウンド Python プロセスがコマンドの起動を管理します。カスタム パネルを登録するパネル ベースの UI を持つ Toolkit アプリは、実行時に Desktop 内のタブに自動的にドッキングされます。Flow Production Tracking Panel などのパネル ベースのアプリを Flow Production Tracking Toolkit でタブとして表示したい場合は、起動時に実行されるように設定します。Desktop がサイト コンテキスト モード(すべてのプロジェクトが表示される)で起動すると、自動起動するよう登録されたすべての項目が起動します。これらの項目にパネルが含まれる場合、ドッキングされます。項目は、設定で定義された順序で処理され、これによりタブの順序が決まります。たとえば、Flow Production Tracking Panel を Flow Production Tracking Toolkit にタブとして表示する場合は、サイト レベルの環境に次の設定を追加します。tk-desktop:  apps:    tk-multi-shotgunpanel:      actions_hook: ...      action_mappings: ...      location: ...  location: ...  run_at_startup:  - {app_instance: '', name: Apps}  - {app_instance: tk-multi-shotgunpanel, name: ''}Apps エントリは特別であり、既定の Apps タブが表示される場所(タブの順序)をコントロールすることに注意してください。",
    "url": "/75097ed0/",
    "relUrl": "/75097ed0/"
  },
  "144": {
    "id": "144",
    "title": "Flame の書き出し",
    "content": "Flame の書き出しFlow Production Tracking Flame Export アプリはプロジェクトの開始時に役立ちます。Flame で最初のコンフォームを作成したら、ショット書き出し機能を使用して、Flow Production Tracking でコンテンツをすばやく生成し、ディスクにプレートをレンダリングして、レビュー用にコンテンツを送信できます。いったん軌道に乗った後は、書き出しアプリが Flare または Flame バッチ モードで実行されているすべてのレンダリングのトラックも行うため、ワークフローの一部としてコンテンツをレビュー用に簡単に送信できます。Flow Production Tracking にコンフォームを送信するFlame でシーケンスのコンフォームをセットアップし、タイムラインのすべてのセグメントにショット名を割り当てたら、シーケンスを選択し、右クリックして[Flow Production Tracking ショット書き出し] (Shotgun Shot Export)オプションを選択します。これにより、パブリッシュの冒頭のコメントを入力できる Flow Production Tracking の UI が表示されます。このコメントはレビューに送信され、パブリッシュとその他のコンテンツに説明を追加する場合にも使用されます。説明とは別に、書き出されるプレートに使用する出力データ形式を選択することもできます。これらのプリセットは Toolkit アプリ設定の一部であり、貴社のニーズに合うように設定できます。送信ボタンをクリックすると、多くの処理がすぐに実行されます。      ショットとタスクが Flow Production Tracking で作成されます。作成される新しいショットに関連するタスクのリストは、一貫性のある構造をすぐに無駄なく作成できるように、タスク テンプレート設定を介して設定可能です。既定では、ショットはシーケンスの子として関連付けられますが、これも設定可能で、シーンまたはエピソードを作業している場合は、代わりにショットと連携するように書き出し機能を再設定できます。        Flow Production Tracking に正しいデータが含まれる場合は、標準的なフォルダ作成メカニズムを使用して、ディスク上にフォルダが作成されます。これにより、作成されるすべてのショットに一貫したフォルダのセットを使用してプロジェクトが開始できるようになります。  上記の 2 つの手順を実行したら、以降の手順を続行するための基本的な構造ができあがります。これらの処理はバックグラウンドで実行されます。      プレートが、設定で定義されたプリセットに従ってショットごとにディスク上に書き出されます。ファイルの場所は Toolkit テンプレート システムを使用して定義されます。つまり、このプレートの場所は適切に定義されているため、パイプラインの下流工程にある他のツールからでも参照できます。        バッチ ファイルとクリップ XML ファイルが書き出されます。これらのファイルは、反復ワークフローを有効にするために Flame で使用されます。これにより、Flame のメイン コンフォームに後で取り込まれる新しいバージョンをすぐにレンダリングできます。        QuickTime が生成され、レビュー用に Flow Production Tracking にアップロードされます。  レビューにバッチ レンダリングを送信するショットの Flame バッチ ファイルをパブリッシュしたら、レンダリングと出力の設定が事前に入力されたバッチ ファイルを開くために、このショットから Flare を直接起動できます。新しいバージョンをレンダリングするには、単純に Render Range ボタンをクリックします。Toolkit にダイアログが表示され、Flow Production Tracking Review にレンダリングを送信するかどうかを選択できます。Flow Production Tracking によってファイルがパブリッシュおよびトラックされ、必要に応じてレビューにも送信されます。詳細について詳細および処理のワークフローを確認する場合は、Flame エンジンのマニュアルを参照してください。このマニュアルには、処理のさまざまなワークフローを説明したいくつかのビデオ コンテンツがあります。LINKBOX_ENGINE:ShotGridsoftware/tk-flame:Flame エンジン統合やカスタマイズに関して疑問がある場合は、サポート サイトにアクセスしてサポートを依頼してください。高度なトピック以下に、設定とカスタマイズに関する高度な詳細情報を示します。書き出しプリセットを使用する書き出し機能は、設定の 「書き出しプリセット」 の概念を使用します。Flame 内で書き出し UI を起動すると、ドロップダウンに利用可能な書き出しプリセットが表示されます。各プリセットは、ファイルをディスクに書き込む方法と Flow Production Tracking にアップロードする方法を設定できる設定オプションです。ディスク上のファイルの場所など、高度な設定は環境設定で直接制御するため、パイプラインに合わせて既定の設定オプションを簡単に調整できます。Flame を制御するために Flame に渡される実際の書き出し XML コンテンツに関する高度な設定と制御は、プリセットごとの動作が定義されているフックによって処理されます。フックでは、書き出し機能によってメディアを生成する方法を完全に制御できます。Flow Production Tracking サーバ側のトランスコーディングを回避する既定では、Version.sg_uploaded_movie フィールドを設定すると、QuickTime が Flow Production Tracking Review にアップロードされます。これにより、Flow Production Tracking サーバ側のトランスコーディングがトリガされます。アップロードされた QuickTime は、ブラウザやモバイルで再生できるように mp4 と webm の各形式に変換されます。場合によっては、このサーバ側のトランスコーディングを回避すると有用なときがあります。回避するには bypass_shotgun_transcoding 構成設定を指定します。true に設定すると、統合により Flow Production Tracking の Version.sg_uploaded_movie_mp4 フィールドに直接アップロードされるため、サーバ側のトランスコーディングが回避されます。この場合、webm バージョンが生成されないため、Firefox でレビューを再生できなくなります。詳細については、https://help.autodesk.com/view/SGSUB/JPN/?guid=SG_Supervisor_Artist_sa_review_approval_sa_transcoding_html を参照してください。ffmpeg をカスタマイズする書き出し機能で QuickTime を生成する場合は、Flame に付属する ffmpeg バージョンが使用されます。書き出し機能の設定フックを修正すると、組み込まれた ffmpeg の代わりに外部の ffmpeg バージョンを指定できます。Flame に付属する ffmpeg バージョンは ffmpeg のトランスコーディングとパフォーマンスの最新機能をトラッキングするため、最新バージョンを使用すると、パフォーマンスを改善できる可能性があります。h264 パラメータが ffmpeg に渡される方法は、既定のバージョンと最新バージョンとの間で変更されています。ffmpeg を最新バージョンに切り替えると、推奨するトランスコーディング ガイドラインを完全に実装できるため、Flow Production Tracking 側でアップロードとパフォーマンスが最適化されます。このガイドラインは以下を参照してください。https://help.autodesk.com/view/SGSUB/JPN/?guid=SG_Supervisor_Artist_sa_review_approval_sa_transcoding_htmlffmpeg バージョンの変更は上級ユーザのみにお勧めします。変更する場合は、次の手順に従ってください。設定フックをコピーする修正が必要なすべての設定は、Flame 書き出しアプリに付属する設定フック内にあります。このフックを修正するには、最初にアプリの場所の内部にある既定の場所からユーザの設定にこのフック ファイルをコピーする必要があります。通常、フック ファイルはプロジェクト設定内の install/apps/app_store/tk-flame-export/va.b.c/hooks/settings.py と同じような場所にあります。config/hooks など、設定内の hooks の場所にこのファイルをコピーします。分かりやすい名前にするため、単なる settings.py よりも、さらに詳細な名前を付けることをお勧めします。install/apps/app_store/tk-flame-export/va.b.c/hooks/settings.py -&amp;gt; config/hooks/flame_export_settings.pyそれでは Flame 環境設定ファイルを編集しましょう。通常は config/env/includes/flame.yml です。見出し tk-flame-export の下に、settings_hook: '{self}/settings.py' と定義されたフックのパスがあります。基本的に、環境設定はアプリの場所({self} など)内部でフック ファイルを探します。これを settings_hook: '{config}/flame_export_settings.py' に変更すると、代わりに環境設定内のフック ファイルを探すように Toolkit に指示されます。まとめると次のようになります。settings_hook: '{self}/settings.py' -&amp;gt; '{config}/flame_export_settings.py'フックを修正するこれで config/hooks/flame_export_settings.py フックを修正する準備ができました。テキスト エディタで開きます。ffmpeg に関連するメソッドと ffmpeg 設定があることにお気づきでしょう。最初に修正するのは次の項目です。def get_external_ffmpeg_location(self):    &quot;&quot;&quot;    Control which version of ffmpeg you want to use when doing transcoding.    By default, this hook returns None, indicating that the app should use    the built-in version of ffmpeg that comes with Flame.    If you want to use a different version of ffmpeg, simply return the path    to the ffmpeg binary here.    :returns: path to ffmpeg as str, or None if the default should be used.    &quot;&quot;&quot;    return None既定で None を返すことで、書き出し機能が Flame に組み込まれた ffmpeg を使用します。ffmpeg にフル パスを返すように変更します。Backburner クラスタを実行している場合は、クラスタ内のすべてのマシンから ffmpeg を呼び出せるため、実行可能ファイルは任意の場所にインストールされます。ffmpeg の場所を更新すると、おそらくは ffmpeg に渡されるパラメータを微調整することになります。これは次の異なる 2 つのメソッドで変更する必要があります。      get_ffmpeg_quicktime_encode_parameters は、Flow Production Tracking にアップロードする QuickTime を生成するときに使用されるパラメータを返します。        get_local_quicktime_ffmpeg_encode_parameters は、QuickTime をディスクに書き込むときに使用されるパラメータを返します。  Flow Production Tracking のアップロードの場合、最初は既定の Flow Production Tracking のエンコード設定を使用することをお勧めします。def get_ffmpeg_quicktime_encode_parameters(self):    return &quot;-vcodec libx264 -pix_fmt yuv420p -vf 'scale=trunc((a*oh)/2)*2:720' -g 30 -b:v 2000k -vprofile high -bf 0&quot;ローカルの Flow Production Tracking トランスコードの場合、Flow Production Tracking トランスコードに基づいて設定しながら、解像度の制限を削除してビット レートを増やすことをお勧めします。def get_local_quicktime_ffmpeg_encode_parameters(self):    return &quot;-vcodec libx264 -pix_fmt yuv420p -g 30 -b:v 6000k -vprofile high -bf 0&quot;",
    "url": "/04a6342b/",
    "relUrl": "/04a6342b/"
  },
  "145": {
    "id": "145",
    "title": "Flame のレビュー",
    "content": "Flame のレビューFlow Production Tracking Flame Review アプリにより、Flame の 1 つまたは複数のシーケンスを Flow Production Tracking Review に簡単にプッシュできます。レビュー対象の 1 つのシーケンスまたは一連のシーケンスを右クリックします。Flow Production Tracking Review のオプションを選択します。レビュー ノートを追加できる Toolkit の UI が表示されます。[OK]をクリックすると、バックグラウンド ジョブが生成され、すべての処理がシーンの背後で実行されます。次の手順が実行されます。      シーケンスが QuickTime 形式でディスクに書き出されます。この書き出しは Flame の QuickTime 書き出しとして処理され、設定フックを使用してさまざまな設定をすべて制御できます。        シーケンスが完了すると、Toolkit は Flow Production Tracking に一致するシーケンスがあるかどうかを確認します。一致するシーケンスがない場合は、シーケンスが自動的に作成されます。        レビュー バージョンが作成され、シーケンスと関連付けられます。        最後に、QuickTime はレビュー バージョンにアップロードされます。  このプロセスはオーディオ トラックやトランジションなどをサポートし、「見たままが得られる」ようになっています。Flow Production Tracking にアクセスすると、Client Review Site や Flow Production Tracking iPhone アプリなど、さまざまな方法でメディアをレビューできます。カスタマイズと設定Flame レビュー アプリはいくつかの異なる方法でカスタマイズすることができます。      Flame でシーケンスを表示するために Flow Production Tracking で使用するエンティティ タイプを制御できます。たとえば、エピソード形式のコンテンツで作業している場合は、レビュー バージョンを Flow Production Tracking のシーケンスよりもエピソードにリンクするほうが便利な場合があります。        Flow Production Tracking で作成された新しい項目に、アプリが自動的に追加するタスクをカスタマイズできます。このためにタスク テンプレート設定を使用すると、作成された構造を標準化できます。        フックを使用すると、アプリが Flame 以外で QuickTime を生成するために使用する XML プリセットを完全に制御できます。  ",
    "url": "/b38dc286/",
    "relUrl": "/b38dc286/"
  },
  "146": {
    "id": "146",
    "title": "Flame",
    "content": "FlameインストールFlow Production Tracking Engine for Flame は、Flame 2015 Extension 2 に追加されている新しい統合フックを使用します。エンジンを機能させるためには、このバージョンの Flame を使用する必要**があります。Flame 2015 Extension 2 の詳細(取得方法を含む)については、「Flame のサポート」を参照してください。Flow Production Tracking Engine for Flame の最も簡単な開始方法は、パイプライン設定例を使用して新しいテスト プロジェクトをセットアップすることです。それには、Flow Production Tracking Toolkit を起動して、新しいプロジェクトのプロジェクト セットアップを実行し、(既定の設定セクションで)既定の Flame 設定を選択します。サポート対象のアプリケーション バージョンこの項目はテスト済みです。次のアプリケーション バージョンで動作することが分かっています。2020+Flame プロジェクトのセットアップFlow Production Tracking Engine for Flame は Flow Production Tracking プロジェクトと Flame プロジェクトを関連付け、必要に応じてプロジェクトを作成します。Flame データが Flow Production Tracking の適切なデータと関連付けられるため、これが統合の鍵となります。追加機能として、エンジンには Flame プロジェクトの命名規則およびプロジェクトの他のさまざまな設定を管理するための機能が用意されています。Flame を Flow Production Tracking から初めて起動すると、Flame プロジェクト作成 UI が表示されるため、アーティストは標準的な Flame プロジェクト作成画面から通常の設定を編集できます。ただし、Flow Production Tracking と統合すると、パイプラインに最適な値があらかじめ設定されるため、アーティストは設定値について検討しなくてもすぐに使用することができます。既定値は project_setup_hook を介してカスタマイズできます。次のオプションをサポートしています。use_project_settings_ui True に設定すると、プロジェクト作成 UI が表示されます。False の場合、Flame プロジェクトはフック内の他の既定値に基づいて自動的に作成されます。get_server_hostname 既定では「localhost」に設定されますが、必要に応じてオーバーライドできます。get_project_name 既定では Flow Production Tracking プロジェクトと同じ値に設定されますが、必要に応じてオーバーライドできます。get_volume 既定では最初に利用可能なストレージに設定されますが、必要に応じてオーバーライドできます。get_workspace 既定では、Flame は標準的なワークスペース作成ロジックに従って既定のワークスペースを作成しますが、必要に応じてオーバーライドできます。get_user Flame マシンにログインしたユーザと Flow Production Tracking のユーザの関連付けを試行します。get_project_settings Flame のメイン設定を指定し、フックで Flame プロジェクト XML ストリームを構築する場所です。次のパラメータを指定する必要**があります。  FrameWidth (例: 1280)  FrameHeight (例: 1080)  FrameDepth (16-bit fp、12-bit、12-bit u、10-bit、8-bit)  FieldDominance (PROGRESSIVE、FIELD_1、FIELD_2)  AspectRatio (4:3、16:9、または文字列として浮動小数点値)プロキシ設定を指定することもできます。詳細については、Autodesk Wiretap SDK のドキュメントを参照してください。project_setup フックのコードベース全体を表示するには、「エンジンの Github リポジトリ」を参照してください。",
    "url": "/d5d7b724/",
    "relUrl": "/d5d7b724/"
  },
  "147": {
    "id": "147",
    "title": "管理 UI",
    "content": "Toolkit 管理 UI フレームワーク管理 UI フレームワークは、Toolkit 管理コマンドをラップする標準ユーザ インタフェースを保持する場所を実装します。現在、唯一のインタフェースは setup_project コマンドに対するものです。SetupProjectWizard API リファレンスこのフレームワークには QWizard が実装されており、Toolkit の Flow Production Tracking インスタンスからプロジェクトを設定できます。ウィザードを使用するには、クラスのインスタンスを作成し、設定するプロジェクトを標準の Flow Production Tracking API エンティティ ディクショナリとして渡し、親にするウィンドウを渡すだけです。adminui = sgtk.platform.import_framework(&quot;tk-framework-adminui&quot;, &quot;setup_project&quot;)setup = adminui.SetupProjectWizard(project, parent)dialog_result = setup.exec_()これによりウィザードが実行され、標準の QDialog Accepted または Rejected 値が返されます。SetupProjectWizard コンストラクタSetupProjectWizard を初期化します。これは、QtGui.QWizard のサブクラスです。SetupProjectWizard()",
    "url": "/02fa2cba/",
    "relUrl": "/02fa2cba/"
  },
  "148": {
    "id": "148",
    "title": "デスクトップ サーバ フレームワーク",
    "content": "Toolkit デスクトップ サーバ フレームワークデスクトップ サーバ フレームワークは、Flow Production Tracking のローカル ファイル リンクと Toolkit による統合で使用します。デスクトップ アクセスを必要とするアクションに、Flow Production Tracking Web サイトからの要求を安全にリッスンするローカル Websocket サーバを提供します。ローカル ファイル リンクの場合、この要求により、Flow Production Tracking は Web インタフェースからローカル ファイル パスにアクセスし、要求時に Flow Production Tracking ページからこのファイルを直接開くことができます。Toolkit の場合、この要求により、Flow Production Tracking は任意のエンティティに登録されたパイプライン アクションを特定し、そのアクションを実行できます。デスクトップ統合を実行する方法この Flow Production Tracking 機能を使用するには、サポートされたデスクトップ統合が実行されている必要があります。Flow Production Tracking とデスクトップを統合する場合のさまざまなオプションについては、こちらのページを参照してください。Websocket サーバのセクションでは、このフレームワークが提供する機能について説明します。Flow Production Tracking Toolkitこのフレームワークは、Flow Production Tracking Toolkit にバンドルされています。Desktop は、こちらに記載されている手順でダウンロードできます。Flow Production Tracking Toolkit を実行すると、Websocket サーバが自動的に起動されます。Flow Production Tracking Toolkit を既に実行している場合、セットアップ プロセスは完了しています。サーバを設定する設定ファイルにブラウザ統合設定を保存できます。この環境設定ファイルを指定するには、環境変数 SGTK_BROWSER_INTEGRATION_CONFIG_LOCATION を設定します。ローカル サーバの設定方法については、サンプル ファイルを参照してください。証明書を削除する作成した証明書を削除する場合は、python certificates.py --remove コマンドを実行することができます。ラッパーを使用して起動する既定では、サーバはオペレーティング システムの既定値を使用してコマンド(Linux では「xdg-open」、OS X では「open」、Windows では「run」に相当)を起動します。ファイルを起動するために独自のラッパーを指定する場合は、カスタム ラッパーを指定するように環境変数 SHOTGUN_PLUGIN_LAUNCHER を設定します。設定されている場合は、ラッパーはその唯一の引数としてパスで呼び出されます。証明書サーバを初めて実行すると、安全な接続の確立に必要な証明書が生成されます。この証明書はマシンのローカルに保存され、公開されることはありません。証明書により、Web ソケットで必要とされる暗号化された接続が可能になります。これはすべてのトラフィックがローカル(ブラウザからサーバ)のままでも必要です。Flow Production Tracking の Websocke トラフィックはインターネットで利用可能になることはありません。証明書がシステムに登録されると、次のようなダイアログが表示されます。登録を続行するには、[OK]をクリックしてください。  Flow Production Tracking Toolkit を使用する場合、生成された証明書は次の場所に保存されます。OS X: ~/Library/Caches/Shotgun/desktop/config/certificatesWindows: %AppData% Flow Production Tracking Toolkit config certificatesLinux: ~/.shotgun/desktop/config/certificatesセキュリティ セットアップ: ローカルの Flow Production Tracking にインストール既定では、Websocket サーバはポート 9000 でホストされる Flow Production Tracking サイトをリッスンするようにセットアップされます。ローカルで Flow Production Tracking サーバを実行する場合、Websocket サーバからの接続を許可するように、Flow Production Tracking サーバの設定を更新する必要があります。Flow Production Tracking Toolkit を実行する場合は、Flow Production Tracking のバイナリ ファイルを含む config.ini ファイルを設定する必要があります。このファイル内に Websocket サーバの機能を制御するセクションがあります。一般的な設定は次のようになります。[BrowserIntegration]low_level_debug=0port=9000enabled=1whitelist=*.shotgunstudio.comトラブルシューティングLinux 上でサーバは libffi に依存しています。Desktop が起動時にクラッシュし、libffi が見つからないというメッセージがログに記録された場合は、このパッケージをインストールする必要があります。セットアップ時に問題が発生したり、不明な点がある場合は、サポート サイトをご覧ください。サーバの実行に関して問題が発生する場合は、config.ini ファイルの debug を 1 に設定して、Desktop のログ ファイルを追加します。ログ ファイルは次の場所にあります。OS X: ~/Library/Logs/Shotgun/tk-desktop.logWindows: ~%APPDATA% Shotgun tk-desktop.logLinux: ~/.shotgun/tk-desktop.log",
    "url": "/c79f1656/",
    "relUrl": "/c79f1656/"
  },
  "149": {
    "id": "149",
    "title": "デスクトップ起動",
    "content": "Toolkit デスクトップ起動フレームワークデスクトップ起動フレームワークには、Flow Production Tracking Toolkit の起動ロジックが実装されています。主な機能は次のとおりです。  ブラウザの統合の初期化  ユーザのログイン  Toolkit のダウンロード  サイト構成の設定  自分自身の自動更新とサイト構成(必要な場合)  tk-desktop エンジンを起動します。  これは内部の Toolkit フレームワークなので、実装するインタフェースは変更される可能性があります。プロジェクトではこのフレームワークを使用しないことを推奨します。起動ロジックのロックダウン  これには、バージョン 1.3.4 の Flow Production Tracking Toolkit アプリが必要です。アプリケーションのバージョンが不明な場合は、Flow Production Tracking Toolkit を起動します。ログインしたら、右下のユーザ アイコンをクリックし、About... をクリックします。App Version は 1.3.4 以上でなければなりません。既定では、Flow Production Tracking Toolkit はユーザのローカル マシンに tk-framework-desktopstartup アップデートをダウンロードし、アプリケーションの起動シーケンス時に使用します。アプリケーションを起動すると、Toolkit は自動的にフレームワークの更新をチェックします。利用可能なアップデートがあれば、自動的にダウンロードしてインストールします。または、ローカル コピーではなくフレームワークの特定のコピーを使用するように Flow Production Tracking Toolkit を構成することもできます。これにより自動更新機能が無効になり、ユーザが自分自身が起動ロジックを更新できるようになります。GitHub から特定のリリースをダウンロードするGitHub から手動でアップデートをダウンロードする必要があります。バンドルは、リリース ページから簡単にダウンロードできます。公式リリースの詳細については、こちらを参照してください。特定のコピーを使用する場合の Flow Production Tracking Toolkit の設定起動ロジックをロックダウンする唯一の方法は環境変数を使用することです。SGTK_DESKTOP_STARTUP_LOCATION をフレームワークのコピーのルート フォルダに設定すると、Flow Production Tracking Toolkit は起動時にこのコードのコピーを使用します。環境変数を設定すると、このコピーの起動ロジックを使用して Flow Production Tracking Toolkit を起動できます。  本マニュアルの執筆時点では、技術的な制限のため、起動ロジックをロックするときに About... ボックスの Startup Version フィールドは Undefined になります。以前の動作に戻す変更を元に戻すには、環境変数の設定を解除して Flow Production Tracking Toolkit を起動します。",
    "url": "/3414fbb3/",
    "relUrl": "/3414fbb3/"
  },
  "150": {
    "id": "150",
    "title": "Hiero/Nuke Studio の書き出し",
    "content": "Hiero/Nuke Studio の書き出しはじめにこのアプリを使用すると、Flow Production Tracking は Hiero のシーケンス用の書き出しダイアログを認識するようになります。概要のビデオとデモFlow Production Tracking Toolkit や Hiero の統合が初めての場合は、次のビデオを視聴すると、Flow Production Tracking Toolkit や Hiero を統合した場合のパイプライン機能の概要が簡単に分かります。Toolkit と Hiero を既に使用している場合は、以降の説明をお読みください。Flow Production Tracking ショット プロセッサこのアプリ自体が起動すると、Hiero 書き出しダイアログに変更が登録されます。最初に、新しいプロセッサが登録されていることが分かります。このボタンをクリックすると、いくつかの変化があることが分かります。ダイアログの上部には、シーケンスの書き出し後に Flow Production Tracking でショットを作成または更新する方法を制御する UI が追加されています。タグドロップダウンを調整すると、さまざまな Hiero タグを Flow Production Tracking ショット ステータスとショット タスクのテンプレートにマッピングできます。そのため、Hiero のタグ設定ワークフローを実行して、Flow Production Tracking ショットを処理中に設定したり、グリーン スクリーンや CG などの任意の目的に合うようにショットのタスクを設定したりできます。この UI はフックを介して統合されるため、追加機能として簡単に設定できます。照合また、Hiero に組み込まれたロジックをミラーリングするトラック項目の照合を共に制御するオプションもあります。ショットを構成する複数の項目がある場合(異なるトラックでのオーバーラップまたは複数のトラック上の同一ショット名)、このオプションをオンにする必要があります。これにより、Flow Production Tracking Toolkit のショット更新ツールは、一致した照合項目を 1 つのショットとして処理します。たとえば、ショット 010 と 020 を表す 2 つのトラック項目があるとします。010 から始まり、020 は別のトラックで 010 の最後とオーバーラップします。010 が最初のトラック項目であり、Hiero の項目です。照合が有効になっているため、Flow Production Tracking はこの 2 つの項目を 1 つのショット 010 として処理され、ショット 010 は Flow Production Tracking で作成または更新されます。カットインはトラック項目 010 の先頭と一致し、カットアウトはトラック項目 020 の最後と一致します。Screening Room 対応バージョンは項目ごとに作成されますが、両方ともショット 010 にリンクされます。プレートは項目ごとにパブリッシュされたファイルとして作成されますが、両方ともショット 010 にリンクされます。1 つの Nuke スクリプトはショット 010 とリンクしてパブリッシュされます。2 つの読み取りノードが含まれ、項目ごとに 1 つのノードが割り当てられます。この場合、ショット 010 と照合しているため、Flow Production Tracking でショット 020 は作成または更新されません。パス次の Flow Production Tracking の UI は標準的なパス ダイアログです。既定で Hiero を介してショットに追加される項目は 3 つあります。既定の Nuke スクリプト、既定の Nuke 書き込み場所、プレート トランスコード用の既定の場所です。これらの項目の場所はアプリの設定によって決まり、テンプレート作成システムの機能をフル活用できます。このアプリによって、Hiero で {tk_version} トークンを使用できるようになります。このトークンはバージョン文字列で置き換えられ、Flow Production Tracking Toolkit 用に正しくフォーマットされます。カスタム テンプレートのフィールドcustom_template_fields 設定で定義されて resolve_custom_strings フックで解決されるトークンは、有効な置き換えトークンの Hiero のリストに自動的に追加され、Toolkit テンプレートパスで有効な置き換えとみなされます。たとえば、Toolkit templates.yml ファイルで次のようにキーを定義するとします。    resolution:        type: str        filter_by: alphanumeric  tk-hiero-export の project.yml 設定は次のようになります。  ...  ...  tk-hiero:    apps:      tk-hiero-export:        custom_template_fields:        - {description: Shot Resolution, keyword: resolution}  ...  ...その後、次のように resolve_custom_strings フックを修正します。# Copyright (c) 2014 Flow Production Tracking Software Inc.## CONFIDENTIAL AND PROPRIETARY## This work is provided &quot;AS IS&quot; and subject to the Flow Production Tracking Toolkit# Source Code License included in this distribution package. See LICENSE.# By accessing, using, copying or modifying this work you indicate your# agreement to the Flow Production Tracking Toolkit Source Code License. All rights# not expressly granted therein are reserved by Flow Production Tracking Software Inc.from tank import Hookclass HieroResolveCustomStrings(Hook):    &quot;&quot;&quot;Translates a keyword string into its resolved value for a given task.&quot;&quot;&quot;    RESOLUTION_TOKEN_NAME = &quot;{resolution}&quot;    def execute(self, task, keyword, **kwargs):        &quot;&quot;&quot;        &quot;&quot;&quot;        self.parent.log_debug(&quot;attempting to resolve custom keyword: %s&quot; % keyword)        if keyword == self.RESOLUTION_TOKEN_NAME:            translated_value = self._clip_resolution_string(task)        else:            raise RuntimeError(&quot;No translation handler found for custom_template_field: %s&quot; % keyword)        self.parent.log_debug(&quot;Custom resolver: %s -&amp;gt; %s&quot; % (keyword, translated_value))        return translated_value    # Handle the {resolution_fs} token    def _clip_resolution_string(self, task):        &quot;&quot;&quot; returns sequence resolution or task format override&quot;&quot;&quot;        width = &quot;&quot;        height = &quot;&quot;        sequence_format = task._sequence.format()        width = sequence_format.width()        height = sequence_format.height()        if &quot;reformat&quot; in task._preset.properties():            task_reformat_settings = task._preset.properties()[&quot;reformat&quot;]            if task_reformat_settings['to_type'] != &quot;None&quot;:                width = task_reformat_settings['width']                height = task_reformat_settings['height']        return &quot;%sx%s&quot; % (width, height)Hiero で resolution トークンを使用できるだけでなく、Toolkit で定義したテンプレート パスに照らして検証できるため、次のような場所に書き出せるようになります。    hiero_plate_path: &quot;sequences/{Sequence}/{Shot}/hiero_plates/{resolution}/v{version}/{project}_{Shot}.mov&quot;Flow Production Tracking タスク2 つの新しいタスク タイプが登録されました。Flow Production Tracking トランスコード イメージこれは、標準的な Hiero トランスコーディング タスクのサブクラス タスクです。トランスコードの結果をパブリッシュとして Flow Production Tracking に登録します。必要に応じて、Flow Production Tracking でバージョンも作成されます。バージョンが作成されると、QuickTime も作成され、Screening Room メディアとしてアップロードされます。Flow Production Tracking Nuke プロジェクト ファイルこれは、標準的な Hiero Nuke スクリプト書き出しのサブクラス タスクです。生成される Nuke スクリプトを PublishedFile としてショットにリンクされた Flow Production Tracking に登録します。この設定を使用すると、書き出し時にファイルに含める Toolkit 対応 WriteNode を指定できます。アプリ設定 plate_published_file_type と nuke_script_published_file_type を使用すると、PublishedFiles を登録する際のファイル タイプを制御できます。さらに、nuke_script_toolkit_write_nodes を使用すると、書き出しダイアログで利用可能な WriteNode 設定を制御できます。書き出しプロセス書き出しを実行すると、書き出しキューにいくつかの追加タスクが表示されます。各ショットは、Flow Production Tracking でのショットの作成と、スキーマ設定で指定した完全なショット構造の作成を行う Flow Production TrackingShotUpdater タスクを実行します。Flow Production Tracking でのシーケンスとショットの更新Hiero シーケンスの名前はシーケンス名として使用され、ショットにはカット情報が設定されます(カットの順序、ヘッド(イン)、カット(イン)、カット(アウト)、テール(アウト)、カットの長さ、作業期間)。また、ショットを構成するシーケンスまたは項目のポスター フレームが選択されている場合は、ショットのサムネイルとしてアップロードされます。ワークフローでショットの親としてシーケンス以外のエンティティ(エピソードなど)を使用する場合は、hook_get_shot フックの get_shot_parent メソッドをオーバーライドできます。既定の実装はシーケンスを(必要に応じて)作成し、返します。カット スキーマのサポートFlow Production Tracking サイトがカット スキーマ(v7.0.0 以降)をサポートしている場合、このアプリは Flow Production Tracking で対応するカット項目を使用してカットを自動的に生成します。このカットエンティティは Hiero シーケンスに対応し、カット項目はシーケンス内の項目に対応します。カットは、hook_get_shot フックの get_shot_parent メソッドで返される親エンティティ(既定ではシーケンス)にリンクされています。カット項目はショットエンティティと関連付けられ、書き出し時に作成されるレビュー可能なバージョンにリンクされます。書き出し後、カットは Flow Production Tracking と RV の[メディア] (Media)タブで再生可能になります。カットとカット項目エンティティに関連付けられたすべてのメタデータは、書き出し UI で指定可能な[カット タイプ] (Cut Type)フィールドを除いて Hiero から推定されます。この値はカットの[タイプ] (Type)フィールドに表示されます。いずれかの照合オプションが選択されている場合、カット スキーマはサポートされません。カットとカット項目エンティティの作成は省略されます。また、カット スキーマはリタイム クリップを処理しません。リタイム クリップを書き出すと、デバッグの警告がログに記録されます。代わりのショット階層標準的な「シーケンス &amp;gt; ショット」階層では作業しないが、エピソードやシーンを使用する可能性がある場合は、どのようなショット階層が使用されていてもアプリが連携するように設定可能な hiero_get_shot フックがあります。",
    "url": "/523d3720/",
    "relUrl": "/523d3720/"
  },
  "151": {
    "id": "151",
    "title": "Flow Production Tracking で Hiero/Nuke Studio を開く",
    "content": "Flow Production Tracking で Hiero/Nuke Studio を開くこのアプリによって、Hiero のスプレッドシートとタイムラインにコンテキスト メニューが追加されるため、任意のトラック項目にショットがある場合に、Flow Production Tracking でこの項目を表示することができます。通常、このアプリを設定する場合は、Flow Production Tracking Engine for Nuke の環境設定に次のコードを追加すると、Hiero のタイムラインとスプレッドシートのメニューにアプリが表示されます。    timeline_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: &quot;Open in Flow Production Tracking&quot;, requires_selection: true}    spreadsheet_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: &quot;Open in Flow Production Tracking&quot;, requires_selection: true}",
    "url": "/88ae1c1d/",
    "relUrl": "/88ae1c1d/"
  },
  "152": {
    "id": "152",
    "title": "Houdini Alembic Node",
    "content": "Houdini Alembic NodeHoudini Alembic Node アプリは、Alembic ファイルの出力場所を簡単に標準化できるカスタムの Flow Production Tracking Alembic 出力ノードを提供します。各環境に合わせた設定が可能です。一般用途Flow Production Tracking Alembic 出力を使用するには、最初にスクリプトを Toolkit 作業ファイルとして保存し、Houdini の TAB メニューから新しいノードを作成します。これにより、通常の Alembic 出力ノードに類似したノードが作成されます。このノードは複数の出力プロファイルを使用して設定できます。Alembic キャッシュをディスクに書き込む必要がある場合に、それぞれのプロファイルで異なるテンプレート パスを使用します。手動でパスを入力するのではなく、使用する出力プロファイルを指定するだけで、ノードが残りのパスを自動的に計算してくれます。UI には計算されたパスが表示されます。出力 Alembic ファイルはバージョンで管理され、バージョン番号は、Multi Publish を使用したパブリッシュ時に自動的に増分される現在の Houdini シーン ファイル バージョンに常に準拠します。環境設定Toolkit Alembic Node は、環境設定ごとに複数の出力プロファイルを指定することができます。次に、複数のプロファイルを使用したノードの設定例を示します。  tk-houdini:    apps:      tk-houdini-alembicnode:        location:          name: tk-houdini-alembicnode          type: app_store          version: v0.2.2        work_file_template: houdini_shot_work        default_node_name: tk_alembic_out        output_profiles:          - name: For Publishing            settings: {}            color: [1.0, 0.5, 0.0]            output_cache_template: houdini_shot_work_alembic_cache          - name: Local Testing            settings: {}            color: [0.0, 0.5, 1.0]            output_cache_template: houdini_shot_local_alembic_cachecolor フィールドを介してノードの外観を変更するために出力プロファイルを使用したり、基本の Alembic ノードで個別のパラメータを調整するために settings フィールドにそのパラメータと一致するキーと値のペアを入力したりできます。最後に、output_cache_template フィールドは、ディスクに書き込まれる Alembic キャッシュの出力パスを操作します。",
    "url": "/55f75584/",
    "relUrl": "/55f75584/"
  },
  "153": {
    "id": "153",
    "title": "Houdini Mantra Node",
    "content": "Houdini Mantra NodeHoudini Mantra Node アプリは、レンダリング ファイルの出力場所を簡単に標準化できるカスタムの Flow Production Tracking Mantra 出力ノードを提供します。各環境に合わせた設定が可能です。一般用途Flow Production Tracking Mantra Node を使用するには、最初にスクリプトを Toolkit 作業ファイルとして保存し、Houdini の TAB メニューから新しいノードを作成します。これにより、通常の Mantra 出力ノードに類似したノードが作成されます。このノードは複数の出力プロファイルを使用して設定できます。レンダリング出力(イメージ、ifd、dcm、aov など)をディスクに書き込む必要がある場合に、それぞれのプロファイルで一連の異なるテンプレート パスを使用します。手動でパスを入力するのではなく、使用する設定を指定するだけで、ノードが残りのパスを自動的に計算してくれます。UI には計算されたパスが表示されます。レンダリングされたファイルはバージョンで管理され、バージョン番号は、Multi Publish を使用したパブリッシュ時に自動的に増分される現在の Houdini シーン ファイル バージョンに常に準拠します。環境設定Toolkit Mantra Node は、環境設定ごとに複数の出力プロファイルを指定することができます。次に、複数のプロファイルを使用したノードの設定例を示します。  tk-houdini:    apps:      tk-houdini-mantranode:        location:          name: tk-houdini-mantranode          type: dev          version: v0.2.2        default_node_name: tk_mantra_out        work_file_template: houdini_shot_work        output_profiles:          - name: Primary Render            settings: {}            color: [1.0, 0.5, 0.0]            output_render_template: houdini_shot_render            output_ifd_template: houdini_shot_ifd            output_dcm_template: houdini_shot_dcm            output_extra_plane_template: houdini_shot_extra_plane          - name: Local Render            settings: {}            color: [0.0, 0.5, 1.0]            output_render_template: houdini_shot_local_render            output_ifd_template: houdini_shot_local_ifd            output_dcm_template: houdini_shot_local_dcm            output_extra_plane_template: houdini_shot_local_extra_planecolor フィールドを介してノードの外観を変更するために出力プロファイルを使用したり、基本の Alembic ノードで個別のパラメータを調整するために settings フィールドにそのパラメータと一致するキーと値のペアを入力したりできます。最後に、output_*_template フィールドは、Mantra レンダラによってディスクに書き込まれるファイルの出力パスを操作します。",
    "url": "/2c47f879/",
    "relUrl": "/2c47f879/"
  },
  "154": {
    "id": "154",
    "title": "Houdini",
    "content": "HoudiniFlow Production Tracking Engine for Houdini は、Flow Production Tracking アプリと Houdini を統合するための標準プラットフォームを提供します。アプリ開発者向けの情報サポートされているプラットフォーム現在、Flow Production Tracking Engine for Houdini は Windows、Linux、OSX でサポートされています。サポート対象のアプリケーション バージョンこの項目はテスト済みです。次のアプリケーション バージョンで動作することが分かっています。17.5 - 19.5 Note: Running on Apple Silicon (M1/M2), Houdini is supported for both Native mode and Rosetta mode.PySide古いバージョンの Houdini (13 以前)の場合、PySide の外部ビルドが必要です。Windows の場合、Houdini が実行する Python と連携する、互換性のある PySide ビルドがバンドルされています。Linux の場合、Houdini は PySide または PyQt のサポートが必要な Python システム(https://www.sidefx.com/docs/houdini12.0/hom/)を使用しています。メニューのロードHoudini 15 以降では、Side Effects により動的メニュー システムが導入され、このエンジンでコンテキスト切り替え時に Flow Production Tracking メニューの再構築がサポートされるようになりました。Houdini 14 以前では、Houdini の Flow Production Tracking メニューは Houdini の起動前に生成され、セッション全体で固定されます。このため、メニューに登録されている Toolkit コマンドは、コンテキストが変更されても更新されません。Flow Production Tracking シェルフリリース v0.2.4 では、エンジンに動的 Flow Production Tracking シェルフが導入されています。このシェルフでは登録されたアプリ コマンドがツール ボタンとして表示されます。ボタンはメニュー コマンドとほとんど同じ順序で表示されます。環境内のシェルフをオンにするには enable_sg_shelf 設定を使用します。動的メニューをサポートしないバージョンの Houdini (14 以前)を使用する場合、シェルフの使用時に Flow Production Tracking メニューをオフにすることもできます。その場合は、enable_sg_menu 設定を false に設定します。シェルフを使用したコンテキストの切り替えを有効にするには、エンジン設定の tk-multi-workfiles アプリの sg_entity_types 設定にエンティティ タイプも追加する必要があります。次に、Flow Production Tracking シェルフに関連する設定を示します。tk-houdini:  apps:    # ... other app definitions    tk-multi-workfiles:       # ... other app settings       sg_entity_types: [Shot, Asset] # allow context switching to Shots or Assets       # ... other app settings  enable_sg_shelf: true  enable_sg_menu: false  # ... other engine settingsFlow Production Tracking シェルフを有効にしたら、Houdini 内で設定したシェルフに手動で追加する必要があります。Flow Production Tracking シェルフをシェルフ セットに追加すると Houdini セッション間をまたいで保持されますが、Flow Production Tracking コンテキストが変更されると動的に更新されます。パネルv0.2.8 以降のエンジンでは、埋め込み Toolkit パネルのサポートを追加できます。埋め込まれた適切なパネルをサポートするには、15.0.272 以降のバージョンの Houdini が必要です。登録パネルは、サポート対象バージョンの Houdini でペイン メニューのペインとして表示されます。古いバージョンの Houdini では登録パネルがダイアログとして表示されます。SESI はいくつかのバグ修正を Houdini 14 の最新ビルドに移植する場合があります。その場合は、埋め込みパネルがそれぞれのバージョンで動作するようにします。OTL を使用したアプリFlow Production Tracking Engine for Houdini を使用すると、アプリケーションによって提供される OTL ファイルを簡単にロードできます。OTL を使用するアプリを作成する場合、otls と呼ばれるフォルダにドロップするだけで、エンジンがアプリをセッションに自動的にロードします。通常の Houdini メソッドからノードに簡単にアクセスできます。警告:OTL の使用は便利ですが、シーン内で保持されるノードを作成する場合、一般的には適切な解決方法ではありません。その理由は、シーン内に OTL を配置するとすぐに、このシーンと OTL コードの間に依存関係が生まれるためです。シーンのロードのたびに Flow Production Tracking Toolkit をロードする必要があるだけでなく、コードを更新するときにシーン内で使用されている古い OTL が分割されないように慎重に管理する必要もあります。OSX のターミナルからデバッグを起動するOS X で、tk-houdini の debug_logging をオンにしても、すべてのデバッグ メッセージがターミナルに送信されるわけではありません。これは、既定では、tk-multi-launchapp アプリが実行可能ファイルの起動に open コマンドを使用するためです。これでターミナルから新しいサブプロセスがスポーンされることはありませんが、代わりに OS X の起動サービスを使用して新しい場所が作成されます。その結果、ログのステートメントが表示されなくなります。Houdini でユーザの既定のデスクトップに Python シェルを保存しても、起動時にデバッグのステートメントは表示されないようです。起動後、埋め込み Python シェルはデバッグ ログのステートメントを表示しますが、起動時に使用可能な出力にはずれが生じます。エンジンの起動時にデバッグ ログのステートメントにアクセスする必要がある場合は、次の 2 つの変更を行います。最初に、Houdini アプリ バンドル内の実行可能ファイルを指定するようにテスト設定で houdini_mac パスを(一時的に)変更します。以下に例を示します。#houdini_mac: /Applications/Houdini 15.0.272/Houdini Apprentice.apphoudini_mac: /Applications/Houdini  15.0.272/Houdini  Apprentice.app/Contents/MacOS/happrentice次に、テスト設定の config/hooks ディレクトリの tk-multi-launchapp アプリの app_launch フックのコピーを作成し、config/env/includes/app_launchers.yml ファイルでそのコピーを指定します。launch_houdini:  defer_keyword: ''  engine: tk-houdini  extra: {}  hook_app_launch: app_launch    # &amp;lt;----- use a custom app_launch hook  hook_before_app_launch: default  icon: '{target_engine}/icon_256.png'  linux_args: ''  linux_path: '@houdini_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.6.6}  mac_args: ''  mac_path: '@houdini_mac'  menu_name: Launch Houdini  versions: []  windows_args: ''  windows_path: '@houdini_windows'その後は実行可能ファイルを直接起動するように起動ロジックを修正するだけです。たとえば、ディレクトリの古い動作(アプリケーション バンドル)を維持し、それ以外のコマンドを直接実行するとします。次に例を示します。        elif system == &quot;darwin&quot;:            # on the mac, the executable paths are normally pointing            # to the application bundle and not to the binary file            # embedded in the bundle, meaning that we should use the            # built-in mac open command to execute it            if os.path.isdir(app_path):                cmd = &quot;open -n  &quot;%s &quot;&quot; % (app_path)                if app_args:                    cmd += &quot; --args  &quot;%s &quot;&quot; % app_args.replace(&quot; &quot;&quot;, &quot;   &quot;&quot;)            # not a directory, execute directly            else:                cmd = &quot;%s %s&quot; % (app_path, app_args.replace(&quot; &quot;&quot;, &quot;   &quot;&quot;))ターミナルで tank を使用して launch_houdini を実行すると、すべてのデバッグ出力を取得できます。テストが完了したら、パスを元に戻して、アプリ起動の変更を取り消してください。デバッグの成功をお祈りします。",
    "url": "/797202da/",
    "relUrl": "/797202da/"
  },
  "155": {
    "id": "155",
    "title": "Mari プロジェクト マネージャ",
    "content": "Mari プロジェクト マネージャMari プロジェクト マネージャは Mari での新しいプロジェクトの作成プロセスを合理化します。アーティストは Flow Production Tracking ローダーを使用して、ロードするパブリッシュ済みジオメトリをすぐに選択できます。このアプリ内で作成されるプロジェクトは Flow Production Tracking に対応しているため、アーティストは書き出しオプションやファイルの場所を気にすることなく、パイプラインの他の部分にテクスチャをパブリッシュできます。",
    "url": "/82aaf735/",
    "relUrl": "/82aaf735/"
  },
  "156": {
    "id": "156",
    "title": "Mari",
    "content": "MariFlow Production Tracking Engine for Mari は、Flow Production Tracking Toolkit アプリと Mari を統合するための標準プラットフォームを提供します。軽量で操作性に優れており、メイン メニューに Flow Production Tracking のメニューを追加します。サポート対象のアプリケーション バージョンこの項目はテスト済みです。次のアプリケーション バージョンで動作することが分かっています。4.0 - 6.0v2最新のリリースでの動作は十分可能ですが、正式なテストはまだ完了していません。概要ビデオ概要ビデオについては、こちらを参照してください。インストールと更新Flow Production Tracking Toolkit にこのエンジンを追加するProject XYZ にこのエンジンを追加するには、asset という名前の環境で次のコマンドを実行します。&amp;gt; tank Project XYZ install_engine asset tk-mari最新バージョンに更新するこの項目が既にプロジェクトにインストールされている場合に最新バージョンを取得するには、update コマンドを実行します。特定のプロジェクトに含まれている tank コマンドに移動し、そこでこのコマンドを実行します。&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updatesまたは、tank コマンドを実行し、プロジェクトの名前を指定して、更新チェックを実行するプロジェクトを指定します。&amp;gt; tank Project XYZ updatesコラボレーションと発展Flow Production Tracking Toolkit にアクセスできる場合は、すべてのアプリ、エンジン、およびShotGridのソース コードにも Github からアクセスできます。オートデスクでは、これらのソース コードを Github で格納および管理しています。これらの項目は自由に発展させてください。さらなる独立した開発用の基盤として使用したり、変更を加えたり(その際はプル リクエストを送信してください)、 いろいろと研究してビルドの方法やツールキットの動作を確認してください。このコード リポジトリには、https://github.com/shotgunsoftware/tk-mari からアクセスできます。",
    "url": "/301f5e66/",
    "relUrl": "/301f5e66/"
  },
  "157": {
    "id": "157",
    "title": "Error {% include product %} tk-maya An exception was raised from Toolkit",
    "content": "Error: Flow Production Tracking tk-maya: An exception was raised from Toolkit使用例実行がトリガされたときにカスタム引数を受け取るように Toolkit アプリを設定することができます。たとえば、アプリを実行するときに、状態に応じて異なる方法でアプリが起動するように設定するある種の状態フラグを指定することができます。次に、このフラグの使用例をいくつか示します。  tk-shotgun-folders アプリ(Shotgun Web アプリで選択したエンティティに基づいてフォルダを作成する)には、ユーザが Shotgun Web アプリで選択して、それに対してアクションを実行した Shotgun エンティティとエンティティ タイプが渡されます(https://github.com/shotgunsoftware/tk-shotgun-folders/blob/v0.1.7/app.py#L86)。  tk-multi-launchapp (Shotgun 統合を使用してソフトウェアを起動する)には、file_to_open 引数を渡すことができます。この引数は、ソフトウェアの起動後にファイルを開く場合に使用します(https://github.com/shotgunsoftware/tk-multi-launchapp/blob/v0.11.2/python/tk_multi_launchapp/base_launcher.py#L157)。通常、Flow Production Tracking Toolkit を使用してソフトウェアを起動した場合は、file_to_open 引数が提供されませんが、一元管理設定(tank maya_2019 /path/to/maya/file.mb)を使用している場合は、tank コマンドをを使用してアプリを呼び出すことができます。また、tk-shotgun-launchpublish アプリによって tk-multi-launchapp が起動し、パブリッシュされたファイルが file_to_open 引数として提供されます。https://github.com/shotgunsoftware/tk-shotgun-launchpublish/blob/v0.3.2/hooks/shotgun_launch_publish.py#L126-L133引数を受け入れるようにアプリをプログラミングするカスタム アプリを作成する場合に必要なことは、必要な引数を受け入れるためにエンジンに登録されるコールバック メソッドを設定することだけです。次に、2 つの必須の引数のほかに追加の引数を受け入れて、これらを出力するように設定された単純なアプリを示します。from sgtk.platform import Applicationclass AnimalApp(Application):    def init_app(self):        self.engine.register_command(&quot;print_animal&quot;, self.run_method)    def run_method(self, animal, age, *args):        print (&quot;&quot;,animal)        print (&quot;age&quot;,age)        print (&quot;args&quot;, args)Tank コマンドから実行するここで、シェルで次の tank コマンドを実行するとします。 ./tank print_animal cat 7 Tortoiseshell largeすると、次のように出力されます。...----------------------------------------------------------------------Command: Print animal----------------------------------------------------------------------libpng warning: iCCP: known incorrect sRGB profile('animal', 'cat')('age', '7')('args', ('Tortoiseshell', 'large'))スクリプトから実行するtk-shell エンジンのスクリプトからアプリを呼び出す場合は、次の操作を実行できます。# This assumes you have a reference to the `tk-shell` engine.engine.execute_command(&quot;print_animal&quot;, [&quot;dog&quot;, &quot;3&quot;, &quot;needs a bath&quot;])&amp;gt;&amp;gt;# ('animal', 'dog')# ('age', '3')# ('args', ('needs a bath',))Maya では、次のような操作を実行します。import sgtk# get the engine we are currently running in.engine = sgtk.platform.current_engine()# Run the app.engine.commands['print_animal']['callback'](&quot;unicorn&quot;,4,&quot;it's soooo fluffy!!!!&quot;)&amp;gt;&amp;gt;# ('animal', 'unicorn')# ('age', 4)# ('args', (&quot;it's soooo fluffy!!!!&quot;,))エラー メッセージMaya のメニューからアプリを起動しようとすると、次のようなエラーが表示されます。// Error: Shotgun tk-maya: An exception was raised from ToolkitTraceback (most recent call last):  File &quot;/Users/philips1/Library/Caches/Shotgun/bundle_cache/app_store/tk-maya/v0.10.1/python/tk_maya/menu_generation.py&quot;, line 234, in _execute_within_exception_trap    self.callback()  File &quot;/Users/philips1/Library/Caches/Shotgun/mysite/p89c1.basic.maya/cfg/install/core/python/tank/platform/engine.py&quot;, line 1082, in callback_wrapper    return callback(*args, **kwargs)TypeError: run_method() takes at least 3 arguments (1 given) //これは、アプリが引数を必要とするように設定されているのに、メニュー ボタンが引数を提供するよう指定されていないためです。修正方法次のようなキーワード引数を使用するようにアプリの run_method を記述することをお勧めします。    def run_method(self, animal=None, age=None, *args):        print (&quot;&quot;,animal)        print (&quot;age&quot;,age)        print (&quot;args&quot;, args)こうすると、引数が提供されない場合の動作を処理し、フォールバック動作を実装することができます。コミュニティの完全なスレッドを参照してください。",
    "url": "/0c5e6ac8/",
    "relUrl": "/0c5e6ac8/"
  },
  "158": {
    "id": "158",
    "title": "Maya",
    "content": "MayaFlow Production Tracking Engine for Maya は、Flow Production Tracking アプリと Maya を統合するための標準プラットフォームを提供します。軽量で操作性に優れており、Maya のメニュー バーに Flow Production Tracking のメニューを追加します。サポート対象のアプリケーション バージョンこの項目はテスト済みです。次のアプリケーション バージョンで動作することが分かっています。2020 - 2024 Note: Apple Silicon (M1/M2) native is supported starting with Maya 2024.最新のリリースでの動作は十分可能ですが、正式なテストはまだ完了していません。PySideFlow Production Tracking Engine for Maya には PySide がインストールされており、必要に応じて有効になります。Maya のプロジェクト管理Flow Production Tracking Engine for Maya が起動すると、このエンジンの設定で定義された場所を Maya プロジェクトが参照するように設定されます。つまり、新しいファイルを開くと、このプロジェクトも変更される場合があります。ファイルに基づく Maya プロジェクトの設定方法に関連する詳細設定は、テンプレート システムを使用して設定ファイルで指定できます。インストールと更新このエンジンを Flow Production Tracking Toolkit に追加します。このエンジンを Project XYZ に追加して、さらに asset という環境に追加するには、次のコマンドを実行します。&amp;gt; tank Project XYZ install_engine asset tk-maya最新バージョンに更新するこの項目が既にプロジェクトにインストールされている場合に最新バージョンを取得するには、update コマンドを実行します。特定のプロジェクトに含まれている tank コマンドに移動し、そこでこのコマンドを実行します。&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updatesまたは Studio の tank コマンドを実行し、プロジェクトの名前を指定して、更新チェックを実行するプロジェクトを指定します。&amp;gt; tank Project XYZ updatesコラボレーションと発展Flow Production Tracking Toolkit にアクセスできる場合は、すべてのアプリ、エンジン、およびフレームワークのソース コードにも Github からアクセスできます。これらは Github を使用して格納および管理しています。これらの項目は自由に発展させてください。さらなる独立した開発用の基盤として使用したり、変更を加えたり(その際はプル リクエストを送信してください)、 いろいろと研究してビルドの方法やツールキットの動作を確認してください。このコード リポジトリには、https://github.com/shotgunsoftware/tk-maya からアクセスできます。",
    "url": "/9e62da4a/",
    "relUrl": "/9e62da4a/"
  },
  "159": {
    "id": "159",
    "title": "Motion Builder",
    "content": "Motion BuilderFlow Production Tracking Engine for Motion Builder は、Flow Production Tracking Toolkit アプリと MotionBuilder を統合するための標準プラットフォームを提供します。軽量で操作性に優れており、メイン メニューに Flow Production Tracking のメニューを追加します。サポート対象のアプリケーション バージョンこの項目はテスト済みです。次のアプリケーション バージョンで動作することが分かっています。2020 - 2024最新のリリースでの動作は十分可能ですが、正式なテストはまだ完了していません。インストールと更新Flow Production Tracking Toolkit にこのエンジンを追加するProject XYZ にこのエンジンを追加するには、asset という名前の環境で次のコマンドを実行します。&amp;gt; tank Project XYZ install_engine asset tk-motionbuilder最新バージョンに更新するこの項目が既にプロジェクトにインストールされている場合に最新バージョンを取得するには、update コマンドを実行します。特定のプロジェクトに含まれている tank コマンドに移動し、そこでこのコマンドを実行します。&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updatesまたは Studio の tank コマンドを実行し、プロジェクトの名前を指定して、更新チェックを実行するプロジェクトを指定します。&amp;gt; tank Project XYZ updatesコラボレーションと発展Flow Production Tracking Toolkit にアクセスできる場合は、すべてのアプリ、エンジン、およびフレームワークのソース コードにも Github からアクセスできます。これらは Github を使用して格納および管理しています。これらの項目は自由に発展させてください。さらなる独立した開発用の基盤として使用したり、変更を加えたり(その際はプル リクエストを送信してください)、 いろいろと研究してビルドの方法やツールキットの動作を確認してください。このコード リポジトリには、https://github.com/shotgunsoftware/tk-motionbuilder からアクセスできます。",
    "url": "/54009c12/",
    "relUrl": "/54009c12/"
  },
  "160": {
    "id": "160",
    "title": "概要",
    "content": "概要このアプリは、現在の作業領域と現在の環境で実行しているすべてのアプリの詳細情報をグラフィカルに表示します。コンテキスト メニューからアクセスできます。すべてのアプリをリロードするこのアプリには、環境全体をリロードする便利なボタンがあります。これは、開発中に一部のコードを変更する場合に便利です。Maya や Nuke を再起動せず、リロード ボタンをクリックするだけです。リロード機能とは別に、このアプリは、現在の作業領域と現在ロードされているすべてのアプリの詳細情報を表示します。次の 3 つの異なるビューがあります。現在の作業領域ここには現在のショット、アセット、タスクなどが表示されます。リスト内の項目をダブル クリックすると、その項目の Flow Production Tracking の[詳細] (Detail)ページが表示されます。実行中のアプリ現在実行中のすべてのアプリおよびそのバージョンと説明を表示します。アプリをダブル クリックすると、そのアプリのマニュアル ページが開きます。現在の環境現在ロードされている環境ファイルとエンジンを表示します。これはデバッグの際に便利です。",
    "url": "/c542e4dd/",
    "relUrl": "/c542e4dd/"
  },
  "161": {
    "id": "161",
    "title": "詳細情報",
    "content": "詳細情報Scene Breakdown アプリは、参照コンテンツのリストを表示し、期限切れの項目を通知します。Flow Production Tracking メニューから利用できます。1 つまたは複数の項目を選択し、選択項目の更新をクリックします。これにより、最新バージョンのコンテンツを使用するよう項目が切り替わります。シーンをスキャンするBreakdown アプリが参照用にシーンをスキャンする場合は、特別なスキャン フックが呼び出されます。このスキャン フックは、ファイルに対応したパスを含むノードのリストを返します。検出した各参照はファイル パスを返し、Tank がファイル パスを確認して、パブリッシュとして認識するかどうかを最初にチェックし、パブリッシュとして認識した場合には、最新バージョンが利用可能かどうかを確認します。ユーザが古いバージョンに表示される更新ボタンをクリックすると、アプリは実際の更新作業を実行する別のフックを呼び出します。つまり、このフックをカスタマイズすることで、Breakdown に新しいカスタム ノードを比較的簡単に追加できます。Flow Production Tracking のデータにアクセスするフック内で更新しようとしているパブリッシュ用の Flow Production Tracking データにアクセスする必要がある場合、次のように find_publish を 1 回呼び出すだけで、アプリで受け渡しを行う全項目のメタデータを取得できます。class BreakdownHook(Hook):    def update(self, items):        &quot;&quot;&quot;        Perform replacements given a number of scene items passed from the app.        Once a selection has been performed in the main UI and the user clicks        the update button, this method is called.        The items parameter is a list of dictionaries on the same form as was        generated by the scan_scene hook above. The path key now holds        the that each node should be updated *to* rather than the current path.        &quot;&quot;&quot;        engine = self.parent.engine        # resolve Flow Production Tracking data for all paths passed via the items dictionary        sg_data = tank.util.find_publish(engine.sgtk,                                         [i[&quot;path&quot;] for i in items],                                         fields=[&quot;id&quot;, &quot;code&quot;, &quot;version_number&quot;])        for i in items:            node_name = i[&quot;node&quot;]            node_type = i[&quot;type&quot;]            new_path = i[&quot;path&quot;]            # now that each item is processed, it is easy to access the            # Flow Production Tracking data via a dictionary lookup:            sg_data = sg_data.get(i[&quot;path&quot;])            # once we have all our desired info and metadata, we can go ahead            # and apply the update business logic.            # [-business logic here-]API アクセスAPI を使用すると、プログラムによって Breakdown アプリにアクセスできます。次のようなメソッドがあります。Breakdown の UI を表示するapp_object.show_breakdown_dialog()Breakdown の UI を表示するには、show_breakdown_dialog() メソッドを実行します。アプリが現在実行している環境の tk-multi-breakdown セクションに含まれていると仮定すると、次のように実行できます。&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; e = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; e.apps[&quot;tk-multi-breakdown&quot;].show_breakdown_dialog()シーン解析を実行するitems = app_object.analyze_scene()analyze_scene() メソッドを使用すると、プログラムによってシーン解析ロジックを実行できます。これにより、Breakdown の UI がシーン項目のリストを作成するときに使用するのとまったく同じロジックが実行されます。このメソッドは、詳細情報項目のリストを返します。各項目は、項目を定義する複数のキーが含まれるディクショナリによって表されます。検出されるのは、パスが Toolkit テンプレート ファイルのテンプレートに対応するファイルのみです。Flow Production Tracking にパブリッシュ ファイルは必要はありませんが、パブリッシュ ファイルがある場合、このメソッドは基本的な Flow Production Tracking パブリッシュ メタデータを返します。node_name と node_type の 2 つのキーを使用すると、DCC 中心の「アドレス」またはリプリゼンテーションが返されるため、DCC 内のパスを特定できます。たとえば、Maya と Nuke の場合、ノード名とタイプを返します。このロジックはフックに実装され、DCC 間で異なります。このメソッドは Flow Production Tracking への接続を試行しますが、実行される呼び出しの数は一定で、シーンの複雑さとは関係ありません。次に、返されるデータ内のディクショナリの一般的な例を示します。{'fields': {'Sequence': 'aaa',            'Shot': 'aaa_00010',            'Step': 'Comp',            'eye': '%V',            'height': 1556,            'name': 'test',            'output': 'output',            'version': 1,            'width': 2048}, 'template': &amp;lt;Sgtk TemplatePath nuke_shot_render_pub_mono_dpx&amp;gt;, 'node_name': 'Read2', 'node_type': 'Read', 'sg_data': {'code': 'aaa_00010_test_output_v001.%04d.dpx',             'entity': {'id': 1660, 'name': 'aaa_00010', 'type': 'Shot'},             'id': 1424,             'name': 'test',             'published_file_type': {'id': 3,                                     'name': 'Rendered Image',                                     'type': 'PublishedFileType'},             'task': {'id': 4714, 'name': 'Comp', 'type': 'Task'},             'type': 'PublishedFile',             'project': {'id': 234, 'name': 'Climp', 'type': 'Project'},             'version_number': 1}, }ヒント: 上記から分かるように、各項目はパスを表すために template オブジェクトと fields ディクショナリを返します。この項目について実際の未処理のパスを確認するには、template_obj.apply_fields(fields_dict) を実行します。このメソッドで返されるいずれかのディクショナリ項目のコンテキストでは、コードが次のようになりますbreakdown_items = analyze_scene()for item in breakdown_items:   path = item[&quot;template&quot;].apply_fields(item[&quot;fields&quot;])項目の最新バージョンを計算するhighest_version = app_object.compute_highest_version(template, fields)項目の最新バージョンを計算するには、compute_highest_version(template, fields) メソッドを使用します。パラメータ template と fields は解析すべきパスを表し、通常は analyze_scene() メソッドの出力から取得します。Breakdown アプリを使用する場合は、バージョン番号を含むテンプレート キーを常に {version} という名前にする必要があります。これにより、ディスクをスキャンして最新バージョンを判断します。このメソッドはディスク上の最新バージョン番号を返します。詳細については、次の使用例を参照してください。シーン項目を更新するapp_object.update_item(node_type, node_name, template, fields)項目を更新するには update_item(node_type, node_name, template, fields) メソッドを使用します。パラメータ template と fields は更新する必要のあるパスを表します。パラメータ node_name と node_type を使用すると、修正する必要のあるシーン内のノードを特定できます。通常、この値は analyze_scene() メソッドの出力から取得します。これは、Breakdown の UI で更新を実行する場合に似ています。実際の更新の呼び出しは、DCC 固有のロジックを処理するフックにディスパッチされます。詳細については、次の使用例を参照してください。Breakdown の API の例次の例では、シーンの内訳を取得し、最新バージョンを使用していないすべての項目を更新する方法について説明します。# find the breakdown app instanceimport sgtkengine = sgtk.platform.current_engine()breakdown_app = engine.apps[&quot;tk-multi-breakdown&quot;]# get list of breakdown itemsitems = breakdown_app.analyze_scene()# now loop over all itemsfor item in items:    # get the latest version on disk    latest_version = breakdown_app.compute_highest_version(item[&quot;template&quot;], item[&quot;fields&quot;])    # if our current version is out of date, update it!    current_version = item[&quot;fields&quot;][&quot;version&quot;]    if latest_version &amp;gt; current_version:        # make a fields dictionary representing the latest version        latest_fields = copy.copy(item[&quot;fields&quot;])        latest_fields[&quot;version&quot;] = latest_version        # request that the breakdown updates to the latest version        breakdown_app.update_item(item[&quot;node_type&quot;], item[&quot;node_name&quot;], item[&quot;template&quot;], latest_fields)",
    "url": "/3c0c0ab6/",
    "relUrl": "/3c0c0ab6/"
  },
  "162": {
    "id": "162",
    "title": "デモ",
    "content": "デモDemo アプリでは、Flow Production Tracking Utilities フレームワーク、Qt ウィジェット フレームワーク、Toolkit コアなど、Flow Production Tracking のネイティブ開発プラットフォーム コンポーネントのライブ デモを視聴できます。アプリに表示される各デモには、ネイティブ プラットフォームの 1 つまたは複数のコンポーネントを使用する方法を示す、動作可能でインタラクティブな UI が含まれています。さらに、実行しているコードは、自分のアプリに簡単にコピーして貼り付けることができます。アプリは簡単に使用できます。左側のリストからデモを選択し、右側のコンポーネントを操作します。一部のデモは、Qt ウィジェット フレームワークから単一のウィジェットを表示するだけです。Flow Production Tracking プラットフォーム コンポーネントをプロダクション アプリで使用する場合の一般的な接続例を紹介するデモもあります。新しいデモは、新しいコンポーネントがプラットフォームに追加されたのち、時間があるときに追加されます。コンポーネントの使用法に一定のパターンがある場合や、ご覧になりたいデモがある場合は、サポート リクエストからお知らせください。インストールDemo アプリをインストールするには、次のコマンドを実行します。tank install_app project tk-shell tk-multi-demoインストールしたら、次のコマンドを実行するとアプリを起動できます。./tank demos",
    "url": "/42395ae7/",
    "relUrl": "/42395ae7/"
  },
  "163": {
    "id": "163",
    "title": "アプリを起動",
    "content": "アプリを起動このアプリを使用すると、Flow Production Tracking からサポート対象のアプリケーションに簡単に移動できます。選択した設定に応じて、Flow Production Tracking のさまざまなエンティティを呼び出す Flow Production Tracking アクション項目を登録します。仕組み設定するオプションによって異なりますが、エンティティを右クリックしたり、Flow Production Tracking アクション メニューや歯車メニューをクリックすると、メニュー項目が Flow Production Tracking に表示されます。たとえば、これはサイトの設定でこのアプリを 3 回使用し、Maya、Nuke、Photoshop にメニューを実装した場合のスクリーンショットです。現在サポートされているアプリケーションとエンジンは次のとおりです。  3DSMax  Hiero  Maya  MotionBuilder  Nuke  Photoshop  Mari  Houdini  Flame起動時にコマンド ライン引数を使用する多くのアプリケーションにはコマンド ライン オプションがあり、異なるエディションのアプリケーションを選択したり(Nuke とNukeX など)、使用に関する他のさまざまな設定を行う際に呼び出すことができます。ランチャーのアプリには、この目的に合わせて設定できる各 OS 用の「引数」の設定があります。たとえば、ここで「–nukex」と設定すると、これがコマンド ラインの起動に追加され、NukeX が通常の Nuke の代わりに実行されます。NukeX の起動の例launch_nuke:  engine: tk-nuke  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: '--nukex'  linux_path: '@nuke_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.15}  mac_args: '--nukex'  mac_path: '@nuke_mac'  menu_name: Launch Nuke  windows_args: '--nukex'  windows_path: '@nuke_windows'環境変数を設定して起動時に動作を自動化する多くの場合、アプリケーションには、スタジオのパイプラインで適切に機能するように設定された特定の環境変数やプラグイン パスなどが必要になります。起動アプリケーションは「before_app_launch」フックを介してこのようなケースをカバーしており、アプリケーションの起動のたびに実行されるコードのスニペットを定義できます。既定では、「before_app_launch」フックは何も実行しない単純なパススルーですが、このドキュメントの説明に従ってオーバーライドできます。たとえば、Zync Render を使用する場合は、Zync Maya プラグイン ディレクトリを $PYTHONPATH と $XBMLANGPATH の両方に含める必要があります。起動アプリでこの環境変数を設定するには、次のように before_app_launch フックのコード数行を更新します。環境変数の設定例def execute(self, **kwargs):    &quot;&quot;&quot;    The execute functon of the hook will be called to start the required application            &quot;&quot;&quot;    # Example to show how to set env vars on Maya launch    # Append the desired path to the existing $PYTHONPATH to ensure    # everything upstream still works    os.environ[&quot;PYTHONPATH&quot;] = os.environ[&quot;PYTHONPATH&quot;] + os.pathsep + &quot;~/Library/zync/zync-maya&quot;    # Set $XBMLANGPATH to the desired path, may need to append it as    # with $PYTHONPATH if already defined in your pipeline    os.environ[&quot;XBMLANGPATH&quot;] = &quot;~/Library/zync/zync-maya&quot;「before_app_launch」を使用すると、Flow Production Tracking の更新など、他の動作を自動化することもできます。たとえば、起動アプリが実行されるたびに(タスクからの起動のみ)タスク ステータスが更新されるように起動アプリを設定できます。次の例では「in progress」に更新するよう設定しています。タスク ステータス更新の自動化の例def execute(self, **kwargs):    &quot;&quot;&quot;    The execute functon of the hook will be called to start the required application            &quot;&quot;&quot;    # If there is a Task in the context, set its status to 'ip'    if self.parent.context.task:        task_id = self.parent.context.task['id']        data = {            'sg_status_list':'ip'        }        self.parent.shotgun.update(&quot;Task&quot;, task_id, data)ご想像のとおり、多くの選択肢があります。起動アプリの目的は、パイプラインのニーズに合わせた柔軟性を提供することです。エンジンをまだ指定していないアプリケーションを起動する起動アプリケーションを使用して、Toolkit のエンジンをまだ指定していないアプリケーションを起動することもできます。この場合、フォルダは、起動元のショット、タスク、またはアセットのディスク上に作成されます。アプリケーションは起動されますが、アプリケーション起動後にコードは実行されず、アプリケーション内に Flow Production Tracking メニューは表示されません。つまり、Flow Production Tracking 内の Toolkit でサポートされていないアプリケーションを起動できます。これを行うには、エンジンのオプションを空にしたまま、起動するアプリケーションのパスを起動アプリケーションに指定します。技術の詳細3DSMaxこのアプリは、3DSMax が起動プロセスの一部として実行する 3DSMax コマンド ラインに、MaxScript の init_tank.ms を自動的に追加します。3DSMax が起動すると、次のプロセスが実行されます。  3DSMax が起動時に init_tank.ms を実行します。  init_tank.ms により、Python インタプリタが利用可能で tank_startup.py が実行されることが確認されます。  Flow Production Tracking Toolkit コンテキスト API を使用して、Flow Production Tracking から渡されたエンティティ ID が Toolkit コンテキストに変換されます。  tank.system.start_engine() を介して適切なエンジンを起動し、コンテキストに渡します。エンジンが残りのプロセスを処理します。Mayaこのアプリは userSetup.py 自動開始スクリプトを Maya に登録し、Maya はそれを起動プロセスの一部として呼び出します。Maya が起動すると、次のプロセスが実行されます。  Maya が userSetup.py 起動スクリプトの実行を開始します  Flow Production Tracking Toolkit コンテキスト API を使用して、Flow Production Tracking から渡されたエンティティ ID が Toolkit コンテキストに変換されます。  tank.system.start_engine() を介して適切なエンジンを起動し、コンテキストに渡します。エンジンが残りのプロセスを処理します。MotionBuilderこのアプリは init_tank.py 自動開始スクリプトを MotionBuilder に登録し、MotionBuilder はそれを起動プロセスの一部として呼び出します。MotionBuilder が起動すると、次のプロセスが実行されます。  MotionBuilder が init_tank.py 起動スクリプトの実行を開始します  Flow Production Tracking Toolkit コンテキスト API を使用して、Flow Production Tracking から渡されたエンティティ ID が Toolkit コンテキストに変換されます。  tank.system.start_engine() を介して適切なエンジンを起動し、コンテキストに渡します。エンジンが残りのプロセスを処理します。Nukeこのアプリは menu.py 自動開始スクリプトを Nuke に登録し、Nuke はそれを起動プロセスの一部として呼び出します。Nuke が起動すると、次のプロセスが実行されます。  Nuke が menu.py 起動スクリプトの実行を開始します  Flow Production Tracking Toolkit コンテキスト API を使用して、Flow Production Tracking から渡されたエンティティ ID が Toolkit コンテキストに変換されます。  tank.system.start_engine() を介して適切なエンジンを起動し、コンテキストに渡します。エンジンが残りのプロセスを処理します。Photoshopこのアプリは、Adobe Extension Manager を使用して Tank プラグインのインストールやインストール確認を行います。Photoshop が起動すると、次のプロセスが実行されます。  Photoshop が Tank プラグインの実行を開始します  Flow Production Tracking Toolkit コンテキスト API を使用して、Flow Production Tracking から渡されたエンティティ ID が Toolkit コンテキストに変換されます。  tank.system.start_engine() を介して適切なエンジンを起動し、コンテキストに渡します。エンジンが残りのプロセスを処理します。追加の設定このアプリを使用して Photoshop を起動する場合、追加 のセクションで 4 つの設定値を指定する必要があります。次に、システムとインストールの場所に合わせた調整が必要な設定および適切な既定値を示します。mac_python_path: &quot;/usr/bin/python&quot;windows_python_path: &quot;C:  Python27  python.exe&quot;mac_extension_manager_path: &quot;/Applications/Adobe Extension Manager CS6/Adobe Extension Manager CS6.app&quot;windows_extension_manager_path: &quot;C:  Program Files (x86)  Adobe  Adobe Extension Manager CS6  XManCommand.exe&quot;",
    "url": "/1b9c259a/",
    "relUrl": "/1b9c259a/"
  },
  "164": {
    "id": "164",
    "title": "ローダー",
    "content": "ローダーこのドキュメントは、Toolkit の設定を管理するユーザのみが使用可能な機能について説明します。詳細については、『Flow Production Tracking 統合ユーザ ガイド』を参照してください。環境設定ローダーは高度にカスタマイズ可能で、さまざまな方法でセットアップできます。設定できる領域は主に 2 つあります。  ツリー ビューの左側に表示するタブとコンテンツをセットアップします。  それぞれのパブリッシュで表示するアクションとそのアクションの実際の内容を制御します。次のセクションでは、ローダーの設定方法の概要を説明します。設定に関する技術詳細については、本ドキュメントの後半部分を参照してください。ツリー ビューツリー ビューは柔軟に設定できます。標準的な Flow Production Tracking フィルタ構文を使用してさまざまなタブのコンテンツを制御できます。各タブは 1 つの階層にグループ化される 1 つの Flow Production Tracking API クエリーで構成されます。表示項目を制御する任意のフィルタを追加し、{context.entity}、{context.project}、{context.project.id}、{context.step}、{context.task}、および {context.user} といった特別なキーワードを使用して、現在のコンテキストに基づいてクエリーを範囲指定できます。各キーワードは、None (コンテキストの該当部分が入力されていない場合)、またはキー ID、タイプ、名前を含む標準的な Flow Production Tracking リンク ディクショナリのどちらかの関連コンテキスト情報に置き換えられます。既定では、ローダーは現在のプロジェクトに属するアセットとショットを表示します。再設定することで、他のプロジェクト(または特定のアセット ライブラリ プロジェクトなど)の項目を表示するといった拡張設定を簡単に行うことができます。また、フィルタを使用して、特定の承認ステータスの項目のみを表示したり、ステータス別、他の Flow Production Tracking フィールド別に項目をグループ化することもできます。次に、ツリー ビュー タブの設定方法を示したいくつかの構成設定例を紹介します。# An asset library tab which shows assets from a specific# Flow Production Tracking projectcaption: Asset Libraryentity_type: Assethierarchy: [sg_asset_type, code]filters:- [project, is, {type: Project, id: 123}]# Approved shots from the current projectcaption: Shotshierarchy: [project, sg_sequence, code]entity_type: Shotfilters:- [project, is, '{context.project}']- [sg_status_list, is, fin]# All assets for which the current user has tasks assignedcaption: Assetsentity_type: Taskhierarchy: [entity.Asset.sg_asset_type, entity, content]filters:- [entity, is_not, null]- [entity, type_is, Asset]- [task_assignees, is, '{context.user}']- [project, is, '{context.project}']パブリッシュをフィルタリングするローダーが Flow Production Tracking からパブリッシュ データをロードする場合に実行するパブリッシュ クエリーに Flow Production Tracking フィルタを適用できます。フィルタは publish_filters パラメータを介して制御されます。たとえば、フィルタを使用すると、承認されていないパブリッシュまたはそれに関連するレビュー バージョンが承認されていない場合にパブリッシュを非表示にできます。アクションが何も表示されないローダーには、各エンジン用にさまざまなアクションが豊富に用意されています。たとえば、Nuke の場合、「スクリプトの読み込み」と「ノードの作成と読み取り」の 2 つのアクションがあります。アクションはフック内で定義されます。つまり、その動作を変更したり、必要に応じて他のアクションを追加したりできます。その後、ローダーの設定で、このアクションを特定のパブリッシュ タイプにバインドできます。基本的に、パブリッシュ タイプにアクションをバインドするということは、アクションがローダー内のこのタイプの項目すべてのアクション メニューに表示されるということです。たとえば、既定では、Nuke のマッピングは次のように設定されています。action_mappings:  Nuke Script: [script_import]  Rendered Image: [read_node]アクション メニューが何も表示されていない場合は、使用しているパブリッシュ タイプとは異なる名前を選択している可能性があります。この場合、設定に移動して、ローダー内に表示するためにこのタイプを追加します。アクションを管理するローダーがサポートするアプリケーションごとに、このアプリケーションでサポートされるアクションを実装するアクション フックがあります。たとえば Maya などの場合、既定のフックは reference、import、および texture_node の各アクションを実装し、それぞれが特定の Maya コマンドを実行して現在の Maya シーンにコンテンツを取り込みます。すべてのフックと同様に、アクションを完全にオーバーライドおよび変更できます。また、埋め込まれたフックに基づいたフックも作成できるため、たくさんのコードを複製しなくても、組み込みのフックに他のアクションを簡単に追加できます。アクション フックでアクションのリストを定義したら、このアクションをパブリッシュ ファイル タイプにバインドできます。たとえば、「Maya Scene」という名前のパイプラインにパブリッシュ ファイル タイプを指定すると、フック内で定義されている reference アクションと import アクションにこの設定をバインドできます。これにより、Toolkit は表示される各「Maya Scene」パブリッシュに reference と import のアクションを追加します。このようにして実際のフックからパブリッシュ タイプを分離すると、既定の設定で用意されるローダーとは異なるパブリッシュ タイプ設定を使用できるようにローダーを簡単に再設定できます。ローダーは Toolkit の第 2 世代のフック インタフェースを使用するため、柔軟性に優れています。このフックの形式は改善された構文を使用します。これはローダーにインストールされた既定の構成設定で次のように表示されます。actions_hook: '{self}/tk-maya_actions.py'キーワード {self} は、フックの hooks アプリ フォルダを確認するように Toolkit に指示します。このフックをユーザが設定した実装でオーバーライドする場合は、値を {config}/loader/my_hook.py に変更します。これにより、設定フォルダ内の hooks/loader/my_hook.py と呼ばれるフックを使用するように Toolkit に指示します。ローダーが使用する別の第 2 世代フック機能では、execute() メソッドを指定する必要がなくなりました。代わりに、フックは通常のクラスのような形式になり、すべてのグループ化に適したメソッドのコレクションが含まれます。ローダーの場合、使用するアクション フックは次の 2 つのメソッドを実装する必要があります。def generate_actions(self, sg_publish_data, actions, ui_area)def execute_multiple_actions(self, actions)詳細については、アプリに付属するフック ファイルを参照してください。フックは継承も活用します。つまり、フック内のすべての項目をオーバーライドすることなく、さまざまな方法で既定のフックを簡単に拡張または強化して簡単にフックを管理できます。v1.12.0 よりも前のバージョンでは、アプリケーションがアクションを実行するには execute_action フックを起動していました。新しいバージョンでは execute_multiple_actions フックを起動します。既存のフックとの下位互換性を提供するために、execute_multiple_actions フックは提供される各アクションの execute_action を実際に起動します。アプリケーションを v1.12.0 以降にアップグレードした後に execute_multiple_actions フックが定義されていないと報告される場合は、環境の actions_hook 設定が組み込みフック {self}/{engine_name}_actions.py から正しく継承されるようにします。組み込みフックからカスタム フックを取得する方法については、Toolkit リファレンス ドキュメントを参照してください。第 2 世代のフック形式については、こちらで確認してください。フックの継承を使用すると、次のように既定のフックに他のアクションを追加できるようになります。import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_publish_data, actions, ui_area):        &quot;&quot;&quot;        Returns a list of action instances for a particular publish.        This method is called each time a user clicks a publish somewhere in the UI.        The data returned from this hook will be used to populate the actions menu for a publish.        The mapping between Publish types and actions are kept in a different place        (in the configuration) so at the point when this hook is called, the loader app        has already established *which* actions are appropriate for this object.        The hook should return at least one action for each item passed in via the        actions parameter.        This method needs to return detailed data for those actions, in the form of a list        of dictionaries, each with name, params, caption and description keys.        Because you are operating on a particular publish, you may tailor the output        (caption, tooltip etc) to contain custom information suitable for this publish.        The ui_area parameter is a string and indicates where the publish is to be shown.        - If it will be shown in the main browsing area, &quot;main&quot; is passed.        - If it will be shown in the details area, &quot;details&quot; is passed.        - If it will be shown in the history area, &quot;history&quot; is passed.        Please note that it is perfectly possible to create more than one action &quot;instance&quot; for        an action! You can for example do scene introspection - if the action passed in        is &quot;character_attachment&quot; you may for example scan the scene, figure out all the nodes        where this object can be attached and return a list of action instances:        &quot;attach to left hand&quot;, &quot;attach to right hand&quot; etc. In this case, when more than        one object is returned for an action, use the params key to pass additional        data into the run_action hook.        :param sg_publish_data: Flow Production Tracking data dictionary with all the standard publish fields.        :param actions: List of action strings which have been defined in the app configuration.        :param ui_area: String denoting the UI Area (see above).        :returns List of dictionaries, each with keys name, params, caption and description        &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_publish_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_publish_data):        &quot;&quot;&quot;        Execute a given action. The data sent to this be method will        represent one of the actions enumerated by the generate_actions method.        :param name: Action name string representing one of the items returned by generate_actions.        :param params: Params data, as specified by generate_actions.        :param sg_publish_data: Flow Production Tracking data dictionary with all the standard publish fields.        :returns: No return value expected.        &quot;&quot;&quot;        # resolve local path to publish via central method        path = self.get_publish_path(sg_publish_data)        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_publish_data)これで、この新しいアクションを設定内のパブリッシュ タイプのセットにバインドできます。action_mappings:  Maya Scene: [import, reference, my_new_action]  Maya Rig: [reference, my_new_action]  Rendered Image: [texture_node]上記のようにフックの派生を利用すれば、カスタム フック コードには、管理と更新を簡単にするために実際追加するビジネス ロジックを含めるだけで構いません。リファレンス次のメソッドがアプリ インスタンスで利用可能です。open_publish()ユーザがパブリッシュを選択できる[ファイルを開く] (Open File)スタイルのバージョンのローダーを表示します。選択したパブリッシュが返されます。アプリ用に設定された通常のアクションは、このモードでは許可されていません。app.open_publish( str title, str action, list publish_types )パラメータと戻り値  str title: open publish ダイアログで表示するタイトルです。  str action: [開く] (Open)ボタンで使用するアクションの名前です。  list publish_types: パブリッシュの利用可能なリストのフィルタリングに使用するパブリッシュ タイプのリストです。これが空または None の場合は、すべてのパブリッシュが表示されます。  戻り値: ユーザによって選択された Flow Production Tracking エンティティ ディクショナリのリストです。例&amp;gt;&amp;gt;&amp;gt; engine = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; loader_app = engine.apps.get[&quot;tk-multi-loader2&quot;]&amp;gt;&amp;gt;&amp;gt; selected = loader_app.open_publish(&quot;Select Geometry Cache&quot;, &quot;Select&quot;, [&quot;Alembic Cache&quot;])&amp;gt;&amp;gt;&amp;gt; print selected",
    "url": "/a4c0a4f1/",
    "relUrl": "/a4c0a4f1/"
  },
  "165": {
    "id": "165",
    "title": "Publish",
    "content": "パブリッシュ概要アーティストは Publish アプリを使用して作品をパブリッシュすることにより、下流工程に関わるアーティストが自分の作品を使用できるようにすることができます。アーティストのコンテンツ作成ソフトウェア内における従来のパブリッシュ ワークフローと、ディスク上にある任意のファイルのスタンドアロン パブリッシュがサポートされます。コンテンツ作成ソフトウェアで作業し、基本的な Flow Production Tracking の統合を使用している場合、このアプリはアーティストがパブリッシュする項目を自動的に探して表示します。さらに高度な制作上のニーズがある場合は、アーティストのワークフローを操作するカスタム パブリッシュ プラグインを作成することもできます。ドキュメントPublisher の完全なドキュメントは、こちらにあります。",
    "url": "/bc718491/",
    "relUrl": "/bc718491/"
  },
  "166": {
    "id": "166",
    "title": "Python コンソール",
    "content": "Python コンソールこれは、Python インタープリタにアクセスする DCC で使用するための Python コンソール パネルです。該当のインタープリタとのインタラクションが制限されている、またはそのサポートがない場合に使用します。パネルコンソールをインストールするとパネルとして DCC に登録され、Flow Production Tracking メニューで利用できるようになります。組み込みの Toolkit パネル(maya、nuke、houdini)をサポートするアプリでは、コンソールはドッキングされたパネルに表示されます。古いバージョンの DCC またはパネルをサポートしない DCC で使用する場合、コンソールは通常の Toolkit ダイアログとして表示されます。タブPython コンソールには 1 つまたは複数のタブが表示され、それぞれエディタと出力ウィンドウが含まれています。右下隅にある + ボタンをクリックすると、新しいタブを作成できます。タブ名の横には x ボタンがあり、タブを削除できます。タブ自体をダブルクリックすると、タブの新しい名前を入力するよう求められます。タブの配置はドラッグ アンド ドロップによって変更することができます。DCC を閉じるときにタブの状態が保存され、次回の起動時に復元されます。エディタコンソールには、Python を編集するための入力領域があります。エディタには行番号が含まれ、カーソルの現在の行を強調表示し、またいくつかの基本構文を強調表示します。コンソールは DCC のパレットを使用して統合されたルック アンド フィールを提供しようとします。ブロックのインデントおよびインデント解除がサポートされています。1 つまたは複数の行を選択し、tab を押すとスペース 4 つ分がインデントされ、shift + tab を押すとスペース 4 つ分のインデントが解除されます。4 つのスペースを 1 つのインデントのグループとして維持しようとするため、4 つのスペースのブロック単位でインデント/インデント解除が行われます。ブロックのコメント付けとコメント解除もサポートされています。1 行または複数の行を選択し、Mac では cmd + /、Windows と Linux では ctrl + / を押します。選択した行の先頭に # がない場合は、選択したすべての行に 1 つづつ追加されます。すべての行に # が存在する場合は、それらが削除されます。出力出力領域には実行した Python の結果が表示されます。ソースの Python コマンド エコーは既定でオンになっており、&amp;gt;&amp;gt;&amp;gt; で始まるので出力画面で区別できます。各実行にはタイムスタンプも付けられます。エコーをオフにするためのトグルがあります。構文およびランタイム エラーは、デバッグ用の完全なスタック トレースとともに赤色で表示されます。ボタン出力  [クリア] (Clear) - 出力ブラウザの内容をクリアします。  [エコー] (Echo) - 実行されたコマンドを出力ブラウザにエコーするかどうかを切り替えます。エディタ  [実行] (Execute) - エディタの内容を実行します。  [保存] (Save) - エディタの現在の内容をファイルに保存します。  [開く] (Open) - エディタでファイルを開きます。  [クリア] (Clear) - エディタの内容をクリアします。  [行番号] (Lines) - 現在のタブの行番号を切り替えます。グローバル一部の Flow Production Tracking/Toolkit グローバル変数は、シェルの Flow Production Tracking エンジンで利用可能なグローバル変数と同様、コンソールにあらかじめ定義されています。  Tk API ハンドルは tk 変数を介して利用できます  Flow Production Tracking API ハンドルは shotgun 変数を介して利用できます  現在のコンテキストは context 変数に格納されます  シェル エンジンは engine 変数を介してアクセスできます外部ソースアプリには、外部ロケーションから Python ソースをロードするために実装できるフックが付属しています。フックは external_sources_hook と呼ばれ、使用するには get_external_source_actions というメソッドを実装する必要があります。このメソッドは、QActions のリストを返し、アクションがトリガされると新しいタブが(コンテンツとともに)コンソールに追加されます。事前定義されたユーザのリストのために github から gist をロードする実装例が提供されます。フックによって返されるアクションは、[開く] (Open)ボタンを押し続けると表示されるポップアップ メニューに表示されます。ホットキー  Ctrl + Enter で選択内容を実行  Ctrl + T を押して新しいタブを作成  Ctrl + Shift + [ または Ctrl + Shift + ] でタブ間を移動  Ctrl + Wheel によって入力/出力フォントのサイズを調整注: これらのホットキーはすべての DCC で使用できるわけではありません。その他の注意事項  一部の古いバージョンの DCC では、セッションを閉じるときに Python コンソールを開いたままにしておくとクラッシュする可能性があります。これは一部の古いバージョンの PySide のバグの可能性があります。新しいバージョンの PySide にバンドルされている最新バージョンの DCC は終了時にクラッシュしないようです。最新の DCC リリースでこの問題が発生する場合は、チケットを送信してください。調査にご協力をお願いいたします。",
    "url": "/770a748a/",
    "relUrl": "/770a748a/"
  },
  "167": {
    "id": "167",
    "title": "レビュー提出",
    "content": "レビュー提出このアプリの使用方法API として使用する場合このアプリには、Multi Publish アプリのような他のアプリ内から呼び出して使用するためのモードがあります。このモードはイメージ シーケンスから QuickTime ファイルを作成して、レビューできるようにバージョンとして Flow Production Tracking に送信します。生成された QuickTime にはスレートとバーンインがあります。フォント、ロゴの位置、ムービーの圧縮オプション、バーンイン/スレート情報などの項目は現在既定のフックでハードコードされているため、動作を調整するためにフック関数を再実装することをお勧めします。次に、スレートとバーンインの、現在の既定の形式を示します。独自のアプリまたはフック内からこのアプリを使用する場合について、その方法の概要を簡単に説明します。  現在のエンジンから tk-multi-reviewsubmission アプリを取得します。これは呼び出し self.parent.engine.apps.get('tk-multi-reviewsubmission') を使用してフック内部から実行できます。  アプリが使用可能な場合は、render_and_submit_version() メソッドを呼び出します。次に、フック コードの内容の例を示します。review_submission_app = self.parent.engine.apps.get(&quot;tk-multi-reviewsubmission&quot;)if review_submission_app:    review_submission_app.render_and_submit_version(        template,        fields,        first_frame,        last_frame,        sg_publishes,        sg_task,        comment,        thumbnail_path,        progress_cb,        color_space    )render_and_submit_version に渡す必要のある引数は次のとおりです。  template: パブリッシュするファイルが格納される場所を定義するテンプレート  fields: テンプレートの入力に使用されるフィールド  first_frame: 処理するイメージ シーケンスの最初のフレーム  last_frame: 処理するイメージ シーケンスの最後のフレーム  sg_publishes: バージョンのリンク先の Flow Production Tracking パブリッシュ ファイル オブジェクトのリスト  sg_task: バージョンのリンク先の Flow Production Tracking タスク リンク ディクショナリ  comment: バージョンの説明に追加するテキスト。  thumbnail_path: ムービーが Flow Production Tracking にアップロードされていない場合にバージョンで使用するサムネイルのパス(設定ファイルで指定)  progress_cb: 進行状況を一緒に報告するコールバック。callback(percent, message) のような形式になります。  color_space: 入力フレームのカラースペース。Nuke では、書き込みノードに使用するカラースペース ノブの列挙値のいずれかになります。メニュー項目として使用する場合このモードは、DCC 内の Flow Production Tracking メニューにメニュー項目を追加します。 また、現在のビューポートのクイック スナップショットを作成して、バージョンのドラフトとして Flow Production Tracking Create に送信します。これにより、Flow Production Tracking Create 内で注釈、文字、比較のメモを追加できるため、詳しいレビューを提出できます。この機能をコンテキストに追加するには、次の操作を行う必要があります。  display_name フィールドがメニュー項目に含まれるように設定します。  render_media_hook フィールドを、DCC でのメディアのレンダリング方法を指示するフックに設定します(tk-photoshopcc と tk-maya で既定の実装は異なります)。  submitter_hook フィールドを {self}/submitter_create.py に設定します。例:tk-multi-reviewsubmission:  display_name: Send for review  render_media_hook: '{self}/render_media.py:{self}/{engine_name}/render_media.py'  submitter_hook: '{self}/submitter_create.py'  location:    type: app_store    name: tk-multi-reviewsubmission    version: v1.0.1",
    "url": "/4badd856/",
    "relUrl": "/4badd856/"
  },
  "168": {
    "id": "168",
    "title": "Screening Room",
    "content": "Screening Roomこれは、Screening Room で現在の Maya セッションに接続する小さなアプリです。[Screening Room にジャンプする] (Jump to Screening Room)という項目が Flow Production Tracking メニューに追加されます。このボタンをクリックすると Screening Room が起動され、ショット、アセット、タスクなど、現在の Flow Production Tracking Toolkit コンテキストが表示されます。その後、Screening Room を使用して、送信したすべてのコンテンツを検索できます。",
    "url": "/f3e452a2/",
    "relUrl": "/f3e452a2/"
  },
  "169": {
    "id": "169",
    "title": "フレーム範囲の設定",
    "content": "フレーム範囲の設定このアプリは、現在開いているシーンのフレーム範囲を管理します。Flow Production Tracking メニューで[フレーム範囲と Flow Production Tracking を同期する] (Sync Frame Range with Shotgun)メニュー オプションをクリックすると、このアプリを利用できます。このオプションをクリックすると、Flow Production Tracking Toolkit は現在の作業領域(通常はショット)に関連する Flow Production Tracking エンティティを確認し、インとアウトのフレーム情報を含むイン フィールドとアウト フィールドを探します。通常、これはショットと一緒に使用されるため、この場合、アプリは Flow Production Tracking の既定の設定で定義された標準的なショットのイン フィールドとアウト フィールドを使用します。ただし、他のフィールドからフレーム範囲を取得するようにアプリを完全に設定することもできます。アプリを実行すると、このインとアウトを使用して現在のシーンが更新され、最後に概要メッセージが表示されます。複数の Flow Production Tracking フィールドの同期オプションmenu_name プロパティを設定すると、Flow Production Tracking メニューでこのアプリの複数のインスタンスを定義できます。これにより、さまざまな Flow Production Tracking フィールドを同期する複数のメニュー アクションを定義することができます。定義するには、menu_name にそれぞれのアプリ インスタンス名を設定し、各インスタンスにフレーム イン フィールドとフレーム アウト フィールドを設定します。tk-multi-setframerange_cuts:  menu_name: Sync frame range using cut fields  sg_in_frame_field: sg_cut_in  sg_out_frame_field: sg_cut_out  location: &quot;@apps.tk-multi-setframerange.location&quot;tk-multi-setframerange_handles:  menu_name: Sync frame range using handle fields  sg_in_frame_field: sg_handle_in  sg_out_frame_field: sg_handle_out  location: &quot;@apps.tk-multi-setframerange.location&quot;Flow Production Tracking メニューには、別個のオプションとして表示されます。注: この機能は、バージョン v0.4.0 のアプリで新しく導入されました。操作フック現在のシーン フレーム範囲の取得、またはフレーム範囲の設定に使用するソフトウェア固有のロジックは、フレーム操作フックで処理されます。新しいエンジンのサポートを追加する場合、または動作の実装方法を変更する場合は、hook_frame_operation アプリ プロパティを設定して取得と設定の独自のロジックを実装すると、フレーム操作フックを引き継ぐことができます。注: この機能は、バージョン v0.4.0 のアプリで新しく導入されました。",
    "url": "/8ac43263/",
    "relUrl": "/8ac43263/"
  },
  "170": {
    "id": "170",
    "title": "Flow Production Tracking Panel",
    "content": "Flow Production Tracking パネルこのドキュメントは、Toolkit の設定を管理するユーザのみが使用可能な機能について説明します。詳細については、『Flow Production Tracking 統合ユーザ ガイド』を参照してください。Flow Production Tracking Panel を設定するFlow Production Tracking Panel で広範囲に設定できる主な領域は 2 つあります。UI の文字の表示と、データに関連付けるアクションです。次のセクションでは、2 つのシステムの設定を制御する方法について説明します。表示内容を設定する詳細領域の値とリストは両方とも Flow Production Tracking_fields フックから設定可能です。正確な値を表示するために、このフックをサブクラス化して実装を変更できます。システムをテンプレート化するフックはシンプルなテンプレート言語をサポートしているため、優れた柔軟性が得られます。また、Qt でサポートされている HTML サブセットもサポートしているため、表示される値の色、フォント サイズ、ウェイトなどを制御できます 。テンプレート言語は次のように機能します。      Flow Production Tracking の値は、{brackets} のように &amp;lt;b&amp;gt;Description:&amp;lt;/b&amp;gt; {description} で囲まれています。このテンプレートをレンダリングすると、{description} の部分が説明フィールドの値で置き換えられます。        値が空以外の場合にのみ表示される値にオプションの接頭辞または接尾辞を指定する場合、{[Prefix]sg_field[suffix]} 構文を使用できます。両方の値が追加されている場合、テンプレート {[Start: ]start_date} {[End: ]end_date} は Start: 12 July 2009 End: 14 July 2012 をレンダリングします。ただし、終了日を設定していない場合は Start: 12 July 2009 をレンダリングします。        一部の値が設定されていない場合はフォールバックを定義することができます。Flow Production Tracking のバージョンについては、プロデューサがアーティストの代わりにバージョンを送信するというワークフローをサポートするため、created_by フィールドが artist フィールドよりも優先されます。この場合、バージョンはプロデューサによって作成されますが、artist フィールドはアーティストに設定されます。ただし、いつもそういうわけではありません。アーティストが自分の作業を送信するパイプラインでは、アーティスト欄は空欄になります。バージョンを表示する場合、最初に artist フィールドを確認できるようにしておくと役立ちます。今回このフィールドは設定されていないため、created_by フィールドにフォールバックします。このようにするには、Created By: {artist|created_by} のように構文 {field1|field2} を使用します。{[Created By: ]artist|created_by} のようにオプション フィールドを組み合わせることができます。  このフックには次のメソッドが含まれます。リストに表示される項目を制御するget_list_item_definition() メソッドは、Flow Production Tracking のエンティティ タイプを考慮して、さまざまなリストの項目の外観を制御するディクショナリを返します。たとえば、top_left、top_right、および body といったキーを持つディクショナリを返します。{ &quot;top_left&quot;: &quot;&amp;lt;big&amp;gt;{code}&amp;lt;/big&amp;gt;&quot;, &quot;top_right&quot;: &quot;{updated_at}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}上部の細部領域を制御するget_main_view_definition() メソッドは、Flow Production Tracking のエンティティ タイプを考慮して、title キーと body キーを含むディクショナリを返します。これらの値は、詳細領域のオブジェクトの外観を次のように制御します。{ &quot;title&quot;: &quot;{type} {code}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}[情報] (Info)タブに表示されるフィールドを制御するget_all_fields() メソッドは、[情報] (Info)タブで任意のエンティティがレンダリングされる場合に表示するフィールドのリストを返します。アクションを設定するアクションは Flow Production Tracking のデータを操作するコードの小さなスニペットです。例を次に示します。  任意の Flow Production Tracking バージョンの RV を起動するアクション  任意のタスクに自分に割り当てることができるアクション  Maya リファレンスとして Maya に Flow Production Tracking パブリッシュをロードするアクションアクションの実際のペイロードはアクション フック**で定義されます。アクションのロジックを定義したら、アプリ設定の Flow Production Tracking オブジェクトにこのアクションをマップすることができます。次に、このアクション マッピングの例を示します。action_mappings:  PublishedFile:  - actions: [reference, import]    filters: {published_file_type: Maya Scene}  - actions: [texture_node]    filters: {published_file_type: Rendered Image}  Task:  - actions: [assign_task]    filters: {}  Version:  - actions: [play_in_rv]    filters: {}上記の例では、reference、import、texture_node、assign_task、および play_in_rv といったアクションを使用します。次に、さまざまな Flow Production Tracking のオブジェクトと条件にこのアクションをマップします。たとえば import アクションは、タイプが「Maya Scene」であるすべてのパブリッシュに表示されるよう要求しています。オブジェクトがパネルにロードされると、上記のアクション設定が読み込まれ、分析されます。現在のオブジェクトに適したアクションのリストが決定され、generate_actions() フック メソッドが実行されます。この特定の Flow Production Tracking オブジェクトに対してアクションを実行できるかどうかをフック コードが判断できるように、この時点で指定したエンティティの Flow Production Tracking データがフックに渡されます。この方法により、各フックで表示前にチェックを実行できます。たとえば、play_in_rv フックはメディアをローカルで利用できる場合にのみ意味を持ちます。設定でセットアップされたアクション マッピングは指定した Flow Production Tracking エンティティで有効にするアクションをパネルに通知しますが、指定したオブジェクトに適していないと generate_actions() メソッドによって判断された場合は、すべてのアクションが表示されない可能性があります。generate_actions() メソッドから返されるアクションはアクション メニューに表示されます。ユーザがクリックすると、execute_action() フック メソッドが呼び出されてアクションが実行されます。パネルがサポートするアプリケーションごとに、適切なアクションを実装するアクション フックがあります。たとえば Maya などの場合、既定のフックは reference、import、texture_node の各アクションを実装し、それぞれが特定の Maya コマンドを実行して現在の Maya シーンにパブリッシュを取り込みます。すべてのフックと同様に、アクションを完全にオーバーライドおよび変更できます。また、埋め込まれたフックに基づいたフックも作成できるため、たくさんのコードを複製しなくても、組み込みのフックに他のアクションを簡単に追加できます。パネルは Toolkit の第 2 世代のフック インタフェースを使用するため、柔軟性に優れています。このフックの形式は改善された構文を使用します。これは既定の構成設定で次のように表示されます。actions_hook: '{self}/tk-maya_actions.py'キーワード {self} は、フックのアプリの hooks フォルダを確認するように Toolkit に指示します。 このフックをユーザが設定した実装でオーバーライドする場合は、値を {config}/panel/maya_actions.py に変更します。これにより、設定フォルダ内の hooks/panel/maya_actions.py と呼ばれるフックを使用するように Toolkit に指示します。詳細については、アプリに付属するフック ファイルを参照してください。フックは継承も活用します。つまり、フック内のすべての項目をオーバーライドすることなく、さまざまな方法で既定のフックを簡単に拡張または強化して簡単にフックを管理できます。LINKBOX_DOC:5#The%20hook%20data%20type:こちらで、第 2 世代のフック形式を確認してください。フックの継承を使用すると、次のように既定のフックに他のアクションを追加できるようになります。import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_data, actions, ui_area):        &quot;&quot;&quot;        Returns a list of action instances for a particular object.        The data returned from this hook will be used to populate the        actions menu.        The mapping between Flow Production Tracking objects and actions are kept in a different place        (in the configuration) so at the point when this hook is called, the app        has already established *which* actions are appropriate for this object.        This method needs to return detailed data for those actions, in the form of a list        of dictionaries, each with name, params, caption and description keys.        Because you are operating on a particular object, you may tailor the output        (caption, tooltip etc) to contain custom information suitable for this publish.        The ui_area parameter is a string and indicates where the publish is to be shown.        - If it will be shown in the main browsing area, &quot;main&quot; is passed.        - If it will be shown in the details area, &quot;details&quot; is passed.        :param sg_data: Flow Production Tracking data dictionary with all the standard publish fields.        :param actions: List of action strings which have been defined in the app configuration.        :param ui_area: String denoting the UI Area (see above).        :returns List of dictionaries, each with keys name, params, caption, group and description        &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;group&quot;: &quot;Pipeline Utils&quot;,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_data):        &quot;&quot;&quot;        Execute a given action. The data sent to this be method will        represent one of the actions enumerated by the generate_actions method.        :param name: Action name string representing one of the items returned by generate_actions.        :param params: Params data, as specified by generate_actions.        :param sg_data: Flow Production Tracking data dictionary with all the standard publish fields.        :returns: No return value expected.        &quot;&quot;&quot;        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_data)これで、この新しいアクションを設定内のパブリッシュ タイプのセットにバインドできます。action_mappings:  PublishedFile:  - actions: [reference, import, my_new_action]    filters: {published_file_type: Maya Scene}  Version:  - actions: [play_in_rv]    filters: {}上記のようにフックの派生を利用すれば、カスタム フック コードには、管理と更新を簡単にするために実際追加するビジネス ロジックを含めるだけで構いません。",
    "url": "/c0b0ce05/",
    "relUrl": "/c0b0ce05/"
  },
  "171": {
    "id": "171",
    "title": "Snapshot",
    "content": "SnapshotFlow Production Tracking Snapshot は簡単な差分バックアップ機能であるため、他のユーザと共有しなくても、作業の差分をバージョン付けしたり、管理することができます。スナップショットの作成、説明やサムネイルの追加、後でいつでも復帰できるポイントの作成、および復元が可能です。これは、大きな変更を行う際に以前のバージョンのシーンをバックアップしておく必要がある場合に役立ちます。",
    "url": "/233f8961/",
    "relUrl": "/233f8961/"
  },
  "172": {
    "id": "172",
    "title": "作業ファイル",
    "content": "作業ファイルFile Open ダイアログ作業領域を移動するメイン ダイアログは半分ずつに分かれています。左側には一連のタブがあります。最初のタブは「My Tasks」と呼ばれ、現在のユーザに割り当てられているすべてのタスクが表示されます。Flow Production Tracking の Web サイトのマイ タスクページに非常によく似ています。エンティティのタブを使用して Flow Production Tracking エンティティを参照することもできます。既定では、作業ファイル アプリケーションにより、それぞれのタブを確認することでショットまたはアセットに関連したタスクを参照できます。一連のタブは、環境ファイルの entities 設定を利用して完全に設定可能です。アプリ設定で show_file_open: true/false を設定すると、このダイアログを無効または有効にできます。ファイルを検索する右側には、左側で選択した内容に関連する作業ファイルとパブリッシュが表示されます。作業ファイルとパブリッシュは、「All」、「Working」、「Publishes」の各タブを使用して一緒に表示したり、別々に表示したりできます。以前のバージョンにアクセスする以前のバージョンにアクセスする方法は 2 つあります。1 つ目の方法では、ブラウザ上部の「All versions」ボックスをクリックしてバージョンを展開し、ブラウザですべてのバージョンを個別に表示します。もう 1 つの方法では、ファイルを右クリックし、最新 10 件のバージョンにアクセスします。ユーザ サンドボックスパイプライン設定でユーザ サンドボックスを使用する場合、既定で表示されるのは現在のユーザのファイルのみです。他のユーザのサンドボックスにあるファイルを表示する場合は、上部のボタンをクリックすると、サンドボックスを選択して元のファイルを表示できます。結果を絞り込む文字を入力すると、表示の結果を絞り込むことができます。検索は項目の名前と一致します。File Save ダイアログ既定では、「File Save」ダイアログを使用すると、現在のコンテキストでファイルを保存できます。シーン名、バージョン番号、およびオプションのファイル拡張子(該当する場合)の入力が要求されます。「Save」ボタンはグレー表示されます。いったんアプリケーションでシーン名として次に利用可能なバージョン番号が確認されると、右下の「Save」ボタンが有効になります。アプリ設定で show_file_save: true/false を設定すると、このダイアログを無効または有効にできます。異なるコンテキストで保存する異なるコンテキストでファイルを保存するためにダイアログの左上にある展開ボタンをクリックすると、「File Save」ダイアログが展開し、保存先として別のコンテキストを選択できます。ファイル拡張子ドロップダウンを追加する新しい File Save ダイアログで、保存するファイルの拡張子を選択できます。これを有効にするためには、パイプライン設定の templates.yml ファイルを調整する必要があります。最初に、templates.yml 内のトークン リストでトークンを定義する必要があります。maya_extension:    type: str    choices:        ma: Maya Ascii (.ma)        mb: Maya Binary (.mb)    default: ma    alias: extensionmaya_extension はトークン名です。choices は、ドロップダウンに表示されるファイル タイプのディクショナリです。キー(ma と mb)は、このテンプレート トークンに指定できる有効な値です。値(Maya Ascii (.ma) と Maya Binary (.mb))は、Toolkit アプリケーションで使用できる UI に適した説明です。alias は作業ファイル アプリケーションで必要なヒントです。このトークンが拡張子であり、ドロップダウン ウィジェットに表示されるということがアプリケーションに通知されます。その後、このトークンは Maya 固有のテンプレートに追加できます。maya_shot_work:    definition: '@shot_root/work/maya/{name}.v{version}.{maya_extension}'    root_name: 'primary'[コンテキスト変更] (Context Change)ダイアログ[コンテキスト変更] (Context Change)ダイアログは、右側にファイルを参照する領域がないことを除けば、[開く] (Open)ダイアログと同様です。[コンテキスト変更] (Context Change)ボタンを押すと、タスクまたはエンティティを選択して、現在のエンジンのコンテキストを変更できます。アプリ設定で show_change_context: true/false を設定すると、このダイアログを無効または有効にできます。ステップ フィルタタスクを取得するときに、階層に step が含まれている場合は、パイプライン ステップのフィルタを使用して、Flow Production Tracking から取得されるデータの量を減らすことができます。選択したステップ リストにリンクされているタスクのみが取得されます。タブに表示されるステップのリストは、step_filter_on 設定によってコントロールされます。設定しない場合は、すべての既存のパイプライン ステップが表示されます。次の例では、アセットおよびショットのタスクをそれぞれ表示する 2 つのタブを定義します。  - caption: Assets Tasks    entity_type: Task    step_filter_on: Asset    filters:    - [entity, type_is, Asset]    hierarchy: [entity.Asset.sg_asset_type, entity, step, content]  - caption: Shots Tasks    entity_type: Task    step_filter_on: Shot    filters:    - [entity, type_is, Shot]    hierarchy: [entity.Shot.sg_sequence, entity, step, content]遅延クエリーエンティティ ツリーを次のように 2 つのステップ クエリーに分割して構築すると、パフォーマンスを向上させることができます。  最初のクエリーは、Flow Production Tracking からレコードを取得し、ツリーの上部に入力するために使用します。  2 番目のクエリーは、ツリーを展開するときに子を取得するために使用します。次の設定では、アプリを起動するときに Flow Production Tracking からアセットおよびショットを取得します。特定のアセットまたはショットを選択した場合、またはツリー ビューで展開した場合は、このアセットまたはショットにリンクされたタスクのみが取得されます。  entities:  - caption: Assets    entity_type: Asset    hierarchy: [sg_asset_type, code]    filters:    sub_hierarchy:      entity_type: Task      filters:      link_field: entity      hierarchy: [step]  - caption: Shots    entity_type: Shot    filters:    hierarchy: [sg_sequence, code]    sub_hierarchy:      entity_type: Task      filters:      link_field: entity      hierarchy: [step]",
    "url": "/9a736ee3/",
    "relUrl": "/9a736ee3/"
  },
  "173": {
    "id": "173",
    "title": "Nuke Quickreview",
    "content": "Nuke QuickreviewQuickreview アプリを使用すると、Nuke でレンダリングしたファイルを Flow Production Tracking に送信してレビューする作業が簡単になります。Quickreview で送信するたびに、Flow Production Tracking にバージョンが作成されます。バージョンは、Nuke 内の Flow Production Tracking ノード メニューにノードとして表示されます。新しいノードを作成し、Nuke ネットワークに接続してから、ダブルクリックして[アップロード] (Upload)ボタンをクリックするだけです。次の UI が表示され、Flow Production Tracking でのバージョンの作成方法を制御できるようになります。次のアイテムを制御できます。  バージョン名は現在ロードされている Nuke スクリプトに基づいて事前に入力され、必要に応じて調整することができます。  バージョンに関連付けられているエンティティ リンクおよびタスクは現在のコンテキストに基づいて決まり、調整することができます。  送信するフレーム範囲を調整することができます。  作成されたバージョンは、プレイリストに追加できます。最新のプレイリストを含むドロップ ダウンが表示されます。[アップロード] (Upload)ボタンをクリックすると、Nuke 内に QuickTime が生成されて、Flow Production Tracking にアップロードされます。アップロードすると、次の画面が表示され、Nuke に組み込まれている Flow Production Tracking Panel や Web オーバーレイ プレイヤにバージョンを表示できるようになります。バーンインとスレート既定では、アプリはスレートおよびバーンインを使用して QuickTime を生成します。 カスタマイズレビュー送信のほとんどの要素は、フックを使用して調整できます。ドキュメントについては、こちらを参照してください。",
    "url": "/40da6878/",
    "relUrl": "/40da6878/"
  },
  "174": {
    "id": "174",
    "title": "Nuke Write Node",
    "content": "Nuke Write NodeNuke Write Node アプリは、イメージのレンダリング先を簡単に標準化できる、カスタムの Flow Production Tracking 書き込みノードを提供します。各環境に合わせた設定が可能です。パス以外に、使用するレンダリング形式も設定で決まります。一般用途Flow Production Tracking Write Node を使用するには、最初にスクリプトを Toolkit 作業ファイルとして保存し、Nuke メニューから新しいノードを作成します。これにより、通常の書き込みノードに類似したノードが作成されます。手動でパスを入力するのではなく、出力名を指定するだけで、Toolkit が残りのパスを自動的に計算してくれます。計算されたパスが UI に表示されます。Show in File System ボタンをクリックすると、ディスク上の該当する場所が開きます。レンダリングの書き込み先は Toolkit の設定に応じて異なります。レンダリングはバージョンで管理され、バージョン番号は、Multi Publish を使用してパブリッシュする場合に自動的に増分される現在の Nuke スクリプト バージョンに常に準拠します。レンダリング パスをリセットするWrite Node は、ファイルを Toolkit 作業領域外から開いても有効になるように現在のパスをキャッシュ化します。場合によっては、パスが同期できなくなり「ロック状態」になることがあります。レンダリング パスがロックされた場合、この Write Node で作成されたレンダリングはパブリッシュできません。レンダリング パスをリセットするには、作業ファイル アプリの「Version Up Scene」コマンドを使用してシーンをバージョンアップするか、書き込みノードを個別に選択して Reset Path をクリックします。別の書き込みノード プロファイルを追加するFlow Production Tracking Write Node は Nuke に組み込まれた書き込みノードをラップするため、Nuke でサポートされている形式をアプリで使用して、別のノードを設定から追加できます。最も簡単な開始方法は、任意のパラメータを使用して簡単な Nuke 書き込みノードをセットアップすることです。次の例では、LZW 圧縮で 16 ビット TIF を実行しているものと仮定します。テキスト エディタで Nuke スクリプトを確認すると、書き込みノードは次のように表示されます。Write {    file /Users/ryanmayeda/Desktop/test.%04d.tif    file_type tiff    datatype &quot;16 bit&quot;    compression LZW    checkHashOnRead false    name Write1    xpos -145    ypos -61}テキストから必要なパラメータ名と値が分かります。この場合は datatype と compression です。次に、環境設定(例: /path/to/pipeline/config/env/shot_step.yml)に移動し、tk-nuke-writenode アプリを設定する領域を探します。settings に次の 2 つのパラメータを指定した別の Write Node を追加します。tk-nuke-writenode:  location: {name: tk-nuke-writenode, type: app_store, version: v0.1.6}  template_script_work: nuke_shot_work  ...  write_nodes:  - file_type: exr    ...  - file_type: dpx    ...  - file_type: tiff    name: Mono Tif    publish_template: nuke_shot_render_pub_mono_tif    render_template: nuke_shot_render_mono_tif    proxy_publish_template: null    proxy_render_template: null    settings: {datatype: 16 bit, compression: LZW}    tank_type: Rendered Image    tile_color: []    promote_write_knobs: []設定を更新すると、追加した Flow Production Tracking Write Node が Nuke で表示されるようになります。注: 新しいテンプレート(nuke_shot_render_mono_tif など)はプロジェクト設定(&amp;lt;configuration root&amp;gt;/config/core/templates.yml)内の templates.yml ファイルに必ず追加してください。別の例として、圧縮を 0.5、サブサンプリングを 4:2:2 に設定した JPEG に出力する Flow Production Tracking Write Node を追加する方法を以下に示します。また、このプロファイルは JPEG 品質ノブをギズモのユーザ インタフェースにまでプロモートする「promote_write_knobs」オプションも使用します。これにより、プロファイルの品質に既定の値が設定され、この設定自体を変更するためのスライダもユーザに表示されます。tk-nuke-writenode:  write_nodes:    - file_type: jpeg      name: Compressed JPEG      publish_template: nuke_shot_render_pub_jpeg      render_template: nuke_shot_render_jpeg      proxy_publish_template: null      proxy_render_template: null      settings: {_jpeg_quality: 0.5, _jpeg_sub_sampling: &quot;4:2:2&quot;}      tank_type: Rendered Image      tile_color: []      promote_write_knobs: [_jpeg_quality]書き込みノブをプロモートする上記のプロファイルに示すように、カプセル化された書き込みノードのノブをプロモートして、Flow Production Tracking Write Node のプロパティ パネルに表示することができます。プロモートされた書き込みノブはプロファイルの一部として定義され、ノブ名で識別されます。複数のノブをプロモートすることができます。レンダリング ファーム統合レンダリング時に通常 Nuke を直接起動するジョブ管理ツール(Deadline など)を実行するレンダリング ファームを使用することは一般的です。このようなツールは、Flow Production Tracking が認識できる方法(デスクトップや tank コマンドなどの使用)で Nuke を起動しないため、Flow Production Tracking 書き込みノードには Nuke を実行するために必要な情報が保持されません。この制限を回避するために、いくつかのオプションが用意されています。Flow Production Tracking 書き込みノードを標準の Nuke 書き込みノードに変換する簡単な方法は、Flow Production Tracking 書き込みノードを標準の Nuke 書き込みノードに変換してから、レンダリングするスクリプトを送信することです。これには次の 2 つのオプションがあります。1. 変換メニュー オプションを有効にして、使用します。2. この API 変換方法をアプリ上で使用します。変換メニューオプションを有効にするyml 環境ファイル内のアプリの設定に追加できる、show_convert_actions という名前の設定オプションがあります。設定 show_convert_actions: True を追加するときに、[SG 書き込みノードを書き込みノードに変換…] (Convert SG Write Nodes to Write Nodes…)および[書き込みノードを SG 形式に再変換…] (Convert Write Nodes back to SG format…)メニュー オプションが使用できるようになります。ただし、書き込みノブをプロモートする、定義済みの Flow Production Tracking 書き込みノード プロファイルがある場合は、show_convert_actions が True に設定されている場合でも、このメニュー オプションは表示されません。これは、現時点で、再変換機能がプロモートされたノブをサポートしていないためです。API を使用して変換するこの変換を実行する convert_to_write_nodes() メソッドが、tk-nuke-writenode アプリに用意されています。スクリプト内のすべての Flow Production Tracking 書き込みノードを標準の Nuke 書き込みノードに変換するには、Nuke 内で次のコードを実行します。import sgtkeng = sgtk.platform.current_engine()app = eng.apps[&quot;tk-nuke-writenode&quot;]if app:    app.convert_to_write_nodes() これにより、シーンから Flow Production Tracking 書き込みノードが削除されるため、レンダリングするスクリプトのコピーを作成し、そのコピーを変換してファームに送信するというワークフローをお勧めします。シーンには Toolkit の参照が含まれなくなっているため、レンダリング ファームで Nuke スクリプトを開いたときに、Toolkit は不要になります。注: 対応する convert_from_write_nodes() メソッドを使用できますが、データの整合性を維持するために、パイプラインの一部としてではなく、デバッグでのみ使用することをお勧めします。init.py を使用して Flow Production Tracking Toolkit エンジンをブートストラップするNuke は、プラグイン パス上にあるすべての init.py スクリプトを実行します。このオプションを使用すると、tk-nuke エンジンの最小限のブートストラップを実行するコードが init.py に追加されるため、Flow Production Tracking 書き込みノードはレンダリング ファーム上で期待どおりに動作します。このワークフローにはいくつかの手順があります。最初に、Flow Production Tracking 対応の Nuke セッション内で実行される「pre-flight」送信スクリプトによって、ファーム ジョブの環境設定に使用するデータが取得されます。次に、レンダリング ファーム管理者が、レンダリング ファーム上の Flow Production Tracking セッションを認証するために使用する追加の環境変数を設定します。最後に、Flow Production Tracking ブートストラップ コードを含む init.py が、レンダリング ファーム上の Nuke セッションによって検出および実行される場所に配置され、セッション内で tk-nuke エンジンをブートストラップします。これにより、Flow Production Tracking 書き込みノードが適切に機能するようになります。1.事前送信スクリプトこの方法は、アーティストが Nuke の Flow Production Tracking 対応セッション内でファーム ジョブを送信していることが前提となります。送信時に、次のコードを実行する必要があります。これにより、Toolkit コンテキスト、パイプライン設定 URI、Toolkit Core API の場所など、環境に関する情報が現在の Nuke セッションから取得されて、ディクショナリに入力されます。このディクショナリがレンダリング ジョブに渡され、そこでこの情報を使用して環境変数が設定されます。# Populating environment variables from running Nuke:# https://developer.shotgridsoftware.com/tk-core/platform.html#sgtk.platform.create_engine_launchercurrent_engine = sgtk.platform.current_engine()launcher = sgtk.platform.create_engine_launcher(     current_engine.sgtk,     current_engine.context,     current_engine.name)# Get a dictionary with the following keys:# SHOTGUN_SITE: The Flow Production Tracking site url# SHOTGUN_ENTITY_TYPE: The Flow Production Tracking Entity type, e.g. Shot# SHOTGUN_ENTITY_ID: The Flow Production Tracking Entity id, e.g. 1234environment = launcher.get_standard_plugin_environment()# Get the current pipeline config descriptorenvironment[&quot;SHOTGUN_CONFIG_URI&quot;] = os.path.join(current_engine.sgtk.configuration_descriptor.get_uri(),&quot;config&quot;)# Get the current tk-core installation pathenvironment[&quot;SHOTGUN_SGTK_MODULE_PATH&quot;] = sgtk.get_sgtk_module_path()この情報の収集が完了したら、レンダリング送信ツールに渡すことができます。このプロセスは、使用しているレンダリング ファーム管理システムによって異なります。レンダリング送信スクリプトの記述方法の詳細については、ファーム管理システムのドキュメントを参照してください。2. Flow Production Tracking 認証ブートストラップ API の ToolkitManager を初期化するには、スクリプト ユーザが必要です。オートデスクの例では、ファーム マシン上にサイト名、スクリプト ユーザ、およびスクリプト キーが環境変数として存在することを想定しています。通常、これはレンダリング ファームの管理者によって管理されます。次に、オートデスクのコードで想定されている環境変数の名前と、サンプル値を示します。SHOTGUN_SITE = “https://mysitename.shotgunstudio.com”SHOTGUN_FARM_SCRIPT_USER = “sg_api_user”SHOTGUN_FARM_SCRIPT_KEY = “xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx”認証の詳細については、開発者向けドキュメントを参照してください。スクリプト ユーザの保護に関する注意事項: ファームで使用するスクリプト ユーザをロックして、管理者レベルの権限が付与されないようにすることをお勧めします。こちらで、API ユーザの権限を確認してください。3.init.py スクリプトこの時点で、レンダリング送信ツールから Toolkit 環境データが渡されていて、レンダリング ファーム マシンの環境変数に認証データが格納されています。レンダリング ジョブ内で Toolkit をブートストラップするためには、最後に、次の init.py サンプル コードを Nuke のプラグイン パスに配置して、Nuke を開始するときに起動されるようにする必要があります。(詳細については、スタートアップ スクリプトに関する Foundry のドキュメントを参照してください。)# This script shows how a Toolkit as a plugin approach could be used to bootstrap# Toolkit in Nuke on the render farm.# https://developer.shotgridsoftware.com/tk-core/bootstrap.html#bootstrapping-toolkitimport sysimport os# If your render nodes can access the same tk-core install location as# artist workstations, retrieve its path from the environment and ensure# it is in the PYTHONPATHTK_CORE_PATH = os.environ[&quot;SHOTGUN_SGTK_MODULE_PATH&quot;]if TK_CORE_PATH not in sys.path:    sys.path.append(TK_CORE_PATH)# If your render nodes don’t have access to the Toolkit Core API in the same filesystem location as artist workstations, you have to make sure that it is available in the PYTHONPATH, so that render nodes can import it. An easy way # to install tk-core in a centralized location is with pip. You can read more # about it here:# https://developer.shotgridsoftware.com/tk-core/bootstrap.html#installing-the-sgtk-module-using-pipimport sgtk# Authenticate using a pre-defined script user.sa = sgtk.authentication.ShotgunAuthenticator()# Here we retrieve credentials from environment variables, assuming a script user# will be used when rendering. This should be typically be handled by your render# farm administrators.SG_SITE_URL = os.environ[&quot;SHOTGUN_SITE&quot;]SG_SCRIPT_USER = os.environ[&quot;SHOTGUN_FARM_SCRIPT_USER&quot;]SG_SCRIPT_KEY = os.environ[&quot;SHOTGUN_FARM_SCRIPT_KEY&quot;]user = sa.create_script_user(    api_script=SG_SCRIPT_USER,    api_key=SG_SCRIPT_KEY,    host=SG_SITE_URL)# Start up a Toolkit Manager with our script usermgr = sgtk.bootstrap.ToolkitManager(sg_user=user)# Set the base pipeline configuration from the environment variable:mgr.base_configuration = os.environ[&quot;SHOTGUN_CONFIG_URI&quot;]# Disable Flow Production Tracking lookup to ensure that we are getting the Pipeline # Configuration defined in SHOTGUN_CONFIG_URI, and not a dev or override# Pipeline Configuration defined in Flow Production Tracking.mgr.do_shotgun_config_lookup = False# Set a plugin id to indicate to the bootstrap that we are starting# up a standard Nuke integrationmgr.plugin_id = &quot;basic.nuke&quot;# Retrieve the Toolkit context from environment variables:# SHOTGUN_SITE: The Flow Production Tracking site url# SHOTGUN_ENTITY_TYPE: The Flow Production Tracking Entity type, e.g. Shot# SHOTGUN_ENTITY_ID: The Flow Production Tracking Entity id, e.g. 1234sg_entity = mgr.get_entity_from_environment()# Now start up the Nuke engine for a given Flow Production Tracking Entitynuke_engine = mgr.bootstrap_engine(&quot;tk-nuke&quot;, entity=sg_entity)設定がこの例よりも複雑な場合、または Nuke (.nk)スクリプトでなく -t フラグを使用して、Python スクリプトをコマンド ラインに渡している場合は、このスクリプトを拡張しなければならない可能性があります。期限固有の手順Deadline は、レンダリング時に Nuke スクリプトを一時的な場所にコピーします。この手順を行うと、Toolkit が認識可能なディスク上の場所にファイルが存在しなくなるため、問題が発生します。この動作を無効にして元の場所からスクリプトをロードするには、次の操作を行います。  Deadline で、Tools &amp;gt; Configure Plugin に移動します(スーパー ユーザ モード)  [Enable Path Mapping]オプションを無効にします。技術の詳細アプリでは次の API メソッドを使用できます。get_write_nodes()現在のシーンの Flow Production Tracking 書き込みノードすべてが含まれるリストを返します。list app.get_write_nodes()パラメータと戻り値  戻り値: list - シーン内で見つかった Toolkit 書き込みノードのリスト例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()get_node_name()指定した書き込みノードの名前を返します。string get_node_name(node ノード)パラメータと戻り値  node ノード: クエリーする書き込みノード  戻り値: string - ノードの名前例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_name(nodes[0])get_node_profile_name()指定した書き込みノードによって使用される設定プロファイルの名前を取得します。string get_node_profile_name(node ノード)パラメータと戻り値  node ノード: クエリーする書き込みノード  戻り値: string - 設定で定義されたこの書き込みノードのプロファイル名例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_profile_name(nodes[0])get_node_render_path()指定した書き込みノードがイメージのレンダリング先として使用するパスを取得します。string get_node_render_path(node ノード)パラメータと戻り値  node ノード: クエリーする書き込みノード  戻り値: string - このノードのレンダリング パス例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_path(nodes[0]) get_node_render_files()指定した書き込みノードに対してレンダリングされているすべてのイメージ ファイルのリストを取得します。list get_node_render_files(node ノード)パラメータと戻り値  node ノード: クエリーする書き込みノード  戻り値: list - この書き込みノードでレンダリングされるイメージ ファイルのリスト例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_files(nodes[0])get_node_render_template()設定の定義に従い、指定した書き込みノードに対するレンダリング イメージが書き込まれる場所を決定するテンプレートを取得します。template get_node_render_template(node ノード)パラメータと戻り値  node ノード: クエリーする書き込みノード  戻り値: template - このノードが使用するように設定されているレンダリング テンプレート例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_template(nodes[0]) get_node_publish_template()設定の定義に従い、指定した書き込みノードに対するレンダリング イメージがパブリッシュされる場所を決定するテンプレートを取得します。template get_node_publish_template(node ノード)パラメータと戻り値  node ノード: クエリーする書き込みノード  戻り値: template - このノードが使用するように設定されているパブリッシュ テンプレート例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_publish_template(nodes[0]) get_node_proxy_render_path()指定した書き込みノードがプロキシ イメージのレンダリング先として使用するパスを取得します。string get_node_proxy_render_path(node ノード)パラメータと戻り値  node ノード: クエリーする書き込みノード  戻り値: string - このノードのプロキシ レンダリング パス例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_path(nodes[0]) get_node_proxy_render_files()指定した書き込みノードに対してレンダリングされているすべてのプロキシ イメージ ファイルのリストを取得します。list get_node_proxy_render_files(node ノード)パラメータと戻り値  node ノード: クエリーする書き込みノード  戻り値: list - この書き込みノードでレンダリングされるプロキシ イメージ ファイルのリスト例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_files(nodes[0])get_node_proxy_render_template()設定の定義に従い、指定した書き込みノードに対するプロキシ レンダリング イメージが書き込まれる場所を決定するテンプレートを取得します。指定したノードにプロキシ レンダリング テンプレートが設定されていない場合は、代わりに通常のレンダリング テンプレートを返します。template get_node_proxy_render_template(node ノード)パラメータと戻り値  node ノード: クエリーする書き込みノード  戻り値: template - このノードが使用するように設定されているプロキシ レンダリング テンプレート例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_template(nodes[0]) get_node_proxy_publish_template()設定の定義に従い、指定した書き込みノードに対するプロキシ レンダリング イメージがパブリッシュされる場所を決定するテンプレートを取得します。指定したノードにプロキシ パブリッシュ テンプレートが設定されていない場合は、代わりに通常のパブリッシュ テンプレートを返します。template get_node_proxy_publish_template(node ノード)パラメータと戻り値  node ノード: クエリーする書き込みノード  戻り値: template - このノードが使用するように設定されているプロキシ パブリッシュ テンプレート例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_publish_template(nodes[0]) get_node_published_file_type()設定の定義に従い、指定した書き込みノードがレンダリング イメージに対してパブリッシュ ファイルを作成するときに使用されるパブリッシュ ファイル タイプを取得します。string get_node_published_file_type(node ノード)パラメータと戻り値  node ノード: クエリーする書き込みノード  戻り値: string - このノードが使用するように設定されているパブリッシュ ファイル タイプ例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_published_file_type(nodes[0]) generate_node_thumbnail()指定した書き込みノードのサムネイルを生成します。一時ファイル(.png)として最大サイズ 800x800 ピクセルでシーケンスの中からフレームをレンダリングします。不要になったら、呼び出し側がこのファイルをクリーンアップします。string generate_node_thumbnail(node ノード)パラメータと戻り値  node ノード: クエリーする書き込みノード  戻り値: string - ディスク上にあるレンダリングされたサムネイル イメージのパス例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.generate_node_thumbnail(nodes[0]) reset_node_render_path()現在のスクリプトと一致するように、指定した書き込みノードのレンダリング パスをリセットします。None reset_node_render_path(node ノード)パラメータと戻り値  node ノード: クエリーする書き込みノード  戻り値: None - 値は何も返されません。例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.reset_node_render_path(nodes[0]) is_node_render_path_locked()指定した書き込みノードのレンダリング パスがロック状態かどうかを判別します。bool is_node_render_path_locked(node ノード)パラメータと戻り値  node ノード: クエリーする書き込みノード  戻り値: bool - レンダリング パスがロックされている場合は True で、それ以外の場合は False です例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.is_node_render_path_locked(nodes[0]) convert_to_write_nodes()現在のスクリプトで見つかったすべての Flow Production Tracking 書き込みノードを標準の Nuke 書き込みノードに変換します。追加の Toolkit 情報は「tk_*」という名前のユーザ ノブに保存されます。None convert_to_write_nodes()例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.convert_to_write_nodes() convert_from_write_nodes()以前に Flow Production Tracking 書き込みノードから変換された標準の Nuke 書き込みノードを、すべて Flow Production Tracking 書き込みノードに戻します。None convert_from_write_nodes()例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.convert_from_write_nodes() process_placeholder_nodes()プレースホルダ ノードを完全な Flow Production Tracking 書き込みノードに変換します。これは主に、スクリプトを最初に Nuke で開いたときに Hiero Toolkit スクリプト書き出し機能によって作成されるプレースホルダ ノードを変換するために使用します。None process_placeholder_nodes()例&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.process_placeholder_nodes() ",
    "url": "/09168e73/",
    "relUrl": "/09168e73/"
  },
  "175": {
    "id": "175",
    "title": "Nuke",
    "content": "NukeFlow Production Tracking Engine for Nuke は、Flow Production Tracking アプリと Nuke、Nuke Studio、および Hiero を統合するための標準プラットフォームを提供します。軽量で操作性に優れており、たくさんの新しい項目を Nuke に追加できます。Nuke に Flow Production Tracking メニューが作成され、さまざまな項目が表示されます。Nuke に Flow Production Tracking ノード メニューが作成され、さまざまな項目が表示されます。ファイル システムのさまざまな場所に簡単にジャンプできる Flow Production Tracking ショートカットがファイル ダイアログに追加されます。favourite_directories 設定を使用すると、現在の環境のテンプレート パスに基づいて独自のショートカットを追加できます。この設定は、リスト内の各項目が新しいお気に入りのディレクトリを表す、ディクショナリのリストを必要とします。次に、使用するフォーマットの例を示します(値として「”“」と指定すると、アイコンを未指定のまま残すこともできます)。  favourite_directories:  - display_name: &quot;Shot Publish Path&quot;    template_directory: &quot;shot_publish_area_nuke&quot;    icon: &quot;icons/custom_publish_icon.png&quot;  - display_name: &quot;Shot Work Path&quot;    template_directory: &quot;shot_work_area_nuke&quot;    icon: &quot;icons/custom_work_icon.png&quot;[Flow Production Tracking の現在のプロジェクト] (Shotgun Current Project)というお気に入りが、定義済みの各ルートに自動的に追加されます。project_favourite_name 設定を使用して名前をカスタマイズするか、値を空の文字列 '' に設定してお気に入りを無効にします。サポート対象のアプリケーション バージョンこの項目はテスト済みです。次のアプリケーション バージョンで動作することが分かっています。12.0 - 14.0v5最新のリリースでの動作は十分可能ですが、正式なテストはまだ完了していません。注: 現在、CentOS 6.5 上で実行される Nuke 8.0 に限り、バグによって Toolkit の実行時に Nuke がクラッシュしてしまいます。他のバージョンの CentOS には影響ありません。Foundry はこの問題を認識しています(バグ 43766)。この問題が発生した場合は、当社までお問い合わせください。Nuke の今後の更新で解決されるまで、問題の回避をお手伝いします。アプリ開発者向けの情報コンテキストのトラッキングFlow Production Tracking Engine for Nuke は、ファイルのロード時にコンテキストを自動的に切り替えます。ファイルをロードすると、エンジンがファイルを確認してからコンテキストを解決します。カスタム ギズモを使用するアプリFlow Production Tracking Engine for Nuke を使用すると、カスタム ギズモを簡単に処理できます。カスタム ギズモを使用するアプリを作成する場合、gizmos と呼ばれるフォルダにドロップするだけで、エンジンがこの場所を Nuke のパスに自動的に追加します。これでノード作成機能からギズモに簡単にアクセスできます。  nuke.createNode(&quot;WriteTank&quot;)                    警告: ギズモを使用すると便利ですが、ノードを作成してシーン内で保持する場合、一般的には適切な方法ではありません。その理由は、シーン内にギズモを配置するとすぐに、このシーンとギズモ コードの間に依存関係が生まれるためです。シーンのロードのたびに Flow Production Tracking Toolkit をロードする必要があるだけでなく、コードを更新するときにシーン内で使用されている古いギズモが分割されないように慎重に管理する必要もあります。    ノードを作成するアプリカスタム Nuke ノードを作成するアプリは慎重に作成する必要があります。シーンとギズモ コードの間に依存関係が必要になるため、ギズモを使用しないことをお勧めします。その代わりに、カスタム ノードを Nuke ファイルとして保存し、シーンに読み込みます。    group_node_script = os.path.join(self.disk_location, &quot;resources&quot;, &quot;my_group_node.nk&quot;)    group_node = nuke.nodePaste(group_node_script)アプリ内からノードを呼び出すコードは、返されたインスタンスのみを使用できます。グループ内からアプリを呼び出す必要があるコードは下位互換性を持つように慎重に処理する必要があります。次の手順をお勧めします。アプリの起動時に、アプリ ハンドルを Nuke ネームスペースの一部として登録します。    def init_app(self):        nuke.tk_nuke_nameofmyapp = selfたとえば、グループ ノードにボタンがあり、何らかの Flow Production Tracking アプリ コードを呼び出す場合、Flow Production Tracking Toolkit が見つからないときには故意に失敗するようにしてください。次のコードは、アプリが作成したグループ ノードに属している Python ボタン ノブに関連付けられたコードです。# have to gracefully support the case when# sgtk is not in the system at all!import nuketry:  app = nuke.tk_nuke_nameofmyapp  app.do_something_v1(nuke.thisNode())except:  nuke.warning(&quot;Could not do XYZ! Most likely Sgtk is not currently active.&quot;)アプリの動作を変更する場合は、アプリのコールバックでバージョン番号を最新にしておきます。これにより、アプリ コードは新旧両方の動作をサポートできます。Hiero 内で Flow Production Tracking Engine for Nuke を使用するFlow Production Tracking Engine for Nuke は、Hiero 内で実行される Flow Production Tracking 対応の統合にも使用されます。アプリケーションの複数の場所(メイン メニュー バーの特定の Flow Production Tracking メニューや、他の Hiero パネルにあるさまざまな右クリック コンテキスト メニュー)に、Flow Production Tracking アプリのアクションを登録できます。Hiero メニューの設定方法Hiero にはいくつかの異なるメニューがあるため、Maya や Nuke などよりも、メニュー項目の配置先を設定するオプションがたくさんあります。Flow Production Tracking Engine for Nuke の Hiero ワークフロー設定は次のようになります。  tk-hiero:    location: {name: tk-nuke, type: app_store, version: v0.6.9}    debug_logging: false    timeline_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: Open in Shotgun, requires_selection: true}    spreadsheet_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: Open in Shotgun, requires_selection: true}    bin_context_menu:    - {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;Flow Production Tracking Save As...&quot;, requires_selection: true}    - {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;Version up Current Scene...&quot;, requires_selection: true}    - {app_instance: tk-multi-snapshot, keep_in_menu: false, name: &quot;Snapshot...&quot;, requires_selection: true}    - {app_instance: tk-multi-snapshot, keep_in_menu: false, name: &quot;Snapshot History...&quot;, requires_selection: true}    - {app_instance: tk-multi-publish, keep_in_menu: false, name: &quot;Publish Project...&quot;, requires_selection: true}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: Shotgun File Manager...}ほとんどのエンジンには menu_favourites オプションがあります。これは、Flow Production Tracking のメイン メニューに登録する「ショートカット」を指定するリストです。これとは別に、Hiero 固有の設定には次の 3 つの特別なセクションがあります。  timeline_context_menu は、タイム ライン エディタのクリップを右クリックすると表示されるメニューを表します。  spreadsheet_context_menu は、スプレッドシート エディタの項目をクリックすると表示されるメニューを表します。  bin_context_menu は、bin エディタの項目を右クリックすると表示されるメニューを表します。ここにはさまざまなプロジェクトとメディアがすべて表示されます。これらのメニューに項目を追加するには、設定で定義する name フィールドとアプリがメニューに表示する内容が一致するようにするだけです。現在のシーンという概念を必要とするアプリ一部の Toolkit アプリには、既定のシーンまたはプロジェクトの概念が必要です。たとえば、スナップショット アプリは現在のシーンのスナップショットを作成する方法を把握しています。ただし、Maya や Nuke とは異なり、Hiero に現在のシーンという概念はありません。Hiero では複数のプロジェクトを同時に開くことができます。そのため、アプリがクリック対象のプロジェクトを理解できるようにするため、多くの場合フックに特別なロジックを追加することが必要になります。以降のセクションではこの仕組みについて説明します。アプリ開発者向けの情報Hiero には現在のプロジェクトという概念がないため、アプリが Hiero 内でクリックされた内容を簡単に確認できるようにするため、たくさんの強力なツールが追加されています。Flow Production Tracking Engine for Hiero には、次の 2 つのメソッドが追加されています。get_menu_selection()最後にクリックしたメニューで選択された Hiero オブジェクトのリストを返します。このリストにはさまざまなタイプの項目が含まれます。どのメソッドで何が返されたのかを正確に確認するには、デバッグ ログをオンにします。これにより動作内容の詳細が出力されます。返されるオブジェクトの例は次のとおりです。  bin ビューでプロジェクトを選択する: hiero.core.Bin  bin ビューで項目を選択する: hiero.core.BinItem  トラックを選択する: hiero.core.TrackItemlist engine_object.get_menu_selection()パラメータと戻り値  戻り値: Hiero オブジェクトのリスト例最後にクリックして選択したオブジェクトを取得します。1 つのオブジェクトが選択されており、このオブジェクトが有効な Hiero プロジェクトであることを確認します。これは Hiero でプロジェクトの保存、ロード、またはパブリッシュ操作をトリガする場合などに役立ちます。# get the menu selection from the engineselection = engine_obj.get_menu_selection()if len(selection) != 1:    raise TankError(&quot;Please select a single Project!&quot;)if not isinstance(selection[0] , hiero.core.Bin):    raise TankError(&quot;Please select a Hiero Project!&quot;)project = selection[0].project()if project is None:    # apparently bins can be without projects (child bins I think)    raise TankError(&quot;Please select a Hiero Project!&quot;)HieroEngine.get_menu_category()最後にクリックしたメニューがある UI 領域を返します。このコマンドはあまり使用しないかもしれません。読み出し元のメニューに応じて異なる動作を求めるアプリ コマンドを使用する場合に必要になることがあります。area_enum engine_object.get_menu_category()パラメータと戻り値次の定数の 1 つを返します。  HieroEngine.HIERO_BIN_AREA  HieroEngine.HIERO_SPREADSHEET_AREA  HieroEngine.HIERO_TIMELINE_AREA  None (不明または未定義の場合)Hiero と連携するようにフックを設定する方法通常、Hiero で設定したマルチ アプリでは、どのプロジェクトがクリックされているかを特定する必要があります。たとえば、tk-multi-workfiles アプリでプロジェクトの[Flow Production Tracking を名前を付けて保存] (Shotgun Save As)を実行する必要があるとします。そのため、ユーザが bin ビュー内のプロジェクトを右クリックして [名前を付けて保存] (Save As)オプションを選択できるように、Hiero の bin メニューに Tank Save As コマンドを追加します。エンジンの設定は次のようになります。bin_context_menu:- {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;Flow Production Tracking Save As...&quot;, requires_selection: true}ここでは、アプリ自体の各エンジンで保存やロードなどのシーン イベントを処理するフックを設定する必要があります。Maya や Nuke などのアプリケーションの場合、通常は保存やロードなどを実行するだけです。ただし Hiero の場合は、実際にクリックされたプロジェクトを見つけてから開始する必要があります。前述のフック コードの例は、次のようになります。class SceneOperation(Hook):    &quot;&quot;&quot;    Hook called to perform an operation with the    current scene    &quot;&quot;&quot;    def execute(self, operation, file_path, context, **kwargs):        &quot;&quot;&quot;        Main hook entry point        :operation: String                    Scene operation to perform        :file_path: String                    File path to use if the operation                    requires it (e.g. open)        :context:   Context                    The context the file operation is being                    performed in.        :returns:   Depends on operation:                    'current_path' - Return the current scene                                     file path as a String                    'reset'        - True if scene was reset to an empty                                     state, otherwise False                    all others     - None        &quot;&quot;&quot;        if operation == &quot;current_path&quot;:            # return the current script path            project = self._get_current_project()            curr_path = project.path().replace(&quot;/&quot;, os.path.sep)            return curr_path        elif operation == &quot;open&quot;:            # open the specified script            hiero.core.openProject(file_path.replace(os.path.sep, &quot;/&quot;))        elif operation == &quot;save&quot;:            # save the current script:            project = self._get_current_project()            project.save()        elif operation == &quot;save_as&quot;:            project = self._get_current_project()            project.saveAs(file_path.replace(os.path.sep, &quot;/&quot;))        elif operation == &quot;reset&quot;:            # do nothing and indicate scene was reset to empty            return True        elif operation == &quot;prepare_new&quot;:            # add a new project to hiero            hiero.core.newProject()    def _get_current_project(self):        &quot;&quot;&quot;        Returns the current project based on where in the UI the user clicked        &quot;&quot;&quot;        # get the menu selection from the engine        selection = self.parent.engine.get_menu_selection()        if len(selection) != 1:            raise TankError(&quot;Please select a single Project!&quot;)        if not isinstance(selection[0] , hiero.core.Bin):            raise TankError(&quot;Please select a Hiero Project!&quot;)        project = selection[0].project()        if project is None:            # apparently bins can be without projects (child bins I think)            raise TankError(&quot;Please select a Hiero Project!&quot;)        return projectメニュー イベントの確認にデバッグ ログを使用する特定の選択項目がクリックされた場合に Hiero から返されるオブジェクトを確認するには、エンジン デバッグ モードをオンにするだけです。スクリプト エディタで、各クリックで選択したオブジェクトの概要を取得します。",
    "url": "/4dc252e5/",
    "relUrl": "/4dc252e5/"
  },
  "176": {
    "id": "176",
    "title": "Photoshop",
    "content": "PhotoshopFlow Production Tracking Engine for Photoshop CC は、Flow Production Tracking と Photoshop CC のワークフローを統合するプラットフォームを提供します。Flow Production Tracking Toolkit の標準エンジンで構成され、tk-framework-adobe (CEP)を使用します。有効にすると、ShotGridAdobe パネルを Photoshop CC で使用できるようになります。現在の Flow Production Tracking コンテキストの情報とそのコンテキストにインストールされたアプリに登録されているコマンドが表示されます。サポート対象のアプリケーション バージョンこの項目はテスト済みです。次のアプリケーション バージョンで動作することが分かっています。2020 (v21.0) - 2023 (v24.7) Note: Apple Silicon (M1/M2) native is not supported, Apple Silicon with Rosetta is supported, learn more here.最新のリリースでの動作は十分可能ですが、正式なテストはまだ完了していません。インタフェースの概要Flow Production Tracking 拡張パネルは、Photoshop CC のネイティブ パネルと同じカラー パレットと基本レイアウトを使用します。次の 5 つのコンポーネントで構成されます。  コンテキスト ヘッダ: 現在のコンテキストのサムネイルとフィールドです。  お気に入りシェルフ: 現在のコンテキストで最もよく使用するアプリを表示するように設計されています。  コマンド リスト: 現在のコンテキストのお気に入りではないすべてのコマンドです。  コンテキスト メニュー: 追加のコンテキスト関連コマンドとデバッグ ツールです。  ロギング コンソール: デバッグのログ出力を表示するコンソール オーバーレイです。インストールFlow Production Tracking Engine for Photoshop CC のインストールには、Flow Production Tracking と他の製品を統合する場合と同じプロトコルを使用します。エンジンやアプリのインストールについては、「Toolkit を管理する」という記事を参照してください。また、統合の設定方法の例については、「Toolkit の既定の設定」を参照してください。拡張機能を有効にする拡張機能をインストールしたら、Photoshop CC の拡張メニューから起動する必要があります。これは、1 回のみ実行する必要があります。それ以降は起動すると、有効にしなくても、Flow Production Tracking 拡張機能パネルが Photoshop CC のレイアウトに表示されるようになります。一度有効にすると、それ以降の起動では、Flow Production Tracking 統合のブートストラップ時に、拡張パネルにロード画面が表示されます。通常、この画面は、現在のコンテキストが決定され、コマンドが表示されるまでの数秒間表示されます。インタフェースのコンポーネント以降のセクションでは、Flow Production Tracking と Photoshop CC を統合した場合のコンポーネントについて説明します。コンテキスト ヘッダコンテキスト ヘッダは、現在の Flow Production Tracking コンテキストに関する情報を表示するカスタマイズ可能な領域です。コンテキストは現在アクティブなドキュメントによって決定されます。コンテキストがエンジンによって決定されると、ヘッダはコンテキストのサムネイル フィールドの詳細を表示するように更新されます。フィールド情報はフックで制御されます。フィールド表示のカスタマイズ方法については、「コンテキスト フィールド表示フック」を参照してください。また、Photoshop CC はマルチドキュメント インタフェースであるため、アクティブなドキュメントを変更するとコンテキストが更新され、それに従って Flow Production Tracking 拡張機能も更新されます。アーティストは、複数の Flow Production Tracking コンテキストで同時に作業する場合は特に、この動作を把握していることが重要です。お気に入りシェルフお気に入りシェルフは、Maya や Houdini のような他の Flow Production Tracking DCC 統合で利用できるお気に入りメニューと似ています。インタフェースのこのセクションはコンテキスト ヘッダのすぐ下にあるので、よく使用する Toolkit アプリが使いやすく、簡単に見つけられるようになります。シェルフにはお気に入りのコマンドがボタンで表示されます。マウスを上に重ねると、灰色から色付きに変化し、上部のラベルにその名前が表示されます。マウスを上に重ねると、ボタンの説明が表示されます。いずれかのボタンをクリックすると、実行する登録済みコマンドのコールバックがトリガされます。コマンドをお気に入りとして指定する方法については、下記の「shelf_favorites」セクションを参照してください。コマンド リストコマンド リストには、現在のコンテキストに登録されているその他の「標準」コマンドが表示されます。通常、パイプライン設定内にインストールされたアプリはここに表示される 1 つまたは複数のコマンドを登録します。コマンドがお気に入りとして識別されず、コンテキスト メニュー コマンドとしても識別されていない場合は、ここに表示されます。コマンド リスト ボタンは、お気に入りシェルフ内のボタンと同じように動作します。唯一異なる点は、アイコンの右側に完全な名前のリストとして表示されることです。コンテキスト メニューコンテキスト メニュー コマンドとして登録されているコマンドは、Flow Production Tracking 拡張パネルのコンテキスト メニューに表示されます。他のコマンド領域と同様に、このコマンドはコンテキストに応じて変化します。Jump to Flow Production Tracking や Jump to Filesystem などのコマンドは常にここから使用できます。ロギング コンソールロギング コンソールは、CEP JavaScript インタプリタと Toolkit の Python プロセスの両方のログ出力をすべて表示します。拡張機能に問題があり、サポートが必要な場合、ロギング コンソール出力は、Flow Production Tracking のサポート チームが問題をデバッグする際に非常に役立ちます。設定と技術の詳細次のセクションでは、貴社のパイプライン固有のニーズに合わせて統合を設定できるよう、統合の技術的な側面について少し説明します。PySideFlow Production Tracking Engine for Photoshop CC は PySide を使用します。Pyside のインストールについては、Pyside をインストールする公式の手順を参照してください。CEP 拡張機能拡張機能自体はエンジンにバンドルされており、エンジンが Photoshop CC の初回起動時に自動的にインストールします。拡張機能は、アーティストが使用するローカル マシンにある OS 固有の標準的な CEP 拡張ディレクトリにインストールされます。# Windows&amp;gt; C: Users [user name] AppData Roaming Adobe CEP extensions # OS X&amp;gt; ~/Library/Application Support/Adobe/CEP/extensions/Photoshop CC を起動すると、エンジン ブートストラップ コードは、エンジンにバンドルされている拡張機能のバージョンとマシン上にインストールされているバージョンを比較します。つまり、新しいバージョンの拡張機能がバンドルされている場合は、エンジンを更新するとインストールされている拡張機能がバンドルされている新しいバージョンに自動的にアップデートされます。お気に入りを設定するお気に入りシェルフは、インストールしたアプリに登録されているコマンドを表示するように設定できます。表示するには、shelf_favorites 設定を環境設定の tk-photoshopcc セクションに追加するだけです。次に例を示します。shelf_favorites:    - {app_instance: tk-multi-workfiles2, name: File Save...}    - {app_instance: tk-multi-workfiles2, name: File Open...}    - {app_instance: tk-multi-publish, name: Publish...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}設定の値は、環境設定にインストールされたアプリの 1 つで提供される、登録済みコマンドを識別するディクショナリのリストです。app_instance キーは特定のインストール済みアプリを識別し、name キーはこのアプリによって登録されたコマンドの表示名に一致します。上記の例では、4 つのお気に入りコマンドが表示されています。tk-multi-workfiles2 アプリのファイルの表示と保存のダイアログと、標準の Toolkit のパブリッシュとスナップショットのダイアログです。これら 4 つのコマンドはお気に入りシェルフに表示されます。コンテキスト フィールド表示フックエンジンには、パネルのコンテキスト ヘッダ セクションに表示されるフィールドを制御するフックがあります。フックには表示する内容をカスタマイズするためにオーバーライドできる 2 つのメソッドがあります。最初のメソッドは get_entity_fields() メソッドです。このメソッドは、現在の Flow Production Tracking コンテキストを表すエンティティ タイプを受け入れます。予想される戻り値は、表示するためにクエリーの必要があるエンティティのフィールドのリストです。エンジン自体はデータのクエリーを非同期に処理します。Flow Production Tracking からデータをクエリーすると、フックの 2 番目のメソッドが呼び出されます。この get_context_html() メソッドは、get_entity_fields() メソッドで指定されたクエリー フィールドが入力されたコンテキスト エンティティ ディクショナリを受け取ります。予想される戻り値は、クエリー対象のエンティティ フィールドを表示するためにフォーマット化された HTML を含む文字列です。これらのメソッドで必要とされる内容については、「既定のフックの実装」を参照してください。エンジンは、エンティティのサムネイルが使用可能であれば、それを常に表示します。Photoshop APIエンジンは Photoshop CC の JavaScript API を Python に公開します。Photoshop API オブジェクトは engine.adobe として公開されます。次の例では、Toolkit のアプリやフック内から Photoshop DOM を直接操作する方法を示します。標準的な Toolkit アプリには、Photoshop マニュアルの操作方法に関する作業例が含まれています。例ファイルをロードする。f = adobe.File('/Path/To/File.jpeg')adobe.app.load(f)ルーラの単位をピクセルに設定する。pixels = adobe.Units.PIXELSadobe.app.preferences.rulerUnits = pixels既定のオプションを使用して Web の現在のドキュメントを書き出す。temp_thumb_file = adobe.File(out_path)save_for_web = adobe.ExportType.SAVEFORWEBexport_options = adobe.ExportOptionsSaveForWeb()adobe.app.activeDocument.exportDocument(temp_thumb_file, save_for_web, export_options)各レイヤを個別のファイルとして書き出す。doc = adobe.app.activeDocumentlayers = doc.artLayerslayers = [layers[i] for i in xrange(layers.length)]original_visibility = [layer.visible for layer in layers]save_for_web = adobe.ExportType.SAVEFORWEBexport_options = adobe.ExportOptionsSaveForWeb()for layer in layers:    layer.visible = Falsefor layer in layers:    layer.visible = True    out_file = adobe.File(&quot;c:/layer.%s.jpg&quot; % str(layer.name))    doc.exportDocument(        out_file,        save_for_web,        export_options,    )    layer.visible = Falsefor (i, layer) in enumerate(layers):    layer.visible = original_visibility[i]環境変数デバッグをサポートするために、エンジンの既定値の一部を変更する環境変数のセットが用意されています。SHOTGUN_ADOBE_HEARTBEAT_INTERVAL: Python ハートビート間隔(秒単位、既定は 1 秒)。従来の環境変数 SGTK_PHOTOSHOP_HEARTBEAT_INTERVAL が設定されている場合は優先されます。SHOTGUN_ADOBE_HEARTBEAT_TOLERANCE: 終了までのハートビートのエラー数(既定は 2)。従来の環境変数 SGTK_PHOTOSHOP_HEARTBEAT_TOLERANCE が設定されている場合は優先されます。SHOTGUN_ADOBE_NETWORK_DEBUG: ログ出力時に追加のネットワーク デバッグ メッセージを含めます。従来の環境変数 SGTK_PHOTOSHOP_NETWORK_DEBUG が設定されている場合は優先されます。SHOTGUN_ADOBE_PYTHON: エンジンの起動時に使用する Python の実行可能ファイルへのパス。設定しない場合は、システムの Python が使用されます。Photoshop が Flow Production Tracking Toolkit や tk-shell エンジンなどの Python プロセスから起動される場合、このプロセスで使用する Python は Photoshop との統合で使用されます。注: 追加の環境変数が Adobe のフレームワークに存在します。詳細については、「開発者用ドキュメント」を参照してください。アプリ開発者メモ  Python プロセスは Photoshop CC プロセスから独立しているため、アプリ ウィンドウで上記の Photoshop ウィンドウをできるだけ整理して表示するには、エンジン内でいくつかの作業を行います。このセットアップの注意点の 1 つに、QFileDialog にネイティブ OS Windows を使用する既定のオプションがあります。このエンジンを使用してアプリを開発する場合は、ネイティブのダイアログを使用しないオプションを設定してください。tk-multi-pythonconsole アプリの例を参照してください。",
    "url": "/8d461cbe/",
    "relUrl": "/8d461cbe/"
  },
  "177": {
    "id": "177",
    "title": "シェル",
    "content": "シェルシェル用の Flow Production Tracking Engine はコマンド ライン操作を処理し、Core API の 1 つとして配布される tank コマンドと緊密に統合されます。ターミナルで tank コマンドを実行すると、Toolkit はアプリの実行を処理するエンジンを起動します。tank コマンドの詳細については、「高度な Toolkit 管理」のドキュメントを参照してください。インストールと更新Flow Production Tracking Toolkit にこのエンジンを追加するProject XYZ にこのエンジンを追加するには、asset という名前の環境で次のコマンドを実行します。&amp;gt; tank Project XYZ install_engine asset tk-shell最新バージョンに更新するこの項目が既にプロジェクトにインストールされている場合に最新バージョンを取得するには、update コマンドを実行します。特定のプロジェクトに含まれている tank コマンドに移動し、そこでこのコマンドを実行します。&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updatesまたは、tank コマンドを実行し、プロジェクトの名前を指定して、更新チェックを実行するプロジェクトを指定します。&amp;gt; tank Project XYZ updatesコラボレーションと発展Flow Production Tracking Toolkit にアクセスできる場合は、すべてのアプリ、エンジン、およびフレームワークのソース コードにも Github からアクセスできます。これらは Github を使用して格納および管理しています。これらの項目は自由に発展させてください。さらなる独立した開発用の基盤として使用したり、変更を加えたり(その際はプル リクエストを送信してください)、 いろいろと研究してビルドの方法やツールキットの動作を確認してください。このコード リポジトリには、https://github.com/shotgunsoftware/tk-shell からアクセスできます。",
    "url": "/2ad59ee8/",
    "relUrl": "/2ad59ee8/"
  },
  "178": {
    "id": "178",
    "title": "Flow Production Tracking フォルダ",
    "content": "Flow Production Tracking フォルダFlow Production Tracking Toolkit には、設定に基づいて標準化されたフォルダ構造を作成するシステムが組み込まれています。このため、複数のショットで一貫したファイル システム レイアウトを簡単に作成できます。このアプリは、Sgtk Core API のファイル システム作成 API メソッドを Flow Production Tracking に接続します。これにより、一連のショットまたはアセットをクリックして、Create Folders アクションをクリックするだけで簡単にフォルダを作成できます。仕組み1 つまたは複数のタスク、ショット、または(設定に応じて)他のエンティティを選択します。ここでアクション メニューから作成フォルダを選択します。処理が完了したら、作成したフォルダの数が報告されます。",
    "url": "/134adb0e/",
    "relUrl": "/134adb0e/"
  },
  "179": {
    "id": "179",
    "title": "Flow Production Tracking 起動フォルダ",
    "content": "Flow Production Tracking 起動フォルダLaunch Folder アプリは Flow Production Tracking ユーティリティです。Flow Production Tracking からファイル システムにジャンプできるようにします。仕組みLaunch Folder アプリを使用すると、Flow Production Tracking からファイル システムにジャンプできます。このアプリは、ショット、アセット、シーケンスなどの Flow Production Tracking エンティティに登録できます。有効にすると、Action メニューに表示されます。1 つまたは複数のエントリを Flow Production Tracking で選択できます。メニュー アクションを選択すると、標準のファイル ブラウザ(Windows のエクスプローラーや Mac の Finder など)が起動されます。",
    "url": "/0c3049eb/",
    "relUrl": "/0c3049eb/"
  },
  "180": {
    "id": "180",
    "title": "Flow Production Tracking 起動パブリッシュ",
    "content": "Flow Production Tracking 起動パブリッシュこのアプリにより、Flow Production Tracking のパブリッシュされたファイルのエンティティで、[関連アプリケーションで開く] (Open in Associated Application)アクションを実行できるようになります。これにより、既にパブリッシュされたファイルを簡単に開くことができます。ファイルに移動して右クリックし、アクションを選択するだけです。このアプリにより、異なるファイルに別々のアプリ起動シーケンスを簡単に設定できます。このすべての操作はフック内から実行します。また、ビューア(RV など)にイメージ シーケンスを割り当てることもできます。このフックで認識されないファイルは、OS レベルのアプリに割り当てられます。",
    "url": "/a01dbeb7/",
    "relUrl": "/a01dbeb7/"
  },
  "181": {
    "id": "181",
    "title": "ShotGrid",
    "content": "ShotGridFlow Production Tracking Engine は Flow Production Tracking 内から起動できるアプリを管理します。この Toolkit アプリを アクション として参照することもあります。通常、このアプリは Flow Production Tracking 内のメニュー項目として表示されます。Flow Production Tracking Toolkit アクションを使用するアクションは Flow Production Tracking のホーム ページに表示されます。また、Flow Production Tracking の標準的なコンテキスト メニューにも表示されます。オブジェクトや選択項目を右クリックすると表示できます。アクションをクリックすると、処理がすぐに開始されます。アプリの処理が完了すると、通常はいくつかのステータス情報を含むメッセージが表示されます。動作しなかった場合にはエラー メッセージが表示されます。Flow Production Tracking 用のアプリを開発するFlow Production Tracking 内で実行するアプリの開発は簡単です。通常のアプリ開発の仕組みが分からない場合は、プラットフォームのマニュアルを見つけて、概要部分を確認してください。このセクションでは、Flow Production Tracking 固有のアプリ開発プロセスの側面について説明します。Core v0.13 以降では、Flow Production Tracking Engine ですべてのマルチ アプリを使用できます。技術的には、Flow Production Tracking Engine と他のエンジンの違いはほとんどありません。ただし、微妙な違いがあります。  Flow Production Tracking Engine で QT ベースのアプリを実行する場合は、標準的な Python 環境に PySide や PyQt を手動でインストールする必要があります。  Flow Production Tracking Engine では、ユーザが属する権限グループに応じてアクションを表示することができます。これは、Flow Production Tracking アクション メニューにコマンドを追加して、このコマンドを管理者にのみ表示する場合などに便利です。Flow Production Tracking アプリで、管理者にのみ「Hello, World!」と表示する場合は、次のように記述します。from tank.platform import Applicationclass LaunchPublish(Application):    def init_app(self):        &quot;&quot;&quot;        Register menu items with Flow Production Tracking        &quot;&quot;&quot;                params = {            &quot;title&quot;: &quot;Hello, World!&quot;,            &quot;deny_permissions&quot;: [&quot;Artist&quot;],        }        self.engine.register_command(&quot;hello_world_cmd&quot;, self.do_stuff, params)    def do_stuff(self, entity_type, entity_ids):        # this message will be displayed to the user        self.engine.log_info(&quot;Hello, World!&quot;)    インストールと更新Flow Production Tracking Toolkit にこのエンジンを追加するProject XYZ にこのエンジンを追加するには、asset という名前の環境で次のコマンドを実行します。&amp;gt; tank Project XYZ install_engine asset tk-shotgun最新バージョンに更新するこの項目が既にプロジェクトにインストールされている場合に最新バージョンを取得するには、update コマンドを実行します。特定のプロジェクトに含まれている tank コマンドに移動し、そこでこのコマンドを実行します。&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updatesまたは Studio の tank コマンドを実行し、プロジェクトの名前を指定して、更新チェックを実行するプロジェクトを指定します。&amp;gt; tank Project XYZ updatesコラボレーションと発展Flow Production Tracking Toolkit にアクセスできる場合は、すべてのアプリ、エンジン、およびフレームワークのソース コードにも Github からアクセスできます。これらは Github を使用して格納および管理しています。これらの項目は自由に発展させてください。さらなる独立した開発用の基盤として使用したり、変更を加えたり(その際はプル リクエストを送信してください)、 いろいろと研究してビルドの方法やツールキットの動作を確認してください。このコード リポジトリには、https://github.com/shotgunsoftware/tk-shotgun からアクセスできます。特殊な要件上記の操作を行うには、Flow Production Tracking Toolkit Core API バージョン v0.19.5 以降が必要です。",
    "url": "/02c2d8aa/",
    "relUrl": "/02c2d8aa/"
  },
  "182": {
    "id": "182",
    "title": "VRED",
    "content": "VREDFlow Production Tracking Engine for VRED は、Flow Production Tracking アプリと VRED を統合する標準プラットフォームを提供します。軽量で操作性に優れており、VRED のメニューに Flow Production Tracking のメニューを追加します。サポート対象のアプリケーション バージョンこの項目はテスト済みです。次のアプリケーション バージョンで動作することが分かっています。2020.3 - 2023最新のリリースでの動作は十分可能ですが、正式なテストはまだ完了していません。アプリ開発者向けの情報VRED プロジェクト管理Flow Production Tracking Engine for VRED が起動すると、このエンジンの設定で定義された場所を VRED プロジェクトが参照するように設定されます。つまり、新しいファイルを開くと、このプロジェクトも変更される場合があります。ファイルに基づく VRED プロジェクトの設定方法に関連する詳細設定は、テンプレート システムを使用して設定ファイルで指定できます。tk-vred を使用するこの Flow Production Tracking 統合は、VRED 製品ファミリ(Pro および Design)をサポートします。VRED を開くと、メニュー バーに Flow Production Tracking メニュー(VRED エンジン)が追加されます。ファイルの表示と保存[マイ タスク] (My Tasks)タブと[アセット] (Assets)タブを使用すると、割り当てられたすべてのタスクを表示して、アセットを参照できます。 右側では、これらのタブを使用してすべてのファイル、作業ファイル、またはパブリッシュ ファイルを表示します。これらのファイルは、左側で選択されているものに関連付けられています。パブリッシュ[パブリッシュ] (Publish)ダイアログを開き、ファイルを Flow Production Tracking にパブリッシュします。パブリッシュ ファイルは、下流工程でアーティストが使用します。VRED パブリッシュの詳細については、こちらを参照してください。 ローダーLoader: コンテンツ ローダ アプリを開きます。動作について説明するスライドも含まれています。VRED のロードの詳細については、こちらを参照してください。 シーンの詳細情報[詳細情報] (Breakdown)ダイアログが開き、「参照される」ファイル(およびそのリンク)のリストが表示され、シーン内で古くなっているものや Published File の別のバージョンを使用しているものが表示されます。",
    "url": "/9d824e0b/",
    "relUrl": "/9d824e0b/"
  },
  "183": {
    "id": "183",
    "title": "API",
    "content": "Toolkit APIここでは、Toolkit プラットフォームで提供される API のリファレンス ドキュメントを紹介します。",
    "url": "/6c5b0b61/",
    "relUrl": "/6c5b0b61/"
  },
  "184": {
    "id": "184",
    "title": "アプリ",
    "content": "Toolkit アプリここでは、Toolkit プラットフォームで使用できるアプリのリファレンス ドキュメントを紹介します。",
    "url": "/f8596e35/",
    "relUrl": "/f8596e35/"
  },
  "185": {
    "id": "185",
    "title": "環境設定",
    "content": "環境設定リファレンスはじめにToolkit パイプラインの中心にあるのは環境設定です。Toolkit パイプライン設定内の環境構成ファイルでは、さまざまな DCC 内で使用可能な Toolkit アプリを定義し、それぞれの設定をカスタマイズできます。このドキュメントは環境設定ファイルの構造と機能についての完全なリファレンスです。ここでは、プロジェクト内のさまざまなワークフローを設定するための Toolkit の「環境」の概念、環境設定の構成、ファイル参照、そしてどのようなカスタマイズが行えるかを確認する方法について説明します。                    注: このドキュメントは環境設定ファイルのリファレンスとして使用しますが、『パイプライン設定の編集に関する Toolkit の基本ガイド』には、構成設定を編集するステップバイステップの手順が例として記載されています。    環境についてFlow Production Tracking Toolkit プラットフォームは、一般的に使用されるコンテンツ作成ソフトウェア用に、完全にカスタマイズ可能な統合セットを提供するため、これを使用してスタジオのパイプラインを構築できます。プロジェクトの構成において、統合されているソフトウェア パッケージはどれか、そのそれぞれで利用可能な Toolkit アプリはどれかを指定し、さらに各アプリのオプションを指定することにより、スタジオのニーズに合わせてアーティストのワークフローを構築できます。しかし、スタジオのパイプラインでは、さまざまなタイプのアーティストが異なるワークフローを使用するのが一般的です。簡単な例として、アセットを扱うアーティストの場合は Mari などのテクスチャ ペイント ソフトウェアを利用可能にし、ショットを扱うアーティストの場合は Nuke などの合成ソフトウェアを利用可能にします。ソフトウェア パッケージの他にも、異なるアーティストに対して、同じ Toolkit アプリで異なる設定を使用することができます。たとえば、ショットのアーティストとアセットのアーティストの両方が Workfiles アプリを使用することがありますが、ショットのアーティストは Shot エンティティ、アセットのアーティストは Asset エンティティに関連付けられているファイルにのみナビゲートできるように制限することができます。プロジェクト内でこれらの個別のワークフローをサポートするために、Toolkit はアプリとエンジンの構成を環境上で分離しています。環境には、一連のソフトウェア パッケージの統合とその設定が含まれています。それらのすべてには、特定の共通するコンテキストがあります。上記の例では、アセットを扱うアーティストはアセットの手順の環境で作業し、ショットを扱うアーティストはショットの手順の環境で作業しています。環境はそれぞれ独立して構成されているため、プロジェクト内で異なるワークフローを使用できます。Toolkit の既定の設定に関するメモToolkit での環境設定の構築には多くの自由が与えられています。このドキュメントは利用可能なすべてのオプションのリファレンスで、実際のパイプラインのニーズに最も適した選択をするのに必要な知識を得ることができます。またこのドキュメントでは、既定の設定と呼ばれる、パイプライン設定の出発点として選択された特別な設定についても説明します。パイプラインをカスタマイズする準備が整ったら、最初の手順はプロジェクト用の編集可能なパイプライン設定を作成することです。これらの選択は単なる規則であり、Toolkit のワークフローにハードコードされているわけではありませんが、既定の設定を例として参照すると、パイプラインのカスタマイズを開始した後に使用できる機能や、独自の設定を構築するためのベスト プラクティスについて学ぶことができます。また、新しい Toolkit ユーザが既定の設定を出発点として参照すれば、Toolkit の規則について知るのにも役立ちます。このドキュメントでは、Toolkit の環境設定の一般的な機能と、既定の設定における特定の選択とを常に区別します。既定の設定の環境構成の詳細については、README ファイルを参照してください。ファイルの場所パイプライン設定内の config/ ディレクトリには、カスタマイズ対象のすべてのファイルとフォルダが含まれています。config/ には、cache、core、および env の 3 つのサブディレクトリがあります。env ディレクトリには環境設定ファイルが保持されるため、このドキュメントでは config/env 内のファイルを参照します。既定の設定では、config/env/ に次のファイルが表示されます。asset.ymlasset_step.ymlproject.ymlsequence.ymlshot.ymlshot_step.ymlこれらの各ファイルは環境に対応しています。異なるファイルを含めることで、各環境を別々に設定できます。Toolkit が現在の環境を判断する仕組みToolkitは pick_environment というコア フックを使用し、現在のコンテキストに基づいて特定の時点で使用する環境ファイルを決定します。pick_environment フックの戻り値は環境設定ファイルに対応しています。たとえば、pick_environment が shot_step を返した場合、Toolkit は config/env/shot_step.yml を使用して Toolkit 環境を設定します。カスタム環境上記の環境設定ファイルは、既定の設定で提供されます。ただし、スタジオによっては、異なる環境や追加の環境を採用することがあります。たとえば、スタジオによっては、パイプラインのステージごとに異なる構成設定が必要な場合があります(asset_step_rig、asset_step_model、shot_step_anim、shot_step_light など)。その場合、利用可能な環境を完全にカスタマイズできます。これを行うには、目的の環境設定ファイルを config/env ディレクトリに追加します。次に、pick_environment コア フックをオーバーライドして、新しい環境をいつ使用するかを定義するロジックを追加します。基本構造Toolkit の設定ファイルは YAML で記述されます。バンドル(アプリ、エンジン、またはフレームワーク)の一般的な設定の構成は次のとおりです。bundle_name:  setting1: value  setting2: value  complex_setting:    sub_setting1: value      Sub_setting2: value  location:    type: descriptor_type    descriptor_setting1: value    descriptor_setting2: valueこの構成を説明するために、非常に単純な例を示します。単一のエンジンがあり、その中に単一のアプリケーションが定義されている環境です。以下は、この設定の project.yml の内容です。engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4エンジン ブロックすべての環境設定ファイルは engines ブロックで始まります。ここに、その環境用に定義されているすべてのエンジンがネストされています。この例では、単一のエンジン tk-maya のみが定義されています。apps と location の 2 つの設定がリストされています。location はすべてのバンドルに必要な特別な設定です。apps 設定はエンジンに定義されたすべてのアプリのリストで、それぞれ独自の設定があります。この場合、エンジンに対して定義されるアプリは 1 つのみです(tk-multi-workfiles2)。ロケーション ディスクリプタすべての Toolkit バンドルには location 設定があり、これをバンドルの「ディスクリプタ」と呼びます。ディスクリプタは、特定のバンドルの入手元、およびそのタイプに応じて直接アクセスするかローカルにキャッシュするかを Toolkit に指示します。Toolkit バンドルは、Flow Production Tracking App Store、git リポジトリ、ディスク上のパス、Flow Production Tracking サイトにアップロードされた zip ファイルなどから入手できます。これらには、それぞれ対応するディスクリプタ タイプがあり、そのタイプに固有の設定があります。以下に、上記の例の tk-maya エンジンのディスクリプタをもう一度示します。    location:        type: app_store        name: tk-maya        version: v0.9.4これは、タイプが app_store のディスクリプタです。指定したバンドルを Flow Production Tracking App Store から入手するように Toolkit に指示します。タイプ app_store のディスクリプタの設定は name と version です。対照的に、スタジオでカスタム バンドルをアクティブに開発している場合、たとえば特定のワークフロー用の Toolkit アプリを作成している場合は、ディスク上のパスから直接入手することができます。この場合、以下に示すようにタイプ dev のディスクリプタを使用します。    location:        type: dev        path: /path/to/appdev ディスクリプタは app_store ディスクリプタとは設定が異なります。他の設定を使用することもできますが、ディスク上のアプリの場所を参照する path 設定を使用して簡単にセットアップすることができます。利用可能なすべてのディスクリプタ タイプとその設定に関する詳細は、Toolkit Core API ドキュメントの「ディスクリプタ」セクションを参照してください。アプリ ブロックアプリは Toolkit のユーザ ツールであり、各アプリは他のアプリから独立して実行できます。パイプラインのニーズに基づいてどのアプリを使用するかを選択できます。エンジン ブロック内の apps 設定は、特定のエンジンで使用できるアプリを定義します。以下に、上記の例の apps 設定をもう一度示します。engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8単一のアプリ、tk-multi-workfiles2 アプリが定義されていることがわかります。現在のところ、単一の設定、すなわちディスクリプタのみが定義されています。project 環境の tk-maya エンジンで他のアプリを利用できるようにするには、ここで追加します。ここでは、エンジンに Panel、tk-multi-shotgunpanel、および About アプリ、tk-multi-about を追加します。例の project.yml ファイルは次のようになります。engines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4ここでは、いくつかの重要な注意事項があります。  既定の設定ではバンドルがアルファベット順にリストされ、この例ではその規則に従います。  ファイルが長くなり始めていますが、構成設定はまだ追加していません。  他のエンジンや他の環境でこれらと同じアプリを使用していることが想像できます。たとえば、Panel、About アプリ、Workfiles アプリの 3 つのすべてのアプリが、異なるエンジン(Houdini、Nuke、Photoshop など)および異なる環境(asset_step や shot_step)で実行されている可能性があります。設定内の異なる場所で共通のアプリ設定を定義することは、変更が必要なときに、それぞれの場所で変更が必要になることを意味します。最後の 2 つの問題を軽減するために、Toolkit 設定はインクルードをサポートします。インクルード「インクルード」を使用すると、あるファイルのセクションを構成内の別のファイルで参照できます。インクルードを使用すると、構成設定を一箇所で設定し、複数の環境で使用できます。インクルードは次の 2 つの部分で構成されます。  includes リスト: キーが includes で、インクルードするすべてのファイルのリストを値に持つ YAML 辞書。  構成設定内の参照。@ 記号で始まり、インクルード ファイルから参照するセクションの名前をポイントする名前が付けられています。上記の例を具体化するために、すべてのエンジンのロケーション ディスクリプタを保持する単一のファイルを作成しているとします。そのファイルを includes サブフォルダに置き、engine_locations.yml という名前を付けます。engine_locations.yml の内容は以下のようになります。config/env/includes/engine_locations.yml:engines.tk-maya.location:  type: app_store  name: tk-maya  version: v0.9.4engines.tk-nuke.location:  type: app_store  name: tk-nuke  version: v0.11.5...このファイルはすべてのエンジンの場所に対する単一のソースとして機能し、すべての環境設定から参照することができます。このインクルード ファイルを使用した場合、この例は次のようになります。config/env/project.yml:includes:- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location: @engines.tk-maya.locationここでは、tk-maya エンジンの location 設定の値が、インクルードされる YAML ファイルのキーを参照していることがわかります。                    注: この例では、既定の設定の規則に従い、すべてのエンジンの場所を config/env/includes/engine_locations.yml ファイルに含めています。    アプリの場所を示すために、2 番目のインクルード ファイルを追加することができます。実際には、これは既定の設定によって行われます。例を拡張してみましょう。config/env/includes/app_locations.yml:apps.tk-multi-about.location:  type: app_store  name: tk-multi-about  version: v0.2.8apps.tk-multi-shotgunpanel.location:  type: app_store  name: tk-multi-shotgunpanel  version: v1.6.3apps.tk-multi-workfiles2.location:  type: app_store  name: tk-multi-workfiles2  version: v0.11.8config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.locationインクルードされた engine_locations.yml ファイルから tk-maya エンジンのディスクリプタを取得し、インクルードされた app_locations.yml ファイルから tk-maya エンジン用に定義された各アプリのディスクリプタを取得します。                    注: 既定の設定では、この例では示されていない 2 番目のネスト レベルを使用しています。単なるディスクリプタ以上の設定を持つすべてのアプリまたはエンジンは、includes/settings に設定ファイルがあります(例: includes/settings/tk-maya.yml、includes/settings/tk-multi-workfiles2.yml)。エンジン設定ファイルには、アプリ設定ファイルからのアプリ設定が含まれ、環境設定ファイルにはエンジン設定ファイルからの設定が含まれています。既定の設定の構造の詳細については、README ファイルを参照してください。構成設定の変更に関する詳細な手順については、『構成設定の編集に関する Toolkit の基本ガイド』を参照してください。    スパース構成すべての Toolkit バンドルには、使用可能な構成設定のセットがあり、それぞれの設定に既定値があります。Toolkit は「スパース構成」を許可します: 構成設定が環境設定ファイル(またはそこに含まれるファイル)で明示的に指定されていない場合、バンドルの既定値が使用されます。この例では、location 以外にアプリの設定を指定していません。したがって、設定の現在の状態では、3 つのアプリはすべての設定に既定値を使用します。それでは、どの構成設定が利用可能であるかを知るにはどうすれば良いでしょうか。                    注: Toolkit の構成がスパース構成であることは必須ではありませんが、既定の設定はスパース構成です。    利用可能な構成設定を検出するスパース構成では、単に設定ファイルを見ただけでは、どの構成設定がアプリに使用できるかをすぐに判断することはできません。アプリで利用可能な構成設定を確認する場合、2 つの選択肢があります。  アプリのドキュメント: 各アプリには独自のドキュメント ページがあり、それぞれのページに「設定オプション」セクションがあります。このセクションでは、アプリで使用可能なすべての構成設定が、それぞれの説明と既定値と共に一覧表示されています。たとえば、Workfiles ドキュメント ページを参照することができます。アプリとエンジンのページには、すべてのアプリとエンジンのドキュメント ページが一覧表示されています。  マニフェスト: すべての Toolkit バンドルは、そのルート ディレクトリに info.yml というファイルを含んでいます。このファイルをバンドルの「マニフェスト」と呼び、バンドルで利用可能なすべての設定を、それぞれの説明と既定値と共に定義します。マニフェストは、バンドルの独自のキャッシュ(パイプライン設定内の install/app_store/tk-multi-workfiles2/v0.11.8/info.yml など)、または Github (ここでは Workfiles の場合の例を示します)にあります。構成設定を修正する既定値の設定を変更するには、パイプライン設定の適切な環境で、適切なブロックに構成を追加し、その値を設定します。例に戻って、プロジェクト環境で Maya が起動されると tk-multi-workfiles2 が自動的に起動するように設定してみましょう。アプリのマニフェストを見ると、アプリの起動時に Workfiles UI を起動するかどうかを制御する launch_at_startup 設定があり、その既定値が False であることがわかります。そこで、launch_at_startup オプションを追加して True に設定します。project.yml ファイルは次のようになります。config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        launch_at_startup: True        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.locationtk-multi-workfiles2 の設定がインクルード ファイルからのものである場合は、そのファイルでこの変更を行います。その他の参考情報  Toolkit の基本ガイド: パイプライン設定を編集する  Toolkit の基本ガイド: アプリを追加する  アニメーション パイプラインのチュートリアル  ディスクリプタのリファレンス ドキュメント  ウェビナー: Toolkit の管理  ファイル システム設定リファレンス  既定の設定の環境構成に関する README",
    "url": "/c73fcb84/",
    "relUrl": "/c73fcb84/"
  },
  "186": {
    "id": "186",
    "title": "環境設定",
    "content": "Toolkit の設定ここでは、Toolkit プラットフォームの設定に関するリファレンス ドキュメントを紹介します。",
    "url": "/10e8ee51/",
    "relUrl": "/10e8ee51/"
  },
  "187": {
    "id": "187",
    "title": "Flow Production Tracking のイベント デーモンを使用してさまざまな Toolkit コア モジュールをロードするにはどうすればいいですか?",
    "content": "shotgunEvent デーモンを使用してさまざまな Toolkit コア モジュールをロードするにはどうすればいいですか?Benoit Leveau @ Milk VFX の協力に感謝します。問題Toolkit の sgtk API はプロジェクト中心です。つまり、API を使用するプロジェクトから明示的に API を読み込まなければなりません。つまり、1 つの Python セッションで複数のプロジェクトに対して sgtk API 操作を使用すると、Python では同じ名前のモジュールを 1 回しか読み込めないため、問題が発生します。Flow Production Tracking Event デーモン を使用している場合、特定のイベントについてはプラグイン内で Toolkit のアクションを実行することができます。 これは、Python がモジュールを一度しか読み込まないため少々厄介です。そのため、プロジェクト A の Toolkit Core API をプラグインの初回実行時に読み込む場合、このバージョンはデーモンの存続期間中読み込まれたままになります。つまり、プラグインに割り当てられる次のイベントがプロジェクト B 用である場合、プロジェクト A の Core API を使用してプロジェクト B の新しい Toolkit オブジェクトのインスタンスを作成しようとすると、Toolkit にエラーが表示されます。一元管理設定を使用する場合の問題の例:  イベント 123 はプロジェクト A 用である。  プロジェクト A 用の Core API が /mnt/toolkit/projectA/install/core/python に配置されている。  このディレクトリの先頭に sys.path を追加する。  import sgtk でこの場所から読み込む。  この Core API を使用して Toolkit のインスタンスを作成していくつかのアクションを実行する。  sys.path から Core API ディレクトリを取り出す。  イベント 234 はプロジェクト B 用である。  プロジェクト B 用の Core API が /mnt/toolkit/projectB/install/core/python に配置されている。  このディレクトリの先頭に sys.path を追加する。  Python に sgtk が既に読み込まれていると表示されるため、import sgtk は何も実行しない  この Core API を使用して Toolkit のインスタンスを作成していくつかのアクションを実行する。  これにより、Toolkit コアがアクションの実行対象のプロジェクト(B)とは異なるプロジェクト(A)用であるため、エラーが発生します。解決策次の例では、異なるバージョンのモジュールが既に読み込まれている場合にスクリプトやプラグインで正しいバージョンの sgtk コアを読み込む方法を説明します。元の読み込みのロードが解除され、Python のメモリから削除されるため、モジュールの新しいインスタンスを読み込んで適切に使用することができます。&quot;&quot;&quot;Example of how to import the correct sgtk core code in a script wherea different instance of the module may have already been imported. Theoriginal import is unloaded and removed from memory in Python so the newinstance of the module can be imported and used successfully.Thanks to Benoit Leveau @ Milk VFX for sharing this.&quot;&quot;&quot;import osimport sysdef import_sgtk(project):    &quot;&quot;&quot;    Import and return the sgtk module related to a Project.    This will check where the Core API is located on disk (in case it's localized or shared).    It shouldn't be used to get several instances of the sgtk module at different places.    This should be seen as a kind of 'reload(sgtk)' command.    :param project: (str) project name on disk for to import the Toolkit Core API for.    &quot;&quot;&quot;    # where all our pipeline configurations are located    shotgun_base = os.getenv(&quot;SHOTGUN_BASE&quot;, &quot;/mnt/sgtk/configs&quot;)    # delete existing core modules in the environment    for mod in filter(lambda mod: mod.startswith(&quot;tank&quot;) or mod.startswith(&quot;sgtk&quot;), sys.modules):        sys.modules.pop(mod)        del mod    # check which location to use to import the core    python_subfolder = os.path.join(&quot;install&quot;, &quot;core&quot;, &quot;python&quot;)    is_core_localized = os.path.exists(os.path.join(shotgun_base, project, &quot;install&quot;, &quot;core&quot;, &quot;_core_upgrader.py&quot;))    if is_core_localized:        # the core API is located inside the configuration        core_python_path = os.path.join(shotgun_base, project, python_subfolder)    else:        # the core API can still be localized through the share_core/attach_to_core commands        # so look in the core_Linux.cfg file which will give us the proper location (modify this        # to match your primary platform)        core_cfg = os.path.join(shotgun_base, project, &quot;install&quot;, &quot;core&quot;, &quot;core_Linux.cfg&quot;)        if os.path.exists(core_cfg):            core_python_path = os.path.join(open(core_cfg).read(), python_subfolder)        else:            # use the studio default one            # this assumes you have a shared studio core installed.            # See https://developer.shotgridsoftware.com/b12f2510/#how-do-i-share-the-toolkit-core-between-projects            core_python_path = os.path.join(shotgun_base, &quot;studio&quot;, python_subfolder)    # tweak sys.path to add the core API to the beginning so it will be picked up    if sys.path[0] != &quot;&quot;:        sys.path.pop(0)    sys.path = [core_python_path] + sys.path    # Remove the TANK_CURRENT_PC env variable so that it can be populated by the new import    if &quot;TANK_CURRENT_PC&quot; in os.environ:        del os.environ[&quot;TANK_CURRENT_PC&quot;]    # now import the sgtk module, it should be found at the 'core_python_path' location above    import sgtk    return sgtk分散設定上の例では、一元管理設定を使用していると想定しており、分散設定を使用している場合は、状況が多少異なります。分散設定用の sgtk API を読み込むには、ブートストラップ APIを使用する必要があります。ブートストラップ API を使用する場合は、通常プロジェクト中心ではない sgtk API を読み込むことから始め、それを使用して特定のプロジェクトのエンジンをブートストラップします。ブートストラップ プロセスは sgtk モジュールのスワップ アウトを処理するので、ブートストラップ プロセスの最後にはエンジン オブジェクトがあります。ブートストラップの後に sgtk を読み込むと、プロジェクトに適した適切な sgtk モジュールが読み込まれます。上記の例のように複数のプロジェクトに対して sgtk をロードする必要がある場合は、代わりに複数のプロジェクトに対してブートストラップする必要があります。ここで少し問題になるのは、一度に実行できるエンジンは 1 つであるため、別のエンジンをロードする前に現在のエンジンを破棄する必要があることです。                    警告: 設定をブートストラップする場合、設定をローカルにキャッシュし、すべての依存関係をダウンロードする必要があるため、処理が遅くなる可能性があります。Event デーモン プラグインのブートストラップはパフォーマンスに深刻な影響を与える可能性があります。考えられるアプローチの 1 つは、プロジェクトのブートストラップごとに別々の Python インスタンスを生成し、プラグインからの通信によりコマンドを送信することです。これにより、必要になるたびにプロジェクトをブートストラップし直す必要がなくなります。    次に例を示します。# insert the path to the non project centric sgtk APIsys.path.insert(0,&quot;/path/to/non/project/centric/sgtk&quot;)import sgtksa = sgtk.authentication.ShotgunAuthenticator()# Use the authenticator to create a user object.user = sa.create_script_user(api_script=&quot;SCRIPTNAME&quot;,                            api_key=&quot;SCRIPTKEY&quot;,                            host=&quot;https://SITENAME.shotgunstudio.com&quot;)sgtk.set_authenticated_user(user)mgr = sgtk.bootstrap.ToolkitManager(sg_user=user)mgr.plugin_id = &quot;basic.&quot;engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity={&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176})# import sgtk again for the newly bootstrapped project, (we don't need to handle setting sys paths)import sgtk# perform any required operations on Project 176 ...# Destroy the engine to allow us to bootstrap into another project/engine.engine.destroy()# now repeat the process for the next project, although we don't need to do the initial non-project centric sgtk import this time.# We can reuse the already import sgtk API to bootstrap the next...                    注: 一元管理設定もブートストラップすることができるので、両方の設定が混在する場合は別の方法は必要ありません。    ",
    "url": "/3520ad2e/",
    "relUrl": "/3520ad2e/"
  },
  "188": {
    "id": "188",
    "title": "Toolkit エンジンでサポートされる OS のバージョン",
    "content": "Toolkit エンジンでサポートされる OS のバージョン次に、Toolkit エンジンでサポートされているオペレーティング システムのリストを示します。            Windows      macOS      Linux                  10      10.14+ 注: M1 ネイティブはサポートされていません。M1 と Rosetta を併用することはできません。詳細については、こちらを参照してください。      CentOS 7.4、Rocky 8.5      ",
    "url": "/918daccf/",
    "relUrl": "/918daccf/"
  },
  "189": {
    "id": "189",
    "title": "エンジンでサポートされるバージョン",
    "content": "Toolkit エンジンでサポートされるバージョン次に、Toolkit プラットフォームで使用可能なエンジンでサポートされているアプリケーションの最小バージョンのリストを示します。            統合      エンジン      サポートされるバージョン                        tk-3dsmax      2020 - 2023                    tk-aftereffects      2020 (v17.0) - 2023 (v23.6)                    tk-alias      2020 - 2023                    tk-flame      2020+                    tk-houdini      17.5 - 19.5 Note: Running on Apple Silicon (M1/M2), Houdini is supported for both Native mode and Rosetta mode.                    tk-mari      4.0 - 6.0v2                    tk-maya      2020 - 2024 Note: Apple Silicon (M1/M2) native is supported starting with Maya 2024.                    tk-motionbuilder      2020 - 2024                    tk-nuke      12.0 - 14.0v5                    tk-photoshopcc      2020 (v21.0) - 2023 (v24.7) Note: Apple Silicon (M1/M2) native is not supported, Apple Silicon with Rosetta is supported, learn more here.                    tk-vred      2020.3 - 2023      ",
    "url": "/cc3d2160/",
    "relUrl": "/cc3d2160/"
  },
  "190": {
    "id": "190",
    "title": "エンジン",
    "content": "Toolkit エンジンここでは、Toolkit プラットフォームで使用できるエンジンのリファレンス ドキュメントを紹介します。",
    "url": "/3a69db47/",
    "relUrl": "/3a69db47/"
  },
  "191": {
    "id": "191",
    "title": "フレームワーク",
    "content": "Toolkit のフレームワークここでは、Toolkit プラットフォームで使用可能なフレームワークのリファレンス ドキュメントを紹介します。",
    "url": "/c6db88dd/",
    "relUrl": "/c6db88dd/"
  },
  "192": {
    "id": "192",
    "title": "Toolkit の概要",
    "content": "Toolkit の概要Flow Production Tracking Toolkit のさまざまなコンセプトの概要ここでは、アプリとエンジンの仕組み、Toolkit の起動方法と現在のコンテキスト(作業領域)の管理方法、ディスク上にフォルダを作成する方法など、主要なコンセプトについて詳細に説明します。環境設定と開発に関与するユーザはここから始めることをお勧めします。このドキュメントは、Toolkit の設定を管理するユーザのみが使用可能な機能について説明します。詳細については、『Flow Production Tracking 統合管理者ガイド』を参照してください。はじめにこのドキュメントでは、いくつかの主要機能の詳細について説明します。説明、例、簡単なデモを通じて、Toolkit のすべてがおわかりいただけると思います。このドキュメントは、Toolkit に慣れる方法や、Toolkit のメリットを紹介する初心者向けのドキュメントです。すべての内容を確認すれば、いくつかの主要なコンセプトとそのコンセプトの仕組みを理解できます。以下に、Toolkit (SGTK)の簡単な説明を示します。  Toolkit は Flow Production Tracking プラットフォームを使用する Pipeline Toolkit です。このツールキットを使用すると、簡単にツールを作成してインストールできます。  Toolkit はファイル システム ベースのツールです。ディスク上の格納場所を整理できるため、ディスク上で管理するものを適切に構造化できます。  Toolkit は支援ツールです。パイプラインでデータを引き継いだり抽出化することはありませんが、アーティストが情報を見つけやすく、ミスを防ぐことができるようにする優れたツールです。  Toolkit は、パブリッシュしたものをすべて Flow Production Tracking に保存して作業を共有できるようにします。Toolkit を使用すると、制作上の更新や作業を簡単に共有できます。次のセクションでは、Toolkit の詳細とその仕組みについて説明します。プロジェクトと環境設定Toolkit の環境設定は、すべてプロジェクト中心に行います。プロジェクトは通常、Flow Production Tracking 内でライフサイクルを開始し、入札とプリプロダクションの段階を経て、コンテンツを作成できる段階になったら、Toolkit をプロジェクトに合わせて設定します。新しいプロジェクトをセットアップする場合は、 テンプレート設定 を使用します。テンプレート設定には、エンジンとアプリ、ファイル システムの設定、およびその他の設定があらかじめ定義されています。Toolkit を初めて使用する場合は、まずはサンプルの設定を使用して吟味してみてください。別のプロジェクトで Toolkit を既に使用したことがある場合は、新しいプロジェクトでもまずはその設定を使用してみることをお勧めします。この方法では、スタジオの設定を展開して、それぞれの新しいプロジェクトに合わせて調整できます。もちろん、スタジオの設定を個別に管理し、新しいプロジェクトすべてのテンプレートとして使用することもできます。それぞれの設定を使用して、数多くの ストレージ ポイント を定義します。標準のサンプル設定 tk-config-default の場合、 プライマリ と呼ばれる 1 つのストレージ ポイントを定義します。つまり、すべてのプロダクション データは 1 つのファイル システムのプロジェクト ルート内に格納されます。また、複数のファイル システムのルートを使用して設定をセットアップすることもできます。これは マルチルート設定 と呼ばれます。マルチルート設定が必要な例としては、レンダリングや編集用の個別ストレージを設定する場合などがあります。各ストレージ ポイントは、Flow Production Tracking の ローカル ファイル ストレージ にする必要があります。これは、[サイト基本設定] (Site Preferences)の [ファイル管理] (File Management) タブで設定できます。Toolkit は、任意の場所に実際のプロジェクト設定をインストールします。通常、このインストール場所は、プロジェクトのデータを格納する場所ではなく、 ソフトウェアをインストール した場所になります。独自の環境設定を展開する新しいプロジェクトをセットアップする場合は、既存のプロジェクトをベースにすることができます。Toolkit は、既存のプロジェクトから新しいプロジェクトに設定フォルダをコピーします。つまり、新しいプロジェクトは、アプリとエンジンのバージョン、設定、およびカスタマイズが元のプロジェクトとまったく同じになります。これは、 パイプラインを展開 し、既存のプロダクションの一部として行った改善と調整を活用する場合に役立ちます。また、プロジェクトのセットアップに問題がなく、一元的に保存する場合は、プロジェクトの設定フォルダを使用するだけです。この設定はスタジオのテンプレートとして使用することができ、新しいプロジェクトを作成するたびにこの設定をベースにすることができます。必要に応じて、git などのリビジョン制御システムを使用すると、このスタジオ テンプレート設定をソース制御することもできます。時間の経過とともにパイプライン設定テンプレートがどのように変化をしているかを、簡単かつ透明性を確保した上でトラッキングできます。更新する場合は、1 つのプロジェクトから設定をコピーして変更をコミットするだけです。設定管理の詳細については、次の詳細ドキュメントを参照してください。プロジェクトの設定を管理するプロジェクトごとにパイプライン設定を指定するプロジェクトに Toolkit をセットアップすると、パイプライン設定が作成されます。この設定にはプロジェクトに必要なすべての設定とファイルが含まれています。この設定には専用の tank コマンドが用意されており、プロジェクトを直接操作する場合はシェルで実行できます(すべてのプロジェクトで動作するグローバルな tank コマンドもあります)。Flow Production Tracking では、ディスク上のプロジェクト設定の格納場所を簡単にトラックできるように、パイプライン設定が特別なパイプライン設定エンティティとして登録されます。プロジェクトのセットアップ時に作成されるマスター設定とは別に、プロジェクトの追加設定を作成できます。これは、プロジェクトのユーザに影響を与えることなく設定に変更を加える場合に役立ちます。それには、Flow Production Tracking でパイプライン設定に移動して右クリックし、クローンを作成します。これにより、プロジェクトに他の設定に基づいた新しいパイプライン設定が作成されます。この新しい設定を使用すると、他のユーザに影響を与えることなく、新しいアプリなどを安全にテストすることができます。プロジェクトのメイン設定は Primary という名前にする変更する必要があります。この設定の名前を変更したり、修正または削除した場合、予想どおりに動作しなくなる可能性があります。Flow Production Tracking に保存されているパイプライン設定は、手動ではなくさまざまな特定の tank 管理コマンドを使用して操作します。例:設定のクローンを作成する方法更新を確認する一般的な他のアプリ ストアと同様に、Toolkit アプリ ストアでは、新しいバージョンのアプリとエンジンを絶えず提供しています。新しいバージョンには、重大なバグの修正や便利な新機能が含まれている場合があります。アプリとエンジンのアップグレードは省略可能です。通常、このプロセスは非常に簡単で、変更を加える前にはアップグレード スクリプトによって必ずプロンプトが表示されます。同様に、誤って不要なバージョンをインストールした場合も簡単にロールバックできます。アップグレード プロセスは 1 つのコマンドで処理します。プロジェクト設定フォルダ内にある tank コマンドを実行して、パラメータ updates を追加するだけです。/software/shotgun/bug_buck_bunny/tank updatesパラメータを設定せずにこのコマンドを実行すると、すべての環境、エンジン、およびアプリがチェックされます。時間はかかりますが、インストールしたアプリとエンジンのサブセットで更新ツールを実行することもできます。一般的な構文:tank updates [environment_name] [engine_name] [app_name]特別なキーワードである ALL を使用すると、カテゴリ内のすべての項目を指定できます。例:  すべてをチェックする: tank updates  ショット環境をチェックする: tank updates Shot  すべての環境内のあらゆる Maya アプリをチェックする: tank updates ALL tk-maya  ショット環境内のあらゆる Maya アプリをチェックする: tank updates Shot tk-maya  Loader アプリが常に最新の状態を維持するようにする: tank updates ALL ALL tk-multi-loader  Loader アプリが Maya で最新の状態を維持するようにする: tank updates ALL tk-maya tk-multi-loaderこのスクリプトは、アプリ ストアだけではなく、登録された他のすべての場所もチェックするため、アプリを展開した場所に応じて、ローカルの git、Github リポジトリ、ディスク上のファイル、およびアプリ ストアをクエリーする可能性があります。新しいバージョンのアプリを導入すると、アプリ設定が変更される場合があります。たとえば、新しい機能で新しい設定パラメータが必要になる場合があります。この場合、tank アップグレード スクリプトは、このパラメータの値を入力するように求めます。Core API の更新を確認するオートデスクは、必要に応じて Toolkit Core API の新しいバージョンをリリースします。Core API の更新には個別のコマンドを使用します。この場合のコマンドは tank core です。ディスク上にフォルダを作成するプロジェクトに Toolkit をセットアップしたら、このツールキットを使用して、一貫性のあるフォルダ構造を作成できます。ディスク上でパイプライン設定の一環としてファイル システム テンプレートを作成すると、このフォルダ構造が設定されます。このフォルダ構造では、一部のパスは動的パスになります。たとえば、Flow Production Tracking アセット エンティティを表す asset と呼ばれるフォルダが作成される場合があります。この動的なフォルダは、Flow Production Tracking クエリーなどの多くの項目と結び付けることができます。Toolkit には、多種多様な設定やシナリオを処理するさまざまな動的フォルダが数多く用意されています。フォルダの作成時に標準的な Flow Production Tracking API クエリー構文を使用すると、アセットをタイプによってファイル システム上の異なるフォルダに格納するようにファイル システムを整理することもできます。この操作方法については、管理者ガイドを参照してください。Flow Production Tracking Toolkit を管理するToolkit のフォルダは 2 つのパスで作成されます。すべてのユーザがいつでも実行できるダイレクト パスと、通常はアプリケーションの起動直前にアーティストが実行する遅延パスです。この遅延パスは完全に自動で、アプリケーション固有のフォルダとユーザ サンドボックスのセットアップに使用されます。現在のコンテキストファイル システム構成が作成されると、Toolkit はディスク上のフォルダとフォルダが属する Flow Production Tracking オブジェクト間の関係を認識します。これにより、パスのパブリッシュ、ロード、解決を行うときに、Flow Production Tracking のオブジェクトとフォルダ、ディスク、またはファイルを簡単に関連付けることができるため重要です。また、 コンテキスト や 現在の作業領域 と呼ばれる場所にも関連付けられます。コンテキスト オブジェクトは Toolkit Core の一部で、作業している現在のコンテキストをトラックします。Toolkit がファイル システムのパスを解決する場合の中心的なメカニズムです。コンテキストは、タスク、アセット、ショットなどの Flow Production Tracking オブジェクトまたはディスク上のパスのいずれかから作成できます。アプリが実行されている場合は、いつでもコンテキストを利用できるため、ファイル システムの命名規則に関する情報がないアプリや、アセット パイプラインとショット パイプラインのどちらで使用するか分からないアプリを簡単に作成できます。これは Toolkit Core API とコンテキストですべて処理されます。ファイル システム テンプレートToolkit Core にはファイル パスを処理するためのシステムが含まれます。これは テンプレート システム と呼ばれています。Toolkit はファイル システム ベースであるため、アプリがディスクからデータを読み取ったり、ディスクにデータを書き込んだりする場合はファイル パスを解決する必要があります。アプリはファイル システム構成に依存しません。つまり、ファイル システムの整理方法を認識しません。テンプレート システムはこれらすべてを処理します。テンプレート システムの中心は、 テンプレート設定ファイル です。このファイルには、プロジェクトの重要なすべてのファイル システムの場所が含まれています。テンプレート は次のようになっています。maya_shot_publish: 'shots/{Shot}/{Step}/pub/{name}.v{version}.ma'特定の動的フィールドが含まれるパスを定義します。各フィールドの設定には検証と入力が必要です。たとえば、上記テンプレートの {version} フィールドが 3 つのゼロ(001、012、132 など)を使用した整数となるように定義します。アプリがディスクに何かを読み書きする必要がある場合は、その場所を示すテンプレートがテンプレート ファイルに追加されます。多くの場合、アプリはパイプラインを形成するように設定されているため、あるアプリ(パブリッシュ アプリなど)の出力テンプレートが、別のアプリ(ロード アプリなど)の入力テンプレートになることがよくあります。そのため、ファイル システムの場所は、すべて 1 つのファイルに保存されます。テンプレート API を使用すると、フィールドの値とパスのリスト間でジャンプできます。# get a template object from the API&amp;gt;&amp;gt;&amp;gt; template_obj = sgtk.templates[&quot;maya_shot_publish&quot;]&amp;lt;SGTK Template maya_asset_project: shots/{Shot}/{Step}/pub/{name}.v{version}.ma&amp;gt;# we can use the template object to turn a path into a set of fields...&amp;gt;&amp;gt;&amp;gt; path = '/projects/bbb/shots/001_002/comp/pub/main_scene.v003.ma'&amp;gt;&amp;gt;&amp;gt; fields = template_obj.get_fields(path){'Shot': '001_002', 'Step': 'comp', 'name': 'main_scene', 'version': 3}# alternatively, we can take a fields dictionary and make a path&amp;gt;&amp;gt;&amp;gt; template_obj.apply_fields(fields)'/projects/bbb/shots/001_002/comp/pub/main_scene.v003.ma'上記のパスとテンプレートには、2 つの異なるタイプのフィールドが設定されます。Shot フィールドと Step フィールドは、Flow Production Tracking の同等のオブジェクト(ショットとパイプライン ステップ)を使用する高レベルのフィールドです。name フィールドと version フィールドは、この特定のタイプのテンプレート専用です。ショットではなくアセットのパブリッシュ パスを定義する場合にも、name フィールドと version フィールドを使用します。パブリッシュ パスはすべてのパブリッシュで必要となるため、データのタイプは関係ありません。ただし、Shot フィールドと Step フィールドは使用できません。代わりに、Asset フィールドと Step フィールドを使用できます。アセット フィールドは、Flow Production Tracking のアセットと関連付けられます。パブリッシュを実行するアプリを開発する場合、ショット パブリッシュとアセット パブリッシュのそれぞれを実行する個別のアプリを作成する必要はまったくありません。シーケンス、ショット、アセットに関係なく、すべてのパブリッシュ シナリオを処理できるパブリッシュ アプリを 1 つのみ作成すれば十分です。ここで Toolkit のコンテキスト が必要になります。Toolkit のコンテキストを使用すると、テンプレート フィールドを 2 つの異なるグループに分割できます。コンテキスト フィールド(Shot、Step、Asset など)は、アプリ外でアプリのロジックを使用して解決するためのフィールドです。ショットやアセットなどのコンセプトを処理する専用コードを設定する必要はありません。アプリには、このアプリに固有の ビジネス ロジック に直接関連付けられたフィールドのみを入力する必要があります。たとえば、Publish アプリでは、ビジネス ロジックは name フィールドと version フィールドで構成されます。したがって、上の図に示すとおり、Toolkit はフィールド解決を 2 つの異なるフェーズに分割します。一部のフィールドはコンテキストによって解決され、他のフィールドはアプリのビジネス ロジックによって処理されます。この方法では、アプリが特定のファイル システム レイアウトに関連付けられない仕様にすることができます。これは優れたパイプライン ツールを作成する上で重要な要素だと考えています。通常、パス解決を処理するアプリ コードは次のようになります。# start with an empty fields dictionaryfields = {}# first let the context populate all its fieldsfields.update( self.context.as_template_fields( publish_template_obj ) )# fields is now {'Shot': '001_002', 'Step': 'comp' }# now the app can add its business logicfields[&quot;name&quot;] = &quot;main_scene&quot;fields[&quot;version&quot;] = 234# and finally the app can produce the path it needs in# order to save out the filepath = publish_template_obj.apply_fields(fields)テンプレート API の設定方法と使用方法に関する詳細については、次を参照してください。ファイル システム設定のリファレンスCore API リファレンス実行するエンジンとアプリを選択するToolkit Core にはユーザに表示するアプリを決定する上で 重要な役割があります 。キャラクタ リギングの作業時に Maya を起動する場合、ショットのライトを処理するときに別のアプリ コレクションが必要になることがあります。さらに、操作方法に応じてアプリを個別に設定できるため、リギングのレビュー アプリでターンテーブルを生成する一方で、アニメータが実行したときには同じレビュー アプリでショット カメラを使用してプレイブラストを実行できます。このような柔軟性を実現するために、Toolkit プロジェクト設定には一連の 環境 が含まれます。環境とは、一連のアプリ、エンジン、およびそれらすべての設定パラメータを定義する設定ファイルです。Toolkit の起動時に、 どちらの 環境を初期化するかを決定する必要があります。このためには、独自のビジネス ロジックを追加できる フック と呼ばれる Python コードを使用します。コンテキスト オブジェクトはこのコードに渡され、多くの場合、使用する環境を決定するために使用されます。これにより、パイプラインのそれぞれの部分に個別のアプリを設定できます。さらに、更新も個別に実行し、管理するスーパーバイザを個別に指定することもできます。既定の設定での環境既定の設定の環境で、環境の仕組みと構造を実例を挙げて紹介します。  project.yml - コンテキストにプロジェクトのみが含まれる場合に実行されるアプリとエンジンです。  shot_and_asset.yml - コンテキストにショットまたはアセットが含まれる場合に実行されるアプリとエンジンです。  shot_step.yml - コンテキストにショットとパイプライン ステップが含まれる場合のアプリとエンジンです。  asset_step.yml - コンテキストにアセットとパイプライン ステップが含まれる場合のアプリとエンジンです。既定の設定のファイル システムはパイプライン ステップに基づいて整理されます。つまり、ショットの場所にモデリングやリギングなどのフォルダが配置されます。基本的に、作業するパイプライン ステップごとにフォルダが 1 つあります。各フォルダには、ディスク上の独自の作業領域とパブリッシュ領域が含まれます。そのため、パブリッシュ テンプレートは次のようになります。maya_shot_publish: 'sequences/{Sequence}/{Shot}/{Step}/pub/{name}.v{version}.ma'このテンプレートを使用するには、コンテキストにエンティティとパイプライン ステップの両方を含める必要があります。シーケンス ABC とパイプライン ステップ Modeling の子であるショット 1122 の場合、上記のテンプレートは sequences/ABC/1122/Modeling/... に解決されます。これは、ショットが含まれ、パイプライン ステップが含まれないコンテキストは、上記のテンプレートの入力値が不足していることを意味します。ショットのみのコンテキストでは Maya を起動できないため、上記のテンプレートを使用することはできません。このテンプレートを使用するには、ステップが必要です。これにより、上記のように環境の内容が設定されます。既定の設定で定義されたファイル システム構成はステップ中心であるため、すべての主要なアプリは、ステップが定義されたコンテキストで実行する必要があります。既定の設定では、asset_step.yml と shot_step.yml の 2 種類の環境ファイルを定義します。各ファイルには、Maya、Nuke、3dsmax、Motionbuilder、Photoshop といった数多くの DCC 用のエンジンが含まれています。Flow Production Tracking 内のタスクから Maya を起動する場合、選択環境フックは環境 shot_step を選択し、Maya を起動して Maya のアプリ設定をロードします。これは、Flow Production Tracking 内のショット オブジェクトから Maya を直接起動する際にも役立ちます。さらに重要なのは、これはコンソール tank Shot 1122 launch_maya で入力できるようにする際に本当に役立つということです。shot 環境と asset 環境が関係するのはこの段階です。ショットまたはアセットが含まれ、パイプライン ステップが含まれないコンテキストを使用して Maya をロードすると、これらの環境のいずれかがロードされます。ファイル システム構成はパイプライン ステップごとにすべて整理されるため、コンテキストにパイプライン ステップの情報がない場合、ロードやパブリッシュの実行は非常に困難です。Maya は、作業ファイル アプリのみが含まれる最小設定で起動されます。このアプリを使用すると、作業するタスクを選択できます。タスクを選択すると、Toolkit はコンテキストを切り替えてエンジンを再起動し、すべてのアプリが搭載された環境 shot_step をロードします。同様に、環境 project は、作業ファイル アプリのみが含まれる汎用的なフォールバックになります。このため、プロジェクト内のほとんどの場所から Maya を起動できます。最小状態で Toolkit が初期化されるため、作業ファイル アプリを使用して有効な作業領域にジャンプできます。アプリを設定する各アプリには、指定する必要のある多数の設定パラメータがあります。アプリをインストールまたはアップグレードする場合は、Toolkit ですべての必須設定を指定していることを確認します。文字列や整数などの単純な設定値は、環境設定で直接指定します。テンプレートはさまざまであり、Toolkit ではすべてのテンプレートが 1 箇所に保持されるため、環境ファイルはテンプレート ファイルで定義されたテンプレートを参照しているに過ぎません。設定で使用するテンプレートには、アプリによってさまざまなフィールドが必要です。前述の例では、Publish アプリで、ディスク上にその出力ファイルを作成するときに、name と version フィールドを含むテンプレートを使用していました。そのため、このアプリには、name と version フィールドを含むテンプレートを必要とする設定が指定されていました。コンテキスト フィールド(name と version)以外を含むテンプレートを使用したアプリを設定しようとすると、アプリが他の追加フィールドの入力方法を認識できないため、このテンプレートからパスを生成することはできません。同様に、いずれかのフィールドが不足しているテンプレートを指定した場合も、混乱を招きます。この場合は、アプリからバージョン番号が書き出されません。そのため、Toolkit は、起動時に設定を検証して、すべてのテンプレートに必要なフィールドが指定されていることを確認します。また、Toolkit は既定値と選択可能なフィールドの使用方法もいくつかサポートしています。完全なリファレンスについては、次のリンクを参照してください。アプリケーションとエンジン設定のリファレンスファイル システム設定のリファレンスフックToolkit は、テンプレートを使用したアプリ設定に加えて、 フック と呼ばれるコンセプトもサポートしています。フックは Python コードの小型スニペットであるため、設定の一環としてアプリを部分的にカスタマイズできます。次に、その動作と仕組みについて説明します。アプリは複数のエンジンとプロジェクト間で再利用できるため優れています。ただし、アプリにはエンジン固有のロジックの小型スニペットがいくつか必要です。たとえば、Nuke と Maya の両方で動作するローダー アプリを作成する場合、 実際のファイル ロード を処理するコードが必要です。このコードは Nuke と Maya では別のものにする必要があります。さらに、すべてのエンジンでこのアプリを使用できれば便利です。また、スタジオが異なればシーンに項目をロードする方法も異なります。スタジオによって、カスタムの Maya リファレンス ノードをサポートする必要がある場合や、読み込みのみができれば良い場合もあります。このような違いは、Toolkit で フック を使用すれば解決できます。フックはカスタマイズ可能なコードです。アプリには、基本的な設定が実装されている既定のフックが含まれているため、アプリはすぐに正常に動作します。ただし、動作をカスタマイズする場合は、フック ファイルを設定にコピーすると、Toolkit がこのコードを使用するようになります。フックの操作方法を管理者ガイドで確認するFlow Production Tracking とシェルから実行するToolkit をインストールすると、複数のプライマリ エントリ ポイントから利用できます。  Flow Production Tracking アクションは Flow Production Tracking 内の右クリック メニューに表示されます。  起動アイコンは Flow Production Tracking Toolkit アプリのプロジェクトで表示されます。  コンソールで tank コマンドを使用することができます。  Toolkit Python API はアプリケーションとシェルの両方で利用可能です。アプリケーションの起動とタスクの実行は、Flow Production Tracking 内から Toolkit を実行するのが一般的です。Flow Production Tracking は Flow Production Tracking Toolkit を使用して、マシンのローカルにインストールされている Toolkit と通信し、ローカルの Python を使用して Toolkit コマンドを実行します。つまり、Flow Production Tracking 内からフォルダ作成などのローカルの作業を実行できます。シェルから Toolkit にアクセスすることもできます。各プロジェクト設定には独自の tank コマンドが用意されています。プロジェクト設定ルートにアクセスして、./tank コマンドを実行するだけです。最後に、Toolkit API を環境変数 PYTHONPATH に追加して読み込みます。API は簡単に使用できます。Flow Production Tracking Toolkit を使用する代わりに、手動またはスタジオの既存の起動システムの一部として、Maya 内で Toolkit を起動する場合は、簡単な数個のコマンドを実行するだけです。パブリッシュ他のユーザと共同で作業しているファイルを共有する場合は、このファイルをパブリッシュできます。これにより、PublishedFile エンティティが Flow Production Tracking 内に作成され、他のユーザが Toolkit のローダー アプリを使用して読み込むことができるようになります。ディスク関連項目の保存場所、ファイルに含まれる内容など、「データ管理」が厳密に何を意味するかは、アプリで行う実際の作業によって異なります。Toolkit API により、アプリ開発者は Flow Production Tracking 内でパブリッシュを簡単に作成し、このパブリッシュと最適なオブジェクトをリンクするメソッドを使用できます。これにより、Flow Production Tracking は処理を実行し、すべての関係者に通知を送信できるようになります。また、用途が幅広く、柔軟な設定が可能な既定の Publish アプリもありますが、これが Toolkit を使用してバージョン管理を実行する唯一の方法ではありません。Toolkit は拡張可能であるため、Toolkit を使用して独自のカスタム バージョン管理とパブリッシュ システムを必要に応じて開発することができます。ただし、最初は Publish アプリを使用することをお勧めします。既定の Multi Publish アプリ再利用可能なアプリを作成するToolkit は、単にアプリとエンジンをまとめたものではありません。独自のツールと技術の開発に使用するフレームワークでもあります。Toolkit を豊富な機能を備えたスタジオの開発プラットフォームにするための機能が多数含まれています。Toolkit を基盤にすると、自分で基本的なプラットフォームを構築する必要がなく、身近な問題に集中することができます。開発者がアーティストのパイプラインを間違って破壊しないようにソフトウェアの作成、評価、およびリリースを簡単に行えるようにしました。  エンジンは、基盤に関係なく、アプリを Python や Qt (PySide/PySide2)で作成できるようにするものです。非常に単純なエンジンもありますが、使用できる API によっては複雑なエンジンもあります。エンジンによって、簡単で一貫性のある方法を使用してスタジオ用のツールを開発できます。これまでの経験から、開発環境スタジオでは Python と Qt を使用することが多く、TD の多くはこれらのプログラミング言語に慣れています。  また、エンジン レイヤによって、アプリを一度作成すれば複数の環境で展開できます。オートデスクは、標準的なアプリ スイートを マルチ アプリ として開発しているため、すべてのエンジンで同じアプリを使用します。各 DCC アプリケーションで公開される特定の API と連携するように調整する必要がある特定のコードが必ずありますが、通常、これは 1 つ以上のフックに含まれるため、アプリケーションを簡単に再利用できます。このようにマルチ アプリを作成できるため、新しいエンジンを開発する場合、この新しいエンジンと連携するように標準的なすべてのアプリを簡単に設定できます。  パイプライン設定とクローン作成により、開発サンドボックスを簡単に作成できるため、開発者は日常の制作活動に影響を受けることなく制作上の開発を行うことができます。ツールを展開する準備が完了すると、メインのプロジェクト設定は簡単に更新でき、このツールはすべてのアーティストに展開されます。  アプリはエンジン内で実行されるため、簡単に再ロードできます。新しいコード変更をテストするたびに Nuke や Maya を再起動する必要はなく、Toolkit の再ロード ボタンをクリックするだけで、最新のコードがロードされます。アプリ開発の詳細については、次のドキュメントを参照してください。Toolkit アプリ開発の概要Toolkit API リファレンスアプリケーションとエンジン設定のリファレンス",
    "url": "/e95205a8/",
    "relUrl": "/e95205a8/"
  },
  "193": {
    "id": "193",
    "title": "パイプライン統合",
    "content": "パイプライン統合Flow Production Tracking には、アーティストが毎日使用するクリエイティブ ツールに Flow Production Tracking のエクスペリエンスを取り込む統合機能が含まれています。特に何も設定しなくても、アーティストのツール内にプラグインを取得して、基本的なパブリッシュ パイプラインの基盤を得ることができます。これらの統合は、Toolkit プラットフォーム、一連の API、UI、および環境設定に基づいて構築されており、スタジオがカスタム ワークフローを構築するためのツールを提供します。",
    "url": "/3d1cd26d/",
    "relUrl": "/3d1cd26d/"
  },
  "194": {
    "id": "194",
    "title": "Web Traffic Isolation",
    "content": "Web Traffic IsolationThe goal is to set up an AWS PrivateLink to privately access your Flow Production Tracking site.Set up PrivateLink to Flow Production Tracking      Ask Flow Production Tracking support to provide you with the Flow Production Tracking PrivateLink service name for your AWS region.        Update the private VPC CloudFormation stack you created earlier and set Flow Production TrackingPrivateServiceName parameter.  Manual steps if needed      Add a new VPC Endpoint in your VPC        For the security group, Flow Production Tracking service only requires the inbound port tcp/443 to be open.  DNS ConfigurationProvide your PrivateLink DNS name to Flow Production Tracking support. We will setup a new private URL for your site that will look like mystudio-staging.priv.shotgunstudio.com.ValidationVerify that your site private URL resolves to IPs in your AWS VPC block.nslookup mystudio-staging.priv.shotgunstudio.comTry to access your test site from inside your office ie https://mystudio-staging.priv.shotgunstudio.comNext StepsSee Fine Tuning to finalize your setup and optimize costs and security.Go to Setup for an overview of the possible next steps.",
    "url": "/d9ef03ce/",
    "relUrl": "/d9ef03ce/"
  },
  "195": {
    "id": "195",
    "title": "トラブルシューティング ガイド",
    "content": "トラブルシューティング ガイド問題のトラブルシューティングを目的としたクイック アンサーのコレクションです。一般的なトラブルシューティングのヘルプ  パフォーマンスのトラブルシューティング  デバッグ ログをオフにするにはどうすればいいですか?  リモート デバッグ  ログ ファイルはどこにありますか?  Toolkit のログの仕組みと参照するログの確認方法  設定の場所  メニュー、Flow Production Tracking Toolkit、または AMI でロード、表示、検出されない Toolkit アプリをデバッグする方法  タスク/ステップがファイル名の一部としては存在しているのにコンテキストで見つからないのはなぜですか?  フォルダを登録解除する理由と方法  フォルダの登録を解除する代わりに、サイトから FilesystemLocations を削除できますか?  分散設定を使用している場合にフォルダを登録解除するにはどうすればいいですか?エラー メッセージのガイダンス  Error: module ‘tank’ has no attribute ‘support_url’  ASCII codec can’t decode byte 0x97 in position 10: ordinal not in range  Configurations does not point to a valid bundle on disk!  Cannot find procedure “MTsetToggleMenuItem”  Could not resolve row id for path!  data_handler_cache error message: ERROR sgtk.env.project.tk-nuke.tk-multi-workfiles2 Failed to create File Open dialog!  Database concurrency problems: The path &amp;lt;PATH&amp;gt; is already associated with Flow Production Tracking entity &amp;lt;ENTITY&amp;gt;  ERROR: App store does not contain an item named my-app  [ERROR] Attempted to communicate without completing encryption handshake.  error Invalid LUT selected : Gamma2.2  [ERROR] [PROXY] Error calling __commands::unreal_engine  [ERROR publish_creation] &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;  Error: Flow Production Tracking tk-maya: An exception was raised from Toolkit  ERROR 18:13:28.365:Hiero(34236): Error!Task type  Exception: Review submission failed.Could not render and submit the review associated sequence.  Windows パスが長すぎるためのエラー(256 文字を超過)  Failed to change work area - Error during execution of MEL script  Failed to create folders: Folder creation aborded  The Frame Server has encountered an error.  ModuleNotFoundError  Maya で context.task を出力すると、空の「None」になる  Python API で発生する SSL: CERTIFICATE_VERIFY_FAILED の問題の解決  Getting CERTIFICATE_VERIFY_FAILED when using Flow Production Tracking Toolkit on a local Flow Production Tracking site  SSLError: [Errno 8] _ssl.c:504: EOF occurred in violation of protocol  [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate  TankInitError: You are loading the Toolkit platform from the pipeline configuration located in  TankError: Cannot resolve template data for context  TankError: Tried to resolve a path from the template  Tk-desktop console silently ignoring errors  SSLHandshakeError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)  TankError: Could not create folders on disk.Error reported: Critical!Could not update Flow Production Tracking with folder data.  [WARNING] Storage root primary could not be mapped to a SG local storageソフトウェア統合  プロジェクト間でパイプライン設定を共有/更新する場合の推奨方法  自宅で作業するユーザにパイプライン設定を配布する方法  一部のユーザの一元管理設定を分散設定に変換する方法  Windows で Qt の UI およびリソース ファイルをコンパイルする方法  Flow Production Tracking の UI に Toolkit コンテキスト メニュー項目を追加する方法  Houdini Flow Production Tracking 統合が起動しないのはなぜですか。  Flow Production Tracking Toolkit から Nuke/Maya などを起動しましたが、Flow Production Tracking メニューにエントリが表示されません。  環境変数 NUKE_PATH を設定すると Nuke 統合の起動に失敗するのはなぜですか?  2 つの機能拡張がインストールされている場合の Photoshop 統合のトラブルシューティング  Flow Production Tracking Toolkit を使用すると 3ds Max の起動時にクラッシュするのはなぜですか?  ソフトウェアの既定のバージョンを設定する方法  ローダー アプリで Alembic パブリッシュが表示されない理由  Toolkit がブートストラップする場合に、正しい PipelineConfiguration エンティティを決定するために使用される順序  Photoshop で 2 つの異なる SG パネルが表示される理由  Photoshop 統合パネルがロード中に停止して「問題が発生しました」  Desktop にソフトウェア エンティティが見つからない場合の修正方法  Tank.template_from_path() が複数のテンプレートを返すことができない場合の対処法  一連のショット(シーケンス全体)にアーティストの作業ファイルを段階的に取り込む方法  ユーザが tk-maya を起動したときに userSetup.py を制御する方法  開発設定用の Tank コマンド  アーティストが既存のパブリッシュを開いているときのみアクションを実行して、アーティストが既存の作業ファイルを開いているときはアクションを実行しないように、フックを使用して設定する方法  フォルダ作成時に、エンティティ名の空白をハイフンではなくアンダースコアに変換する方法ブラウザの統合  ローカル ファイル リンクを使用できず、Chrome から Toolkit アプリケーションを起動できない  ローカル ファイル リンクを使用できず、Firefox から Toolkit アプリケーションを起動できない  Linux で Flow Production Tracking Toolkit/ブラウザ統合の起動に失敗する回答が見つからない場合さらにトラブルシューティングを行う場合は、コミュニティで回答を検索することができます。",
    "url": "/7ef5be1d/",
    "relUrl": "/7ef5be1d/"
  },
  "196": {
    "id": "196",
    "title": "Fine Tuning",
    "content": "Fine TuningCost Management RecommendationsS3 Infrequent AccessWe recommend enabling S3 Infrequent Access to easily reduce costs without impacting performance. For the Flow Production Tracking Cloud hosted offering, we apply a policy for all objects older than one month.With Infrequent Access, objects are stored at a lower cost. However, if they are accessed, it will involve an additional cost. Flow Production Tracking has observed that one month was the right policy to use globally, but you may want to adapt that policy to your studio workflows as needed.Read more about S3 Infrequent Access and other storage classes here.S3 Bucket policyWe recommend you restrict access to your S3 bucket to only your VPC and Flow Production Tracking transcoding services IPs. There is an example policy, replace your_vpc_id and your_s3_bucket by your values.We strongly recommend you test media access and media transcoding in your site right after applying the bucket policy changes to be sure your S3 bucket is still accessible from your VPC and from Flow Production Tracking transcoders.{    &quot;Version&quot;: &quot;2012-10-17&quot;,    &quot;Id&quot;: &quot;Policy1415115909152&quot;,    &quot;Statement&quot;: [        {            &quot;Sid&quot;: &quot;AllowSSLRequestsOnly&quot;,            &quot;Effect&quot;: &quot;Deny&quot;,            &quot;Principal&quot;: &quot;*&quot;,            &quot;Action&quot;: &quot;s3:*&quot;,            &quot;Resource&quot;: [                &quot;arn:aws:s3:::your_s3_bucket&quot;,                &quot;arn:aws:s3:::your_s3_bucket/*&quot;            ],            &quot;Condition&quot;: {                &quot;Bool&quot;: {                    &quot;aws:SecureTransport&quot;: &quot;false&quot;                }            }        },        {            &quot;Sid&quot;: &quot;Access-to-specific-VPC-only and Shotgun transcoder&quot;,            &quot;Effect&quot;: &quot;Deny&quot;,            &quot;Principal&quot;: &quot;*&quot;,            &quot;Action&quot;: &quot;s3:GetObject*&quot;,            &quot;Resource&quot;: &quot;arn:aws:s3:::your_s3_bucket/shotgun/*&quot;,            &quot;Condition&quot;: {                &quot;NotIpAddress&quot;: {                    &quot;aws:SourceIp&quot;: [                        &quot;34.200.155.69/32&quot;,                        &quot;34.224.232.103/32&quot;,                        &quot;34.202.127.170/32&quot;                    ]                },                &quot;StringNotEquals&quot;: {                    &quot;aws:sourceVpc&quot;: [                        &quot;vpc-2fd62a56&quot;,                        &quot;your_vpc_id&quot;                    ]                }            }        }    ]}S3 endpoint policyWe recommend setting a VPC endpoint policy on your S3 endpoint to allow access to your S3 bucket only. See here for an example.Application Load Balancer  We recommend you enable deletion protection on the S3 proxy load balancer to prevent accidental deletion.  We recommend you enable access logging on the S3 proxy load balancer to aid in traffic analysis and identification of security issues.Next StepsSee Activation to migrate your production site to use the isolation features.Go to Setup for an overview of the possible next steps.",
    "url": "/26190270/",
    "relUrl": "/26190270/"
  },
  "197": {
    "id": "197",
    "title": "デバッグ ログをオフにするにはどうすればいいですか?",
    "content": "デバッグ ログをオフにするにはどうすればいいですか?Toolkit ツールの出力よりも多くのログ データを既定で表示することが必要な場合があります。詳細なログ出力を表示するには、デバッグ ログを有効にします。このための方法はいくつかあります。                    注: ログ ファイルの検索場所が不明な場合は、「ログ ファイルはどこにありますか?」ドキュメントを参照してください。    Flow Production Tracking Toolkit によるデバッグを有効にするデバッグを有効にする最も簡単な方法は、Flow Production Tracking Toolkit アプリを使用してオンに切り替えることです。これは、Flow Production Tracking Toolkit にログインした後で設定できます。アプリの右下にあるプロファイル画像をクリックして、[Advanced] -&amp;gt; [Toggle Debug Logging]を選択します。この設定はセッションの終了後も維持されるため、デバッグが終了したら忘れずにオフにしてください。デバッグをオンにすると、Flow Production Tracking Toolkit から起動されたアプリ、またはブラウザ統合を介した Toolkit コマンドも、このデバッグ状態を継承することに注意してください。環境変数をセットアップするデバッグ ログを常にオンにする最初に、新しい環境変数 TK_DEBUG=1 をセットアップする必要があります。                    注: 手順はプラットフォームによって異なるため、スタジオ内の専門家を集めて環境変数をセットアップする方法について話し合うことをお勧めします。次の例では、Windows 7 マシンで環境変数をセットアップする方法について説明しています。    Windows 7 を使用する場合  デバッグ ログを常にオンにするには、 Windows アイコン &amp;gt; [コントロール パネル] &amp;gt; [システム] &amp;gt; [システムの詳細設定] &amp;gt; [環境変数…] &amp;gt; [新規…]にアクセスします  変数名: TK_DEBUG  変数の値: 1  [OK]を選択します。これで、環境変数が正しくセットアップされ、デバッグ ログがオンになりました。                    注: ログを有効にするために Desktop を必ず再起動してください。    デバッグ ログをオフにするには、次のいずれかを実行します。a. TK_DEBUG 環境変数を 0 に設定します。b. TK_DEBUG 環境変数を削除します。環境変数が既に設定されているかどうかを確認する環境変数が正しく設定されているかどうかを確認するには、ターミナルを開いて set コマンドを実行します。次に、TK_DEBUG=1 を検索します。これにより、Desktop を起動すると、デバッグ ログがオンになります。デバッグ ログを一時的にオンにするセッションの代わりにデバッグ ログを一時的に使用する場合は、ターミナルを開き、set TK_DEBUG=1 コマンドを使用してデバッグ ログを設定できます。次に、ターミナルを介して Desktop を起動します。                    注: Flow Production Tracking Toolkit とターミナルを閉じると、デバッグ ログはオンではなくなります。    詳細設定のデバッグ ログ オプション詳細設定にはいくつかのオプションがあります。この機能は、Toolkit の設定をコントロールできる場合のみ利用可能です。すべてのエンジンの環境ファイルには debug_logging 設定があります。これをオンにすると、ソフトウェア(Nuke または Maya のスクリプト エディタなど)の既定の出力に追加のデバッグレベル ログ メッセージが送信されます。エンジンで実行中のアプリすべてがこのようなデバッグ レベルのメッセージを発行するため、エンジンでこの設定をオンにすると、すべてのアプリの設定も実質的にオンになります。これにより、ファイルにログ メッセージが出力されることはありません。標準的なロギング フレームワークでこの出力が可能になるように現在取り組んでいます。例外は Flow Production Tracking Toolkit および Photoshop エンジンで、これらはログの出力を GUI コンソールとファイルの両方に記録します。ソフトウェアでエンジンのデバッグ ログをオンにするたとえば、ショットのステップ環境で Nuke エンジンのデバッグ出力をオンにするには、環境ファイルで Nuke エンジン(tk-nuke)セクションを見つけて、この設定を debug_logging: true に更新します。config/env/shot_step.yml を編集します。engines:  ...  ...  tk-nuke:    apps:      ...      ...    compatibility_dialog_min_version: 9    debug_logging: true    favourite_directories: []    location: {name: tk-nuke, type: app_store, version: v0.2.23}    ...   ...ファイルを保存し、ショットのステップ環境で Nuke を再起動します。これで、スクリプト エディタ ウィンドウにデバッグ出力が表示されます。                    注: Flow Production Tracking Toolkit のチェックボックス、環境変数、またはエンジン設定のいずれかを使用してデバッグ ログが有効になっている場合は、デバッグ ログが出力されます。また、この 3 つの各設定は、他の設定とは別に変更されます。チェックボックスの値を設定すると、アプリが永続的に設定されますが、この設定はエンジンの設定または環境変数から完全に独立しています。つまり、Desktop のチェックボックスをオフにした場合も、他のいずれかの方法を使用してデバッグ ログを有効にすることができます。    tank コマンドのデバッグ ログをオンにするtank コマンドを実行し、ターミナルでデバッグ出力を確認する場合は、実行するコマンドで --debug オプションを使用すると、コマンドのデバッグ ログがオンになります。./tank --debug coreDEBUG [10:11:38 617.835998535]:DEBUG [10:11:38 618.768930435]: Running with debug output enabled.DEBUG [10:11:38 618.921995163]:DEBUG [10:11:38 619.092941284]: Core API resides inside a (localized) pipelineconfiguration.DEBUG [10:11:38 619.235992432]: Full command line passed:['/sgtk/software/shotgun/scarlet/install/core/scripts/tank_cmd.py','/sgtk/software/shotgun/scarlet', '--debug', 'core']DEBUG [10:11:38 619.364023209]:DEBUG [10:11:38 619.463920593]:DEBUG [10:11:38 619.575977325]: Code install root:/sgtk/software/shotgun/scarletDEBUG [10:11:38 619.678020477]: Pipeline Config Root:/sgtk/software/shotgun/scarletDEBUG [10:11:38 619.756937027]:DEBUG [10:11:38 619.826078415]:DEBUG [10:11:38 619.905948639]:DEBUG [10:11:38 619.978904724]: Context items:['/sgtk/software/shotgun/scarlet']DEBUG [10:11:38 620.06688118]: Command: coreDEBUG [10:11:38 620.129108429]: Command Arguments: []DEBUG [10:11:38 620.193004608]: Sgtk Pipeline Config Location:/sgtk/software/shotgun/scarletDEBUG [10:11:38 620.270967484]: Location of this script (__file__):/sgtk/software/shotgun/scarlet/install/core/scripts/tank_cmd.pyWelcome to the Flow Production Tracking Toolkit!For documentation, see https://developer.shotgridsoftware.com/d587be80/?title=Integrations+User+GuideStarting Toolkit for your current path '/sgtk/software/shotgun/scarlet'- The path is not associated with any Shotgun object.- Falling back on default project settings.DEBUG [10:11:39 125.463962555]: Sgtk API and Context resolve complete.DEBUG [10:11:39 126.449108124]: Sgtk API: Sgtk Core v0.15.18, config/sgtk/software/shotgun/scarletDEBUG [10:11:39 126.588106155]: Context: scarlet- Using configuration 'Primary' and Core v0.15.18- Setting the Context to scarlet.DEBUG [10:11:39 129.276990891]: No need to load up the engine for thiscommand.- Running command core...----------------------------------------------------------------------Command: Core----------------------------------------------------------------------Welcome to the Flow Production Tracking Toolkit update checker!This script will check if the Toolkit Core API installedin /sgtk/software/shotgun/scarletis up to date.Please note that when you upgrade the core API, you typically affect more thanone project. If you want to test a Core API upgrade in isolation prior torolling it out to multiple projects, we recommend creating a special*localized* pipeline configuration. For more information about this, pleasesee the Toolkit documentation.You are currently running version v0.15.18 of the Flow Production Tracking ToolkitNo need to update the Toolkit Core API at this time!DEBUG [10:11:39 981.74405098]: Exiting with exit code None",
    "url": "/143e0a94/",
    "relUrl": "/143e0a94/"
  },
  "198": {
    "id": "198",
    "title": "2 つの機能拡張がインストールされている場合の Photoshop 統合のトラブルシューティング",
    "content": "2 つの機能拡張がインストールされている場合の Photoshop 統合のトラブルシューティングどんな問題がありますか?After Effects 統合のリリースに伴い、Flow Production Tracking と統合されるすべての Adobe アプリで使用できる共通プラグインが用意されました。この変更の一環として、以前の Photoshop 統合との後方互換性を保ち、スタジオが更新プログラムに正しく移行できるようにするため、機能拡張の名前を変更する必要がありました。これは残念ながら、アップグレード時に 2 つの Flow Production Tracking 機能拡張がインストールされる可能性があることも意味します。Flow Production Tracking Adobe Panel が新しい機能拡張であり、v1.7.0 以降の Photoshop 統合を使用している場合にはこちらを使用する必要があります。エラーの修正方法古い機能拡張を削除するには、ホーム ディレクトリの Adobe 製品のインストール場所から削除します。フォルダは、Photoshop 起動時に以下のデバッグ出力に表示されます。  ~/Library/Application Support/Adobe/CEP/extensions/com.sg.basic.psOSX:  Windows: %AppData% Adobe CEP extensions com.sg.basic.psPhotoshop を終了してそのディレクトリを削除すると、再起動時の拡張拡張は 1 つだけになります。                    注: 複数の環境または複数の設定に Photoshop 統合があり、古いプラグインと新しいプラグインが混在している場合、あるユーザがその古い統合で Photoshop を起動すると、古いプラグインが返されます。このクリーンアップが一度で済むよう、Photoshop を組織全体で更新することを推奨します。    ",
    "url": "/3fd1f835/",
    "relUrl": "/3fd1f835/"
  },
  "199": {
    "id": "199",
    "title": "Unable to get local issuer certificate",
    "content": "[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate使用例Windows で Python API を使用して Amazon に対してメディアをアップロードおよびダウンロードする際に問題が発生します。この問題が発生すると、Python API によって次のエラー メッセージが表示されます。shotgun_api3.shotgun.ShotgunFileDownloadError: Failed to open https://xxx.shotgunstudio.com/file_serve/attachment/xyz&amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1108)&amp;gt;Amazon は一部の証明書をバックエンドで更新しました。Windows で新しい証明書を必要とする Web ページを参照すると、通常は、証明書ストアが更新されます。通常の参照アクティビティを認識しないコンピュータで実行されているスタンドアロンの Python スクリプトでは証明書の更新が取得されないため、コンピュータの証明書が大量に不足する可能性があります。修正方法問題のあるマシンに GUI でアクセスできる場合は、S3 に現在保存されているメディアを再生するだけで、証明書ストアが更新されます。この再生ソリューションは、Chrome、Internet Explorer、Edge、またはその他の Chromium ベース ブラウザでのみ機能します。Firefox または Safari では機能しません。これらのブラウザでは、証明書の検証に Windows の標準 API が使用されないためです。このソリューションが機能しない場合や、更新するコンピュータ数が非常に多い場合は(Deadline レンダリング ファームなど)、不足している証明書をコンピュータに追加するスクリプトも提供されます。公開されているスクリプトのリンクはこちらです。Windows 10 の Powershell ユーザまたは Windows 7 の Powershell 3 ユーザは、コンピュータの管理者として次のスクリプトを実行して新しい証明書を取得することができます。$cert_url = &quot;https://www.amazontrust.com/repository/AmazonRootCA1.cer&quot;$cert_file = New-TemporaryFileInvoke-WebRequest -Uri $cert_url -UseBasicParsing -OutFile $cert_file.FullNameImport-Certificate -FilePath $cert_file.FullName -CertStoreLocation Cert: LocalMachine Rootコマンドが機能した場合は、次のように表示されます。   PSParentPath: Microsoft.PowerShell.Security Certificate::LocalMachine RootThumbprint                                Subject----------                                -------8DA7F965EC5EFC37910F1C6E59FDC1CC6A6EDE16  CN=Amazon Root CA 1, O=Amazon, C=USこれにより、証明書が実行されているコンピュータでは、すべてのユーザ アカウントがこの証明書を使用できるようになります。ユーザに管理者アクセス権がない場合は、次の方法で最後の行を変更できます。Import-Certificate -FilePath $cert_file.FullName -CertStoreLocation Cert: CurrentUser Root証明書が現在のユーザにのみ追加されます。筆者のような保守的なユーザがまだ cmd.exe を使用している場合は、certutil を使用することもできます。まず、https://www.amazontrust.com/repository/AmazonRootCA1.cer から証明書をダウンロードし、コンピュータ上の任意の場所に保存する必要があります。次に、管理モードでコマンド プロンプトを起動します。次の行を実行します。certutil -addstore root &amp;lt;path-to-the-cert&amp;gt;これで、すべてのユーザ アカウントが証明書を使用できるようになります。管理者アクセス権がない場合は、次のように、-user を追加して現在のユーザにのみ証明書をインストールすることができますcertutil -user -addstore root &amp;lt;path-to-the-cert&amp;gt;関連リンクコミュニティの完全なスレッドを参照してください。",
    "url": "/e9d994eb/",
    "relUrl": "/e9d994eb/"
  },
  "200": {
    "id": "200",
    "title": "アプリまたはエンジンをアンインストールするにはどうすればいいですか?",
    "content": "アプリまたはエンジンをアンインストールする方法アプリまたはエンジンを削除するには、設定の YAML 環境ファイルを編集して、アプリまたはエンジンを記述から除外します。環境ファイルを使用すると、特定のコンテキストまたはエンジンでのみ使用できるようにアプリを設定できます。アプリを完全に削除する必要はありません。環境ファイルの一般的な編集方法については、このガイドを参照してください。例次に、既定の設定から Publish アプリを完全に削除する方法について説明します。アプリは環境設定内のエンジンに追加されるため、Publish アプリが追加されたすべてのエンジンからこのアプリを削除する必要があります。エンジンからアプリを削除する各エンジンは .../env/includes/settings 内に独自の YAML ファイルを保持しています。Publish アプリはすべてのエンジンに含まれているため、各エンジンの YAML ファイルを変更する必要があります。Maya エンジンを例に挙げると、tk-maya.yml を開いて、Publish アプリに対するすべての参照を削除します。まず、includes セクションに Publish アプリに対する参照があります。.../env/includes/settings/tk-maya.yml L18アセット ステップのコンテキストの場合、このアプリは Maya エンジンにも含まれています。.../env/includes/settings/tk-maya.yml L47次の行を使用して、Favorites メニューにもこのアプリを追加します。.../env/includes/settings/tk-maya.yml L56次に、ショット ステップの設定で次の行を繰り返します。.../env/includes/settings/tk-maya.yml L106.../env/includes/settings/tk-maya.yml L115他のすべてのエンジンの yml 環境ファイル(tk-nuke、tk-3dsmaxplus、tk-desktop など)にこれらの手順を繰り返します。                    重要: この時点で、ユーザの統合環境にこのアプリが表示されないようにするのに必要な操作が完了しているので、必要な作業はここまです。ただし、設定からアプリに対する参照を完全に削除して、設定を常に整理しておくには、残りの手順を完了する必要があります。    アプリの設定を削除するこれらのエンジンのすべての YAML ファイルには、tk-multi-publish2.yml 設定ファイルが含まれていました。エンジンの YAML ファイル内にある、このアプリに対する参照が削除されたので、このファイルを完全に削除することができます。                    重要: tk-multi-publish2.yml を削除したにもかかわらず、これを指しているエンジン ファイルが存続している場合は、次の行と共にエラーが表示される可能性があります。ErrorInclude resolve error in '/configs/my_project/env/./includes/settings/tk-desktop2.yml': './tk-multi-publish2.yml' resolved to '/configs/my_project/env/./includes/settings/./tk-multi-publish2.yml' which does not exist!    アプリの場所を削除する既定の設定では、…/env/includes/app_locations.yml ファイル内にすべてのアプリの場所記述子が保存されています。tk-multi-publish2.yml はこの記述子を参照しているため、この記述子の行を削除する必要があります。",
    "url": "/86ab39ef/",
    "relUrl": "/86ab39ef/"
  },
  "201": {
    "id": "201",
    "title": "Error calling __commands::unreal_engine",
    "content": "[ERROR] [PROXY] Error calling __commands::unreal_engine]使用例:Flow Production Tracking デスクトップ アプリをセットアップした後に、UE4 を取得して Flow Production Tracking アプリに表示できるようになったので、Unreal を起動しようとすると、次のメッセージが表示されます。2020-06-06 03:22:24,246 [ ERROR] [PROXY] Error calling __commands::unreal_engine_4.24.3((), {}):Traceback (most recent call last):File “C: Users USER0 AppData Roaming Shotgun bundle_cache app_store tk-desktop v2.4.12 python tk_desktop desktop_engine_project_implementation.py”, line 164, in _trigger_callbackcallback(*args, **kwargs)File “C: Users USER0 AppData Roaming Shotgun babilgames p91c38.basic.desktop cfg install core python tank platform engine.py”, line 1084, in callback_wrapperreturn callback(*args, **kwargs)File “C: Users USER0 AppData Roaming Shotgun bundle_cache app_store tk-multi-launchapp v0.10.2 python tk_multi_launchapp base_launcher.py”, line 125, in launch_version*args, **kwargsFile “C: Users USER0 AppData Roaming Shotgun bundle_cache app_store tk-multi-launchapp v0.10.2 python tk_multi_launchapp base_launcher.py”, line 343, in _launch_callback“Could not create folders on disk. Error reported: %s” % errTankError: Could not create folders on disk. Error reported: Could not resolve row id for path! Please contact support! trying to resolve path ‘D: UEProjects SON D: UEProjects SON’. Source data set: [{‘path_cache_row_id’: 2, ‘path’: ‘D: UEProjects SON’, ‘metadata’: {‘root_name’: ‘primary’, ‘type’: ‘project’}, ‘primary’: True, ‘entity’: {‘type’: ‘Project’, ‘id’: 91, ‘name’: ‘SON’}}]エラーの原因ディスク上の UE4 プロジェクトのパス D: UEProjects PROJECT_NAME  が正しくありませんでした。修正方法この問題は、Flow Production Tracking の設定用フォルダを新規に作成することで解決します。コミュニティの完全なスレッドを参照してください。",
    "url": "/5e456562/",
    "relUrl": "/5e456562/"
  },
  "202": {
    "id": "202",
    "title": "API を使用して Toolkit の設定をプログラムによって更新するにはどうすればいいですか?",
    "content": "API を使用して Toolkit の設定をプログラムによって更新するにはどうすればいいですか?アプリ、エンジン、およびフレームワークを更新するエンジン、アプリ、およびフレームワークのすべてをプログラムによって最新バージョンに更新する場合は、次のコードを使用できます。import syssys.path.append(&quot;&amp;lt;path_to_your_config&amp;gt;/install/core/python&quot;)import sgtk# substitute your Project id here or alternatively use sgtk_from_path()tk = sgtk.sgtk_from_entity('Project', 161)c=tk.get_command(&quot;updates&quot;)# setup authenticationif hasattr(sgtk, &quot;set_authenticated_user&quot;):     from tank_vendor.shotgun_authentication import ShotgunAuthenticator     user = ShotgunAuthenticator(sgtk.util.CoreDefaultsManager()).get_default_user()     sgtk.set_authenticated_user(user)# finally, execute the commandc.execute({})                    注意: これにより、追加の操作や確認を行うことなく、このパイプライン設定のエンジン、アプリ、およびフレームがすべて最新バージョンに更新されます。作業を進める前にこの操作を把握してください。    コアを更新するスクリプトからプロジェクトのコア バージョンを非インタラクティブに更新する場合は、次のコードを使用できます。import syssys.path.append(&quot;&amp;lt;path_to_your_config&amp;gt;/install/core/python&quot;)import sgtk# substitute your Project id here or alternatively use sgtk_from_path()tk = sgtk.sgtk_from_entity('Project', 161)c=tk.get_command(&quot;core&quot;)# setup authenticationif hasattr(sgtk, &quot;set_authenticated_user&quot;):    from tank_vendor.shotgun_authentication import ShotgunAuthenticator    user = ShotgunAuthenticator(sgtk.util.CoreDefaultsManager()).get_default_user()    sgtk.set_authenticated_user(user)# finally, execute the commandc.execute({})                    注意: これにより、追加の操作や確認を行うことなく、Toolkit コアが最新バージョンに更新されます。このコードを実行しているコアが共有コアの場合は、このコア バージョンを共有するすべてのプロジェクトで使用されているコア バージョンが更新されます。作業を進める前にこの操作を把握してください。    関連トピック  カスタム スクリプトによる認証とログイン資格情報",
    "url": "/4de9c1d6/",
    "relUrl": "/4de9c1d6/"
  },
  "203": {
    "id": "203",
    "title": "パイプライン設定のコアの場所を更新するにはどうすればいいですか?",
    "content": "パイプライン設定のコアの場所を更新するにはどうすればいいですか?ローカル コアを使用するようにパイプライン設定を更新するにはどうすればいいですか?共有 Toolkit コアを使用するようにパイプラインが設定されている場合は、基本的に、このプロセスを元に戻すことができます。つまり、コアの「共有を解除」し、tank localize コマンドを使用してパイプライン設定内に Toolkit Core API のコピーをインストールできます。これをコアの「ローカライズ」と呼んでいます。       ターミナルを開いて、Toolkit コアのインストール先のパイプライン設定に移動します。     $ cd /sgtk/software/shotgun/scarlet            次の tank コマンドを実行します。     $ ./tank localize ... ... ---------------------------------------------------------------------- Command: Localize ---------------------------------------------------------------------- This will copy the Core API in /sgtk/software/shotgun/studio into the Pipeline configuration /sgtk/software/shotgun/scarlet. Do you want to proceed [yn]        続行する前に、Toolkit がすべてを確認します。パイプライン設定が現在指定している Toolkit コアのコピーは、パイプライン設定にローカルにコピーされます。        Toolkit は、パイプライン設定で使用中のすべてのアプリ、エンジン、フレームワークを install フォルダにローカルにコピーします。次に Toolkit コアがコピーされ、新たにインストールされたローカルな Toolkit コアを使用するようにパイプライン設定内の設定ファイルが更新されます。     Copying 59 apps, engines and frameworks... 1/59: Copying tk-multi-workfiles v0.6.15... 2/59: Copying tk-maya v0.4.7... 3/59: Copying tk-nuke-breakdown v0.3.0... 4/59: Copying tk-framework-widget v0.2.2... 5/59: Copying tk-shell v0.4.1... 6/59: Copying tk-multi-launchapp Undefined... 7/59: Copying tk-motionbuilder v0.3.0... 8/59: Copying tk-hiero-openinshotgun v0.1.0... 9/59: Copying tk-multi-workfiles2 v0.7.9... ... ... 59/59: Copying tk-framework-qtwidgets v2.0.1... Localizing Core: /sgtk/software/shotgun/studio/install/core -&amp;gt; /sgtk/software/shotgun/scarlet/install/core Copying Core Configuration Files... The Core API was successfully localized. Localize complete! This pipeline configuration now has an independent API. If you upgrade the API for this configuration (using the 'tank core' command), no other configurations or projects will be affected.                          注: 出力は、インストールしたアプリ、エンジン、およびフレームワークのバージョンによって異なります。    既存の共有コアを使用するようにパイプライン設定を更新するにはどうすればいいですか?既存の共有 Toolkit コアを使用する場合は、tank コマンドを使用して共有コアを使用するように「ローカライズされた」既存のパイプライン設定を更新できます。      ターミナルを開いて、更新するパイプライン設定に移動します。     $ cd /sgtk/software/shotgun/scarlet            次に、tank attach_to_core コマンドを実行して、現在のプラットフォーム上の共有コアへの有効なパスを指定します。     $ ./tank attach_to_core /sgtk/software/shotgun/studio ... ... ---------------------------------------------------------------------- Command: Attach to core ---------------------------------------------------------------------- After this command has completed, the configuration will not contain an embedded copy of the core but instead it will be picked up from the following locations: - Linux: '/mnt/hgfs/sgtk/software/shotgun/studio' - Windows: 'z: sgtk software shotgun studio' - Mac: '/sgtk/software/shotgun/studio' Note for expert users: Prior to executing this command, please ensure that you have no configurations that are using the core embedded in this configuration. Do you want to proceed [yn]        続行する前に、Toolkit がすべてを確認します。この共有コアは複数のプラットフォーム用に既にセットアップされているため、それぞれの場所を示します。    新しいプラットフォームに場所を追加する必要がある場合、共有コア設定内の config/core/install_location.yml を更新して、必要なパスを追加します。        Toolkit は、パイプライン設定のローカル コア API をバックアップし、ローカライズされたコアを削除し、共有コアでパイプライン設定を指定するために必要な設定を追加します。     Backing up local core install... Removing core system files from configuration... Creating core proxy... The Core API was successfully processed.        後で、パイプライン設定内で Toolkit コアをローカライズする(つまり、共有コアからパイプライン設定を切り離して、ローカルにインストールされたバージョンを使用する)場合は、tank localize コマンドを使用してこの操作を行うことができます。                      注: スタジオの共有コアは、現在のパイプライン設定のコアと同じかそれ以降のバージョンである必要があります。    プロジェクト間で Toolkit コアを共有するにはどうすればいいですか?現在、Toolkit Core API は、SG Desktop を使用してプロジェクトを設定するときに「ローカライズ」されます。つまり、この API がパイプライン設定内にインストールされます。 これは、すべてのパイプライン設定が完全に独立した Toolkit インストールであることを意味します。プロジェクト間で共有する Toolkit Core API のバージョンを使用して、メンテナンスを最小限に抑え、すべてのプロジェクトで同じコア コードが使用されるようにします。これを「スタジオの共有コア」と呼ぶこともあります。次に、異なるプロジェクト パイプライン設定間で共有できる新しい Toolkit Core API 設定を作成する方法を示します。      ターミナルを開いて、共有する Toolkit Core バージョンが含まれる既存のパイプライン設定に移動します。プロセスが完了すると、このパイプライン設定はローカライズされなくなりますが、新しく作成した共有コアは使用されます。     $ cd /sgtk/software/shotgun/pied_piper            次の tank コマンドを実行して、Toolkit core をディスクの外部の場所にコピーします。このパスがすべてのプラットフォームで見つかるように、場所を指定する必要があります(inux_path、windows_path, mac_path)。各パスに引用符を使用することをお勧めします。特定のプラットフォームで Toolkit を使用しない場合は、空の文字列 &quot;&quot; を指定するだけです。      $ ./tank share_core &quot;/mnt/sgtk/software/shotgun/studio&quot; &quot;Z: sgtk software shotgun studio&quot;   &quot;/sgtk/software/shotgun/studio&quot;            Toolkit が処理を続ける前に、加えられる変更の概要が表示されます。     ---------------------------------------------------------------------- Command: Share core ---------------------------------------------------------------------- This will move the embedded core API in the configuration '/sgtk/software/shotgun/pied_piper'. After this command has completed, the configuration will not contain an embedded copy of the core but instead it will be picked up from the following locations: - Linux: '/mnt/sgtk/software/shotgun/studio' - Windows: 'Z: sgtk software shotgun studio' - Mac: '/sgtk/software/shotgun/studio' Note for expert users: Prior to executing this command, please ensure that you have no configurations that are using the core embedded in this configuration. Do you want to proceed [yn]            Toolkit は新しい共有場所にコア インストールをコピーし、新しい共有コアを指定するように既存のパイプライン設定を更新します。     Setting up base structure... Copying configuration files... Copying core installation... Backing up local core install... Removing core system files from configuration... Creating core proxy... The Core API was successfully processed.      これで他のパイプライン設定からこの新しい共有コアを使用できます。既存の共有コア(先ほど作成したコアなど)を使用するようにパイプライン設定を更新するには、tank attach_to_core コマンドを使用します。",
    "url": "/b12f2510/",
    "relUrl": "/b12f2510/"
  },
  "204": {
    "id": "204",
    "title": "バージョンと Published File の違いは何ですか?",
    "content": "バージョンと Published File の違いは何ですか?「パブリッシュ」は、アプリケーション内で使用可能なディスク上のファイル(またはイメージ シーケンス)またはデータを表します。これには、exr シーケンス、abc、Maya ファイルなどがあります。パブリッシュは Flow Production Tracking の PublishedFile エンティティによって表されます。「バージョン」(Flow Production Tracking の Version エンティティ)はパブリッシュの視覚表現で、レビューやノートの作成に使用されます。Version エンティティ上に Published Files という名前のフィールドがあり、互いに接続する任意の数のパブリッシュ レコードを入力することができます。このフィールドを使用して、パブリッシュ グループに関連付けられているレビュー Version をトラックできます。パブリッシュ時にこの関係を設定することをお勧めします。バージョンは Flow Production Tracking の Version エンティティによって表されます。究極的には、ファイル形式は異なるが実際は同じコンテンツを表す(Maya ファイル、obj、alembic などの)一連のファイルをパブリッシュ時に生成できることが理想です。これらのファイルは、同じ内容をすべて異なる形式で表現しています。その後、パブリッシュ データをプレビューしてノートを作成するために、1 つのレビュー Version に関連付けます。パブリッシュされたデータがイメージ シーケンスの場合、これは少し冗長な考え方になります。実際イメージ シーケンスは、レビュー対象であり、かつパイプラインに送信する対象でもあります。この場合、パブリッシュと Version の両方を「1 つにまとめて」作成する必要があります。この操作を行うと、(Loader アプリを使用するなどの方法により)パブリッシュされたデータのうち、Version を表すものがロードされます。",
    "url": "/b867b4b0/",
    "relUrl": "/b867b4b0/"
  },
  "205": {
    "id": "205",
    "title": "Toolkit ウェビナー",
    "content": "Flow Production Tracking Toolkit ウェビナー更新日: 2020 年 5 月 8 日Flow Production Tracking Toolkit ウェビナー プレイリストFlow Production Tracking Toolkit ウェビナー ビデオ1: Flow Production Tracking Toolkit ウェビナー: 追加設定が不要な統合(60 分)新しい一連の Toolkit ウェビナーではまず、Rob Blau と Manne Öhrström が、すぐに開始できる統合についての質問に答えます。2: Flow Production Tracking Toolkit ウェビナー: 新しい既定の設定についての解説(60 分)このウェビナーでは、Josh Tomlinson と Rob Blau が、Toolkit プロジェクトの新しい既定の設定での変更点(およびその理由)について説明します。3: Flow Production Tracking Toolkit ウェビナー: パブリッシュ ワークフローのカスタマイズ - ライブ デモ(60 分)このウェビナーでは、Josh Tomlinson が、Maya でカスタムのパブリッシュ ワークフローを作成する方法について手順に沿って説明します。ここでは、パブリッシュ アプリの構成、構成方法、およびデータの収集とパブリッシュのためのカスタム フックの作成方法について学びます。補足資料パイプラインのチュートリアル4: Flow Production Tracking Toolkit ウェビナー: クラウド設定とマルチロケーション ワークフロー(60 分)このウェビナーでは、Manne Ohrstrom が複数の場所にあるスタジオのアーティストのためのワークフローについて説明します。補足資料Toolkit の初期化と設定管理に関する開発者用ドキュメントManne がビデオで参照する記述子タイプのリスト5: Flow Production Tracking エコシステム ウェビナー: REST API (60 分)このウェビナーでは、Brandon Ashworth が、役に立つデモ、使用例、レシピの紹介を通じて REST API の全体像と重要性、使用方法について説明します。補足資料REST API 参照ドキュメント6: Flow Production Tracking Toolkit ウェビナー: 新しい Publisher API (35 分)最新の統合リリースには、改善された Publish API が含まれています。これによって GUI アプリからパブリッシュ ロジックを分離し、各自のツールから、あるいはレンダー ファームからパブリッシュを実行できます。このウェビナーでは、Jean-Francois Boismenu が、API を使用して Publisher UI からパブリッシュ項目ツリーをレンダー ファームのジョブに渡す方法について説明します。補足資料設定付き GitHub リポジトリ31:00 に参照されたプル リクエストPublish API ドキュメント7: Flow Production Tracking Toolkit ウェビナー: After Effects の統合(38 分)Adobe After Effects は、Flow Production Tracking の最新の統合対象です。このウェビナーでは、Rob Blau が、機能のライブ デモを通じて After Effects の統合について詳しく説明します。また、Photoshop との統合における困難な仕事を振り返り、Adobe 統合のための再利用可能なフレームワークを開発する方法について議論を展開します。また、Tannaz Sassooni が、新しい開発者向けドキュメント サイトを紹介し、Flow Production Tracking との統合方法を学ぶユーザ向けによりわかりやすいコンテンツを作成している現状を説明します。補足資料After Effects の統合ドキュメント開発者用ドキュメントのポータルFlow Production Tracking Developer Day プレイリストFlow Production Tracking Developer Day のビデオFlow Production Tracking チームは SIGGRAPH 2018 および 2019 において Flow Production Tracking Developer Day を発表しました。このコースへの参加を通じて、開発者はタスクの自動化、カスタム アプリの作成などで使用できるさまざまなリソースについて学ぶことができます。SIGGRAPH の後、Developer Day のコンテンツを特集した一連のウェビナーを開催しました。このプレイリストには、それらのウェビナーの記録が含まれています。スライド デッキ全体、コード例、およびこのコンテンツに関連するその他のリソースは、2019 の場合はこちら、2018 の場合はこちらにあります。1: SIGGRAPH Developer Day 2019: Flow Production Tracking 開発の概要(83 分)このウェビナーでは、Tannaz Sassooni と Patrick Boucher が Flow Production Tracking 開発の概要を説明し、Flow Production Tracking の自動化エントリ ポイント、Flow Production Tracking の Python および REST API、Flow Production Tracking の API を使用してスタジオのタスクやデータ トラッキングを自動化する方法について紹介します。0:56 あいさつとオリエンテーション3:00 Flow Production Tracking 開発の概要:パイプラインに関する一般的なニーズの概要、および Flow Production Tracking の API と開発フレームワークを使用した対処方法を示します。[Tannaz Sassooni]25:59 Flow Production Tracking API を使用したデータ管理の概要: 簡単な Python および REST スクリプトと、アクション メニュー項目を作成するためのフレームワークを使用して、Flow Production Tracking の API について詳しく説明します。[Patrick Boucher]2: SIGGRAPH Developer Day 2019: 高度な Flow Production Tracking 開発(78 分)このウェビナーでは、Brandon Ashworth と Manne Öhrström が、Flow Production Tracking について説明します。イベント デーモンと新しい Webhooks を使用して Flow Production Tracking でのデータ変更に対応し、Flow Production Tracking Toolkit を使用して簡単なパイプライン ツールを作成する方法を紹介します。0:39 あいさつとオリエンテーション2:33 Flow Production Tracking イベントを操作する[Brandon Ashworth]41:25 複数のアーティスト アプリで実行される Flow Production Tracking ツールを開発する[Manne Öhrström]3: SIGGRAPH Developer Day: Toolkit の管理(1 時間 15 分)このウェビナーでは、Josh Tomlinson、Tannaz Sassooni、Phil Scadding が、統合を引き継ぎ、カスタム ディレクトリ構造を作成し、フックによってスタジオのデータフローをさらに自動化する方法をデモを通じて説明します。0:00 あいさつとオリエンテーション1:04Flow Production Tracking Toolkit 管理: Flow Production Tracking Toolkit アプリを使用して一般的なコンテンツ作成ソフトウェアを起動する方法と、既定のパイプライン統合を使用して、作業セッションを終了せずにアーティストが Flow Production Tracking を操作する方法について確認します。[Phil Scadding]32:41 Toolkit の設定の紹介: Toolkit のパイプライン設定を自由にナビゲートして、パイプライン ワークフローをカスタマイズする方法について学びます。[Tannaz Sassooni]56:20 フックの管理: Flow Production Tracking Toolkit の広範なフック セットを使用して設定にカスタム ロジックを追加し、Toolkit パイプラインをスタジオのニーズに合わせて調整する方法について説明します。[Josh Tomlinson]4: SIGGRAPH Developer Day: 高度な Flow Production Tracking 開発(1 時間 15 分)Manne Ohrstrom、Jeff Beeland、Rob Blau が、ソース管理とクラウドベースのパイプライン展開のベスト プラクティスを実演し、アプリのビルドおよび Toolkit の標準フレームワークを使用した UI の迅速な設計とデータ処理について説明します。0:00 あいさつとオリエンテーション2:31 Toolkit プラットフォーム: 開発と展開パターン: 開発のワークフロー、バージョン管理のベスト プラクティス、Flow Production Tracking サイトへのアップロードによるリモート ユーザへのパイプライン設定の配布など、Toolkit パイプライン構成を設定および展開するためのさまざまな方法について説明します。[Manne Ohrstrom]30:23 Toolkit プラットフォーム: 独自のアプリを作成する: 提供されている API とフレームワークを利用して強力な UI を迅速に作成する方法を、簡単な Toolkit アプリの作成を通じて説明します。[Jeff Beeland]1:02:22 Autodesk Forge の概要: オートデスクの一連の API 駆動型クラウド サービスである Forge、およびこのサービスを使用して Flow Production Tracking をさらに便利にする方法について説明します。[Rob Blau]",
    "url": "/869a6fab/",
    "relUrl": "/869a6fab/"
  },
  "206": {
    "id": "206",
    "title": "VPC / IAM / Security Group",
    "content": "VPC / IAM / Security GroupAmazon Virtual Private Cloud permits users to logically separate virtual networks that host their AWS resources and provides you complete control over access to your AWS network.Within a VPC, security groups act as a basic firewall and control what inbound and outbound connections are permitted to each given resource. For example, a security group can allow inbound HTTPS traffic to a proxy server but block all other inbound traffic.With AWS Identity and Access Management (IAM), access to AWS resources and services can be controlled at a more fine-grained level. For example, IAM can be leveraged to control who or which resources can access S3 buckets used by Flow Production Tracking.All three of the above features are used in the Flow Production Tracking isolation features implementation to ensure that you securely connect your closed VPC to Flow Production Tracking and allow access to the media S3 buckets.",
    "url": "/28430132/",
    "relUrl": "/28430132/"
  },
  "207": {
    "id": "207",
    "title": "Web Traffic Isolation",
    "content": "Web Traffic IsolationCommunication between your client systems and your Flow Production Tracking site will traverse the open Internet by default. Web Traffic Isolation allows you to restrict access to your Flow Production Tracking site from the public Internet entirely and ensure that all traffic transits directly between your AWS VPC and Autodesk’s AWS VPC.ConfigurationA unique VPC endpoint is provided by Autodesk. Access to the endpoint must be configured from your VPC, and the relevant DNS configuration must be completed to allow your client systems to reach the new endpoint.How it worksBy using the provided VPC endpoint, web traffic is isolated from the public Internet completely. All web traffic transits between your AWS VPC and Autodesk’s AWS VPC, rather than the public Internet.CostsThe only cost associated with Web Traffic Isolation are those related to web traffic transiting to/from your AWS VPC. See AWS VPC Pricing for more details.Next StepsSee Web Traffic Isolation for setup instructions.",
    "url": "/57122ae9/",
    "relUrl": "/57122ae9/"
  },
  "208": {
    "id": "208",
    "title": "Webhook",
    "content": "WebhookWebhook を使用すると、ユーザがコントロールしているサービスに Flow Production Tracking で発生したイベントを通知することができます。Webhook を作成する場合は、対象となるイベントのタイプを指定し、このイベントがトリガされたときにデータを送信する URL を Flow Production Tracking に指示します。Flow Production Tracking で関連イベントが発生すると、そのイベントを示すデータのペイロードが Webhook の URL に送信されます。これにより、Flow Production Tracking との統合が緊密化され、ワークフローの一部を自動化することができます。Webhook を使用する例Webhook には多くの使用事例があります。このドキュメントでは役立つ事例をいくつか紹介しますが、Webhook の使用はこれらの例に限定されません。エンティティを作成するときにディスク上にディレクトリ構造を作成するFlow Production Tracking で新しいエンティティを作成するときに何度も繰り返されてきたワークフローの 1 つとして、ディスク上にディレクトリ構造を作成することが挙げられます。Flow Production Tracking で新しいショットを作成したら、作業を進めて、アーティストの作業準備が整っていることを自動的に確認できると便利です。ステータス管理の自動化アニメーション チームが作業を終えたら、作業を進めて、同じショットに関する下流工程のタスクのステータスを変更し、開始できる作業が増えたことを知らせるようにしましょう。こうすることで、別の作業に割り当てられているアーティストに、準備ができていることを自動的に通知できます。ステータス管理の自動化が役立つもう 1 つの例は、新しい Note を作成するときに、Task エンティティのステータス変更をトリガすることです。この方法は、アーティスト チームとプロダクション チームに、レビュー セッション後にスーパーバイザーから現在の作品を変更または修正するよう要求されたことを知らせる場合に便利です。Flow Production Tracking のイベント デーモンではなく、Webhook を使用する場合Webhook と Flow Production Tracking のイベント デーモンの機能は似ていますが、重要な違いがいくつかあります。イベント デーモンは、ユーザ独自のサービスを実行、監視、メンテナンスする必要があります。すべてのコードを Python で記述する必要があり、これによって Flow Production Tracking との独自の接続を開始することが可能となります。対照的に、Webhook は複数の接続に対応し、任意のプログラム言語で記述することができます。これらは、AWS Lambda などのサーバレス環境でホストしたり、Zapier や IFTTT などのオンラインで使用可能な任意の自動化プラットフォームをトリガしたりできます。Webhook を使用できるのであれば、Webhook がお勧めのソリューションです。Webhook を作成するWebhook の作成を開始するには、[Webhooks] (Webhooks)ページに移動します。次に、[Webhook を作成] (Create Webhook)を選択します。                    注: Webhook へのアクセスは、[高度な権限] (Advanced Permissions)の[Webhook を表示] (Show Webhooks)でコントロールします。管理者およびマネージャ権限ロールでは、このオプションは既定で有効になっています。    次に、新しい Webhook を作成するために必要な情報を入力します。シークレット トークンWebhook にシークレット トークンを割り当てる作業は省略できます。シークレット トークンを指定した場合、Webhook の URL に送信されるすべての要求はこのトークンを使用して署名されます。この要求と一緒にトークン値が送信されます(ヘッダ名は X-SG-SIGNATURE)。署名は HMAC および SHA1 を使用して計算され、署名されたメッセージが要求の本文(JSON 形式)になります。ヘッダ形式&amp;lt;algorithm&amp;gt;=&amp;lt;signature&amp;gt;シークレット トークンを使用する理由厳密に必要なわけではありませんが、シークレット トークンを指定すると、Webhook の URL に送信されるペイロードに署名が付けられます。これにより、カスタマー サービスは、データが予測された送信元から送信されていること、および送信中にペイロードがいかなる方法でも変更されなかったことを確認できます。署名の検証Python を使用してペイロードの署名を確認する例の 1 つを、次に示します。&amp;gt;&amp;gt;&amp;gt; import hmac&amp;gt;&amp;gt;&amp;gt; import hashlib&amp;gt;&amp;gt;&amp;gt; body | `&amp;lt;json body&amp;gt;'&amp;gt;&amp;gt;&amp;gt; token | `mytoken'&amp;gt;&amp;gt;&amp;gt; 'sha1=' + hmac.new(token, body, hashlib.sha1).hexdigest()  == 'sha1=32824e0ea4b3f1ae37ba8d67ec40042f3ff02f6c'TrueSSL 証明書を検証するSSL 証明書の検証機能はオプションです。Webhook の使用者 URL に対する接続のセキュリティを確保する際に役立ちます。この機能を有効にすると、Webhook の URL に配信された場合、Flow Production Tracking は OpenSSL の証明書検証ルーチンを使用して証明書を検証します。バッチ形式で配信バッチ形式での配布の詳細については、こちらを参照してください。不安定な場合に通知不安定な場合に通知: Webhook が失敗したときに通知するユーザまたはグループを選択できます。この設定はオプションです。プロジェクトとエンティティでフィルタする特定のプロジェクト、エンティティ、フィールドを選択すると、Webhook へのトラフィックが最小限になるため、以下のことが可能になります。  パフォーマンスを改善する  リソースのコストを削減する  不要なバックログを防止する                    注: プロジェクトを選択すると、「バージョン」のように常に 1 つのプロジェクトに属するエンティティを選択するように制限されます。ユーザなどのプロジェクト以外(またはマルチプロジェクト)のエンティティを選択する場合は、プロジェクトを選択しないでください。こうすることで、Webhook イベントをフィルタするときに、エンティティ更新のパフォーマンスにオーバーヘッドが生じることはなくなります。    Webhook のステータスWebhook はさまざまなステータスを取ることができます(健全性や、配信を引き続き受信できるかどうか)。            ステータス      例      説明                  アクティブ            Webhook の動作は安定しています。過去 24 時間以内に、この Webhook の使用者 URL に対する配信が宛先に到達しなかったことはありません。              不安定            Webhook の動作は不安定です。過去 24 時間以内に、一部の配信が宛先に到達しませんでしたが、Webhook が停止していると Flow Production Tracking が判断するには不十分です。              失敗            Webhook は停止していると判断されていて、配信はこれ以上試行されません。この原因は、短期間に発生した配信失敗の数が多すぎたことです。システムは、Webhook が使用できなくなったと判断しました。過去 24 時間以内に配信が 100 回失敗すると、Webhook に障害があると見なされます。              無効            Webhook は無効な状態です。再度有効になるまで、配信はこれ以上試行されません。      配信Webhook リスト内の Webhook を選択すると、この Webhook に行われたすべての配信が 7 日前まで遡って表示されます。                    注: 7 日前より古い配信のログは削除され、復元できません。    配信ステータス配信ステータスは、Webhook の URL に正常に配信されたかどうかを示します。配信の詳細配信を展開して、Webhook の URL に送信された要求およびこの要求に対する応答の詳細を表示することができます。ペイロードの要求Webhook の URL に送信されるペイロードには、Flow Production Tracking で発生したイベントと、それをトリガしたユーザを示す情報が格納されています。この情報は、JSON 形式で提供されます。                    ペイロード サイズ: 配信のペイロードの最大サイズは 1 MB です。Flow Production Tracking でトリガされたイベントのうち、ペイロード サイズが 1 MB を超えるものは、new_value および old_value キーが削除され、発生したイベントの内容と、Flow Production Tracking からイベント ログ エントリ全体を取得する理由および方法を示すメッセージが含まれている warning キーが追加されます。    サンプル ペイロード{  &quot;data&quot;: {    &quot;id&quot;: &quot;11777.3065.0&quot;,    &quot;meta&quot;: {      &quot;type&quot;: &quot;attribute_change&quot;,      &quot;entity_id&quot;: 1246,      &quot;new_value&quot;: &quot;*Add fog and mist with depth&quot;,      &quot;old_value&quot;: &quot;*Add fog and mist.&quot;,      &quot;entity_type&quot;: &quot;Shot&quot;,      &quot;attribute_name&quot;: &quot;description&quot;,      &quot;field_data_type&quot;: &quot;text&quot;    },    &quot;user&quot;: {      &quot;id&quot;: 88,      &quot;type&quot;: &quot;HumanUser&quot;    },    &quot;entity&quot;: {      &quot;id&quot;: 1246,      &quot;type&quot;: &quot;Shot&quot;    },    &quot;project&quot;: {      &quot;id&quot;: 122,      &quot;type&quot;: &quot;Project&quot;    },    &quot;operation&quot;: &quot;update&quot;,    &quot;created_at&quot;: &quot;2022-02-01 20:53:08.523887&quot;,    &quot;event_type&quot;: &quot;Shotgun_Shot_Change&quot;,    &quot;delivery_id&quot;: &quot;3a5de4ee-8f05-4eac-b537-611e845352fc&quot;,    &quot;session_uuid&quot;: &quot;dd6a1d6a-83a0-11ec-8826-0242ac110006&quot;,    &quot;attribute_name&quot;: &quot;description&quot;,    &quot;event_log_entry_id&quot;: 545175  },  &quot;timestamp&quot;: &quot;2022-02-01T20:53:09Z&quot;}セッション UUIDFlow Production Tracking でイベントをトリガした session_uuid が、イベント ペイロードの一部として提供されます。この値は、Flow Production Tracking の Python API に指定できます。この値を指定すると、session_uuid を持つ任意の開いているブラウザ セッションに、API によって生成されたイベントの更新が表示されます。Webhook からの応答[応答] (Response)タブには、配信に対する Webhook の応答に関する詳細が表示されます。Webhook の応答の HTTP ヘッダ、本文、および計測された応答時間を確認できます。Webhook の応答の本文の最大文字数は 100 文字です。(上記のとおり、配信情報は確認のために 7 日間保持され、その後削除されます)。                    セキュリティ上のベスト プラクティス: Webhook の応答にセキュリティに関するデータを含めないでください。また、応答にシステム エラーの詳細を含めて返さないでください。    配信に応答する配信が正常に行われたとシステムが判断するためには、Webhook コンシューマ サービスが配信に応答する必要があります。                    応答のタイムアウト: Webhook の URL に配信されてから 6 秒以内に応答を受信する必要があります。6 秒が経過すると、接続は終了します。時間内に応答しなかった場合は、配信が失敗します。    各配信の処理時間が記録され、[応答の詳細] (Response details)タブに表示されます。調整使用者の配信への応答時間は、サイトの Webhook のスループットに影響します。各サイトでは、1 分あたりの応答時間として 1 分が許可されます。そのため、サイトに設定されたコンシューマ エンドポイントが応答するまで丸々 6 秒かかった場合、このサイトの Webhook 配信数は 1 分あたり 10 に調整されます。全体的なスループット レートを高くする必要がある場合は、次のモデルに従ってコンシューマ エンドポイントを設計する必要があります。  要求を受け取ります。  別のプロセス/スレッドをスポーンして、目的の方法で処理します。  確認応答 200 で即座に応答します。ステータス コード            ステータス      コード      説明                  成功      &amp;lt; 400      配信は受信されて、正常に処理されました。              エラー      &amp;gt;= 400      配信は受信されましたが、正常に処理されませんでした。              リダイレクト      3xx      配信は受信されましたが、別の URL にリダイレクトする必要があります。      確認応答配信を更新して確認応答を含めることができます。配信時に、要求の一部としてヘッダが提供されます。これらのヘッダには、x-sg-delivery-id キーに格納されている配信レコードの ID が含まれます。この ID を使用して、Flow Production Tracking REST API を用いて配信レコードを更新し、確認応答を含めることができます。                    確認応答のサイズ: 確認応答に割り当てられた最大サイズは 4 KB です。    サンプル ヘッダ{  &quot;accept&quot;: &quot;application/json&quot;,  &quot;content-type&quot;: &quot;application/json; charset=utf-8&quot;,  &quot;x-sg-webhook-id&quot;: &quot;30f279a0-42a6-4cf2-bb5e-6fc550d187c8&quot;,  &quot;x-sg-delivery-id&quot;: &quot;dea7a71d-4896-482f-b238-b61820df8b65&quot;,  &quot;x-sg-event-batch-id&quot;: &quot;1&quot;,  &quot;x-sg-event-batch-size&quot;: &quot;4&quot;,  &quot;x-sg-webhook-site-url&quot;: &quot;https://yoursite.shotgunstudio.com/&quot;,  &quot;x-sg-event-batch-index&quot;: &quot;3&quot;}確認応答の用途確認応答を使用すると、成功または失敗を示す詳細レポートを帯域外で送信し、Webhook の URL で正常に受信された配信を処理することができます。これにより、Flow Production Tracking からの配信に関する受信ステータスを成功または失敗から切り離し、この配信に関連付けられているイベントを処理できるようになります。その結果、正常に配信されたイベントにデバッグに役立つ追加情報を含めることができます。適切な例として、Asset エンティティの作成時にトリガされる Webhook があります。新しい Asset ごとにディスク上にディレクトリ構造を 1 つ作成する作業を Webhook で行う場合、Webhook の URL は配信を正常に受信できますが、ディスクまたはネットワークが停止しているため、関連ディレクトリを作成することはできません。配信を受信した後、Webhook は、ディレクトリ構造が作成されなかったこと、およびその理由を示す詳細なエラー メッセージを使用して、配信記録を更新することができます。Webhook のテスト無料公開されている任意の Webhook URL ジェネレータをオンラインで使用して、テストすることができます。これらのサービスは特に、Webhook やその他のタイプの HTTP 要求をテストすることを目的としています。この方法は、ネットワーク上にインフラストラクチャを設定しないで、Web について学習する場合に便利です。webhook.site を使用するwebhook.site をお勧めします。このサイトでは、コピーして Webhook に貼り付けることができる一意の URL が提供され、このアドレスへの配信がリアルタイムに表示されます。このページは、特定のステータス コードおよび本文を含む配信に応答するようにカスタマイズできます。つまり、配信の成功と失敗をテストすることができます。webhook.site サービスの速度は積極的に制限されます。つまり、一部の配信が拒否されて、Webhook が不安定になる、または停止することが容易に発生します。テストする場合は、プロダクションのライブ データではなく、既知のコントロール可能なプロジェクト環境を使用することをお勧めします。                    プロダクション データ: プロダクション イベント データを一般公開されているサードパーティの Web サービスに送信することはお勧めしません。テスト データの使用は、webhook.site のようなサービスを使用して Webhook をテストする場合に限定してください。    ",
    "url": "/3d448f5e/",
    "relUrl": "/3d448f5e/"
  },
  "209": {
    "id": "209",
    "title": "パス キャッシュとは何ですか? ファイルシステムの場所とは何ですか?",
    "content": "パス キャッシュとは何ですか? ファイルシステムの場所とは何ですか?パス キャッシュは、ディスクのフォルダと Flow Production Tracking のエンティティ間の関連付けをトラックするために Toolkit で使用されます。マスター キャッシュは、エンティティ タイプ FilesystemLocation を使用して Flow Production Tracking 内に保存されます。各ユーザには、ディスクの Toolkit キャッシュ ディレクトリにローカルに保存された独自のバージョンのパス キャッシュがあり、アプリケーションを起動するときやフォルダを作成するときはいつでもバックグラウンドで同期されます。通常は、パス キャッシュを手動で変更しないことをお勧めします。オートデスクの内部プロセスで、ローカル キャッシュと Flow Production Tracking 内の FilesystemLocation エンティティを同期するだけでなく、イベント ログ エントリを作成して、すべてのユーザのマシンが Flow Production Tracking との同期を維持できるようにもしています。パス キャッシュを変更するために使用できる tank コマンドがいくつかあります。  tank unregister_folders は、パス キャッシュの関連付けを削除します。  tank synchronize_folders は、ローカル パス キャッシュと Flow Production Tracking を強制的に同期します。通常、これらのコマンドのいずれかを実行する必要はありませんが、状況によっては、これらが役立つことがあります。たとえば、プロジェクト内のエンティティの名前を変更するか、エンティティを再作成する場合は、その前に unregister_folders を実行する必要があります。",
    "url": "/cbbf99a4/",
    "relUrl": "/cbbf99a4/"
  },
  "210": {
    "id": "210",
    "title": "ログ ファイルはどこにありますか?",
    "content": "ログ ファイルはどこにありますか?既定では、Flow Production Tracking Toolkit と統合は、ログ ファイルを次のディレクトリに保存します。Mac~/Library/Logs/Shotgun/Windows%APPDATA% Shotgun logs Linux~/.shotgun/logs/ログ ファイル名の形式は tk-&amp;lt;ENGINE&amp;gt;.log です。例として tk-desktop.log や tk-maya.log があります。ユーザのキャッシュの場所をオーバーライドするようにShotGrid_HOME 環境変数を設定した場合、ログ ファイルは次の場所に配置されます。$SHOTGUN_HOME/logs                    注: Flow Production Tracking Toolkit からこのディレクトリにアクセスすることもできます。プロジェクトを選択し、プロジェクト名の右側にある下矢印ボタンをクリックして、[ログフォルダを開く] (Open Log Folder)を選択します。    ",
    "url": "/38c5c024/",
    "relUrl": "/38c5c024/"
  },
  "211": {
    "id": "211",
    "title": "キャッシュの場所",
    "content": "キャッシュの場所ルート キャッシュの場所Toolkit は、Flow Production Tracking サーバに対する不要な呼び出しを防止するために、一部のデータをローカル キャッシュに保存します。ローカル キャッシュにはパス キャッシュ、バンドル キャッシュ、およびサムネイルが含まれます。ほとんどのユーザは既定の場所を使用しますが、変更の必要がある場合は、cache_location コア フックを使用して設定可能です。既定のキャッシュ ルートの場所は次のとおりです。Mac OS X~/Library/Caches/ShotgunWindows%APPDATA% ShotgunLinux~/.shotgunパス キャッシュキャッシュ パスは次の場所にあります。&amp;lt;site_name&amp;gt;/p&amp;lt;project_id&amp;gt;c&amp;lt;pipeline_configuration_id&amp;gt;/path_cache.dbバンドル キャッシュ分散設定バンドル キャッシュとは、Flow Production Tracking サイト上のプロジェクトすべてで使用される、すべてのアプリケーション、エンジン、およびフレームワークのキャッシュ コレクションです。分散設定用のバンドル キャッシュは次の場所に保存されています。Mac: ~/Library/Caches/Shotgun/bundle_cacheWindows:%APPDATA% Shotgun bundle_cacheLinux: ~/.shotgun/bundle_cache                    注: これらの場所は SHOTGUN_BUNDLE_CACHE_PATH 環境変数を使用してオーバーライドできるため、具体的な実装は変わる可能性があります。    一元管理設定一元管理設定用のバンドル キャッシュは、一元管理設定内に配置されます。...{project configuration}/install/設定で共有コアを使用している場合は、代わりに、共有コアのインストール フォルダ内に配置されます。サムネイルToolkit アプリ(Loader など)で使用されるサムネイルは、Toolkit のローカル キャッシュに保存されます。サムネイルは、プロジェクト、パイプライン設定、およびアプリごとに(必要に応じて)保存されます。ルート キャッシュ ディレクトリ下の構造は次のとおりです。&amp;lt;site_name&amp;gt;/p&amp;lt;project_id&amp;gt;c&amp;lt;pipeline_configuration_id&amp;gt;/&amp;lt;app_or_framework_name&amp;gt;/thumbs/",
    "url": "/7c9867c0/",
    "relUrl": "/7c9867c0/"
  },
  "212": {
    "id": "212",
    "title": "ワークフロー",
    "content": "ワークフローToolkit ワークフローベースの関連するクイック アンサーの集まりです。  バージョンと Published File の違いは何ですか?",
    "url": "/8396394b/",
    "relUrl": "/8396394b/"
  },
  "213": {
    "id": "213",
    "title": "ワークフロー",
    "content": "ワークフローFlow Production Tracking のパイプライン統合をカスタマイズすると、フィーチャ アニメーション、エピソード ワークフロー、ビジュアル エフェクト、ゲームなど、さまざまなワークフロー作成ツールを使用できるようになります。このセクションには、特定のワークフローを構築するためのリソースが含まれています。",
    "url": "/f5a4341f/",
    "relUrl": "/f5a4341f/"
  }
}
