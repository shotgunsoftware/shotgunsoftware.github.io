{
  "0": {
    "id": "0",
    "title": "Why does 3ds Max crash on startup when using ShotGrid Toolkit?",
    "content": "Why does 3ds Max crash on startup when using ShotGrid Toolkit?When launching 3ds Max from ShotGrid Desktop or the ShotGrid website, it is possible that 3ds Max will freeze, leaving you with a frozen white dialog, or the following message will appear:Microsoft Visual C++ Runtime Library (Not Responding)Runtime Error!Program: C: Program Files Autodesk 3ds Max 2016 3dsmax.exeR6034An Application has made an attempt to load the C runtime library incorrectly.Please contact the application's support team for more information.This is generally due to a version of msvcr90.dll in your path that conflicts with the version of Python that is bundled with 3ds Max.SolutionFirst, go to your pipeline configuration’s config/hooks folder and create the file before_app_launch.py. In it, paste the following:&quot;&quot;&quot;Before App Launch HookThis hook is executed prior to application launch and is useful if you needto set environment variables or run scripts as part of the app initialization.&quot;&quot;&quot;import osimport tankclass BeforeAppLaunch(tank.get_hook_baseclass()):    &quot;&quot;&quot;    Hook to set up the system prior to app launch.    &quot;&quot;&quot;    def execute(self, **kwargs):        &quot;&quot;&quot;        The execute functon of the hook will be called to start the required application        &quot;&quot;&quot;        env_path = os.environ[&quot;PATH&quot;]        paths = env_path.split(os.path.pathsep)        # Remove folders which have msvcr90.dll from the PATH        paths = [path for path in paths if &quot;msvcr90.dll&quot; not in map(            str.lower, os.listdir(path))        ]        env_path = os.path.pathsep.join(paths)        os.environ[&quot;PATH&quot;] = env_pathNow save the file.Then, open config/env/includes/app_launchers.yml in your pipeline configuration and find the launch_3dsmax entry. You should replace hook_before_app_launch: default to hook_before_app_launch: '{config}/before_app_launch.py'.You should now be able to launch 3ds Max correctly from ShotGrid and ShotGrid Desktop. If you still have any issues, please visit our support site for help.",
    "url": "/a7555f37/",
    "relUrl": "/a7555f37/"
  },
  "1": {
    "id": "1",
    "title": "About the Isolation Feature Set",
    "content": "What is the Isolation Feature SetThe isolation feature set combines our Cloud Hosted Platform with client-managed AWS resources to provide a solution that satisfies the most stringent security and privacy requirements. Clients retain control of their sensitive content without having to host ShotGrid on their infrastructure.Leveraging the isolation feature set has the following advantages over the Standard offering:  Media Isolation by hosting of assets and attachments in a client-owned S3 Bucket  Media Traffic Isolation from the public internet  Media Replication allowing you to replicate media in one additional AWS Region  Access to fully managed ShotGrid Cloud Services  Automatic and continuous version upgrades  Ephemeral compute + in-memory segration between clientsIn a nutshell, this means that with the isolation features, your ShotGrid site and the data related to it cannot be reached by anyone outside of your studio network.The isolation feature set is a solution that requires less upkeep, as well as less IT/System Administrator knowledge and skills, than hosting ShotGrid on-premise. The list of advantages compared to on-premise includes, but is not limited to:  No ShotGrid specific knowledge required  No manual ShotGrid updates required  Very low level of maintenance required for the AWS componentsMedia isolation featureMedia Isolation allows your studio to keep the ownership and control of the media and attachments that you upload to ShotGrid. With Media Isolation, all the content that you upload to ShotGrid can be store in your studio private S3 bucket. Access to the media is provided to the ShotGrid service only, using AWS AssumeRole keyless Security Token Service. Your studio remains in control of the assets and the access to the assets, access that you can revoke at will.Traffic isolation featureMedia traffic isolation feature can be enabled to prevent your media traffic from being routed on the public internet, limiting it to the AWS backbone and your studio network. The traffic between ShotGrid Services and your studio stays in closed network, never going outside AWS or your Studio network.With the Media Traffic Isolation feature activated, the media will only leave your studio infrastructure once to get transcoded.Media ReplicationShotGrid is compatible with the S3 Cross-Region replication feature, allowing your users located in different regions to read from the region closer to them in order to reduce latency and increase throughput. Replication to one region is currently supported.EligibilityThe Isolation feature set is available to clients with an active ShotGrid subscription. See Getting Started for more details about how to active the different features. The activation of the isolation feature set is not instantaneous, and requires manual setup involving your AWS account.What the Isolation Feature Set is notThe isolation feature set is not a completely isolated solution. Both the compute services and the database services are shared amongst clients, and managed by ShotGrid. From a hardware standpoint, the isolation features does not guarantee complete physical isolation. However, ShotGrid services are guaranteeing isolation at the memory level. Processes are never reused to answer requests from different clients during their lifetime. Client metadata is stored in different databases. Client media is individually stored on S3.High Level ArchitectureThe ShotGrid cloud service  can be decoupled at a high level in 3 parts:Compute Stack: The part of the ShotGrid Service that handles client requests and serves data to the client.Data Stack: Metadata storage (databases).Media Storage: Where the client’s attachments, media, and assets are stored. ShotGrid uses AWS S3 to store client content.Please read Securing Studio IP in AWS: Cloud-based VFX Project Management with Autodesk ShotGrid for more details about the architecture.Ephemeral compute and memory isolationEven if clients share the same infrastructure, ShotGrid guarantees a complete memory isolation, both in transit and at rest, of client data. This makes ShotGrid less prone to data leaking due to architecture flaws or software vulnerabilities exploiting memory, like buffer overflow.Ephemeral transcodingEverytime media is uploaded to ShotGrid, the transcoding service is invoked to create a web friendly versions of your assets. That process happens only once, after the initial upload. The media is directly uploaded from the client to S3, from where it is fetched by the ShotGrid Transcoding Service. Each transcoding job is handled by a single container, which is killed after that unique job. The only place the media temporarily lives is in the container memory. The ShotGrid Transcoding service doesn’t store permanently a copy of your media.",
    "url": "/84dfd5cc/",
    "relUrl": "/84dfd5cc/"
  },
  "2": {
    "id": "2",
    "title": "Custom Action Menu Items",
    "content": "Custom Action Menu ItemsAPI developers can customize context menu items on a per-entity basis, through Action Menu Items (AMIs). For example, from a Versions page, you could select multiple versions, right-click, then choose “Build a PDF Report.”Action Menu Item fields1. Title (title): The display name of the menu item.2. Entity Type (entity_type): Restrict the menu item to only appear on one type of entity page, such as Version. Omitting this key (a nil value) has the effect of allowing the menu item on ALL enabled entities.3. URL (url): The URL of our script that will create the PDF report.4. Order (list_order): The ordinal position of the menu item (relative to other custom menu items).5. Light Payload (light_payload): When using a custom protocol your script will receive the id of the event log entry record that holds the payload information instead of the full payload itself.6. Configure Menu Options: There are a few options to select from:      Include in the right-click menu on an Entity record: This is the default value that will include the AMI by right-clicking on a record.          Include in “Add Entity” dropdown menu on Entity pages: Option to include this AMI in the “Add Entity” dropdown menu (ex: “Add Asset”, “Add Shot”, etc.).          Override “Add Entity” button on Entity pages: This option allows you to overwrite the “Add Entity” button with an AMI.          Include in Internal Resources section of the User Menu: This gives you the option to customize the User Menu with internal resources. Learn more about customizing the user menu with internal resources here.  7. Folder (folder): Allows you to organize AMIs into folders within the context menu (currently only a single level of folders is supported).   8. Open in Modal Overlay: Allows AMIs to open in an iframe window, instead of in a new tab. Please note that if Shotgun is running HTTPS, then all iframes need to be HTTPS as well.9. Poll for Data Updates (poll_for_data_updates): Starts a polling loop to query for event log entries. This is for cases where the code on the other end of the ActionMenuItem makes changes back to Shotgun via the API on entities that are visible on the page that triggered the ActionMenuItem.10. Restrict to Permission Groups (permissions_groups): Allows you to restrict access for the AMI to only specified permission groups. If left empty, AMI will be available for all users.11. Restrict to Projects (projects): Will make it so the AMI only shows up in specified Projects. If left empty, AMI will be available in all Projects.12. Secret Token: Secure your AMI by setting a secret token.13. Selection Required (selection_required): Determines whether the menu item will be active if there are no rows currently selected.Types of Action Menu itemsThere are two types of menu items you can create:HTTP URL exampleAs an example, you can create a custom menu item called “Build PDF Report.” This will allow people to go to any Versions page, select one or more Versions, right-click, and then choose “Build PDF Report” from the ShotGrid menu. Doing this will launch a script, which you must create, to get a nicely formatted report sent back to their browser. Here’s how it works:Create the menu item via the UIFrom the settings menu, choose Action Menu Items to open the AMI Admin page.To create a new AMI, click on .Fill out the Title and any other required fields, and click on “Create Action Menu Item.”What happens when a user clicks on the AMI?ShotGrid dispatches a POST request in a new window, or in a modal dialog if that option was selected, and sends along data from the current page (as part of the POST request) to the receiving URL. Here’s an example of the workflow.  User navigates to a Versions page  User selects one or more Versions  User brings up the context menu (by right-clicking or clicking on the gear menu in the toolbar)  User clicks ‘Build PDF Report’  ShotGrid dispatches a POST request to the AMI’s URL in a new window (If your ShotGrid server is served over HTTPS, and your URL is served over HTTP, expect to see a browser warning)  Your script, located at the URL specified, processes the POST data, and generates a PDF document  A nicely formatted PDF report is sent back to the user for viewing or downloadCustom protocol handler exampleA more advanced implementation of custom AMIs involves setting up a custom protocol handler (e.g., ShotGrid://process_version). This allows you to bridge ShotGrid with applications like Maya, RV, or Cinesync via a script on your local computer. When you specify a non HTTP(S) protocol, data is sent via GET instead of POST to your URL. You may want to use this to launch an in-house tool to dispatch different requests.Read more about custom protocols in Launching Applications Using Custom Browser Protocols.  Note: We also have built-in integration with Maya and other software packages via ShotGrid integrations .Light payloadWhen using custom protocols, the query information is sent as a GET request. Certain operating system and browser combinations have varying limitations of the size of the GET request they allow. We suggest enabling the light payload checkbox on custom protocol AMIs. With light payload checked, your script will receive a single event log entry ID that it can fetch to get the full payload from by reading the ami_payload key of the record’s meta field.ExamplesHere are some related example scripts to help get you started:  Handling ActionMenuItem Calls  Version PackagerPayload contentsUser data  user_id: The user ID of the currently logged in user (e.g., 34)  user_login: The login of the currently logged in user (e.g., joe)Entity data  entity_type: The entity type of the current page or view (e.g., Version)  selected_ids: A comma-separated list of the selected entity IDs (e.g., 931, 900)  ids: A comma-separated list of all IDs of the entities returned by the current page’s query. This returns ALL IDs, including those that aren’t visible due to pagination. (e.g., 931, 900, 904, 907). If “Selection required” was checked on the AMI, this value will be the same as selected_ids .Page data  title: The page title (e.g., “All Versions”)  page_id: The ID of the page from which the action menu item was clicked (e.g., 1353)  server_hostname: The hostname of the system where the AMI was triggered. Can be useful if you have multiple servers invoking the same AMIs like a staging and a production server.  referrer_path: the canonical path of the URL where the AMI was invoked.  session_uuid: The unique identifier for the window where this AMI was invoked. This can be used with the “Poll for Data Updates” checkbox and the Python API’s set_session_uuid method to broadcast back information to the page where the AMI was invoked. Note: This feature’s polling for updates falls off exponentially and eventually stops so if your AMI doesn’t update before polling stops, you may not see any updates in your source page.  cols: A comma-separated list of system field names of all the visible columns on the page (e.g., code, sg_status_list, description)  column_display_names: A comma-separated list of display names of all the visible columns on the page (e.g., Version, Status, Description)  view: The view that was selected when the AMI was invoked. Multiple views can be created for any given page via the design page mode.  sort_column: The system name of the column that was sorted by (e.g., code). Only sends the first sort key if there are multiple, see sort_columns  sort_direction: (e.g., asc or desc) Only sends the first sort direction if there are multiple, see sort_directions  sort_columns: A comma separated list of the system names of the columns that the page or view was sorted by (e.g., code,created_at). Only sent if there are multiple sorting keys  sort_directions: A comma separated list of the system names of the columns that the page or view was sorted by (e.g., code, created_at). Only sent if there are multiple sorting keys  grouping_column: The system name of the column that was grouped by (e.g., code). Only sends the first grouping column if there are multiple, see grouping_columns  grouping_method: The method the by which the grouping occurs (e.g. grouping by entitytype for an entity field or month for a date field). Only sends the first grouping method if there are multiple, see grouping_columns  grouping_direction: The grouping direction (e.g., asc or desc) Only sends the first grouping direction if there are multiple, see grouping_directions  grouping_columns: A comma separated list of system names of the columns that the data was grouped by (e.g., code,created_at). Only sent if there are multiple grouping columns  grouping_methods: A comma separated list of grouping methods (e.g., entity_type,month). Only sent if there are multiple grouping columns  grouping_directions: A comma separated list of grouping directions (e.g., asc,desc). Only sent if there are multiple grouping columnsProject data (only sent if all entities on the current page share the same project)  project_name: The name of the Project (e.g., Gunslinger)  project_id: The ID of the Project (e.g., 81)Internal Resources MenuTo learn more about leveraging Action Menu Items for Internal Resources in the User Menu, visit our Admin Guide here.",
    "url": "/67695b40/",
    "relUrl": "/67695b40/"
  },
  "3": {
    "id": "3",
    "title": "Action Menu Items",
    "content": "Action Menu ItemsThis section contains information about creating custom Action Menu Items (AMIs) and launching applications using custom browser protocols.  Custom Action Menu Items  Launching Applications Using Custom Browser ProtocolsTo learn more about leveraging Action Menu Items for Internal Resources in the User Menu, visit our Admin Guide here.",
    "url": "/581648bb/",
    "relUrl": "/581648bb/"
  },
  "4": {
    "id": "4",
    "title": "Activation",
    "content": "ActivationOnce everything is configured and properly tested, it’s now time to migrate your production site to use the isolation features.TestNavigate to the /admin/speedtest route of your ShotGrid site. Select the new S3_CONFIG_NAME that was just set up previously and start the test to confirm that all the upload/download tests work as intended.Switch to your own Isolation S3 BucketNavigate to the Advanced section of Site Preferences page and set the storage location to your own S3 bucket.",
    "url": "/47ecbf94/",
    "relUrl": "/47ecbf94/"
  },
  "5": {
    "id": "5",
    "title": "Administering",
    "content": "AdministeringA collection of quick answers based around administering and configuring your Toolkit setup.ShotGrid Desktop:  How do I re-setup a Toolkit project using ShotGrid Desktop?  How do I install the ShotGrid Desktop silently on Windows?  How do I set up a desktop/launcher icon for ShotGrid Desktop on Linux?  How can I disable the ShotGrid Desktop’s browser integration?Managing your config:  How do I modify my configuration to use multiple storage roots?  How do I move my pipeline configuration to a new location?  How do I move my project directories to a new Local Storage root?  How do I update my pipeline configuration core locations?  How do I share assets between projects?  How do I uninstall an app or engine?Cache based questions:  What is the Path Cache? What are Filesystem Locations?  Where is my cache?",
    "url": "/ba09d04c/",
    "relUrl": "/ba09d04c/"
  },
  "6": {
    "id": "6",
    "title": "Administration",
    "content": "AdministrationShotGrid’s pipeline integrations offer a vast set of customization options. Getting your studio’s desired pipeline up and running can be a combination of configuration, running command line tools, and ensuring that the ShotGrid tools work in your studio environment.This section contains information about administering your studio’s ShotGrid Toolkit pipeline.",
    "url": "/a944bb05/",
    "relUrl": "/a944bb05/"
  },
  "7": {
    "id": "7",
    "title": "Advanced Toolkit Administration",
    "content": "Advanced Toolkit AdministrationThis is an introduction to how to administer and configure Toolkit for advanced configurations.In this topic:  Introduction  Using the tank command          Running in debug mode      Running tank commands via the Tookit API      Useful tank commands                  setup_project          core          configurations          updates          install_app, install_engine          app_info          folders, preview_folders          shell          dump_configAdvanced tank commands                      The Toolkit Python API  Pipeline Configurations and Sandboxes          Running the tank command for a sandbox      Using the Core API from a sandbox      Accessing a sandbox      Localizing a Pipeline Configuration      Deleting a cloned configuration        Checking for Updates          Creating a staging sandbox        Configuring how Apps are launched  Creating folders on disk          Filesystem Locations      Renaming Toolkit Folders      Deferred Creation and User Sandboxes        Configuring Templates          @include syntax in the template file      Including external files in your template file      Folder creation and templates        Hooks          App level hooks      Core level hooks      Studio level hooks      Project name hook      Connection hook        Configuring Apps and Engines          Each App has a Location setting      Including files      Configuring Template settings - file paths      Using Hooks to customize App Behaviour      IntroductionWelcome to the ShotGrid Toolkit Admin guide! This document explains how to work with the ShotGrid Pipeline Toolkit from an administrative point of view - installing and updating apps, setting up new projects, and managing your studio configuration. The Toolkit is still relatively technical, so we imagine that the person handling the configuration and administration is a sysadmin, pipeline/tools developer or TD. Before we start getting into details, we would recommend that you read through the following document if you haven’t already! It covers a number of the basic concepts and gives a brief introduction to configuration management and updates:An Introduction to the basic Concepts in ShotGrid Pipeline Toolkit.If you are not set up with the ShotGrid Toolkit yet, you may want to read through the Integrations User Guide.Using the tank commandWhen managing the ShotGrid Toolkit, and using the Toolkit in general, the tank command is your friend! The tank command lets you run both administrative commands and actual Apps quickly and easily from a command shell.By default, each new project you create gets its own, independent Core API and also its own tank command. Simply navigate to your Project Config location and execute the tank command to see all applicable commands for that project:cd /mnt/software/ShotGrid/big_buck_bunny./tankYou can use the tank command in many different ways. The basic idea is that you first tell the tank command where you want to operate and then what you want to do. If you don’t tell it what you want to do, it will display a list of all the available commands. If you don’t tell it where you want to operate, it will try to use your current directory. You can also use the tank command to list things in ShotGrid.Basic overview of how you can use the tank command:# Show all tank commands for an asset named 'piano'&amp;gt; tank Asset piano# We can also list all assets containing the phrase 'pi'&amp;gt; tank Asset pi# We can execute the built-in folder creation command for# the piano&amp;gt; tank Asset piano folders# If the application launcher app is installed, we can launch maya# and set the work area to the piano&amp;gt; tank Asset piano launch_maya# Alternatively, we can specify a path on disk instead of a ShotGrid entity&amp;gt; tank /mnt/projects/hero/assets/piano launch_maya# Or we can change our work directory and run tank like this&amp;gt; cd /mnt/projects/hero/assets/piano launch_maya&amp;gt; tank launch_mayaRunning in debug modeSometimes it can be useful to see what is going on under the hood. You can pass a --debug flag to the tank command which will enable verbose output and timings, sometimes making it easier to track down problems or understand why something isn’t doing what you expected it to.Running tank commands via the Tookit APIMost Tank commands are also fully supported to run via the API. This makes it easy to perform toolkit related maintenance operations as part of more extensive scripted workflows. For more information how to do this, see the Core API ReferenceUseful tank commandsHere’s a brief list of useful tank commands that you can use when you are administering the ShotGrid Toolkit.setup_projectCommand line version of the setup project wizard found in the ShotGrid Desktop. Sets up a new project with the ShotGrid Toolkit. This is where you start when you have a project in ShotGrid and you want to extend this to use the Toolkit. The command will guide you through the process and ask you for various pieces of information, such as which configuration to use and which project to set up.Re-run setup_project on the Same ProjectBy default, setup_project will only list projects that haven’t been set up yet. But, it’s often necessary to re-run setup_project on the same project, especially while testing. This can be done by passing the –force flag, which will list all projects, with a note to identify projects that have already been set up before:&amp;gt; tank setup_project --forceWelcome to SGTK!For documentation, see https://developer.shotgridsoftware.com- Running setup_project...force mode: Projects already set up with Toolkit can be set up again.Welcome to SGTK Project Setup!Connecting to ShotGrid...Connecting to the App Store...------------------------------------------------------------------Which configuration would you like to associate with this project?You can use the configuration from an existing project as a template for thisnew project. All settings, apps and folder configuration settings will becopied over to your new project. The following configurations were found:   big_buck_bunny: '/mnt/software/sgtk/big_buck_bunny'   ghosts: '/mnt/software/sgtk/ghosts'   chasing_perfection: '/mnt/software/sgtk/chasing_perfection'If you want to use any of the configs listed about for your new project, justtype in its path when prompted below.You can use the Default Configuration for your new project.  The defaultconfiguration is a good sample config, demonstrating a typical basic setup ofthe ShotGrid Pipeline Toolkit using the latest apps and engines. This will beused by default if you just hit enter below.If you have a configuration stored somewhere on disk, you can just enter thepath to this config it will be used for the new project.[tk-config-default]:Downloading Config tk-config-default v0.4.15 from the App Store...This is the 'Default Config' config.Below are all active projects, including ones that have been set up:--------------------------------------------------------------------[ 4] Demo Project     Fubar is an epic story of an on-going political wa...[ 5] Big Buck BunnyNote: This project has already been set up.     A killer bunny movie[ 6] The Ghosts of Pere LachaiseNote: This project has already been set up.     De Films en Aiguille and ChezEddy present this year...[ 7] Chasing PerfectionNote: This project has already been set up.     You've seen the car commercials, the car races, and...[ 8] What Happened to My Headphones?     The Ryan Mayeda storyPlease type in the id of the project to connect to or ENTER to exit:Toolkit provides you with a project name suggestion as part of the project setup process. If you are happy with the name, you can just press Enter to continue or alternatively type in another name by hand.If you have a special studio naming convention for projects, it is also possible to control the default value that the setup project process suggests. This is done via an advanced studio level hook - read more about it in the studio level hooks section further down in this document.coreChecks for Core API Updates. This will connect to the App Store and see if there is a more recent version of the Core API available. If there is, the command will ask you if you want to update.Example output from this command:&amp;gt; tank coreWelcome to Sgtk!Starting Sgtk for your current directory '/private/tmp'- Running core...WARNING: You are potentially about to update the Core API for multipleprojects.Welcome to the Sgtk update checker!This script will check if the Sgtk Core APIinstalled in /mnt/software/sgtk/studiois up to date.You are currently running version v0.13.22 of the Sgtk PlatformNo need to update the Sgtk Core API at this time!configurationsGives an overview of all the configurations for a project. This can be handy when you want to get a breakdown of the current activity for a project.Example output from this command:&amp;gt; tank Project Bunny configurationsWelcome to Sgtk!Will search across all ShotGrid Projects.- Found Project Big Buck Bunny- Starting Sgtk v0.13.22 using configuration/mnt/software/sgtk/big_buck_bunny.- Setting the Context to Big Buck Bunny.- Running configurations...Fetching data from ShotGrid...======================================================================Available Configurations for Project 'Big Buck Bunny'======================================================================Configuration 'Primary' (Public)-------------------------------------------------------This is the Project Master Configuration. It will be used whenever thisproject is accessed from a studio level sgtk command or API constructor.Linux Location:  /mnt/software/sgtk/big_buck_bunnyWinows Location: z: mnt software sgtk big_buck_bunnyMac Location:    /mnt/software/sgtk/big_buck_bunnyThis configuration is using a shared version of the Core API.If you want it torun its own independent version of the Toolkit Core API, you can run:&amp;gt; /mnt/software/sgtk/big_buck_bunny/tank localizeIf you want to check for app or engine updates, you can run:&amp;gt; /mnt/software/sgtk/big_buck_bunny/tank updatesIf you want to change the location of this configuration, you can run:&amp;gt; /mnt/software/sgtk/big_buck_bunny/tank move_configurationThis is a public configuration. In ShotGrid, the actions defined in thisconfiguration will be on all users' menus.Configuration 'Dev Area' (Private)-------------------------------------------------------Linux Location:  /Users/manne/sgtk_devWinows Location: z: Users manne sgtk_devMac Location:    /Users/manne/sgtk_devThis configuration is using a shared version of the Core API.If you want it torun its own independent version of the Toolkit Core API, you can run:&amp;gt; /Users/manne/sgtk_dev/tank localizeIf you want to check for app or engine updates, you can run:&amp;gt; /Users/manne/sgtk_dev/tank updatesIf you want to change the location of this configuration, you can run:&amp;gt; /Users/manne/sgtk_dev/tank move_configurationThis is a private configuration. In ShotGrid, only Admin 3 will see the actionsdefined in this config. If you want to add additional members to thisconfiguration, navigate to the SG Pipeline Configuration Page and addthem to the Users field.updatesThis command will go through all the environments associated with the project and check if there are more recent versions of apps or engines available. Depending on how the apps and engines have been installed, this updater may check against a local git repository, Github or the ShotGrid Toolkit App Store. If a more recent version is detected, you will get asked if you want to update your setup. If any new configuration parameters have been introduced in the new version of the App, you may be prompted for values.General syntax:&amp;gt; tank updates [environment_name] [engine_name] [app_name]The special keyword ALL can be used to denote all items in a category. Examples:  Check everything: tank updates  Check the Shot environment: tank updates Shot  Check all maya apps in all environments: tank updates ALL tk-maya  Check all maya apps in the Shot environment: tank updates Shot tk-maya  Make sure the loader app is up to date everywhere: tank updates ALL ALL tk-multi-loader  Make sure the loader app is up to date in maya: tank updates ALL tk-maya tk-multi-loaderinstall_app, install_engineInstalls a new engine or App in one of the environments associated with the project. You can use this command to install something either from the Toolkit app store or from git.app_infoSee a breakdown of all the apps and their key configuration settingsfolders, preview_foldersCreates folders on disk for an item.Example output from this commandWelcome to Sgtk!Will search across all ShotGrid Projects.- Found Asset Squirrel (Project 'Big Buck Bunny')- Starting Sgtk v0.13.22 using configuration/mnt/software/sgtk/big_buck_bunny.- Setting the Context to Asset Squirrel.- Running folders...Creating folders, stand by...The following items were processed: - /mnt/projects/big_buck_bunny - /mnt/projects/big_buck_bunny/reference - /mnt/projects/big_buck_bunny/reference/artwork - /mnt/projects/big_buck_bunny/reference/footage - /mnt/projects/big_buck_bunny/sequences - /mnt/projects/big_buck_bunny/assets - /mnt/projects/big_buck_bunny/assets/Character - /mnt/projects/big_buck_bunny/assets/Character/Squirrel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/sgtk_overrides.yml - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/elements - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/photoshop/jpg - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/publish/photoshop/psd - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/reference - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/reference/artwork - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/reference/footage - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/review - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/images - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/maya/workspace.mel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/maya/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/nuke/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Art/work/photoshop/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/elements - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/photoshop/jpg - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/publish/photoshop/psd - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/reference - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/reference/artwork - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/reference/footage - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/review - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/images - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/maya/workspace.mel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/maya/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/nuke/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Model/work/photoshop/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/elements - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/photoshop/jpg - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/publish/photoshop/psd - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/reference - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/reference/artwork - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/reference/footage - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/review - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/images - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/maya/workspace.mel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/maya/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/nuke/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Rig/work/photoshop/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/elements - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/photoshop/jpg - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/publish/photoshop/psd - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/reference - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/reference/artwork - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/reference/footage - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/review - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/images - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/maya - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/maya/workspace.mel - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/maya/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/nuke - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/nuke/snapshots - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/photoshop - /mnt/projects/big_buck_bunny/assets/Character/Squirrel/Surface/work/photoshop/snapshotsIn total, 93 folders were processed.shellStarts an interactive Python shell in your currently selected context. Sets up handy references to pre-initialized APIs, context, and engine objects. You can use ./tank shell to try out Toolkit and ShotGrid API code examples. The tank executable is located in the Pipeline Configuration root on your local machine, and looks something like:&amp;gt; cd /my_tank_configs/project_foobarExample output from this command:Welcome to SGTK!For documentation, see https://developer.shotgridsoftware.comYou are running a tank command associated with ShotGrid Project 'Chasing theLight'. Only items associated with this project will be considered.- Found Shot moo87 (Project 'Chasing the Light')- Starting the SG pipeline toolkit v0.15.14.- Setting the Context to Shot moo87.- Started Shell Engine version v0.3.3- Environment: /mnt/software/tank/chasing_the_light/config/env/shot.yml.- Running shell...Welcome to SG Pipeline Toolkit Python!2.7.1 (r271:86832, Jul 31 2011, 19:30:53)[GCC 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2335.15.00)]Running on darwin- A tk API handle is available via the tk variable- A Shotgun API handle is available via the Shotgun variable- Your current context is stored in the context variable- The shell engine can be accessed via the engine variable&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; tk&amp;lt;Sgtk Core vHEAD@0x105f66990 Config /mnt/software/tank/chasing_the_light&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; context&amp;lt;Sgtk Context:   Project: {'type': 'Project', 'id': 88, 'name': 'Chasing the Light'}  Entity: {'type': 'Shot', 'id': 1184, 'name': 'moo87'}  Step: None  Task: None  User: {'type': 'HumanUser', 'id': 42, 'name': 'Manne  xc3 x96hrstr xc3 xb6m'}  Additional Entities: []&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Shotgun&amp;lt;tank_vendor.Shotgun_api3.Shotgun.Shotgun object at 0x105fb2990&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; engine&amp;lt;Sgtk Engine 0x105feead0: tk-shell, env: shot&amp;gt;&amp;gt;&amp;gt;&amp;gt;In the example above, ./tank is starting a Python shell for you and setting up a few variables that you’ll need. This obviates a bit of groundwork on your part, such as setting up authentication and user sessions and starting the connection to your ShotGrid site, by providing these handles and contexts in the above variables:  The tk variable has a handle that will let you access the Toolkit API.  The ShotGrid variable has a handle to the ShotGrid API that’s already connected to your site and is ready to query the database and other things in your [ShotGrid site].  The context variable reads your current context (Project, Shot, Asset, Pipeline Step, User, etc.). Here is an example of an active context. In this example, a context instance is used to collect a set of key fields describing the current context. We sometimes refer to the context as the current work area. Typically this would be the current Shot or Asset that someone is working on. You can see in this example that the Project is “Chasing the Light”, the id is 1184, and the Shot is “moo87”. There are no Pipeline Steps or Tasks assigned, but the user is Manne. You may need to know this information when writing scripts for the Toolkit API, and everything is available in this handy context variable:&amp;lt;Sgtk Context:   Project: {'type': 'Project', 'id': 88, 'name': 'Chasing the Light'}     Entity: {'type': 'Shot', 'id': 1184, 'name': 'moo87'}     Step: None     Task: None     User: {'type': 'HumanUser', 'id': 42, 'name': 'Manne  xc3 x96hrstr xc3 xb6m'}     Additional Entities: []&amp;gt;The engine variable points to the currently running instance of the shell engine.dump_configAvailable in core v0.18.Dumps an existing environment configuration to STDOUT or to another file. Has the ability to dump a full or sparse representation of the config. A full representation includes default values for all settings, while a sparse representation only includes values that differ from the setting’s default. The output of the command by default includes comments for each setting that note the manifest where the default value can be found and the default value if it differs from what is in the configuration. The command does not allow dumping an environment config to an existing file as a safety precaution.Usage:./tank dump_config env_name [--sparse | --full] [--no_debug-comments] [--file=/path/to/output/file.yml]Example output from this command:&amp;gt; ./tank dump_config shot_step --sparse --file=/tmp/shot_step.ymlWelcome to SGTK!For documentation, see https://developer.shotgridsoftware.comStarting toolkit for path '/Shotgun/configs/sparse34913'- The path is not associated with any SG object.- Falling back on default project settings.- Running as user 'Toolkit'- Using configuration 'Primary' and Core HEAD- Setting the Context to sparse34913.- Running command dump_config...----------------------------------------------------------------------Command: Dump config----------------------------------------------------------------------Dumping config...Running the above command will write a sparse copy of the current project’s shot_step environment file to /tmp/shot_step.yml.To exclude the additional debug comments, use the --no_debug_comments flag.Advanced tank commandsHere’s a brief list of advanced tank commands that you can use when you are administering the ShotGrid Toolkit.      tank share_core - When new projects are created, these are often created in a state where each project maintains its own independent copy of the core API. This command allows you to take the core for such a project and move it out into a separate location on disk. This makes it possible to create a shared core, where several projects share a single copy of the Core API.        tank attach_to_core - When new projects are created, these are often created in a state where each project maintains its own independent copy of the core API. This command allows you to attach the configuration to an existing core API installation rather than having it maintain its own embedded version of the Core API        tank localize - This command will download the Core API to a particular pipeline configuration location. This is useful if you want to test a new version of the Core API inside a Toolkit staging area. This process is described in detail further down in this document.        tank clear_cache - Clears some of the Toolkit’s caches. This can be useful if menu items aren’t showing up inside ShotGrid for some reason.        tank validate - Validate the project configuration        tank cache_apps - Ensure that all required app, engine and framework versions exist on disk.        tank switch_app - Useful for development. Switches an app from app store mode to local or git mode or vice versa.        tank push_configuration - Push the configuration contained in the current pipeline configuration to another pipeline configuration.  The Toolkit Python APIIf you are launching applications using the ShotGrid Desktop, the tank command or using ShotGrid, Toolkit will automatically get added to the PYTHONPATH and initialize. Sometimes it is useful to manually source and run the Toolkit API. This can be done by adding the Toolkit Core API to the pythonpath and then importing it.In each project configuration, there is a python folder located inside your project_config_root/install/core/python. Just add that location to your Python path and you can import the sgtk API:import sgtk# create a Sgtk API object for a ShotGrid entitytk = sgtk.sgtk_from_entity(&quot;Shot&quot;, 123)# Create a Sgtk API object based on a file system locationtk = sgtk.sgtk_from_path(&quot;/mnt/projects/hero/assets/chair&quot;)Pipeline Configurations and SandboxesA Pipeline Configuration has the same basic structure as the studio installation. Most importantly, it contains a both a tank command and a Toolkit API inside of install/core/python. The reason the API and the tank command is duplicated across each configuration is to make it easy to do development and to do work outside of the production configuration.When a new project is set up in the ShotGrid Toolkit, the project setup creates a Primary Pipeline Configuration for the project. This is always called ‘Primary’ and represents the main configuration for the project. You can see the configuration represented inside of ShotGrid in the form of a Pipeline Configuration entity for the project. When you are doing development or are making changes to the configuration, you typically don’t work in the Primary configuration - if you accidentally break something, everyone working on the project will be affected. Instead, you can clone the configuration inside of ShotGrid. You now have your own parallel configuration where you can make changes without anyone else being affected.Running the tank command for a sandboxIf you use the studio level tank command to run an app, it will always use the Primary configuration for a project. So if you just type in tank Shot ABC123 launch_maya, the ShotGrid Toolkit will find the project that shot ABC123 belongs to, find its primary pipeline configuration and use those configuration settings when it launches maya. If you instead want to use the experimental configuration in your development sandbox you instead use the specific tank command inside the dev sandbox to launch maya: ~/sgtk_dev_sandbox/tank Shot ABC123 launch_maya. The Toolkit will now use the config in the dev sandbox instead of the Primary configuration for the project.Using the Core API from a sandboxSimilarly, if you want run the Toolkit API from inside your pipeline configuration and not from the studio install location, you can add your dev sandbox to the PYTHONPATH rather than the studio python API.Accessing a sandboxInside ShotGrid, it is a lot simpler. Each Pipeline Configuration for a Project has a list of users that can see that Configuration. By leaving the field blank, everyone will see the configuration.When you clone a configuration (which you can do by right clicking on it in ShotGrid), you will automatically be associated with that configuration, effectively granting you exclusive visibility to the configuration. If you are developing new tools in Maya and want an artist to test them out, simply add the artist to your pipeline configuration dev sandbox and they can launch maya from your sandbox and will then have access to your work in progress tools.Localizing a Pipeline ConfigurationBy default, a Pipeline Configuration will pick up its code from the ShotGrid Toolkit Studio install. The Toolkit studio installation will contain a cache of all the app and engine code that the ShotGrid Toolkit is using and the Toolkit Core API installation. Each Pipeline configuration will share the Core API and the apps cache in the studio location. This is often useful because you can roll out core API updates to all projects at the same time. Simply update the studio location, and all projects will be affected.Sometimes, however, it is useful to be able to cut off a Pipeline Configuration and make it independent. Examples when this makes sense include:  You have a project that is about to wrap up and want to freeze updates and make sure nothing is changing.  You have a pipeline configuration that you want to test a new version of the Toolkit Core API in.  You are assembling a minimal Toolkit bundle that you will use when working from home.This process of making a pipeline configuration completely independent from the studio location is called localizing the Configuration and basically means that the Core API is copied into the Pipeline Configuration. You do this by running the tank localize command.Note that once you have localized a configuration, you cannot necessarily run the studio tank command anymore - the general rule is that once a project has been localized, you need to use its local tank command and Python API.Deleting a cloned configurationIf you don’t want your cloned configuration or dev area anymore, simply delete the record and then delete the configuration from disk.Checking for UpdatesChecking if there are any updates to apps or engines is easy! Simply run the tank updates command for a project. The ShotGrid Toolkit will check for updates and ask you if you want to update. If there are any new parameters that don’t have default values, the update script will prompt you for values. Each update presents a url link to a release notes page, in case you want to check the details of what has changed. You can exit the process at any point.Updating the Toolkit Core API is equally easy. Just run the tank core command!Creating a staging sandboxWhile it is often perfectly safe to simply run tank updates on your primary configuration, it is sometimes better to test things prior to rolling it out in production. In this case, you just clone the Primary pipeline configuration and run the update commands there. In the case of a Core API upgrade, make sure you localize the sandbox before running the core command (see above for more information about localize). Once you have verified that the update works, run it again on the primary configuration. For more detailed information how to do this, see Managing your configuration.Configuring how Apps are launchedA part of the Toolkit configuration that is often necessary to configure right after you have installed it is the app launch configuration. We have tried to make this flexible and configurable, knowing that this is an area where studios often already have customization and tools in place.When you are launching an application (such as maya or nuke) either from inside of ShotGrid or using the tank command, you are invoking an app that is responsible for starting up the application and initializing the Toolkit. This app is called tk-multi-launchapp.When you setup a new project with one of the Toolkit starter configurations, it will display instructions how to change the application paths that are used with the Launch App. You are not required to use this app - if you have an alternative system in place that works just as well. The Launcher application typically carries out the following steps:      It figures out a context to use. The context represents the current work area. If you are right clicking a task, asset or shot inside ShotGrid, the context is created based on this. If you are using the tank command, it will be something you specify as part of the command line or is picked up from your current directory.        It then launches the application based on settings in the app configuration. You can configure the launch app in several ways - the path to the application, the command line arguments to pass, the actual code that executes the application and environment variables that needs setting prior to application launch.        It sets the Pythonpath to ensure that the Toolkit API can be initialized later.        Once the application has started, the Toolkit API is imported and initialized.        Finally, the engine is launched.  Example: A more hands on example of how the ShotGrid Toolkit starts up.The typical bootstrapping of the Toolkit happens in a couple of phases:      The main host application is launched. This is anything that has a python interpreter. In its simplest form it is just the CPython interpreter running in a standard shell. It can also be Maya or Nuke or anything else that has a built in embedded Python interpreter.        The Toolkit Core API is added to the PYTHONPATH and imported: import sgtk        Now we need to figure out a context. It can either be a path on disk or a ShotGrid object. We can now create a Toolkit API instance using a factory method: tk = sgtk.sgtk_from_path(&quot;/mnt/projects/hero/assets/chair01/lighting&quot;). Alternatively, we can use a ShotGrid Entity: tk = sgtk.sgtk_from_entity(&quot;Shot&quot;, 123). When using an entity, the above code will connect to ShotGrid, resolve the pipeline configuration for that shot, locate the pipeline configuration on disk and load up basic settings for Sgtk such as the file system templates. No apps or engines are loaded at this point. In the case of a path lookup, it will use the file system to locate the pipeline configuration.        Now we create a context object to represent the current work area. This can also be done either from an entity or a path: ctx = tk.context_from_entity(&quot;Shot&quot;, 123) or ctx = tk.context_from_path(&quot;/mnt/projects/hero/assets/chair01/lighting&quot;)        Finally we start the engine. Assuming we are inside of Maya, running these commands in Maya’s python interpreter, we would do this: sgtk.platform.start_engine('tk-maya', tk, ctx). This would do the following:                  Run the pick environment hook for the context. The pick environment hook will return the environment to use. The environment contains a list of all apps to load and their configrations.                    Once the environment file has been determined, the engine is loaded into memory. This will dynamically load the engine base object and execute its init method. Once the engine is loaded, all apps are loaded the same way. Typically, as part of this, the engine will register a “ShotGrid” menu somewhere in the application and each app will register a series of commands with the engine. These commands become the entry points for execution later on: a user clicks something on the ShotGrid menu and that triggers the app execution.            A complete example would look something along these lines:# starting up sgtk when your context is based on a pathimport sgtkpath = &quot;/mnt/projects/hero/assets/chair01/lighting&quot;# create a sgtk api handletk = sgtk.sgtk_from_path(path)# create a context objectctx = tk.context_from_path(path)# start the tank enginesgtk.platform.start_engine('tk-maya', tk, ctx)# starting up sgtk when your context is based on a ShotGrid objectimport sgtkentity_type = &quot;Shot&quot;entity_id = 123# create a sgtk api handletk = sgtk.sgtk_from_entity(entity_type, entity_id)# create a context objectctx = tk.context_from_entity(entity_type, entity_id)# start the sgtk enginesgtk.platform.start_engine('tk-maya', tk, ctx)Creating folders on diskOne key part of the Toolkit Configuration is the file system configuration. The ShotGrid Toolkit can help create folders on disk in a consistent fashion and the creation process is driven from ShotGrid. Below is an overview of the core folder inside a configuration:Setting up a folder configuration is relatively easy. The configuration is basically a template folder structure that you create, with some configuration files to indicate that a folder should be representing for example an asset or a shot. When you configure you file system structure, you can always use the folder preview functionality to get a listing of what will be created. This command is available both in ShotGrid and in the tank command.Start by outlining your scaffold using normal folders. If you have a level of dynamic folders in your scaffold, for example representing assets, shots or pipeline steps, just ignore that for the moment. Once you are happy with the result, add dynamic functionality step by step to each dynamic folder. This is done by adding a yml file that has the same name as the folder.Inside the yaml file, use a special syntax to define how a folder is created. The ShotGrid Toolkit supports a number of different dynamic behaviours, but the normal one is a dynamic node that represents a ShotGrid entity. In this case, the configuration file could look something like this:# the type of dynamic contenttype: &quot;Shotgun_entity&quot;# the Shotgun field to use for the folder namename: &quot;{code}_{sg_prefix}&quot;# the Shotgun entity type to connect toentity_type: &quot;Asset&quot;# Shotgun filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std Shotgun API syntax)# any values starting with $ are resolved into path objectsfilters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }This will inform that that the dynamic folder should create folders named using two ShotGrid fields on the Asset entity. Using standard ShotGrid API query syntax, we also define constraints based on parent folders; only consider assets for the current project and asset type.For a full reference of what types of nodes are supported, please see the reference documentation.Filesystem LocationsWhen folders are created on disk via the Toolkit folder creation system, these folders are also stored and tracked in ShotGrid. Folders are represented as Filesystem Location entities in ShotGrid which can be found under the administrator menu. Normally, this data is tracked behind the scenes by Toolkit and nothing that users need to look at. These Filesystem Location entities are used by Toolkit to sync and track folders on disk and can be used to recreate folder structure on disk just the way it was created when the folder creation was initially running. The Filesystem Location entity data is in turn primarily used when trying to figure out which ShotGrid Entity is associated with a particular path on disk.For performance reasons, the contents of the Filesystem Location table is cached on a user’s local machine. This is in order to speed up folder/entity lookups. For expert users, the location of this cache can be customized by modifying the cache_location core hook. The cached local folder representation is synchronized whenever folders are created on disk and when applications are launched.Renaming Toolkit FoldersWhen you run the Toolkit folder creation, a connection is established between an entity in ShotGrid and a folder on disk. Toolkit uses its folder schema configuration to generate a series of folders on disk and each of these folders are registered as a Filesystem Location entity in ShotGrid. One way to think about this is that ShotGrid data (e.g. Shot and Asset names) and configuration is “baked” out into actual folders on disk and in ShotGrid.Once folders have been created, you can no longer freely change the name of an entity in ShotGrid. If you try to rename an entity and then launch Toolkit, an error message will appear. This is to avoid losing track of the folders which are associated with a particular entity.In order to rename a Toolkit folder, do the following:  First rename the entity (Asset or Shot) in ShotGrid.  Unregister any registered folders by running the tank unregister_folders command. This will remove any filesystem location entities in ShotGrid tracking the relationship between the Entity and locations on disk. Note that this command does not affect any content on disk, but merely the Filesystem Location entities in ShotGrid which point at the locations on disk. For example, if you want to unregister folders for an asset named Plant, execute the command tank Asset Plant unregister_folders. You will be presented with an overview of which folders will be unregistered and you will be asked to confirm the operation.  After unregistering the folders, you have essentially “reset” the asset. No folders are now associated with the asset and by running the folder creation in ShotGrid with the new name, new folders on disk will be created.  Lastly, move any data across from the previous location on disk to the new location. Take care to ensure that any links between files are updated to point to the new location as well.Deferred Creation and User SandboxesIt is also possible to set up the Toolkit folder creation so that it runs in two phases: One phase whenever someone runs the folder creation command, one phase just before an application is launched. This is a behaviour that is built into the Toolkit Application Launcher (which is simply calling a standard API method to carry out the folder creation). With deferred folder creation you can handle the following use cases:  If you have multiple different content creation applications in your pipeline and don’t want to include a complete folder scaffold for every single one of them until they are actually needed, you can set up the folder creation so that each content creation app has its own deferred subtree in the config. When a production person or admin creates folders for the Shot, it will stop just before it starts creating work areas for maya, nuke, mari etc. Then, when an application is launched these folders are created just before the application starts up.  If you want to create user based sandboxes in the file system, these will need to be created immediately prior to the work taking place. With deferred folder creation, you can add a special user node that makes this process easy. In the templates config, you then refer the to user node as HumanUser since this is the way the ShotGrid API denotes it.For more information about deferred creation, please see the reference documentation.Configuring TemplatesOnce you have created the file system structure it is time to configure a set of file system locations based on the folder structure above. These locations are called templates and are an integral part of the ShotGrid Toolkit. The template file contains three parts: a keys section, where you define what each field means, a paths section where you can define template paths and a strings section where you can define string expressions. There are two syntaxes you can use in your file - one simple form that you can use for configs that have a single storage root and an advanced syntax that you can use for multi-root configs.Example: Single Root Template Format# The keys section contains the definitions for all the different keys that are being# used in the Toolkit. A key is a magic token that is replaced by a value at runtime, for example# {Shot}. The section below tells the Toolkit which data types and formats to expect for each key.keys:    Sequence:        type: str    Shot:        type: str    Step:        type: str    sg_asset_type:        type: str    Asset:        type: str    name:        type: str        filter_by: alphanumeric    iteration:        type: int    version:        type: int        format_spec: '03'    version_four:       type: int       format_spec: '04'       alias: version    timestamp:        type: str    width:        type: int    height:        type: int    channel:        type: str        filter_by: alphanumeric    SEQ:        type: sequence        format_spec: '04'    eye:        type: str# The paths section contains all the the key locations where files are to be stored# by the Toolkit Apps. Each path is made up of several keys (like {version} or {shot}) and# these are defined in the keys section above.## Toolkit apps use these paths as part of their configuration to define where on disk# different files should go.paths:    ##########################################################################################    # Shot pipeline / maya    shot_root: 'sequences/{Sequence}/{Shot}/{Step}'    # define the location of a work area    shot_work_area_maya: '@shot_root/work/maya'    # define the location of a publish area    shot_publish_area_maya: '@shot_root/publish/maya'    # The location of WIP files    maya_shot_work: '@shot_root/work/maya/{name}.v{version}.ma'    # The location of backups of WIP files    maya_shot_snapshot: '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'    # The location of published maya files    maya_shot_publish: '@shot_root/publish/maya/{name}.v{version}.ma'    ##########################################################################################    # Asset pipeline / maya    asset_root: 'assets/{sg_asset_type}/{Asset}/{Step}'    # define the location of a work area    asset_work_area_maya: '@asset_root/work/maya'    # define the location of a publish area    asset_publish_area_maya: '@asset_root/publish/maya'    # The location of WIP files    maya_asset_work: '@asset_root/work/maya/{name}.v{version}.ma'    # The location of backups of WIP files    maya_asset_snapshot: '@asset_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'    # The location of published maya files    maya_asset_publish: '@asset_root/publish/maya/{name}.v{version}.ma'# The strings section is similar to the paths section - but rather than defining paths# on disk, it contains a list of strings. Strings are typically used when you want to be# able to configure the way data is written to ShotGrid - it may be the name field for a# review version or the formatting of a publish.strings:    nuke_shot_version_name: '{Shot}_{name}_{channel}_v{version}.{iteration}'    nuke_asset_version_name: '{Asset}_{name}_{channel}_v{version}.{iteration}'Example: Multi Root Template Format## The keys section contains the definitions for all the different keys that are being# used in the Toolkit. A key is a magic token that is replaced by a value at runtime, for example# {Shot}. The section below tells the Toolkit which data types and formats to expect for each key.#keys:    Sequence:        type: str    Shot:        type: str    Step:        type: str    sg_asset_type:        type: str    Asset:        type: str    name:        type: str        filter_by: alphanumeric    iteration:        type: int    version:        type: int        format_spec: '03'    version_four:       type: int       format_spec: '04'       alias: version    timestamp:        type: str    width:        type: int    height:        type: int    channel:        type: str        filter_by: alphanumeric    SEQ:        type: sequence        format_spec: '04'    eye:        type: str# The paths section contains all the the key locations where files are to be stored# by the Toolkit Apps. Each path is made up of several keys (like {version} or {shot}) and# these are defined in the keys section above.# Toolkit apps use these paths as part of their configuration to define where on disk# different files should go.paths:    ##########################################################################################    # Shot pipeline / Maya    shot_root: 'sequences/{Sequence}/{Shot}/{Step}'    # define the location of a work area    shot_work_area_maya:      definition: '@shot_root/work/maya'      root_name: primary    # define the location of a publish area    shot_publish_area_maya:      definition: '@shot_root/publish/maya'      root_name: primary    # The location of WIP files    maya_shot_work:      definition: '@shot_root/work/maya/{name}.v{version}.ma'      root_name: primary    # The location of backups of WIP files    maya_shot_snapshot:      definition: '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'      root_name: primary    # The location of published maya files    maya_shot_publish:      definition: '@shot_root/publish/maya/{name}.v{version}.ma'      root_name: primary    ##########################################################################################    # Asset pipeline / Maya    asset_root: 'assets/{sg_asset_type}/{Asset}/{Step}'    # define the location of a work area    asset_work_area_maya:      definition: '@asset_root/work/maya'      root_name: secondary    # define the location of a publish area    asset_publish_area_maya:      definition: '@asset_root/publish/maya'      root_name: secondary    # The location of WIP files    maya_asset_work:      definition: '@asset_root/work/maya/{name}.v{version}.ma'      root_name: secondary    # The location of backups of WIP files    maya_asset_snapshot:      definition: '@asset_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'      root_name: secondary    # The location of published maya files    maya_asset_publish:      definition: '@asset_root/publish/maya/{name}.v{version}.ma'      root_name: secondary# The strings section is similar to the paths section - but rather than defining paths# on disk, it contains a list of strings. Strings are typically used when you want to be# able to configure the way data is written to ShotGrid - it may be the name field for a# review version or the formatting of a publish.strings:    # when a review version in ShotGrid is created inside of nuke, this is the    # name that is being given to it (the code field)    nuke_shot_version_name: '{Shot}_{name}_{channel}_v{version}.{iteration}'    nuke_asset_version_name: '{Asset}_{name}_{channel}_v{version}.{iteration}'There are a number of configuration options available for the templates file - you can find a complete reference here.@include syntax in the template fileTo cut down on repetition in the templates file, you can reuse fields:paths:    asset_root: 'assets/{sg_asset_type}/{Asset}/{Step}'    maya_asset_work: '@asset_root/work/maya/@maya_asset_file'strings:    maya_asset_file: '{name}.v{version}.ma'You can also split the templates across multiple files and include files in other files. For full details, see the reference documentation.Including external files in your template fileJust like you can split up your environment configuration into multiple files and then including files into other files, you can manage the templates file this way. This can be useful if you for example are setting up a global configuration that is shared across multiple projects.You include additional files in your templates.yml file by using one of the include syntaxes:# single include using a path local to the location of the current fileinclude: './include_file.yml'# multiple incudes, processed in orderincludes: ['./include_file_1.yml', './include_file_2.yml']# you can also use absolute paths when including things:include:# files that are not recognized are skipped, so you can put paths for# windows and linux next to each other for multi platform support:includes: ['/foo/bar/hello.yml', 'z: foo bar hello.yml']# you can use environment variables inside of full paths tooincludes: ['$STUDIO_ROOT/foo/bar/hello.yml', '%STUDIO_ROOT% foo bar hello.yml']An included file needs to have the same structure as the main templates.yml file, meaning that it needs to contain a paths, keys and a strings section. When toolkit processes includes, it will read them in recursively in a top-down, depth first order, adding data separately into three paths, keys and paths “buckets”. If a value already exists in a bucket during this process, it will be overwritten. Once all includes have been processed, the entire configuration is validated.Here’s a quick example. Here is the main templates.yml file:include: ./global_defs.ymlkeys:    name:        type: str        filter_by: alphanumeric    version:        type: int        format_spec: &quot;03&quot;paths:    maya_shot_work: '@shot_root/work/maya/{name}.v{version}.ma'And here is the contents of the included file global_defs.yml:keys:    Sequence:        type: str    Shot:        type: str    Step:        type: strpaths:    shot_root: sequences/{Sequence}/{Shot}/{Step}It is recommended good practice (but may not always be appropriate) to keep the keys and the paths together, so that each file contains all the pieces it needs. This generally makes things easier to maintain.Folder creation and templatesWhen you create a template that refers to folders created by the folder creation system, you need to specify the fields using ‘ShotGrid API’ style notation! This a subtle detail which can be easily missed. The example above is a good illustration of this. In the folder creation, we have set up a configuration which first groups items by their asset type and then by their asset name. For example:/mnt/projects/my_project/assets/character/HeroWe then want to create a template in the Toolkit that matches this path. In order for the ShotGrid Toolkit to be able to match up the template with the path and the context, the fields need to be named the same way you would name them if you were using the ShotGrid API - the asset type folder level needs to be called sg_asset_type since this is the field name for this field in ShotGrid, and the asset level folder needs to be called Asset (with a capital A) since this is how you refer to the asset entity type when using the ShotGrid API.HooksHooks are flexible pieces of the toolkit configuration. Normally, when you configure an app, engine or the core API, you specify a collection of parameters to define the behaviour of something. However, sometimes this is not powerful enough and this is where hooks come into play. Hooks are small chunks of Python code that you can use to customize an aspect of an app, engine or indeed the core. We have tried to design the hooks to be light weight and atomic. There are three different levels at which hooks appear in Toolkit. Read more about each level in the sections below.App level hooksEach Toolkit app (and engine for that matter) comes with a collection of settings, some of which can be hooks. Each app carries a collection of default hooks which will be automatically used unless you specifically override them. Hooks are typically used to customize something very application specific. For example, for a Toolkit which loads images into Maya, the UI code and all the interaction logic is inside the app, but the little piece of business logic which actually loads the image into maya is inside a hook. This makes it possible for a studio to customize the behaviour; the default hook may simple create a standard texture node in maya, but a studio which wants to use a different node type can override the hook and thereby easily change the behaviour of the entire app - without having to rewrite any of the code!When customizing an app hook, you typically copy the default hook from inside the hooks folder in the app into your project’s hooks folder. Next, you need to update the app settings inside the environment file so that it will read your new hook and not the default one. Your custom hook will automatically inherit from the default hook provided by the app, making it easy to add tweaks and small adjustments yet keep most of the business logic in the default hook. For more information about hook inheritance, please see the environment configuration reference.Core level hooksCore hooks makes it possible to override system wide behaviour in toolkit. Core level hooks are all overridden per project, so each project needs to set up individually with overrides. (If you keep re-using the same configuration when you set up new projects, this is generally straight forward).The Core configuration area contains a special hooks folder. This folder is where you can put your own implementations of certain core hooks. Core hooks are similar to the hooks that you find in apps - it is a way to extract a code snippet from the Toolkit and be able to customize it. The core API allows you to override a number of different core behaviours, including file system I/O, folder creation and validation of file system structure.By default, the Toolkit will pick up the core hooks it needs from with the API folder itself. If you want to customize the behaviour, take the hook file and copy it into the config/core/hooks area in your configuration. Then modify the code.For a list of what core hooks are available, have a look at the hooks folder inside the Core API. Each hook contains extensive documentation about what it does and how it can be modified.Studio level hooksThere are also a couple of very special hooks which we call studio level hooks. These hooks are global and will affect everything. These hooks control aspects of Toolkit which sits outside of any specific project.Project name hookThe project setup process will prompt you for a ‘disk name’ for your project and suggest a name based on the project name in ShotGrid, but with spaces and other non-file system friendly replaced with underscores. The disk name will be the name of the folder under which the project data and configuration is stored.It is possible to use slashes when specifying the disk name. This will produce a project root point which spans over several folders in depth and can sometimes be useful if the studio is organizing its projects based on for example discipline (commercials, vfx, etc) or if the sheer volume of projects in a studio is so large that a single level in the file system would make it difficult to overview. Note that you should always use forward slashes (‘/’). Toolkit will make the necessary adjustments on Windows.In conjunction with the multi-level folders described above, it is also possible to customize the name that Toolkit suggests as part of the setup process. This is done in a special studio-level hook. If you want to customize this behaviour, create a file named project_name.py inside of the studio API location, in the config/core folder. This folder should already contain files such as install_location.yml, app_store.yml and shotgun.yml.The project_name.py hook file can for example look like this:from tank import Hookimport osclass ProjectName(Hook):    def execute(self, sg, project_id, **kwargs):        &quot;&quot;&quot;        Gets executed when the setup_project command needs a disk name preview.        &quot;&quot;&quot;        # example: create a name based on both the sg_type field and the name field        sg_data = sg.find_one(&quot;Project&quot;, [[&quot;id&quot;, &quot;is&quot;, project_id]], [&quot;name&quot;, &quot;sg_type&quot;])        # create a name, for example vfx/project_x or commercials/project_y        name = &quot;%s/%s&quot; % ( sg_data[&quot;sg_type&quot;], sg_data[&quot;name&quot;] )        # perform basic replacements        return name.replace(&quot;_&quot;, &quot;/&quot;).replace(&quot; &quot;, &quot;/&quot;)Connection hookToolkit stores connection settings so that it can connect to its associated ShotGrid instance. Sometimes it may be useful to control these connection settings in a dynamic fashion. In this case, create a hook file named sg_connection.py inside of the studio API location, in the config/core folder. This folder should already contain files such as install_location.yml, app_store.yml and shotgun.yml.This hook that is called after ShotGrid connection settings have been read in from the shotgun.yml and app_store.yml configuration files. It makes it easy to modify connection settings procedurally, for example set up a proxy server which depends on some external environment variable.The following three parameters are passed to the hook:      config_data is a dictionary containing the settings in the ShotGrid config file that has been read in. It typically contains the keys host, api_script, api_key and http_proxy.        user is the user profile which the connection information is associated with. This is an expert setting and is almost always set to defualt.        cfg_path is the path to the configuration file from which the config_data was loaded.  The hook needs to return a dictionary on the same form as config_data.If you are customizing proxy settings, note that the proxy string returned should be on the same form as is expected by the ShotGrid API constructor, e.g. 123.123.123.123, 123.123.123.123:8888 or username:pass@123.123.123.123:8888.Below is an example implementation that can be used as a starting point:from tank import Hookimport osclass CustomShotunConnection(Hook):    &quot;&quot;&quot;    Allows for post processing of ShotGrid connection data prior to connection    &quot;&quot;&quot;    def execute(self, config_data, user, cfg_path, **kwargs):        # explicitly set the proxy server setting        config_data[&quot;http_proxy&quot;] = &quot;123.123.123.123&quot;        return config_dataConfiguring Apps and EnginesNow that we have a templates file set up that defines all the key locations on disk, we can start deciding which apps and engines to include in our configuration. As explained in other parts of the introductory documentation, the apps and engines configuration is broken down into series of environments. Environments are essentially alternative configurations - and this is useful since you most likely need to provide a different suite of apps, configured differently, for example shot work and asset work. For a more complex pipeline, you may want to break it down further in departments, so that modeling have a different setup than rigging. This is all handled via environments.The environment file defines a number of possible engines, and depending on the application you are running, one of these sections will be used. For example, if you are running maya, you tell the Toolkit to launch the ‘tk-maya’ engine. The ShotGrid Toolkit will first determine which environment to use (based on the current work area) and then look for a tk-maya engine inside this environment. When it finds it, it will load in all the apps defined for this section.Each app has a number of settings that can be configured. When you install or upgrade an app, the ShotGrid Toolkit will ask you to configure any setting that doesn’t have a default value. The Toolkit Apps are often designed to be reusable, so depending on how you set it up, it can be used in many different ways and workflows. You can even have the same app defined several times in the same environment, for example you may want to have two publishers appear on the maya menu - one for a rig publish and one for a model publish - both using the same publishing app but with different configurations.Example: An environment fileinclude: ./includes/app_launchers.ymlengines:  # 3dsmax engine  tk-3dsmax:    debug_logging: false    location: {name: tk-3dsmax, type: app_store, version: v0.2.6}    # all the registered apps for this engine    apps:      tk-multi-about:        location: {name: tk-multi-about, type: app_store, version: v0.1.8}      tk-multi-loader-texture:        dependency_mode: false        hook_add_file_to_scene: default        location: {name: tk-multi-loader, type: app_store, version: v0.2.6}        menu_name: Load Texture...        publish_filters: []        sg_entity_types:          Asset: []        single_select: true        tank_types: [Diffuse Texture, Specular Texture]      tk-multi-publish:        display_name: Publish        hook_copy_file: default        hook_post_publish: default        hook_primary_pre_publish: default        hook_primary_publish: default        hook_scan_scene: default        hook_secondary_pre_publish: default        hook_secondary_publish: default        hook_thumbnail: default        location: {name: tk-multi-publish, type: app_store, version: v0.2.5}        primary_description: Publish and version up the current 3ds Max scene        primary_display_name: 3ds Max Publish        primary_icon: icons/publish_3dsmax_main.png        primary_publish_template: max_shot_publish        primary_scene_item_type: work_file        primary_tank_type: 3dsmax Scene        secondary_outputs: []        template_work: max_shot_work      tk-multi-screeningroom: '@launch_screeningroom'      tk-multi-snapshot:        hook_copy_file: default        hook_scene_operation: default        hook_thumbnail: default        location: {name: tk-multi-snapshot, type: app_store, version: v0.1.15}        template_snapshot: max_shot_snapshot        template_work: max_shot_work      tk-multi-workfiles:        hook_copy_file: default        hook_scene_operation: default        location: {name: tk-multi-workfiles, type: app_store, version: v0.2.5}        sg_entity_types: [Shot, Asset]        template_publish: max_shot_publish        template_publish_area: shot_publish_area_max        template_work: max_shot_work        template_work_area: shot_work_area_max  # the maya engine  tk-maya:    debug_logging: false    location: {name: tk-maya, type: app_store, version: v0.2.7}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: File Manager...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}    - {app_instance: tk-multi-workfiles, name: Save As...}    - {app_instance: tk-multi-publish, name: Publish...}    template_project: shot_work_area_maya    # all the registered apps for this engine    apps:      tk-maya-breakdown:        hook_multi_update: default        hook_scan_scene: default        location: {name: tk-maya-breakdown, type: app_store, version: v0.2.7}      tk-multi-about:        location: {name: tk-multi-about, type: app_store, version: v0.1.8}      tk-multi-loader-1:        dependency_mode: false        hook_add_file_to_scene: default        location: {name: tk-multi-loader, type: app_store, version: v0.2.6}        menu_name: Load Assets...        publish_filters: []        sg_entity_types:          Asset: []        single_select: true        tank_types: [Maya Model, Maya Rig]      tk-multi-loader-2:        dependency_mode: false        hook_add_file_to_scene: default        location: {name: tk-multi-loader, type: app_store, version: v0.2.6}        menu_name: Load Shots...        publish_filters: []        sg_entity_types:          Shot: []        single_select: true        tank_types: [Maya Anim, Maya Lighting, Maya Scene]      tk-multi-publish:        display_name: Publish        hook_copy_file: default        hook_post_publish: default        hook_primary_pre_publish: default        hook_primary_publish: default        hook_scan_scene: default        hook_secondary_pre_publish: default        hook_secondary_publish: default        hook_thumbnail: default        location: {name: tk-multi-publish, type: app_store, version: v0.2.5}        primary_description: Publish and version up the current Maya scene        primary_display_name: Maya Publish        primary_icon: icons/publish_maya_main.png        primary_publish_template: maya_shot_publish        primary_scene_item_type: work_file        primary_tank_type: Maya Scene        secondary_outputs: []        template_work: maya_shot_work      tk-multi-screeningroom: '@launch_screeningroom'      tk-multi-setframerange:        location: {name: tk-multi-setframerange, type: app_store, version: v0.1.2}        sg_in_frame_field: sg_cut_in        sg_out_frame_field: sg_cut_out      tk-multi-snapshot:        hook_copy_file: default        hook_scene_operation: default        hook_thumbnail: default        location: {name: tk-multi-snapshot, type: app_store, version: v0.1.15}        template_snapshot: maya_shot_snapshot        template_work: maya_shot_work      tk-multi-workfiles:        hook_copy_file: default        hook_scene_operation: default        location: {name: tk-multi-workfiles, type: app_store, version: v0.2.5}        sg_entity_types: [Shot, Asset]        template_publish: maya_shot_publish        template_publish_area: shot_publish_area_maya        template_work: maya_shot_work        template_work_area: shot_work_area_mayaEach App has a Location settingEach item in the environment file has a special location token. This token defines where the Toolkit should pick up the app code from and how it should check for new versions of the app. For example, a location token may be defined like this:location: {name: tk-multi-setframerange, type: app_store, version: v0.1.2}The type indicates that this app comes from the app store and that a particular version is being used. When you run the update check, the ShotGrid Toolkit will connect to the app store and check if there is a version more recent than v0.1.2 available and if this is the case, ask you if you want to upgrade. The Toolkit supports a couple of different location types, including git and github, so you can build your own apps, use git to track them and when you create a new tag in git, the update will detect this handle it correctly in the upgrades check. For detailed information, see the reference documentation.Including filesYou can include external files into your environment files. This is often useful when you try to centralize settings or manage overrides:      You can organize your configuration so that you manage all the file paths to applications (maya, nuke) in one place even though you launch maya from multiple environments.        Apps that are used with the same settings in many environments can be defined in a single place.        You could maintain a ‘central’ pipeline configuration that is shared across multiple projects, and when this is updated, all projects will benefit from the update. Each project could then potentially override or extend the central config that is included if they need a particular behaviour.        You can include files from your context as overrides, meaning that you could reconfigure settings parameters on a per-shot or per-asset basis. This is illustrated in our default config, where you can set override the paths to maya, nuke, etc. on a per shot or asset basis.        If you use environment variables in full paths, these will be automatically expanded. Note that on linux, they must be on the $ENV_VAR form and not on the ${ENV_VAR} form as this will confuse the include parser. Example: includes: ['$STUDIO_ROOT/foo/bar/hello.yml', '%STUDIO_ROOT% foo bar hello.yml'].  Example: Shot specific overrides for app launchImagine you have the following environment file for the shell engine:include: ./includes/app_launchers.ymlengines:  tk-shell:    debug_logging: false    location: {name: tk-shell, type: app_store, version: v0.3.0}    apps:        tk-multi-launch3dsmax: '@launch_3dsmax'        tk-multi-launchmaya: '@launch_maya'        tk-multi-launchmotionbuilder: '@launch_motionbuilder'        tk-multi-launchnuke: '@launch_nuke'        tk-multi-launchphotoshop: '@launch_photoshop'Each of those apps are references, defined in the app_launchers include file. This file contains the actual app configurations for each of the apps and looks like this:includes:    # first include the configuration's global settings for application paths    - ./paths.yml    # now include overrides - these will be loaded if they are found    - sequences/{Sequence}/{Shot}/sgtk_overrides.yml    - assets/{sg_asset_type}/{Asset}/sgtk_overrides.ymllaunch_3dsmax:  engine: tk-3dsmax  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: ''  linux_path: ''  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.4}  mac_args: ''  mac_path: ''  menu_name: Launch 3DSMax  windows_args: ''  windows_path: '@3dsmax_windows'launch_maya:  engine: tk-maya  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: ''  linux_path: '@maya_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.4}  mac_args: ''  mac_path: '@maya_mac'  menu_name: Launch Maya  windows_args: ''  windows_path: '@maya_windows'The above file does not contain any actual paths to maya, nuke etc. Instead, these are defined in a separate file, paths.yml:# mayamaya_windows: 'C: Program Files Autodesk Maya2012 bin maya.exe'maya_mac: /Applications/Autodesk/maya2012/Maya.appmaya_linux: maya# nukenuke_mac: /Applications/Nuke6.3v8/Nuke6.3v8.appnuke_windows: 'C: Program Files Nuke6.3v8 Nuke6.3.exe'nuke_linux: Nuke6.3Note how the app_launchers file first includes the above file, but then also includes sequences/{Sequence}/{Shot}/sgtk_overrides.yml. This is a context specific file path, just like a template, so it will try to resolve the path against the current context. If it manages to resolve it, it will look for the path and load it in. This means that you can create a sgtk_overrides.yml in the shot location and override the application paths for a specific shot only:# mayamaya_windows: 'C: Program Files Autodesk Maya2012 bin special_maya.exe'Here we are using a special version of Maya for windows. The rest of the paths will be the original paths defined in the paths.yml file.For more details on how the includes work, see the reference documentation.Configuring Template settings - file pathsAn important type of setting that many Apps use is the template setting. Apps needing to specify a file system location will use these settings. Apps are developed to be generic or flexible, designed to work with any file system structure or naming convention. The templates are the key piece which makes it possible for and app to be independent of the underlying file system. For more information about this, see the concepts introduction.When configuring apps and are coming across a template setting, you will need to specify a template that contains the right set of fields. Fields can be either required or optional, with required being fields that have to be included in the template and optional meaning that a field can be part of the template, however the app will also work if that field is not defined in the template.When an app runs, it will create paths from the template that you specify in the configuration. These paths are created based on the current context plus a set of fields provided by the app logic. This means that if your template contains any fields that are not part of the context nor part of the optional or required fields for the app, the app doesn’t know how to set a value for that field and hence wont work. This situation is prevented by the Toolkit validating the configuration at startup.When a template setting is validated, the Toolkit will first check the context - and compare the fields given by the context against the fields in the template. If the list of fields once the context has been compared isn’t matching the required/optional parameter definition for the app, a validation error will be raised.Practical Example: The snapshot appHere’s a practical example of how this works. Let’s have a look at one of the Toolkit apps, the snapshot app:This app uses a number of template settings. Here’s one of those settings, as defined in the app settings breakdown:  Settings name: template_snapshot  Type: template  Required Template Keys: version  Optional Template Keys: name, timestamp, increment  Description: A reference to a template which defines the location where snapshot backups will be stored on disk.In addition to the fields provided by the context at runtime, this template setting requires a template that contains a version field. It can also contain optional name, timestamp or increment fields, but not any other fields. For example:Imagine you start up Maya for a Task on a Shot. The context will then contain the following fields:  The current project is set.  The current entity (e.g. the Shot) is set.  The current step is set.  The current task is set.When the engine starts up, it will validate the configuration. Here’s some examples of what would happen with different settings for the template_snapshot field above:      The template sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{version}.ma would be valid to use with the snapshot template_snapshot setting:          Sequence, Shot and Step are populated by the context. Note that because the context knows what the current Shot is, it can automatically figure out what the current Sequence is (since this is a parent folder in the file system).      There is a version field in the template which the App setting requires      There is a name field, something that is optional.      There are no other fields.            The template assets/{Asset}/work/maya/{name}.v{version}.ma would be invalid because the (Shot) context does not know how to resolve the Asset field.        The template sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.ma would be invalid because the required version field is missing.        The template sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{version}.{extension} would be invalid because the field extension is unknown and the app does not know how to populate it.  Using Hooks to customize App BehaviourAnother type of setting that apps use frequently is the hook settings type. A hook is a piece of code that the app will run as part of its normal execution. Hooks makes it possible to do very flexible customization of apps and means that some of the business logic of the app can be separated out from the actual app code.For example, imagine a breakdown app that needs to scan the scene for various references and file inputs. For maya, we can provide a default behaviour that handles the standard reference nodes that maya provides, but what if a studio is using a custom type of reference node? Of course the studio could always take the app and fork it in github, but that’s a pretty drastic action given that all they really want to change is to add their custom node type to the code that scans the scene for reference nodes.Instead, the breakdown could implement the scene scanning code snippet as a hook. This means that it is effectively a setting, a part of the app configuration. It will come with a default value, which will handle the plain-vanilla maya case, so it will work out of the box, but it is also easy for someone to configure the ShotGrid Toolkit to change this behaviour completely if they wish.When an App is installed, the hook settings will all show up in the configuration as default. This means that the app will use the built in hook implementation that comes with the App. For example, here’s the launcher app configuration as an example:launch_maya:  engine: tk-maya  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: ''  linux_path: '@maya_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.4}  mac_args: ''  mac_path: '@maya_mac'  menu_name: Launch Maya  windows_args: ''  windows_path: '@maya_windows'We can see that there are two hooks here, hook_app_launch and hook_before_app_launch, both using the default app implementation. These hooks have been created to allow studios to customize the launch process, set environment variables etc.In order to customize these hooks, first you need to find their original implementation. Each App has a hooks folder in which any hooks will be registered. Now grab the hook you wish to customize and copy the hook into the hooks folder in your configuration. Make the necessary code changes.Now the environment configuration still has the hook set to default and as long as it has that, it will pick up the default hook that comes with the app and nothing else. In order to pick up your new settings, change default to the name of the python hook file you have inside the configuration hooks folder.Example: How to customize a hookHere’s a quick rundown of how to customize the hook_before_app_launch hook for an app launcher.      Copy the default hook implementation. See the image above for the location of the default hook that comes with the app. Now copy this file into your configuration area, in the hooks folder. For example, if your Pipeline Configuration is located in /mnt/software/sgtk/big_buck_bunny, you want to copy the file to /mnt/software/sgtk/big_buck_bunny/config/hooks/before_app_launch.py        Make the necessary changes to the python code.        Finally, update the environment configuration to use your new code:  yaml launch_maya: engine: tk-maya extra: {} hook_app_launch: default hook_before_app_launch: before_app_launch # &amp;lt;-- uses custom hook! linux_args: '' linux_path: '@maya_linux' location: {name: tk-multi-launchapp, type: app_store, version: v0.2.4} mac_args: '' mac_path: '@maya_mac' menu_name: Launch Maya windows_args: '' windows_path: '@maya_windows'The next time you run the launch app, your code will be executed instead of the default hook code.",
    "url": "/425b1da4/",
    "relUrl": "/425b1da4/"
  },
  "8": {
    "id": "8",
    "title": "Configuration Setup",
    "content": "Getting started with configurationsAfter completing this guide, you will have the knowledge fundamental to adding your project information to a configuration, associating that configuration with your project, and preparing your pipeline configuration to be customized.About the guideThis guide describes how to use the Advanced Project Setup Wizard in ShotGrid Desktop to create a configuration for a digital content creation pipeline. You will quickly become acquainted with the configuration tools, learn how to use the Wizard, and be presented with opportunities to learn more. Using the Wizard creates a pipeline configuration for your project and prepares it to be edited and extended to support each step in the pipeline. The configuration controls aspects of the UI, ShotGrid Apps, and various tools necessary to support a production pipeline. Using the Wizard is just one way to extend a configuration. Along with adding specific settings for each step in a pipeline, it will add integrations with software applications. In this guide, we’ll be basing our project’s configuration on Toolkit’s Default Configuration.This guide assumes the user:  Has never used the Advanced Project Setup Wizard  Has some basic knowledge of how to use ShotGrid  Is new to ShotGrid ToolkitUsing this documentTo use this guide and create a customizable configuration for your project, the following is required:  An active ShotGrid site. You can register for ShotGrid here and get a 30-day trial to begin exploring.  ShotGrid Desktop. If Desktop is not installed, you can begin by following this link.  Access to a filesystem where you can store project files and a pipeline configuration. On the filesystem, create a folder called Shotgun, with two folders, projects and configs, within it.About the Advanced Project Setup WizardThe Advanced Project Setup Wizard in ShotGrid Desktop generates a pipeline configuration based on the Default Configuration. The Default Configuration provides a solid base to build on, complete with customizable settings, apps, and UI elements that support the pipeline process. It creates a configuration you can edit and extend to meet your project’s pipeline needs.The Default Configuration includes:  A basic filesystem schema and templates that determine where files live on disk  All of the supported software integrations allowing interaction with ShotGrid and pipeline functions from directly inside the user’s software applications.Customizations are only limited by imagination, cleverness, and programming knowledge or the ability to borrow from what others in the ShotGrid community have created.Creating the configurationA configuration is required for every project. The first time a project is accessed through ShotGrid Desktop, a Basic Configuration is downloaded and configured. This Basic Configuration automatically detects the supported content creation software a user has on their system and associates the configuration with the project. Settings in the pipeline configuration govern the integrations within the supported software applications. The Panel app displays project information from ShotGrid and allows artists to reply to notes and view Versions without leaving their work session. The Publisher app allows artists to make their work available for others on their team, and through the Loader app, artists can load their teammates’ published files. The Basic Configuration does not include file system management setup or the development of templates for specifying how files and directories are named on disk. It also doesn’t have the plethora of Apps that are added when a Default Configuration is configured. It is a simple configuration that allows Toolkit to run without any manual editing of configuration files. The Wizard replaces the Basic Configuration with a Default Configuration. It provides more apps and software integrations to support you on your journey. While the Basic Configuration can be edited as well, it’s not until you have an advanced setup that your project will be set up for customization.Differences between the Basic and Default Configurations            FEATURE      BASIC CONFIGURATION      DEFAULT CONFIGURATION                  Download      Automatically downloaded when a project is accessed      Created via Advanced Setup Wizard              Accessibility      Stored in a system location      Manually editable files              Updates      Automatically updated      Manually updated              File System Support      No support for filesystem schema      Includes tools to support folder structure and file naming standards              Software Integrations      3ds Max, Houdini, Maya, Nuke, Photoshop, Flame      Basic + Hiero, Motionbulder, Mari              Toolkit Apps      ShotGrid Panel, Publisher, Loader      Basic + Workfiles, Snap Shot, Scene breakdown, Nuke write node, Houdini Mantra node, and more      In this guide, you will use the Wizard in ShotGrid Desktop to generate a pipeline configuration for your project based on the Default Configuration. Generating this configuration sets you up to make the customizations necessary to support a proprietary production pipeline.Begin ExercisePrepare to use a Default ConfigurationStep 1: Create a new project in ShotGrid called “the_other_side.”Step 2: Launch the ShotGrid Desktop app and log in using the username and password from your ShotGrid site.Step 3: Navigate to the project where you wish to run the Wizard by selecting its thumbnail image.                    Tip: If a new project was created while Desktop was open, the Projects window may need to be refreshed to see the new projects. Select your profile avatar at the bottom right of the desktop and select Refresh Projects.    Accessing the Default ConfigurationA Basic Configuration was downloaded and configured when the project was accessed. The Publish app and supported software packages were detected and automatically added to the Apps pane in ShotGrid Desktop.Step 4: Once the project is loaded, select your profile avatar at the bottom right of the screen. In the popup menu, select Advanced project setup… to initiate the Wizard.A dialog box will be displayed with four options and ShotGrid Default selected. At this point, you can choose to base your project’s pipeline configuration on the configuration of an existing project, on a configuration in a git repository, or on a path on disk.For this exercise, we’ll choose ShotGrid Default. This option will create a pipeline configuration for your project that’s based on ShotGrid’s Default Configuration.Step 5: Select Continue.A dialog box will be displayed with two options and Default selected. At this point there’s an option to select a Legacy Default Configuration setup. This configuration setup is from an older version of ShotGrid for studios who still use that version. We will use the Default for this exercise.Step 6: Select Continue.Define storage locations for project filesA dialog box will appear displaying a drop-down menu next to the word Storage:Step 7: Identify where to store project data for this project. From the dropdown at the top of the dialogue box select + New and type projects in the field.ShotGrid Toolkit supports three operating systems: Linux, Mac, and Windows.Step 8: Select the field next to the operating system utilized for storing project data. Select the folder icon and navigate to the project folder created on the filesystem prior to this exercise.This setup allows ShotGrid to have access to only the folder you identify for storing production data. When preparing for this exercise you added a projects/ directory within your ShotGrid root directory. The projects/ directory is where Toolkit will store any local project related information.Step 9: Select SAVE to identify the projects folder as the storage destination for project data.The operating system path is automatically updated to identify the path where the project data is stored.Step 10: Select Continue.Name the Project FolderA dialog box is displayed with the name of the project populating the text field. The name is automatically populated pulling from the project information and the path is automatically updated.Toolkit can work in either a Distributed Setup, where the pipeline configuration is uploaded to ShotGrid and cached locally for each user, or a Centralized Setup, where users access a single configuration in a shared location on disk. For this exercise we will use a Centralized Setup. You can learn more about Distributed Setups here.The final step generates the appropriate folders, files, and data necessary to create the configuration specific to a project.Step 11: Under the appropriate operating system, select Browse… and navigate to the configuration folder you created when preparing for this exercise, configs, and enter the project name the_other_side. This creates the folder where the project configuration is stored. Select Run Setup and wait for it to complete the setup.Step 12: Select Done to display the new icons populating the project windows.TIP: Pin the app to the menu bar to allow quick access to ShotGrid Desktop: select your avatar and select Pin to Menu.You’re done; the project setup is complete. You now have a Toolkit pipeline configuration for your project in the location you specified, based on the Default Configuration, and you’re ready to start customizing.Take a look in the configs folder and you will find several folders and files. Explore a little to see what’s in there.And now the real fun begins, learning all the things you can do with the Configuration. Below are some advanced topics to explore.Advanced topicsShotGrid Toolkit provides many convenient ways to edit, clone, or take over a configuration. Extending existing configurations will save time and allow you access to all of the cool stuff that others within your network have created. You can take advantage of the vast ShotGrid community that may have the exact configuration you need. The ShotGrid community is a sharing community, so be kind, say thank you, and recognize the person who created the configuration that helped you get the job done. Oh, and don’t forget to give back, it’s how we help our fellow ShotGrid gurus and what makes it so special to be a part of this community!Below are some ways you can have fun with configurations.Using the command line to create a default configurationFrom inside any project configuration, the tank command lets you run administrative commands from a terminal. Each project has its own dedicated tank command. The tank setup_project command’s functionality is analogous to the Advanced Setup Wizard’s: it creates an editable configuration on disk for your project based either on an existing project’s configuration or the Default Configuration. You can learn more about running tank setup_project here, and more about the  tank command here.Editing a configuration that’s in productionThere will be times when you want to modify a configuration that is currently in production, but you won’t want to edit it while artists are using it. With just a few commands, ShotGrid provides a way to copy an existing configuration where you can test your modifications safely before pushing them into production. This process replaces the production configuration with the new one and automatically backs up the old one.The reasons you would want work on a copy of a configuration are:  To update the configuration  Test some modifications before going live  Upgrade, or add some apps  Do development and roll it out after it’s been testedTo learn about cloning your configuration, as well as other basics of configuration management, refer to the Configuration Staging and Rollout document.Cloud distribution of pipeline configurationsThis guide walks through creating a centralized configuration: a single copy of a pipeline configuration that is located in a shared network location and accessed by all users. But, if your workforce is distributed across locations and networks, it may not be feasible to share a single copy of a pipeline configuration. Toolkit allows for this scenario by providing a distributed configuration option where a pipeline configuration is uploaded to ShotGrid and each time a user accesses a project the configuration is downloaded and cached locally. You can learn more about distributed configurations in our Core API developer documentation.Working with more than one root folderIdeally your facility would want to be optimized for specific tasks. You can work with more than one root folder to optimize things such as video playback for dailies on one server and interactive processing on another. Toolkit allows you to work with more than one storage root in order to facilitate workflows such as these. Check out how to convert from a single root to a multi-root configuration.Now that you have a pipeline configuration for your project, get started on editing it! Jump into the next guide, Editing a Pipeline Configuration, to learn how.",
    "url": "/5d83a936/",
    "relUrl": "/5d83a936/"
  },
  "9": {
    "id": "9",
    "title": "Alias ShotGrid Workflows",
    "content": "Alias ShotGrid WorkflowsThese workflows cover using ShotGrid and Alias for Automotive Design. For more tutorials, visit:  Artist Workflows in Automotive Design  Automotive introduction tutorial",
    "url": "/7584b650/",
    "relUrl": "/7584b650/"
  },
  "10": {
    "id": "10",
    "title": "Apps and Engines Configuration Reference",
    "content": "Apps and Engines Configuration ReferenceThis document contains an overview of all the different options that you can include when creating configurations for Apps, Engines and Frameworks in the ShotGrid Pipeline Toolkit. It can be useful when doing advanced configuration of Apps, and it is important when you are doing development and need to add parameters to your App Configuration Manifest.This document describes functionality only available if you have taken control over a Toolkit configuration. For more info, see ShotGrid Integrations Admin Guide.IntroductionThis document contains specifications for the various file formats that Sgtk uses for its configuration and settings. Please note that this is a reference document which outlines all the various options and parameters available. For best practices on how to manage your configuration, please see the following document:Configuration Management best practices.ShotGrid Pipeline Toolkit EnvironmentsThree major components exists in Toolkit:  An engine provides a translation layer or an adapter between a host application (such as Maya or Nuke) and Sgtk Apps. Apps typically use python and PySide, and it is the responsibility of the engine to present the host application in a standardized fashion and for example add pyside on top of the host application if this doesn’t exist already.  An app provides a piece of business logic, it is essentially a tool that does something. Apps can be hand crafted to work in a specific host application, or they can be designed to run in more than one host application.  A framework is a library which can be used by engines, apps or other frameworks. A framework makes it possible to more easily manage code or behaviour which is shared between multiple apps.An environment file contains the configuration settings for a collection of engines, apps and frameworks. Such a collection is called an Environment. Sgtk launches different environments for different files or different people. You can for example have an environment for Shot production and environment for Rigging. Each environment is a single yaml file.Environment files are located at /&amp;lt;sgtk_root&amp;gt;/software/shotgun/&amp;lt;project_name&amp;gt;/config/envThe yaml file has the following basic format:    engines:        tk-maya:            location            engine settings                apps:                tk-maya-publish:                    location                    app settings                    tk-maya-revolver:                    location                    app settings            tk-nuke:            location            engine settings                apps:                tk-nuke-setframerange:                    location                    app settings                    tk-nuke-nukepub:                    location                    app settings        frameworks:        tk-framework-tools:            location            framework settingsEach app and engine can be configured via settings. These settings correspond with the list of settings that the app/engine exposes in its manifest file called info.yml. As of v0.18.x of Sgtk Core, settings only need to be specified if they differ from the default values specified in the manifest file. In addition to the manifest file, the configurable settings can typically be found on the app/engine page within the Toolkit App Store.In addition to the various settings that can be defined for each item, each app, engine and framework also needs to define where its code is located. This is done using a special location parameter.Code LocationsEach app, engine or framework defined in the environment file has got a location parameter which defines which version of the app to run and where to download it from. Most of the time this is handled automatically by the tank updates and tank install commands. However, if you are doing hand editing of configurations, a variety of options are available for you to help deploy and structure Toolkit:Toolkit currently supports app installation and management using the following location descriptors:  An app_store descriptor represents an item in the Toolkit App Store  A ShotGrid descriptor represents an item stored in ShotGrid  A git descriptor represents a tag in a git repository  A git_branch descriptor represents a commit in a git branch  A path descriptor represents a location on disk  A dev descriptor represents a developer sandbox  A manual descriptor that is used for custom deployment and rolloutFor documentation on how to use the different descriptors, please see the Toolkit reference documentation.Disabling Apps and EnginesSometimes it can be useful to temporarily disable an app or an engine. The recommended way of doing this is to to add a disabled: true parameter to the location dictionary that specifies where the app or engine should be loaded from. This syntax is supported by all the different location types. It may look like this for example:location: {&quot;type&quot;: &quot;app_store&quot;, &quot;name&quot;: &quot;tk-nukepublish&quot;, &quot;version&quot;: &quot;v0.5.0&quot;, &quot;disabled&quot;: true}Alternatively, if you want an app to only run on certain platforms, you can specify this using the special deny_platforms setting:location: {&quot;type&quot;: &quot;app_store&quot;, &quot;name&quot;: &quot;tk-nukepublish&quot;, &quot;version&quot;: &quot;v0.5.0&quot;, &quot;deny_platforms&quot;: [windows, linux]}Possible values for the  deny_platforms  parameter are windows, linux, and mac.Settings and parametersEach app, engine or framework explicitly defines a number of settings which you can override in the configuration file. These settings are strongly typed into strings, integers, lists, etc. For details, see the Toolkit reference documentation.",
    "url": "/6d10dedf/",
    "relUrl": "/6d10dedf/"
  },
  "11": {
    "id": "11",
    "title": "as_template_fields() Is Missing Values That Exist in My Context",
    "content": "as_template_fields() is missing values that exist in my contextThe as_template_fields() method uses the path cache so if the folders corresponding to the keys in your template haven’t been created yet, then you won’t get the fields returned. This can happen for a couple of reasons:  Your template definition and schema need to be in sync. If you’ve modified either this template definition or your schema in your pipeline configuration, but not both, the expected fields will not be returned.  The folders have not been created for this particular context. If they haven’t been created yet, there will be no matching records in the path cache and the expected fields will not be returned.",
    "url": "/8d9d2658/",
    "relUrl": "/8d9d2658/"
  },
  "12": {
    "id": "12",
    "title": "ascii codec can’t decode byte 0x97 in position 10",
    "content": "ASCII codec can’t decode byte 0x97 in position 10: ordinal not in rangeRelated error messages:While cloning a configuration  TankError: Could not create file system structure: ascii! codec can’t decode byte 0x97 in position 10: ordinal not in range(128)While setting up a project configuration using another project  ” ‘ascii’ codec can’t decode byte 0x97 in position 10: ordinal not in range(128)”How to fix:Typically we see this error when there is a Unicode/special character somewhere in the “config” folder. We recomment taking a look to see if you can spot the special character.Example of what’s causing this error:In this case, the error stemmed from Windows adding a postfix – at end of file name. After removing all of those files, it started to work.See the full thread in the community.",
    "url": "/483eb2db/",
    "relUrl": "/483eb2db/"
  },
  "13": {
    "id": "13",
    "title": "AWS Knowledge",
    "content": "AWS KnowledgeBelow you can find links to additional reading material from AWS, including documentation on technologies leveraged by the Isolation feature set, as well as compliance information:  [AWS Media Blog] Securing Studio IP in AWS: Cloud-based VFX Project Management with Autodesk Shotgun  [AWS Media Blog] Designing for Studio-Grade Security  [Compliance] MPAA &amp;amp; Studio Security  [AWS Direct Connect] Overview          [AWS Direct Connect] User Guide        [AWS S3] Overview          [AWS S3] User Guide        [AWS EC2] Overview          [AWS EC2] User Guide        [AWS VPC] Overview          [AWS VPC] User Guide        [AWS PrivateLink] Overview",
    "url": "/5528234a/",
    "relUrl": "/5528234a/"
  },
  "14": {
    "id": "14",
    "title": "Webhooks Batch Deliveries",
    "content": "Batch DeliveryEnabling Batch DeliveryYou can choose to configure your webhook so that it will make requests with a batched payload format by selecting the “Deliver in Batched Format” option.If enabled, at the time each request is formed, it will batch up to 50 pending deliveries into its payload.This can help with managing the processing of large bursts of deliveries as a result of many SG events being generated in a short amount of time. Under typical system operation, multiple deliveries per payload will occur when subscribed events are generated more frequently than once in a 2-second period.Responding to deliveriesIf enabling batched deliveries, we recommend that your receiving service is designed to guarantee a response much faster than 1 second per event. Otherwise, you will be at increased risk for timeouts and webhook failure when batches are large.                    Note: For a receiving service that takes on order of 1 second to respond to a single event, the response time is the main performance factor, not delivery overhead. There will not be any significant benefit in batching.    Non-batched-deliveries Webhooks  timeout allowance is 6 seconds per delivery. i.e. a webhook endpoint must respond to each request within 6 seconds.Batched-deliveries Webhooks  timeout allowance is the maximum of: 6 seconds, or, 1 second per event in the batch.  throttling limits still apply: 1 minute of webhook endpoint response time per minute per ShotGrid site, across all webhooks.Comparison of Webhook Delivery FormatsNon-batched-deliveries Webhook Message Body (always 1 delivery):{  &quot;data&quot;:{    &quot;id&quot;:&quot;119.110.0&quot;,    &quot;event_log_entry_id&quot;:479004,    &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,    &quot;operation&quot;:&quot;update&quot;,    &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},    &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1419},    &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:127},    &quot;meta&quot;:{      &quot;type&quot;:&quot;attribute_change&quot;,      &quot;attribute_name&quot;:&quot;code&quot;,      &quot;entity_type&quot;:&quot;Asset&quot;,      &quot;entity_id&quot;:1419,      &quot;field_data_type&quot;:&quot;text&quot;,      &quot;old_value&quot;:&quot;Cypress test asset for Webhooks deliveries&quot;,      &quot;new_value&quot;:&quot;Revised test asset for Webhooks deliveries&quot;    },    &quot;created_at&quot;:&quot;2021-02-22 17:40:23.202136&quot;,    &quot;attribute_name&quot;:&quot;code&quot;,    &quot;session_uuid&quot;:null,  },  &quot;timestamp&quot;:&quot;2021-02-22T17:40:27Z&quot;}Batched-Deliveries Webhook Message Body (may contain 1 to 50 deliveries)When batching is enabled, a deliveries key is always present, even if there is only 1 event in the batch. Its value is an array of individual event delivery data, where the information provided for each delivery is identical to un-batched mode.{  &quot;timestamp&quot;:&quot;2021-02-22T18:04:40.140Z&quot;,  &quot;data&quot;:{    &quot;deliveries&quot;:[      {        &quot;id&quot;:&quot;170.141.0&quot;,        &quot;event_log_entry_id&quot;:480850,        &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,        &quot;operation&quot;:&quot;update&quot;,        &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},        &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1424},        &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:132},        &quot;meta&quot;:{          &quot;type&quot;:&quot;attribute_change&quot;,          &quot;attribute_name&quot;:&quot;code&quot;,          &quot;entity_type&quot;:&quot;Asset&quot;,          &quot;entity_id&quot;:1424,          &quot;field_data_type&quot;:&quot;text&quot;,          &quot;old_value&quot;:&quot;Cypress test asset for Webhooks deliveries&quot;,          &quot;new_value&quot;:&quot;Revised test asset for Webhooks deliveries&quot;        },        &quot;created_at&quot;:&quot;2021-02-22 18:04:39.198641&quot;,        &quot;attribute_name&quot;:&quot;code&quot;,        &quot;session_uuid&quot;:null,      },      {        &quot;id&quot;:&quot;170.141.1&quot;,        &quot;event_log_entry_id&quot;:480851,        &quot;event_type&quot;:&quot;Shotgun_Asset_Change&quot;,        &quot;operation&quot;:&quot;update&quot;,        &quot;user&quot;:{&quot;type&quot;:&quot;HumanUser&quot;,&quot;id&quot;:24},        &quot;entity&quot;:{&quot;type&quot;:&quot;Asset&quot;,&quot;id&quot;:1424},        &quot;project&quot;:{&quot;type&quot;:&quot;Project&quot;,&quot;id&quot;:132},        &quot;meta&quot;:{          &quot;type&quot;:&quot;attribute_change&quot;,          &quot;attribute_name&quot;:&quot;description&quot;,          &quot;entity_type&quot;:&quot;Asset&quot;,          &quot;entity_id&quot;:1424,          &quot;field_data_type&quot;:&quot;text&quot;,          &quot;old_value&quot;:null,          &quot;new_value&quot;:&quot;Some other *description*&quot;        },        &quot;created_at&quot;:&quot;2021-02-22 18:04:39.212032&quot;,        &quot;attribute_name&quot;:&quot;description&quot;,        &quot;session_uuid&quot;:null,      },    ]  }}",
    "url": "/e7890fc8/",
    "relUrl": "/e7890fc8/"
  },
  "15": {
    "id": "15",
    "title": "Beyond Your First Project",
    "content": "Beyond your first projectHere, we explain where to go once you have got your first project up and running using the ShotGrid Desktop. It covers useful common questions and topics and lists useful documentation resources.Welcome to ToolkitWelcome to Toolkit! If you are reading this, it probably means that you have managed to successfully install your first ShotGrid Pipeline Toolkit Project using the ShotGrid Desktop.At this stage, we are hoping you are up and running and have something looking like the screenshot above, a project page with several application launchers. At this stage, try opening Maya, Nuke or any of the other Applications. You should find a ShotGrid menu with further functionality for managing files and assets.So where do you go from here? Toolkit offers a lot of flexibility in terms of its configuration and how it works. This document tries to cover some of the next steps that we recommend that you carry out once you are up and running with your first project using the ShotGrid Desktop.Basic ConfigurationThis section contains a collection of tweaks and useful things to configure. If you have just set up your very first Toolkit project, there are most likely a number of little tweaks and adjustments you need to do to get everything up and running properly. This section tries to explain these various steps. Please note that some of these things involve editing configuration files and going “under the hood” at the moment. If you have any questions about anything, please visit our support site for help.Setting up Application PathsOnce you have set up your first project and click one of the launch buttons to launch Maya, Motionbuilder or Nuke, it is possible that you see an error message looking something like this:In the toolkit project configuration, we store paths to the various executables that you can launch. If you are seeing the above message, it probably means that those paths are not matching your studio setup. You may also find that the wrong version of the application is being launched; for example, our default configuration may have a path to maya 2015 but your studio is running maya 2014. In this case, you also need to change the paths.In our default configurations, these paths are all stored in a single file called  paths.yml. In order to change a path, locate your project configuration on disk and then navigate into the config folder until you find the  paths.yml file:Open this file and make the necessary changes to the paths. Once you have saved the file, you need to leave the project inside of ShotGrid desktop and then click back into it. (but no need to restart the entire application).Further ReadingFor more information about applications, check out the following topics:  The Toolkit Application Launcher  Passing Commandline ArgumentsShotGrid IntegrationToolkit integrates with ShotGrid and extends the traditional interface by adding special toolkit action menu items to various parts of the UI:This offers a way to launch Toolkit applications or custom tools that operate on data directly from ShotGrid. You can learn more about integrating with your ShotGrid site in  the Browser Integration section of the Admin Guide.Adding Publishes to the ShotGrid UIOnce you have toolkit installed, it usually makes sense to make some minor adjustments to the ShotGrid UI layouts. The ShotGrid Pipeline Toolkit creates  Publish Entities when you publish a file, so it is handy to add a  Publishes Tab to key Assets such as Shot and Asset. To do this, make sure that you are logged in as an admin user. Start by navigating to an Asset or Shot and enter into  Design Mode:Now click the little menu triangle on one of the tabs, and select the  Add New Tab action. This will bring up a Dialog UI. Call the tab  Publishes and make sure that it is associated with  Published File Entities:Now click  Save to save your changes. You are all set!Note: ShotGrid will choose a couple of default fields to pull in when you create a new tab. You may want to add a couple of extra fields for publishes. This is done by clicking the little plus button in the top-right hand corner of the spreadsheet you can see under your new publishes tab. We recommend that you add the following fields:  Description - Holds a description of the changes in this publish  Created By - The user who created the publish  Date Created - When the publish was madeIf you make changes to your layouts, don’t forget to save the page afterwards!Multiple Operating SystemsIn some cases, you may be seeing a message popping up, informing that you  Python cannot be found with a link to this section of the documentation.Toolkit executes its scripts and functionality using a language called  Python. The ShotGrid Desktop comes with a complete Python installation built in, so normally you never need to worry about this. When you set up a new Toolkit project using the ShotGrid Desktop, the project will be set up by default to use the Python that comes bundled with the ShotGrid Desktop. However, sometimes you may explicitly have to tell Toolkit which Python you want it to use. This can happen in if you for example:  Use an older version of the ShotGrid Desktop which doesn’t set up all Python defaults automatically.  If you have installed the ShotGrid Desktop in a non-standard location on disk.  If you a running a manual or more complex Toolkit project setup.The path to Python is stored in configuration files which you can manually edit:In order to find the right file, first navigate to your project configuration. In there, find the tree files starting with  interpreter_. These contain the paths to the python interpreter for Linux, Windows and Mac (“Darwin”). These files contain the location of Python for each of the three operating systems. You now need to go in and manually add the python locations for any operating system you wish you use.If the files are blank, this indicates that you are using an older version of the ShotGrid Desktop. If this is the case, simply try to update the blank files with the default Python paths. They are as follows:  Macosx (Darwin):  /Applications/Shotgun.app/Contents/Frameworks/Python/bin/python  Windows:  C: Program Files Shotgun Python python.exe  Linux:  /opt/Shotgun/Python/bin/pythonIf you rather have installed the ShotGrid Desktop in a non-standard location or intend to use a custom python location, please ensure that the paths in the files point to a valid Python installation. It needs to be v2.6 or above (but not Python 3!). If you want to execute UI based applications and tools, please make sure that the Python you specify has either PyQt or PySide installed and is linked up to a QT v4.6 or higher.Please also note that in order to run Toolkit on multiple operating systems, you need to specify the paths to all your desired platforms when you are running the project setup wizard. If you haven’t done this, and want to add an additional operating system to a storage path or configuration location, please visit our support site for help.Next StepsHopefully at this point you now have the default ShotGrid setup working for a ShotGrid project (or test project). Applications are launching, Context menu actions and publishes are showing up in ShotGrid and things are working on all your desired operating system platforms.This next section is all about what to do next – the process of starting to take that default configuration and adjust it to work more like the rest of your studio pipeline. Toolkit is flexible and highly configurable, and we have lots of documentation. But before you get started, to see it all in action, we recommend spending a couple of minutes checking out our various walkthrough videos. These show the ShotGrid Pipeline Toolkit in action, how it works inside applications such as Maya and Nuke. It also goes through basic concepts such as publishing, version control, loading etc.The anatomy of a Toolkit ProjectWhen you create a new Toolkit project, you end up with a couple of key locations.  The ShotGrid Desktop and its configuration is installed on your local machine. (If you want, it is possible to relocate both the application and the configuration to a shared storage).  The data area where the Toolkit project will store textures, files, renders etc. This is normally on a shared storage, because you want to share this data with other users, however there are exceptions to this rule; user work areas can be stored on local (user only) storage, and integrations such as our perforce integration uses an external system to help distribute content.  The toolkit configuration is a fully self contained bundle, including code, apps, core API etc. This is normally stored on a shared storage so that the configuration is easily accessible by all users.Your Project configuration on disk contains a couple of different items.In the following sections we’ll walk through the various parts of the project configuration folder.Command line accessAs well as using the ShotGrid Desktop, you can also access Toolkit via a terminal or shell. Each project that you create on disk comes with a special  tank command which gives you command line based access to a lot of functionality, including starting up an API session and launching applications.If you navigate to your project configuration, you can see a  tank and a  tank.bat command in the root of the configuration. Running these commands without any options will give you a list of all the commands that are supported in your current configuration, including the following useful commands:  tank shell - Start an interactive python shell with tk api access  tank core - Check if there are any core API updates available for this project  tank updates - Check if any of the apps or engines in this configuration has got any updates availableFor more details on what you can do with the  tank command, please see the in-depth technical documentation:How to Administer ToolkitKey Configuration FilesThe  config folder contains a couple of key configuration files.Toolkit comes with a folder creation system which tries to automatically create folders on disk to make sure that when you start up an application, all the necessary structure on disk exists and has been prepared on beforehand! The configuration for this can be found in the  schema folder indicated above.Hand in hand with this goes the Toolkit  template system which makes it easy to define the various paths to files that you can configure; your publishes, work files, renders etc. This is stored in the  templates.yml file above.Together, these two parts of the project configuration makes it possible to adjust the various Apps that toolkit use to write out data to locations on disk which make sense are are understood by your existing pipeline.Read more about this in our advanced documentation:  Folder Configuration  Filesystem TemplatesA toolkit configuration is essentially made up of a collection of configured  apps and engines. This configuration is located in the  env folder. If the file system configuration files discussed above define  where resources should be located on disk, the environment configuration with its apps and engines define  what the pipeline is supposed to do.Core API platformEach project configuration uses a collection of Apps and Engines. The configuration for these apps and engines are stored in the  env folder inside the configuration. Toolkit will then automatically download and manage the various versions of the code needed to run these apps and engines. The code is placed inside the  installfolder.The configuration, apps and engines are all running on top of the Toolkit Core platform. For new projects, this is also stored inside the  install folder. Essentially, a project configuration is fully self contained - all the necessary pieces required to run toolkit are in a single place. This also means that each project is independent and updating one project will not break another.Tech Notes: Using a shared Toolkit Core (Click to expand)Further readingWe also have a more technical document that goes through the high level concepts in the ShotGrid Pipeline Toolkit and explains ‘bigger picture’ things. Once you have a good grasp of what Toolkit does out of the box, we recommend that you move on to this document to get a deeper undestanding of how Toolkit could be adjusted to suit your particular studio needs.An introduction to the high level concepts in the ShotGrid ToolkitThe Toolkit CommunityA part of Toolkit is its community of pipeline engineers and TDs! We are on a mission to create a vibrant, code sharing community where we all can help evolve Toolkit together to become a powerful and flexible pipeline environment.If you have any questions, or want to read through existing posts and conversations, please visit our community.",
    "url": "/c3b662a6/",
    "relUrl": "/c3b662a6/"
  },
  "16": {
    "id": "16",
    "title": "ShotGrid Desktop / browser integration fails to launch on Linux",
    "content": "ShotGrid Desktop / browser integration fails to launch on LinuxWhen running the ShotGrid Desktop on Linux for the first time, you may experience one of these error messages. If so, please follow the steps below for your specific error to see if that resolves things.If you’re still stuck, please visit our support site for help.Contents  OPENSSL_1.0.1_EC or HTTPSConnection related issues  libffi.so.5 related issues  Certificate validation failed related issues  Incompatible Qt versionsOPENSSL_1.0.1_EC or HTTPSConnection related issuesErrorsimporting '/opt/Shotgun/Resources/Python/tk-framework-desktopstartup/python/server/resources/python/dist/linux/cryptography/_Cryptography_cffi_36a40ff0x2bad1bae.so': /opt/Shotgun/Resources/Python/tk-framework-desktopstartup/python/server/resources/python/dist/linux/cryptography/_Cryptography_cffi_36a40ff0x2bad1bae.so: symbol ECDSA_OpenSSL, version OPENSSL_1.0.1_EC not defined in file libcrypto.so.10 with link time referenceAttributeError: 'module' object has no attribute 'HTTPSConnection'SolutionYou need to install OpenSSL. To do so, run the following command as an administrator:$ yum install openssllibffi.so.5 related issuesErrorBrowser Integration failed to start. It will not be available if you continue.libffi.so.5: cannot open shared object file: No such file or directorySolutionYou need to install libffi. To do so, run the following command as an administrator:yum install libffiIf you’ve installed libffi and it still doesn’t work, try creating the following symlink and then re-launching the ShotGrid Desktop:sudo ln -s /usr/lib64/libffi.so.6.0.1 /usr/lib64/libffi.so.5Some users have reported success with the above. Others still have issues. The latest version of ShotGrid Desktop added some additional dependencies with the web socket server which we’re currently looking into.Certificate validation failed related issuesPossible errorsBrowser Integration failed to start. It will not be available if you continue.Error: There was a problem validating if the certificate was installed. certutil: function failed: SEC_ERROR_BAD_DATABASE: security library: bad database.SolutionIf you have Google Chrome installed on your computer, launch it and then relaunch the ShotGrid Desktop. If you still have the issue, please visit our support site for help.If you don’t have Chrome, open a terminal and run the following command:ls -al $HOME/.pki/nssdbIf that search does not come up empty, please contact support and attach the contents of the following log file to your ticket:~/.shotgun/logs/tk-desktop.logIf the search did come up empty, then type the following:$ mkdir --parents ~/.pki/nssdb$ certutil -N -d &quot;sql:$HOME/.pki/nssdb&quot;Do not enter any password.Launching the ShotGrid Desktop should now work correctly.Incompatible Qt versionsPossible errorsCannot mix incompatible Qt library (version 0x40805) with this library (version 0x40807)SolutionOften this comes up because there is an override happening that ends up loading incompatible Qt libraries.You can try modifying your environment with this command to keep that from happening:unset QT_PLUGIN_PATH",
    "url": "/9207f027/",
    "relUrl": "/9207f027/"
  },
  "17": {
    "id": "17",
    "title": "I can't use local file linking and launch Toolkit applications from Chrome",
    "content": "I can’t use local file linking and launch Toolkit applications from ChromeOverviewSometimes in ShotGrid the action menu will not display the list of Toolkit applications available or will error when using local file linking, even with ShotGrid Desktop running. This is a guide to troubleshooting ShotGrid Desktop’s browser integration in Chrome and will hopefully help you get things working. We have a separate guide for Firefox.  Diagnosing the issue  How to quickly fix certificate issues  Fixing ERR_CERT_COMMON_NAME_INVALID or ERR_SSL_SERVER_CERT_BAD_FORMAT on all platforms  Fixing ERR_CERT_AUTHORITY_INVALID on WindowsDiagnosing the issueIs ShotGrid Desktop running?Yes, we know. You probably already checked. We had to ask. :)Have you restarted Chrome since ShotGrid Desktop started?If you have launched Chrome before allowing ShotGrid Desktop to register the certificate (this happens only the first time you launch ShotGrid Desktop and will not be an issue afterwards), Chrome will use an out of date copy of the certificates and will refuse to connect to ShotGrid Desktop. Closing all tabs will not necessarily close Chrome, so we recommend that you type chrome://restart in the address bar and hit enter. This will ensure that all Chrome related processes will be terminated and Chrome then restarted.Are you using firewall software?Ensure that no firewall software is preventing connections to localhost or on port 9000.Is Chrome rejecting the certificate?You can verify that Chrome accepts the certificate by browsing to https://localhost:9000. This is the address the ShotGrid website tries to access in order to do local file linking and launch Toolkit applications. You should normally be greeted by this message:On the other hand, if you are greeted by one of these messages, it means there was a problem with the certificate registration process:How to quickly fix certificate issuesThe easiest way to circumvent those issues is to click ADVANCED and Proceed to localhost (unsafe). This will let Chrome know that you are accepting the certificate nonetheless and will allow the ShotGrid website to communicate with ShotGrid Desktop.                    Note: This only enables the connection between your web browser and ShotGrid Desktop. The trust setting lets traffic flow between these two applications, it does not imply trust of any other server on the internet. Unfortunately, this process needs to be repeated on every single computer with the problem. If this doesn’t solve the issue or you feel it would be too complicated to deploy to all your users, we recommend you take a look at the following steps.                        Note: This step fix is not applicable to the ERR_SSL_SERVER_CERT_BAD_FORMAT error and you will need to regenerate the certificates, as outlined below.    Fixing NET::ERR_CERT_COMMON_NAME_INVALID and ERR_SSL_SERVER_CERT_BAD_FORMAT on all platformsChrome regularly upgrades its security around self-signed certificates and our browser integration is sometimes broken by these updates. Unfortunately, these sorts of issues can only be remediated by regenerating the certificate’s certificate_path.To regenerate the certificates, you can pick the Regenerate Certificates option under the Advanced section of ShotGrid Desktop’s user menu. (If you don’t see this option, please make sure you update the tk-desktop engine to unlock it.)After confirming that you want to regenerate the certificates, a series of dialogs will pop-up just like the first time you’ve generated the certificates. On Windows and macOS, you will be prompted to update the Windows Certificate Store or the macOS keychain twice: once to remove the old certificate and once to register the new one. On Linux, the registration is done silently. Once this is done, let ShotGrid Desktop restart.Once ShotGrid Desktop is back up and running, we recommend you restart Chrome by typing chrome://restart in the address bar to ensure that Chrome is completely shut down and that its certificate cache is cleared.If your computer is not connected to the Internet and can’t download the updates, please visit our support site for help.Fixing NET::ERR_CERT_AUTHORITY_INVALID on WindowsUnder certain circumstances, Windows will report that a certificate has been imported successfully, but will not make it available to applications requiring it. This can be validated by visiting the certificate dialog on Windows. To access it, hit the Windows key and type Internet Options. On the Internet Properties dialog, switch to the Content tab and then click on the Certificates button. Finally, click on the Trusted Root Certification Authorities and look for localhost.If the entry is missing, there is probably a group policy issue on your Windows domain or local computer. If it is present, we recommend you contact our support team.At this point, we recommend that you communicate with the person who administers the Windows computers for your organization and ask that person about any group policies that could have been set that instructs Windows not to trust self-signed certificates.Investigating Group Policy IssuesIf your computer is on a domain, the administrator can try out the steps detailed in this StackExchange post.If your computer is not on a domain, it is possible the computer has still been locked down by the administrator. For the following steps, you will need a Windows administrator account.Hit the Windows keys, type mmc and hit enter. This will launch the Microsoft Management Console. In the application, click on the File menu and select Add Remove Snap-In. This will show the Add or Remove Snap-ins dialog. On the left-hand side, search for Group Policy Object Editor and click Add &amp;gt;. A new dialog will appear, which you can dismiss by clicking Finish. Finally, click OK on the Add or Remove Snap-ins dialog.Finally, on the left-hand side of the main dialog, navigate to Local Computer Policy/Computer Configuration/Windows Settings/Security Settings/Public Key Policies. Once selected, double click Certificate Path Validation Settings in the central pane.On the next dialog, make sure that Define these policy settings is unchecked. If it is checked, make sure that Allow user trusted root CAs to be used to validate certificates (recommended) is checked. Once you’re done, click OK and the settings will be saved.At this point, you need to close all Chrome windows and restart Chrome. We recommend doing so with chrome://restart as we did above. This is required for the changes that have been made to take effect. Browsing to the certificates list should now show the localhost certificate.If you still encounter issues using the browser integration after these changes, or if the settings were correct in the first place, please contact our support team.Troubleshooting on other OSesIf you have issues with the ShotGrid Desktop integration on other OSes, please contact our support team so that we can assist you and update this article.",
    "url": "/95518180/",
    "relUrl": "/95518180/"
  },
  "18": {
    "id": "18",
    "title": "I can't use local file linking and launch Toolkit applications from Firefox",
    "content": "I can’t use local file linking and launch Toolkit applications from FirefoxOverviewSometimes in ShotGrid the action menu will not display the list of Toolkit applications available or will error when using local file linking, even with ShotGrid Desktop running.This is a guide to troubleshooting ShotGrid Desktop’s browser integration in Firefox and will hopefully help you get things working. We have a separate guide for Chrome.Diagnosing the issueIs ShotGrid Desktop running?Yes, we know. You probably already checked. We had to ask. :)Are you using firewall software?Ensure that no firewall software is preventing connections to localhost or on port 9000.Is Firefox rejecting the certificate?You can verify that Firefox accepts the certificate by browsing to https://localhost:9000, which is the address the ShotGrid website tries to access in order to do local file linking and launch Toolkit applications. You should normally be greeted by this message:On the other hand, if you are greeted by one of those two messages, it means there was a problem with the certificate registration process:How to fix “Your connection is not secure”You need to add an exception to the Firefox browser so that the certificate is accepted. If you just visited https://localhost:9000, the easiest way to add the exception is by clicking on Advanced, then click the Add Exception button. A dialog will appear.Click Get Certificate and then Confirm Security Exception. You can ignore the message about the certificate not being trusted. This is normal as the certificate was generated by ShotGrid Desktop and not by a certification authority.You should now be able to access local file linking and launch Toolkit applications from your ShotGrid site. If you are still experiencing issues after adding the exception, please visit our support site for help.How to fix “Secure connection failed”You need to click on the Open Menu button and pick Preferences. Then pick Advanced on the left hand side, Certificates and finally View Certificates.In the Servers section, click on any item and start typing localhost or simply scroll until you find an entry named localhost:9000. Delete it. Then, go to the Authorities tab and type localhost again. You can once again also scroll until you reach the Autodesk section with a localhost entry underneath. You can remove the localhost entry. Once this is done, click OK and restart Firefox. Once Firefox has been restarted, browse to https://localhost:9000. You should now be greeted by this message:At this point, you need to follow the step documented above to add an exception.If this is not the screen you are getting, please visit our support site for help.",
    "url": "/d4936105/",
    "relUrl": "/d4936105/"
  },
  "19": {
    "id": "19",
    "title": "Getting CERTIFICATE_VERIFY_FAILED when using {% include product %} Desktop on a local {% include product %} site",
    "content": "Getting CERTIFICATE_VERIFY_FAILED when using ShotGrid Desktop on a local ShotGrid siteUse cases:When using a local install of ShotGrid, this error can arise in two scenarios:  when logging in ShotGrid Desktop  when downloading media from the Toolkit AppStoreHow to fix:To solve this issue, you need to provide a file to the ShotGrid API that contains the list of all valid CAs, including your own. We usually recommend that people download a fresh copy of this file from Python’s certifi package as a starting point and then add their own CA at the end of the file. Then, save that file in a location all your users can access. Finally, on each computer, set the SHOTGUN_API_CACERTS environment variable to the full path to that file, for example /path/to/my/ca/file.pem.Doing this should solve any CERTIFICATE_VERIFY_FAILED errors you are getting with your local site. Note that if you are able to connect to your ShotGrid site, but are still unable to download updates from the Toolkit AppStore, that’s likely because you are missing the Amazon CAs in your .pem file. This usually happens if you’ve started from an empty file and only added your custom CAs instead of starting from something like the file we’ve linked to above.Note that this information only applies to local installs. If you have a hosted site and are experiencing this error, if it’s happening on Windows, take a look at this forum post. If it’s happening on a different OS, take a look at this document.Example of what’s causing this error:This problem usually arises because you’ve configured your local site to use HTTPS, but you haven’t configured Toolkit so that the certificate authority (known as CA from here on out) that you’ve used to sign your local site’s certificate is recognized.See the full thread in the community.",
    "url": "/413b6be4/",
    "relUrl": "/413b6be4/"
  },
  "20": {
    "id": "20",
    "title": "ShotGrid in the Cloud",
    "content": "ShotGrid in the CloudWhat is ShotGrid in the Cloud?ShotGrid Cloud is our default offering, hosted on AWS and built on top of Autodesk’s Cloud technology platform. ShotGrid Cloud is the latest generation of our hosted service and is completely cloud based.Further ReadingAdministration documentation can be found here.",
    "url": "/af35baf6/",
    "relUrl": "/af35baf6/"
  },
  "21": {
    "id": "21",
    "title": "Community Shared Integrations",
    "content": "Community Shared IntegrationsHere are projects that people in the Toolkit community have been gracious enough to share. They aren’t written by us at ShotGrid and we can’t vouch for them, but we’ll definitely answer any questions we can about them. If you have a project you want added to the list, please visit our support site for help.Engines            Integration      Engine      Information                        tk-katana      Project URL: https://github.com/robblau/tk-katana  Project Contributor:  Lightchaser Animation  Project Maintainer:   Project Description: A ShotGrid Engine for Foundry’s Katana                    tk-unreal      Project URL: https://docs.unrealengine.com/4.26/en-US/ProductionPipelines/UsingUnrealEnginewithAutodeskShotgun/  Project Contributor:  Epic Games  Project Maintainer:  Project Description: A ShotGrid Engine for  Unreal Engine                    tk-substancepainter      Project URL:  https://github.com/diegogarciahuerta/tk-substancepainter  Project Contributor:  Factor64  Project Maintainer: Diego Garcia Huerta  Project Description: A ShotGrid Engine for Adobe’s Substance Painter                    tk-substancedesigner      Project URL:  https://github.com/diegogarciahuerta/tk-substancedesigner    Project Contributor:  Factor64    Project Maintainer: Diego Garcia Huerta    Project Description: A ShotGrid Engine for Adobe’s Substance Designer    More info:  ShotGrid Community Forums                    tk-modo      Project URL: https://github.com/tremolo/tk-modo    Project Contributor: Lutz Pälike and  Walking The Dog    Project Maintainer:    Project Description: A ShotGrid Engine for Foundry’s Modo                    tk-clarisse      Project URL:  https://github.com/diegogarciahuerta/tk-clarisse  Project Contributor:  Factor64  Project Maintainer:  Diego Garcia Huerta  Project Description: A ShotGrid Engine for  Clarisse iFX, a fully interactive CG toolset for set-dressing, look development, lighting and rendering.                    tk-natron      Project URL:  https://github.com/diegogarciahuerta/tk-natron  Project Contributor:  Factor64  Project Maintainer:  Diego Garcia Huerta  Project Description: A ShotGrid Engine for  Natron, a free and open-source node-based software application.                    tk-harmony      Project URL:  https://github.com/diegogarciahuerta/tk-harmony  Project Contributor:  Factor64  Project Maintainer:  Diego Garcia Huerta  Project Description: A ShotGrid Engine for  Toon Boom Harmony, industry leading production animation software.                    tk-cinema      Project URL:  https://github.com/mikedatsik/tk-cinema  Project Contributor: Mykhailo Datsyk  Project Maintainer: Mykhailo Datsyk  Project Description: A ShotGrid Engine for  Maxon Cinema 4D, a designer-friendly toolset for modeling, animation, and rendering.  More Information:  ShotGrid Community Forums                    tk-krita      Project URL:  https://github.com/diegogarciahuerta/tk-krita  Project Contributor: Factor64  Project Maintainer: Diego Garcia Huerta  Project Description: A ShotGrid Engine for  Krita, a free and open-source raster graphics editor designed primarily for digital painting and 2D animation.  More Information: ShotGrid Community Forums                    tk-blender      Project URL:  https://github.com/diegogarciahuerta/tk-blender  Project Contributor: Factor64  Project Maintainer: Diego Garcia Huerta  Project Description: A ShotGrid Engine for  Blender, a free and open-source 3D computer graphics software toolset used for creating animated films, visual effects, art, 3D printed models, motion graphics, interactive 3D applications, virtual reality and computer games.  More Information: ShotGrid Community Forums      Apps            Integration      Engine      Information                        tk-maya-playblast      Project URL:  https://github.com/basestudio/tk-maya-playblast    Project Contributor: BASE Studio    Project Maintainer:    Project Description: App to publish playblasts from Maya. See https://goo.gl/5oJTv0                    tk-multi-renderfarm      Project URL: https://github.com/baitstudio/tk-multi-renderfarm    Project Contributor: Bait Studio    Project Maintainer:    Project Description: App to submit work to the farm. See https://goo.gl/ew6mkD                    tk-shotgun-publishrenders      Project URL: https://github.com/janimation/tk-shotgun-publishrenders    Project Contributor:    Project Maintainer:  Dave Sisk    Project Description: This app searches the directory structure of a project to find existing published files or file sequences, then registers them in ShotGrid as published files if the published file objects don’t already exist.                    nuke-getShotgunData      Project URL: https://github.com/RicardoMusch/nuke-getShotgunData    Project Contributor:  Ricardo Musch    Project Maintainer: Ricardo Musch    Project Description: Getting ShotGrid data into nuke text nodes can be a bit of a pain. This node can be used to pipe that info into slates, burn-ins, or anywhere else.                    sb-shotgun-schema-introspection      Project URL: https://github.com/scottb08/sb-shotgun-schema-introspection    Project Contributor:  Scott Ballard    Project Maintainer: Scott Ballard    Project Description: This is a simple Toolkit app that allows ShotGrid and Toolkit developers to quickly navigate and inspect the ShotGrid entities, fields and the underlying schema.                    foto-multi-namingconvention      Project URL: https://github.com/scottb08/foto-multi-namingconvention    Project Contributor:  Griffith Observatory    Project Maintainer: Scott Ballard    Project Description: This is a simple Toolkit app that allows ShotGrid and Toolkit developers to quickly navigate and inspect the ShotGrid entities, fields and the underlying schema.                    tk-cpenv      Project URL: https://github.com/cpenv/tk-cpenv    Project Contributor:  Dan Bradham    Project Maintainer: Dan Bradham    Project Description: This app adds support for  cpenv, a tool that uses modules to manage software plugins, project dependencies and environment variables.    More Information: ShotGrid Community Forums                    rtm-tk-hiero-shotgunDropper      Project URL: https://github.com/RicardoMusch/rtm-tk-hiero-shotgunDropper  Project Contributor:  Ricardo Musch  Project Maintainer: Ricardo Musch  Project Description: This app allows you to drop Versions and playlists from ShotGrid into Hiero.  More Information: ShotGrid Community Forums      ",
    "url": "/58a557ee/",
    "relUrl": "/58a557ee/"
  },
  "22": {
    "id": "22",
    "title": "Configuration Staging and Rollout",
    "content": "Configuration Staging and RolloutThis document explains best practices for how to safely roll out changes to your production pipeline. It explains how you can create a staging sandbox, which is a copy of your production configuration, update this sandbox and do testing and then finally push your changes to the production config.Please note that this document describes functionality only available if you have taken control over a Toolkit configuration. For the default setup, please see  ShotGrid Integrations Admin Guide.IntroductionThis document outlines how to manage your Toolkit configuration. Toolkit contains several utilities and tools that lets you safely manage your configuration and test upgrades and changes in a safe and sandboxed environment before rolling them out to the entire production.In this document, we’ll describe how to:  Safely upgrade the Toolkit Core API.  Upgrading your Apps and Engines.  Various ways to manage your config across multiple projects.  Go through Toolkit’s  Clone  and  Push  functionality that allows you to safely test upgrades and changes without disrupting production.  How to work with  git  source control and Toolkit.Basics of configuration managementEach Toolkit Project has one or more configurations associated with it. The configuration contains all the settings that the project needs, including file system locations (templates), engines apps, etc. In Toolkit, each project is independently configurable. This means that different projects can live side-by-side safely, and upgrading one project will not affect another.If you are working with a large number of projects, this may become cumbersome and we offer several ways to make this process easy, safe and streamlined.In ShotGrid, each project has a number of  Pipeline Configurations. When a project is first set up with Toolkit, a Pipeline Configuration called  primary  is created. The pipeline configuration entity in ShotGrid points at a location on disk where the Toolkit configuration can be found.During the course of a project, you often need to make changes to the configuration. This can be tweaks to the configuration, or perhaps you need to add additional apps or engines. We also release new app versions frequently and we recommend that you use the latest versions if possible.While it is possible to upgrade your  primary  project configuration straight away, this can be risky; since this configuration is used by everybody on the project, introducing a problem will affect everyone. A better approach is to create an isolated version of the configuration that a select group of people have access to. In this safe environment, upgrades, configuration changes and development can happen without impacting the rest of the production. Once the changes have been tested, they can be safely and confidently pushed to the primary configuration.This process is called  cloning  and means that you make a personal copy of the primary configuration that only you (and other people you invite) have access to the clone. In here you can make changes safely and once you are happy you can push these changes back to the primary configuration.Cloning your ConfigurationOnce you have set up Toolkit and configured a project, the setup will look something like this:There is a  studio  install which holds the Core API for all projects. This  studio  location also contains a  tank command and a Toolkit Python API you can use to access any of your Toolkit-enabled ShotGrid projects.In addition to this, there is a configuration folder for each project. This folder contains all the settings for that project. It also contains a  tank  command (and a Python API) which specifically operates on this configuration. When you are using this tank command or API code, you can strictly only operate on this configuration.When a new project is set up, a  Primary  configuration is created. This is the configuration that Toolkit will use by default for the project. In addition to the primary configuration, you can create additional configurations for a project. These can exist in parallel and are useful if you for example want to privately test some modifications, upgrade some apps or do development without impacting the entire team. Additional configurations are created by a process called  cloning, a process where a configuration is copied to a new location.Once you have cloned your configuration, your setup may look something like this:In addition to the studio level  tank  command and your primary project configuration  tank  command, you now have a new pipeline configuration which has its own  tank  command. If you run this  tank  command, you will operate exclusively on the configuration located in the staging sandbox. So if you want to test out some new things in Maya, you can simply navigate to your cloned sandbox, run  ./tank Shot xyz launch_maya  and the ShotGrid menu which appears in Maya will reflect the configuration inside of your staging sandbox rather than your Primary configuration.Note that the studio level  tank  command always uses the Primary config, so the only way to access a cloned configuration is by navigating to its location and using the  tank  command that is located in that folder. In ShotGrid, you can assign a specific set of users to a pipeline configuration entry, and any users that are associated with a configuration will now see menu entries appear in addition to those coming from the Primary config:Creating a Cloned ConfigurationIn order to create a staging sandbox where you can safely test your upgrades, navigate to the pipeline configurations for your project in ShotGrid and right click on the Primary configuration. An option to clone your configuration will appear:Once you click it, you’ll be presented with a dialog where you specify the path on disk where you want this new configuration to be located. If you are running a multi OS setup, make sure to put in paths for all relevant platforms.When you press ok, Toolkit will copy the configuration across and set up the clone. It will also associate your ShotGrid user with this configuration, so as soon as you have created your clone, you will see new menu items appearing inside ShotGrid.Pushing changes from your staging sandbox to PrimaryOnce you have applied the relevant updates and run any testing that you deem is necessary, you can push back your changes into the production configuration by executing the  tank push_configuration  command. This will transfer all the changes you have made in your staging sandbox to your Primary configuration.Please note that your current configuration is moved to a backup location when you run the push_configuration command. If you accidentally push or if there is a problem with the push, you can roll back simply by taking the content in the backup folder and copying into the config folder.By default, this command will copy a collection of files into the  config  folder in the target pipeline configuration. If you are using unix and would like a more atomic update, you can add a  --symlink  flag to the  push_configuration  command. This will turn the  config  folder in the target pipeline configuration into a symbolic link which makes it easier to upgrade without running the risk of having configuration mismatches in currently running sessions.Refreshing an old cloned configurationIf you have a old dev or staging sandbox set up, but it is out of date and you need to sync its contents with the latest production configuration, you do this by running the  push_configuration  command for the primary configuration:tank push_configurationWelcome to the ShotGrid Pipeline Toolkit!For documentation, see https://developer.shotgridsoftware.comStarting Toolkit for your current directory '/tmp'- Using configuration 'Primary' and Core v0.14.52- Setting the Context to Empty Context.- Running command push_configuration...----------------------------------------------------------------------Command: Push configuration----------------------------------------------------------------------This command will push the configuration in the current pipeline configuration('Primary') to another pipeline configuration in the project.Your existing configuration will be backed up.The following pipeline configurations are available to push to: - [324] Staging Sandbox (/my/staging/sandbox)Please type in the id of the configuration to push to (ENTER to exit): 324Hold on, pushing config...Checking if there are any apps that need downloading...Push Complete!Your old configuration has been backed up into the following folder:/my/staging/sandbox/config.bak.20140108_093218Note how we are pushing from the primary project config to the staging sandbox. We do this by running the  primary  configuration’s tank command. If you have multiple sandboxes set up, it is also possible to push data between those.Deleting a cloned configurationIf you want to delete a cloned configuration, simply delete the entry in ShotGrid and remove the folder from disk.Getting latest apps and enginesInside your staging sandbox (or in any other config), you can run the  tank updates  command in order to check if there are any app updates available. This command has got rudimentary filters that you can use if you only want to check certain areas of your configuration:----------------------------------------------------------------------Command: Updates----------------------------------------------------------------------This command will go through your current configuration and check if there areany updates available. If there are updates, you will be asked if you want toperform an upgrade. If settings has been added to the new version that you areinstalling, you may be prompted to specified values for these.Running this command with no parameters will check all environments, enginesand app. This may take a long time. You can also run the updater on a subsetof your installed apps and engines.General syntax:&amp;gt; tank updates [environment_name] [engine_name] [app_name]The special keyword ALL can be used to denote all items in a category.Examples:Check everything:&amp;gt; tank updatesCheck the Shot environment:&amp;gt; tank updates ShotCheck all maya apps in all environments:&amp;gt; tank updates ALL tk-mayaCheck all maya apps in the Shot environment:&amp;gt; tank updates Shot tk-mayaMake sure the loader app is up to date everywhere:&amp;gt; tank updates ALL ALL tk-multi-loaderMake sure the loader app is up to date in maya:&amp;gt; tank updates ALL tk-maya tk-multi-loaderUpgrading the Toolkit Core APIThis section explains how you can use a clone staging sandbox configuration to safely upgrade the Toolkit Core API. If you haven’t got a staging sandbox prepared yet, just follow the instructions in the previous section!If your staging sandbox was cloned from a pipeline configuration using a  shared studio Core API, you’ll want to update your sandbox to use it’s own unique Core API code. This is called “localizing” the core and can be done by navigating to your staging sandbox and running  tank localize. This command will copy the Core API from the studio install, into your sandbox, making it possible to run and test a different version of the Core API later on.The default behavior in Toolkit is to localize the core by default. If you haven’t explicitly created a shared studio core previously, it’s safe to assume your core is localized already.cd /my/staging/sandbox./tank localizeWelcome to the ShotGrid Pipeline Toolkit!For documentation, see https://developer.shotgridsoftware.comStarting Toolkit for your current directory '/my/staging/sandbox'- Using configuration 'Staging Sandbox' and Core v0.14.52- Setting the Context to Empty Context.- Running command localize...----------------------------------------------------------------------Command: Localize----------------------------------------------------------------------This will copy the Core API in /mnt/software/shotgun/studio into the Pipelineconfiguration /my/staging/sandbox.Do you want to proceed [yn]yLocalizing Core: /mnt/software/shotgun/studio/install/core -&amp;gt; /my/staging/sandbox/install/coreCopying Core Configuration Files...Localizing Apps: /mnt/software/shotgun/studio/install/apps -&amp;gt; /my/staging/sandbox/install/appsLocalizing Engines: /mnt/software/shotgun/studio/install/engines -&amp;gt; /my/staging/sandbox/install/enginesLocalizing Frameworks: /mnt/software/shotgun/studio/install/frameworks -&amp;gt; /my/staging/sandbox/install/frameworksThe Core API was successfully localized.Localize complete! This pipeline configuration now has an independent API. If you upgrade the API for this configuration (using the 'tank core' command), no other configurations or projects will be affected.Now we are no longer sharing the Core API with the studio location but are running our own, independent version. We can now go ahead and perform a standard Core API upgrade, again using our local tank command:cd /my/staging/sandbox./tank coreToolkit will check if there is a new version available and offer you to download and install it.Once you have updated the Core API, make sure to test the installation. Launch some apps, either using the tank command in the sandbox or using the special menu entries in ShotGrid. Do a basic run-through of your pipeline and perform the tests you deem necessary.Finally, once you are happy, it is time to go ahead and update the studio version of the Core API. Note that in the typical Toolkit setup, the Core API is shared between all projects, so by running the tank core command from your studio location  tank  command, you are updating the Core API for all projects.Managing the Project LifecycleEach Toolkit project contains an independent configuration which holds all the settings for that project. If you are managing a lot of projects, this means that you need to manage a lot of configurations. For this reason, Toolkit contains a number of different tools and ways to handle configurations, both for individual projects and for the studio lifecycle and configuration evolution. This section outlines some of those best practices and shows practical steps for how to set up your config.Depending on the needs of your studio, different levels of complexity may be relevant. Toolkit offers three different approaches and we’ll explain each one of them in detail:  The most straightforward approach is to copy the config from the previous project when you set up a new project. This is good if you are a small studio and don’t have a large number of projects.  If you have a higher project turnover and if you run more than one project in parallel, the next level of integration that we recommend involves git version control. Toolkit has native support for git and once you are up and running with a git-based workflow you have a single configuration for your studio and are tracking all the changes you are making to that configuration over time. Each project can safely pull in configuration changes as and when they need to.  If you are running a large-scale facility, it may be worth considering a setup where a single configuration is directly connected to all the currently-active projects in the studio. A single change to this configuration will have an immediate impact on all the projects.In the following sections we’ll describe the different approaches in detail.Inheriting the config from your previous projectThis is the simplest approach to configuration management. For the very first time you set up a project with Toolkit, you download our default configuration. You then set up that first project to match your pipeline settings, filesystem locations, etc. When the project is running, you run commands such as tank updates to update the app versions you are running.When your second project comes around, you don’t want to start with the default config again - instead, during the project setup phase, pick the config from your first project as the starter for your new project. This means that all the changes, tweaks and improvements you did for the first project will be taken advantage of in the second project as well. For the third project, use the second project’s config etc.This is a very simple way to gradually evolve the configuration over time. Changes and improvements will flow from project to project in an ad hoc fashion. The first time you run the setup_project command, just hit enter when the setup process prompts for the configuration to use. This will download and install the default configuration.For your second project, you will be presented with a list of paths to configurations for previous projects. Choose one of these paths and enter that when the setup process prompts for a config. This will copy that configuration to the new project:Welcome to the ShotGrid Pipeline Toolkit!For documentation, see https://developer.shotgridsoftware.com- Running command setup_project...----------------------------------------------------------------------Command: Setup project----------------------------------------------------------------------Welcome to the ShotGrid Pipeline Toolkit Project Setup!Connecting to ShotGrid...Connecting to the App Store...------------------------------------------------------------------Which configuration would you like to associate with this project?You can use the configuration from an existing project as a template for thisnew project. All settings, apps and folder configuration settings will becopied over to your new project. The following configurations were found:   My very first project: '/mnt/software/shotgun/first_project/config'If you want to use any of the configs listed about for your new project, justtype in its path when prompted below.You can use the Default Configuration for your new project.  The defaultconfiguration is a good sample config, demonstrating a typical basic setup ofthe ShotGrid Pipeline Toolkit using the latest apps and engines. This will beused by default if you just hit enter below.If you have a configuration stored somewhere on disk, you can enter the pathto this config and it will be used for the new project.You can also enter an url pointing to a git repository. Toolkit will thenclone this repository and base the config on its content.[tk-config-default]: /mnt/software/shotgun/first_project/configA studio configuration in git source controlLimitations with the first approach include the fact that the projects are not connected to each other. If you have 10 projects and you all need to update them because a critical bug fix has been released, you would have to manually go through each project and run the  tank updates  command.One way to resolve this is to create a master configuration and store it in git source control. Whenever you create a new project, simply type in the path to this git repository in the setup project dialog and Toolkit will clone it for you. Now all the projects are connected to the same “studio master” config. If you have made some good changes to a project configuration, you can commit them and push them to the studio master. Other projects can then easily pull these down. You also retain a history of all your changes via git.What is Git?The basic idea is that you set up a git repository which holds the git configuration. Whenever you run tank setup_project, you specify the git url to this repository (for example  username@someserver.com:/studio_config.git) and the setup process will clone the repository so that the new project becomes a repository connected to the main studio repository. Once they are connected you can push and pull changes, and work in branches for finer granularity.Setting up your studio config repositoryBefore you do anything else, you need to create a studio config repository. This section shows how to take an existing toolkit configuration and creating a git repository from that.First, you need to go to your git server and create a repository. This process may be different depending on your setup. If you are using something like GitHub, you would start a web browser and navigate to github.com. If you have access to the server you may do something like  git init --bare. In our example, we assume that the git repository you create is called  username@someserver.com:/studio_config.git.Now move the  config  folder of the project you want to use to seed your repo with into a  config.bak  location:cd /project_configs/studio_configmv config config.bakClone your initialized git repository into the  config  location of your project that you want to base the studio config on. Once you have run the clone command, you will have an empty  config folder  which is also a git repository:cd /project_configs/studio_configgit clone username@someserver.com:/studio_config.git configCopy all the files from your config.bak location back into the config folder. Once done, you can delete the empty config.bak folder. Your config files are now inside the git repository and we need to add them, commit them and push them to the server. But before doing that, we need to do some house keeping to handle some Toolkit system files correctly. In the  config  folder, create a  .gitignore  file and add the following lines to it:install_location.ymlpipeline_configuration.ymlNow git will ignore those two system files. We can go ahead and add the rest of the files in the configuration, commit them and push them to the studio repository.git add --allgit commit -am &quot;initial commit of our studio config!&quot;git pushCreating a new project from gitWhen you create a new project, simply specify a valid git url when the setup process prompts you to enter the path to the configuration to use. Following our example above, we would enter username@someserver.com:/studio_config.git. As part of the project setup process, Toolkit will clone this repository into the config folder of your new project configuration. This means that you can later on go into this config folder and run git commands. Note that any cloned pipeline configurations will also clone the git repository and will work seamlessly.Making changes to a projectWhenever you have made changes to your primary config, you can simply go to your config folder and then run git diff, git commit and git push. This would push your changes to the studio configuration that you cloned your project config from.Updating a project to have the latest versionAlternatively, if you have updated your studio level config with some changes and you want to pull those down to your project, just go to your config folder and run a git pull.  Important: Note that once you have done this, make sure you run a tank cache_apps to ensure that all the app versions that your changed config requires are present in the system!Advanced git usage: BranchesThe default behavior in Toolkit is a simple clone operation when a new project is created. The project will be using the git master branch. For a more advanced setup, if you for example want to keep certain configuration changes for a project private and don’t share them with other projects, you can set up a git branch after the project has been created. You then commit to this branch. The changes you want to push to the studio configuration can be merged with the local master branch for the project and then pushed.Advanced git usage: Batch deploymentSince Toolkit keeps a list of all the different configurations for a ShotGrid site via its pipeline configuration entity, it is possible to iterate over this list and execute a git pull command for each of the items, effectively running a batch update on all projects. This functionality is not currently part of Toolkit out of the box, but can be scripted using Python and the ShotGrid Python API.A global configuration using includesThe git based approach above handles independent project configurations which are connected via git: Updates are not automatically reflected across projects but will have to be pulled and pushed.For a fully centralized configuration, where the configuration truly resides in one place and where a single change immediately reflects a group of projects, you will need to make use of the  @include  functionality in the Toolkit configuration. This makes it possible to create references so that each project configuration points at a central location where the actual configuration is being kept.The  @include  syntax allows you to chain together multiple files. For example, if you have a file  /tmp/stuff.yml, which contains the following content:# paths to mayamaya_windows: 'C: Program  Files Autodesk Maya2012 bin maya.exe'maya_mac: '/Applications/Autodesk/maya2012/Maya.app'maya_linux: 'maya'# a configured toolkit appfile_manager:  allow_task_creation: true  file_extensions: []  hook_copy_file: default  hook_filter_publishes: default  hook_filter_work_files: default  hook_scene_operation: default  launch_at_startup: false  launch_change_work_area_at_startup: false  location: {name: tk-multi-workfiles, type: app_store, version: v0.4.8}  saveas_default_name: scene  saveas_prefer_version_up: false  sg_entity_type_filters: {}  sg_entity_types: [Shot, Asset]  task_extra_display_fields: []  template_publish: null  template_publish_area: null  template_work: null  template_work_area: nullAs you can see above, you can create include definitions at several different levels - in the case above, we have an app definition and three strings values. These can then be referenced from an environment file:includes: ['/tmp/stuff.yml']engines:  tk-maya:    # First all our app definitions    apps:         # normally, we would have the entire set of configuration parameters at this point.        # because we are using an include, we can reference an entire sub-section of configuration        # using the @ keyword:         tk-multi-workfiles: '@file_manager'        # alternatively, for simple values, we can use them as parameter values for apps:         tk-maya-launcher:          mac_path: '@maya_mac'          linux_path: '@maya_linux'          windows_path: '@maya_windows'          location: {name: tk-multi-launchapp, type: app_store, version: v0.2.19}    # and after the apps section follows specific configuration options for the engine    location: {name: tk-maya, type: app_store, version: v0.4.1}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: ShotGrid File Manager...}    template_project: null    use_sgtk_as_menu_name: falseFurthermore, you can read in several include files, one after the other. If the same include definition exists in two different files, the most recently read file will take precedence. We could extend our example environment above:includes:     # first include a global config file which contains all the studio level app definitions    - '/studio/configurations/studio_apps.yml'    # now we can include an include containing overrides, for example based on project type.    # if the global config contains an entry named file_manager and the vfx_apps.yml contains    # the same, the vfx_apps definition will be used.    - '/studio/configurations/vfx_apps.yml'engines:  tk-maya:        apps:         tk-multi-workfiles: '@file_manager'    location: {name: tk-maya, type: app_store, version: v0.4.1}    use_sgtk_as_menu_name: falseWith the approach just shown, it is possible to have a set of studio defaults which can be overridden by project type defaults which in turn can be overridden by specific project settings. You can either do it on the app level, as shown in the example above, or an engine level, as shown in the next section.Best practices when setting up a global configThere are several ways to set up a global configuration. Our recommended best practices approach for setting this up breaks the configuration down on a per engine basis. Each environment file is completely empty and references engines (and apps) defined in separate files. This makes it easy to tweak and reconfigure things - one engine at a time.Each of these include files are in a standard form, named after the engine. For example, if you have a Maya engine, an include file would contain just the engine and its apps. Its top level entry would simply be named  maya:maya:    apps:      tk-maya-breakdown:        hook_multi_update: default        hook_scan_scene: default        location: {name: tk-maya-breakdown, type: app_store, version: v0.2.13}      tk-multi-loader2:        action_mappings:          Maya Scene: [reference, import]          Photoshop Image: [texture_node]          Rendered Image: [texture_node]        actions_hook: '{self}/tk-maya_actions.py'        entities:        - caption: Assets          entity_type: Asset          filters:          - [project, is, '{context.project}']          hierarchy: [sg_asset_type, code]        filter_publishes_hook: '{self}/filter_publishes.py'        location: {name: tk-multi-loader2, type: app_store, version: v1.0.6}        menu_name: Load        publish_filters: []        title_name: Loader      [... additional app entries here ...]    debug_logging: true    location: {name: tk-maya, type: app_store, version: v0.3.10}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: ShotGrid File Manager...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}    - {app_instance: tk-multi-workfiles, name: ShotGrid Save As...}    - {app_instance: tk-multi-publish, name: Publish...}    template_project: shot_work_area_maya    use_sgtk_as_menu_name: false# each include file has a framworks section containing all the frameworks needed for# all apps in the fileframeworks:  tk-framework-shotgunutils_v1.x.x:    location: {name: tk-framework-shotgunutils, type: app_store, version: v1.0.8}In your studio, you most likely don’t have a single maya setup, but may have a number of different ones for different departments and types of things. We recommend that you set up a maya include file for each of these ones, organized in a file hierarchy. Each of these files has a top level  maya  entry just like the file above.Now each project will contain a number of environments. Each of these environment files will be a list of engine includes, linking that specific environment to a collection of engine and app setups. You can set up one (or several) default project configurations for your studio, all containing includes like this, thereby ensuring that the actual app and engine payload is completely contained within the include files and therefore global. If you make a change to your global include files, all projects will be affected. With this setup, your environment files will then be on the following form:includes:         - '/studio/configurations/maya/asset.yml'    - '/studio/configurations/nuke/asset.yml'    - '/studio/configurations/houdini/generic.yml'engines:  tk-maya: '@maya'  tk-nuke: '@nuke'  tk-houdini: '@houdini'# we don't need any frameworks here because there are no apps or engines definedframeworks: nullIf you wanted to break out of the above setup and start defining some project specific entries, you would simply replace  @maya  with a series of app and engine definitions in the environment file itself.Managing a global configurationManaging a global configuration is more involved than managing a normal one. Because you have effectively combined a number of projects into a single file structure, running the  tank updates  command from any project and choosing to update an app version will affect all other projects, so proceed with some caution here.Furthermore, the standard clone workflow won’t work out of the box, since what you are cloning is the project configuration, which now only contains includes.For safe testing and maintenance, we recommend storing the global configuration in source control (e.g.  git) and do updates in a separate test area with a special test project. Once the quality control passes, commit the changes and pull them down into the actual global configuration.",
    "url": "/60762324/",
    "relUrl": "/60762324/"
  },
  "23": {
    "id": "23",
    "title": "Configurations does not point to a valid bundle on disk!",
    "content": "Configurations does not point to a valid bundle on disk!Use CaseWhen installing ShotGrid Desktop for the first time, this error can be presented after a file path after opening a project.How to fixThe Pipeline Configuration entity for the project is pointing to ... ShotGrid Configurations path to the config on Windows. This is likely not the correct path, so as a first step, ensure that path exists or correct it.It’s also possible that you may be trying to access from a centralized set-up where you do not have access to that path location. In this case, switching to a distributed set-up will help.Related linksSee the full thread in the community",
    "url": "/84bb455b/",
    "relUrl": "/84bb455b/"
  },
  "24": {
    "id": "24",
    "title": "Connecting Your Studio With Your AWS VPC",
    "content": "Connecting Your Studio With Your AWS VPCYou can connect your studio networks with AWS using one of many options, described in detail in this Amazon Virtual Private Cloud Connectivity Options whitepaper.Some of the common options our clients have used include:VPN ConnectionUsing a VPN appliance - AWS-managed or client-managed - your studio can establish a secure connection between your data center (or offices) to your AWS private VPC.AWS Direct ConnectAWS Direct Connect creates a dedicated link between your studio and your AWS VPC. This will help segregate your studio’s network traffic to your private AWS VPC from general internet traffic.",
    "url": "/de0ef1a3/",
    "relUrl": "/de0ef1a3/"
  },
  "25": {
    "id": "25",
    "title": "Why is my context missing the Task/Step when it exists as part of the filename?",
    "content": "Why is my context missing the Task/Step when it exists as part of the filename?When you create folders via Toolkit it registers the path against the entity so that a lookup may be performed. This means that given a path, you can determine the correct context.Toolkit will only create registries for folders generated from the schema, and so it doesn’t consider things like file names or folders that were defined solely in the templates.yml file.If you don’t have a Task folder in your schema then you can get in a situation where Toolkit needs to know the task of the file but is unable to work out the task from the path alone.ExampleTake the default schema structure below; Asset and Step folders will be registered during the folder creation process:If you generated a file path using a template like this:assets/{sg_asset_type}/{Asset}/{Step}/work/maya/{task_name}_{name}.v{version}.{maya_extension}`And then attempted to figure out the context from that generated path, it would only be able to establish the Asset and the Step and not the Task despite the task’s name being in the file path.SolutionHaving a Step folder and no Task folder in your schema is fine for most workflows. Normally you would use the Workfiles app to open your scene file by selecting the task you want to work on and then selecting the file. The task you select in the UI is then used to drive the context rather than trying to figure it out from the path of the opened file.However, there are situations where it may be important to be able to get the context from a path such as:  Using our automatic context switching feature; this is a feature that allows Toolkit to detect when you open a file in a software’s native open dialog (rather than via the Workfiles app) and switch the current context accordingly.  Using the API in a standalone process where it needs to figure out the context for a given file.The solution in these situations would be to either introduce a Task folder into your schema or not use automatic context switching, or in the case of the API script, ensure that your process already has the required context information up front, to save it from having to do this lookup.",
    "url": "/a10dadb2/",
    "relUrl": "/a10dadb2/"
  },
  "26": {
    "id": "26",
    "title": "Contribution Guide",
    "content": "Contribution GuideIn our efforts to work as openly as possible, we have decided to build our developer documentation in a public repository under a Creative Commons license. If you see a way to make this documentation better, we would love to get a pull request for the repo with improvements. In order to accept a pull request, we need to have one of the following contributor agreements signed by you:  Individual Contribution Agreement  Corporate Contribution AgreementOnce you have submitted one of the above agreements, you can follow the instructions in the README on how to submit a change.",
    "url": "/92b042bd/",
    "relUrl": "/92b042bd/"
  },
  "27": {
    "id": "27",
    "title": "How do I modify my configuration to use multiple storage roots?",
    "content": "How do I modify my configuration to use multiple storage roots?The Default Configuration we provide is set up to use a single local storage root (i.e, all of your project files are stored underneath a single root point like /sgtk/projects). You may want to add a new storage root to store some of your project files. This is a common situation that arises when you’re running out of disk space or want some media to be on a faster storage, etc.Let’s say you want to add another root named “secondary”. Here are the steps you need to take:Add the local storage in ShotGrid  In ShotGrid, navigate to the Admin &amp;gt; Site Preferences page  Open up the File Management section  Click on [+] Add Local File Storage  Fill out the name (“secondary”) and the paths to the storage root on all of the relevant platforms. If you’re not using a particular platform, you can simply leave it blank.  Click on the Save Page button on the top or the bottom of the pageAdd the new root to your pipeline configurationToolkit caches information about the local storages used in a pipeline configuration in the config/core/roots.yml file. Edit this file to add the new secondary storage root you just created in ShotGrid:primary: {    linux_path: /mnt/hgfs/sgtk/projects,     mac_path: /sgtk/projects,     windows_path: 'z: sgtk projects'}secondary: {    linux_path: /mnt/hgfs/sgtk/secondaries,     mac_path: /sgtk/secondaries,     windows_path: 'z: sgtk secondaries'}                    Note: As of tk-core v0.18.141, the names of the roots defined in roots.yml do not need to match the names of the local storage defined in SG. You can explicitly define the connection by including a shotgun_storage_id: &amp;lt;id&amp;gt; key/value pair in your roots.yml definitions.Example:secondary: {    linux_path: /mnt/hgfs/sgtk/secondaries,     mac_path: /sgtk/secondaries,     windows_path: 'z: sgtk secondaries'    shotgun_storage_id: 123}The storage id is currently only queryable via an API call.    Modify your schema to use your new local storage rootNow that you’ve defined the new storage root and essentially told Toolkit about it, you need to decide how you’re going to use it in your directory structure. For this example, let’s assume you want all of your asset work to go in the secondary storage, and all of your shot work to go in the primary storage. You might setup your schema to look like the following in config/core/schema:config/core/schema/project.yml# the type of dynamic contenttype: &quot;project&quot;# name of project root as defined in roots.ymlroot_name: &quot;primary&quot;config/core/schema/secondary.yml# the type of dynamic contenttype: &quot;project&quot;# name of project root as defined in roots.ymlroot_name: &quot;secondary&quot;You will also need to modify any YAML files that reference the root in their filters.For example, if you had an asset.yml somewhere under your secondary folder, then you need to update the filters so that it filters the project against the secondary folder value.filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$secondary&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }Update your template paths to specify which root to useFinally you will update1 the paths defined in your config/core/templates.yml file to specify which storage root to use, and update any of the paths as necessary. Remember that your template paths are very good friends with your schema and they need to match up. If you have a template path defined that doesn’t match correctly with the path defined in your schema, you’ll run into errors.For example, since we want to have all of our asset work on the secondary storage, to update the maya_asset_work template path, we’d modify it to look like this:maya_asset_work:    definition: '@asset_root/work/maya/{name}.v{version}.ma'    root_name: 'secondary'You should follow this same pattern for each template path in your config/core/templates.yml file. Specify the correct root_name for each one (‘primary’ or ‘secondary’).                    Note: You do not need to specify a root_name for templates that use the default storage root. The default root is indicated by specifying default: true in the roots.yml file. If a default is not explicitly defined in roots.yml, the root named primary will be considered the default.    1 It is worth noting that updating the paths might not be ideal, since any old files that were created using the previous value will not be accessible by Toolkit once the new value is set (e.g. old work files won’t be found by Toolkit after changing their template path). If this is a concern, you may then create a new template (e.g. houdini_shot_publish_v2) with the new location and upgrade your apps to use that new version. Not all apps handle a fallback concept like this, but this will allow some apps to recognize the old files. This does not affect publishes, as these are always linked to their publish in ShotGrid.",
    "url": "/9ea9dd4e/",
    "relUrl": "/9ea9dd4e/"
  },
  "28": {
    "id": "28",
    "title": "Critical! Could not update ShotGrid with folder data.",
    "content": "TankError: Could not create folders on disk. Error reported: Critical! Could not update ShotGrid with folder data.Use CaseWe are using centralized configs and are adding Linux support for existing projects, but there are issues with the filsystem configuration.We already  added the corresponding roots to roots.yml  added a linux path in the pipeline configuration, install_location.yml, etc.  added linux paths for Software entitiesNow ShotGrid desktop starts successfully, but when trying to launch a program we get:TankError: Could not create folders on disk. Error reported: Critical! Could not update Shotgun with folder data. Please contact support. Error details: API batch() request with index 0 failed.  All requests rolled back.API create() CRUD ERROR #6: Create failed for [Attachment]: Path /mnt/cache/btltest3 doesn't match any defined Local Storage.Likewise, when trying to run tank folders and other commands, the same error is printed.I believe we have added linux paths in all places necessary. Is this a matter of synchronizing the database?tank synchronize_folders prints among other things.  The path is not associated with any ShotGrid object.How to fixUnder Site Preferences &amp;gt; File Management, add your Linux path to your Local storage in ShotGrid.Related linksSee the full thread in the community",
    "url": "/904fdaf9/",
    "relUrl": "/904fdaf9/"
  },
  "29": {
    "id": "29",
    "title": "How can I create publishes via the API?",
    "content": "How can I create publishes via the API?Our sgtk API provides a convenience method for registering PublishedFiles entities in ShotGrid.In addition we also have a Publish app, that comes with its own API. The Publish API ultimately uses the core sgtk API method to register the PublishedFile, but it also provides a framework around collection, validation, and publishing, which can be customizedIn addition to the the Publish API documentation, we have examples of writing your own publish plugins in our pipeline tutorial.Using the register_publish() API methodWhile it is possible to create publish records in ShotGrid using a raw ShotGrid API call, we would strongly recommend using Toolkit’s convenience method.All toolkit apps that create publishes are using a API utility method method called sgtk.util.register_publish().Basically, this method will create a new PublishedFile entity in ShotGrid and is trying to make that easy by using toolkit concepts. Your code would need to do something along these lines:# Get access to the Toolkit APIimport sgtk# this is the file we want to publish.file_to_publish = &quot;/mnt/projects/proj/seq_abc/shot_123/comp/foreground.v034.nk&quot;# alternatively, for file sequences, we can just use# a standard sequence token# file_to_publish = &quot;/mnt/projects/proj/seq_abc/shot_123/comp/renders/v034/foreground.%04d.exr&quot;# The name for the publish should be the filename# without any version number or extensionname = &quot;foreground&quot;# initialize an API object. If you have used the Toolkit folder creation # to create the folders where the published file resides, you can use this path# to construct the API object. Alternatively you can create it from any ShotGrid# entity using the sgtk_from_entity() method.tk = sgtk.sgtk_from_path(file_to_publish)# use the file to extract the context. The context denotes the current work area in Toolkit# and will control which entity and task the publish will be linked up to. If you have used the Toolkit# folder creation to create the folders where the published file resides, you can use this path# to construct the context.ctx = tk.context_from_path(file_to_publish)# alternatively, if the file you are trying to publish is not in a location that is# recognized by toolkit, you could create a context directly from a ShotGrid entity instead:ctx = tk.context_from_entity(&quot;Shot&quot;, 123)ctx = tk.context_from_entity(&quot;Task&quot;, 123)# Finally, run the publish command.# the third parameter (file.nk) is typically the file name, without a version number.# this makes grouping inside of ShotGrid easy. The last parameter is the version number.sgtk.util.register_publish(  tk,   ctx,   file_to_publish,   name,   published_file_type=&quot;Nuke Script&quot;,  version_number=34)There are several options you can populate in addition to the basic ones shown above. For a full list of parameters and what they do, see the Core API documentation.                    Tip: If your code is running from within a Toolkit app you can grab the sgtk instance via self.sgtk and the context with self.context.If it’s not in an app, but will be running within software where a Toolkit integration is present, you can access the current context and sgtk instance with the following code:import sgtkcurrentEngine = sgtk.platform.current_engine()tk = currentEngine.sgtkctx = currentEngine.context    ",
    "url": "/ed4bcc20/",
    "relUrl": "/ed4bcc20/"
  },
  "30": {
    "id": "30",
    "title": "How do I set up a desktop/launcher icon for ShotGrid Desktop on Linux?",
    "content": "How do I set up a desktop/launcher icon for ShotGrid Desktop on Linux?The current ShotGrid Desktop installer doesn’t automatically create shortcuts and launch entries, so you have to manually go in and do this afterwards. It’s straightforward and may differ depending on which flavour of Linux you are using.Once you have run the ShotGrid desktop installer, the ShotGrid Desktop executable will be located in the /opt/Shotgun folder. The name of the executable is ShotGrid.No icon is distributed with the installer. Download it from the ShotGrid Desktop engine github repository.Once you have downloaded the icon and have the path to the executable (/opt/Shotgun/Shotgun), please manually create any desktop or menu launchers you may require. The process for doing this varies depending on the version of Linux, but you can typically create a desktop launcher by right clicking on the Desktop and looking for a suitable menu option there.",
    "url": "/d82ab5ce/",
    "relUrl": "/d82ab5ce/"
  },
  "31": {
    "id": "31",
    "title": "Cross Project Workflow",
    "content": "Cross Project WorkflowBest PracticeCross Project workflows in ShotGrid allow you to re-use, share and work with Assets across multiple Projects. The most common method for re-using Assets is to use a single “Asset Library” project as the source Project. While we still recommend using a singular “Library” project to keep it simple, ShotGrid also allows you to link Assets across any active Project.There are two main ways to re-use Assets. The more nimble approach is to re-use a source asset “as is” (Direct Reference). However,  limitations or restrictions may be in place based on Projects and Pipelines—so copying the source Asset over into a project is also an option (Duplicating or Forking).  Direct Reference - Re-use a source Asset as is. If that asset changes, you can keep your Version or update to the latest Version.  Duplicating or Forking - Import the source Asset from another Project (breaking any connections to the source) to build on it or take control and save to your current Project.Cross Project / Library Project WorkflowThis tutorial will show you how to use ShotGrid Toolkit to re-use your Assets across multiple Projects and build up an Asset library that’s easily accessible for Artists in your studio. Let’s take you through the three main steps to get this up and running.  ShotGrid Assets linked across Projects - use the Linked Projects field to link between Assets and Projects  Loading/referencing Assets into Scenes - use a dynamic tab in the Loader  Keep Assets up to date - use the Scene Breakdown AppStep 1 - Linking AssetsThe first step to re-use an Asset is by making ShotGrid aware of what other Projects you would like to use the source Asset in.From the source Project that has the original Asset you’re re-using, navigate to the Assets page.Add the Linked Projects field to the Assets Page (if it’s not already visible). Then, specify Project you want to re-use the Asset in.See the detailed documentation here.Step 2 - Loading AssetsWith an Asset properly linked via the Linked Projects field, you can have a simple and dynamic tab in Loader to show your studios linked, re-used Assets. This helps Artist and creative teams easily re-use Assets across multiple Projects.Once the Asset is properly linked:  Launch your content creation software of choice (Maya, Houdini, Alias, etc.)  Set the context by opening or saving your working scene  Once your scene context is set, launch the Loader from the ShotGrid menu  Now, you will see the tab Assets - Linked which allows you to access Published Files for Assets across Projects.See the detailed instructions to add to this Tab to the Loader in your config here.From here, you can take advantage of your content creation software Loader actions to do things like Import—if you plan to duplicate or fork your asset breaking any connections to its source—or Reference the Asset for an ongoing connection to the current Version and all subsequent Versions of this Asset.Step 3 - Updating those assetsIf you choose to reference the Asset by keeping the connection to the source, you will likely want to see updates and changes to that source Asset. In this scenario, it’s common that another team may continue to iterate on the source Asset and you will need the latest Version.Using the Scene Breakdown 2 App in your config will enable you to see all the referenced items currently in your Scene. When any of these references get updated, the Scene Breakdown will show you the conflicts, share the Published File notes about what changed, and allow you to update to the latest Version or any other Version of the Published File.Note: The updating of Assets only applies when using an Advanced Configuration. If your studio uses a Basic Configuration, you will not have access to this Scene Breakdown App.",
    "url": "/0d2b28cd/",
    "relUrl": "/0d2b28cd/"
  },
  "32": {
    "id": "32",
    "title": "Launching Applications Using Custom Browser Protocols",
    "content": "Launching Applications Using Custom Browser ProtocolsContent  Registering a protocol          Registering a protocol on Windows      Registering a protocol on macOS      Registering a protocol on Linux      A very practical version of an Action Menu Item (AMI) is a variant that will run an application or a script on your local computer. For this to work you need to set up a connection between your browser and the script or application you wish to run. This link is called a custom browser protocol.You may want to set up a type of link where if a user clicks on it, it will launch the [foo] application. Instead of having ‘http’ as the prefix, you need to designate a custom protocol, such as ‘foo’. Ideally you want a link that looks like:foo://some/info/hereThe operating system has to be informed how to handle protocols. By default, all of the current operating systems know that ‘http’ should be handled by the default web browser, and ‘mailto’ should be handled by the default mail client. Sometimes when applications are installed, they register with the OS and tell it to launch the applications for a specific protocol.As an example, if you install RV, the application registers rvlink:// with the OS and tells it that RV will handle all rvlink:// protocol requests to show an image or sequence in RV. So when a user clicks on a link that starts with rvlink:// , as you can do in ShotGrid, the operating system will know to launch RV with the link and the application will parse the link and know how to handle it.See the RV User Manual for more information about how RV can act as a protocol handler for URLs and the “rvlink” protocol.Registering a protocolRegistering a protocol on WindowsOn Windows, registering protocol handlers involves modifying the Windows Registry. Here is a generic example of what you want the registry key to look like:HKEY_CLASSES_ROOTfoo(Default) = &quot;URL:foo Protocol&quot;URL Protocol = &quot;&quot;shellopencommand (Default) = &quot;foo_path&quot; &quot;%1&quot;The target URL would look like:foo://host/path...                    Note: For more information, please see http://msdn.microsoft.com/en-us/library/aa767914(VS.85).aspx.    Windows QT/QSetting exampleIf the application you are developing is written using the QT (or PyQT / PySide) framework, you can leverage the QSetting object to manage the creation of the registry keys for you.This is what the code looks like to automatically have the application set up the registry keys:// cmdLine points to the foo path.//Add foo to the Os protocols and set foobar to handle the protocolQSettings fooKey(&quot;HKEY_CLASSES_ROOT  foo&quot;, QSettings::NativeFormat);mxKey.setValue(&quot;.&quot;, &quot;URL:foo Protocol&quot;);mxKey.setValue(&quot;URL Protocol&quot;, &quot;&quot;);QSettings fooOpenKey(&quot;HKEY_CLASSES_ROOT  foo  shell  open  command&quot;, QSettings::NativeFormat);mxOpenKey.setValue(&quot;.&quot;, cmdLine);Windows example that starts a Python script via a ShotGrid AMIA lot of AMIs that run locally may opt to start a simple Python script via the Python interpreter. This allows you to run simple scripts or even apps with GUIs (PyQT, PySide or your GUI framework of choice). Let’s look at a practical example that should get you started in this direction.Step 1: Set up the custom “ShotGrid” protocolUsing Windows Registry Editor:[HKEY_CLASSES_ROOT ShotGrid]@=&quot;URL:ShotGrid Protocol&quot;&quot;URL Protocol&quot;=&quot;&quot;[HKEY_CLASSES_ROOT ShotGrid shell][HKEY_CLASSES_ROOT ShotGrid shell open][HKEY_CLASSES_ROOT ShotGrid shell open command]@=&quot;python&quot;&quot;sgTriggerScript.py&quot;&quot;%1&quot;This setup will register the ShotGrid:// protocol to launch the python interpreter with the first argument being the script sgTriggerScript.py and the second argument being %1 . It is important to understand that %1 will be replaced by the URL that was clicked in the browser or the URL of the AMI that was invoked. This will become the first argument to your Python script.                    Info: You may need to have full paths to your Python interpreter and your Python script. Please adjust accordingly.    Step 2: Parse the incoming URL in your Python scriptIn your script you will take the first argument that was provided, the URL, and parse it down to its components in order to understand the context in which the AMI was invoked. We’ve provided some simple scaffolding that shows how to do this in the following code.Python scriptimport sysimport pprinttry:    from urlparse import parse_qsexcept ImportError:    from urllib.parse import parse_qsdef main(args):    # Make sure we have only one arg, the URL    if len(args) != 1:        sys.exit(&quot;This script requires exactly one argument&quot;)    # Make sure the argument have a : symbol    if args[0].find(&quot;:&quot;) &amp;lt; 0:        sys.exit(&quot;The argument is a url and requires the symbol ':'&quot;)    # Parse the URL    protocol, fullPath = args[0].split(&quot;:&quot;, 1)    # If there is a querystring, parse it    if fullPath.find(&quot;?&quot;) &amp;gt;= 0:        path, fullArgs = fullPath.split(&quot;?&quot;, 1)        action = path.strip(&quot;/&quot;)        params = parse_qs(fullArgs)    else:        action = fullPath.strip(&quot;/&quot;)        params = &quot;&quot;    # This is where you can do something productive based on the params and the    # action value in the URL. For now we'll just print out the contents of the    # parsed URL.    fh = open('output.txt', 'w')    fh.write(pprint.pformat((protocol, action, params)))    fh.close()if __name__ == '__main__':    sys.exit(main(sys.argv[1:])) Note: This script is compatible with Python 3 and Python 2.Step 3: Connect the ShotGrid interface with your custom protocol and ultimately, your scriptFinally, create an AMI in ShotGrid whose URL value will be shotgrid://processVersion . You can assign this AMI to any entity type you wish, but this example uses the Version entity.Go to a Version page, right-click on a version and select your AMI from the menu. This should make your browser open a shotgrid:// URL which will be redirected to your script via the registered custom protocol.In the output.txt file in the same directory as your script you should now see something like this:('processVersion', {'cols': ['code',           'image',           'entity',           'sg_status_list',           'user',           'description',           'created_at'],  'column_display_names': ['Version Name',                           'Thumbnail',                           'Link',                           'Status',                           'Artist',                           'Description',                           'Date Created'],  'entity_type': ['Version'],  'ids': ['6933,6934,6935'],  'page_id': ['4606'],  'project_id': ['86'],  'project_name': ['Test'],  'referrer_path': ['/detail/HumanUser/24'],  'selected_ids': ['6934'],  'server_hostname': ['my-site.shotgrid.autodesk.com'],  'session_uuid': ['9676a296-7e16-11e7-8758-0242ac110004'],  'sort_column': ['created_at'],  'sort_direction': ['asc'],  'user_id': ['24'],  'user_login': ['shotgrid_admin'],  'view': ['Default']})Possible variantsBy varying the keyword after the // part of the URL in your AMI, you can change the contents of the action variable in your script, all the while keeping the same shotgrid:// protocol and registering only a single custom protocol. Then, based on the content of the action variable and the contents of the parameters, your script can understand what the intended behavior should be.Using this methodology you could open applications, upload content via services like FTP, archive data, send email, or generate PDF reports.Registering a protocol on macOSTo register a protocol on macOS BigSur and Monterey, you need to create an .app bundle that is configured to run your application or script.Step 1: AppleScript Script EditorFirst, start by writing the following script in the AppleScript Script Editor:on open location this_URL    do shell script &quot;sgTriggerScript.py '&quot; &amp;amp; this_URL &amp;amp; &quot;'&quot;end open location Debugging Tip: Catching an error and then displaying it in a popup will allow you to see if there were any issues executing the Python script without it erroring silently. Here is an example snippet that can be added to your AppleScript for a try on error:on open location this_URL	try		do shell script &quot;/path/to/script.py '&quot; &amp;amp; this_URL &amp;amp; &quot;'&quot;	on error errStr		display dialog &quot;error&quot; &amp;amp; errStr	end tryend open location   Note: To ensure you are running Python from a specific shell, such as tcsh, you can change the do shell script for something like the following: do shell script tcsh -c  &quot;sgTriggerScript.py '&quot; &amp;amp; this_URL &amp;amp; &quot;' &quot;. In the Script Editor, save your short script as an Application Bundle.Step 2: Edit the info.plist fileFind the saved Application Bundle, and Open Contents.Then, open the info.plist file and add the following to the plist dict:&amp;lt;key&amp;gt;CFBundleIdentifier&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;com.mycompany.AppleScript.ShotGrid&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;CFBundleURLTypes&amp;lt;/key&amp;gt;&amp;lt;array&amp;gt;&amp;lt;dict&amp;gt;&amp;lt;key&amp;gt;CFBundleURLName&amp;lt;/key&amp;gt;&amp;lt;string&amp;gt;ShotGrid&amp;lt;/string&amp;gt;&amp;lt;key&amp;gt;CFBundleURLSchemes&amp;lt;/key&amp;gt;&amp;lt;array&amp;gt;&amp;lt;string&amp;gt;ShotGrid&amp;lt;/string&amp;gt;&amp;lt;/array&amp;gt;&amp;lt;/dict&amp;gt;&amp;lt;/array&amp;gt;You can also change the following three strings (optional):com.mycompany.AppleScript.ShotGridShotGridShotGridThe third string is the protocol handler; therefore a URL would be:shotgrid://somethingIf using BigSur, you will need to delete the following lines in the info.plist file, which fall between the NSAppleEventsUsageDescription and NSSystemAdministrationUsageDescription. If you are using a version older than BigSur, skip this step and continue to step 3 below.	&amp;lt;key&amp;gt;NSAppleMusicUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your music to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSCalendarsUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your calendars to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSCameraUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your camera to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSContactsUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your contacts to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSHomeKitUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your HomeKit Home to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSMicrophoneUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your microphone to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSPhotoLibraryUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your photos to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSRemindersUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to your reminders to run.&amp;lt;/string&amp;gt;	&amp;lt;key&amp;gt;NSSiriUsageDescription&amp;lt;/key&amp;gt;	&amp;lt;string&amp;gt;This script needs access to Siri to run.&amp;lt;/string&amp;gt; Step 3: Move your .app bundle to the Applications folderFinally, move your .app bundle to the Applications folder of your Mac. Then double click on it—that will register your protocol with the operating system.The data flow looks like this: once you click the AMI in ShotGrid, or click a URL that starts with shotgrid:// , the .app bundle will respond to it and pass the URL over to your Python script. At this point the same script that was used in the Windows example can be used and all the same possibilities apply.                    Info: For additional information on troubleshooting with Monterey, visit this community post.    Registering a protocol on LinuxUse the following code:gconftool-2 -t string -s /desktop/gnome/url-handlers/foo/command 'foo &quot;%s&quot;'gconftool-2 -s /desktop/gnome/url-handlers/foo/needs_terminal false -t boolgconftool-2 -s /desktop/gnome/url-handlers/foo/enabled true -t boolThen use the settings from your local GConf file in the global defaults in:/etc/gconf/gconf.xml.defaults/%gconf-tree.xmlEven though the change is only in the GNOME settings, it also works for KDE. Firefox and GNU IceCat defer to gnome-open regardless of what window manager you are running when it encounters a prefix it doesn’t understand (such as foo:// ). So, other browsers, like Konqueror in KDE, won’t work under this scenario.See https://askubuntu.com/questions/527166/how-to-set-subl-protocol-handler-with-unity for more information on setting up protocol handlers for Action Menu Items in Ubuntu.",
    "url": "/af0c94ce/",
    "relUrl": "/af0c94ce/"
  },
  "33": {
    "id": "33",
    "title": "sgtk.env.project.tk-nuke.tk-multi-workfiles2 Failed to create File Open dialog!",
    "content": "data_handler_cache error message: ERROR sgtk.env.project.tk-nuke.tk-multi-workfiles2 Failed to create File Open dialog!Use case:It happens when launching an app like Nuke, tk-multi-workfiles2 File Open dialog fails with an error at the end of the stack trace about the get_children method of data_handler_cache failing to iterate because it’s been passed a string value when it’s expected a dict.The full stack looks something like:2020-12-07 09:42:03,571 [7192 ERROR sgtk.env.project.tk-nuke.tk-multi-workfiles2] Failed to create File Open dialog!Traceback (most recent call last):  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles work_files.py&quot;, line 115, in _show_file_dlg    self._dialog_launcher(dlg_name, app, form)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install core python tank platform engine.py&quot;, line 1822, in show_dialog    dialog, widget = self._create_dialog_with_widget(title, bundle, widget_class, *args, **kwargs)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install core python tank platform engine.py&quot;, line 1684, in _create_dialog_with_widget    widget = self._create_widget(widget_class, *args, **kwargs)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install core python tank platform engine.py&quot;, line 1658, in _create_widget    widget = derived_widget_class(*args, **kwargs)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles file_open_form.py&quot;, line 46, in __init__    FileFormBase.__init__(self, parent)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles file_form_base.py&quot;, line 64, in __init__    self._my_tasks_model = self._build_my_tasks_model()  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles file_form_base.py&quot;, line 134, in _build_my_tasks_model    bg_task_manager=self._bg_task_manager)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles my_tasks my_tasks_model.py&quot;, line 57, in __init__    bg_task_manager=bg_task_manager  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-multi-workfiles2 v0.11.8 python tk_multi_workfiles entity_models extended_model.py&quot;, line 74, in __init__    **kwargs  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-framework-shotgunutils v5.5.0 python shotgun_model shotgun_entity_model.py&quot;, line 70, in __init__    self._load_data(entity_type, filters, hierarchy, fields)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-framework-shotgunutils v5.5.0 python shotgun_model shotgun_model.py&quot;, line 367, in _load_data    self._create_item  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install core python tank log.py&quot;, line 503, in wrapper    response = func(*args, **kwargs)  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-framework-shotgunutils v5.5.0 python shotgun_model data_handler.py&quot;, line 266, in generate_child_nodes    for data_item in self._cache.get_children(unique_id):  File &quot;X: sgtk_studio _projects Endlings2 shotgun_configuration install app_store tk-framework-shotgunutils v5.5.0 python shotgun_model data_handler_cache.py&quot;, line 129, in get_children    for item in cache_node[self.CACHE_CHILDREN].itervalues():AttributeError: 'str' object has no attribute 'itervalues'What’s causing the error?Something has gone wrong in our caching, you should be able to fix it by removing the cache (see next section).How to fixFollow these instructions on where to find the cache and remove it. You can wipe the whole thing, though that will cause a delay when you restart Desktop next time while it downloads everything. It’s recommended that you wipe the folder named after your ShotGrid site that sits inside the root cache folder, there will still be a bit of rebuilding but not as much.See the full thread in the community.",
    "url": "/aaac055f/",
    "relUrl": "/aaac055f/"
  },
  "34": {
    "id": "34",
    "title": "Developer Overview",
    "content": "Developer OverviewPython APIShotGrid software provides a Python-based API for accessing ShotGrid and integrating with other tools. The API follows the CRUD pattern allowing execution of Create, Read, Update, and Delete actions on the ShotGrid server. Each request acts on a single entity type and depending on the specific action, can define filters, columns to return, sorting information, and some additional options.  Code Repository  Documentation  ForumsEvent Trigger FrameworkWhen you want to access the ShotGrid event stream, the preferred way to do so is to monitor the events table, get any new events, process them and repeat.A lot of stuff is required for this process to work successfully, stuff that may not have any direct bearing on the business rules that need to be applied.The role of the framework is to keep any tedious monitoring tasks out of the hands of the business logic implementor.The framework is a daemon process that runs on a server and monitors the ShotGrid event stream. When events are found, the daemon hands the events out to a series of registered plugins. Each plugin can process the event as it wishes.  Code Repository  DocumentationAction Menu Item FrameworkAPI developers can customize context menu items on a per-entity basis. For example, from a Versions page, you could select multiple versions, right-click, then…. Build a PDF Report (for example). We call these ActionMenuItems (AMI’s).  Documentation  Example Code Repository",
    "url": "/1e047003/",
    "relUrl": "/1e047003/"
  },
  "35": {
    "id": "35",
    "title": "Developing",
    "content": "DevelopingA collection of quick answers based around development with Toolkit.  How do I set environment variables before launching software?  How do I work with authentication and login credentials in custom scripts?  as_template_fields() is missing values that exist in my context  How do I add a shelf button to launch a Toolkit app in Maya?  How can I load different Toolkit Core modules using the shotgunEvent daemon?  How do I update my Toolkit config programmatically with the API?  How can I create publishes via the API?",
    "url": "/16654f1f/",
    "relUrl": "/16654f1f/"
  },
  "36": {
    "id": "36",
    "title": "Development",
    "content": "DevelopmentWhat is Toolkit?Toolkit is the platform that underpins our pipeline integrations. For example, If you are using the ShotGrid Panel app in Maya or launching the Publish app from ShotGrid Create, you are using tools built upon the Toolkit platform.How can I develop with Toolkit?There are a number of different ways in which you can develop with Toolkit.  Writing custom code, in what we call hooks, to expand the existing app, engine, or framework behavior.  Writing your own apps, engines or frameworks.  Or writing your own standalone scripts that make use of the API.To do any of these things it’s important to understand how to work with the Toolkit API.ShotGrid as a whole has three main API’s  ShotGrid Python API  ShotGrid REST API  ShotGrid Toolkit APIThe Toolkit API is a Python API, designed to be used alongside the ShotGrid Python API or REST API, and is not a replacement for them.Although the Toolkit API does have some wrapper methods, in general whenever you need to access data from your ShotGrid site you will use the ShotGrid Python or REST APIs instead.The Toolkit API instead focuses on the integrations and management of file paths.Some Toolkit apps and frameworks also have their own APIs.These articles will guide you through how you can develop with Toolkit.",
    "url": "/a1cfe87c/",
    "relUrl": "/a1cfe87c/"
  },
  "37": {
    "id": "37",
    "title": "Direct Connect",
    "content": "Direct ConnectAWS Direct Connect is a service from AWS that allows you to establish a dedicated connection from your on-premise data center (or offices) to AWS. Direct Connect will allow you to create a dedicated link between your network and one of the AWS Direct Connect locations.Leveraging AWS Direct Connect ensure that you will benefit from the best experience possible when using the isolation feature set, optimizing reliability and performance for all your access points across the globe.",
    "url": "/0de47d40/",
    "relUrl": "/0de47d40/"
  },
  "38": {
    "id": "38",
    "title": "ShotGrid AWS Direct Connect Onboarding",
    "content": "ShotGrid AWS Direct Connect OnboardingIntroductionAWS Direct Connect (DX) is used to establish private connectivity between AWS and an on-prem facility. DX provides a private, high bandwidth network connection between your network and AWS Virtual Private Cloud (VPC) and bypasses the public internet. AWS has established 100 Direct Connect locations globally and leverages the AWS Partner Network to extend the footprint.Review of Shogun Configuration in AWSCustomer Types  Customer already has AWS Direct Connect dedicated connection  Customer has equipment and network presence in an AWS Direct Connect location  Customer does not have equipment or presence in an AWS Direct Connect locationSetup Options  Request a dedicated Direct Connect connection through AWS Console          Provision the required connectivity yourself      Work with Direct Connect Partner to help establish a dedicated connection to AWS equipment        Request a hosted Direct Connect connection through AWS Direct Connect PartnerCriteria to Determine Setup PathIf you answer “yes” to the following, then request a dedicated Direct Connect connection through the AWS Console (Option 1a):  Do you already have equipment and presence in an AWS Direct Connect location?  Do you know the process for requesting a cross-connect within the Direct Connect location facility?  Are you looking for any one of the following - 1Gbps, 10Gbps port, or a dedicated connection?If you answer “yes” to the following, then request a dedicated Direct Connect connection through the AWS Console and select a Partner to assist (Option 1b):  Are you planning to use AWS Direct Connect to connect to other AWS resources outside of ShotGrid?  Do you have the time and resources to complete the setup?  Are you looking for any one of the following - 1Gbps, 10Gbps port, or a dedicated connection?If you answer “yes” to the following, then you should work with an AWS Direct Connect Partner to request a hosted Direct Connect connection (Option 2):  Are you already working with an AWS Direct Connect Partner?  Do you want a Partner to facilitate the setup?  Are you looking for a port less than 1Gbps or a hosted connection?Disclaimer:  All options are valid and the criteria are just a guide to help simplify the selection process. You can still pick any option based on more specific criteria.Setup DirectionsRequest through AWS Console - Option 1 (a and b)  Create a Connection in the AWS Console  Download the LOA-CFA. The LOA is the authorization to connect to AWS and is required to establish the cross-network connection.  (Option 1a only) Request cross-connects at AWS Direct Connect locations. Find contact information here.  (Option 1b only) Reach out to an AWS Partner and share the LOA with them.  Once the dedicated connection is provisioned into your account, set up logical connectivity (Virtual Interfaces).Request through AWS Direct Connect Partner - Option 2  Reach out to an AWS Partner. The criteria for choosing an AWS Partner are:          AWS Region      Providers      If you are already working with an AWS Direct Connect Partner        If hosted connection, accept a hosted connection. More information can be found here.  Once the hosted connection is provisioned into your account, set up logical connectivity (Virtual Interfaces).FAQHow long should it take to set up AWS Direct Connect?Short Answer - It depends. A lot of factors go into the time it takes to set up AWS Direct Connect. The timeline can vary from a few days to a few months. Some of the factors include current infrastructure, location of equipment, providers, partners, and more. If you are looking to expedite the process, consider using an AWS Direct Connect Partner who is geographically nearby.Further questions about AWS Direct Connect?AWS Direct Connect FAQsVPNA site-to-site VPN can be used as an alternative to AWS Direct Connect. Learn more about AWS VPN here.AWS Documentation &amp;amp; Resources  What is AWS Direct Connect?  Direct Connect User Guide  re:Invent 2018 - 400 level Deep Dive on Direct Connect  AWS Direct Connect Locations  AWS Direct Connect Partners",
    "url": "/8233001e/",
    "relUrl": "/8233001e/"
  },
  "39": {
    "id": "39",
    "title": "How can I disable ShotGrid Desktop's browser integration?",
    "content": "How can I disable ShotGrid Desktop’s browser integration?To disable browser integration, follow these two simple steps.      Create or open the text file at:     Windows: %APPDATA% ShotGrid preferences toolkit.ini Macosx: ~/Library/Preferences/ShotGrid/toolkit.ini Linux: ~/.ShotGrid/preferences/toolkit.ini            Add the following section:     [BrowserIntegration] enabled=0      See complete instructions on how to configure the browser integration in our Admin guide.Alternate methodIf you’ve taken over your Toolkit pipeline configuration, an alternative would be to remove the tk-ShotGrid engine from your environments so that it can’t load any actions.",
    "url": "/1bb3f6ad/",
    "relUrl": "/1bb3f6ad/"
  },
  "40": {
    "id": "40",
    "title": "Filesystem configuration",
    "content": "Dynamic filesystem configurationIn this guide, you will learn how to modify your Toolkit pipeline configuration to customize your production folder structure and file naming.About the guideOne of the hardest things about managing a pipeline is keeping track of the myriad files that will be created. Your Toolkit pipeline automates filesystem management: by creating folders based on data in ShotGrid and a configured folder structure, and automatically writing files to the right place and with standardized naming, artists can focus on content creation. Your pipeline configuration comes with a default set of folder and file naming conventions, but productions often customize them. This guide will provide the knowledge necessary to make those customizations.In the Default Configuration, assets are managed in a folder structure like asset_type/asset/pipeline_step. In this guide, we’ll be using a custom entity called “Set” to organize them further by the production set on which each asset is used. We will first set up the custom entity in ShotGrid, then use it to manage the assets created for any given set, so that the folder structure looks like set/asset_type/asset/pipeline_step.We can demonstrate the idea behind organizing assets by set with an example: say you have a project where some scenes take place in a garage, while others take place in a dining room. With our setup, files for assets like “wrench”, “oilcan”, or “workbench” would be organized in a “garage” folder, while “plate”, “winebottle”, or “tablecloth” would be organized in a “dining_room” folder. In our example, we’ll be ensuring that a juicy “filet” asset is properly placed in the dining room.As part of our example, we’ll also edit the filenaming templates for the project, such that Maya work files for assets will include the set in their name. The dynamically generated name of the file will distinguish files for the dining room from files used in other sets.There are three parts to this guide  Creating a custom entity in ShotGrid called “Set”, which you will use to associate with the dining room elements the artists are creating.  Editing the folder schema, enabling Toolkit to include a dynamically named folder based on the current set in the folder structure.  Editing the template used for naming asset work files, enabling Toolkit to include the name of the associated set in the file name.PrerequisitesTo use this guide, the following is required:  An active ShotGrid site. You should have a project with at least one Asset created. The asset should have a Model task.  A basic understanding of how a ShotGrid site is used to manage assets  ShotGrid Desktop installed on your system.  A cloned pipeline configuration for the identified project, or complete the Getting started with configurations guide and clone the configuration created in that exercise.  Basic familiarity with YAML.  Read and write permissions set appropriately for the filesystem where the Pipeline Configuration is stored.  Read and write permissions set appropriately to allow Toolkit to read and write to the production filesystem.  An active subscription for Maya. Get a 30 day trial of MayaThis guide is based on the tk-config-default2 pipeline configuration. If your config was modified, the location of files, folders, and blocks of YAML settings may vary from what is described here.About file schemas and templatesThe schema and templates in the Toolkit pipeline configuration allow you to take advantage of your ShotGrid data for managing production files on disk. The schema in the Default Configuration includes entities like Shot, Sequence, Asset, Asset Type, etc.  Other entities like Level, Episode, Season, or in our case, custom entities like Set can be added.The Toolkit platform allows you to build your folder structure dynamically by using a schema, a miniature version of a production folder structure that will be used as a template when building out your actual production filesystem. The schema is an explicit guide for the dynamic creation of folders, and uses YAML files to define the rules for dynamically created folders. The Default Configuration includes a pre-configured schema that supports folder creation for both asset and shot pipelines. You will be modifying the portion of the schema that supports creating the asset folder structure, /assets/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt;, to add support for the new Set entity you’re creating.Templates allow you to dynamically name and save files as they’re created using ShotGrid data and information from the schema structure. The Default Configuration provides a set of starter templates that you can edit to meet the needs of your pipeline.The Basic setup for ShotGrid integrations doesn’t include filesystem management. In order to configure filesystem management for your project, your project will need an Advanced setup. The first guide, Getting started with configurations goes through the Advanced setup process.Begin exerciseCustomizing your schema and templates will allow you to dynamically manage the files generated when creating the dining room set: a place setting, a steaming hot filet mignon, a bottle of Penfolds Grange Hermitage 1951, potatoes au gratin, lemon garlic asparagus, etc. Assets used in the dining room set will be associated with the “Dining Room” Set entity enabling you to manage them more easily. Set is not an entity type that comes standard with the Default Configuration, so you need to enable a custom entity and call it Set before extending the schema and templates to use it.Enabling a custom entityStep 1: Open your ShotGrid site in the browser. Click on your avatar and go to ADMIN &amp;gt; Site Preferences. In the resulting page, expand the Entities section.Displayed is a list of entity types that are available in ShotGrid. At the top of the list in the image below are some entity types that are configured for the current ShotGrid site. Underneath these entity types are several Custom Entities that are not configured or enabled.Choose one of the custom entity types, configure it, and enable it.Step 2: Select the arrow to open the settings on a grayed out disabled custom entity. Select the radio button next to Yes, use Custom Entity…, change the Display name to Set then scroll to the top of the window and select Save Changes.Doing this makes that custom entity active in ShotGrid and gives it the display name Set. Essentially you are creating an alias for the custom entity because the system name of the entity remains CustomEntity01. In this example, we’re using CustomEntity01; you might use a different custom entity.Remember the system name of the custom entity you chose.Add a data field to associate assets with setsAdding a data field to the Asset entity enables us to link assets to the new entity. The assets the artists create for the dining room will be associated with the Dining Room set entity.Step 3: Select the Projects dropdown at the top of the page to open the project you want to use for this exercise.Step 4: Select Assets in your project menu bar to go to an Assets page. In the Assets menu, select Fields &amp;gt; Manage Asset Fields…This action displays the asset field manager.Select + Add a new fieldSelect the parameters for the new field.In New Field Name, type “Set”. In the GENERAL menu under Field Type, select Entity and scroll down to Restrict the type to Set. Select Next.For this guide, apply it to Only the current project and select Create Field.ShotGrid will configure the new field.Your change has been applied and you can select Done.Creating the Dining Room Set entityStep 5: Select the new Set field of an asset and start typing Dining Room. A dialog box is displayed stating, No matches found. Create “Dining Room”Select Create “Dining Room”.Select Create Set.Adding Dining Room in the Set field of an asset creates an association with the Dining Room set entity.Step 6: Assign the Model task on the filet asset to yourself, so you can find it easily for testing purposes.Setting up the schemaYou’ve now enabled a Set custom entity, created a Set entity called “Dining Room”, and linked an Asset entity to the Dining Room set. You’ve got all the pieces in place in your ShotGrid site to now modify your folder structure. When an artist starts working on a task, Toolkit uses the associated ShotGrid data to determine what folders to create in the filesystem. New folders are created and named automatically based on the pipeline configuration’s schema.Now it’s time to define the folder structure you want Toolkit to dynamically generate as artists step through the production pipeline. This is done by editing the schema.It’s a good practice to test configurations in a cloned configuration, so as not to affect the active production configuration. The cloning process creates a copy of the configuration that you can edit safely before pushing changes to the live config. You can find details on cloning your config in the Configuration Staging and Rollout document.”Step 7: Navigate to your pipeline configuration. Drill down to the schema folder, &amp;lt;pipeline_configuration_root&amp;gt;/config/core/schema and open the project folder.The current schema, which looks like this:&amp;lt;project&amp;gt;/assets/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt;supports dynamically creating this folder structure:the_other_side/assets/prop/filet/modelWe want the following structure instead:the_other_side/assets/Dining-Room/Prop/filet/modelTo achieve this, you would set up the schema like this:&amp;lt;project&amp;gt;/assets/&amp;lt;CustomEntity01&amp;gt;/&amp;lt;asset_type&amp;gt;/&amp;lt;asset&amp;gt;/&amp;lt;step&amp;gt;The Set entity is represented as CustomEntity01. While we gave CustomEntity01 the display name of Set in ShotGrid, in our configuration, we’ll always refer to it by its system name, CustomEntity01.How the schema uses YAML filesA schema can contain static and dynamic folders. If you have a static folder in your schema called “assets”, it will correspond to a single folder in your production filesystem called “assets”. On the other hand, you might have a dynamic folder in your schema named “asset” that represents one folder for each asset in your project. Every dynamic folder has a corresponding YAML file next to it with the same name as the folder (eg, asset/ and asset.yml) that defines the rules for how to generate production folders based on the schema folder.Create the new folder and YAML file for the Set entityThe schema has a project folder that contains folders relative to the different entities ShotGrid tracks. You are adding the new asset entity, CustomEntity01, to enable ShotGrid to track the items in a Set. These items are assets, so you will edit the folders and YAML files under assets.Again, our goal is to go from an asset_type/asset/step folder structure to set/asset_type/asset/step. So, we’ll want to add a folder to represent set in our schema, with a corresponding YAML file. Since we need to use the system name for custom entities, we’ll be creating the CustomEntity01/ folder and CustomEntity01.yml.Step 8: Add a CustomEntity01 folder inside the project/assets folder of your schema.Step 9: Create a file called CustomEntity01.yml file next to the CustomEntity01 folder, with the following contents:type: &quot;shotgun_entity&quot;name: &quot;code&quot;entity_type: &quot;CustomEntity01&quot;filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }The YAML file will give the instructions to Toolkit for what to name the CustomEntity01 folder. In this case, we’re making a folder of type ShotGrid_entity, which means that it corresponds to a ShotGrid query. The entity_type field tells us to query the CustomEntity01 entity in ShotGrid, and the name field tells us which field on the entity to query – in this case we’re getting the code field from CustomEntity01.The filters field limits the cases in which this dynamic folder should be created.Step 10: Move asset_type/ and asset_type.yml into the CustomEntity01 folderAs we want our folder structure to look like Dining-Room/Prop/filet, the asset_type folder should be below the CustomEntity01 folder in our hierarchy. Move asset_type/ and asset_type.yml into the CustomEntity01 folder.Edit the asset.yml fileThe filters field limits which entities have folders created for them at a given time. In its current state, the filters field in asset.yml looks like this:filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }When we decide to make a folder for an asset, we want to make sure that we’re in the correct project folder, and in the correct asset_type folder. Now that we’ve added a set folder, we’ll want to add a third filter. Without it, we’d end up with folders like the following, which of course would be incorrect:assets/Dining-Room/Prop/spoonassets/Garage/Prop/spoonassets/Classroom/Prop/spoonTo prevent that, we’ll add a third filter, which will ensure that an asset’s folder will only be created in the correct set’s folder.Step 11: Modify the filters field in asset.yml to look like this:filters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }    - { &quot;path&quot;: &quot;sg_set&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$CustomEntity01&quot; ] }Test folder creationYou’ve now successfully modified your schema to organize assets by a Set custom entity. Now,  let’s test it out.Folders are created at a few points in Toolkit pipeline workflows:  Application launchers: Every time a user launches a DCC for a task, Toolkit will create the directories for that task if they’re not already there. Since launching a DCC tends to be the first thing someone does with Toolkit, this is the usual way directories get created. This can happen via the right-click menus in ShotGrid, or from ShotGrid Desktop or Create apps.  ShotGrid menu: The most direct way to create folders for a task is to right-click on it in ShotGrid and choose the “Create Folders” menu item.  Toolkit API: You can trigger the directory creation logic directly through the Toolkit API. This can be used to plug Toolkit into a custom launcher, or for something like an event trigger for a workflow where you want to automatically create the directories for a Shot as it is created in ShotGrid.  tank command: Analogous to the menu item in ShotGrid, the tank folders terminal command will also create folders for a task.We’ll test with the tank command.Step 12: Run tank folders on the filet asset. From your terminal, run the following:&amp;gt; cd &amp;lt;pipeline_configuration_root_folder&amp;gt;&amp;gt;  ./tank Asset Filet foldersAbridged output:----------------------------------------------------------------------Command: Folders----------------------------------------------------------------------Creating folders, stand by...The following items were processed: - /Users/michelle/Documents/Shotgun/projects/the_other_side. . . - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/ - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/model - /Users/michelle/Documents/Shotgun/projects/the_other_side/assets/Dining-Room/Prop/Filet/model/publish. . .In total, 23 folders were processed.The final structure matches what was expected, and Toolkit is so smart that it even added a dash between Dining and Room./the_other_side/assets/Dining-Room/Prop/Filet/modelToolkit templates for reading and writing filesNow that we’ve set up our folder structure, the next step is to edit the templates, so production files will be named appropriately and put in the correct folder when they’re created.How Toolkit apps use templatesYou first created a way to associate an asset with a set in ShotGrid by enabling CustomEntity01 to represent sets, then adding a link field to the Asset entity to represent the link between an asset and a set. After establishing the relationship between assets and sets, you set up your folder schema to use that association to place all asset folders within a folder for their associated set. Now you’re going to create a way to dynamically name files and allow Toolkit Apps to manage the files automatically.As artists start working on tasks in a project, the necessary folder structure is generated. Then,  when they initiate the Workfiles app’s File Save action, the file is named automatically. A template accessed through Toolkit’s Workfiles app is used to name that file. Render apps like Nuke Write node and Houdini Mantra node use templates to name and save rendered files, as does the Publisher app for published files.When files are accessed using the Workfiles File Open action, it uses a template to find the appropriate file to load. The Publisher, Loader, and Nuke Studio Export apps also use templates to find and manage files. The artist doesn’t have to worry about file names or locations; Toolkit manages it all based on the template and the task being performed.Templates are managed by the configuration file /&amp;lt;pipeline_configuration_root&amp;gt;/config/core/templates.yml. In the last two guides, you managed and created settings that were specific to work environments. The schema and template settings are stored in the config/core folder and are not specific to an environment. While all templates are stored in a single file, they are referenced from this file in app settings in the different environment configuration files. For example, template_work is the setting for the Workfiles app that specifies which template in templates.yml to use for work files. Depending on the environment and engine in which Workfiles is configured, you might use this configuration setting to point to the maya_shot_work template or the houdini_asset_work template from templates.yml.Step 13: Open config/core/templates.yml in your pipeline configuration.This file is broken down into three sections:  Keys: A set of tokens (like {version}, {Asset}, etc.) to be used to build templates. They will be replaced with real values when the template is actually used. Each key has a required name and type and other optional parameters.  Paths: Named strings that use keys to represent paths to folders and files on disk. Note that templates in the paths section are validated and must actually exist on disk.  Strings: Similar to the paths section, but these are templates for arbitrary text. While items in the paths section are validated and must correspond with actual paths on disk, strings can be used to store any text data that you want to refer to in your Toolkit workflows.Add a template key for the Set entityThe first thing to do is define a new key for the Set entity, using the entity’s system name.Step 14: Add the following lines to the keys section of templates.yml, being mindful of proper indentation:       CustomEntity01:           type: strModifying the templateSince templates define where Toolkit reads and writes files, it’s crucial that the paths we define here stay in step with the folder structure defined in the schema. After all, production files should go into the filesystem we’re creating. So, we’re going to modify all of our asset-related templates to match the new folder structure we defined in the schema.Then, we’ll modify the template for work files on asset steps in Maya to also include the set in the file name. In the Default Config, the template in question is maya_asset_work, and that’s where we’ll start.Using a template called maya_asset_work for asset-based Workfiles in Maya is a convention of the Default Configuration. To confirm that that’s the right template, check the value of the template_work setting for tk-multi-workfiles2 in the tk-maya engine, in the asset_step environment (here it is in Github).Step 15: Open templates.yml and search for maya_asset_work.   maya_asset_work:        definition: '@asset_root/work/maya/{name}.v{version}.{maya_extension}'The definition value for maya_asset_work begins with @asset_root. The @ symbol signifies that the value of @asset_root is defined elsewhere.A leading @ symbol does not denote an include in templates.yml as it does in the environment configuration files.Since each integration, each app, and each environment might use different settings, you can imagine that the first part of a path might be used in many different places inside templates.yml. The configuration is set up so it can use a single variable to store a common path root, then refer to that variable within templates. You won’t have to change each instance of the path generation settings when you can reference the common root.The Default Configuration has three of these common root variables: @shot_root, @sequence_root, and @asset_root. We’ll be modifying @asset_root, and this single change will affect every asset-related template.Edit the template to match the path in the filesystem schemaStep 16: Search for asset_root at the top of the paths section of templates.yml. In the Default Config, it looks like:asset_root: assets/{sg_asset_type}/{Asset}/{Step}Add CustomEntity01 to the asset_root path to match the schema modifications:asset_root: assets/{CustomEntity01}/{sg_asset_type}/{Asset}/{Step}Add set to the file nameWe’ve changed the folder structure for our files to reflect our schema changes, and now files will be read and written to the proper location. Now, let’s modify the file name for the Maya asset work file template, so that it also includes the set.Find the maya_asset_work template definition again.  In its current state, the file name is{name}.v{version}.{maya_extension}The {name} template key is a special key that represents user input in the Workfiles app’s File Save action. Let’s modify the template so that it doesn’t include any user input, and instead just consists of the current set and asset.Step 17: Modify the maya_asset_work template definition so that it looks like this:    maya_asset_work:        definition: '@asset_root/work/maya/{CustomEntity01}_{Asset}.v{version}.{maya_extension}'This action allows you to use the Dining-Room entity proper name in the file name. The result will be something like Dining-Room_Filet.v1.mb.You’ve now modified templates.yml to reflect the new set folder in your production folder structure, and to include the name of the set in work files for asset tasks in Maya. Let’s test out the changes.Test itStep 18: Launch Maya from ShotGrid Desktop.In Maya, go to ShotGrid &amp;gt; File Open, and in the resulting dialog, select a task on an asset for which you’ve specified a Set in ShotGrid.Select +New File.You can create a simple 3D object or just save the file using the ShotGrid &amp;gt; Save File.Success!Notice the File Save dialog box is displaying Preview: Dining-Room_scene.v001.ma using the new settings in the template.The Work Area: is displaying …/ShotGrid/projects/the_other_side/assets/Dining-Room/Prop/Filet/model/work/maya as the path for where Workfiles is saving the file.Advanced topicsExtending the exampleIn this example, we modified a single template, but there’s plenty more you can do with your filesystem configuration. In a real world example, you’d likely change all asset-related files to have the same file naming conventions. You can make modifications based on other entities (Season, Episode, Level, etc.), create user folders, name your folders based on ShotGrid data manipulated with regular expressions, and much more. You can learn about all of Toolkit’s folder and schema options in the Filesystem Configuration Reference.The Path CacheAt folder creation time, a mapping is created between a folder on disk and a ShotGrid entity. These mappings are stored as FilesystemLocation entities in ShotGrid, and cached in an SQLite database on user machines. To learn more about how the path cache works and how to work with it, see this document.Additional Resources  Filesystem Configuration Reference  Intro to Toolkit Configuration webinar video",
    "url": "/56b441c6/",
    "relUrl": "/56b441c6/"
  },
  "41": {
    "id": "41",
    "title": "Editing a Config",
    "content": "Editing a pipeline configurationAfter completing this guide, you will have the knowledge fundamental to:  Finding a configuration setting for a specific Toolkit app  Editing the settings  Exploring what other functions the configuration settings can extend.About the guideThis guide describes how to edit settings within an existing Pipeline Configuration to meet the needs of a project pipeline. The first guide, Getting started with configurations, described how to prepare a pipeline configuration for editing. If you aren’t familiar with how to create an editable configuration for your project, complete Getting started with configurations before proceeding.Through extending the Default Configuration, ShotGrid Toolkit allows for customizing tasks within pipeline workflows. An example of a customization might be as simple as enabling or disabling a button in a Toolkit app within one or more software packages, changing the way users interact with Toolkit’s features. Toolkit allows proprietary configurations that enable you to work smarter and faster by: creating custom workflows, automating repetitive and mundane tasks, modifying hooks, and even adding custom tools built on the Toolkit platform. Unfortunately, it’s only accessible through ShotGrid software integrations, and not yet released for everyday tasks like washing your clothes.The exercises in this guide will teach you how to find what configuration settings control actions within the ShotGrid software integrations, where the settings live, and how to edit them. Specifically, we will edit a setting in the Workfiles app that manages the behavior of the +New Task button, preventing artists from creating a new task when working on a project inside Maya.Using this documentTo use this guide and perform an edit on a pipeline configuration, the following is required:  An active ShotGrid site.  A project with at least one asset. You can add an asset to the_other_side project you created in the first guide. You can review how to create an asset for a project in the Getting started with configurations guide.  A pipeline configuration for the identified project, or complete the Getting started with configurations guide and use the configuration created in that exercise.  Read and write permissions set appropriately for the filesystem where the Pipeline Configuration is stored.  ShotGrid Desktop installed on your system.  An active subscription for Maya. Get a 30 day trial of Maya here                    Note: This guide is based on the tk-config-default2 pipeline configuration. If your config was modified, the location of files, folders, and blocks of YAML settings may vary from what is described here.    About the Workfiles appThe Workfiles app governs file management in a ShotGrid software integration and controls access to functionality for browsing, opening, and saving work files. The +New Task button is an action of the Workfiles app that allows a user to add a task without having to go to ShotGrid to do so. The configuration is broken down into per-environment files. This allows you to manage functionality relative to different stages in the pipeline, controlling when a user can create, name and save files, execute tasks, or perform certain functions. This is relevant for all the functions in the Workfiles app and it also applies to modifying settings for any app or engine. Find more details in the Advanced Topics at the end of this document.Getting familiar with the configuration filesUse the Pipeline Configuration List in ShotGrid to locate where the pipeline configuration is stored for the project you’re working with. If you know where it’s stored, you can skip to step 5.Finding the pipeline configurationStep 1: Open the ShotGrid site that manages the project you will be using for this exercise.Step 2: Access the project from the ShotGrid site by selecting it from the Projects page.Step 3: Select the avatar in the upper right to display the ADMIN menu and scroll down to select Default Layouts &amp;gt; Pipeline Configuration &amp;gt; Pipeline Configuration List.Step 4: Once the Pipeline Configuration List is displayed, select the + sign on the far right of the column headers to add another column. In the dropdown list, choose the appropriate path for your operating system.The path will be displayed in a new field.Step 5: In a terminal or file manager, browse to the folder where the project’s pipeline configuration is stored and open the folder.There are three subfolders in a Toolkit configuration root folder: cache, config and install. Open the config folder and nested inside you will find several subfolders and a few files.The env folder stores the integration settings that support the environments artists work within. Environments allow different stages in the pipeline to have a customized configurations. The Default Configuration comes with a set of pre-defined environments, but these can be modified if your pipeline requires a more granular set.Step 6: Open the env folder.Toolkit uses YAML files to configure functionality. YAML was chosen as the language for the configurations because it allows the files in Toolkit to be formatted in a way that’s easily readable, lightweight, and simple to customize. You can explore more about YAML here. The configurations are made up of nested YAML files that provide identifiers engines, apps, and frameworks. It’s a roadmap of sorts guiding you to the specific bundle of code that controls the actions you want to affect.Editing the configuration fileShotGrid Toolkit allows alterations to the apps that are integrated within various software packages. One of the functions of the Workfiles app is the +New Task button, which allows a user to add a new task in the File Open dialog box. By default, this function is enabled for every user at every phase of a project. But a studio might want to restrict this functionality – say, if they have a specific naming convention, or want to limit task creation to a project’s production management team. In this case, they would disable the +New Task button for all the points in a pipeline where artists will be working in Maya.Disabling the +New Task button for projects in MayaStep 7: Open ShotGrid Desktop.Step 8: Select the project whose configuration you are going to edit.Step 9: Launch Maya from ShotGrid Desktop.Wait for the ShotGrid menu to fully load. If you have a slow internet connection, this would be the time to run the configuration that makes you that perfect shot of espresso with just the right amount of crema.Once Maya and ShotGrid are fully loaded, the File Open dialog box will open automatically. When you launch Maya from ShotGrid Desktop, you will enter Maya in the project environment; the configuration of your Toolkit workflows will be driven by the file config/env/project.yml. The environments that are identified in the Default Configuration are project, sequence, shot, shot_step, asset, asset_step.Step 10: Select the Assets tab in the left pane of the File Open dialog box. Select any asset inside the folder displayed in the search results.The +New Task button is enabled.Find what setting controls the +New Task buttonToolkit pipeline configurations are used to customize environments to meet your pipeline’s needs. A pipeline configuration can override default ShotGrid integration settings, varying as much or as little as necessary to meet the needs of a project’s pipeline. This structure allows configurations to be lightweight, adding only the settings that are different from the default values in the ShotGrid core code. In this exercise, we want to turn off the Workfiles app’s +New Task button, but before we can do so, we need to figure out which configuration setting controls it.Step 11: Select the &amp;gt; at the top right of the File Open window next to Project (name of project).This reference box shows details about the configuration settings that control the functions of the File Open window. Some apps in Toolkit have a reference box to show what settings are used for the app and what the default settings are. Notice the Location:: identifier is tk-multi-workfiles2. This is the identifier for the bundle of code that creates the Workfiles app. When searching a pipeline configuration this name will identify where the settings live for the app. There’s an Apps and Engines page that lists all the configuration settings, apps, and engines for what’s available in a ShotGrid Integration.Look under the Configuration header to find the settings for this specific environment.                    Note: After the setting my_tasks_filters is a setting launch_at_startup. This is important to note because it’s the default setting for the File Open setting in the project environment. This tells you that when Maya is launched from ShotGrid Desktop, the File Open dialog automatically opens.    Scroll down to Setting allow_task_creation. The default value of this setting is True, allowing a user to create a new task while in the Maya project environment.When searching for a setting there are several things to consider:  What software application you are running.  What file you are working on and what environment you are working in. This is found in the App’s reference box.  What the specific setting is called. This is found in the App’s reference box or on the Apps and Engines page page.  What YAML file to extend. There are identifiers and a roadmap detailed in the YAML files to guide you to where the settings live.  What specific blocks within the YAML file to extend. This is identified in the roadmap.  What identifiers and symbols are used in the YAML files.  And, most importantly, where the configuration is stored for the current project.A setting can be utilized in multiple places within a pipeline configuration. What determines where it goes are: which software integration you want to affect and where in the pipeline process you want to impact a change.Find where to set the value for allow_task_creationStep 12: Bring the main Maya window forward.Step 13: Find the ShotGrid menu item in the upper right of the Maya window.TIP: If the menu isn’t visible there will be » to show that some menu items are hidden. Select the » to display the ShotGrid menu or you can widen the Maya window.Step 14: Select ShotGrid &amp;gt; Project the_other_side &amp;gt; Work Area Info… on the top right of the menu.The Work Area Info dialog box shows what’s under the hood and details about your current work area. This includes the environment that you are is working in and the path to the environment configuration file where the settings are located.Step 15: In the Your Current Work Area dialog box, select the Environment tab at the bottom.The first item identifies the engine being used. The engine is what drives the ability to have the ShotGrid tools integrated within a specific software application. It holds the logic specific to each software integration. The second item displayed in the window shows the path where the current project environment is located.The last two folders are config/env/ followed by project.yml. The project.yml file is the start of the roadmap that will guide you to where the settings for the current environment are located.Step 16: Open project.yml in your favorite text editor.description: Apps and Engines when launching with a project only context.################################################################################includes:- ./includes/frameworks.yml- ./includes/settings/tk-3dsmaxplus.yml- ./includes/settings/tk-desktop.yml- ./includes/settings/tk-flame.yml- ./includes/settings/tk-houdini.yml- ./includes/settings/tk-mari.yml- ./includes/settings/tk-maya.yml- ./includes/settings/tk-motionbuilder.yml- ./includes/settings/tk-nuke.yml- ./includes/settings/tk-photoshopcc.yml- ./includes/settings/tk-shell.yml- ./includes/settings/tk-shotgun.yml################################################################################# configuration for all engines to load in a project contextengines:  tk-3dsmaxplus: &quot;@settings.tk-3dsmaxplus.project&quot;  tk-desktop: &quot;@settings.tk-desktop.project&quot;  tk-flame: &quot;@settings.tk-flame.project&quot;  tk-hiero: &quot;@settings.tk-nuke.hiero.project&quot;  tk-houdini: &quot;@settings.tk-houdini.project&quot;  tk-mari: &quot;@settings.tk-mari.project&quot;  tk-maya: &quot;@settings.tk-maya.project&quot;  tk-motionbuilder: &quot;@settings.tk-motionbuilder.project&quot;  tk-nuke: &quot;@settings.tk-nuke.project&quot;  tk-nukestudio: &quot;@settings.tk-nuke.nukestudio.project&quot;  tk-photoshopcc: &quot;@settings.tk-photoshopcc.project&quot;  tk-shell: &quot;@settings.tk-shell.project&quot;  tk-shotgun: &quot;@settings.tk-shotgun.project&quot;################################################################################# reference all of the common frameworksframeworks: &quot;@frameworks&quot;Inside project.yml, there are three sections below the description: includes, engines, and frameworks. The includes section is a list of file pointers that reference other YAML files in the configuration. The architecture of the Default Configuration takes advantage of nesting files and using pointers as another way to keep the files lightweight. Following the includes will bring you through one file to the next until you find the configuration setting you are looking for. It’s a bit like Russian Matryoshka dolls: you open up each doll that’s nested inside the next until you find the appropriate configuration setting.Every engine is identified as tk-&amp;lt;name of software application&amp;gt;. You know you want to affect settings in Maya, so the identifier we’re looking for is tk-maya.Look under the includes: section of the project.yml file and find this line, ./includes/settings/tk-maya.yml. This line indicates the configurations controlling the settings for the Maya engine, tk-maya, are nested inside the includes folder within the settings folder.In the engines: section find the tk-maya value.tk-maya: &quot;@settings.tk-maya.project&quot;The @ signifies that a value is coming from an included file.The settings and project reference indicate it’s a project’s settings. These are naming conventions within the Default Configuration that help to guide you.This complete line tells us to look for the settings.tk-maya.project block in the included file to find the configuration settings for the Maya engine, tk-maya.ShotGrid Toolkit uses simple terms in the YAML files to indicate the names of the settings and what paths will lead you to them. You already know from looking in the Maya File Open reference box that the bundle of code which controls how the +New Task button performs, is identified by tk-multi-workfiles2. Toolkit bundles are referenced in the YAML files using these identifiers. ‘tk-multi-workfiles2’ is the identifier for the Workfiles app code bundle, and the +New Task button is a function of the Workfiles app.Looking for the Workfiles App settings in tk-maya.ymlStep 17: In your file browser, browse to the env/includes/settings folder and open tk-maya.yml.Step 18: Following the include from project.yml, search the tk-maya.yml file for settings.tk-maya.project. You are specifically looking to disable the +New Task button in the project environment of a specific project. You are in the configuration for that project and obtained the location information while you were in the project environment.# projectsettings.tk-maya.project:  apps:    tk-multi-about:      location: &quot;@apps.tk-multi-about.location&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-multi-shotgunpanel: &quot;@settings.tk-multi-shotgunpanel&quot;    tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;  menu_favourites:  - {app_instance: tk-multi-workfiles2, name: File Open...}  location: &quot;@engines.tk-maya.location&quot;Under settings.tk-maya.projects, the tk-multi-workfiles2 app settings are listed astk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;The @ symbol tells us that that the value for tk-multi-workfiles2 is coming from an included file. In the includes section at the top of tk-maya.yml, we see the following:includes:...- ./tk-multi-workfiles2.ymlWe should look for settings.tk-multi-workfiles2.launch_at_startup in the tk-multi-workfiles2.yml file, in the same directory as the current file, config/env/includes/settings.Step 19: Open the tk-multi-workfiles2.yml file and search for settings.tk-multi-workfiles2.launch_at_startup.# launches at startup.settings.tk-multi-workfiles2.launch_at_startup:  launch_at_startup: true  entities:The Maya reference box indicated the allow_task_creation setting has a default value of true. As a best practice, no default settings are reflected in a pipeline configuration. This allows for a sparse format, adding only the settings that differ from the default code to the configuration. If a setting isn’t explicitly provided, any calls accessing that setting will receive the default value. When Toolkit reads the configuration and builds an environment, the apps, engines, and frameworks running in that environment use that project’s pipeline configuration settings and override any default settings based on what’s in the configuration.Step 20: In tk-multi-workfiles2.yml, add allow_task_creation under settings.tk-multi-workfiles2.launch_at_startup: and set the value to false# launches at startup.settings.tk-multi-workfiles2.launch_at_startup:  allow_task_creation: false  launch_at_startup: true  entities:NOTE: Toolkit Default Configuration settings are organized alphabetically as an easy way to find specific settings. Keeping this convention will make your life a lot easier as the configuration gets a little heavier.Step 21: Save the file.Reload the configurationStep 22: In the File Open dialog box inside of Maya, open the reference box and select Reload Engines and Apps.This will reload the configuration settings.View your changesStep 23: Navigate to the File Open dialog box and select an asset.Notice that the +New Task button is not visible.You’ve modified a configuration setting for the Workfiles app, changing the behavior of a button in a project environment. Since you only modified that setting in the project environment, if you start working in another environment the settings for the +New Task button will still be active. In a real production example, you’d likely make the change we made here for all environments.Changing environmentsStep 24: Under the Assets search results, open a folder and select asset you wish to work on.Step 25: Select +New FileBy selecting +New File, you began to work on a new asset and the asset_step environment was loaded in Maya. When an artist selects an asset task and creates a new file or opens an existing one, the asset_step environment is automatically loaded, presenting the tools and functions configured for that stage in the pipeline.Discover what environment you are working inStep 26:  In the upper right of the Maya menu select ShotGrid.Art, Asset Text Overlay tells you’re working on and what environment you’re in.Step 27: Select Art, Asset Text Overlay &amp;gt; Work Area Info… to display what the parameters are in your current work area.Step 28: Select the Environment tab at the bottom.Each environment will display the information necessary to determine where the settings live in the pipeline configuration. To disallow an artist from adding a new task, it’s necessary to disable the +New Task button for every environment that artist works in. For each environment, use the same steps outlined above to edit the configuration appropriately.NOTE: Each environment is independent, a project has a dedicated configuration, and the software integrations only read settings for their specific software from the pipeline configuration when a project is loaded.You’ve now edited your pipeline configuration, making a change to the settings for an app. And now the real fun begins: learning all the things you can do with ShotGrid Toolkit environments. Here are some advanced topics to explore.Advanced topicsIn this guide, we made a simple change to the configuration settings for an app, in a single engine (tk-maya) and in a single environment (project). You’ve learned that Toolkit is organized by environments, each environment is unique for every software implementation, and the environments are focused by project and task allowing you to have specific functions available for artists at defined points in a pipeline. You can generalize our simple change to make rich customizations to your Toolkit pipeline configuration.Other enginesThe system name for the Workfiles app is tk-multi-workfiles2, and multi in the name implies that it’s a multi app. Multi apps are software-agnostic: their features and functionality are the same whether you run them in Maya, Nuke, Houdini, or any other supported app. If you wanted to disable task creation in Workfiles across all software packages, you’d follow the steps in this guide for every engine: tk-nuke, tk-houdini, and so on.Other environmentsWe disabled task creation in the project environment, but in a real studio environment, you’d probably want to disable it for all environments in which your artists are working. To do so, you’d follow the steps in the guide, but instead of starting at project.yml, you’d start at asset_step.yml, shot_step.yml, and so on.Creating custom environmentsThe Default Configuration comes with a set of pre-defined pipeline steps: project, sequence, shot, shot_step, asset, and asset_step. However, a studio might want different configuration settings for every stage in the pipeline – say asset_step_rig, asset_step_model, shot_step_anim, shot_step_light, and so on. Toolkit supports custom environments. See the “Custom environments” section of the Environment Configuration Reference for details.Video Resources  Intro to Toolkit configurations from our SIGGRAPH 2018 Developer Day  Demystifying the Default Configuration webinarNow that you’ve learned how to modify an app configuration setting, try adding an app to your Toolkit configuration.",
    "url": "/37f575b8/",
    "relUrl": "/37f575b8/"
  },
  "42": {
    "id": "42",
    "title": "Attempted to communicate without completing encryption handshake",
    "content": "[ERROR] Attempted to communicate without completing encryption handshakeUse case:Having trouble getting the browser integration of ShotGrid Desktop up and running.Launching Shotgun Desktop tells me the webserver is running:[    INFO] WebSocketServerFactory (TLS) starting on 9000[    INFO] Starting factory …followed by loads of debug records which do not show any errors.When logging into the ShotGrid site, I get:[ INFO] Connection accepted.Right-clicking on a project tells me that ShotGrid is retrieving actions and gives me the following log output:[    INFO] Connection accepted.[   ERROR] Attempted to communicate without completing encryption handshake.[   ERROR] Attempted to communicate without completing encryption handshake.[    INFO] Connection closed.[   DEBUG] Reason received for connection loss: [Failure instance: Traceback (failure with no frames): : Connection to the other side was lost in a non-clean fashion: Connection lost.Opening a project in ShotGrid produces the following log output:[    INFO] Connection accepted.[   ERROR] Attempted to communicate without completing encryption handshake.[   ERROR] Attempted to communicate without completing encryption handshake.[   ERROR] Attempted to communicate without completing encryption handshake.[   ERROR] Attempted to communicate without completing encryption handshake.[ WARNING] dropping connection to peer tcp4:127.0.0.1:52451 with abort=True: WebSocket closing handshake timeout (peer did not finish the opening handshake in time)[    INFO] Connection closed.[   DEBUG] Reason received for connection loss: [Failure instance: Traceback (failure with no frames): : Connection to the other side was lost in a non-clean fashion: Connection lost.How to fix:Add shotgunlocalhost.com to the proxy bypass list.Example of what’s causing this error:Proxy configuration.See the full thread in the community.",
    "url": "/2fa5964e/",
    "relUrl": "/2fa5964e/"
  },
  "43": {
    "id": "43",
    "title": "VPC Endpoints",
    "content": "VPC EndpointsComing soon.",
    "url": "/8a9c5baf/",
    "relUrl": "/8a9c5baf/"
  },
  "44": {
    "id": "44",
    "title": "환경 구성 참조",
    "content": "환경 구성 참조소개툴킷 파이프라인의 핵심에는 환경 구성이 있습니다. 툴킷 파이프라인 구성 내에서 환경 구성 파일은 다양한 DCC 내에서 사용할 수 있는 툴킷 앱을 정의하고 각 설정을 커스터마이즈할 수 있는 곳입니다. 이 문서는 환경 구성 파일의 구조 및 기능을 전체적으로 소개하는 완전한 참조 자료입니다. 이 문서에서는 프로젝트 내에서 다양한 워크플로우를 구성할 수 있게 해 주는 툴킷 환경의 개념과 커스터마이즈할 수 있는 항목을 찾는 방법에 대해 설명합니다.                    참고: 이 문서는 환경 구성 파일에 대한 참조 자료로 사용될 수 있으며 툴킷 기본 사항 안내서의 파이프라인 구성 편집에서는 구성 설정 편집에 대한 단계별 예제를 확인할 수 있습니다.    환경이란?ShotGrid 툴킷 플랫폼은 스튜디오 파이프라인을 구축하는 데 일반적으로 사용되는 컨텐츠 작성 소프트웨어를 위해 완전히 커스터마이즈 가능한 통합 세트를 제공합니다. 프로젝트 구성 내에서 통합이 있는 소프트웨어 패키지, 각각 사용 가능한 툴킷 앱, 각 앱에 대한 옵션을 지정하여 스튜디오의 요구 사항에 맞게 아티스트 워크플로우를 구축할 수 있습니다.하지만 대부분의 스튜디오 파이프라인에서는 아티스트 유형별로 다른 워크플로우를 사용하는 것이 일반적입니다. 간단한 예로, 에셋 작업 중인 아티스트의 경우 텍스처 페인팅 소프트웨어(예: Mari)를 사용하게 하고 샷 작업 중인 아티스트의 경우에는 컴포지팅 소프트웨어(예: Nuke)를 사용하게 할 수 있습니다.소프트웨어 패키지뿐 아니라 동일한 툴킷 앱에 대한 설정도 아티스트별로 다르게 지정할 수 있습니다. 예를 들어 샷 아티스트와 에셋 아티스트 둘 다 Workfiles 앱을 사용할 수 있지만 샷 아티스트는 샷 엔티티, 에셋 아티스트는 에셋 엔티티와 관련된 파일로만 파일 탐색을 제한할 수 있습니다.프로젝트 내에서 이렇게 서로 다른 워크플로우를 지원하기 위해 툴킷은 환경에서 앱과 엔진 구성을 분리합니다. 각 환경에는 소프트웨어 패키지 셋트의 통합과 설정이 모두 공통적으로 포함되어 있습니다.위의 예에서 에셋 작업 중인 아티스트는 에셋 단계 환경에서 작업하고 샷 작업 중인 아티스트는 샷 단계 환경에서 작업합니다. 각 환경은 서로 독립적으로 구성되므로 한 프로젝트 내에서 각기 다른 워크플로우를 사용할 수 있습니다.툴킷의 기본 구성에 대한 참고 사항툴킷은 환경을 구성하는 방식에 있어 매우 자유롭습니다. 이 문서에서는 사용 가능한 모든 옵션을 모두 소개하므로 파이프라인 요구 사항에 가장 적합한 선택을 하는 데 필요한 지식을 얻을 수 있습니다.또한 이 문서에서는 기본 구성이라는 시작점으로 제공되는 파이프라인 구성의 선택 사항에 대해서도 설명합니다. 파이프라인을 커스터마이즈할 준비가 된 경우 첫 번째 단계는 프로젝트에 대해 편집 가능한 파이프라인 구성을 만드는 것입니다.이러한 선택 사항은 일반적인 규칙일 뿐이고 툴킷 워크플로우에 하드코딩되지 않으므로, 기본 구성은 파이프라인을 커스터마이즈한 후 사용할 수 있는 기능을 학습하기 위한 예제로 참조하거나 고유의 구성을 설정하기 위한 모범 사례로 사용하는 것이 좋습니다. 또한 새로운 툴킷 사용자를 위한 시작점으로도 좋으며 몇 가지 규칙을 알아 두면 유용합니다. 이 문서에서는 툴킷 환경 구성의 일반적인 기능과 기본 구성에 특정한 선택 사항을 구분해 두었습니다. 기본 구성의 환경 구조에 대한 자세한 내용은 읽어보기 파일을 참조하십시오.파일 위치파이프라인 구성에서 config/ 디렉토리에는 커스터마이즈할 수 있는 모든 파일 및 폴더가 포함됩니다. config/에는 세 개의 하위 디렉토리(cache, core 및 env)가 있습니다. env 디렉토리에 환경 구성 파일이 있으므로 이 문서에서는 config/env의 파일을 참조합니다.기본 구성의 config/env/에는 다음 파일이 있습니다.asset.ymlasset_step.ymlproject.ymlsequence.ymlshot.ymlshot_step.yml이러한 각 파일이 환경에 해당하며 별도 파일을 사용하면 각 환경을 별도로 구성할 수 있습니다.툴킷이 현재 환경을 결정하는 방식툴킷은 pick_environment라는 코어 후크를 사용하여 현재 컨텍스트를 기반으로 지정된 시간에 사용할 환경 파일을 결정합니다. pick_environment 후크의 반환 값은 환경 구성 파일에 해당합니다. 예를 들어 pick_environment가 shot_step을 반환하는 경우 툴킷은 config/env/shot_step.yml을 사용하여 툴킷 환경을 구성합니다.커스텀 환경위에 나열된 환경 구성 파일은 기본 구성에서 제공하는 파일입니다. 그러나 일부 스튜디오에서는 다른 환경 또는 추가 환경을 필요로 할 수 있습니다. 예를 들어 스튜디오에서 파이프라인 단계(asset_step_rig, asset_step_model, shot_step_anim, shot_step_light 등)마다 다른 구성 설정을 사용해야 할 수 있습니다. 다행히도 사용 가능한 환경을 완전히 커스터마이즈할 수 있습니다.이렇게 하려면 원하는 환경 구성 파일을 config/env 디렉토리에 추가해야 합니다. 그런 다음 pick_environment 코어 후크를 재지정하여 새 환경을 사용할 때 정의하는 로직에 추가합니다.기본 구조툴킷의 구성 파일은 YAML로 작성됩니다. 모든 번들(앱, 엔진 또는 프레임워크)의 일반적인 구성은 다음과 같은 구조로 되어 있습니다.bundle_name:  setting1: value  setting2: value  complex_setting:    sub_setting1: value      Sub_setting2: value  location:    type: descriptor_type    descriptor_setting1: value    descriptor_setting2: value이 구조를 보여 주는 간단한 예제가 아래에 있습니다(단일 엔진이 있고 엔진 내에 단일 앱이 정의된 환경). 다음은 이 구성에서 project.yml의 내용이 될 수 있습니다.engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4엔진 블록모든 환경 구성 파일은 engines 블록으로 시작합니다. 해당 환경에 대해 정의된 모든 엔진이 이 블록 내에 중첩됩니다.이 예에서는 하나의 엔진, tk-maya만 정의되어 있습니다. 여기에는 두 개의 설정(apps 및 location)이 나열되어 있습니다.location은 모든 번들에 필요한 특수한 설정입니다. apps 설정은 엔진에 대해 정의된 모든 앱의 목록으로, 각 앱에는 자체 설정이 있습니다. 이 예에서는 엔진에 대해 하나의 앱, tk-multi-workfiles2만 정의되어 있습니다.위치 설명자모든 툴킷 번들에는 번들의 설명자라고 불리는 location 설정이 있습니다. 설명자를 통해 툴킷은 지정된 번들의 위치를 파악하고 해당 유형에 따라 직접 액세스할지 아니면 로컬로 캐시할지 여부를 파악합니다. 툴킷 번들을 가져올 수 있는 위치는 ShotGrid 앱 스토어, git 리포지토리, 디스크의 경로 또는 ShotGrid 사이트에 업로드된 ZIP 파일 등입니다. 이러한 각 위치에 해당하는 설명자 유형이 있으며 여기에는 해당 유형과 관련된 설정이 포함됩니다. 위 예제의 tk-maya 엔진에 대한 설명자는 다음과 같습니다.    location:        type: app_store        name: tk-maya        version: v0.9.4이 예는 app_store 유형의 설명자로, 툴킷이 ShotGrid 앱 스토어에서 지정된 번들을 가져오도록 합니다. app_store 유형의 설명자에는 name 및 version 설정이 있습니다.한편, 커스텀 번들을 개발 중이고 스튜디오의 특정 워크플로우에 대한 툴킷 앱을 작성 중인 경우 디스크의 경로에서 직접 가져오고 싶을 수 있습니다. 이 경우 다음과 같이 dev 유형의 설명자를 사용합니다.    location:        type: dev        path: /path/to/appdev 설명자에는 app_store 설명자와 다른 설정이 있습니다. 다른 설정을 가져올 수 있지만 디스크에 있는 앱 위치를 가리키는 path 설정으로 간단하게 설정할 수 있습니다.사용 가능한 모든 설명자 유형 및 해당 설정에 대한 자세한 내용은 Toolkit Core API 문서의 설명자 섹션을 참조하십시오.앱 블록앱은 툴킷의 사용자 도구로, 각 앱은 서로 독립적으로 실행할 수 있습니다. 파이프라인 요구 사항에 맞게 사용할 앱을 선택할 수 있으며 엔진 블록 내의 apps 설정은 지정된 엔진에서 사용할 수 있는 앱을 정의하는 곳입니다.위 예제에서 apps 설정은 다음과 같습니다.engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8단일 앱인 tk-multi-workfiles2 앱이 정의되어 있는 것을 확인할 수 있습니다. 현재는 하나의 설정(설명자)만 정의되어 있습니다.project 환경의 tk-maya 엔진에서 다른 앱을 사용할 수 있도록 하려면 여기에 추가합니다. 엔진에 패널 tk-multi-shotgunpanel 및 앱 정보 tk-multi-about을 추가해 보겠습니다. project.yml 예제 파일은 이제 다음과 같이 표시됩니다.engines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4이때 다음과 같은 몇 가지 중요 사항에 유의해야 합니다.  기본 구성에는 번들이 알파벳순으로 나열되며 이 예에서는 해당 규칙을 따릅니다.  파일이 길어지기 시작하고 있지만 아직 어떤 구성 설정도 추가하지 않은 상태입니다.  다른 엔진 및 다른 환경에서도 이와 동일한 앱을 사용할 수 있습니다. 예를 들어 다른 엔진(예: Houdini, Nuke 또는 Photoshop) 및 다른 환경(예: asset_step 또는 shot_step)에도 이 세 개의 앱(Panel 앱, About 앱, Workfiles 앱)이 모두 있을 수 있습니다. 구성에서 여러 곳에 공통 앱 설정을 정의하면 변경 시에도 여러 곳에서 수정해야 합니다.마지막 두 가지 문제점을 해결하기 위해 툴킷 구성은 includes를 지원합니다.Includesincludes는 구성에서 한 파일의 섹션을 다른 파일에서 참조할 수 있게 해 줍니다. includes를 사용하면 한 곳에서 구성 설정을 설정한 후 여러 환경에서 사용할 수 있습니다.includes는 두 부분으로 구성됩니다.  includes 목록: 키가 includes인 YAML 사전이며 값은 포함할 모든 파일의 목록입니다.  구성 설정 내의 참조: 앞에 @ 기호가 붙고, 포함된 파일에서 참조할 섹션의 이름을 가리키도록 명명됩니다.위의 예제를 구체화하기 위해 모든 엔진에 대한 위치 설명자가 있는 단일 파일이 있다고 가정합니다. 이 파일을 includes 하위 폴더에 넣고 engine_locations.yml로 지정하겠습니다.engine_locations.yml의 내용은 다음과 같습니다.config/env/includes/engine_locations.yml:engines.tk-maya.location:  type: app_store  name: tk-maya  version: v0.9.4engines.tk-nuke.location:  type: app_store  name: tk-nuke  version: v0.11.5...이 파일은 모든 엔진 위치에 대한 단일 소스 역할을 하며 모든 환경 구성에서 참조할 수 있습니다. 이 포함 파일을 사용할 경우 예제는 이제 다음과 같이 표시됩니다.config/env/project.yml:includes:- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location: @engines.tk-maya.locationtk-maya 엔진에 대한 location 설정 값이 이제 포함된 YAML 파일의 키에 대한 참조임을 확인할 수 있습니다.                    참고: 이 예제에서와 같이 config/env/includes/engine_locations.yml 파일에 모든 엔진 위치가 있는 기본 구성의 규칙을 따릅니다.    앱 위치에 대한 두 번째 포함 파일을 추가할 수 있으며 사실 기본 구성은 이 작업을 수행합니다. 예제를 확장해 보겠습니다.config/env/includes/app_locations.yml:apps.tk-multi-about.location:  type: app_store  name: tk-multi-about  version: v0.2.8apps.tk-multi-shotgunpanel.location:  type: app_store  name: tk-multi-shotgunpanel  version: v1.6.3apps.tk-multi-workfiles2.location:  type: app_store  name: tk-multi-workfiles2  version: v0.11.8config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.location이제 포함된 engine_locations.yml 파일에서 tk-maya 엔진의 설명자를 가져오고 포함된 app_locations.yml 파일에서 tk-maya 엔진에 대해 정의된 각 앱의 설명자를 가져옵니다.                    참고: 기본 구성은 여기에 설명되지 않은 두 번째 중첩 수준을 사용합니다. 설명자 외에도 설정이 있는 모든 앱 또는 엔진에 includes/settings의 설정 파일(예: includes/settings/tk-maya.yml, includes/settings/tk-multi-workfiles2.yml)이 있습니다. 엔진 설정 파일에는 앱 설정 파일의 앱 설정이 포함되고 환경 구성 파일에는 엔진 설정 파일의 설정이 포함됩니다. 기본 구성의 구조에 대한 자세한 내용은 읽어보기 파일을 참조하십시오. 구성 설정 수정에 대한 자세한 내용은 툴킷 기본 사항 안내서의 파이프라인 구성 편집을 참조하십시오.    스파스 구성모든 툴킷 번들에는 각 기본값이 포함된 일련의 구성 설정이 있습니다. 툴킷은 스파스 구성을 허용하므로 환경 구성 파일(및/또는 포함 파일)에 구성 설정이 명시적으로 지정되지 않은 경우에는 번들의 기본값이 사용됩니다.이 예에서는 location을 제외하고 앱에 대한 어떤 설정도 지정하지 않았습니다. 따라서 구성의 현재 상태에서 세 개의 앱은 모든 설정에 대해 기본값을 사용합니다. 그렇다면 어떤 구성 설정을 사용할 수 있는지 어떻게 알 수 있을까요?                    참고: 툴킷 구성이 스파스일 필요는 없지만 기본 구성은 스파스 구성입니다.    사용 가능한 구성 설정 확인스파스 구성의 경우 단순히 구성 파일을 보는 것만으로는 앱에 대해 사용할 수 있는 구성 설정을 바로 확인할 수 없습니다. 사용 가능한 앱 구성 설정을 확인하려면 두 가지 방법이 있습니다.  앱 설명서: 각 앱에는 고유의 설명서 페이지가 있으며 이 각 페이지마다 “구성 옵션” 섹션이 있습니다. 이 섹션에는 각각의 설명 및 기본값을 포함하여 사용 가능한 모든 앱 구성 설정이 나와 있습니다. 예를 들어 Workfiles 설명서 페이지를 참조할 수 있습니다. 앱 및 엔진 페이지에는 모든 앱 및 엔진에 대한 문서 페이지가 나열되어 있습니다.  매니페스트: 모든 툴킷 번들에는 루트 디렉토리에 info.yml  파일이 포함되어 있습니다. 이 파일을 번들의 매니페스트라고 하며 각각의 설명 및 기본값을 포함하여 번들에 대해 사용 가능한 모든 구성 설정을 정의합니다. 매니페스트는 번들의 자체 캐시(예: 파이프라인 구성 내의 install/app_store/tk-multi-workfiles2/v0.11.8/info.yml) 또는 GitHub(Workfiles용)에서 찾을 수 있습니다.구성 설정 수정기본값에서 구성을 수정하려면 파이프라인의 구성에서 적절한 환경의 적절한 블록에 추가하고 값을 설정하면 됩니다.예제로 돌아가 프로젝트 환경에서 Maya를 시작할 때 tk-multi-workfiles2가 자동으로 시작되도록 구성한다고 가정해 보겠습니다. 앱의 매니페스트에서 응용프로그램 시작 시 Workfiles UI 시작 여부를 제어하는 launch_at_startup 설정이 있고 기본값은 False임을 확인할 수 있습니다. 따라서 launch_at_startup 옵션을 추가하고 해당 옵션을 True로 설정합니다. project.yml 파일은 이제 다음과 같이 표시됩니다.config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        launch_at_startup: True        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.locationtk-multi-workfiles2에 대한 설정을 포함 파일에서 가져온 경우 해당 파일에서 설정을 변경해야 합니다.추가 리소스  툴킷 기본 사항 안내서: 파이프라인 구성 편집  툴킷 기본 사항 안내서: 앱 추가  애니메이션 파이프라인 튜토리얼  설명자 참조 설명서  웨비나: 툴킷 관리  파일 시스템 구성 참조  기본 구성 환경 구조 읽어보기",
    "url": "/487a9f2c/",
    "relUrl": "/487a9f2c/"
  },
  "45": {
    "id": "45",
    "title": "EOF occurred in violation of protocol",
    "content": "SSLError: [Errno 8] _ssl.c:504: EOF occurred in violation of protocolUse CaseWhen opening Nuke 10.5 from Desktop, the following SSL Error is presented:[13:57.14] ERROR: Shotgun Error: [ERROR tk-nuke] App /media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2 failed to initialize. It will not be loaded.Traceback (most recent call last):File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank/platform/engine.py”, line 2792, in __load_appsapp.init_app()File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/app.py”, line 26, in init_appself._tk_multi_workfiles = self.import_module(“tk_multi_workfiles”)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank/platform/bundle.py”, line 462, in import_moduleself.__module_uid, None, python_folder, (&quot;&quot;, “”, imp.PKG_DIRECTORY)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/init.py”, line 11, infrom . import tk_multi_workfilesFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/init.py”, line 14, infrom .file_open_form import FileOpenFormFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/file_open_form.py”, line 19, infrom .actions.file_action_factory import FileActionFactoryFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/actions/file_action_factory.py”, line 19, infrom .interactive_open_action import InteractiveOpenActionFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/actions/interactive_open_action.py”, line 17, infrom .open_file_action import OpenFileActionFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/actions/open_file_action.py”, line 22, infrom …work_area import WorkAreaFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/work_area.py”, line 19, infrom .user_cache import g_user_cacheFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/user_cache.py”, line 203, ing_user_cache = UserCache()File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/app_store/tk-multi-workfiles2/v0.12.2/python/tk_multi_workfiles/user_cache.py”, line 32, in initself._current_user = sgtk.util.get_current_user(self._app.sgtk)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank/util/login.py”, line 125, in get_current_user“HumanUser”, filters=[[“login”, “is”, current_login]], fields=fieldsFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 882, in find_oneadditional_filter_presets=additional_filter_presets)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 1003, in findadditional_filter_presets)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 1072, in _construct_read_parametersparams[“paging”] = {“entities_per_page”: self.config.records_per_page,File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 471, in records_per_pageself._records_per_page = self._sg.server_info.get(“api_max_entities_per_page”) or 500File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 763, in server_inforeturn self.server_caps.server_infoFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 778, in server_capsself._server_caps = ServerCapabilities(self.config.server, self.info())File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 833, in inforeturn self._call_rpc(“info”, None, include_auth_params=False)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank/authentication/shotgun_wrapper.py”, line 63, in _call_rpcreturn super(ShotgunWrapper, self)._call_rpc(*args, **kwargs)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 3302, in _call_rpcencoded_payload, req_headers)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 3442, in _make_callreturn self._http_request(verb, path, body, req_headers)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/shotgun.py”, line 3496, in _http_requestresp, content = conn.request(url, method=verb, body=body, headers=headers)File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 2192, in requestcachekey,File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 1845, in _requestconn, request_uri, method, body, headersFile “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 1750, in _conn_requestconn.connect()File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 1399, in connectself.key_password,File “/media/vfxbox/SHOTGUN/configsDeluxe/animationcopy/install/core/python/tank_vendor/shotgun_api3/lib/httplib2/python2/init.py”, line 109, in _ssl_wrap_socketssl_version=ssl_version,File “/usr/local/Nuke10.5v7/lib/python2.7/ssl.py”, line 381, in wrap_socketciphers=ciphers)File “/usr/local/Nuke10.5v7/lib/python2.7/ssl.py”, line 143, in initself.do_handshake()File “/usr/local/Nuke10.5v7/lib/python2.7/ssl.py”, line 305, in do_handshakeself._sslobj.do_handshake()SSLError: [Errno 8] _ssl.c:504: EOF occurred in violation of protocolThis does not happen with Nuke version 11 or 12.How to fixThe issue you are seeing is because Nuke 10.x is not TLS 1.2 compliant. Software will need to be TLS compliant.Related linksSee the full thread in the community",
    "url": "/4947c1f4/",
    "relUrl": "/4947c1f4/"
  },
  "46": {
    "id": "46",
    "title": "Episodic workflow with Nuke Studio",
    "content": "Episodic workflow with Nuke StudioIntroduction and prep workThis article explains how to get your episodic workflow up and running with our tk-hiero-export app in Nuke Studio or Hiero. Please note there is no one exact method for this, and the approach will vary slightly depending on your desired workflow. For the sake of this example we are going to make the following assumptions:  Your goal is to set up a three-tiered hierarchy of Episode &amp;gt; Sequence &amp;gt; Shot  You will have read and completed the steps in the file system configuration guide .  You will use the Episode entity type, (not the CustomEntity02 —both can work in the same way, it’s just a change of name.)  The Sequence entity has an entity field called episode .  You’ll be using Nuke Studio, although the process is the same for Hiero.  You will be starting with a default configuration for your Toolkit project.There is one more decision to make before you get started, and that is how to resolve the Episode . The out-of-the-box ShotGrid Hiero/Nuke Studio export process creates Sequence and Shot entities on your ShotGrid site based upon the contents of your Nuke Studio project. So, unlike working in Maya with Toolkit where we expect you to have already created the Assets and Tasks, in Nuke Studio we don’t expect your Episodes Sequences or Shots to already be created. With that said, you need to decide how to define the Episode in Nuke Studio. There are a few possible options here:  Create the Episodes up front in ShotGrid and configure the Nuke Studio Toolkit integrations to work in the context of an Episode, so that at export time you can get the Episode entity from the current scene context.  Assume Episode entities haven’t already been created and make use of the Nuke Studio’s tagging feature to tag the Sequence with the Episode name and use that to resolve our Episode at export time.There may be other ways that suit your workflow better, such as extracting the episode name from part of the Nuke Studio Sequence or Shot names, e.g., taking the “ep1” bit from a sequence called “ep1_s01”. Or you could use the export app’s hiero_customize_export_ui.py hook to add a GUI for linking up exports with Episodes.For this example we will go with the second option: the Sequence tagging solution.Note that this walkthrough is for implementing three layers of hierarchy ( Episode &amp;gt; Sequence &amp;gt; Shot ). The process for simply trying to replace the Sequence entity type with the Episodes entity type ( Episode &amp;gt; Shot ) is easier. We cover this scenario briefly near the end of this guide, but it’s still worth reading the rest to get a better understanding.Schema and templatesAs mentioned previously, this example assumes that you have updated your schema and templates . Make sure that you have also updated the hiero_plate_path and hiero_render_path path values in the templates.yml, so that they contain an episode key in the correct part.Hooks and settingsIn order to get the ShotGrid Export process to handle our Episode correctly, you will need to modify some of the export hooks. In this article we’ll assume you know what hooks are, and are comfortable with overriding the base implementations.There are two export hooks that will help you enable episodes.  hiero_get_shot.py  hiero_resolve_custom_strings.pyNOTE: There is a third hook called hiero_translate_template.py . We are not going to use it in this example, however, you will need it if you only wanted to replace Sequences with Episodes and maintain a two layer hierarchy. We’ll cover this a bit more at the end of the article.Modify the hiero_get_shot.py so you can find the Episode, and create an entity for it in ShotGrid , and modify the hiero_resolve_custom_strings.py so that Nuke Studio knows what value to give to the {Episode} key in the path. Here are the steps in more detail:1. Add Episode FieldYou now have a new key in your templates called Episode , and you need to tell the tk-hiero-export app how to resolve this. Modify the custom_template_fields in the &amp;lt;pipeline_configuration&amp;gt;/config/env/includes/settings/tk-hiero-export.yml file, so that it looks like this: settings.tk-hiero-export:      custom_template_fields: [{keyword: Episode, description: The episode name}]   ... This adds a valid export token named {Episode} to the Hiero exporter.2. hiero_get_shot hookNow you need to tell the export process how to find the Episode name and create the Episode in ShotGrid , using the hiero_get_shot.py hook.The default version of the hook (hiero_get_shot.py) will return the Shot from ShotGrid with the same name as the TrackItem. The Shot must also be linked to a Sequence with the same name as the Nuke Studio sequence item. If the Sequence or Shot doesn’t exist in ShotGrid , the hook will create them. You’re adding another level of hierarchy so you need to tell the hook to also create the Episode if it doesn’t exist.And, since the Sequence is linked to the Episode , you should tie this into the code that looks up the Sequence , ( get_shot_parent() method).Create an hiero_get_shot.py file in your config’s hooks folder, and add hook_get_shot: '{config}/hiero_get_shot.py' to your tk-hiero-export.yml settings , so that you now have something like this: settings.tk-hiero-export:      custom_template_fields: [{keyword: Episode, description: The episode name}]      hook_get_shot: '{config}/hiero_get_shot.py' Below is the complete code for the hiero_get_shot.py hook. Add this to the hook you created:from sgtk import Hookclass HieroGetShot(Hook):    &quot;&quot;&quot;    Return a  ShotGrid  Shot dictionary for the given Hiero items    &quot;&quot;&quot;    def execute(self, task, item, data, **kwargs):        &quot;&quot;&quot;        Takes a hiero.core.TrackItem as input and returns a data dictionary for        the shot to update the cut info for.        &quot;&quot;&quot;       # get the parent entity for the Shot       parent = self.get_shot_parent(item.parentSequence(), data, item=item)       # shot parent field       parent_field = &quot;sg_sequence&quot;       # grab shot from  ShotGrid        sg = self.parent.shotgun       filter = [           [&quot;project&quot;, &quot;is&quot;, self.parent.context.project],           [parent_field, &quot;is&quot;, parent],           [&quot;code&quot;, &quot;is&quot;, item.name()],        ]       # default the return fields to None to use the python-api default       fields = kwargs.get(&quot;fields&quot;, None)       shots = sg.find(&quot;Shot&quot;, filter, fields=fields)       if len(shots) &amp;gt; 1:           # can not handle multiple shots with the same name           raise StandardError(&quot;Multiple shots named '%s' found&quot;, item.name())       if len(shots) == 0:           # create shot in            shot_data = {               &quot;code&quot;: item.name(),               parent_field: parent,               &quot;project&quot;: self.parent.context.project,           }           shot = sg.create(&quot;Shot&quot;, shot_data, return_fields=fields)           self.parent.log_info(&quot;Created Shot in  ShotGrid : %s&quot; % shot_data)       else:           shot = shots[0]       # update the thumbnail for the shot       upload_thumbnail = kwargs.get(&quot;upload_thumbnail&quot;, True)       if upload_thumbnail:           self.parent.execute_hook(               &quot;hook_upload_thumbnail&quot;,               entity=shot,               source=item.source(),               item=item,               task=kwargs.get(&quot;task&quot;)           )       return shot    def get_episode(self, data=None, hiero_sequence=None):        &quot;&quot;&quot;        Return the  episode for the given Nuke Studio items.        We define this as any tag linked to the sequence that starts        with 'Ep'.        &quot;&quot;&quot;       # If we had setup Nuke Studio to work in an episode context, then we could       # grab the episode directly from the current context. However in this example we are not doing this but here       # would be the code.       # return self.parent.context.entity       # stick a lookup cache on the data object.       if &quot;epi_cache&quot; not in data:           data[&quot;epi_cache&quot;] = {}       # find episode name from the tags on the sequence       nuke_studio_episode = None       for t in hiero_sequence.tags():           if t.name().startswith('Ep'):               nuke_studio_episode = t               break       if not nuke_studio_episode:           raise StandardError(&quot;No episode has been assigned to the sequence: %s&quot; % hiero_sequence.name())       # For performance reasons, lets check if we've already added the episode to the cache and reuse it       # Its not a necessary step, but it speeds things up if we don't have to check  for the episode again       # this session.       if nuke_studio_episode.guid() in data[&quot;epi_cache&quot;]:           return data[&quot;epi_cache&quot;][nuke_studio_episode.guid()]       # episode not found in cache, grab it from  ShotGrid        sg = self.parent.shotgun       filters = [           [&quot;project&quot;, &quot;is&quot;, self.parent.context.project],           [&quot;code&quot;, &quot;is&quot;, nuke_studio_episode.name()],       ]       episodes = sg.find(&quot;Episode&quot;, filters, [&quot;code&quot;])       if len(episodes) &amp;gt; 1:           # can not handle multiple episodes with the same name           raise StandardError(&quot;Multiple episodes named '%s' found&quot; % nuke_studio_episode.name())       if len(episodes) == 0:           # no episode has previously been created with this name           # so we must create it in            epi_data = {               &quot;code&quot;: nuke_studio_episode.name(),               &quot;project&quot;: self.parent.context.project,           }           episode = sg.create(&quot;Episode&quot;, epi_data)           self.parent.log_info(&quot;Created Episode in  ShotGrid : %s&quot; % epi_data)       else:           # we found one episode matching this name in , so we will resuse it, instead of creating a new one           episode = episodes[0]       # update the cache with the results       data[&quot;epi_cache&quot;][nuke_studio_episode.guid()] = episode       return episode    def get_shot_parent(self, hiero_sequence, data, **kwargs):        &quot;&quot;&quot;        Given a Hiero sequence and data cache, return the corresponding entity        in  ShotGrid  to serve as the parent for contained Shots.        :param hiero_sequence: A Hiero sequence object        :param data: A dictionary with cached parent data.        .. note:: The data dict is typically the app's `preprocess_data` which maintains the cache across invocations of this hook.                        &quot;&quot;&quot;         # stick a lookup cache on the data object.         if &quot;parent_cache&quot; not in data:             data[&quot;parent_cache&quot;] = {}                 if hiero_sequence.guid() in data[&quot;parent_cache&quot;]:             return data[&quot;parent_cache&quot;][hiero_sequence.guid()]                 episode = self.get_episode(data, hiero_sequence)                 # parent not found in cache, grab it from  ShotGrid                  sg = self.parent.shotgun filter = [             [&quot;project&quot;, &quot;is&quot;, self.parent.context.project],             [&quot;code&quot;, &quot;is&quot;, hiero_sequence.name()],             [&quot;episode&quot;, &quot;is&quot;, episode],             ]                 # the entity type of the parent.         par_entity_type = &quot;Sequence&quot;                 parents = sg.find(par_entity_type, filter)         if len(parents) &amp;gt; 1:             # can not handle multiple parents with the same name             raise StandardError(                 &quot;Multiple %s entities named '%s' found&quot; % (par_entity_type, hiero_sequence.name())                 )                     if len(parents) == 0:             # create the parent in              par_data = {                 &quot;code&quot;: hiero_sequence.name(),                 &quot;project&quot;: self.parent.context.project,                 &quot;episode&quot;: episode,                 }                         parent = sg.create(par_entity_type, par_data)             self.parent.log_info(                 &quot;Created %s in  ShotGrid : %s&quot; % (par_entity_type, par_data)                )        else:             parent = parents[0]                         # update the thumbnail for the parent         upload_thumbnail = kwargs.get(&quot;upload_thumbnail&quot;, True)                 if upload_thumbnail:             self.parent.execute_hook(                 &quot;hook_upload_thumbnail&quot;, entity=parent, source=hiero_sequence, item=None             )                     # cache the results         data[&quot;parent_cache&quot;][hiero_sequence.guid()] = parent         return parent Getting the SequenceWith the code above, we’ve modified the get_shot_parent() method. It now uses the Episode returned from the new get_episode() method when finding and creating the Sequence. When checking for a pre-existing Sequence in the ShotGrid database it now filters by the episode&amp;lt;/code&amp;lt; field, and when it creates the Sequence, it populates the Sequence’s episode field with the Episode returned from get_episode().Getting the EpisodeSo how do you get the Episode? The get_episode() method code is very similar to the get_shot_parent() method but modified to retrieve the Episode instead of the Sequence.In this guide you are assigning the episode in Nuke Studio by using Tags. For example, you could create a Tag in Nuke Studio named “Ep01”. Then you would apply that Tag to the sequence in Nuke Studio.At a high level the get_episode() method looks at all of the Tags applied to the sequence item in Nuke Studio, and if it encounters one that starts with the string “Ep”, it assumes that is the tag defining the Episode name. The method then finds and returns the matching Episode from ShotGrid and creates it if it doesn’t yet exist. It also caches this information so it doesn’t have to perform the costly find call again.If you wanted to get the episode in a different way, for example from context or by taking the first section of the Sequence or Shot name, then use that logic in this method.Getting the ShotThe main purpose of the hiero_get_shot hook is to return the Shot data from ShotGrid. You don’t actually need to touch the logic for getting the shot, as you only need to modify how the Sequence got its parent. If you want to also link the Shot with the Episode through a custom field, then you would need to modify the code in the execute method as well. Access the Episode from the Sequence like parent[“episode”] and then link it up to the Shot in the create call.3. Hiero_resolve_custom_strings.pyThe second hook you need to take over is the hiero_resolve_custom_strings.py. This is so you can resolve the path for the Nuke Studio exports. Once again you will need to create the hook in the hooks folder and add the setting hook_resolve_custom_strings: {config}/hiero_resolve_custom_strings.py to your tk-hiero-export.yml file.The custom key {Episode}, which we added in step 1, will be passed to this hook, and the export app expects the resolved folder name to be returned. The hook needs to check if the passed key is {Episode}, and if it is, it will reuse the get_episode() method in the hiero_get_shot.py hook to get the Episode entity. Once it has the Episode, then the code can extract the name of the episode to generate the folder.Here is the full code for the hook:from sgtk import Hookclass HieroResolveCustomStrings(Hook):    &quot;&quot;&quot;Translates a keyword string into its resolved value for a given task.&quot;&quot;&quot;    # cache of shots that have already been pulled from     _sg_lookup_cache = {}    def execute(self, task, keyword, **kwargs):        &quot;&quot;&quot;        The default implementation of the custom resolver simply looks up        the keyword from the  shot dictionary.        For example, to pull the shot code, you would simply specify 'code'.        To pull the sequence code you would use 'sg_sequence.Sequence.code'.        &quot;&quot;&quot;        if keyword == &quot;{Episode}&quot;:            episode_entity = self.parent.execute_hook_method(                &quot;hook_get_shot&quot;,                &quot;get_episode&quot;,                data=self.parent.preprocess_data,                hiero_sequence=task._item.parentSequence(),            )            # hard coded to return the name of the episode            # if however your folder for the episode in the schema, is not just made up from the code field            # you need to get it to return what ever string value the folder would normally be created with.            return episode_entity['code']        shot_code = task._item.name()        # grab the shot from the cache, or the get_shot hook if not cached        sg_shot = self._sg_lookup_cache.get(shot_code)        if sg_shot is None:            fields = [ctf['keyword'] for ctf in self.parent.get_setting('custom_template_fields')]            sg_shot = self.parent.execute_hook(                &quot;hook_get_shot&quot;,                task=task,                item=task._item,                data=self.parent.preprocess_data,                fields=fields,                upload_thumbnail=False,            )            self._sg_lookup_cache[shot_code] = sg_shot        self.parent.log_info(&quot;_sg_lookup_cache: %s&quot; % (self._sg_lookup_cache))        if sg_shot is None:            raise RuntimeError(&quot;Could not find shot for custom resolver: %s&quot; % keyword)        # strip off the leading and trailing curly brackets        keyword = keyword[1:-1]        result = sg_shot.get(keyword, &quot;&quot;)        self.parent.log_debug(&quot;Custom resolver: %s[%s] -&amp;gt; %s&quot; % (shot_code, keyword, result))        return result Note that if your schema Episode folder name is generated from something other than just the code field, then you will need to replicate that name here.A more correct, but more complicated approach could be to add a episode_root template in the templates.yml, and then get the fields from the template. This would mean the returned folder name always matches the schema, even if you change the Episode folder name in the schema. It would look something like this:ctx = tk.context_from_entity(&quot;Episode&quot;, episode_entity[id])my_template = tk.templates[&quot;episode_root&quot;]fields = my_template.get_fields(ctx.filesystem_locations[0])return fields[&quot;Episode&quot;] Wrapping upThat should be it! All that’s left to do is test that our changes work correctly.Having started up Nuke Studio, created a project, and populated it with sequences and footage, you can now test the export process. First, create the Episode tag. Remember you coded the hook to look for tags on the Sequence that start with Ep , so you must name the tag Ep…Now add the Tag to the Sequence.Once that is done, export the Shots from your tagged Sequence.Check that the Export Structure hierarchy matches that of our schema. If it does not match, you may need to refresh the structure .Once you click export, it should then create your Episodes, Sequences, and Shots in your ShotGrid site, as well as the folder structure on disk. If you run into issues along the way, remember to check the Nuke Studio script editor or  ShotGrid logs (tk-nukestudio.log) for any errors that you might encounter.That completes this guide. Of course this is just one of the many ways to achieve working with episodes, and it’s up to you to figure out which approach and structure works best for your studio.Swapping Sequence for EpisodeAs briefly mentioned above, if you want to simply swap the default Sequence/Shot hierarchy for Episode/Shot, you can use the Nuke Studio Sequence item as the source of your Episode name.      Set up your schema and templates to work with an Episode/Shot structure.        Take over the default hiero_get_shot.py hook like shown above. However this time, change the parent_field variable value to sg_episode (make sure you have an episode field on your Shot entity) and the par_entity_type variable value to Episode.        Take over the hiero_translate_template.py hook and change the mapping in the hook file:   mapping = {   &quot;{Episode}&quot;: &quot;{sequence}&quot;,   &quot;{Shot}&quot;: &quot;{shot}&quot;,   &quot;{name}&quot;: &quot;{clip}&quot;,   &quot;{version}&quot;: &quot;{tk_version}&quot;,} The Episode key will get resolved with the Nuke Studio sequence key value.  Tip:  If you’ve opened your Hiero/Nuke Studio project before making these changes, or you’re testing while making the changes, then it’s possible you will need to reset the export path. Nuke Studio caches the export tree when you open the export dialog, so you will need to rebuild it by pressing the refresh button when you want your changes to the schema to be reloaded.",
    "url": "/459f67b7/",
    "relUrl": "/459f67b7/"
  },
  "47": {
    "id": "47",
    "title": "Failed to change work area - Error during execution of MEL script",
    "content": "Failed to change work area - Error during execution of MEL scriptUse CaseWhen creating a new special pipeline configuration for freelancers who don’t have access to the network, we created a new root name and pointed it to another path. The production pipeline configuration has the roots paths pointed to our file server.But when creating a new file with tk-multi-workfiles on Maya, the following error occurs:Failed to change work area - Error during execution of MEL script: file: C:/Program files/Autodesk/Maya2019/scripts/others/setProject.mel line 332: New project location C: VetorZero work Shotgun-workflow_completo sequences Seq_001 SH_010 ANIM maya is not a valid directory, project not created.Calling Procedure: setProject, in file “C: Program Files Shotgun c” set project(“C: Vetorzero work SHOTGUN-workflow_completo sequences Seq_001 SH_010 ANIM maya”)It created the folder, but it did not create the folder “maya”.How to fixCheck to make sure the the folder “maya” was not deleted by mistake. This error has been presented in cases where it was.Related linksSee the full thread in the community",
    "url": "/4f00a298/",
    "relUrl": "/4f00a298/"
  },
  "48": {
    "id": "48",
    "title": "API",
    "content": "APIregisterCallbacksA global level function in all plugins that is used to tell the framework about event processing entry points in the plugin.registerCallbacks(reg)  reg: The Registrar you will interact with to tell the framework which functions to call.RegistrarThe Registrar is the object used to tell the framework how to interact with a plugin. It is passed to the registerCallbacks function.AttributesloggerSee getLogger.MethodsgetLoggerGet the python Logger object used to log messages from within the plugin.setEmails(*emails)Set the emails that should receive error and critical notices when something bad happens in this plugin or any of its callbacks.To send emails to default addresses as specified in the configuration file (default)reg.setEmails(True)To disable emails (this is not suggested as you won’t get error messages)reg.setEmails(False)To send emails to specific addresses usereg.setEmails('user1@domain.com')orreg.setEmails('user1@domain.com', 'user2@domain.com')registerCallback(sgScriptName, sgScriptKey, callback, matchEvents=None, args=None, stopOnError=True)Register a callback into the engine for this plugin.  sgScriptName: The name of the script taken from the ShotGrid  scripts page.  sgScriptKey: The application key for the script taken from a ShotGrid  script page.  callback: A function or an object with a __call__ method. See exampleCallback.  matchEvents: A filter of events you want to have passed to your callback.  args: Any object you want the framework to pass back into your callback.  stopOnError: Boolean, should an exception in this callback halt processing of events by all callbacks in this plugin. Default is True.The sgScriptName is used to identify the plugin to ShotGrid. Any name can be shared across any number of callbacks or be unique for a single callback.The sgScriptKey is used to identify the plugin to ShotGrid and should be the appropriate key for the specified sgScriptName.The specified callback object will be invoked when an event that matches your filter needs processing. Although any callable should be able to run, using a class here is not suggested. Use of a function or an instance with a __call__ method is more appropriate.The matchEvent argument is a filter that allows you to specify which events the callback being registered is interrested in. If matchEvents is not specified or None is specified, all events will be passed to the callback. Otherwise each key in the matchEvents filter is an event type while each value is a list of possible attribute names.matchEvents = {    'Shotgun_Task_Change': ['sg_status_list'],}You can have multiple event types or attribute namesmatchEvents = {    'Shotgun_Task_Change': ['sg_status_list'],    'Shotgun_Version_Change': ['description', 'sg_status_list']}You can filter on any event type that has a given attribute namematchEvents = {    '*': ['sg_status_list'],}You can also filter on any attribute name for a given event typematchEvents = {    'Shotgun_Version_Change': ['*']}Although the following is valid and functionally equivalent to specifying nothing, it’s just really uselessmatchEvents = {    '*': ['*']}When matching against non field specific event types such as “_New” or “_Retirement”, you don’t provide a list, instead you pass None as the value.matchEvents = {    'Shotgun_Version_New': None}The args argument will not be used by the event framework itself but will simply be passed back to your callback without any modification.                    Note: The point of the args argument is for you to be able to process time consuming stuff in the registerCallbacks function and have it passed back to you at event processing time.    Another use of the args argument could be to pass in a common mutable, a dict for example, to multiple callbacks to have them share data.The stopOnError argument tells the system if an exception in this callback can cause event processing to stop for all callbacks in the plugin. By default this is True but can be switched to False. You will still get mail notifications of errors should there be any but processing of events will not stop. Being a per callback setting you can have some critical callbacks for whom this is True but others for whom this is False.CallbackAny plugin entry point registered by Registrar.registerCallback is generally a global level function that looks like this:exampleCallback(sg, logger, event, args)  sg: A ShotGrid connection instance.  logger: A Python logging.Logger object preconfigured for you.  event: A ShotGrid event to process.  args: The args argument specified at callback registration time.                    Note: Implementing a callback as a __call__ method on an object instance is possible but left as an exercise for the user.    ",
    "url": "/b04a53ae/",
    "relUrl": "/b04a53ae/"
  },
  "49": {
    "id": "49",
    "title": "Configuration",
    "content": "ConfigurationThe following guide will help you configure ShotGridEvents for your studio.Most of the configuration for ShotGridEvents is controlled by the shotgunEventDaemon.conf file. In this file, you’ll find several settings you can modify to match your needs. Most of them have defaults that will work fine for most studios, however, there are some settings that must be configured (specifically, your ShotGrid server URL, script name, and application key so the ShotGridEventDaemon can connect to your ShotGrid server).                    Note: For Windows: Windows users will need to change all the paths in the configuration file for Windows equivalents. We suggest keeping all paths, including logging, under one single location for the sake of simplicity. This documentation tends to refer to C: shotgun shotgunEvents when mentioning Windows paths.    Edit shotgunEventDaemon.confOnce you have installed ShotGridEvents, the next step is to open the shotgunEventDaemon.conf file in a text editor and modify the settings to match your studio’s needs. The defaults will be fine for most studios, however, there are some settings that have no defaults that will need to be provided by you before you can run the daemon.The items you must provide are:  your ShotGrid server URL  the Script name and Application key for connecting to ShotGrid  the full path to your plugins for the ShotGridEventDaemon to runOptionally, you can also specify an SMTP server and email-specific settings in order to setup email notification for errors. While this is optional, if you choose to set this up, you must provide all of the configuration values in the email section.There is also a section for an optional timing log which can help with troubleshooting if you ever encounter performance issues with your daemon. Enabling timing logging will populate its own separate log file with the timing information.ShotGrid SettingsUnderneath the [ShotGrid] section, replace the default tokens with the correct values for server, name, and key. These should be the same values you’d provide to a standard API script connecting to ShotGrid.Exampleserver: https://awesome.shotgunstudio.comname: ShotGridEventDaemonkey: e37d855e4824216573472846e0cb3e49c7f6f7b1Plugin SettingsYou will need to tell the ShotGridEventDaemon where to look for plugins to run. Under the [plugins] section replace the default token with the correct  value for paths.You can specify multiple locations (which may be useful if you have multiple departments or repositories using the daemon). The value here must be a full path to a readable existing directory.Examplepaths: /usr/local/shotgun/ShotGridEvents/pluginsWhen you’re first getting started, a good plugin to test with is the logArgs.py plugin located in the /usr/local/shotgun/ShotGridEvents/src/examplePlugins directory. Copy that into the plugins folder you specified and we’ll use that for testing things.Location of shotgunEventDaemon.confBy default, the daemon will look for the shotgunEventDaemon.conf file in the same directory that ShotGridEventDaemon.py is in, and in the /etc directory. If you need to put the conf file in another directory, it’s recommended you create a symlink to it from the current directory.                    Note: If for some reason the above won’t work for you, the search paths for the config file are located in the _getConfigPath() function at the bottom of the shotgunEventDaemon.py script                        Note: For Windows The /etc doesn’t exist on Windows so the configuration file should be put in the same directory as the Python files.    Testing the DaemonDaemons can be difficult to test since they run in the background. There isn’t always an obvious way to see what they’re doing. Lucky for us, the ShotGridEventDaemon has an option to run it as a foreground process. Now that we have done the minimum required setup, let’s go ahead and test the daemon and see how things go.                    Note: The default values used here may require root access (for example, to write to the/var/log directory). The examples provided use are run using sudo to accommodate this.    $ sudo ./ShotGridEventDaemon.py foregroundINFO:engine:Using ShotGrid version 3.0.8INFO:engine:Loading plugin at /usr/local/shotgun/ShotGridEvents/src/examplePlugins/logArgs.pyINFO:engine:Last event id (248429) from the ShotGrid database.You should see the lines above when you start the script (some of the details may differ obviously). If you get any errors, the script will terminate since we opted to run it in the foreground we’ll see that happen. Some common errors are displayed below if you get stuck.The logArgs.py plugin simply takes the event that occurred in ShotGrid and passes it to the logger. Not very exciting but it’s a simple way to ensure that the script is running and the plugin is working. If you’re at a busy studio, you may have already noticed a rapid stream of messages flowing by. If not, login to your ShotGrid server in your web browser and change some values or create something. You should see log statements printed out to your terminal window corresponding to the type of event you generated with your changes.                    Note: There are variables in the logArgs.py file that need to be filled in with appropriate values. ‘$DEMO_SCRIPT_NAMES$’ and ‘$DEMO_API_KEY$’ must be edited to contain the same values that were used in the shotgunEventDaemon.conf file in order for the logging to function correctly.    If you don’t see anything logged to the log file, check your log-related settings in ShotGridEventDaemon.conf to ensure that the logging value is set to log INFO level messageslogging: 20and the logArgs plugin is also configured to show INFO level messages. There is a line at the end of the registerCallbacks() method that should readreg.logger.setLevel(logging.INFO)Assuming all looks good, to stop the ShotGridEventDaemon process, simply type &amp;lt;ctrl&amp;gt;-c in the terminal and you should see the script terminate.Running the daemonAssuming all went well with your testing, we can now run the daemon as intended, in the background.$ sudo ./ShotGridEventDaemon.py startYou should see no output and control should have been returned to you in the terminal. We can make sure that things are running well in two ways. The first would be to check the running processes and see if this is one of them.$ ps -aux | grep shotgunEventDaemonkp              4029   0.0  0.0  2435492    192 s001  R+    9:37AM   0:00.00 grep shotgunEventDaemonroot            4020   0.0  0.1  2443824   4876   ??  S     9:36AM   0:00.02 /usr/bin/python ./ShotGridEventDaemon.py startWe can see by the second line returned that the daemon is running. The first line is matching the command we just ran. So we know it’s running, but to ensure that it’s working and the plugins are doing what they’re supposed to, we can look at the log files and see if there’s any output there.$ sudo tail -f /var/log/shotgunEventDaemon/shotgunEventDaemon2011-09-09 09:42:44,003 - engine - INFO - Using ShotGrid version 3.0.82011-09-09 09:42:44,006 - engine - INFO - Loading plugin at /usr/local/shotgun/ShotGrid/src/plugins/logArgs.py2011-09-09 09:42:44,199 - engine - DEBUG - Starting the event processing loop.Go back to your web browser and make some changes to an entity. Then head back to the terminal and look for output. You should see something like the following2011-09-09 09:42:44,003 - engine - INFO - Using ShotGrid version 3.0.82011-09-09 09:42:44,006 - engine - INFO - Loading plugin at /usr/local/shotgun/ShotGrid/src/plugins/logArgs.py2011-09-09 09:42:44,199 - engine - DEBUG - Starting the event processing loop.2011-09-09 09:45:31,228 - plugin.logArgs.logArgs - INFO - {'attribute_name': 'sg_status_list', 'event_type': 'Shotgun_Shot_Change', 'entity': {'type': 'Shot', 'name': 'bunny_010_0010', 'id': 860}, 'project': {'type': 'Project', 'name': 'Big Buck Bunny', 'id': 65}, 'meta': {'entity_id': 860, 'attribute_name': 'sg_status_list', 'entity_type': 'Shot', 'old_value': 'omt', 'new_value': 'ip', 'type': 'attribute_change'}, 'user': {'type': 'HumanUser', 'name': 'Kevin Porterfield', 'id': 35}, 'session_uuid': '450e4da2-dafa-11e0-9ba7-0023dffffeab', 'type': 'EventLogEntry', 'id': 276560}The exact details of your output will differ, but what you should see is that the plugin has done what it is supposed to do, that is, log the event to the logfile. Again, if you don’t see anything logged to the log file, check your log-related settings in ShotGridEventDaemon.conf to ensure that the loggingvalue is set to log INFO level messages and your logArgs plugin is also configured to show INFO level messages.A Note About LoggingIt should be noted that log rotation is a feature of the ShotGrid daemon. Logs are rotated at midnight every night and ten daily files are kept per plugin.Common ErrorsThe following are a few of the common errors that you can run into and how to resolve them. If you get really stuck, please visit our support site for help.Invalid path: $PLUGIN_PATHS$You need to specify the path to your plugins in the shotgunEventDaemon.conf file.Permission denied: ‘/var/log/shotgunEventDaemon’The daemon couldn’t open the log file for writing.You may need to run the daemon with sudo or as a user that has permissions to write to the log file specified by the logPath and logFile settings in shotgunEventDaemon.conf. (the default location is /var/log/shotgunEventDaemon which is usually owned by root.ImportError: No module named shotgun_api3The ShotGrid API is not installed. Make sure it is either located in the current directory or it is in a directory in your PYTHONPATH.If you have to run as sudo and you think you have the PYTHONPATH setup correctly, remember that sudo resets the environment variables. You can edit the sudoers  file to preserve the PYTHONPATH or run sudo -e(?)List of Configuration File SettingsDaemon SettingsThe following are general daemon operational settings.pidFileThe pidFile is the location where the daemon will store its process id while it is running. If this file is removed while the daemon is running, it will shut down cleanly after the next pass through the event processing loop.The directory must already exist and be writable. You can name the file whatever you like but we strongly recommend you use the default name as it matches with the process that is runningpidFile: /var/log/shotgunEventDaemon.pideventIdFileThe eventIdFile points to the location where the daemon will store the id of the last processed ShotGrid event. This will allow the daemon to pick up where it left off when it was last shutdown, thus it won’t miss any events. If you want to ignore any events since the last daemon shutdown, remove this file before starting up the daemon and the daemon will process only new events created after startup.This file keeps track of the last event id for each plugin and stores this information in pickle format.eventIdFile: /var/log/shotgunEventDaemon.idlogModeThe logging mode can be set to one of two values:  0 = all log messages in the main log file  1 = one main file for the engine, one file per pluginWhen using a value of 1, the log messages generated by the engine itself will be logged to the main log file specified by the logFile config setting. Any messages logged by a plugin will be placed in a file named plugin.&amp;lt;plugin_name&amp;gt;.logMode: 1logPathThe path where to put log files (both for the main engine and plugin log files). The name of the main log file is controlled by the logFilesetting below.logPath: /var/log/shotgunEventDaemon                    Note: The shotgunEventDaemon will have to have write permissions for this directory. In a typical setup, the daemon is set to run automatically when the machine starts up and is given root privileges at that point.    logFileThe name of the main daemon log file. Logging is configured to store up to  10 log files that rotate every night at midnight.logFile: shotgunEventDaemonloggingThe threshold level for log messages sent to the log files. This value is the default for the main dispatching engine and can be overridden on a per plugin basis. This value is simply passed to the Python logging module. The most common values are:  10: Debug  20: Info  30: Warnings  40: Error  50: Criticallogging: 20timing_logEnabling timing logging by setting this value to on will generate a separate log file with timing information which should make troubleshooting performance issues with your daemon simpler.The timing information provided for each callback invocation is as follows:  event_id The id of the event that triggered the callback  created_at The timestamp in ISO format when the event was created in ShotGrid  callback The name of the invoked callback in plugin.callback format  start The timestamp in ISO format of the start of callback processing  end The timestamp in ISO format of the end of callback processing  duration The duration in DD:HH:MM:SS.micro_second format of the callback processing time  error If the callback failed or not. The value can be False or True.  delay The duration in DD:HH:MM:SS.micro_second format of the delay between the event creation and the start of processing by the callback.conn_retry_sleepIf the connection to ShotGrid fails, this is the number of seconds to wait until the connection is re-attempted. This allows for occasional network hiccups, server restarts, application maintenance, etc.conn_retry_sleep = 60max_conn_retriesNumber of times to retry the connection before logging an error level message(which potentially sends an email if email notification is configured below).max_conn_retries = 5fetch_intervalThe number of seconds to wait before requesting new events after each batch of events is done being processed. This setting generally doesn’t need to be adjusted.fetch_interval = 5ShotGrid SettingsThe following are settings related to your ShotGrid instance.serverThe URL for the ShotGrid server to connect to.server: %(SG_ED_SITE_URL)s                    Note: There is no default value here. Set the SG_ED_SITE_URL environment variable to the URL for your ShotGrid server (ie. https://awesome.shotgunstudio.com)    nameThe ShotGrid Script name the ShotGridEventDaemon should connect with.name: %(SG_ED_SCRIPT_NAME)s                    Note: There is no default value here. Set the SG_ED_SCRIPT_NAME environment variable to the Script name for your ShotGrid server (ie. shotgunEventDaemon)    keyThe ShotGrid Application Key for the Script name specified above.key: %(SG_ED_API_KEY)s                    Note: There is no default value here. Set the SG_ED_API_KEY environment variable to the Application Key for your Script name above (ie:0123456789abcdef0123456789abcdef01234567)    use_session_uuidSets the session_uuid from every event in the ShotGrid instance to propagate in any events generated by plugins. This will allow the ShotGrid UI to display updates that occur as a result of a plugin.use_session_uuid: True  ShotGrid server v2.3+ is required for this feature.  ShotGrid API v3.0.5+ is required for this feature.                    Note: The ShotGrid UI will only show updates live for the browser session that spawned the original event. Other browser windows with the same page open will not see updates live.    Plugin SettingspathsA comma-delimited list of complete paths where the framework should look for plugins to load. Do not use relative paths.paths: /usr/local/shotgun/plugins                    Note: There is no default value here. You must set the value to the location(s) of your plugin files (ie:/usr/local/shotgun/shotgunEvents/plugins or C: shotgun shotgunEvents plugins on Windows)    Email SettingsThese are used for error reporting because we figured you wouldn’t constantly be tailing the log and would rather have an active notification system.Any error above level 40 (ERROR) will be reported via email if all of the settings are provided below.All of these values must be provided for there to be email alerts sent out.serverThe server that should be used for SMTP connections. The username and password values can be uncommented to supply credentials for the SMTP connection. If your server does not use authentication, you should comment out the settings for username and passwordserver: smtp.yourdomain.com                    Note: There is no default value here. You must replace the smtp.yourdomain.com token with the address of your SMTP server (ie. smtp.mystudio.com).    usernameIf your SMTP server requires authentication, uncomment this line and make sure you have configured the SG_ED_EMAIL_USERNAME environment variable with the username required to connect to your SMTP server.username: %(SG_ED_EMAIL_USERNAME)spasswordIf your SMTP server requires authentication, uncomment this line and make sure you have configured the SG_ED_EMAIL_PASSWORD environment variable with the password required to connect to your SMTP server.password: %(SG_ED_EMAIL_PASSWORD)sfromThe from address that should be used in emails.from: support@yourdomain.com                    Note: There is no default value here. You must replacesupport@yourdomain.com with a valid value (ie. noreply@mystudio.com).    toA comma-delimited list of email addresses to whom these alerts should be sent.to: you@yourdomain.com                    Note: There is no default value here. You must replace you@yourdomain.com with a valid value (ie. shotgun_admin@mystudio.com).    subjectAn email subject prefix that can be used by mail clients to help sort out alerts sent by the ShotGrid event framework.subject: [SG]",
    "url": "/ed5161c4/",
    "relUrl": "/ed5161c4/"
  },
  "50": {
    "id": "50",
    "title": "Example Plugins",
    "content": "Example PluginsThere is a folder of example plugins in the source code.This page includes a few more simple examples, for anyone looking to get started. You can copy/paste this code and it should run(Note: you’ll have to update the script_name, and script_key values to something specific for your installation)First, here’s a template upon which all SG event code should be written1. Code TemplateCopy / Paste this to get started on new plugins&quot;&quot;&quot;Necessary Documentation of the codeAuthor: YouTemplate Author: Andrew Britton&quot;&quot;&quot;def registerCallbacks(reg):    # This takes the form of:    #    matchEvents = {'Shotgun_Entity_EventType': ['list', 'of', 'field', 'names', 'you', 'need', 'sg_custom_field']}    # the 'id' is always returned, in addition to any fields specifically requested by your callback    matchEvents = {        'Shotgun_Task_Change': ['content']    }    # script_name and script_key are defined by you whenever you create a SG script    # the entry_function_call refers to the function that performs the work of the event plugin    reg.registerCallback('script_name', 'script_key', entry_function_call, matchEvents, None)# This gives you#    shotgun handle = sg#    a logger object... please use this instead of python print, especially if you respect your time and your fellow developers#    an event object... this is the metadata that describes what's happening with the particular event.#        some very good information comes from the event['meta'] object, below is the example event['meta'] data from the subject renamer plugin#              {#                &quot;type&quot;: &quot;attribute_change&quot;,#                &quot;attribute_name&quot;: &quot;subject&quot;,#                &quot;entity_type&quot;: &quot;Note&quot;,#                &quot;entity_id&quot;: 2,#                &quot;field_data_type&quot;: &quot;text&quot;,#                &quot;old_value&quot;: &quot;My Note Subject&quot;,#                &quot;new_value&quot;: &quot;2017-05 May-09 - My Note Subject&quot;#              }def entry_function_call(sg, logger, event, args):    # Now do stuff    pass   2. Note Subject RenamingWorking with New Entity EventsThis is a great one to start with  because it’s simple, but it also deals with a rather tricky aspect of catching Shotgun_Entity_New events…import timefrom pprint import pprintdef registerCallbacks(reg):    matchEvents = {        'Shotgun_Note_New': ['*'],    }    reg.registerCallback('script_name', 'script_key', Function_Name, matchEvents, None)def Function_Name(sg, logger, event, args):    # Waiting here should allow the entity to be fully created             #     and all the necessary attributes to be added to the NOTE entity    time.sleep(1)    current_date = time.strftime(&quot;%Y-%m %b-%d&quot;)    asset_id = event['meta']['entity_id']    asset_type = event['meta']['entity_type']    asset = sg.find_one(asset_type, [['id', 'is', asset_id]], ['subject'])    if asset['subject'] is None:        current_name = current_date + ' - ' + event['project']['name'] + ' - ' + event['user']['name']    else:        current_name = current_date + ' - ' + asset['subject']    # Modify ALL notes except those in 'Software Development'    if event['project'] == None:        logger.info('Updated Note ID is #%d, and is being prepended with &quot;%s&quot;', asset_id, current_date)        logger.info(event)        sg.update(asset_type, asset_id, {'subject': current_name})        return    if event['project']['id'] != 116:        logger.info('Updated Note ID is #%d, and is being prepended with &quot;%s&quot;', asset_id, current_date)        logger.info(event)        sg.update(asset_type, asset_id, {'subject': current_name})    else:        logger.info('Dates are not prepended for notes in project id 116 - Software Development')        returnNote the sleep call as the very first line of the function body. The reason for this deals with the way that new events are handled.  When a NEW entity is created in SG, it is still rather unformed - meaning that it doesn’t possess all the attributes needed to fully define that entity as you’re used to it. In fact, in this example, I can’t even guarantee that the subject attribute will be on the Note entity when SG emits the Shotgun_Note_New event.  In order to add all of the necessary attributes, SG then publishes a series of Shotgun_Note_Change events wherein SG will add every single attribute to the entity and update the values of those attributes - if required.  This means that a multiplicity of events are created, which means that if you need two different attributes to be present and you didn’t write a sleep aspect to your code, then you’d have to sift through ALL of the Shotgun_Note_Change events and the internal metadata looking for only those that have new attributes added and values set… This is a cumbersome process and will process many Shotgun_Note_Change events looking for - effectively - just one per note at time of creation.  The solution as I’ve found it is to rely on Shotgun_Entity_New and let the script sleep for a short period. At the end of the sleep, SG will have updated all the attributes required for the entity and then you can re-query that same entity for any of the fields you need2. Field Deletion WarningGenerating Notes, Working with Fields as Entities, and Entity Retirement Events&quot;&quot;&quot;Create a Note when a field is deletedAuthor: Andrew Britton&quot;&quot;&quot;def registerCallbacks(reg):    &quot;&quot;&quot;    fn: registerCallbacks    @brief required function. It connects to the event daemon and calls the trashedFieldWarning Function.    It runs every time a field is deleted (retired)    @param[in] reg variable that is required by shotgun event daemon plugins    @return none    &quot;&quot;&quot;    matchEvents = {        'Shotgun_DisplayColumn_Retirement': ['*']    }    reg.registerCallback('script_name', 'script_key',                         trashedFieldWarning, matchEvents, None)def CreateNote(sg, logger, event):    constants = {'note header': ':: FIELD DELETION :: '}    def GetListOfPipelineUsers():        pipeline_users = sg.find('Group', [['code', 'is', 'People_Who_Need_to_Know']], ['code', 'users', 'addressings_to',                                                                         'sg_ticket_type', 'sg_priority'])        return pipeline_users[0]['users']    def CreateToolsNote():        # Note to members of the pipeline group        # Body text = CreateNoteRequestText()        # Date Created = event['event']['created_at']        # Created By = event['user']['id']        # Project = Software Development['id']        # Subject = ':: Field Delete Warning :: ' + event['entity']['name']        note_data = {            'project': {'type': 'Project', 'id': 'ID OF PROJECT WHERE YOU WANT THE NOTE REPORTED TO'},            # ex: 'project': {'type': 'Project', 'id': 2},            'content': CreateNoteRequestText(),            'created_at': event['created_at'],            'created_by': event['user'],            'addressings_to': GetListOfPipelineUsers(),            'subject': constants['note header'] + event['meta']['display_name']        }        sg.create('Note', note_data)    def CreateNoteRequestText():        OUT = ''        # Tool Name = event['entity']['name']        # sg_assigned_to = members of the pipeline group        # Description = linked Ticket decription        # Project = decided in GUI        # sg_sg_request_ticket = event['entity']['id']        # task_template = Software task template        # Software Projects = defined in GUI        OUT = '::FIELD DELETION WARNING:: n'        OUT += ':: A Field was deleted :: n'        OUT += ':: It was called %s :: n'%event['meta']['display_name']        return OUT    logger.info('::WARNING:: A FIELD has been deleted')    CreateToolsNote()def trashedFieldWarning(sg, logger, event, args):    &quot;&quot;&quot;    fn: finalizeTasksFromShot    @brief Function to create and send a warning note, via SG, whenever a field is deleted    event['entity']['id'] yields the id of the current entity that was caught by the plugin as having been changed.    ie. this is the id of the field that was just deleted    @param[in] sg defines the Shotgun handle to access the database    @param[in] logger sets logging messages to the shotgun event daemon    @param[in] event the collection of shots that have changed    @param[in] args useless variable for this particular function    @return none    &quot;&quot;&quot;    if event['meta']['entity_type'] == 'DisplayColumn':        logger.info('This DisplayColumn was deleted %s', event['meta']['display_name'])    if event['event_type'] == 'Shotgun_DisplayColumn_Retirement':        logger.info('The incoming event call is for deleting a field from an entity. Field name: %s', event['meta']['display_name'])    # logger.info(' TEST ')    # logger.info('Deleted Field ID is #%d, and is called: %s', event['entity']['id'], event['entity']['name'])    CreateNote(sg, logger, event)This is a very simple script. There is no special logic in checking for deleted fields. If a field is deleted, then a note is created and sent to a group of people that need to know. In my department, we have the group id set to the ‘programmers’ group, and the project id of the note set to the ‘development’ project.",
    "url": "/34048d1e/",
    "relUrl": "/34048d1e/"
  },
  "51": {
    "id": "51",
    "title": "Installation",
    "content": "InstallationThe following guide will help you setup ShotGridEvents for your studio.System RequirementsThe daemon can run on any machine that has Python installed and has network access to your ShotGrid server. It does not need to run on the ShotGrid server itself. In fact, if you are using the hosted version of ShotGrid, this isn’t an option. However, you may run it on your ShotGrid server if you like. Otherwise, any server will do.  Python v2.6, v2.7 or 3.7  ShotGrid Python API          Use v3.1.0+ for Python 3.7+ (note: Python 2 is no longer supported).      In either case, we strongly suggest using the most up to date Python API version and keeping this dependency updated over time.        Network access to your ShotGrid serverInstalling the ShotGrid APIAssuming Python is already installed on your machine, you now need to install the ShotGrid Python API so that the ShotGrid Event Daemon can use it to connect to your ShotGrid server. You can do this in a couple of ways:  place it in the same directory as the ShotGrid Event Daemon  place it in one of the directories specified by the PYTHONPATH environment variable.To test that the ShotGrid API is installed correctly, from your terminal window:$ python -c &quot;import shotgun_api3&quot;You should see no output. If you see something like the output below then you need to make sure your PYTHONPATH is setup correctly or that the ShotGrid API is located in the current directory.$ python -c &quot;import shotgun_api3&quot;Traceback (most recent call last):File &quot;&amp;lt;string&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;ImportError: No module named shotgun_api3Installing ShotGridEventsThe location you choose to install ShotGridEvents is really up to you. Again, as long as Python and the ShotGrid API are installed on the machine, and it has network access to your ShotGrid server, it can run from anywhere. However, it makes sense to install it somehwere that is logical to your studio, something like /usr/local/shotgun/shotgunEvents seems logical so we’ll use that as the example from here on out.The source and archives are available on GitHub at https://github.com/shotgunsoftware/shotgunEvents                    Note: For Windows: You could use C: shotgun shotgunEvents if you have a Windows server but for this documentation we will be using the Linux path.    Cloning the sourceThe easiest way to grab the source if you have git installed on the machine is to simply clone the project. This way you can also easily pull in any updates that are committed to ensure you stay up to date with bug fixes and new features.$ cd /usr/local/shotgun$ git clone git://github.com/shotgunsoftware/shotgunEvents.git                    Warning: Always make sure you backup your configuration, plugins, and any modifications you make to shotgunEvents before pulling in updates from GitHub so you don’t lose anything. Or, fork the project yourself so you can maintain your own repository of changes :)    Downloading the archiveIf you don’t have git on your machine or you simply would rather download an archive of the source, you can get things rolling following these steps.  head over to https://github.com/shotgunsoftware/shotgunEvents/  download the source in the format you want  save it to your machine  extract the files to the /usr/local/shotgun directory  rename the /usr/local/shotgun/shotgunsoftware-shotgunEvents-xxxxxxx directory to /usr/local/shotgun/shotgunEventsExtracting the archive into /usr/local/shotgun.For .tar.gz archives:$ tar -zxvf shotgunsoftware-shotgunEvents-v0.9-12-g1c0c3eb.tar.gz -C /usr/local/shotgunFor .zip archives:$ unzip shotgunsoftware-shotgunEvents-v0.9-12-g1c0c3eb.zip -d /usr/local/shotgunThen you can rename the GitHub-assigned directory name to shotgunEvents:$ mv shotgunsoftware-shotgunEvents-1c0c3eb shotgunEventsNow you should now have something like this:$ ls -l /usr/local/shotgun/shotgunEventstotal 16-rw-r--r--  1 kp  wheel  1127 Sep  1 17:46 LICENSE-rw-r--r--  1 kp  wheel   268 Sep  1 17:46 README.mkddrwxr-xr-x  9 kp  wheel   306 Sep  1 17:46 docsdrwxr-xr-x  6 kp  wheel   204 Sep  1 17:46 srcInstalling RequirementsA requirements.txt file is provided at the root of the repository. You should use this to install the required packages$ pip install -r /path/to/requirements.txtWindows specificsYou will need one of the following on your Windows system:  Python with PyWin32 installed  Active PythonActive Python ships with the PyWin32 module which is required for integrating the ShotGrid Event Daemon with Windows’ Service architecture.You can then install the deamon as a service by running the following command (we are assuming that C: Python27_32 python.exe is the path to your Python executable, adjust accrodingly):&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py installOr remove it with:&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py removeStarting and stopping the service can be achieved through the normal service management tools or via the command line with:&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py start&amp;gt; C: Python27_32 python.exe shotgunEventDaemon.py stopIn most cases you will need to be sure you are running each of the commands listed as your system’s administrative user. You can do so by right clicking the cmd application and choosing “Run as Administrator”.                    Note: If you have installed the daemon on Windows in a network location or if you have configured it to read and write logs and other resources from a network location you will need to edit the service’s properties to change the user running the service from the local machine account to a domain account that has access to the network resources.    ",
    "url": "/7c203655/",
    "relUrl": "/7c203655/"
  },
  "52": {
    "id": "52",
    "title": "Plugins",
    "content": "Plugins OverviewA plugin file is any .py file in a plugin path as specified in the config file.There are some example plugins provided in the src/examplePlugins folder in your download of the code. These provide simple examples of how to build your own plugins to look for specific events generated, and act on them, changing other values on your ShotGrid instance.You do not need to restart the daemon each time you make updates to a plugin, the daemon will detect that the plugin has been updated and reload it automatically.If a plugin generates an error, it will not cause the daemon to crash. The plugin will be disabled until it is updated again (hopefully fixed). Any other plugins will continue to run and events will continue to be processed. The daemon will keep track of the last event id that the broken plugin processed successfully. When it is updated (and fixed, hopefully), the daemon will reload it and attempt to process events starting from where that plugin left off. Assuming all is well again, the daemon will catch the plugin up to the current event and then continue to process events with all plugins as normal.A ShotGrid event processing plugin has two main parts: a callback registration function and any number of callbacks.registerCallbacks functionTo be loaded by the framework, your plugin should at least implement the following function:def registerCallbacks(reg):    passThis function will be used to tell the event processing system which functions to call to process events.This function should take one argument which is a Registrar object.The Registrar has one critically important method:Registrar.registerCallback.For each of your functions that should process ShotGrid events, call Registrar.registerCallback once with the appropriate arguments.You can register as many functions as you wish and not all functions in the file need to be registered as event processing callbacks.CallbacksA callback that will be registered with the system must take four arguments:  A ShotGrid connection instance if you need to query ShotGrid for additional information.  A Python Logger object that should be used for reporting. Error and Critical messages will be sent via email to any configured user.  The ShotGrid event to be processed.  The args value passed in at callback registration time. (See Registrar.registerCallback)                    Warning: You can do whatever you want in a plugin but if any exception raises back to the framework, the plugin within which the offending callback lives (and all contained callbacks) will be deactivated until the file on disk is changed (read: fixed).    LoggingUsing the print statement in an event plugin is not recommended. It is prefered you use the standard logging module from the Python standard library. A logger object will be provided to your various functionsdef registerCallbacks(reg):    reg.setEmails('root@domain.com', 'tech@domain.com') # Optional    reg.logger.info('Info')    reg.logger.error('Error') # ERROR and above will be sent via email in default configanddef exampleCallback(sg, logger, event, args):    logger.info('Info message')If the event framework is running as a daemon this will be logged to a file otherwise it will be logged to stdout.Building Robust pluginsThe daemon runs queries against ShotGrid but has built in functionality to retry find() commands should they fail, giving the daemon itself a certain degree of robustness.https://github.com/shotgunsoftware/shotgunEvents/blob/master/src/shotgunEventDaemon.py#L456If a plugin needs network resources (be that ShotGrid or some other resource), it needs to provide its own retry mechanisms / robustness. In the case of ShotGrid access you could riff off what’s in the daemon and make a helper function or class that could provide that functionality to your plugins.The ShotGrid Python API does already do some level of retrying on network issues but should you hit a ShotGrid maintenance window that can run a few minutes, or be unlucky enough to hit a network blip, that might not be enough.https://github.com/shotgunsoftware/python-api/blob/master/shotgun_api3/shotgun.py#L1554Depending on what your plugin does, you can also register it to just keep trucking should it encounter issues while processing events. Look at the stopOnError argument of the registerCallback function:https://github.com/shotgunsoftware/shotgunEvents/wiki/API#wiki-registerCallback                    Note: The plugin won’t stop but any failed attempts won’t be retried.    ",
    "url": "/3d05c112/",
    "relUrl": "/3d05c112/"
  },
  "53": {
    "id": "53",
    "title": "Technical Details",
    "content": "Technical OverviewEvent TypesThe event types your triggers can register to be notified of are generally respect the following form Shotgun_[entity_type]_[New|Change|Retirement|Revival]. Here are a few examples of this pattern:Shotgun_Note_NewShotgun_Shot_NewShotgun_Task_ChangeShotgun_CustomEntity06_ChangeShotgun_Playlist_RetirementShotgun_Playlist_RevivalSome notable departures from this pattern are used for events that aren’t related to entity record activity but rather key points in application behavior.CRS_PlaylistShare_CreateCRS_PlaylistShare_Revoke SG_RV_Session_Validate_SuccessShotgun_Attachment_ViewShotgun_Big_QueryShotgun_NotesApp_Summary_EmailShotgun_User_FailedLoginShotgun_User_LoginShotgun_User_LogoutToolkit_App_StartupToolkit_Desktop_ProjectLaunchToolkit_Desktop_AppLaunchToolkit_Folders_CreateToolkit_Folders_Delete    This list is not exhaustive but is a good place to start. If you wish to know more about the activity and event types on your ShotGrid site, please consult a page of EventLogEntries where you can filter and search through like any other grid page of any other entity type.Event Log Entries for ThumbnailsWhen a new thumbnail is uploaded for an entity, an Event Log entry is created with `Type` == `Shotgun_&amp;lt;Entity_Type&amp;gt;_Change` (e.g. Shotgun_Shot_Change).  The ‘is_transient’ field value is set to true:    { &quot;type&quot;: &quot;attribute_change&quot;,&quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: null, &quot;new_value&quot;: 11656,  &quot;is_transient&quot;: true }        When the thumbnail becomes available, a new Event Log entry is created with the ‘is_transient’ field value now set to false:    { &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;, &quot;old_value&quot;: null, &quot;new_value&quot;: 11656, &quot;is_transient&quot;: false }        If we update the thumbnail again, we get these new Event Log entries:    { &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;, &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;,  &quot;old_value&quot;: 11656, &quot;new_value&quot;: 11657,  &quot;is_transient&quot;: true }{ &quot;type&quot;: &quot;attribute_change&quot;, &quot;attribute_name&quot;: &quot;image&quot;,  &quot;entity_type&quot;: &quot;Shot&quot;, &quot;entity_id&quot;: 1286, &quot;field_data_type&quot;: &quot;image&quot;,  &quot;old_value&quot;: null, &quot;new_value&quot;: 11657,  &quot;is_transient&quot;: false }        Notice the ‘old_value’ field is set to null when the attachment’s thumbnail is the placeholder thumbnail.Plugin Processing OrderEach event is always processed in the same predictable order so that if any plugins or callbacks are co-dependant, you can safely organize their processing.The configuration file specifies a paths config that contains one or multiple plugin locations. The earlier the location in the list the sooner the contained plugins will be processed.Each plugin within a plugin path is then processed in ascending alphabetical order.                    Note: Internally the filenames are put in a list and sorted.    Finally, each callback registered by a plugin is called in registration order. First registered, first run.We suggested keeping any functionality that needs to share state somehow in the same plugin as one or multiple callbacks.Sharing stateMany options exist for multiple callbacks that need to share state.  Global variables. Ick. Please don’t do this.  An imported module that holds the state information. Ick, but a bit better than simple globals.  A mutable passed in the args argument when calling Registrar.registerCallback. A state object of your design or something as simple as a dict. Preferred.  Implement callbacks such as __call__ on object instances and provide some shared state object at callback object initialization. Most powerful yet most convoluted method. May be redundant compared to the args argument method above.Event BacklogsThe framework is designed to have every plugin process every single event they are interested in exactly once, without exception. To make sure this happens, the framework stores a backlog of unprocessed events for each plugin and remembers the last event each plugin was provided. Here is a description of situations in which a backlog may occur.Backlogs due to gaps in the event log entry sequenceEach event that occurs in ShotGrid (field update, entity creation, entity retirement, etc.) has a unique ID number for its event log entry. Sometimes there are gaps in the ID number sequence. These gaps can occur for many reasons, one of them being a large database transaction that has not yet been completed.Every time there is a gap in the event log sequence the “missing” event IDs are put into a backlog for later processing. This allows for the event daemon to process the events from a long database transaction once it has finished.Sometimes the gap in the event log sequence will never be filled in, such as with a failed transaction or reverted page setting modifications. In this case, after a 5 minute timeout, the system will stop waiting for the event log entry ID number and will remove it from the backlog. When this happens you will see a “Timeout elapsed on backlog event id #” message. If the first time a gap in the event sequence is seen and it is already deemed to have exceeded the timeout, the message will appear as “Event # never happened - ignoring” and it won’t be put in the backlog in the first place.Backlogs due to plugin errorsDuring normal operation, the framework is always tracking the last event that was processed by each plugin. If you have a plugin that fails for any reason it will stop processing further events. When you fix the plugin, by fixing a bug for example, the framework will start processing events at the last event stored for the fixed plugin. This is done in order to make sure the newly fixed plugin gets to process all events, including those that have occurred in the past between the failure and the fix. If the failure occurred long ago, this may mean a lot of events need to be revisited and it may take a while for the fixed plugin to catch up with the other plugins that were functioning normally.While your fixed plugin plays catch-up, the other plugins will be ignoring these events in order to make sure no single event is processed twice by the same plugins. This leads to the “Event X is too old. Last event processed is (Y)” message. This is a debug message and can be safely ignored.There is no formal way to sidestep this. The framework is designed to make sure every single plugin processes every event once and only once. However, If you are familiar with Python and its pickle data format, you can stop the daemon, open the .id file with a Python interpreter/interactive shell, decode its contents with the pickle modules and edit its contents to remove the stored id thus skipping the accrued backlog. This is unsupported and at your own risk. Please backup the .id file appropriately before you do this.",
    "url": "/af5c969c/",
    "relUrl": "/af5c969c/"
  },
  "54": {
    "id": "54",
    "title": "Writing Event-Driven Triggers",
    "content": "ShotGrid Event FrameworkThis software was originaly developed by Patrick Boucher with support from Rodeo Fx and Oblique. It is now part of ShotGrid Software’s open source initiative.This software is provided under the MIT License that can be found in the LICENSE file or at the Open Source Initiative website.Content:  Overview  Advantages of the framework  Writing event driven triggers          Example use cases      How event driven triggers work      Polling the EventLog versus triggers      Event types      Transactions and potentially missing events      OverviewWhen you want to access the ShotGrid event stream, the preferred way to do so it to monitor the events table, get any new events, process them and repeat.A lot of stuff is required for this process to work successfully, stuff that may not have any direct bearing on the business rules that need to be applied.The role of the framework is to keep any tedious monitoring tasks out of the hands of the business logic implementor.The framework is a daemon process that runs on a server and monitors the ShotGrid event stream. When events are found, the daemon hands the events out to a series of registered plugins. Each plugin can process the event as it wishes.The daemon handles:  Registering plugins from one or more specified paths.  Deactivate any crashing plugins.  Reloading plugins when they change on disk.  Monitoring the ShotGrid event stream.  Remembering the last processed event id and any backlog.  Starting from the last processed event id on daemon startup.  Catching any connection errors.  Logging information to stdout, file or email as required.  Creating a connection to ShotGrid that will be used by the callback.  Handing off events to registered callbacks.A plugin handles:  Registering any number of callbacks into the framework.  Processing a single event when one is provided by the framework.Advantages of the framework  Only deal with a single monitoring mechanism for all scripts, not one perscript.  Minimize network and database load (only one monitor that supplies event tomany event processing plugins).Writing event driven triggersNote: For more information about event driven triggers, please see our documentation at https://github.com/shotgunsoftware/shotgunEvents .ShotGrid creates an event log entry for every action that happens in ShotGrid. You can see these events in your ShotGrid site, as well as through the ShotGrid API.In addition to seeing a detailed history of events in ShotGrid, you can write your own event listener Scripts to poll the EventLog and act on certain events you care about. Your Script can execute other internal Scripts in your pipeline, or it can use the ShotGrid API and update other information in ShotGrid, or both.Example use casesHere are some examples of using event driven triggers:  Automatically set the ‘Animation’ Task status to ’ready to start’ whenever the status for a Shot’s ‘Layout’ Task is marked as ‘final’, so the animator knows to start working on the Shot.  Create the appropriate Shot directories on the filesystem whenever a new Shot is created in ShotGrid.  Notify the artists assigned to a Shot if it goes ‘on hold’  Make a directory read-only when an Asset is finaled.  Copy relevant Version (or Take) information to a dailies system when the Version is added to a Review in ShotGrid.  Twitter a random quote that begins with the same letter as the third word in a Scene’s description field when the Scene grows to 25 shots.How event driven triggers workBelow is a simple diagram of EventLogEntries generated by ShotGrid. Your Script will use the API to get a list of events that have occurred since the last time it asked. It will then look at each event type (e.g., ShotGrid_Task_Change) and see if any of them are ones that you care about.Once it finds an event that is interesting, it will examine the details of the event even further (e.g., what field was changed, what the value was changed to, etc. At this point you can even use the API to request more information for an entity if you need to).If the event proves worthy, the Script will then act on the event and execute whatever code you decide needs to be executed whether its using the ShotGrid API, or something in your pipeline, or both. When there are no more events to look at, it repeats the process and use the API to get a list of events that have occurred since the last time you asked.Polling the EventLog versus triggersShotGrid provides a constant stream of event information and you can listen to it all and act only on the events you care about. This provides the following advantages over having ShotGrid control triggers itself:  Flexible : Your trigger Scripts can run independent of ShotGrid. This allows your Script to interact both with ShotGrid and your pipeline in any way you want. You define the rules and actions as you wish without being bound by any constraints. ShotGrid doesn’t need to know anything about the event triggers you have. All it needs to do is keep generating the EventLogEntries. You control every other aspect of what happens next.  Remote : Your Scripts can run from anywhere that has network access to the ShotGrid server. Your Script simply needs API access to run.  Multiplicity : You can have multiple Scripts running concurrently. Different departments may have different needs and thus be listening for different events. There’s no restriction saying that all triggers be run from the same Script. You may wish to break up your triggers into separate logical Scripts. The polling query is very light and doesn’t have any noticeable impact on performance.  Accountability : If your Scripts make changes to ShotGrid, they too create their own events, allowing you to see exactly what Scripts made changes.Event typesAll internal event types follow the format Shotgun_[entity_type]_[New|Change|Retirement]. Some examples are Shotgun_Shot_New and Shotgun_Asset_Change. For more information, see the Event types documentation.Transactions and potentially missing eventsShotGrid executes destructive database queries in transactions and only writes to the EventLog when the transaction is complete. Because of this, it’s possible that you may miss events using the “highest ID” method here. However, the Event Trigger Framework on our GitHub site has code that should handle these situations.",
    "url": "/0d8a11d9/",
    "relUrl": "/0d8a11d9/"
  },
  "55": {
    "id": "55",
    "title": "Features Description",
    "content": "Isolation Feature SetThis section describes in detail each of the Isolation Features.To get the onboarding process started, go to Onboarding Process.To start the setup for any of the Isolation features, go to the Setup section.In This Section  Media Isolation  Media Traffic Isolation  Media Replication",
    "url": "/82f8da29/",
    "relUrl": "/82f8da29/"
  },
  "56": {
    "id": "56",
    "title": "Filesystem Configuration Reference",
    "content": "File System Configuration ReferenceIn this topic:  Introduction  Part 1 - Folder Creation Syntax          Query Folders      Multiple folders      Create With Parent Folder      Optional fields      Regular expression token matching      Examples      List Field Folders      Pipeline Step Folder                  Different file system layouts for different pipeline steps                    Advanced - Specifying a parent      Task Folder                  Advanced - Specify a parent                    Workspaces and Deferred Folder Creation      Current User Folder      Static folders      Symbolic Links      Ignoring files and folders      Customizing IO and Permissions                  Data passed to the hook          Passing your own folder creation directives to the hook          Adding custom configuration to static folders                    Simple customization of how folders are created        Part 2 - Configuring File System Templates          The Keys Section                  Example - An alphanumeric name          Example - Version number          Example - A stereo eye          Example - Image sequences          Example - Two fields both named version via an alias          Example - Timestamp          Example - mappings          Example - String field with two valid values          Example - Disallowing a value          Example - Subsets of strings                    The Paths Section      The Strings Section      Using Optional Keys in Templates        Advanced questions and troubleshooting          How can I add a new entity type to my file structure?                  Fields required for the Episode &amp;gt; Sequence &amp;gt; Shot hierarchy                          Episode              Sequence              Shot              Episodes              Toolkit template definitions                                          How can I set up a branch in my structure?      How can I create a custom Pipeline Step?      This document is a complete reference of the file system centric configurations in the ShotGrid Pipeline Toolkit. It outlines how the template system works and which options are available. It also shows all the different parameters you can include in the folder creation configuration.Please note that this document describes functionality only available if you have taken control over a Toolkit configuration. For details, see  ShotGrid Integrations Admin Guide.IntroductionThis document explains how to configure the part of Toolkit’s configuration related to your file system, including examples. Toolkit handles a lot of files and directories, and you can leverage Toolkit’s configuration as a way of expressing how paths are put together and what they mean. The file system is typically accessed in two different and completely separate ways:Folder Creation: After an object has been created in ShotGrid, folders on disk need to be created before work can begin. This can be as simple as having a folder on disk representing the Shot, or can be more complex-for example setting up a user specific work sandbox so that each user that works on the shot will work in a separate area on disk.  Toolkit automates folder creation when you launch an application (for example you launch Maya for shot BECH_0010), Toolkit ensures that folders exist prior to launching Maya. If folders do not exist, they are created on the fly. Folders can also be created using API methods, using the  tank command in the shell  and via the  Create Folders menu in ShotGrid. A special set of configuration files drives this folder creation process and this is outlined in  Part 1  of the document below.Opening and Saving Work: While working, files need to be opened from and saved into standardized locations on disk. These file locations typically exist within the folder structure created prior to work beginning.  Once a folder structure has been established, we can use that structure to identify key locations on disk. These locations are called  Templates. For example, you can define a template called  maya_shot_publish  to refer to published Maya files for Shots.  Toolkit apps  will then use this template-a publish app may use it to control where it should be writing its files, while a  Workfiles App  may use the template to understand where to open files from. Inside Toolkit’s environment configuration, you can control which templates each app uses. All the key file locations used by Toolkit are therefore defined in a single template file and are easy to overview.Part 1 - Folder Creation SyntaxThe folder configuration maps entities in ShotGrid to locations on disk. Rather than using a single configuration file, the configuration is in the form of a “mini file system” which acts as a template for each unit that is configured-this is called the schema configuration. Folders and files will be copied across from this “mini file system” to their target location when Toolkit’s folder creation executes. It is possible to create dynamic behavior. For example, a folder can represent a Shot in ShotGrid, and you can control the naming of that folder. More specifically, you can pull the name of that folder from several ShotGrid fields and then perform character conversions before the folder is created.The above image shows a schema configuration. When you run the Toolkit folder creation, a connection is established between an entity in ShotGrid and a folder on disk. Toolkit uses this folder schema configuration to generate a series of folders on disk and each of these folders are registered as a  Filesystem Location  entity in ShotGrid. One way to think about this is that ShotGrid data (e.g., Shot and Asset names) and the configuration is “baked” out into actual folders on disk and in ShotGrid. Configurations always start with a folder named “project”. This will always represent the connected project in ShotGrid and will be replaced with the Toolkit name for the project. Below this level are static folders. The folder creator will automatically create the sequencesfolder, for example.Digging further inside the sequences folder, there is a sequence folder and a sequence.yml file. Whenever Toolkit detects a YAML file with the same name as a folder, it will read the contents of the YAML file and add the desired dynamic behavior. In this case, the sequence.yml file contains the structure underneath the project folder, which consists of three types of items:  Normal folders and files: these are simply copied across to the target location.  A folder with a YAML file (having the same name as the folder): this represents dynamic content. For example, there may be a shot and shot.yml and when folders are created, this shot folder is the template used to generate a number of folders-one folder per shot.  A file named name.symlink.yml which will generate a symbolic link as folders are being processed.  Symbolic links are covered later in this document.The dynamic configuration setup expressed in the YAML files currently supports the following modes:      ShotGrid Query folders: Dynamic folder names based on a ShotGrid Database Query. For example, this mode can be used to create a folder for every Shot in a project.        ShotGrid List Field folders: Dynamic folder names based on a ShotGrid List Field. For example, this mode can be used to create a folder for every value in the ShotGrid List field “Asset Type”, found on the Asset Entity in ShotGrid.        Deferred folders: Only executed when a second folder creation pass is requested via the create folders method of the Toolkit API, usually when an application (such as Maya) is launched. Typically, this method is executed by Toolkit’s various application launchers just prior to starting up an application.        Current User Folders: A special folder, which represents the current user.  Let’s dive deeper into these modes.Query FoldersFor a dynamic folder which corresponds to a ShotGrid query, use the following syntax in your YAML file:# the type of dynamic contenttype: shotgun_entity# the ShotGrid entity type to connect toentity_type: Asset# the ShotGrid field to use for the folder namename: code# ShotGrid filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std ShotGrid API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]   Set the value of dynamic content type field to be shotgun_entity.  The entity_type field should be set to the ShotGrid entity from which we want to pull data from (e.g., “Asset”, “Shot”, “Sequence”, “CustomEntity02”, etc).      The name field is the name that should be given to each folder based on the data in ShotGrid.    You can use a single field, like in the example above (e.g.,  name: code).  You can use multiple fields in brackets (e.g.,  name:  &quot;{asset_type}_{code}&quot;).  If you want to include fields from other linked entities, you can use the standard ShotGrid dot syntax (e.g.,  name: &quot;{sg_sequence.Sequence.code}_{code}&quot;).  The filters field is a ShotGrid Query. It follows the  ShotGrid API syntax  relatively closely. It is a list of dictionaries, and each dictionary needs to have the keys  path,  relation, and  values. Valid values for $syntax are any ancestor folder that has a corresponding ShotGrid entity (e.g.,  &quot;$project&quot;  for the Project and  &quot;$sequence&quot;  if you have a sequence.yml higher up the directory hierarchy). For ShotGrid entity links, you can use the $syntax (e.g.,  { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }) to refer to a parent folder in the configuration-this is explained more in depth in the  examples below.Multiple foldersInclude a slash in your name definition in order to create an expression which creates multiple folders at once:# the type of dynamic contenttype: shotgun_entity# the ShotGrid entity type to connect toentity_type: Asset# the ShotGrid field to use for the folder namename: &quot;{sg_asset_type}/{code}&quot;# ShotGrid filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std ShotGrid API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ] When creating a file system template (see for a Part 2 of this document for details) for this kind of path, the  _last_folder will represent the ShotGrid entity. The example above could for example be expressed with the following templateasset_step_folder: assets/{asset_type}/{Asset}/{Step}{asset_type}  and  {Asset}  are both defined as string template keys and the  {Asset}  token will be used in context calculations when determining the context for a given path.Create With Parent FolderIn ShotGrid, there is nesting within ShotGrid data structures. This nesting can be referred to as a Parent to Child relationship, and vice versa. For instance, Sequences are typically parents to Shots in the file system, and likewise, Shots are typically Children to Sequences.                    Note: This filesystem nesting relationship is independent from the  ShotGrid Hierarchy, and there is no connection between the two. They are configured completely independently.    A shotgun_entity type folder supports an optional flag to control whether the folder creation process tries to recurse down into it when a parent is created, so that the child will also be created. Flags are settings that can only have certain fixed values, in this case “true” or “false”. To add this flag, use this example:# recurse down from parent foldercreate_with_parent: true As mentioned, this setting is optional and set to false by default. If you set it to true, Toolkit create folders for any child entity it finds. To continue with our example, if you want Shots to be created whenever their parent Sequence is created, set  create_with_parent  to  true  for the Shot.                    Note: the default setting is  false, meaning that if you create folders for a Sequence, shot folders will not be created automatically. Also, you will need to add this flag to make it true. There will not be a flag in the shotgun_entity folder specifying false since false is the default behavior.    Optional fieldsTypically, when you define the folder name (e.g.,  {code}_{sg_extra_field}), Toolkit requires all fields to have values in ShotGrid. For example, if the  sg_extra_field  is blank, an error message will be generated. If you have a field that is sometimes populated and sometimes not, you can mark it as optional. This means that Toolkit will include the field if it has a value, and exclude it if the value is blank-without error.You define optional fields using square brackets, like:  {code}[_{sg_extra_field}]. This will generate the following folder names:  If the  code  is BECH_0010 and the  sg_extra_field  is extra, the folder name will be  BECH_0010_extra.  If the  code  is BECH_0010 and the  sg_extra_field  is blank, the folder name will be  BECH_0010.                    Note: optional fields can only be used to define part of the name of a folder in your schema. An entire folder can not be optional.    Regular expression token matchingToolkit supports the extraction of parts of a ShotGrid field name using regular expressions. This makes it possible to create simple expressions where a value in ShotGrid can drive the folder creation. For example, if all assets in ShotGrid are named with a three letter prefix followed by an underscore (e.g  AAT_Boulder7), this can split into two filesystem folder levels, e.g.  AAT/Boulder7:# the type of dynamic contenttype: shotgun_entity# the ShotGrid entity type to connect toentity_type: Asset# Extract parts of the name using regular expressionsname: &quot;{code:^([^_]+)}/{code^[^_]+_(.*)}&quot;# ShotGrid filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std ShotGrid API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]The syntax is similar to the  subset  tokens in the Template system; Simply add a colon after the ShotGrid field name, then followed by a regular expression. Any groups (e.g. sections surrounded by  ()s) defined in the regular expression will be used to extract values. If there are multiple groups in the regex, these will be concatenated together. For example, the following expression would extract the intials for the user who created an object:  {created_by.HumanUser.code:^([A-Z])[a-z]* ([A-Z])[a-z]*}ExamplesBelow are a collection of examples showing how to use the filters syntax.To find all shots which belong to the current project and are in progress, use the syntax below. Note that the ShotGrid Shot entity has a link field called project which connects a shot to a project. We want to make sure that we only create folders for the shots that are associated with the current project. Since there is a project level higher up in the configuration file system, we can refer to this via the $syntax and Toolkit will automatically create to this ShotGrid entity link reference. Remember, valid values for $syntax are any ancestor folder that has a corresponding ShotGrid entity (e.g.,  &quot;$project&quot;  for the Project and  &quot;$sequence&quot;  if you have a sequence.yml higher up the directory hierarchy).entity_type: Shotfilters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;status&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;ip&quot; ] }If you have a Sequence folder higher up the tree and want to create folders for all Shots which belong to that Sequence, you can create the following filters:entity_type: Shotfilters:    - { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] }    - { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] }To find all assets use this syntax:entity_type: Assetfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]List Field FoldersShotGrid list field  folders are useful if you want to create one folder for every asset type in ShotGrid, for instance. Asset types are list fields in ShotGrid, and this folder config type makes it possible to define a layer in the file system that reflects those asset type listings.                    Note: once folders have been created on disk, we strongly advise not to change the value (e.g., the asset type) on the associated data.    When you want a dynamic folder which corresponds to all the items in a ShotGrid list field, use the following syntax in your YAML file:# the type of dynamic contenttype: &quot;shotgun_list_field&quot;# the ShotGrid entity type to connect toentity_type: &quot;Asset&quot;# only create for values which are used in this project.# this is optional and will be set to false if not specified.skip_unused: false# by default, list fields are only created if they are needed by a child entity node# by setting the create_with_parent parameter to true you ensure that list field# nodes are always createdcreate_with_parent: false# the ShotGrid field to use for the folder namefield_name: &quot;{sg_asset_type}_type&quot;  Set value of dynamic content type field to be  shotgun_list_field.  The  entity_type  field should be set to the ShotGrid entity from which we want to pull data (for instance, “Asset”, “Sequence”, “Shot”, etc.).      The  field_name  field should be set to the ShotGrid field from which the data is pulled from and must be a  list type field. You can use expressions if you want to add static text alongside the dynamic content.field_name: &quot;{sg_asset_type}_type&quot;  This example expression includes text as well as a template key.    The optional  skip_unused  parameter will prevent the creation of directories for list type field values which are not used (as covered under the  Optional Fields  section above).                    Note: setting this to True may negatively affect folder creation performance. Also, the culling algorithm is currently crude and does not work in scenarios where complex filters have been applied to the associated entity.      The optional  create_with_parent  parameter forces the creation of the list_field node, even if there isn’t a child entity level node that is currently being processed (see  Create With Parent Folder  section above).Pipeline Step FolderThe Pipeline Step folder represents a  Pipeline Step  in ShotGrid. Pipeline Steps are also referred to as Steps.# the type of dynamic contenttype: &quot;shotgun_step&quot;# the ShotGrid field to use for the folder name. This field needs to come from a step entity.name: &quot;short_name&quot;You can use name expressions here, just like you can with the  ShotGrid entity described above. The node will look at its parent, grandparent, etc., until a ShotGrid entity folder configuration is found. This entity folder will be associated with the Step and the type of the entity will be used to determine which Steps to create.                    Note: If you want to create a top level folder with Pipeline Steps, just use the ShotGrid entity node and set the associated type to step.    By default, the Step folder will try to create all the relevant Steps for a particular entity automatically. For example, if the folder creation is triggered for a shot which has five Steps (Layout, Animation, FX, Lighting, Compositing), Step folders will automatically be created for those five Steps (Layout, Animation, FX, Lighting, Compositing).You can, however, turn this off by using the following syntax:# recurse down from parent foldercreate_with_parent: falseAdding this setting to the configuration means that no Step folders will be created when a Shot folder is created. Instead, Step folders will be created only when you run the folder creation on a Task. This can be useful if you want to configure user sandboxes and other structures which are created just before work starts.Different file system layouts for different pipeline stepsImagine you want to have one folder structure for Lighting and Comp and one for everything else. If you want to have different file system layouts for different Pipeline Steps, you can achieve this by adding a  filter  clause to your config. This filter allows you to scope which Pipeline Steps will be covered by a particular Step’s configuration. In our example, you can create two configuration files:  step_lightcomp.yml  and  step.yml. In the first one, you would add the following filter:filters: [ { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;in&quot;, &quot;values&quot;: [ &quot;Light&quot;, &quot;Comp&quot;  ] } ] The above syntax will only be used when Step folders of the type  Light  or  Comp  are being created. For the other file, we want to create a rule for everything else:filters: [ { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;not_in&quot;, &quot;values&quot;: [ &quot;Light&quot;, &quot;Comp&quot;  ] } ]Now you can define separate sub structures in each of these folders.Advanced - Specifying a parentAs part of the folder creation, Toolkit needs to associate a Pipeline Step with an entity (e.g., “Shot”, “Asset”, etc). Toolkit does this by default by looking up the folder tree and picking the first ShotGrid entity folder it finds. For example, if you have the hierarchy  Sequence &amp;gt; Shot &amp;gt; Step, the Step folder will automatically be associated with the Shot, which is typically what you want.However, if you have a hierarchy with entities below your primary entity, for example  Sequence &amp;gt; Shot &amp;gt; Department &amp;gt; Step, Toolkit will, by default, associate the Step with the Department level, which is not desired. In this case, we need to explicitly tell Toolkit where to look. We can do this by adding the following to the Step configuration:associated_entity_type: ShotTask FolderThe Task folder represents a  Task  in ShotGrid. By default, the Task folder will not will not be created with its parent. For example, if the folder creation is triggered for a Shot which has a Task node associated, the Task folders will not be created automatically. Instead, Task folders will only be created when the folder creation is executed for the Task (e.g., launching a Task from ShotGrid).# the type of dynamic contenttype: &quot;shotgun_task&quot;# the ShotGrid field to use for the folder name. This field needs to come from a task entity.name: &quot;content&quot; You can, however, turn on creation so that Tasks are created with their parent entity by using the following syntax:# recurse down from parent foldercreate_with_parent: trueSimilar to a Step, you can also optionally supply a  filter  parameter if you want to filter which Tasks your folder configuration should operate on.Once again, you can use name expressions, just like you can with the  ShotGrid entity described above, where static text can be used alongside dynamic content so that you can create a name that has both dynamic and static context.name: &quot;task_{content}&quot;The node will look at its parent, grandparent etc., until a ShotGrid entity folder configuration is found. This entity folder will be associated with the task and will be used to determine which task folders to create.Advanced - Specify a parentAs part of the folder creation, Toolkit needs to associate a Task with an entity (e.g., a Shot, an Asset, etc.). Toolkit does this by default by looking up the folder tree and picking the first ShotGrid entity folder it finds. For example, if you have the hierarchy  Sequence &amp;gt; Shot &amp;gt; Task, the Task folder will automatically be associated with the Shot, which is typically what you want.However, if you have a hierarchy with entities below your primary entity (e.g., below Shot), like  Sequence &amp;gt; Shot &amp;gt; Department &amp;gt; Task,  Toolkit would by default associate the Task with the department level, which is not desired. In this case, we need to explicitly tell Toolkit where to look, similarly to how we updated this with Steps in the  previous section. We can do this by adding the following to the Task configuration:associated_entity_type: ShotWorkspaces and Deferred Folder CreationDeferred folder creation means that creation will only be executed when a second folder creation pass is requested via the optional  engine  parameter in the create folders method of the Toolkit API. Typically, this method is executed by Toolkit’s various application launchers just prior to starting up an application. Most folder types support a deferred flag, which is  false  by default. To make deferred folder creation  true, you can add this flag:# only create this folder when tk.create_filesystem_structure is# called with tk-maya, tk-nuke or any-custom-string.defer_creation: [&quot;tk-maya&quot;, &quot;tk-nuke&quot;, &quot;any-custom-string]# create this folder when any application launches, but not when normal folder# creation runsdefer_creation: trueThis flag makes it possible to split the folder creation in half-one part that runs in a first “global” pass and a second pass that runs at a later point. Typically, the second pass is associated with the engine launching (although it does not happen automatically since the default is  false) and allows for a user to create folders just before engine startup. This allows for two primary workflows:  Workspaces: Application specific folder setups. Folders can be created just before an application launches.  A common workflow for this is to have a Pipeline Step that might require Houdini, Maya, and another Engine, depending on what the shot requires and how an Artist chooses to tackle it. The Artist can create maya/, houdini/, and other directories for that Pipeline Step initially, but if the Artist on a given shot only ever works in Maya, empty folders for Houdini and any other Engine are unnecessary. So, if you defer the folder creation to happen at the time of the launch of individual engines, then if an Artist never uses Houdini, the houdini/ folder will not be created for that shot.  User folders: A user folder is created just before application launch. The user folder config construct (described above) is deferred by default.  This can happen so that instead of basing a user folder on the assigned user in ShotGrid, you can create a folder for the current user whenever they launch an Engine. For instance, if you start working on a shot, and you launch Maya, a username folder will be created for you (based on your username in ShotGrid), and you will not interfere with anyone else’s work.Tip: If you prefer a normal, static folder to be created when an application (like Maya) launches, just create a config YAML file named the same as the folder and add the following:# type of contenttype: &quot;static&quot;# only create this folder for mayadefer_creation: &quot;tk-maya&quot;# type of contenttype: &quot;static&quot;# only create this folder when tk.create_filesystem_structure is# called with any-custom-string.defer_creation: &quot;any-custom-string&quot; Current User FolderThe current user folder is a special construct that lets you set up work areas for different users. A common scenario is if you have multiple artists from a department working on the same shot. User folders can be used so that artists can store their workfiles in their own directories and be able to filter just for their files in the  Workfiles App. In this case, the configuration file needs to include the following options:# the type of dynamic contenttype: &quot;user_workspace&quot;name: &quot;login&quot;  Set value of type field to be  user_workspace.  The name field is the name that should be given to a user folder. It must consist of a combination of fields fetched from People in ShotGrid (HumanUser  in ShotGrid).  You can use a single field, like in the example above (e.g.,  name: login).  You can use multiple fields in brackets (e.g.,  name: &quot;{firstname}_{lastname}&quot;).  If you want to include fields from other linked entities, you can use the standard ShotGrid dot syntax (e.g.,  name: &quot;{sg_group.Group.code}_{login}&quot;).The current user folder is created as a deferred folder by default, meaning that it will only be executed when a second folder creation pass is requested via the optional  engine  parameter in the create folders method of the Toolkit API.Static foldersStatic folders (and files) are the most simple type. You can drop them into the configuration structure, and they will automatically get copied across when the folder creation process executes.  Here are some examples of static folders  (https://github.com/shotgunsoftware/tk-config-default/tree/master/core/schema/project) in the default configuration (note that static folders do not have a corresponding YAML file).Often, you will not need to go beyond this for static folders; however, Toolkit does support some more advanced functionality for static folders. It is possible to define dynamic conditions to determine if a static folder should get created. For example, you may want to have special static folders that only get created for Pipeline Steps of the Editorial type. In this case, you need to add a YAML configuration file next to the static folder and give it the same name, with the extension “yml”. Then, use the following syntax:# the type of dynamic contenttype: &quot;static&quot;# pick one of the ShotGrid folders that are above this folder# in the folder hierarchy. In this case it is a parent folder# named step that we want to look at when deciding if this# static folder should be created or not.constrain_by_entity: &quot;$step&quot;# we can now define constraints for this step. Constraints are simple# ShotGrid queries, following the same syntax as the other ShotGrid filters# shown in previous sections.# In our example, if the parent step matches the constraints given# in the filter below, the static folder will be created. If not,# it (and its children) will be ignored by the folder creation process.constraints:    - { &quot;path&quot;: &quot;short_name&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;edit&quot; ] } By default, static folders will automatically get created together with their parent folder. There may be cases where this is not desirable, and in those cases you can add a special flag to indicate that the static folder should not be created together with its parent:# do not recurse down automaticallycreate_with_parent: falseSymbolic LinksYou can create symbolic links (symlink) as part of the dynamic folder creation. If you want to create a symbolic link with the name  artwork, create a file in your schema configuration named  artwork.symlink.yml. This will be identified by the system as a symbolic link request and will not be copied across, but will instead be processed.The  artwork.symlink.yml  file must, at the very least, contain a  target  key:# Example of a .symlink.yml file# A target parameter is required.target: &quot;../Stuff/$Project/$Shot&quot;# Additional parameters will be passed to the hook as metadata# so you can for example include permission hints or other stuff# that you may need for advanced customizationadditional_param1: abcadditional_param2: def If the target parameter contains  $EntityType  tokens such as  $Asset,  $Shot, or  $Project, these will attempt to be resolved with the name of the folder representing that entity (Asset, Shot, Project, etc.). Toolkit will look up the filesystem tree for these values and if they are not defined higher up in the tree, an error will be reported.List fields, such as asset type on assets, are expressed with a syntax that includes the entity type, e.g.  $Asset.sg_asset_type. For example:# Example of a .symlink.yml file# A target parameter is required.target: &quot;../renders/$Project/$Asset.sg_asset_type/$Asset&quot;Symlink creation happens (like all input/output, or I/O) inside the folder processing hook. A special  symlinkaction is passed from the system into the hook, and you will get the name of the symlink, the fully resolved target, and all the YAML metadata contained within the definition file along with this request. For our  artworkexample above, we create the folder under the Shot like this: {'action': 'symlink',  'path': '/mnt/projects/chasing_the_light/Sequences/AA/AA001/artwork'  'target': '../Stuff/chasing_the_light/AA001',  'metadata': {'target': '../Stuff/$Project/$Shot', 'additional_param1': 'abc', 'additional_param2': 'def'}  }Ignoring files and foldersFiles that are placed in the schema scaffold will be copied across into the target area as part of the folder creation. This copy process is handled by a core hook, so for example, permissions handling can be customized for a project or studio.                    Note: There are more details on this kind of handling in the  Customizing I/O and Permissions sectionCustomizing I/O and Permissions section under Simple Customization. We have a  process_folder_creation core hook  (https://github.com/shotgunsoftware/tk-core/blob/master/hooks/process_folder_creation.py#L62-L71) that handles a lot of folder setup. You can add chmod calls into this hook (and/or set permissions as you mkdir), thereby setting permissions for the folders you are creating.    Sometimes it can be useful to exclude certain files and folders from being copied across as part of the folder creation. For example, if you store your folder creation configs in Git or SVN, you will have  .git  and  .svnfolders that you will not want to copy to each Shot or Asset folder. If there are files which you do not want to have copied, a file named  ignore_files  can be placed in the  config/core/schema  folder inside the project configuration. This file should contain glob-style patterns to define files not to copy. Each pattern should be on a separate line:# This is a good example of a standard ignore_files file.svn                # no svn temp files to be copied across at folder creation time.git                # no git temp files to be copied across at folder creation time.DS_Store           # no mac temp files to be copied across at folder creation timeYou can also use wildcards. For example, if you need to exclude all files with the TMP extension, just add a *.tmp line to the file.# This is a good example of a standard ignore_files file.svn                # no svn temp files to be copied across at folder creation time.git                # no git temp files to be copied across at folder creation time*.tmp           # no files with tmp extension to be copied across at folder creation timeCustomizing IO and PermissionsShot and Asset folders often need to be created with special permissions and parameters. Sometimes this is as simple as setting permission bits during the folder creation, and sometimes it may be as complex as sending a remote request to a special folder creation server that will create the folders with the appropriate credentials, groups, and permissions.It is also common that folders on different levels in the file system tree need to have different permissions; a work area folder is typically writeable for everybody, whereas a shot folder may have much stricter permissions.Toolkit allows for customization of the folder creation via a single hook. This is a core hook and it is named  process_folder_creation.py. As the folder creation API call is traversing the folder configuration and deciding which folders should be created, it builds up a list of items that could be created. These items can be both files and folders. As the final step of the folder creation, this list is passed to a hook to handle the actual folder processing. You can examine the default  process_folder_creation core hook here(https://github.com/shotgunsoftware/tk-core/blob/master/hooks/process_folder_creation.py#L62-L71).Data passed to the hookThe folder creation hook is executed just once for each folder creation request. All the folder creation data is passed in a list to the hook and the hook typically loops over this and creates the folders according to the parameters passed from the Core API.The data in the list is always a depth first recursion, starting with the top level folders and files and then traversing deeper and deeper. Here is an example of what the data passed to the hook may look like:    [         {'action': 'entity_folder',      'entity': {'id': 88, 'name': 'Chasing the Light', 'type': 'Project'},      'metadata': {'root_name': 'primary', 'type': 'project'},      'path': '/mnt/projects/chasing_the_light'},         {'action': 'folder',      'metadata': {'type': 'static'},      'path': '/mnt/projects/chasing_the_light/sequences'},         {'action': 'entity_folder',      'entity': {'id': 32, 'name': 'aa2', 'type': 'Sequence'},      'metadata': {'entity_type': 'Sequence',                   'filters': [{'path': 'project',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04c90&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'path': '/mnt/projects/chasing_the_light/sequences/aa2'},         {'action': 'entity_folder',      'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'},         {'action': 'copy',      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'source_path': '/mnt/software/tank/chasing_the_light/config/core/schema/project/sequences/sequence/shot/sgtk_overrides.yml',      'target_path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87/sgtk_overrides.yml'},         {'action': 'create_file',      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'content': 'foo bar',      'target_path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87/automatic_content.txt'},         {'action': 'symlink',      'path': '/mnt/projects/chasing_the_light/Sequences/AA/AA001/artwork'      'target': '../Stuff/chasing_the_light/AA001',      'metadata': {'target': '../Stuff/$Project/$Shot', 'additional_param1': 'abc', 'additional_param2': 'def'}      },        ]The data is a list of dictionaries. Each dictionary has a key called  action. This key denotes the type of I/O item that is requested. If you are implementing the folder creation hook, you need to add support for the following different actions:  entity_folder: A folder on disk which is associated with a ShotGrid entity.  folder: A folder on disk.  copy: A file that needs to be copied from a source location to a target location.  create_file:- A file that needs to be created on disk.  symlink: A symbolic link should be created.Each of the actions have a different set of dictionary keys. For example, the  entity_folder  action has an  entity key  which contains the details of the entity that it is connected to. The  create_file  has a  source_path  and a  target_path  key which inform the hook which file to copy and where.All  actions  also have a key called  metadata. This key represents the YAML configuration data that comes from the associated configuration file in the schema setup. You can see in the example above how the  metadata  key for a ShotGrid folder contains all the filter and naming information that is set up within the schema configuration. For example, here is the metadata for the Shot folder in the example above:    {'action': 'entity_folder',      'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity'},      'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'} …which corresponds to the  shot.yml  schema configuration file:# Copyright (c) 2013 ShotGrid Software Inc.## CONFIDENTIAL AND PROPRIETARY## This work is provided &quot;AS IS&quot; and subject to the ShotGrid Pipeline Toolkit# Source Code License included in this distribution package. See LICENSE.# By accessing, using, copying or modifying this work you indicate your# agreement to the ShotGrid Pipeline Toolkit Source Code License. All rights# not expressly granted therein are reserved by ShotGrid Software Inc.# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the ShotGrid field to use for the folder namename: &quot;code&quot;# the ShotGrid entity type to connect toentity_type: &quot;Shot&quot;# ShotGrid filters to apply when getting the list of items# this should be a list of dicts, each dict containing# three fields: path, relation and values# (this is std ShotGrid API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ] Note that the dynamic token  $sequence  has been resolved into an actual object at runtime.Passing your own folder creation directives to the hookIn addition to the various configuration directives required by Toolkit, you can also define your own configuration items as part of the schema configuration. These are passed into the hook via the  metadata  key described above, and can be used to drive folder creation.For example, if you had the following structure in your schema setup:# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the ShotGrid field to use for the folder namename: &quot;code&quot;# the ShotGrid entity type to connect toentity_type: &quot;Shot&quot;# ShotGrid filters to apply when getting the list of itemsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ]# user settingsstudio_permissions_level: &quot;admin&quot; …the data passed via the folder creation hook would be:    {'action': 'entity_folder',      'entity': {'id': 1184, 'name': 'moo87', 'type': 'Shot'},      'metadata': {'entity_type': 'Shot',                   'filters': [{'path': 'sg_sequence',                                'relation': 'is',                                'values': [&amp;lt;tank.folder.folder_types.FilterExpressionToken object at 0x10ca04b10&amp;gt;]}],                   'name': 'code',                   'type': 'shotgun_entity',                   'studio_permissions_level': 'admin'},      'path': '/mnt/projects/chasing_the_light/sequences/aa2/moo87'} Now the special parameter  studio_permissions_level  is passed into the hook and you can use that, for example, to control file permissions. You can also pass arbitrarily complex data structures using this method. A typical usecase for this would be to control permissions at a very detailed level.Adding custom configuration to static foldersTypically, when you create a folder inside the folder schema configuration, and it does not have a corresponding YAML file, Toolkit will assume that it is a static folder and will simply create it.If you would like to associate custom configuration metadata with a static folder, you have to create a YAML configuration file with the  static  type. For example, let’s say you have a static  assets  folder just under the project root and would like to group together assets and add custom configuration metadata. To achieve this, create the following  assets.yml  file:type: staticstudio_permissions_level: &quot;admin&quot;The configuration data passed to the hook will then contain the following:{'action': 'folder', 'metadata': {'studio_permissions_level': 'admin', 'type': 'static'}, 'path': '/mnt/projects/chasing_the_light/assets'},Again, arbitrarily complex data can be passed from the YAML configuration file into the hook in this way.Simple customization of how folders are createdA simple folder creation hook could look something like this:    class ProcessFolderCreation(Hook):            def execute(self, items, preview_mode, **kwargs):            &quot;&quot;&quot;     The default implementation creates folders recursively using open permissions.         This hook should return a list of created items.         Items is a list of dictionaries. Each dictionary can be of the following type:         Standard Folder     ---------------     This represents a standard folder in the file system which is not associated     with anything in ShotGrid. It contains the following keys:         * &quot;action&quot;: &quot;folder&quot;     * &quot;metadata&quot;: The configuration yaml data for this item     * &quot;path&quot;: path on disk to the item         Entity Folder     -------------     This represents a folder in the file system which is associated with a     ShotGrid entity. It contains the following keys:         * &quot;action&quot;: &quot;entity_folder&quot;     * &quot;metadata&quot;: The configuration yaml data for this item     * &quot;path&quot;: path on disk to the item     * &quot;entity&quot;: ShotGrid entity link dict with keys type, id and name.         File Copy     ---------     This represents a file copy operation which should be carried out.     It contains the following keys:         * &quot;action&quot;: &quot;copy&quot;     * &quot;metadata&quot;: The configuration yaml data associated with the directory level     on which this object exists.     * &quot;source_path&quot;: location of the file that should be copied     * &quot;target_path&quot;: target location to where the file should be copied.         File Creation     -------------     This is similar to the file copy, but instead of a source path, a chunk     of data is specified. It contains the following keys:         * &quot;action&quot;: &quot;create_file&quot;     * &quot;metadata&quot;: The configuration yaml data associated with the directory level     on which this object exists.     * &quot;content&quot;: file content     * &quot;target_path&quot;: target location to where the file should be copied.         &quot;&quot;&quot;                # set the umask so that we get true permissions            old_umask = os.umask(0)            folders = []            try:                    # loop through our list of items                for i in items:                        action = i.get(&quot;action&quot;)                        if action == &quot;entity_folder&quot; or action == &quot;folder&quot;:                        # folder creation                        path = i.get(&quot;path&quot;)                        if not os.path.exists(path):                            if not preview_mode:                                # create the folder using open permissions                                os.makedirs(path, 0777)                            folders.append(path)                        elif action == &quot;copy&quot;:                        # a file copy                        source_path = i.get(&quot;source_path&quot;)                        target_path = i.get(&quot;target_path&quot;)                        if not os.path.exists(target_path):                            if not preview_mode:                                # do a standard file copy                                shutil.copy(source_path, target_path)                                # set permissions to open                                os.chmod(target_path, 0666)                            folders.append(target_path)                        elif action == &quot;create_file&quot;:                        # create a new file based on content                        path = i.get(&quot;path&quot;)                        parent_folder = os.path.dirname(path)                        content = i.get(&quot;content&quot;)                        if not os.path.exists(parent_folder) and not preview_mode:                            os.makedirs(parent_folder, 0777)                        if not os.path.exists(path):                            if not preview_mode:                                # create the file                                fp = open(path, &quot;wb&quot;)                                fp.write(content)                                fp.close()                                # and set permissions to open                                os.chmod(path, 0666)                            folders.append(path)                        else:                        raise Exception(&quot;Unknown folder hook action '%s'&quot; % action)                finally:                # reset umask                os.umask(old_umask)                return folders Part 2 - Configuring File System TemplatesThe Toolkit templates file is one of the hubs of the Toolkit configuration. There is always one of these files per project and it resides inside the config/core folder inside your pipeline configuration.This file contains definitions for  templates  and their  keys.A key is a dynamic field we defined. It can be a name, a version number, a screen resolution, a shot name etc. Keys are configured with types, so we can define that a key should be a string or an int for example. They are also formatted, so we can define that a string should only contain alpha numeric characters, or that all integers should be padded with eight zeroes.A template is a dynamic path. An example of a template is  shots/{shot}/publish/{name}.{version}.ma. This template could for represent maya publishes for a shot - the bracketed fields are keys.The templates file is divided into three sections: keys, paths and strings.The Keys SectionKeys define what values are acceptable for fields. In the template config file keys are defined in the form:key_name:   type: key_type   option: option_value   option: option_value Key type is either  str,  int, or  sequence. Str keys are keys whose values are strings, int keys are keys whose values are integers, and sequence keys are keys whose values are sequences of integers.In addition to specifying the type, you can also specify additional options. The following options exist:      default: default_value  - Value used if no value was supplied. This can happen if you are using the Toolkit API and trying to resolve a set of field values into a path for example.        choices: [choice1, choice2, etc]  - An enumeration of possible values for this key.        exclusions: [bad1, bad2, etc]  - An enumeration of forbidden values for this key. If key is of type sequence, frame spec values cannot be invalidated with this setting.        length: 12  - This key needs to be of an exact length.        alias: new_name  - Provides a name which will be used by templates using this key rather than the key_name. For example if you have two concepts of a version number, one is four zero padded because that is how the client wants it, and one is three zero padded because that how it is handled internally - in this case you really want both keys named “version” but this is not really possible since key names need to be unique. In this case you can create an alias. See one of the examples below for more information.        filter_by: alphanumeric  - Only works for keys of type string. If this option is specified, only strings containing alphanumeric values (typically a-z, A-Z and 0-9 for ascii strings but may include other characters if your input data is unicode) will be considered valid values.        filter_by: alpha  - Only works for keys of type string. If this option is specified, only strings containing alpha values (typically a-z, A-Z for ascii strings but may include other characters if your input data is unicode) will be considered valid values.        filter_by: '^[0-9]{4}_[a-z]{3}$'  - Only works for keys of type string. You can define a regular expression as a validation mask. The above example would for example require the key to have four digits, then an underscore and finally three lower case letters.        format_spec: &quot;04&quot;  - For keys of type int and sequence, this setting means that the int or sequence number will be zero or space padded. Specifying “04” like in the example will result in a four digit long zero padded number (e.g. 0003). Specifying “03” would result in three digit long zero padded number (e.g. 042), etc. Specifying “3” would result in three digit long space padded number (e.g. “ 3”). For keys of type timestamp, the format_spec follows the  strftime and strptime convention.        strict_matching: true  - Only works for keys of type type int. This settings means that the field will only match numbers that have been properly formatted. For example, given “003” and strict_matching set to true, we would match “002”, “12345” and “042”, but not “00003” or “2”. If you need the matching to be less strict, set strict_matching to false. The default behavior is to strictly match.        shotgun_entity_type  - When used in conjunction with the  shotgun_field_name  option, will cause contexts to query ShotGrid directly for values. This allows using values from fields not seen in the folder structure to be used in file names.        shotgun_field_name  - Only used in conjunction with  shotgun_entity_type.        abstract  - Denotes that the field is abstract. Abstract fields are used when a pattern is needed to describe a path - for example image sequences (%04d) or stereo (%V). Abstract fields require a default value.        subset  and  subset_format  - Extracts a subset of the given input string and makes that the key value, allowing you to create for example an initials key from a full username or a key that holds the three first letters of every shot name.  For technical details about template keys, see the  API reference.Example - An alphanumeric nameA name that defaults to “comp” and that is alphanumeric:name:    type: str    default: &quot;comp&quot;    filter_by: alphanumericnuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{name}.v{version}.nk Example - Version numberA version number that would match numbers such as 002, 102, 034, 12341version:    type: int    format_spec: &quot;03&quot; A version number that would match numbers such as 002, 102, 034, 12341, but also 0002, 2 and 0102version:    type: int    format_spec: &quot;03&quot;    strict_matching: false Example - A stereo eyeA typical stereo eye setup. The eye field is either L or R, but when used in software, it is often referred to in a generic, abstract fashion as %V. Since %V does not really refer to a file name but rather a collection of files, we set the  abstract  flag. Abstract fields need to have a default value that is pulled in whenever the abstract representation is being requested.eye:    type: str    choices: [&quot;L&quot;, &quot;R&quot;, &quot;%V&quot;]    default: &quot;%V&quot;    abstract: truenuke_shot_render_stereo: sequences/{Sequence}/{Shot}/{Step}/work/images/{Shot}_{name}_{eye}_v{version}.{SEQ}.exrExample - Image sequencesImage sequences are abstract by definition and they have a default value set to %0Xd unless otherwise specified. The below sequence spec would identify frame numbers such as 0001, 1234 and 12345.SEQ:    type: sequence    format_spec: &quot;04&quot;nuke_shot_render_stereo: sequences/{Sequence}/{Shot}/{Step}/work/images/{Shot}_{name}_{channel}_{eye}_v{version}.{SEQ}.exr Example - Two fields both named version via an aliasTwo definitions of version number that can both be used by code that expects a key which is named “version”. This is useful if you have two Toolkit apps that both need a  version  field but you want these version field to be formatted differently.nuke_version:    type: int    format_spec: &quot;03&quot;    alias: versionmaya_version:    type: int    format_spec: &quot;04&quot;    alias: version# nuke versions are using numbers on the form 003, 004, 005# the nuke publish app requires a field called {version}# however {nuke_version} is a valid replacement for {version}# because it has an alias definednuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{name}.v{nuke_version}.nk# maya versions are using numbers on the form 0004, 0005, 0006maya_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{maya_version}.ma Example - TimestampA timestamp that defaults to the current local time and is formatted as YYYY-MM-DD-HH-MM-SS.now:    type: timestamp    format_spec: &quot;%Y-%m-%d-%H-%M-%S&quot;    default: now A timestamp that defaults to the current utc time and is formatted as YYYY.MM.DD.year_month_day:    type: timestamp    format_spec: &quot;%Y.%m.%d&quot;    default: utc_now A timestamp that defaults to 9:00:00 and is formatted as HH-MM-SS.nine_am_time:    type: timestamp    format_spec: &quot;%H-%M-%S&quot;    default: &quot;09-00-00&quot; Example - mappingsThis is useful when you would like to to add ShotGrid fields to a file name, for example. Let’s say we would like to include the user name in a file name- we’d use the following definition:current_user_name:    type: str    shotgun_entity_type: HumanUser    shotgun_field_name: loginnuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{current_user_name}_{name}.v{version}.nkWhen a Toolkit app populates all the context fields (via the  context.as_template_fields()  method, it will populate the higher level fields  Shot,  Sequence  and  Step  automatically. It will also scan through all fields which have  shotgun_entity_type  defined (like our  current_user_name  field above). If the ShotGrid Entity is defined in the context, it will be able to automatically resolve the value. The current user is always tracked in the context, and in the above example, it would also be possible to pull data from fields on Shot, Sequence and Step since these are defined as part of the higher level path and therefore part of the context. However, trying to refer to an Asset entity in a field wouldn’t work in the above example since Toolkit would have no way of knowing which asset in ShotGrid to pull the data from.Example - String field with two valid valuesOften times a studio will have a project that needs to save out ASCII and Binary Maya files. In this scenario, a string value with two valid values looks like:maya_file_extension:    type: str    choices: [&quot;ma&quot;, &quot;mb&quot;]                     Note: the default apps use either  .ma  or  .mb  based on what’s configured in the  templates.yml. So, for example, if you want to change the work files app to save  .mb  instead of  .ma  in a project, you can change these three templates (for Shots):    maya_shot_work:  '@shot_root/work/maya/{name}.v{version}.ma'maya_shot_snapshot:  '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.ma'maya_shot_publish:  '@shot_root/publish/maya/{name}.v{version}.ma'If  you  instead  end  them  with  .mb,  then  the  apps  will  save  out  as  Maya  binary:maya_shot_work:  '@shot_root/work/maya/{name}.v{version}.mb'maya_shot_snapshot:  '@shot_root/work/maya/snapshots/{name}.v{version}.{timestamp}.mb'maya_shot_publish:  '@shot_root/publish/maya/{name}.v{version}.mb' Check out  The Paths Section  below for more details.Example - Disallowing a valueA string field for which the value “assets” is not allowed. This is useful if you for example have two a folder which contains folders for all the sequences for a project alongside with a single “assets” folder where all the assets are kept:project |--- sequence1 |--- sequence2 |--- sequence3  --- assets In order for Toolkit to correctly understand that the assets folder is not just another sequence, we can define that “assets” is not a valid value for the sequence template.sequence:    type: str    exclusions: [&quot;assets&quot;] The exclusions field above allows us to define two templates that both correctly resolves:sequence_work_area: {sequence}/{shot}/workasset_work_area: assets/{asset}/work Example - Subsets of stringsThe following example extends a previous example and shows how to prefix filenames with a user’s initials.user_initials:    type: str    shotgun_entity_type: HumanUser    shotgun_field_name: login    subset: '([A-Z])[a-z]*  ([A-Z])[a-z]*'    subset_format: '{0}{1}'nuke_shot_work: sequences/{Sequence}/{Shot}/{Step}/work/nuke/{user_initials}_{name}.v{version}.nk The Paths SectionThe Paths section specifies where work will be saved. All paths consist of at least a name and a definition, where the definition is a combination of key names in brackets interspersed with non-key values representing a path. For example, a definition for a shot work file might look like:shot_work: sequences/{Sequence}/{Shot}/{Step}/work/{Shot}.v{version}.ma With Sequence, Shot, Step and version being keys defined in the same template file.                    Note: If a string key’s name matches the entity type of a dynamic schema folder that has an associated ShotGrid entity, then that folder name will be substituted in for the token. For example, if you are using a {Sequence} template key of type ‘string’ like the above snippet, and in your schema, you have a dynamic folder named ‘sequence’, and in its corresponding  sequence.yml  file, it’s defined to be of type  shotgun_entity, and is connected to the ‘Sequence’ entity type in ShotGrid. Toolkit will recognize that your template key corresponds to this dynamic folder’s entity type (in that they are both Sequence). So, Toolkit will take the resulting folder name (i.e., the name of the specific sequence in question), and substitutes that in for the template key.    This form is required if any optional attributes need to be defined. Currently, the only optional attribute is  root_name, which can be used to specify a project root for a path in a project that has multiple roots.  Multiple roots  are used when you’d like to add a new storage root to store some of your project files.root_name: name_of_project_rootFor example, it may look like this:shot_work:  definition: sequences/{Sequence}/{Shot}/{Step}/work/{Shot}.v{version}.ma  root_name: primary You need to use the above format if you want to use another storage root than the primary one. In this example, using this simple format implies that you are using the primary root for all entries.The Strings SectionStrings are similar to paths in that they must include a name and definition, which can be supplied in the simple form:string_name: string_definitionString definitions are templates consisting of key names and other values which together resolve to a string rather than a file system path. An example might the name used in ShotGrid for a publish:maya_publish_sg_name: &quot;Maya  publish,  {name},  v{version}&quot;With name and version as key names defined in the same file.Using Optional Keys in TemplatesOptional keys in templates are useful for a number of reasons. One common case is when  {SEQ}  is optional for rendered images. In this example, there can be a set of exrs that that are comprised of frame numbers, like  /path/to/render/shot.101.exr  (and 102, 103, etc), while you are also able to use the same template for quicktime movies, like  /path/to/render/shot.qt. Another more common case is when you are rendering stereo images. If you are in a studio where the convention is:  left eye: file.LFT.exr, right eye: file.RGT.exr, stereo image: file.exr?, you can make  {eye}  optional.Optional sections can be defined using square brackets:shot_work: sequences/{Shot}/work/{Shot}.[v{version}.]ma The optional section must contain at least one key. If the path is resolved with no value for the key(s) in an optional section, the path will resolve as if that section did not exist in the definition. The example above can be thought of as two templates baked into a single definition:shot_work: sequences/{Shot}/work/{Shot}.v{version}.mashot_work: sequences/{Shot}/work/{Shot}.ma As you pass in a dictionary of fields, Toolkit will choose the right version of the template depending on the values:&amp;gt;&amp;gt;&amp;gt; template = tk.templates[&quot;shot_work&quot;]&amp;gt;&amp;gt;&amp;gt; template.apply_fields({&quot;Shot&quot;:&quot;ABC_123&quot;, &quot;version&quot;: 12}/project/sequences/ABC_123/work/ABC_123.v12.ma&amp;gt;&amp;gt;&amp;gt; template.apply_fields({&quot;Shot&quot;:&quot;ABC_123&quot;}/project/sequences/ABC_123/work/ABC_123.ma Advanced questions and troubleshootingHow can I add a new entity type to my file structure?Let’s say you have been working on feature animations and shorts on your ShotGrid site, and now you have been awarded episodic work. Let’s walk through how you can incorporate an episodic workflow to Toolkit. The first thing to do is to set up your hierarchy in ShotGrid for episodic work following the instructions  here.                    Note: see the  Create with parent folder section above  to revisit nesting relationships in Toolkit (which is completely independent from the project hierarchy in ShotGrid).    Additional Reference:  How does the Episode entity work?  Customizing an entity’s hierarchyFields required for the Episode &amp;gt; Sequence &amp;gt; Shot hierarchyYou can choose to use any Custom Entity for Episode (Site Preferences &amp;gt; Entities), or you can use the official Episode entity that was made available in ShotGrid 7.0.7.0. If you signed up for ShotGrid pre-7.0.7.0 (before 2017), the “TV Show” template uses CustomEntity02 for Episodes. If you decide to use another entity that is not CustomEntity02 or the official Episode entity, no worries! ShotGrid and Toolkit are flexible. Let’s walk through both cases.For the purpose of this exercise, we will use Episode (CustomEntity02) and the official Episode entity as examples of how to incorporate Episodes with the project hierarchy update (you can use either/or). First, the way to properly set up our Project’s Episode &amp;gt; Sequence &amp;gt; Shot hierarchy is to ensure the following fields are in ShotGrid:Episodea) Using the official Episode entity: the “Episode” entity may be the entity used when creating a TV Show project from the Project Template.ORb) Using a custom entity: CustomEntity02  may be the custom entity used when creating a TV Show project from the Project Template.  As noted previously, you can enable another custom entity and use it instead of  CustomEntity02—just make sure to replace all  CustomEntity02’s with the specific one that you have enabled.SequenceA single entity link called Episode (sg_episode) that links to the Episode entity is required.Using the official  Episode  EntityUsing  CustomEntity02ShotA single entity field called Sequence (sg_sequence) that links to the Sequence entity. This should already exist as part of the TV Show Project Template in ShotGrid.Using the official  Episode  EntityUsing  CustomEntity02Toolkit schema definitionLet’s assume a hierarchy as follows (where the folders in  {}s are dynamically named based on their name in ShotGrid):- {project_name} - shots episode.yml - {episode_name} sequence.yml - {sequence_name} shot.yml - {shot_name} ... …EpisodesIn your  config/core/schema/project/shots  folder, create a folder named  episode  with a corresponding  episode.yml  file in the same directory with the following content:Using the official  Episode  Entity# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the ShotGrid field to use for the folder namename: &quot;code&quot;# the ShotGrid entity type to connect toentity_type: &quot;Episode&quot;# ShotGrid filters to apply when getting the list of items# this should be a list of dicts, each dict containing # three fields: path, relation and values# (this is std ShotGrid API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ]Using CustomEntity02# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the ShotGrid field to use for the folder namename: &quot;code&quot;# the ShotGrid entity type to connect toentity_type: &quot;CustomEntity02&quot;# ShotGrid filters to apply when getting the list of items# this should be a list of dicts, each dict containing # three fields: path, relation and values# (this is std ShotGrid API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;project&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$project&quot; ] } ] This tells Toolkit to create folders for every Episode in this project.SequenceIn your  config/core/schema/project/shots/episode  folder, create a folder named  sequence  with a corresponding  sequence.yml  file in the same directory with the following content:# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the ShotGrid field to use for the folder namename: &quot;code&quot;# the ShotGrid entity type to connect toentity_type: &quot;Sequence&quot;# ShotGrid filters to apply when getting the list of items# this should be a list of dicts, each dict containing # three fields: path, relation and values# (this is std ShotGrid API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_episode&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$episode&quot; ] } ]` This tells Toolkit to create folders for every Sequence that is linked to the Episode above it in the directory tree.ShotsIn your  config/core/schema/project/shots/episode/sequence  folder, create a folder named  shot  with a corresponding  shot.yml  file in the same directory with the following content:# the type of dynamic contenttype: &quot;shotgun_entity&quot;# the ShotGrid field to use for the folder namename: &quot;code&quot;# the ShotGrid entity type to connect toentity_type: &quot;Shot&quot;# ShotGrid filters to apply when getting the list of items# this should be a list of dicts, each dict containing # three fields: path, relation and values# (this is std ShotGrid API syntax)# any values starting with $ are resolved into path objectsfilters: [ { &quot;path&quot;: &quot;sg_sequence&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$sequence&quot; ] } ]` This tells Toolkit to create folders for every Shot that is linked to the Sequence above it in the directory tree.After you’ve done this, your schema should reflect the following:Toolkit template definitionsIn order to tell Toolkit that you are using Episodes in your schema, you need to create a new key in the  keys section  at the top to define it:Using the official  Episode  Entitykeys:    ...    Episode:        type: str    ... Then, in your template paths below, update the  shot_root  template, as well as any other template paths that are in the shot hierarchy, to match your episodic hierarchy by inserting  {Episode}  in the proper place to specify the episode in the directory structure:...    paths:        shot_root: shots/{Episode}/{Sequence}/{Shot}/{Step}        … Using  CustomEntity02keys:    ...    CustomEntity02:        type: str    ...Then, in your template paths below, update the  shot_root  template, as well as any other template paths that are in the shot hierarchy, to match your episodic hierarchy by inserting  {CustomEntity02}  in the proper place to specify the episode in the directory structure:...    paths:        shot_root: shots/{CustomEntity02}/{Sequence}/{Shot}/{Step}        … That’s all you need for the basic Episode &amp;gt; Sequence &amp;gt; Shot workflow!How can I set up a branch in my structure?This relates to  Different file system layouts for different Pipeline Steps, more specifically, if you are looking to add a branch to your structure. For example, you can have one structure for “Pipeline Step A” and another for all other Pipeline Steps.Let’s say you are adding another kind of  Asset Type  to your Pipeline, and that new Asset Type is a Vehicle. You want to change the file structure for Vehicles so that it has different folders for different Pipeline Steps; for example, “geoprep” and “lookdev”, with additional folders inside each of those Pipeline Step folders. In parallel to this update, the way that you create Assets currently should remain the same. Let’s walk through how to update your pipeline to accommodate this new flow.Step 1: Modify the schemaFirst, modify your schema to reflect the way your folder structure will look with the new Asset Type.  Start by creating a new branch in the schema for this new Asset Type: vehicle.  At the same level as  asset/  and  asset.yml, add an  asset_vehicle/  folder and  asset_vehicle.yml.  These YAML files also have a filter setting in them. Modify the filter in your  asset.yml  so that it applies to all assets  except for  vehicle, and then modify  asset_vehicle.yml  to apply  only to  assets of type vehicle.  Here is an example of what those filters look like.      Now that you have two folders to represent  asset  and  asset_vehicles, add all the folders underneath  asset_vehicle  that you expect to be created for those assets (e.g.,  geoprep,  lookdev, etc.).    If you are saving and publishing files for these assets, you’ll want to create templates, in  core/templates.yml, that describe the file paths for saved and publish files. For example, in addition to  maya_asset_work, you may create a template called  maya_asset_work_vehicle, and its definition will be the templated path where you want to save Maya work files for vehicle assets.Step 2: Create a new environment fileAt this point, you have a directory structure for the new Asset Type, and you have templates that describe where to save and publish files in the new directory structure. Now, you need to tell Toolkit when to use these new templates. To do this, create a new environment file.  Create a copy of  env/asset_step.yml  called  env/asset_vehicle_step.yml. These two files will be identical, except  env/asset_vehicle_step.yml  will use your new templates. Replace any instances of  maya_asset_work  with  maya_asset_work_vehicle. Do the same for any other vehicle templates you’ve created.  Finally, you’ll need to teach Toolkit when to pick your new environment. To do this, modify the  pick_environment  core hook to return  asset_vehicle  or  asset_vehicle_step  when the asset in context is of type  vehicle  . Now, when you are working with an Asset of this new type (vehicle), Toolkit will know to use its environment configuration, and to therefore save and publish files to its alternate file system structure.How can I create a custom Pipeline Step?In ShotGrid 7.0.6.0,  managing Pipeline Steps via the Admin menu  was introduced. With this feature, you can easily add custom fields to Pipeline Steps. Pro Tip: In most cases, utilizing custom fields on Pipeline Steps helps keep your pipeline more organized than creating a custom entity to manage those Pipeline Steps.",
    "url": "/82ff76f7/",
    "relUrl": "/82ff76f7/"
  },
  "57": {
    "id": "57",
    "title": "Fixing the SSL: CERTIFICATE_VERIFY_FAILED issues with the Python API",
    "content": "Fixing the SSL: CERTIFICATE_VERIFY_FAILED issues with the Python APIThe Python API relies on a list of certificates that is bundled with the API and on your machine in order to connect to the various webservices ShotGrid uses. Unfortunately, new certificate authorities can be released and those might not be bundled with the Python API or OS.While our Python API comes with a very recent copy of the certificates, as of February 21st 2019, there’s a bug that prevents the API from using those certificates for Amazon S3 uploads, even if you are using the latest version of the API. For background please see this AWS blog post. To remediate the situation temporarily, you can try the following solutions.                    Note: These are temporary workarounds and we’re looking into a long-term solution.    Preferred SolutionAdd the required CA certificate to the Windows Certificate Store. Windows 7 users may have to first upgrade to PowerShell 3.0 in order to use this solution, or alternatively use certutil to add the required certificate.      Start an elevated PowerShell by right-clicking Start and then left-clicking Windows PowerShell (Admin)        Paste the following commands into the PowerShell window and then press Return to execute:     $cert_url = &quot;https://www.amazontrust.com/repository/SFSRootCAG2.cer&quot; $cert_file = New-TemporaryFile Invoke-WebRequest -Uri $cert_url -UseBasicParsing -OutFile $cert_file.FullName Import-Certificate -FilePath $cert_file.FullName -CertStoreLocation Cert: LocalMachine Root            If details of the added certificate bearing thumbprint 925A8F8D2C6D04E0665F596AFF22D863E8256F3F are displayed then the operation is complete and PowerShell can be closed.  Alternative SolutionsIf you are using the Python API only      Upgrade to the Python API v3.0.39        a. Set SHOTGUN_API_CACERTS to /path/to/shotgun_api3/lib/httplib2/cacerts.txt    or    b. Update your scripts and set the ca_certs=/path/to/shotgun_api3/lib/httplib2/cacerts.txt when instantiating the Shotgun object.  If you are using Toolkit      Upgrade to the latest version of the Toolkit API via the tank core command or by updatingthe core/core_api.yml file of your pipeline configuration, depending on how you deploy Toolkit.        Download an up-to-date list of certificates at https://github.com/certifi/python-certifi/blob/master/certifi/cacert.pem.        Set SHOTGUN_API_CACERTS to the location where you saved this file. Toolkit doesn’t allow you to specify the ca_certs parameter when creating connections the way the Python API does.  If you can’t update the Python API or Toolkit      Download an up-to-date list of certificates at https://github.com/certifi/python-certifi/blob/master/certifi/cacert.pem.        Set the SSL_CERT_FILE environment variable to the location where you saved this file.  ",
    "url": "/c593f0aa/",
    "relUrl": "/c593f0aa/"
  },
  "58": {
    "id": "58",
    "title": "Folder creation aborded",
    "content": "Failed to create folders: Folder creation abordedUse CaseCurrently we create new project on the web interface and then use ShotGrid desktop to configure Toolkit as centralized setup. However when try to edit an asset name, it’s no longer working (artist cannot open the file to edit in CCD such as Maya), and the error returned was “Failed to create folders”. ShotGrid asks to rerun tank commands to unregister the asset and reregister it to fix but we don’t know where to run those.How to fixOnce the advanced setup wizard has been run on a project, the option to run it is intentionally removed. It is possible to re setup a project however if you wish.You will need to run the tank command mentioned in the error message:tank.bat Asset ch03_rockat_drummer unregister_foldersThe tank.bat can be found at the root of the configuration you set up, if you’re not sure where that is, this topic should help you find it.Related linksSee the full thread in the community",
    "url": "/25a37fc0/",
    "relUrl": "/25a37fc0/"
  },
  "59": {
    "id": "59",
    "title": "The Frame Server has encountered an error",
    "content": "The Frame Server has encountered an errorUse CaseWhen launching Nuke from SG Desktop the error message “The Frame Server has encountered an error.” is presented, and you can continue to work.Complete error:The Frame Server has encountered an error.Nuke 12.1v5, 64 bit, built Sep 30 2020.Copyright (c) 2020 The Foundry Visionmongers Ltd. All Rights Reserved.Loading - init.pyTraceback (most recent call last):File “/Applications/Nuke12.1v5/Nuke12.1v5.app/Contents/Resources/pythonextensions/site-packages/foundry/frameserver/nuke/workerapplication.py”, line 18, infrom util import(asUtf8, asUnicode)ImportError: cannot import name asUtf8cannot import name asUtf8How to fixThis error can happen when there is a dev path still on the config.Related linksSee the full thread in the community",
    "url": "/2f35b796/",
    "relUrl": "/2f35b796/"
  },
  "60": {
    "id": "60",
    "title": "Getting Started",
    "content": "Isolation Feature Set - Getting StartedWant to learn more about the isolation features? See About the Isolation Feature Set for more details about what is in store for you. The Isolation feature set is available to clients with an active ShotGrid subscription. Before starting, please be sure to complete your subscription purchase.To get the onboarding process started, go to Onboarding Process.To start the setup for any of the Isolation features, go to the Setup sectionIn This Section  About the Isolation Feature Set  Client Responsibilities  Onboarding Process  Planning Your Setup",
    "url": "/0f6d8a60/",
    "relUrl": "/0f6d8a60/"
  },
  "61": {
    "id": "61",
    "title": "Getting Started",
    "content": "Getting StartedShotGrid Toolkit provides a set of highly customizable tools for creating studio pipelines where artists can access info from ShotGrid and share their work with each other, without ever leaving their content creation software. These guides are designed to get you started with setting up your custom Toolkit pipeline via hands-on exercises: you’ll use the ShotGrid Desktop app to generate an editable configuration for your project, modify settings on existing apps, and even add Toolkit apps to different artist environments, getting you on the path to designing your custom pipeline. Each guide builds on the ones before it, but they include instructions for jumping in from anywhere.",
    "url": "/3c5b69aa/",
    "relUrl": "/3c5b69aa/"
  },
  "62": {
    "id": "62",
    "title": "ERROR 18:13:28.365:Hiero(34236) Error! Task type",
    "content": "ERROR 18:13:28.365:Hiero(34236): Error! Task typeUse case:After updating to config_default2, nuke_studio does not initialize. Under Nuke 12.0 studio I get no errors in the script editor, but in Nuke 11.1v3 I get:ERROR 18:13:28.365:Hiero(34236): Error! Task type tk_hiero_export.sg_shot_processor.ShotgunShotProcessor Not recognisedWithout fail after a rollback, it still does not initialize the tk-nuke engine, and ShotGrid fails to load anything…The community post includes a full log for further details.What’s causing the error?It’s not treating it as a NukeStudio launch, and is probably instead treating it as a standard Nuke launch.The defined a Nuke Studio Software entity, with a path, and set the args to -studio. The arg needs to be --studio.How to fixThe args on the software entity need to be set to -studio.See the full thread in the community.",
    "url": "/8edc0d13/",
    "relUrl": "/8edc0d13/"
  },
  "63": {
    "id": "63",
    "title": "Why are my Houdini ShotGrid integrations not starting?",
    "content": "Why are my Houdini ShotGrid integrations not starting?This covers the most common reason we’ve seen for the ShotGrid integrations not starting in Houdini. In this case,Houdini launches without error from ShotGrid Desktop, your ShotGrid website, or the tank command. However, once Houdiniis launched, the ShotGrid menu or shelf does not appear.Often the reason for this is that the HOUDINI_PATH environment variable has been overridden, and ShotGrid relies on that for passing the startup script path.When Houdini is launched from ShotGrid, the launch app logic adds the ShotGrid bootstrap script path to the HOUDINI_PATHenvironment variable. However, the problem can arise when Houdini has ahoudini.env file.This file allows the user to set environment variables that will be present when Houdini is loaded, but any valuesdefined in the file will overwrite pre-existing environment variables in the current session.The fix for this is to make sure you include the pre-existing HOUDINI_PATH environment variable in the new definitionfor that variable.For example, if you have something like this already in your houdini.env file:HOUDINI_PATH = /example/of/an/existing/path;&amp;amp;Then you should add $HOUDINI_PATH; to the end of the path defined in the file and save it:HOUDINI_PATH = /example/of/an/existing/path;$HOUDINI_PATH;&amp;amp;This will allow the ShotGrid set value to persist when Houdini launches.                    Caution: On Windows we’ve seen $HOUDINI_PATH causing issues. It sometimes tries to bootstrap the Shotgun integration multiple times generating an error like this:Toolkit bootstrap is missing a required variable : TANK_CONTEXTIf you get this you should try using %HOUDINI_PATH% instead.    If this does not fix your problem please reach out to our support team and they will help you diagnose the issue.",
    "url": "/eecfb05b/",
    "relUrl": "/eecfb05b/"
  },
  "64": {
    "id": "64",
    "title": "Overview",
    "content": "",
    "url": "/",
    "relUrl": "/"
  },
  "65": {
    "id": "65",
    "title": "How do I install the ShotGrid Desktop silently on Windows?",
    "content": "How do I install the ShotGrid Desktop silently on Windows?To run the ShotGrid Desktop installer silently, simply launch the ShotGrid Desktop installer the following way:ShotgunInstaller_Current.exe /SIf you wish to also specify the installation folder, launch it with the /D argument:ShotgunInstaller_Current.exe /S /D=X: path to install folder.                    Note: The /D argument must be the last argument and no &quot; should be used in the path, even if there are spaces in it.    ",
    "url": "/3a27b3da/",
    "relUrl": "/3a27b3da/"
  },
  "66": {
    "id": "66",
    "title": "Adding an app",
    "content": "Adding an appBy completing this guide, you will quickly become acquainted with the configuration management tools in Toolkit and learn how to:  Safely create a copy of an active pipeline configuration  Add an app to a configuration  Add the settings necessary to use that app in specific environments  Push your changes back to the active configurationAbout the guideThis guide will demonstrate how to add a ShotGrid Toolkit app to an existing pipeline configuration. You will quickly become acquainted with the configuration management tools.The app we will be adding is the ShotGrid Python Console app. Maya has its own Python console, but there are some features in the Toolkit app that don’t exist in the Maya console.This guide utilizes the pipeline configuration we created in the Editing a Pipeline Configuration guide. If you haven’t completed this guide, you can use an existing pipeline configuration and add the app there.Using this documentTo use this guide and install a Toolkit app, the following is required:  An active ShotGrid site.  A pipeline configuration for the identified project, or complete the Getting Started with Configurations guide and use the configuration created in that exercise.  Read and write permissions set appropriately for the filesystem where the pipeline configuration is stored.  ShotGrid Desktop installed on your system.  An active subscription for Maya. Get a 30 day trial of Maya here.                    Note: This guide is based on the tk-config-default2 pipeline configuration. If your config was modified, the location of files, folders, and blocks of YAML settings may vary from what is described here.    About ShotGrid Toolkit appsHow Toolkit apps workApps that are referenced in pipeline configurations can be sourced from various locations. The apps that are standard in the Default Configuration are sourced from the ShotGrid App Store. The files in a pipeline configuration specify how ShotGrid integrations access an app, kind of like asking Toolkit, “Can you look in your little black book for the address of the Python Console App?” The pipeline configuration files tell Toolkit where to find the bundles of code that are utilized for a specific app.The “addresses” for Toolkit Apps are listed in the config/env/includes/app_locations.yml file in the Default Configuration and specify how to find the code. These “addresses” are called descriptors. The ShotGrid integrations need to be told not only how to find the code bundles for the app, but also in what environment(s) to use the app.Below is a conceptual overview of how to install an app and how to tell a ShotGrid integration where to use it. It outlines the steps for extending the configuration, asking Toolkit to look up a descriptor, and telling ShotGrid where to use the app. These steps are detailed in this guide:  Determine the descriptor for the app you want to add.  Make a copy of the active pipeline configuration you want to add the app descriptor to.  See if the app’s descriptor exists in the configuration and if not, add it.  Format the YAML file correctly using spaces and not tabs for indents.  Determine in what environment(s) the app is to be used.  Within those environment(s), add the setting that will allow ShotGrid to use the app.  Test the new configuration.  Push the extended configuration live.Find the location descriptor for the Python Console AppStep 1: Open the Apps and Engines page and find the information for the ShotGrid Python Console under Maya. Select the title.This will bring up the information for the app, which includes everything that’s needed for the little black book.The System Name is the main identifier: tk-multi-pythonconsole. You will also need the Latest Version: v1.1.2.Confirm that there’s no Python Console app in the Project environment in MayaStep 2: Launch Maya and select the ShotGrid Menu, ShotGrid &amp;gt; Project the_other_side and you will see the list of apps that are available for that project in the Project environment.Extend the configurationTo edit a configuration that’s in production, you’ll want to first create a copy, then edit the copy. This way you don’t affect the live configuration and you can create a safe space to test it before pushing it live. Creating a staging sandbox allows you to play with a copy of the pipeline configuration currently being used in production. In the sandbox, you make changes to the copy of the configuration and test the changes before pushing the changes live into production.Cloning a pipeline configuration automates the process of creating a copy, building a sandbox where you can play with the copy, before pushing the new configuration to the live production.Clone the Pipeline Configuration you want to add an app toGo to the Pipeline Configuration list.Step 3: Open ShotGrid and in the upper right, select the Admin Menu (your avatar) &amp;gt; Default Layouts &amp;gt; Pipeline Configuration &amp;gt; Pipeline Configuration List.This action displays a detailed list of all of your ShotGrid site’s pipeline configurations.Step 4: Once the Pipeline Configuration List is displayed, select the + sign on the far right of the column headers, and add the column Projects.Review where the project’s configuration is locatedStep 5:  Additionally, add the the appropriate Path field for your operating system.This displays the paths to the configuration files.Step 6: Right-click in the empty space next to the Primary line item and select Clone this Configuration… in the context menu.Step 7: Name the configuration in the Configuration List and name the file in the directory: “Primary Clone Config 2” and “the_other_side_clone2,” respectively. Select OK.Wait while ShotGrid copies all of the files and folders in the configuration and creates a cache for the apps. Now would be an opportune time to use an app that makes you a light, fluffy, melt in your mouth croissant to go with that perfect shot of espresso.When completed, the Configuration List will be updated with information about the cloned configuration and there will be a new configuration added to your local config folder.                    Note: Under User Restrictions your user name was added. ShotGrid automatically restricts access to the new configuration to only the person who created the configuration. You can add people you want to edit, test, and eventually use this configuration. Yet another way ShotGrid allows for flexibility and control.    Associate the cloned configuration with the projectStep 8: Open ShotGrid Desktop and select the project you created the cloned configuration for. Select the down arrow in the upper right to display the configurations associated with this project and select the Primary Clone Config 2 that you just created.ShotGrid Desktop is now using the cloned config for this project.Edit the Pipeline ConfigurationStep 9: Find the cloned configuration on your file system, in the path you specified when you created it. View the config/env/includes/app_locations.yml file.The app_locations.yml file is the Default Configuration’s little black book and the descriptors for apps are listed in this file. This file points to where the app is located and allows you to create settings for the app.If an app that you want to use isn’t referenced in the little black book, you will need to tell Toolkit where to find it.Tell Toolkit where to find the appStep 10: Search the file for pythonconsole. If you used the Default Configuration for the project, you will find that the descriptor for the Python Console app is listed in this file. It should match the description we found in the list of Maya apps we looked at when we started on our journey. Check to make sure the version matches what we looked at in the list of Maya apps.apps.tk-multi-pythonconsole.location:	type: app_store	name: tk-multi-pythonconsole	version: v1.1.2                    Note: If you’re using a different configuration, you may need to add the descriptor to the file.    All apps and engines have descriptors. You can read about how descriptors work and how to set the type: in the Descriptor section of our Core API docs.Tell Toolkit to use the descriptorNow we need to tell Toolkit to use the descriptor to locate the Python Console app and use it when we’re in a Project environment in Maya.Step 11: Open the config/env/project.yml file in your cloned config and find the settings for the tk-maya engine.# configuration for all engines to load in a project contextengines:  tk-3dsmaxplus: &quot;@settings.tk-3dsmaxplus.project&quot;  tk-desktop: &quot;@settings.tk-desktop.project&quot;  tk-flame: &quot;@settings.tk-flame.project&quot;  tk-hiero: &quot;@settings.tk-nuke.hiero.project&quot;  tk-houdini: &quot;@settings.tk-houdini.project&quot;  tk-mari: &quot;@settings.tk-mari.project&quot;  tk-maya: &quot;@settings.tk-maya.project&quot;  tk-motionbuilder: &quot;@settings.tk-motionbuilder.project&quot;  tk-nuke: &quot;@settings.tk-nuke.project&quot;  tk-nukestudio: &quot;@settings.tk-nuke.nukestudio.project&quot;  tk-photoshopcc: &quot;@settings.tk-photoshopcc.project&quot;  tk-shell: &quot;@settings.tk-shell.project&quot;  tk-shotgun: &quot;@settings.tk-shotgun.project&quot;The tk-maya: “@settings.tk-maya.project” line using the @settings tells you that the settings are in an included file. The tk-maya identifies the Maya engine and the project identifies the environment.YAML filesThe ShotGrid Toolkit pipeline configuration uses simple terms in YAML files to identify the location of apps and engines, as well as their settings.For this specific block:  settings is what was chosen for the Default Configuration as a reference for the settings folder  project is what was chosen for the Default Configuration as a reference for the project environment  tk-maya is the identifier for Toolkit’s engine for Maya  @ is a Toolkit term used to denote that a setting value is coming from an included fileThe YAML files are the windows into ShotGrid’s integrations and make it easier to configure working environments that meet the needs of your pipeline.How the configuration references Toolkit bundlesThe code for ShotGrid’s integrations is organized into bundles for apps, engines, and frameworks. The bundles are referenced in Toolkit’s YAML files using identifiers like tk-maya, tk-multi-pythonconsole, etc. Each bundle’s corresponding block of YAML contains settings that control how the identified bundle is accessed and utilized.Where to put settings for the Python ConsoleFor this specific block in the Default Configuration, ‘tk-maya.project’ is the identifier for the Maya engine in the project environment. Our goal is to add the Python Console app code bundle to the Maya engine in project environment. Based on the terms used, it’s a safe bet that tk-maya.yml is the name of the YAML file where settings for the project environment are located. Find the settings.tk-maya.project for apps in the tk-maya.yml file.Step 13: To find the file, look for tk-maya.yml in the includes section above the engines../includes/settings/tk-maya.ymlStep 14: In your cloned configuration, open config/env/includes/settings/tk-maya.yml in a text editor, and search for settings.tk-maya.project.Step 15: Add the location descriptor undersettings.tk-maya.project:  apps:Use the about app, tk-multi-about:, as a guide for how to add the location descriptor, then save the file.                    Note: Make sure your YAML files are formatted correctly using spaces and not tabs.    # projectsettings.tk-maya.project:  apps:    tk-multi-about:      location: &quot;@apps.tk-multi-about.location&quot;    tk-multi-pythonconsole:      location: &quot;@apps.tk-multi-pythonconsole.location&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-multi-shotgunpanel: &quot;@settings.tk-multi-shotgunpanel&quot;    tk-multi-workfiles2: &quot;@settings.tk-multi-workfiles2.launch_at_startup&quot;You will notice the Screening Room, ShotGrid Panel, and Workfiles2 app’s location identifiers are listed in a different included file and accessed differently than the About app. To keep things tidy, these apps were split off to the included settings folder because they have additional settings.                    Note: The python console app already exists in the Default Configuration, however if you are adding an app that has never been added to your configuration before or if you have changed the version of an app, and you are using a centralized configuration, then there is an additional step you need to take. Open your terminal and browse to where your cloned configuration is stored. From your cloned configuration’s root folder, run the following command:On Linux or Mac:./tank cache_appsOn Windows:tank.bat cache_appsThis will scan your configuration for apps, engines and frameworks and ensure that they are all downloaded.    View the changes in MayaStep 16: Open ShotGrid Desktop, select the project you were working with, and confirm you are using the cloned configuration.There will be a blue bar with the name of the clone that you created under the name of the project.                    Note: If you’re using the primary, there will be no blue bar and the configuration name won’t be visible.    Step 17: Launch Maya from Desktop and select the menu ShotGrid &amp;gt; Project &amp;gt; …If:  You’re using the cloned configuration that you just edited  The cloned configuration was extended correctly  You saved the extended files  You chose to associate the project with the cloned configuration  You relaunched Maya from ShotGrid DesktopThe Python Console app will be available in Maya.Push the changes into productionAfter confirming you added the Python Console app correctly, you’re ready to push the changes live.Step 18: Open your terminal and browse to where your cloned configuration is stored. From your cloned configuration’s root folder, run the following command:On Linux or Mac:./tank push_configurationOn Windows:tank.bat push_configurationFollow the prompts and type in the ID for your project’s Primary configuration, the configuration you want to push the changes to.$ lscache		config		install		tank		tank.bat$ ./tank push_configurationWelcome to the Shotgun Pipeline Toolkit!For documentation, see https://developer.shotgridsoftware.comStarting Toolkit for your current path'/Users/michelle/Documents/Shotgun/configs/the_other_side_clone2'- The path is not associated with any Shotgun object.- Falling back on default project settings.- Running as user 'Michelle'- Using configuration 'Primary Clone Config 2' and Core v0.18.159- Setting the Context to Project the_other_side.- Running command push_configuration...----------------------------------------------------------------------Command: Push configuration----------------------------------------------------------------------This command will push the configuration in the current pipeline configuration('Primary Clone Config 2') to another pipeline configuration in the project.By default, the data will be copied to the target config folder. If pass a--symlink parameter, it will create a symlink instead.Your existing configuration will be backed up.The following pipeline configurations are available to push to: - [1] Primary (/Users/michelle/Documents/Shotgun/configs/the_other_side)Please type in the id of the configuration to push to (ENTER to exit): There will be a list of the available pipeline configurations that the cloned configuration can be pushed to. Enter the ID of the primary pipeline configuration for the project you are updating the configuration for.                    Note: You can also find the id for your Pipeline Configuration on the Pipeline Configuration page in ShotGrid that we viewed in Step 3 of this guide. To find the project ID, go to the Configuration List and add the ID column.    After you enter the ID, ShotGrid will:  Backup the Primary configuration  Copy the cloned configuration  Associate the copied cloned configuration with the project leaving the clone intact  Displaying where the Primary config was saved  Check to see if there are any apps that need to be downloaded and cachedPlease type in the id of the configuration to push to (ENTER to exit): 1Hold on, pushing config…Your old configuration has been backed up into the following folder:/Users/michelle/Documents/Shotgun/configs/the_other_side/config.bak.20190118_111627Checking if there are any apps that need downloading…Push Complete!View the changes you made in the primary configurationStep 19: In ShotGrid Desktop, click on the arrow in the upper right and choose Primary in the CONFIGURATION list.Step 20: Launch Maya from Desktop and look in the menu ShotGrid &amp;gt; Project &amp;gt; … to find the ShotGrid Python Console…The Python Console app was added to the Project environment for the chosen project. We discussed in the second guide, “Editing a configuration, that each environment is independent, a project has a dedicated configuration, and the software integrations gather settings from the pipeline configuration when a project is loaded. For the Python Console to be available in an environment, that environment will need instructions to look in the app_locations.yml file for the location descriptor. Given this, at any point in the pipeline where you want the Python Console app to be available will need the settings that say, “use the Python Console app here.”Advanced topicsThe ShotGrid developer communityOne of the wonderful things about Toolkit is that anyone can create a Toolkit app. Apps can be kept proprietary, or they can be shared within the ShotGrid community, adding to the ShotGrid arsenal. If you’ve created a really stellar app you want share on the ShotGrid community page, please visit our support site for help.Standard Toolkit apps and apps created by the loving ShotGrid community are actively discussed in the ShotGrid-dev Google group. The knowledge and tool base continues to grow as the ShotGrid community adds their contributions.Investigate how to extend a configurationYou may have noticed when we were selecting which configuration to use for the project, the Python Console App was available in the ShotGrid Desktop dropdown.If there’s an environment that is using an app you want to add to your pipeline configuration, you can use a little detective work to find the information you need to add that app to your configuration. By looking in the configuration file in the environment where the app is being used, you can determine how to add the app location descriptor and setting.The Desktop app opens in the project environment, so find tk-desktop in the project.yml file.Open config/env/project.yml.In the engine block, tk-desktop points to included content:includes:  - ./includes/settings/tk-desktop.ymlengines:  tk-desktop: &quot;@settings.tk-desktop.project&quot;Follow the include: open config/env/includes/settings/tk-desktop.yml and find the settings.tk-desktop.project block. In that block you’ll see the following:apps:  tk-multi-pythonconsole:  location: &quot;@apps.tk-multi-pythonconsole.location&quot;These blocks add the Python Console app to the Desktop engine in the project step.Follow that include further to ../includes/app_locations.yml and search for apps.tk-multi-pythonconsole.location to find the following:# pythonconsoleapps.tk-multi-pythonconsole.location:  type: app_store  name: tk-multi-pythonconsole  version: v1.1.2Every app, engine, and framework has a location descriptor that is used to tell Toolkit where to access the specific bundle. Many app descriptors exist in the app_locations.yml file, but may not be referenced where you want them, as we saw with the Python Console app. All the standard Apps and Engines are listed on the Apps and Engines page.You can add any app to any appropriate software integration that ShotGrid supports, or add your own proprietary application to your Toolkit arsenal. All the supported software applications are also listed on the Integrations Apps and Engines page page.If you can’t find the exact app you are looking for, you can create one. There’s a good chance that other ShotGrid users will need the same function and sharing new apps is one way to give back to the ShotGrid community.In the next guide, you will learn how to customize your production folder structure to reflect how your facility is structured.",
    "url": "/4d147fb2/",
    "relUrl": "/4d147fb2/"
  },
  "67": {
    "id": "67",
    "title": "ShotGrid Integrations Admin Guide",
    "content": "ShotGrid Integrations Admin GuideIntroductionThis document serves as a guide for administrators of ShotGrid integrations. It’s one of three: user, admin, and developer. Our  User Guide  is intended for artists who will be the end users of ShotGrid integrations in their daily workflow, and our  Developer Guide  is technical documentation for those writing Python code to extend the functionality. This document falls between those two: it’s intended for those who are implementing ShotGrid integrations for a studio, managing software versions, and making storage decisions for published files.Standard Pipeline ConfigurationsAt the heart of any Toolkit setup is the Pipeline Configuration, a set of YAML files that manage everything from installed apps to software versions, and in some cases, even hold the templates for setting up your production directory structure and file names. The Pipeline Configuration is highly customizable, but we offer two starting points.The Basic ConfigOur out-of-the-box integrations are designed to run without the need to set up or modify any configuration files. When you use our out-of-the-box integrations, there’s nothing to administer, but Toolkit uses an implied Pipeline Configuration under the hood, and we call this Pipeline Configuration the Basic Config. The Basic Config makes three Toolkit apps – The Panel, Publisher, and Loader – available in all supported software packages, and looks to your Software Entities in ShotGrid to determine which software packages to display in ShotGrid Desktop. The Basic Config does not include filesystem location support. When you use out-of-the-box integrations on a project, your copy of the Basic Config is auto-updated whenever you launch Desktop, so you’ll always have the latest version of our integrations. You can  subscribe to release notes here, and  see the Basic Config in Github here.The Default ConfigThis is the default starting point for our Advanced project setup. It includes  filesystem location support  and a wider array of Toolkit apps and engines.You can  see the Default Config in Github here. For a detailed description of the Default Config’s structure, see the  config/env/README.md  file in your Pipeline Configuration, or  view it here in Github.                    Note: Looking for the old config structure? With the v1.1 release of Integrations, we reorganized the structure of the Default Config to help maximize efficiency and readability, and to make it match the Basic Config’s structure more closely You can still base projects on the legacy Default Config. Just choose ‘Legacy Default’ when prompted to select a configuration in the Desktop Set Up Project Wizard.    The PublisherThe Publisher is designed to ease the transition between the out-of-the-box workflow and the full pipeline configuration. In the out-of-the-box setup, files are published in place, which avoids the need to define templates or filesystem schema. Once a project has gone through the advanced setup and has a full Pipeline Configuration, the same publish plugins will recognize the introduction of templates to the app settings and begin copying files to their designated publish location prior to publishing. Studios can therefore introduce template-based settings on a per-environment or per-DCC basis as needed for projects with full configurations. The Default Config comes fully configured for template-based workflows and is a good reference to see how templates can be configured for the Publish app. See the  tk-multi-publish2.yml file  in the Default Config in Github for more info.For details on writing plugins for the Publisher, see the  Publisher section of our Developer Guide.Configuring software launchesIt’s simple to rely on ShotGrid’s auto-detection of host applications on your system: just launch ShotGrid Desktop, choose a project, and Desktop will display launchers for all supported software packages that it finds in standard application directories. But we also offer robust tools for more fine-grained management of the software in your studio. You can restrict application visibility to specific projects, groups, or even individual users. You can specify Versions, deactivate a given software package across your site, and group software packages together. All of this is managed through Software entities in ShotGrid.When you create a new ShotGrid site, it will have a set of default Software entities—one for each supported host application. You can modify these and add your own to manage the software that shows up in Desktop exactly how you want it.                    Important: Newer versions of Hiero, Mari, MotionBuilder and RV will need an additional configuration within the software_paths.yml file. The software_paths.yml file is available when you have taken over your configuration. For more details, see instructions in the Hiero, Mari, MotionBuilder and RV engine topics.    To see your Software entities in ShotGrid, open the Admin menu by clicking on the profile icon in the upper right corner of the screen, and choose  Software.The Software entity has the following fields:  Software Name:  The display name of the Software in Desktop.  Thumbnail:  Uploaded image file for Desktop icon.  Status:  Controls whether or not the Software is available.  Engine:  The name of the integration for the content creation tool.  Products:  For Software packages that include variants (e.g., Houdini vs. Houdini FX), you can specify a comma separated list here. Valid only in auto-detect mode, not manual mode.  Versions:  Specific versions of the software to display. You can specify a comma separated list here. Valid only in auto-detect mode, not manual mode.  Group:  Entities with the same value for the  Group  field will be grouped under a single icon in Desktop and a single menu in ShotGrid. For example, you could create an FX group that includes Houdini and Nuke.  Group Default: When one member of a group has  Group Default  checked, clicking the icon or menu item for the group will launch this software.  Projects:  A way to restrict software to certain projects.  User Restrictions:  A way to restrict software to certain users or groups.  Linux/Mac/Windows Path:  Use these fields to explicitly specify an OS-specific path to software.  Linux/Mac/Windows Args:  Commandline args to append to the command when launching the Software.We can learn a lot about how these fields work together by demonstrating some ways of using them.Example: Grouping versions of the same application, auto-detectSay you have three versions of Maya on your filesystem: Maya 2016, Maya 2017, and Maya 2018. You want to make all of these available to your artists, but you want them to be grouped under a single icon in Desktop.If these three versions of Maya are installed in the standard location on your filesystem, then this will all happen automatically. When you select a project in Desktop, it will scan the standard applications directory on the local machine, and will find the three versions. Since you already have a Maya software entity in ShotGrid, with no specific versions or paths specified, it will display all versions it finds in Desktop.A few things to note here:  When ShotGrid auto-detects your software, a single Software entity generates the menu items for all versions.  None of the Path fields have values specified. The Software entity is in auto-detect mode, so the App is assumed to be in the standard location.These will show up in Desktop as you see here: one icon for Maya, with a drop-down listing all the available versions. If you click on the icon itself, you’ll launch the latest version of Maya.Example: Grouping versions of the same application, manual modeIt’s perfectly fine to store Maya in a non-standard location in your studio. You’ll just need to create your own Software entities, and specify paths to let ShotGrid know where to find your software. Your setup may look like this:Some notes here:  Unlike in auto-detect mode, here you have a Software entity for each version of a given software package.  In order to group them together, use the  Group  and  Group Default  fields. Software entities that share the same value for  Group  will be grouped in Desktop in a dropdown under a single icon, which uses the  Group  value as its name.  When you click on that icon itself, you’ll launch the software within the group with  Group Defaultchecked.  When you specify a value for  any  of Linux Path, Mac Path, or Windows Path on a Software entity, that entity will shift to Manual mode.  Unlike auto-detect mode, where the software  would  show up in Desktop when a path field is empty, in manual mode, a software package will  only  show up on a given operating system if a path is specified for it and the file exists at the specified path.  In this example, none of the three Maya versions would show up in Desktop on Windows because no  Windows Path  has been specified.Example: Restrict by users or groupsNow, say with that last example that we’re not ready to make Maya 2018 available to all users just yet. But we do want TDs, Devs, and our QA engineer, Tessa Tester, to be able to access it. We can achieve this with the  User Restrictions  field. Here’s an example:We made a couple changes from the last example:  The group default is now Maya 2017. We want that to be the production version, so with that box checked, clicking the icon for Maya will now go to this version.  We’ve added a few values to the  User Restrictions  field: It can take both users and groups, and we’ve added our Dev and TD groups, as well as the user Tessa Tester. Now, only those people will see Maya 2018 in Desktop.Example: Restrict software versions by projectSometimes you want to do more complex version management across projects in your studio. You may have a project in a crunch to deliver, which you want to lock off from new versions of software, while at the same time, its sequel may just be starting up and able to evaluate newer versions. In this case, you may have your Software entities set up like this:A few important things to note:  We’ve removed the  Group  and  Group Default  values here, as only one Maya version will ever show up in Desktop for a given environment.  We’ve set the  Software Name  for all three versions to “Maya”. This way, on every project, users will have an icon with the same name, but it will point to different versions depending on what’s configured here.  We’ve set Maya 2016’s  Status  field to  Disabled. We are no longer using this version in our studio, and this field toggles global visibility across all projects.  We’ve specified values for  Projects  for Maya 2017 and Maya 2018. This  Projects  field acts as a restriction. Maya 2017 will  only  show up in the Chicken Planet project, and Maya 2018 will only show up in Chicken Planet II.  Note that once you’ve specified a value for  Projects  for a Software entity, that Software will only show up in the projects you’ve specified. So, if you have other projects in your studio in addition to the Chicken Planet series, you’ll need to specify software for them explicitly.Example: Add your own SoftwareThere are several reasons you might add a new software entity in addition to those that ShotGrid Desktop has auto-detected on your system:  You want to make an application for which there is no engine available to your users through Desktop.  You have in-house software, or third-party software that we don’t have an integration for, for which you’ve written your own engine.  Your software doesn’t live in a standard location, so you want to point ShotGrid to it manually. (This case was described in the “Grouping versions of the same Application, Manual mode” example above.)In these cases, you can add your own Software entities. You’ll need to have a value for the  Software Namefield. If you’re using an in-house engine for your software, specify the engine name in the  Engine  field. Some studios may want to include apps in Desktop that don’t have ShotGrid integrations, as a convenience for artists. Your artists can launch the app straight from Desktop. You can even use all of the settings above to manage versions and usage restrictions. In this case, leave the  Engine  field empty, but you’ll need to specify a value for at least one of  Mac Path,  Linux Path, and  Windows Path.Configuring published file path resolutionWhen you publish a file, the Publisher creates a PublishedFile entity in ShotGrid, which includes a  File/Link  field called  Path. Later on, a different user may try to load this file into their own work session using the Loader. The Loader uses complex logic to resolve a valid local path to the PublishedFile across operating systems.The way in which the Loader attempts to resolve the publish data into a path depends on whether the the publish is associated with a local file link or a  file://  URL.Resolving local file linksLocal file links are generated automatically at publish time if the path you are publishing matches any local storage defined in the ShotGrid Site Preferences. If the publish is a local file link, its local operating system representation will be used. Read more about local file links  here.If a local storage doesn’t define a path for the operating system you are currently using, you can use an environment variable to specify your local storage root. The name of the environment variable should take the form of  SHOTGUN_PATH_&amp;lt;WINDOWS|MAC|LINUX&amp;gt;_&amp;lt;STORAGENAME&amp;gt;. So, if you wanted to define a path on a Mac for a storage root called “Renders”, you’d create a  SHOTGUN_PATH_MAC_RENDERS  environment variable. Let’s go deeper with that example:  Say your ShotGrid site has a storage root called “Renders”, with the following paths specified:  Linux path:  /studio/renders/  Windows path:  S: renders       Mac path:  &amp;lt;blank&amp;gt;        You are on a Mac.    You want to load a publish with the path  /studio/renders/sq100/sh001/bg/bg.001.exr  into your session.The Loader can parse the path and deduce that  /studio/renders/  is the storage root part of it, but no storage root is defined for Mac. So, it will look for a  SHOTGUN_PATH_MAC_RENDERS  environment variable, and if it finds one, it will replace  /studio/renders  in the path with its value.Note:  If you define a  SHOTGUN_PATH_MAC_RENDERS  environment variable, and the local storage Renders does have Mac path set, the local storage value will be used and a warning will be logged.Note:  If no storage can be resolved for the current operating system, a  PublishPathNotDefinedError  is raised.Resolving file URLsThe Loader also supports the resolution of  file://  URLs. At publish time, if the path you are publishing does not match any of your site’s local storages, the path is saved as a  file://  URL. Contrary to local file links, these paths are not stored in a multi-OS representation, but are just defined for the operating system where they were created.If you are trying to resolve a  file://  URL on a different operating system from the one where where the URL was created, the Loader will attempt to resolve it into a valid path using a series of approaches:  First, it will look for the three environment variables  SHOTGUN_PATH_WINDOWS,  SHOTGUN_PATH_MAC, and  SHOTGUN_PATH_LINUX. If these are defined, the method will attempt to translate the path this way. For example, if you are trying to resolve  file:///prod/proj_x/assets/bush/file.txt  on Windows, you could set up  SHOTGUN_PATH_WINDOWS=P: prod  and  SHOTGUN_PATH_LINUX=/prod  in order to hint the way the path should be resolved.  If you want to use more than one set of environment variables, in order to represent multiple storages, this is possible by extending the above variable name syntax with a suffix:  If you have a storage for renders, you could for example define  SHOTGUN_PATH_LINUX_RENDERS,  SHOTGUN_PATH_MAC_RENDERS, and  SHOTGUN_PATH_WINDOWS_RENDERS  in order to provide a translation mechanism for all  file://  URLs published that refer to data inside your render storage.  Then, if you also have a storage for editorial data, you could define  SHOTGUN_PATH_LINUX_EDITORIAL,  SHOTGUN_PATH_MAC_EDITORIAL, and  SHOTGUN_PATH_WINDOWS_EDITORIAL, in order to provide a translation mechanism for your editorial storage roots.Once you have standardized on these environment variables, you could consider converting them into a ShotGrid local storage. Once they are defined in the ShotGrid preferences, they will be automatically picked up and no environment variables will be needed.  In addition to the above, all local storages defined in the ShotGrid preferences will be handled the same way.  If a local storage has been defined, but an operating system is missing, this can be supplied via an environment variable. For example, if there is a local storage named  Renders  that is defined on Linux and Windows, you can extend to support mac by creating an environment variable named  SHOTGUN_PATH_MAC_RENDERS. The general syntax for this is  SHOTGUN_PATH_&amp;lt;WINDOWS|MAC|LINUX&amp;gt;_&amp;lt;STORAGENAME&amp;gt;.  If no root matches, the file path will be returned as is.Here’s an example:Say you’ve published the file  /projects/some/file.txt  on Linux, and a ShotGrid publish with the URL  file:///projects/some/file.txt  was generated. In your studio, the Linux path  /projects  equates to  Q: projects  on Windows, and hence you expect the full path to be translated to  Q: projects some file.txt.All of the following setups would handle this:  A general environment-based override:  SHOTGUN_PATH_LINUX=/projects  SHOTGUN_PATH_WINDOWS=Q: projects      SHOTGUN_PATH_MAC=/projects        A ShotGrid local storage called “Projects”, set up with:    Linux Path:  /projects  Windows Path:  Q: projects      Mac Path:  /projects        A ShotGrid local storage called “Projects”, augmented with an environment variable:    Linux Path:  /projects  Windows Path:  Mac Path:  /projects  SHOTGUN_PATH_WINDOWS_PROJECTS=Q: projectsNote:  If you have a local storage  Renders  defined in ShotGrid with  Linux path  set, and also a  SHOTGUN_PATH_LINUX_RENDERS  environment variable defined, the storage will take precedence, the environment variable will be ignored, and a warning will be logged. Generally speaking, local storage definitions always take precedence over environment variables.Advanced configurationFor information on the underlying method that performs the resolution of PublishedFile paths, take a look at our  developer reference docs.If you are using Advanced Project Setup, you can add support beyond local file links and  file://  URLs by customizing the  resolve_publish  core hook. Possible customizations include:  Publishes with associated uploaded files could be automatically downloaded into an appropriate cache location by the core hook and the path would be be returned.  Custom URL schemes (such as  perforce://) could be resolved into local paths.Browser IntegrationBrowser integration for ShotGrid Toolkit refers to access to Toolkit apps and launchers by way of right-click context menus in the ShotGrid web application. These menus, an example of which is shown above, contain actions configured for various entity types. In the case where you have multiple pipeline configurations for a project, the actions are organized by pipeline configuration. Browser integration allows you to launch content creation software like Maya or Nuke that is aware of your ShotGrid context, right from the browser.A Brief History of Browser IntegrationOver the years, ShotGrid Toolkit’s browser integration has taken several forms. As technologies and security requirements have progressed, so has the approach to implementing browser integration.Java Applet (deprecated)The first implementation consisted of a Java applet that provided access to the local desktop from the ShotGrid web application. As Java applets became recognized as an exploitable security risk, they fell out of favor, necessitating its deprecation.Browser Plugin (deprecated)Replacing the deprecated Java applet was a browser plugin making use of NPAPI to access the local desktop from the ShotGrid web application. As NPAPI also became known as a security risk, the major web browsers began blocking its use. This necessitated deprecating the browser plugin.Websockets v1 via ShotGrid Desktop (legacy)Hosting a websocket server within the ShotGrid Desktop app was, and still is, the approach to communicating with the local desktop from the ShotGrid web application. The first implementation of this websocket server’s RPC API made use of the same underlying technology developed for the Java applet and browser plugin before it. When the server received a request from ShotGrid, the tank command from the associated project’s pipeline configuration was used to get the list of commands to show in the action menu.Websockets v2 via ShotGrid DesktopThe second iteration of the websocket server’s RPC API changes the underlying mechanism used to get, cache, and execute Toolkit actions. This implementation addresses a number of performance issues related to the earlier browser integration implementations, improves the visual organization of the action menus, and adds support for  out-of-the-box ShotGrid Integrations, which work without explicitly configuring Toolkit. This is the current implementation of browser integration.ConfigurationTo control what actions are presented to the user for each entity type, you modify YAML environment files in your project’s pipeline configuration. There are a few things to understand and consider when first attempting customization.Which engine configuration?The Toolkit engine that manages Toolkit actions within the ShotGrid web app is  tk-shotgun, so it’s this engine’s configuration that controls what shows up in the action menus.In the above example from  tk-config-basic, there are two apps configured that will result in a number of engine commands turned into menu actions. Toolkit apps will register commands that are to be included in the action menu, including launcher commands for each software package found on the local system that correspond to the list of  Software entities  in the ShotGrid site. The result is the list of menu actions shown here:The browser integration code found installations of Houdini, Maya, Nuke, and Photoshop on the user’s system, which resulted in menu actions for launching each of those integrations. Note that in a given environment configuration file, the  engine  for a Software entity needs to be present in order for that Software’s launcher to show up for entities of that environment. So, in this example, the  tk-houdini,  tk-maya,  tk-nuke, and  tk-photoshopcc  engines must all be present in the file from which this snippet was taken. If you wanted to remove, for example, Maya from the list of launchers on this entity, you could just remove the  tk-maya  engine block from the environment config file.In addition to these launchers, the Publish app’s “Publish…” command is included in the menu.Which YML file?You can take one of two paths: making use of the primary environment configuration (config/env/*.yml), as controlled by the config’s  pick_environment.py core hook, or the legacy approach employed by  tk-config-default, which uses  config/env/shotgun_&amp;lt;entity_type&amp;gt;.yml  files.In the case where the standard environment files are used, browser integration uses the  pick_environmentcore hook to determine which environment configuration file to use for a given entity’s action menu. In the simplest case, the environment corresponds to the entity type. For example, if you right-click on a Shot, the resulting action menu will be configured by the  tk-shotgun  block in  config/env/shot.yml. You can customize the  pick_environment  hook to use more complex logic. Should there be no  tk-shotgun  engine configured in the standard environment file, a fallback occurs if a  shotgun_&amp;lt;entity_type&amp;gt;.yml  file exists. This allows browser integration to work with legacy configurations that make use of the entity-specific environment files.Tip: Removing Software from the Browser Launchers with tk-config-default2Updating the configuration for launching software from the ShotGrid browser varies from tk-config-default to tk-config-default2.With tk-config-default2, updates should be applied to config/env/includes/settings/tk-shotgun.yml, whereas in tk-config-default, they were done in config/env/shotgun_task.yml.As an example, let’s remove Mari from the list of options when launching from an Asset through the browser.First, navigate to  config/env/asset.yml  and notice how the  tk-shotgun  engine engine block is pointing to  @settings.tk-shotgun.asset. The  @  symbol signifies that the value for the configuration is coming from an included file. This means you’ll need to go to your  env/includes/settings/tk-shotgun.yml  to make the update.While in your  env/includes/settings/tk-shotgun.yml, notice how each block is per Entity. So, for instance, Asset first:&amp;lt;a name=&quot;asset&quot;&amp;gt;&amp;lt;/a&amp;gt;# assetsettings.tk-shotgun.asset:  apps:    tk-multi-launchapp: &quot;@settings.tk-multi-launchapp&quot;    tk-multi-launchmari: &quot;@settings.tk-multi-launchapp.mari&quot;    tk-multi-launchmotionbuilder: &quot;@settings.tk-multi-launchapp.motionbuilder&quot;    tk-multi-publish2: &quot;@settings.tk-multi-publish2.standalone&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-shotgun-folders: &quot;@settings.tk-shotgun-folders&quot;    tk-shotgun-launchfolder: &quot;@settings.tk-shotgun-launchfolder&quot;  location: &quot;@engines.tk-shotgun.location&quot;To remove Mari from the list of options on an Asset in the browser, remove the Mari line (tk-multi-launchmari: &quot;@settings.tk-multi-launchapp.mari&quot;):&amp;lt;a name=&quot;asset&quot;&amp;gt;&amp;lt;/a&amp;gt;# assetsettings.tk-shotgun.asset:  apps:    tk-multi-launchapp: &quot;@settings.tk-multi-launchapp&quot;    tk-multi-launchmotionbuilder: &quot;@settings.tk-multi-launchapp.motionbuilder&quot;    tk-multi-publish2: &quot;@settings.tk-multi-publish2.standalone&quot;    tk-multi-screeningroom: &quot;@settings.tk-multi-screeningroom.rv&quot;    tk-shotgun-folders: &quot;@settings.tk-shotgun-folders&quot;    tk-shotgun-launchfolder: &quot;@settings.tk-shotgun-launchfolder&quot;  location: &quot;@engines.tk-shotgun.location&quot;Then, follow the same instructions for each entity (like Shot) from which you’d like to remove the ability to launch a particular software in the ShotGrid browser. Note that once you save the file, you may need to wait a minute and hard-refresh the browser for it to take effect.CachingBrowser integration has a robust caching mechanism, which allows menu actions to be shown to the user as quickly as possible. This is necessary because the process of bootstrapping Toolkit and getting a list of engine commands can be time consuming.When is the cache invalidated?The websocket server’s RPC API looks at two things to determine whether the cached data is still valid: YAML file modification times, and the contents of the site’s Software entities. If one of the environment YAML files in a given config has been modified since the cache data was written, the requisite data is recached and fresh data returned to the ShotGrid web application. Similarly, if any field on any Software entity in ShotGrid has been modified since the data was cached, Toolkit is bootstrapped and new data is cached.Where is the cache file on disk?The cache file location is dependent upon the operating system.`OS X: ~/Library/Caches/Shotgun/&amp;lt;site_name&amp;gt;/site.basic.desktop/tk-desktopWindows: %APPDATA% Shotgun &amp;lt;site_name&amp;gt; site.basic.desktop tk-desktopLinux: ~/.shotgun &amp;lt;site_name&amp;gt; site.basic.desktop tk-desktopHook MethodsA  browser_integration.py  hook is included in  tk-framework-desktopserver, which provides the following hook methods:  get_cache_key: This method determines the cache entry’s key for the given configuration URI, project entity, and entity type. The default implementation combines the configuration URI and entity type.  get_site_state_data: This method can be used to include additional queried data from ShotGrid into the hash that’s used to test the validity of cached data. By default, the state of all Software entities that exist on the site are used, but if additional data should be included in the hash, that can be implemented in this hook method.  process_commands: This method provides a place to customize or alter the commands that are to be returned to the ShotGrid web application. The data structure provided to the method is a list of dictionaries, with each dictionary representing a single menu action. Data can be altered, filtered out, or added into the list as is necessary and will be reflected in the menu requesting Toolkit actions immediately.LogsLogs for browser integration can be found in Toolkit’s  standard log location. The relevant log files are  tk-desktop.log  and  tk-shotgun.log. In addition, if you are using Google Chrome, some relevant log output is sometimes available in the developer console within the browser.TroubleshootingThe complex nature of communicating from a web application with the local desktop means that there are possible points of failure along the way. Below are a few such situations and some suggestions of first steps to take when you encounter them.“Open or install ShotGrid Desktop…” shown in the action menuThis likely means one of three things:      ShotGrid Desktop is not currently running on the local machine. It seems obvious, but it is definitely worth double checking.        Chrome or the Python websocket server has refused the connection, resulting in the ShotGrid web application being unable to communicate with ShotGrid Desktop. This situation is most likely related to the self-signed certificates that allow the connection to proceed when requested. Regenerating these certificates from scratch often resolves the issue, and can be triggered from ShotGrid Desktop, as shown below.    ShotGrid Desktop’s websocket server failed to start on launch. This situation is likely limited to situations where a bad release of the websocket server has gone out to the public, which should be exceedingly rare. In this situation, logging will be present in  tk-desktop.log  explaining the error, which can be  sent to ShotGrid’s support team.No actions are shown in the action menuThis is indicative of a configuration problem if actions were expected for this entity type. Some possible issues:      The  tk-shotgun  engine is configured in the correct environment YAML file, but there are no apps present in that configuration. In this case, it’s likely that the intention was for no actions to be present for this entity type.        The  tk-shotgun  engine is configured in the correct environment YML file, and apps are present, but actions still do not appear in the menu. This is likely due to apps failing to initialize. In this case, there will be information in  tk-shotgun.log and tk-desktop.log  describing the problems.        The environment that corresponds to this entity type does not contain configuration for  tk-shotgun. The end result here is the same as #1 on this list. In this case, you can look at the pipeline configuration’s  pick_environment  hook to determine which environment is being loaded for this entity type, and the configuration of  tk-shotgun  can be verified there.        There is an empty list of menu actions cached on disk. To force the cache to be regenerated, there are a few options:          Update the modification time of a YAML file in your project’s configuration. This will trigger a recache of menu actions when they are next requested by ShotGrid. Worth noting is that this will trigger a recache for  all  users working in the project.      Update the value of a field in any of the Software entities on your ShotGrid site. The behavior here is the same as the above option concerning YAML file modification time, but will invalidate cached data for all users in  all  projects on your ShotGrid site. Software entities are non-project entities, which means they’re shared across all projects. If data in any of the Software entities is altered, all projects are impacted.      The cache file can be deleted on the host suffering from the problem. It is typically safe to remove the cache, and since it is stored locally on each host, it will only cause data to be recached from scratch on that one system. The cache is stored in the following SQLite file within your ShotGrid cache location:  &amp;lt;site-name&amp;gt;/site.basic.desktop/tk-desktop/shotgun_engine_commands_v1.sqlite      “Toolkit: Retrieving actions…” is never replaced with menu actionsThere are a few possibilities for this one:      The websocket server has not yet finished caching actions. If this is the first time actions are being retrieved after a significant update to the project’s config, the process can take some time to complete. Wait longer, and observe the contents of  tk-desktop.log  to see if processing is still occurring.        The websocket server has failed to respond and never will. This situation should be rare, but if it becomes obvious that there is no additional processing occurring as a result of the request for actions, as seen in  tk-desktop.log,  contact ShotGrid support, providing relevant log data.        The user is working in more than one ShotGrid site. With ShotGrid Desktop authenticated against a single site, requesting menu actions from a second ShotGrid site results in the user being queried about restarting ShotGrid Desktop and logging into the new site. If that request is ignored, the second site will never receive a list of menu actions.  Toolkit Configuration FileIf your studio is using a proxy server, if you want to pre-populate the initial login screen with some values, or if you want to tweak how the browser-based application launcher integrates with ShotGrid Desktop, there is a special configuration file called  toolkit.ini. ShotGrid Desktop does not require this file in order to run; it’s only needed if you need to configure its behavior. Toolkit looks for the file in multiple locations, in the following order:  An environment variable named  SGTK_PREFERENCES_LOCATION  that points to a file path.  Inside the ShotGrid Toolkit preferences folder: (Note that this file does not exist by default in these locations; you must create it.)          Windows:  %APPDATA% Shotgun Preferences toolkit.ini      macOS:  ~/Library/Preferences/Shotgun/toolkit.ini      Linux:  ~/.shotgun/preferences/toolkit.ini      The  SGTK_PREFERENCES_LOCATION  environment variable option allows you to store your configuration file somewhere else on your computer or on your network. Please note that  toolkit.ini  is the current standard file name. If you were using  config.ini, check below in the  “Legacy Locations”  section.You can see a documented example of a configuration file  here.Please note that this example file is called  config.ini  but it can be just renamed to  toolkit.iniPlease also note that you can use environment variables as well as hard coded values in this file, so that you could, for example, pick up the default user name to suggest to a user via the USERNAME variable that exists on Windows.Legacy Locations (DEPRECATED)Although  toolkit.ini  is the current standard file name, we previously used a  config.ini  file for same purpose. The contents of  toolkit.ini  and  config.ini  are the same. The  config.ini  will be searched for using the following deprecated locations:  An environment variable named  SGTK_DESKTOP_CONFIG_LOCATION  that points to a file.  In the following paths:          Windows:  %APPDATA% Shotgun desktop config config.ini      macOS:  ~/Library/Caches/Shotgun/desktop/config/config.ini      Linux:  ~/shotgun/desktop/config/config.ini      Proxy ConfigurationIf your studio is accessing the internet through a proxy, you’ll need to tell Toolkit to use this proxy when it accesses the Internet. Do so by specifying your proxy as the value of the  http_proxy  setting:http_proxy: &amp;lt;proxy_server_address&amp;gt;Running ShotGrid Desktop with a locally hosted siteIf your ShotGrid site URL does not end with  shotgunstudio.com or shotgrid.autodesk.com, it means that you are running a local ShotGrid site. In this case, it is possible that your site has not yet been fully prepared for ShotGrid integrations and the ShotGrid team may need to go in and do some small adjustments before you can get going! In this case,  please submit a ticket  and we’ll help sort you out.Connecting to the app store with a locally hosted siteIf you are using a local ShotGrid site with access to the Internet through a proxy, you might want to set an HTTP proxy for accessing the app store, but not the local ShotGrid website. To do this, simply add the following line to  toolkit.ini:app_store_http_proxy: &amp;lt;proxy_server_address&amp;gt;where  &amp;lt;proxy_server_address&amp;gt;  is a string that follows the convention documented  in our developer docs.If you need to override this setting on a per-project basis, you can do so in  config/core/shotgun.yml  in your project’s Pipeline Configuration.Configuring the thumbnail display in ShotGrid DesktopShotGrid Desktop will now resize non-square images used as thumbnails to show the entire image as shown by the Demo: Automotive project in the image.If you would like to revert to the previous cropping behavior you can use the SGTK_PROJ_THUMB_OLD environment variable.Offline Usage ScenariosImportant: These offline usage scenarios only apply to locally installed instances of ShotGrid. Local installations of ShotGrid are no longer offered. This documentation is intended only for those with existing instances of Shotgun Enterprise Docker. Click here for a list of our current offerings.In general use, ShotGrid Desktop automatically checks for updates for the Desktop app itself, the tk-desktop engine, and the basic configuration at launch time. However, there are cases where you might want to run integrations while offline or on machines that are completely disconnected from the Internet. The following section describes how to address each of these scenarios.ShotGrid CreateThe approaches to resolving offline usage scenarios outlined in this document also apply to the integration features provided by  ShotGrid Create. The various environment variables used to tailor the behavior of ShotGrid Toolkit, such as  SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS, apply when using ShotGrid Create in the same ways as ShotGrid Desktop.Running integrations while offlineScenario: I want to run ShotGrid integrations, but I am not connected to the Internet. We have a local ShotGrid install.Solution  If you can temporarily connect to the internet, just download ShotGrid Desktop. It comes prepackaged with a set of  integrations, and pre-bundled with all the apps and engines needed for the ShotGrid integrations for all supported DCCs. When you start it up, it will automatically try to look for upgrades, but if it cannot connect to the ShotGrid App Store, it will simply run the most recent version that exists locally.Good to know  Some Toolkit operations (such as registering a Publish) require access to your ShotGrid site. So, this solution only works for locally hosted sites.  Updates are downloaded to your local machine.  If you switch between being connected and disconnected, Desktop, as well as in-app integrations like those inside Maya and Nuke, will download upgrades at startup whenever they are connected.Managing updates via manual downloadScenario: Our artist workstations are disconnected from the internet, so we cannot use the auto-updates in Desktop. We still want to get updates, but we have to download them via a single online machine and manually transfer them to artists or into a centralized location.Solution  Run ShotGrid Desktop on a workstation connected to the internet. When it starts up, the latest upgrades are automatically downloaded at launch time.  Option 1: Shared Desktop bundle  Copy the  bundle cache  to a shared location where all machines can access it.  Set the  SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS  environment variable on offline machines to point to this location.  When Desktop starts up on offline machines, they will pick up the latest upgrades that are available in the bundle cache.  Option 2: Local deployment  Distribute the updated bundle cache to the correct bundle cache location on each local machine.Good to know  With Option 1, the Toolkit code will be loaded from the location defined in  SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS. If this location is on a shared storage, make sure that it is performant enough to load many small files.  For Windows setups, this is often not the case. Here we would instead recommend Option 2.Locking off updatesWhile Desktop’s auto-updates are handy for making sure you always have the latest, sometimes you’ll want to freeze a project, or even your whole site, locking it to a specific version and preventing any updates.Freezing updates for a single projectScenario: My project is about to wrap and I would like to freeze it so that no ShotGrid integration updates are automatically downloaded.Solution  Determine the version you want to lock your project to.  You can find the integration releases here.  In ShotGrid, create a Pipeline Configuration entity for the project you want to lock down, with the following fields populated (In this example, we are locking down the config to use v1.0.36 of the integrations):  Name:  Primary  Project: The project you want to lock down  Plugin ids:  basic.*      Descriptor:  sgtk:descriptor:app_store?name=tk-config-basic&amp;amp;version=v1.0.36    Anyone starting ShotGrid Desktop on the project will now always use v1.0.36. Any new users starting to work on the project will also get v1.0.36.Good to know  Updates are downloaded to your local machine.  The next time a user launches Desktop while connected to the Internet,  v1.0.36  of the basic config, and all of its related code, will be downloaded to their machine.  basic.*  means that all plugins in the basic configuration will pick up this override. If, for example, you wanted to freeze the Nuke and Maya integrations only, you could specify  basic.maya, basic.nuke.  To test, you can create a duplicate of this Pipeline Configuration entity, and add your username to the  User Restrictions  field. This will restrict the entity such that it’s only available to you and won’t impact other users. You can then launch Maya or some other software from this duplicate configuration and confirm that it’s running the expected integrations versions.Known issues  The Flame integration is namespaced  basic.flame, and so is implied to be part of  basic.*. However, the Flame integration isn’t actually included in the basic config. So, if you are using Flame for a project and implement this override, the Flame integration will stop working.  The solution would be to create an additional Pipeline Configuration override specifically for flame:  Name:  Primary  Project: The project you want to lock down (or None for all projects)  Plugin ids:  basic.flame  Descriptor:  sgtk:descriptor:app_store?name=tk-config-flamepluginFreezing updates for your siteScenario: I don’t want any updates. I want full control over what is being downloaded and used in all projects in my studio.Solution  Follow the steps in the above example, but leave the  Project  field blank. With no override in the  Project  field, this Pipeline Configuration entity will apply to all projects, including the “site” project, i.e., the site configuration that is used by Desktop outside of any project.Good to know  This is the workflow to use if you want to “lock down the site config”. This would lock down everything, and you can then proceed with the advanced project setup via the Desktop menu.  If you lock down your entire site to use, for example,  v1.2.3, you can still lock down an individual project to use another config.Known issues  Flame would be affected by this. See the ‘Known Issues’ section of the above scenario for a solution.Freezing updates for all but one projectScenario: I’d like to lock down all projects in our site, except for our test project, which we still want to allow to auto-update.Solution  Freeze updates for your site as described in the above section.  Configure the exception project’s Pipeline Configuration entity to have the following field values:  Name:  Primary  Project: The project you want  not  to lock down  Plugin ids:  basic.*  Descriptor:  sgtk:descriptor:app_store?name=tk-config-basicGood to know  Note that you’ve omitted the version number from the Descriptor field for the project. This will mean that the project is tracking the latest release of the basic config.Safely Upgrading a locked off site  Scenario: We’re locked down to v1.0.0, and we’d like to upgrade to v2.0.0, but first I want to test out the new version before deploying it to the studio.*Solution  Duplicate the Pipeline Configuration entity in ShotGrid by right-clicking on it and selecting “Duplicate Selected”.  Name the cloned config “update test”, and assign yourself to the User Restrictions field.  You will now begin to use this Pipeline Configuration.  Change the descriptor to point to the version you wish to test.  You can invite any users you want to partake in testing by adding them to the User Restrictions field.  Once you are happy with testing, simply update the main Pipeline Configuration to use that version.  Once users restart Desktop or DCCs, the update will be picked up.Taking over a Pipeline ConfigurationWithout setting up any configurations, you get a basic set of ShotGrid integrations out-of-the-box, and this document covers the kinds of administration you can do with these out-of-the-box integrations. This basic setup is built on top of ShotGrid’s Toolkit platform, which supports much richer customization. Within Desktop, the Toolkit Project Setup Wizard will lead you through the process of creating a full, customizable Pipeline Configuration for your project.Each section below explains in detail each of the steps of the Wizard with examples and suggestions of sensible default values in case you are not sure how to set things up.Launching the setup wizard from DesktopOnce you have navigated to a project there will be an “Advanced Project Setup…” menu item in the user menu in the bottom right hand of Desktop. Click on this menu item to launch the Toolkit Setup Wizard.Select a configuration typeWhen you start configuring a new project, the first thing to decide is  which configuration template to use. A configuration template is essentially the complete project configuration with all settings, file system templates, apps and logic needed to run the project.  If this is your very first project, head over to the ShotGrid defaults to get you started.  If you already have configured projects and configurations for previous projects, you can easily reuse these by basing your new project on an existing project  For advanced workflows, you can use external configurations or configs stored in git repositories.The Default ConfigurationThis is the default Toolkit VFX configuration and usually a great starting point when you start setting things up. It comes with 3dsmax, Flame, Houdini, Nuke, Mari, Maya, Motionbuilder, and Photoshop set up and contains a simple, straight forward folder setup on disk.The configuration contains a number of different pieces:  A file system setup  A set of templates to identify key locations on disk  A set of preconfigured engines and apps which are chained together into a workflow.File System OverviewThe standard config handles Assets and Shots in ShotGrid. It breaks things down per Pipeline Step. A pipeline step is similar to a department. Each pipeline step contains work and publish areas for the various supported applications. The Shot structure looks like this:Applications and workflowsThe config contains the following components:  Maya, Mari, Nuke, 3dsmax, Flame, Houdini, Photoshop, and Motionbuilder support  ShotGrid Application Launchers  Publishing, Snapshotting, and Version Control  A Nuke custom Write Node  ShotGrid integration  A number of other tools and utilitiesIn addition to the apps above, you can easily install additional apps and engines once the config has been installed.Basing your new project on an existing projectThis is a quick and convenient way to get up and running with a new project with all the defaults and settings that you had in a previous project. Toolkit will simply copy across the configuration from your old setup to the new project. This is a simple and pragmatic way to evolve your configuration - each new project is based on an older project.For more ways and documentation on how to evolve and maintain your pipeline configuration, see here:Managing your project configurationUsing a configuration template from gitUse this option if you want to keep your project’s configuration connected to source control. Specify a url to a remote git or github repository and the setup process will clone it for you. Note that this is not just github, but works with any git repository. Just make sure that the path to the repository ends with  .git, and Toolkit will try to process it as a git setup. Because your project configuration is a git repository, you can commit and push any changes you make to your master repository and beyond that to other projects. Using a github based configuration makes it easy to keep multiple Toolkit projects in sync. You can read more about it here:Managing your project configurationPlease note that if you are running on Windows, you need to have git installed on your machine and accessible in your  PATH. On Linux and Mac OS X, it is usually installed by default.Browsing for a configuration templateUse this option if you have a configuration on disk, either as a folder or zipped up as a zip file. This can be useful if someone has emailed a configuration to you or if you keep a master config on disk which you are basing all your projects on. This is usually an expert option and we recommend either using a config from another project or one of our app store default configs.Setting up a storageEach Toolkit project writes all its files and data to one or more shared storage locations on disk. For example, a configuration may require one storage where it keeps textures, one where it keeps renders and one where it stores scene files. Normally, these storages are controlled from within the ShotGrid Site Preferences, under the  File Management  tab.The Toolkit Setup wizard will ask you to map each storage root required by the configuration to a local storage in ShotGrid.The required root is listed on the left with its description (as defined in the configuration’s  roots.yml  file). On the right, a list of existing ShotGrid local storages is listed. You must select a storage for each required root and enter a path for the current OS if one does not already exist in ShotGrid.You can also add paths for other operating systems that have not been defined. Existing paths are locked to ensure you don’t accidentally affect other projects that may be relying on that storage path. The mapping page in the wizard will ensure that you’ve mapped each required root and that each mapping is valid.You can create a new local storage in the wizard as well by selecting the  +New  item at the end of the storage selection list. You will be prompted for a local storage name and path for the current OS.Once the project is being set up, Toolkit will create a folder for each new project in each of the storage locations. For example, if your primary storage location is  /mnt/projects, a project called  The Edwardian Cry  would end up in  /mnt/projects/the_edwardian_cry. And if the config is using more than just the primary storage, each of the storages would end up with an  the_edwardian_cry  folder.Your primary storage location is typically something like  /mnt/projects  or    studio projects  and is typically a location where you are already storing project data, grouped by projects. It is almost always on a shared network storage.Choosing a project folder nameNow it is time to choose a disk name for your project. This folder will be created in all the different storages which are needed by the configuration. You can see a quick preview in the UI - for most configurations this will only preview the primary storage, but if you are using a multi root config, additional storages will show up too. Toolkit will suggest a default project name based on the name in ShotGrid. Feel free to adjust it in order to create what is right for your setup.Selecting a configuration locationLastly, please decide where to put your configuration files on disk. Toolkit will suggest a location based on previous projects, so that they all end up in the same place on disk.The configuration normally resides on a shared storage or disk, so that it can be accessed by all users in the studio who needs it. If you are planning on using more than one operating system for this project, make sure to enter all the necessary paths. All paths should represent the same location on disk. Often, the path can be the same on Mac OS X and Linux but will be different on Windows.If this is your first project, you typically want to identify a shared area on disk where you store all your future pipeline configurations. This is typically a location where you store software or software settings shared across the studio. This could be something like  /mnt/software/shotgun. It may vary depending on your studio network and file naming conventions.When you set up your first configuration, set it up with paths for all the platforms you use in your studio. This will make it easier later on to create an environment which is accessible from all machines. As a hypothetical example, if your project name is  Golden Circle  you may type in the following three paths:linux:   /mnt/software/shotgun/golden_circlemacosx:  /servers/production/software/shotgun/golden_circlewindows:   prod software shotgun golden_circleWhat can I do once I have a configuration?Once you are up and running with your first configuration, please navigate to our ‘next steps’ documentation to learn more about how to configure and adjust Toolkit to better suite your studio needs:Beyond your first projectAdvanced functionalitySilent installsIf you are on a Windows network, you can use the argument “/S” to force the .exe ShotGrid Desktop installer to do a silent install. Then you can push a copy of the shortcut to the executable to the startup folder.",
    "url": "/8085533c/",
    "relUrl": "/8085533c/"
  },
  "68": {
    "id": "68",
    "title": "통합",
    "content": "RV 통합RV는 서로 다른 기능 세트를 가진 여러 ShotGrid 통합(ShotGrid Integration, RV용 Screening Room 및 ShotGrid Review)을 비롯해 Nuke 및 Maya를 위한 통합 도구가 함께 제공됩니다.앞쪽의 두 문서에서는 Nuke 및 Maya 통합의 설치 및 워크플로우에 대해 설명하며, 뒤쪽의 두 문서에서는 선택에 도움을 주기 위해 다양한 ShotGrid 통합에 대해 설명합니다.",
    "url": "/268002fe/",
    "relUrl": "/268002fe/"
  },
  "69": {
    "id": "69",
    "title": "Invalid LUT selected",
    "content": "error Invalid LUT selected : Gamma2.2Use case:While working in an ACES color management project, when you use the default toolkit publishing, it fails with an error  Invalid LUT selected : Gamma2.2.What’s causing the error?There is an app that creates the quicktime that is a part of the toolkit publishing from Nuke called  tk-multi-reviewsubmission,  and by default it will create a QT that works with Nukes standard color model.How to fixSince you are using ACES (I’m assuming the ICIO model), we just need to change the colorspace setting in the  tk-multi-reviewsubmission  app by taking over and adding it into the  codec_settings.py  hook.Codecs vary per preference, but in this example, we’re using the  Output - sRGB Codec: So in the  codec_settings.py hook add the setting  settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;  to where it makes sense for your setup. (I’ve just added it everywhere)        settings = {}        if sys.platform in [&quot;darwin&quot;, &quot;win32&quot;]:            settings[&quot;file_type&quot;] = &quot;mov&quot;            if nuke.NUKE_VERSION_MAJOR &amp;gt;= 9:                # Nuke 9.0v1 changed the codec knob name to meta_codec and added an encoder knob                # (which defaults to the new mov64 encoder/decoder).                                  settings[&quot;meta_codec&quot;] = &quot;jpeg&quot;                settings[&quot;mov64_quality_max&quot;] = &quot;3&quot;                settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;            else:                settings[&quot;codec&quot;] = &quot;jpeg&quot;                settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;        elif sys.platform == &quot;linux2&quot;:            if nuke.NUKE_VERSION_MAJOR &amp;gt;= 9:                # Nuke 9.0v1 removed ffmpeg and replaced it with the mov64 writer                # https://help.thefoundry.co.uk/nuke/9.0/#appendices/appendixc/supported_file_formats.html                settings[&quot;file_type&quot;] = &quot;mov64&quot;                settings[&quot;mov64_codec&quot;] = &quot;jpeg&quot;                settings[&quot;mov64_quality_max&quot;] = &quot;3&quot;                settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;            else:                # the 'codec' knob name was changed to 'format' in Nuke 7.0                settings[&quot;file_type&quot;] = &quot;ffmpeg&quot;                settings[&quot;format&quot;] = &quot;MOV format (mov)&quot;                settings[&quot;colorspace&quot;] = &quot;Output - sRGB&quot;        return settingsNow if you got all that right then when you publish in Nuke the QT will be made in an ACES compatible colorspace!See the full thread in the community.",
    "url": "/749984aa/",
    "relUrl": "/749984aa/"
  },
  "70": {
    "id": "70",
    "title": "Knowledge",
    "content": "Generic KnowledgeIn This Section  Connecting Your Studio With Your AWS VPC  ShotGrid AWS Direct Connect Onboarding  S3  VPC / IAM / Security Group  Direct Connect  Private Link  VPC Endpoints  AWS Knowledge",
    "url": "/540597cc/",
    "relUrl": "/540597cc/"
  },
  "71": {
    "id": "71",
    "title": "Learn",
    "content": "ShotGrid Isolation - LearnThis section will host a learning curriculum for ShotGrid Isolation features n the near future.",
    "url": "/da5a2d10/",
    "relUrl": "/da5a2d10/"
  },
  "72": {
    "id": "72",
    "title": "In Maya, when I print context.task, it is empty “None”",
    "content": "In Maya, when I print context.task, it is empty “None”Use CaseWhen in Maya, after printing context.task, it is empty “None”, but when trying other layout files from a different step/task, shows up the context.task details. It’s also possible to print context.task details when navigating through Open &amp;gt; Layout &amp;gt; new file, but when saving the file via File Save, the context.task is None.How to fixTry unregistering the folders for one of the Shots that doesn’t work, and then run the folder creation for it again.Related linksSee the full thread in the community",
    "url": "/38c4e054/",
    "relUrl": "/38c4e054/"
  },
  "73": {
    "id": "73",
    "title": "How do I add a shelf button to launch a Toolkit app in Maya?",
    "content": "How do I add a shelf button to launch a Toolkit app in Maya?Adding a shelf button in Maya to launch Toolkit apps in Maya is pretty straightforward. Here is an example of how to add a custom shelf button that opens the Loader app.                    Note: This assumes Toolkit is currently enabled in your Maya session. This example code does not bootstrap Toolkit.    Open your Script Editor in Maya and paste in the following Python code:import maya.cmds as cmds # Define the name of the app command we want to run.# If your not sure on the actual name you can print the current_engine.commands to get a full list, see below.tk_app = &quot;Publish...&quot;try:     import sgtk    # get the current engine (e.g. tk-maya)     current_engine = sgtk.platform.current_engine()     if not current_engine:         cmds.error(&quot;ShotGrid integration is not available!&quot;)     # find the current instance of the app.    # You can print current_engine.commands to list all available commands.    command = current_engine.commands.get(tk_app)     if not app:         cmds.error(&quot;The Toolkit app '%s' is not available!&quot; % tk_app)     # now we have the command we need to call the registered callback    command['callback']()except Exception, e:     msg = &quot;Unable to launch Toolkit app '%s': %s&quot; % (tk_app, e)    cmds.confirmDialog(title=&quot;Toolkit Error&quot;, icon=&quot;critical&quot;, message=msg)    cmds.error(msg)Select this code and drag it on to your custom shelf. See Maya docs for more info on how to work with custom shelf buttons.You should be able to use this code example to launch any Toolkit apps that are enabled in Maya by modifying the tk_app and call_func variables at the top.",
    "url": "/dba779a5/",
    "relUrl": "/dba779a5/"
  },
  "74": {
    "id": "74",
    "title": "Media Isolation",
    "content": "Media IsolationMedia Isolation allows your studio to retain ownership and control of the media and attachments that you upload to ShotGrid. With Media Isolation, all the content that you upload to ShotGrid is stored in your studio’s private S3 Bucket. Access to the media is provided to the ShotGrid services only, using AWS AssumeRole keyless Security Token Service.Client-Owned S3 BucketStoring media and attachments in an S3 bucket that you own means that you remain the legal owner of these artifacts, allowing you to comply with your company’s security and legal policies. Your studio retains control of asset storage and access, access that you can revoke at will.More about AccessWhen using ShotGrid to upload and download media it is transferred directly to / from AWS S3 without transiting through Autodesk infrastructure. ShotGrid will only access media in two situations:  The ShotGrid Transcoding service will get read/write access once, soon after upload, when transcoding the media. See Ephemeral Transcoding for details.  When the ShotGrid service generates S3 Links to your sources and transcoded media.This is rendered possible by leveraging AWS AssumeRole keyless Security Token Service. When setting up Media Isolation, an AWS Role allowing ShotGrid to access your media for the action listed above is created, and the ShotGrid service is allowed to assume that role.ShotGrid Support staff do not have access to your S3 Bucket under any circumstances.CostsWhen activating Media Isolation the following costs, previously covered by Autodesk, become the responsibility of the client:  S3 Costs. All the S3 storage costs will be assumed by the customer. See Media Isolation for more details about how to reduce costs.  S3 Bandwidth. Bandwidth out of the S3 bucket will be assumed by the customer.What Media Isolation is not providingActivating Media Isolation doesn’t guarantee that the access to your ShotGrid site or media takes place within a closed network.",
    "url": "/a3c0e676/",
    "relUrl": "/a3c0e676/"
  },
  "75": {
    "id": "75",
    "title": "Media Replication",
    "content": "Media ReplicationShotGrid is compatible with the S3 Cross-Region replication feature, allowing your users located in different regions to read from the region closer to them in order to reduce latency and increase throughput. Replication to one region is currently supported.Pre-requisitesMedia Isolation is required in order to elect Media Replication.Configuration by usersWhen using Media Replication, each user can customize which region data is read from. A user can either specify the region to use, or use automatic mode. In automatic mode ShotGrid selects the replica determined by the user’s IP address using IP ranges specified in the Isolation Preferences.How it worksShotGrid can be configured to read from up to two different buckets. Using the AWS S3 Replication feature, you can configure replication between buckets in different regions, and then consume media from the region closest to your users. It is important to underline that media is always uploaded to the main bucket.Following AWS service level agreement, S3 guarantees the replication of 99.99% of the object within 15 minutes.Replication DelayA small amount of time, typically under 15 minutes, is required before replication happens. The replication time depends on the size of the object to replicate. In order to alleviate that replication delay, ShotGrid will, for a small period of time, generate links from to object in the source bucket instead of the replica. The duration of this transitional state is configurable in the Isolation Preferences.CostsActivating the Media Replication feature can increase your AWS costs considerabibly. Before activating, be aware that:  Your S3 cost linked to ShotGrid usage will more or less double, because the media is now stored in two regions.  You will be charged for the transfer cost between the source and the destination region. See AWS S3 CRR and the destination region for more details.Next StepsSee Media Replication Setup for setup instructions.",
    "url": "/0221297e/",
    "relUrl": "/0221297e/"
  },
  "76": {
    "id": "76",
    "title": "Media Traffic Isolation",
    "content": "Media Traffic Isolation using AWS PrivateLink for Amazon S3                    Disclaimer: This documentation is provided solely as an example. It explains how to set up your ShotGrid Isolation environment so that it can be connected to ShotGrid cloud infrastructure. Please adapt it to your studio security requirements as needed. As ShotGrid has no visibility on your AWS Account, ensuring that this account is secure is a client responsibility.    The media traffic isolation feature allows your users to access media in your AWS S3 bucket privately (not transiting over the public Internet). Please note that if you have a multi-region setup and that leverages the ShotGrid Transcoding service there may still be instances where media transits across the public Internet. Reach out to our support team for more details.Media Isolation activation is a pre-requisite to enable this feature. If you haven’t done so already, see Media Isolation.Set up a VPC in your S3 bucket AWS regionYou will need to deploy a VPC with the required VPC endpoint. We provide a private VPC CloudFormation templates as starting points. This template create the necessary VPC, subnets and VPC endpoint.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL to https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-vpc-s3-privatelink.yml  Click Next  Set a stack name. Eg. ShotGrid-vpc  Choose network ranges that doesn’t conflict with your studio network and set subnet CIDR values accordingly  Set your S3 bucket name  Click Next  Click NextSet up access from your site network to your AWS VPCOptions provided by AWS:  AWS Site-to-Site VPN  AWS Direct Connect                    Note: If Direct Connect is chosen, we recommend testing with a simpler / faster solution in the meantime to validate your Isolation setup. You can then replace that solution with Direct Connect once it is available.    Add an S3 endpoint to your VPC                    Note: This step should only be performed if the CloudFormation template was not used.    Simply add an com.amazonaws.us-west-2.s3 Interface VPC Endpoint to your existing VPC. Make sure the associated security group allow traffic from your site network.Add the VPC to your S3 bucket policyIn order for the S3 VPC endpoint to communicate with your S3 bucket your bucket policy must allow access from the S3 endpoint’s VPC. You can find instructions on how to configure the policy in the Fine Tuning step.ValidationTest the S3 VPC endpointUse the endpoint URL to list objects in your bucket using AWS CLI. In the following example, replace the VPC endpoint ID vpce-1a2b3c4d-5e6f.s3.us-east-1.vpce.amazonaws.com and bucket name my-bucket with appropriate information.    aws s3 --endpoint-url https://bucket.vpce-1a2b3c4d-5e6f.s3.us-east-1.vpce.amazonaws.com ls s3://my-bucket/Configure site to use your S3 VPC endpointYou can test by adding a temporary entry to the S3 Configuration site preference on your site.The complete entry will look like the following:{​​​​​​​​   &quot;&amp;lt;S3_CONFIG_NAME&amp;gt;&quot;: {​​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​,   &quot;&amp;lt;S3_CONFIG_NAME_WITH_S3_VPC_ENDPOINT&amp;gt;&quot;: {​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;,     &quot;s3_interface_vpc_endpoint_dns_name&quot;: &quot;vpce-1234567-5e6f.s3.us-east-1.vpce.amazonaws.com&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​After the configuration has been updated on your site, navigate to the /admin/speedtest route of your ShotGrid site. Select the new S3_CONFIG_NAME_WITH_S3_VPC_ENDPOINT and start the test to confirm that all the upload/download tests work as intended.Once it has been verified to work correctly, add the value from s3_interface_vpc_endpoint_dns_name to the main S3 configuration S3_CONFIG_NAME and your current setup should be using Media Traffic Isolation.Erase the S3_CONFIG_NAME_WITH_S3_VPC_ENDPOINT entry from the S3 Configuration to clean up your configurations.Next StepsSee Media Replication to activate the Media Replication Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/2ab85e3e/",
    "relUrl": "/2ab85e3e/"
  },
  "77": {
    "id": "77",
    "title": "Media Traffic Isolation - S3 Proxy",
    "content": "                    Deprecated: The preferred way is to use S3 Private Link instead of a S3 proxy, see Media Traffic Isolation    Media Traffic Isolation using an S3 proxy (DEPRECATED)                    Disclaimer: This documentation is provided solely as an example. It explains how to set up your ShotGrid Isolation environment so that it can be connected to ShotGrid cloud infrastructure. Please adapt it to your studio security requirements as needed. As ShotGrid has no visibility on your AWS Account, ensuring that this account is secure is a client responsibility.    The media traffic isolation feature allows your users to access media in your AWS S3 bucket privately (not transiting over the public Internet). Please note that if you have a multi-region setup and that leverages the ShotGrid Transcoding service there may still be instances where media transits across the public Internet. Reach out to our support team for more details.Media Isolation activation is a pre-requisite to enable this feature. If you haven’t done so already, see Media Isolation.Set up a VPC in your S3 bucket AWS region                    Disclaimer: Before starting, decide whether your S3 proxy will be privately accessible within your VPC or publicly accessible via the Internet and choose the relevant templates in the following instructions.    You will need to deploy a VPC with the required VPC endpoints. We provide both private VPC and public VPC CloudFormation templates as starting points. These template create the necessary VPCs, subnets and VPC endpoints.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL depending upon your desired configuration          Private VPC (default):https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-vpc.yml      Public VPC:https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-public-vpc.yml        Click Next  Set a stack name. Eg. shotgun-vpc  Choose network ranges that doesn’t conflict with your studio network and set subnet CIDR values accordingly  Set your S3 bucket name  Click Next  Click NextSet up access from your site network to your AWS VPCOptions provided by AWS:  AWS Site-to-Site VPN  AWS Direct Connect                    Note: If Direct Connect is chosen, we recommend testing with a simpler / faster solution in the meantime to validate your Isolation setup. You can then replace that solution with Direct Connect once it is available.    Add an S3 endpoint to your VPC                    Note: This step should only be performed if the CloudFormation template was not used when configuring Media Isolation.    Set up S3 proxyYou will need to deploy an S3 proxy in your VPC to forward traffic to the S3 VPC endpoint. We provide both private and public S3 proxy CloudFormation templates as starting points for this purpose. These will create the necessary Elastic Container Service (ECS) cluster and other resources to run the S3 proxy on AWS Fargate behind an AWS Application Load Balancer (ALB).Make the Docker image available from a private AWS ECR repository  Create a new Elastic Container Registry (ECR) repository  Name the repository s3-proxy  Upload the s3-proxy Docker image to the newly created ECR repository          Install Docker on your workstation      Follow the docker login instructions shown by clicking the View push commands button      Run the following commands, substituting the ECR endpoint in the example for yours:        docker pull quay.io/shotgun/s3-proxy:1.0.6docker tag quay.io/shotgun/s3-proxy:1.0.6 627791357434.dkr.ecr.us-west-2.amazonaws.com/s3-proxy:1.0.6docker push 627791357434.dkr.ecr.us-west-2.amazonaws.com/s3-proxy:1.0.6                    Create S3 proxy CloudFormation stackCreate a new stack in AWS Console using either the private or public CloudFormation template.  Create a new CloudFormation stack  Select Template is ready  Set Amazon S3 URL depending upon your desired configuration          Private S3 proxy (default):https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-s3-proxy.yml      Public S3 proxy:https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-s3-proxy-public.yml        Click Next  Set a stack name up to 32 characters in length. Eg. shotgun-s3-proxy  Set the parameters that do not have default values with those used when creating the ECR repository, VPC and S3 bucket previously  Click Next  Accept I acknowledge that AWS CloudFormation might create IAM resources  Click NextConfigure HTTPSShotGrid requires that the S3 proxy be accessed via HTTPS, therefore the AWS ALB handling requests for your newly created S3 proxy stack must be configured to accept HTTPS requests.  Create a DNS entry pointing to your S3 proxy, depending upon whether public or private          Private S3 proxy (default):                  Go to the EC2 Load Balancers dashboard, select your S3 proxy’s ALB and make a note of the DNS name          Add a DNS CNAME record pointing to the DNS name of the ALBEg. s3-proxy.mystudio.com. 300 IN CNAME s3proxy-12R1MXX0MFFAV-2025360147.us-east-1.elb.amazonaws.com.                    Public S3 proxy:                  Go to the AWS Global Accelerator dashboard and make a note of the DNS name associated with your S3 proxy’s accelerator          Add a DNS CNAME record pointing to the DNS name of the Global AcceleratorEg. s3-proxy.mystudio.com. 300 IN CNAME a48a2a8de7cfd28d3.awsglobalaccelerator.com.                      Obtain an SSL certificate for your chosen URL, we recommend using AWS Certificate Manager (ACM) for this  Configure HTTPS for the S3 proxy by adding a new HTTPS listener to the AWS ALB          Go to the EC2 Load Balancers dashboard, select your S3 proxy’s ALB and click on the Listeners tab      Click Add listener      Select HTTPS from the Protocol dropdown menu      Click Add action -&amp;gt; Forward to…      Select your S3 proxy’s target group from the Target group dropdown menu      Select the Security policy you’d like to use. Eg. TLS-1-2-Ext-2018-06 (See AWS documentation for more information)      Select the SSL certificate you’d like to use from ACM or import a new certificate      Click Save      Add S3 proxy VPC to S3 bucket policyIn order for the S3 proxy to communicate with your S3 bucket your bucket policy must allow access from the S3 proxy’s VPC. You can find instructions on how to configure the policy in the Fine Tuning step.ValidationTest the S3 proxyTry to access your S3 proxy using the ping route. Eg. https://s3-proxy.mystudio.com/pingConfigure your test site to use the S3 proxy  Navigate to the Site Preferences menu within ShotGrid and expand the Isolation section  Set S3 Proxy Host Address to the S3 proxy url. Eg. https://s3-proxy.mystudio.com then click Save changes  Confirm that you are still able to access existing media  Attempt to upload new mediaNext StepsSee Media Replication to activate the Media Replicaton Traffic Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/85124db5/",
    "relUrl": "/85124db5/"
  },
  "78": {
    "id": "78",
    "title": "Media Traffic Isolation",
    "content": "Media Traffic IsolationCommunication between your client systems and S3 bucket targets a number of AWS network endpoints and data traverses the open Internet by default. Media Traffic Isolation allows you to limit the number of network endpoints used to transfer data to and from your S3 bucket and optionally restrict access to your AWS VPC or a defined set of public address scopes.ConfigurationAn S3 interface VPC endpoint is deployed within your VPC; which is then used as the endpoint for all S3 communication.How it worksShotGrid can be configured to use an S3 interface VPC endpoint to communicate with your S3 bucket. Deploying the S3 VPC endpoint within your VPC makes it possible to isolate traffic from the public Internet completely, or to allow more tightly controlled access from the Internet to your media.CostsActivating the Media Traffic Isolation feature will increase your AWS costs. Before activating, be aware that:  There are costs associated with running the S3 interface VPC Endpoint. See AWS PrivateLink pricing for more details.Next StepsSee Media Traffic Isolation for setup instructions.",
    "url": "/58919eae/",
    "relUrl": "/58919eae/"
  },
  "79": {
    "id": "79",
    "title": "I've launched Nuke/Maya/etc. from ShotGrid Desktop, but the ShotGrid menu is missing entries",
    "content": "I’ve launched Nuke/Maya/etc. from ShotGrid Desktop, but the ShotGrid menu is missing entriesThe actions that show up in the ShotGrid menu are contextually configured. That means the list of available actions may be different depending on the context you’re in.It’s possible you may not be seeing the app you’re after because you’re in the wrong context.ExampleWhen you launch an application from ShotGrid Desktop, it puts you in the project environment by default. This environment is managed by the config file in your pipeline configuration located at config/env/project.yml. Because most user’s work will probably not be done in this environment, it’s not configured with many apps for you to work with.Default Maya Project actions:You can use the ShotGrid Workfiles app to select the Asset, Shot, or Task to work on. This will load up the appropriate new environment for you which will then have more apps enabled with menu items in your ShotGrid menu.Default Maya Asset Task actions:If you believe you’re in the correct environment and the actions are still not showing, then the next step is to check the relevant log, and see if there are any errors.You may need to enable debug logging to get the full output.",
    "url": "/901110e2/",
    "relUrl": "/901110e2/"
  },
  "80": {
    "id": "80",
    "title": "Migration",
    "content": "MigrationOnce everything is configured and properly tested with the migration test site, it’s now time to migrate your production site to use the isolation features.Test migrationAsk the ShotGrid team to start the migration process in support ticket/slack.  ShotGrid will clone your production site database to your migration test site.  You will do a first sync of the media from ShotGrid’s S3 bucket to your bucket. ShotGrid will provide the exact instructions.  You can now test your site to be sure your existing media is available.Final migrationThe second test is to definitly migrate your site to use your own S3 bucket.  You will do a second sync of the media from ShotGrid’s S3 bucket to your bucket.  ShotGrid will reconfigure your hosted site with media isolation. Some media will be missing until the final media sync is completed.  You will do a final media sync.",
    "url": "/09699c82/",
    "relUrl": "/09699c82/"
  },
  "81": {
    "id": "81",
    "title": "Error module 'tank' has no attribute 'support_url' when launching {% include product %} Desktop",
    "content": "Error module ‘tank’ has no attribute ‘support_url’ when launching ShotGrid DesktopIssueThe following message appears when launching ShotGrid Desktop after upgrading the version:ShotGrid Desktop Error:Error: module 'tank' has no attribute 'support_url'CausesThe Descriptor version is incompatible with the newer ShotGrid Desktop version 1.7.3.‘support_url’ was introduced in tk-core v0.19.18.SolutionTo overcome this issue, do the following:  Access the Pipeline Configuration List page on the ShotGrid website.  Check if the Descriptor field has an old version incompatible with the newer ShotGrid Desktop version.Related links  Knowledge base support article",
    "url": "/2c67d8b6/",
    "relUrl": "/2c67d8b6/"
  },
  "82": {
    "id": "82",
    "title": "ModuleNotFoundError",
    "content": "ModuleNotFoundErrorUse CaseWith a distributed confguration, when bootrstrapping tk-shell to access the tk.templates command outside of an engine, this error is presented. When following this doc (part 4), and importing sgtk v0.19.18 from an install folder this is the error:Traceback (most recent call last):  File &quot;.../_wip/sgtk_bootstrap.py&quot;, line 9, in &amp;lt;module&amp;gt;    import sgtk  File &quot;L:/_tech/sgtk_sandbox/install/core/python sgtk __init__.py&quot;, line 16, in &amp;lt;module&amp;gt;    import tank  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank __init__.py&quot;, line 58, in &amp;lt;module&amp;gt;    from . import authentication  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication __init__.py&quot;, line 33, in &amp;lt;module&amp;gt;    from .shotgun_authenticator import ShotgunAuthenticator  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication shotgun_authenticator.py&quot;, line 13, in &amp;lt;module&amp;gt;    from .sso_saml2 import (  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication sso_saml2 __init__.py&quot;, line 15, in &amp;lt;module&amp;gt;    from .core.errors import (  # noqa  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication sso_saml2 core __init__.py&quot;, line 15, in &amp;lt;module&amp;gt;    from .sso_saml2_core import (  # noqa  File &quot;L:/_tech/sgtk_sandbox/install/core/python tank authentication sso_saml2 core sso_saml2_core.py&quot;, line 19, in &amp;lt;module&amp;gt;    from Cookie import SimpleCookieModuleNotFoundError: No module named 'Cookie'How to fixThis issue may be due to using Python 3 (older versions of Python are no longer supported).Related linksSee the full thread in the community",
    "url": "/d8981e04/",
    "relUrl": "/d8981e04/"
  },
  "83": {
    "id": "83",
    "title": "How do I move my pipeline configuration to a new location?",
    "content": "How do I move my pipeline configuration to a new location?                    Note: The contents of this doc only apply to centralized configuration setups. Distributed configurations are cached locally to the individual client machines and are managed automatically by Toolkit.    The easiest way to move your pipeline configuration to a new location is by using the tank move_configuration command. This will take care of moving your files, updating ShotGrid, and updating your config files to point to the new location.This command is also useful if you are only moving the location for a single operating system, or were not previously using a certain operating system but would like to add it now. Toolkit will detect what needs to be moved or added and what doesn’t, and will show you what it is about to do to allow you to confirm before progressing.  Using the tank move_configuration command  Manually moving your pipeline configuration                    Caution: If you are moving a configuration that has a localized core, and you have other projects that are using the Toolkit core embedded in this pipeline configuration (i.e. other configurations are using this as a shared core), you’ll have to manually update the configuration files in those projects to point to the new location for this pipeline configuration. These files are located in:  /path/to/pipeline_configuration/install/core/core_Darwin.cfg  /path/to/pipeline_configuration/install/core/core_Linux.cfg  /path/to/pipeline_configuration/install/core/core_Windows.cfg    Using the tank move_configuration command:    $ cd /sgtk/software/shotgun/scarlet     $ ./tank move_configuration    Welcome to the ShotGrid Pipeline Toolkit!    For documentation, see https://developer.shotgridsoftware.com/d587be80/?title=Integrations+User+Guide    Starting Toolkit for your current path '/sgtk/software/shotgun/scarlet'    - The path is not associated with any ShotGrid object.    - Falling back on default project settings.    - Using configuration 'Primary' and Core v0.15.22    - Setting the Context to Scarlet.    - Running command move_configuration...    ----------------------------------------------------------------------    Command: Move configuration    ----------------------------------------------------------------------    Syntax: move_configuration linux_path windows_path mac_path    This will move the location of the given pipeline configuration.    You can also use this command to add a new platform to the pipeline    configuration.    Current Paths    --------------------------------------------------------------    Current Linux Path:   '/mnt/hgfs/sgtk/software/shotgun/scarlet'    Current Windows Path: 'z: sgtk software shotgun scarlet'    Current Mac Path:     '/sgtk/software/shotgun/scarlet'    You typically need to quote your paths, like this:    &amp;gt; tank move_configuration &quot;/linux_root/my_config&quot; &quot;p: configs my_config&quot;    &quot;/mac_root/my_config&quot;    If you want to leave a platform blank, just just empty quotes. For example, if    you want a configuration which only works on windows, do like this:    &amp;gt; tank move_configuration &quot;&quot; &quot;p: configs my_config&quot; &quot;&quot;Example:    $ cd /sgtk/software/shotgun/scarlet     $ ./tank move_configuration &quot;/mnt/hgfs/sgtk/software/shotgun/scarlet_new&quot; &quot;z: sgtk software shotgun scarlet_new&quot; &quot;/sgtk/software/shotgun/scarlet_new&quot;    Welcome to the ShotGrid Pipeline Toolkit!    For documentation, see https://developer.shotgridsoftware.com/d587be80/?title=Integrations+User+Guide    Starting toolkit for path '/sgtk/software/shotgun/scarlet'    - The path is not associated with any ShotGrid object.    - Falling back on default project settings.    - Using configuration 'Primary' and Core v0.15.22    - Setting the Context to Scarlet.    - Running command move_configuration...    ----------------------------------------------------------------------    Command: Move configuration    ----------------------------------------------------------------------    Current Paths    --------------------------------------------------------------    Current Linux Path:   '/sgtk/software/shotgun/scarlet'    Current Windows Path: 'z: sgtk software shotgun scarlet'    Current Mac Path:     '/sgtk/software/shotgun/scarlet'    New Paths    --------------------------------------------------------------    New Linux Path:   '/mnt/hgfs/sgtk/software/shotgun/scarlet_new'    New Windows Path: 'z: sgtk software shotgun scarlet_new'    New Mac Path:     '/sgtk/software/shotgun/scarlet_new'    The configuration will be moved to reflect the specified path changes.    Note for advanced users: If your configuration is localized and you have other    projects which are linked to the core API embedded in this configuration,    these links must be manually updated after the move operation.    Are you sure you want to move your configuration? [Yes/No] yes    Copying '/sgtk/software/shotgun/scarlet' -&amp;gt; '/sgtk/software/shotgun/scarlet_new'    Copying /sgtk/software/shotgun/scarlet/cache...    Copying /sgtk/software/shotgun/scarlet/config...    Copying /sgtk/software/shotgun/scarlet/config/core...    Copying /sgtk/software/shotgun/scarlet/config/core/hooks...    Copying /sgtk/software/shotgun/scarlet/config/core/schema...    Copying /sgtk/software/shotgun/scarlet/config/env...    Copying /sgtk/software/shotgun/scarlet/config/env/includes...    Copying /sgtk/software/shotgun/scarlet/config/hooks...    Copying /sgtk/software/shotgun/scarlet/config/icons...    Copying /sgtk/software/shotgun/scarlet/install...    Copying /sgtk/software/shotgun/scarlet/install/apps...    Copying /sgtk/software/shotgun/scarlet/install/apps/app_store...    Copying /sgtk/software/shotgun/scarlet/install/core...    Copying /sgtk/software/shotgun/scarlet/install/core/python...    Copying /sgtk/software/shotgun/scarlet/install/core.backup...    Copying /sgtk/software/shotgun/scarlet/install/core.backup/20150518_143244...    Copying /sgtk/software/shotgun/scarlet/install/core.backup/20150518_143940...    Copying /sgtk/software/shotgun/scarlet/install/engines...    Copying /sgtk/software/shotgun/scarlet/install/engines/app_store...    Copying /sgtk/software/shotgun/scarlet/install/frameworks...    Copying /sgtk/software/shotgun/scarlet/install/frameworks/app_store...    Updating cached locations in /sgtk/software/shotgun/scarlet_new/config/core/install_location.yml...    Updating ShotGrid Configuration Record...    Deleting original configuration files...    All done! Your configuration has been successfully moved.Manually moving your pipeline configuration                    Important: If you haven’t yet moved your pipeline configuration, then we strongly advise using the built-in tank command above to take care of this automatically.    If you’ve already started moving things manually and are stuck, here’s a rundown of what you need to change to ensure Toolkit continues to work with your pipeline configuration now in a new location.      Move your pipeline configuration files to their new location     $ mv /sgtk/software/shotgun/scarlet /mnt/newserver/sgtk/software/shotgun/scarlet_new            Edit your install_location.yml, which helps Toolkit find where the pipeline configuration is located:     $ vi /mnt/newserver/sgtk/software/shotgun/scarlet_new/config/core/install_location.yml        Update the paths in this file to point to the new location for your pipeline configuration on all of the applicable platforms. If you’re not using a platform, enter an empty string ''     # ShotGrid Pipeline Toolkit configuration file # This file was automatically created by setup_project # This file reflects the paths in the primary pipeline # configuration defined for this project. Windows: 'Y: sgtk software shotgun scarlet_new' Darwin: '/mnt/newserver/sgtk/software/shotgun/scarlet_new' Linux: '' # End of file.            Locate the corresponding PipelineConfiguration entity in ShotGrid for this project and modify the Linux Path, Mac Path, and Windows Path field values to match the changes you made above.  Now your pipeline configuration should work as expected from the new location.                    Note: If you’re using SG Desktop, you’ll need to navigate out of your project and then click on the project icon again in order to reload the pipeline configuration from its new location.    ",
    "url": "/18e34e3c/",
    "relUrl": "/18e34e3c/"
  },
  "84": {
    "id": "84",
    "title": "How do I move my project directories to a new Local Storage root?",
    "content": "How do I move my project directories to a new Local Storage root?                    Caution: Moving a project location mid project can have many ramifications even extending beyond ShotGrid Toolkit. It should not be undertaken lightly.    Sometimes it’s necessary to move your project files (scene files, renders, etc.) to a new root storage location (e.g., from /mnt/smalldrive to /mnt/bigdrive/foo). This can be done whether you’re using a single or multi-root configuration. For example, let’s say we want to move your storage named “asset_storage”:  Copy (or move) your project files from the old location to the new location.  In ShotGrid, navigate to the Admin &amp;gt; Site Preferences page and open the File Management section.    Update the Local File Storage named “primary” with the paths for each platform to the new storage for your project files. If you’re not using a specific platform, leave it blank.  Click on the “Save Changes” button on the top or bottom of the page.  Update your config/core/roots.yml file in your project configuration to match the new path values you just saved in ShotGrid.Toolkit stores publish paths as relative paths from a storage root. So with the old storage root the path was expanded like so:[asset_storage]/assets/Character/betty =&amp;gt; /mnt/smalldrive/assets/Character/bettyWith the new storage root definition, the path is now expanded like this:[asset-storage]/assets/Character/betty =&amp;gt; /mnt/bigdrive/foo/assets/Character/bettyand we don’t need to worry about updating any other publish information in ShotGrid or Toolkit!                    Warning: The above steps assume that you are re-pathing the existing storage root. If instead you trash the existing one or create a new one then you will need to re-register all your folders and re-publish your PublishedFiles entities.    ReferencesIf any of your scene files have references in them that are pointing to the old path, you’ll need to update these on your own, or make symlinks to ensure that they get resolved correctly.VersionsIf you have Version entities in ShotGrid that store information in the Path to Movie or Path to Frames fields that are affected by this change, these will also have to be updated to point to the new location since these fields are string fields that contain an absolute path to the media.",
    "url": "/9aaa493a/",
    "relUrl": "/9aaa493a/"
  },
  "85": {
    "id": "85",
    "title": "Cannot find procedure “MTsetToggleMenuItem”",
    "content": "Cannot find procedure “MTsetToggleMenuItem”Related error messages:Maya crashs just before loading the full window, after the usual splash screen:  Cannot find procedure “MTsetToggleMenuItem”How to fix:In the before_app_launch hook before launching Maya, it’s possible that something inadvertently is being removed from the path, causing the error at Maya launch. In this case, adding a python install to PTHONPATH will prevent Maya 2019 from finding the Plugin Path.Example of what’s causing this error:The user had several problems, as this hook ensured that C: Python27 was set as PYTHONPATH, and they actually installed the workstation with this PYTHONPATH.See the full thread in the community.",
    "url": "/74106124/",
    "relUrl": "/74106124/"
  },
  "86": {
    "id": "86",
    "title": "App store does not contain an item named my-app",
    "content": "ERROR: App store does not contain an item named my-appHow to fix:This has to do with the location descriptor on your custom app—check out this doc.For locations, set up your my-app with a path descriptor—see details here.Example of what’s causing this error:While trying to use tank validate since tk-multi-snapshot isn’t showing up in maya, the error is presented when it tries to validate a custom app, stating it isn’t in the app store.See the full thread in the community.",
    "url": "/226a0069/",
    "relUrl": "/226a0069/"
  },
  "87": {
    "id": "87",
    "title": "Why does the Nuke integration fail to start when I set the NUKE_PATH environment variable?",
    "content": "Why does the Nuke integration fail to start when I set the NUKE_PATH environment variable?Our integrations set the NUKE_PATH environment variable when launching Nuke so that our bootstrap script runs during the Nuke startup process.It’s the tk-multi-launchapp that specifically defines the NUKE_PATH prior to it executing the before_launch_app.py hook.If you’re setting this environment variable during the launch process using something like os.environ['NUKE_PATH'] = &quot;/my/custom/path&quot;, then the ShotGrid integration won’t ever be started, because you’ll have removed our startup script path from the environment variable.Use this function in tank.util to append or prepend your path to the NUKE_PATH environment variable, while preserving the path to the Toolkit bootstrap:tank.util.append_path_to_env_var(&quot;NUKE_PATH&quot;, &quot;/my/custom/path&quot;)Alternately, you can prepend your path using prepend_path_to_env_var().",
    "url": "/fc2af72c/",
    "relUrl": "/fc2af72c/"
  },
  "88": {
    "id": "88",
    "title": "Offline usage and turning off auto updates",
    "content": "Offline usage and turning off auto updatesImportant: This topic applies only to locally installed instances of ShotGrid. Local installations of ShotGrid are no longer offered. This documentation is intended only for those with existing instances of Shotgun Enterprise Docker. Click here for a list of our current offerings.  Auto updates          What parts auto update?      What doesn’t auto update?        Running the integrations offline          Initial Setup      Managing updates        Turning off auto updates          Turning off updates at a project or site level      Turning off updates for all but one project      Upgrading      Auto updatesWhat parts auto update?By default ShotGrid Desktop will automatically check for updates, and install them to the local machine if it finds any.It checks for updates on two components:  tk-framework-desktopstartup - A frame work which aids the launch of ShotGrid Desktop.  tk-config-basic - The default site config.The configuration acts as a manifest for the versions of the apps, engines, frameworks, and core version that should be used by ShotGrid Desktop.By updating the config, you are potentially updating any of these components as well.Any updates that are found are downloaded and stored in the user’s local cache, rather than modifying the original ShotGrid Desktop installed files.ShotGrid Create as an application has it’s own update mechanism separate from ShotGrid Desktop which is not covered here.However the integration features provided in ShotGrid Create work in a similar way, and will also auto update tk-config-basic into the same user cache.What doesn’t auto update?      If you have taken over a site configuration, then it won’t check for newer tk-config-basic updates but more on that further down.        Any projects that aren’t using the default site configuration (I.e. a project where the Toolkit advanced setup wizard has been run on it.), will not have their configuration auto updated.        Resources such as Python and QT that come bundled with ShotGrid Desktop, don’t auto update. We occasionally release new ShotGrid Desktop installers when we need to update these parts.  Running the integrations offlineInitial setupIf your studio has restricted internet access or no internet access then you will need to ensure that you have all the required parts cached locally.You will still need one machine that can connect to the internet in order to download ShotGrid Create or ShotGrid Desktop.ShotGrid Desktop comes prepackaged with all the dependencies required to run the basic integrations. Whilst ShotGrid Create also comes bundled with the dependencies, it requires you to follow the steps mentioned in managing updates as well.When you start either of them up, it will automatically try to look for updates, but if it cannot connect to the ShotGrid App Store, it will simply run the most recent version that exists locally.It is recommended that you follow the managing updates steps bellow after installing ShotGrid Desktop, as the components bundled with the installer may not be the latest.                    Note: Depending on your network setup, it can sometimes get stuck looking for updates online even though it won’t be able to access them. In this situation you can set the environment variable SHOTGUN_DISABLE_APPSTORE_ACCESS to &quot;1&quot; to stop it from trying.                        Note: You will still need to be able to connect to your ShotGrid site. When we say offline we are talking about not being able to connect to our app store to download updates.    Managing updatesTo update the tk-framework-desktopstartup component, you will need to download the latest version, and set the environment variableSGTK_DESKTOP_STARTUP_LOCATION to point to its location on disk, (This only applies to ShotGrid Desktop.)For the tk-config-basic component it’s a bit more tricky, due to all its dependencies.  Run ShotGrid Desktop or ShotGrid Create on a workstation connected to the internet. When it starts up, the latest upgrades will be automatically downloaded.(Ensure SHOTGUN_DISABLE_APPSTORE_ACCESS is not set on this machine.)  Copy the bundle cache to a shared location where all machines can access it.  Set the SHOTGUN_BUNDLE_CACHE_FALLBACK_PATHS environment variable on offline machines to point to this location.  When ShotGrid Desktop or ShotGrid Create starts up on offline machines, they will pick up the latest upgrades that are available in the bundle cache.                    Warning: Depending on your network setup, it can sometimes get stuck looking for updates online even though it won’t be able to access them. In this situation you can set the environment variable SHOTGUN_DISABLE_APPSTORE_ACCESS to &quot;1&quot; to stop it from trying.    Turning off auto updatesTurning off updates at a project or site level                    Note: If possible we recommend that you continue to allow auto updates to avoid missing out on new features and bug fixes.    Follow these steps to turn off automatic updates for the integrations.  Determine the version you want to stay at. You can find the integration releases here.      In ShotGrid, create a Pipeline Configuration entity either on a project or on a global page, with the following fields populated (In this example, we are locking down the config to use v1.0.36 of the integrations):          Name: Primary      Project: Leave empty if you want updates turned off for all projects, or pick a specific project if you only want to lock down a single project.      Plugin ids: basic.*      Descriptor: sgtk:descriptor:app_store?name=tk-config-basic&amp;amp;version=v1.0.36                Start ShotGrid Desktop, and if you left the project field empty then ShotGrid Desktop will have switched over to using this version if it wasn’t already doing so.        If you set a project, then only that project will be affected and you won’t see a change in the ShotGrid Desktop about window.    [Optional] To lock the version of tk-framework-desktopstartup you will need to download the latest version, and set the environment variableSGTK_DESKTOP_STARTUP_LOCATION to point to its location on disk, (This only applies to ShotGrid Desktop.)It’s The majority for the functionality is controlled by the config which can be locked down with the previous steps, however as mentioned in the “what parts auto update?” section, the  component is also updated and that is handled separately from the config. This also only applies to ShotGrid Desktop.Good to know  You don’t need to download the release of the configuration manually, ShotGrid Desktop will handle this when it launches or you enter the project.  basic.* means that all plugins in the basic configuration will pick up this override. If, for example, you wanted to freeze the Nuke and Maya integrations only, you could specify basic.maya, basic.nuke.  To test, you can create a duplicate of this Pipeline Configuration entity, and add your username to the User Restrictions field. This will restrict the entity such that it’s only available to you and won’t impact other users. You can then launch Maya or some other software from this duplicate configuration and confirm that it’s running the expected integrations versions.      Leaving the project field blank is what we call a site configuration. ShotGrid Desktop uses the site configuration, as it operates outside of projects. When you select a project in ShotGrid Desktop it then loads the project configuration as well.    The Flame integration is namespaced basic.flame, and so is implied to be part of basic.*. However, the Flame integration isn’t actually included in the basic config. So, if you are using Flame for a project and implement this override, the Flame integration will stop working.The solution would be to create an additional Pipeline Configuration override specifically for flame:          Name: Primary      Project: The project you want to lock down (or None for all projects)      Plugin ids: basic.flame      Descriptor: sgtk:descriptor:app_store?name=tk-config-flameplugin      Turning off updates for all but one projectIf you have turned off updates on all projects as mentioned in the example above, but would like to enable updates on a specific projectYou can  Turning off updates for your site as described in the above section.  Configure the exception project’s Pipeline Configuration entity to have the following field values:          Name: Primary      Project: The project you want not to lock down      Plugin ids: basic.*      Descriptor: sgtk:descriptor:app_store?name=tk-config-basic  With the version number omitted from the Descriptor field, the project is now tracking the latest release of the basic config.      UpgradingWhen it comes to updating your configuration, you may wish to test out the newer version before rolling it out to all your users.  Duplicate the Pipeline Configuration entity in ShotGrid by right-clicking on it and selecting “Duplicate Selected”.  Name the cloned config “update test”, and assign yourself to the User Restrictions field.  You will now begin to use this Pipeline Configuration.  Change the descriptor to point to the version you wish to test.  You can invite any users you want to partake in testing by adding them to the User Restrictions field.  Once you are happy with testing, simply update the main Pipeline Configuration to use that version.  Once users restart ShotGrid Desktop and relaunch any currently open software with the ShotGrid integration running, the update will be picked up.",
    "url": "/b31ed3ef/",
    "relUrl": "/b31ed3ef/"
  },
  "89": {
    "id": "89",
    "title": "Onboarding Process",
    "content": "Onboarding ProcessLeveraging the isolation features requires adopters to become AWS users. In order to ensure that this joint venture between Autodesk, AWS, and our clients is as streamlined as possible, we decided to work closely with AWS to define a cooperative onboarding process that would meet client expectations for a premium offering.Autodesk will provide dedicated resources during the onboarding process to help you on this journey.To start the on-boarding process for any of the Isolation features, please fill out this short survey, before proceeding with your setup.Onboarding Process OverviewDuring the onboarding process, you’ll have direct access to Autodesk resources who will support you during the implementation.Setup / Test / Activation:	Iterative installation process where you connect your AWS resources to ShotGrid, and activate the isolation features.Onboarding ResourcesShotGrid Community: The ShotGrid Isolation Community forum can be used to ask questions that can be answered by either ShotGrid Experts or other isolation features users. This should be your first stop when asking general questions about isolation features, during setup and beyond.Dedicated Microsoft Teams team: During the onboarding, you will be given access to a Microsoft Teams team. Your ShotGrid leaders will be available for quick feedback, answers, and ad-hoc meetings to help you progress as fast as possible with your ShotGrid Isolation setup. This channel will be available only for the onboarding period.ShotGrid Support: A ShotGrid Support ticket will be used to track your onboarding at a higher level. Once your ShotGrid Isolation setup is complete, follow-up support tickets can be opened with the support team as needed.Next StepsOnce the onboarding process is started, you can start thinking about your setup",
    "url": "/f66c5afa/",
    "relUrl": "/f66c5afa/"
  },
  "90": {
    "id": "90",
    "title": "Other Integrations",
    "content": "Other IntegrationsWith ShotGrid’s API, you can integrate with a number of third party packages. However, there are a few with which ShotGrid integrates right out-of-the-box.CinesyncCinesync allows you to have simultaneous synced playback between multiple locations. ShotGrid’s integration allows you to create a Playlist of Versions, play it in Cinesync, and send your Notes made during the session right back into ShotGrid.For more information, please see https://www.cinesync.com/manual/latest.DeadlineThe ShotGrid+Deadline integration allows you to automatically submit rendered Versions to ShotGrid complete with thumbnail, links to frames, and other metadata.For more information, please see https://docs.thinkboxsoftware.com/products/deadline/5.2/User%20Manual/manual/shotgunevent.html.RushMuch like the Deadline integration, the ShotGrid+Rush integration allows you to automatically submit rendered Versions to ShotGrid complete with thumbnail, links to frames, and other metadata.For more information, please see https://seriss.com/rush-current/index.html.Subversion (SVN)ShotGrid a light but flexible integration, which we use internally, that allows us to track revisions and link them to tickets and releases in ShotGrid. We also provide links to Trac to integrate with an external web SVN repository viewer. This is all done by adding a post-commit hook to SVN, a ShotGrid API script that takes some ENV variables from the commit and then creates a Revision entity in ShotGrid with various fields filled in. It can be modified to match your studio’s needs and can be used for a local or hosted installation since it’s just using the API. For more information, please see https://subversion.apache.org/docs.",
    "url": "/f0ee6c48/",
    "relUrl": "/f0ee6c48/"
  },
  "91": {
    "id": "91",
    "title": "The path `&lt;PATH&gt;` is already associated with {% include product %} entity `&lt;ENTITY&gt;`",
    "content": "Database concurrency problems: The path &amp;lt;PATH&amp;gt; is already associated with ShotGrid entity &amp;lt;ENTITY&amp;gt;Related error messages:  Database concurrency problems: The path &amp;lt;PATH&amp;gt; is already associated with ShotGrid entity &amp;lt;ENTITY&amp;gt;.  Could not resolve row id for path!Example:This error occurs when a Toolkit user tries to create folders. Here’s the full error:ERROR: Database concurrency problems: The path'Z: projects SpaceRocks shots ABC_0059' is already associated withShotgun entity {'type': 'Shot', 'id': 1809, 'name': 'ABC_0059'}. Please re-runfolder creation to try again.What’s causing the error?It happens when you’re in a state where you’re trying to create a FilesystemLocation entity for a folder that already has one.How to fixClear the bad FilesystemLocation entities. If you can narrow down to a set of errant FilesystemLocation entities, just remove those. In a lot of cases though, all of the paths for a project are compromised, so they all need to go.  How to clear the FilesystemLocation entities: ideally you can run tank unregister_folders. To clear all of them, run tank unregister_folders --all. (For all the options for tank unregister_folders, just run it with no arguments and it will output usage notes.)  However, because the db is already in a wonky state, this may not work, or may only partially work. Once you’ve run the command, go back to FilesystemLocations in ShotGrid, and confirm that what you expected to be deleted is actually gone. If not, select the bad entities, and move them to trash manually.At this point, the FilesystemLocations in ShotGrid are clean, but artists’ local caches may not reflect your changes. The last step is to actually sync the local cache on each user’s machine. To do this, they should run tank synchronize_folders --full.Once all those steps are taken, the path cache should be in a good state, and that errors shouldn’t appear anymore.Related links  Here’s the code in question  What is the path cache? What are Filesystem Locations?See the full thread in the community.",
    "url": "/3636e362/",
    "relUrl": "/3636e362/"
  },
  "92": {
    "id": "92",
    "title": "Errors due to Windows paths too long",
    "content": "Errors due to Windows paths too long (&amp;gt;256 characters)The hard factsWindows has a really low default limit of 255/260 characters for path names. Microsoft’s information about this limit is here and you can see more technical info here.The error(s)This manifests itself in various ways but typically happens when SG Desktop is loading a config for the first time, it hits this error while downloading items into the bundle cache. The error can be somewhat cryptic though it looks like recent versions of Windows 10 have improved the error slightly. These are some examples of what you might see:[ WARNING] Attempt 1: Attachment download of id 3265791 from https://xxxxx.shotgunstudio.com failed: [Error 206] The filename or extension is too long: 'C:  Users  xxxxx  AppData  Roaming  Shotgun  bundle_cache  tmp  0933a8b9a91440a2baf3dd7df44b40ce  bundle_cache  git  tk-framework-imageutils.git  v0.0.2  python  vendors  osx  lib  python2.7  site-packages  pip  _vendor  requests  packages  urllib3  packages  ssl_match_hostname'[ WARNING] File 'c: users xxxxx appdata local temp ab35bd0eb2b14c3b9458c67bceeed935_tank.zip' could not be deleted, skipping: [Error 32] The process cannot access the file because it is being used by another process: 'c:  users  xxxxx  appdata  local  temp  ab35bd0eb2b14c3b9458c67bceeed935_tank.zip'ERROR sgtk.core.descriptor.io_descriptor.downloadable] Failed to download into path C: Users xxxxx AppData Roaming Shotgun bundle_cache tmp 123456789012a34b567c890d1e23456: Failed to download sgtk:descriptor:shotgun?entity_type=PipelineConfiguration&amp;amp;field=uploaded_config&amp;amp;id=38&amp;amp;version=123456 from https://xxxxx.shotgunstudio.com. Error: Failed to download from 'https://xxxxx.shotgunstudio.com' after 5 retries. See error log for details.. Attempting to remove it.WARNING sgtk.core.util.shotgun.download Attempt 4: Attachment download of id 1182 from https://xxxxx.shotgunstudio.com failed: [Errno 2] No such file or directory: 'C:  Users  xxxxx  AppData  Roaming  Shotgun  bundle_cache  tmp  dd2cc0804122403a87ac71efccd383ea  bundle_cache  app_store  tk-framework-desktopserver  v1.3.1  resources  python  build  pip  _vendor  requests  packages  urllib3  packages  ssl_match_hostname  _implementation.py'WARNING sgtk.core.util.filesystem File 'c: users xxxxx appdata local temp 08f94bfe9b6d43e7a7beba30c192a43c_tank.zip' could not be deleted, skipping: [Error 32] The process cannot access the file because it is being used by another process: 'c:  users  xxxxx  appdata  local  temp  08f94bfe9b6d43e7a7beba30c192a43c_tank.zip'ERROR sgtk.core.descriptor.io_descriptor.downloadable] Failed to download into path C: Users xxxxx AppData Roaming Shotgun bundle_cache tmp dd2cc0804122403a87ac71efccd383ea: Failed to download sgtk:descriptor:shotgun?entity_type=PipelineConfiguration&amp;amp;field=sg_uploaded_config&amp;amp;id=1&amp;amp;version=1182 from https://xxxxx.shotgunstudio.com. Error: Failed to download from 'https://xxxxx.shotgunstudio.com' after 5 retries. See error log for details.. Attempting to remove it.ERROR sgtk.core.bootstrap.cached_configuration Failed to install configuration sgtk:descriptor:shotgun?entity_type=PipelineConfiguration&amp;amp;field=sg_uploaded_config&amp;amp;id=1&amp;amp;version=1182. Error: Failed to download into path C: Users xxxxx AppData Roaming Shotgun bundle_cache tmp dd2cc0804122403a87ac71efccd383ea: Failed to download sgtk:descriptor:shotgun?entity_type=PipelineConfiguration&amp;amp;field=sg_uploaded_config&amp;amp;id=1&amp;amp;version=1182 from https://xxxxx.shotgunstudio.com. Error: Failed to download from 'https://xxxxx.shotgunstudio.com' after 5 retries. See error log for details.. Cannot continue.Why this happensOn Windows, ShotGrid Desktop stores data in your %APPDATA% folder (typically C: Users jane AppData Roaming Shotgun. When using the standard default2 Toolkit config things should be mostly fine as long as your username isn’t super long. However, if you are creating your own apps, engines, or frameworks, you may have more risk of running into this, especially if you bundle dependencies with your code (as we do), and you have deep trees of directories in your bundles.Working around the issueThe way to resolve this issue is typically to set a $SHOTGUN_HOME environment variable to something very short like C: SG. This tells SG Desktop to store it’s data in C: SG instead of C: Users jane AppData Roaming Shotgun which saves you some characters and is usually enough to keep you under the limit. You can read about the environment variables here.Future possibilities?There may be another way to mitigate this issue with more recent versions of Windows 10 by updating the registry as described here but I think it also requires SG Desktop to update it’s manifest file to indicate it wants to take advantage of the longPathAware setting. I’m a Mac guy so I’m not sure if I’m just talking crap here ;)See the full thread in the community.",
    "url": "/aed84d1f/",
    "relUrl": "/aed84d1f/"
  },
  "93": {
    "id": "93",
    "title": "Performance Troubleshooting",
    "content": "Performance troubleshootingYou may come across situations where Toolkit usage can become slow. There can be many reasons for encountering this, ranging from issues with the client side infrastructure such as server speeds or internet connection, to configuration based issues where Toolkit or ShotGrid is not configured in a performant way, to areas of our code that could use further optimization.Here is a quick list of things to check which we cover in further detail below:  Make sure your apps, engines, frameworks, core, and ShotGrid Desktop are up to date.  Ensure debug logging is not enabled during general use.  Only create the folders that you need to, and limit folders so they are only created when they are actually needed. Adding too many folders to your schema will slow things down.  Storing your user caches on a server can be slow. You can redirect the user’s ShotGrid cache by setting the ShotGrid_HOME environment variable to point to a location on your local drive.  Configure the workfiles and loader apps to filter out content that is not needed by the artist. Consider filtering by statuses to help keep the list of entities short and relevant to the artist’s current tasks.  Check to see if you have any custom hooks and that they are not adding additional overhead.Below is a list of good practices and common slow down scenarios. This is not an exhaustive list and we will try to add to it as and when we see new patterns. If this guide doesn’t help you get to the bottom of the problem you’re facing, then please feel free to submit a support ticket in and our team will be happy to assist you further.Table of Contents:  General good practice          Cache Location      Keeping up to date      Centralized configs vs distributed configs      Debugging        Launching software is slow          Diagnosis      Is the issue pre or post launch?      Checking the logs      Common causes of slow software launches        File Open, File Save, or the Loader app is slow?  Folder Creation is slow          Tackling I/O usage      Registering folders      General good practiceCache LocationShotGrid Toolkit caches data to the user’s home directory. This cache can include a number of different SQLite databases as well as cached apps and configs. Normally the user’s home directory is stored on the machine’s local hard drives, but it’s fairly common for studios to redirect them to network storage. Doing this can impact performance—most notably to the SQLite databases, which are used for browser integration and folder creation/lookup among other things.If your user directories are stored on a server location, we recommend repathing the ShotGrid Toolkit cache using the ShotGrid_HOME environment variable. The ShotGrid_HOME environment variable is used to set the location where Toolkit caches various data, such as the bundle cache, thumbnails, SQLite databases used for fast lookup of data and other things.DebuggingYou can enable debug logging in ShotGrid Toolkit, so that you can get more verbose output from the various processes. This can be incredibly useful when trying to diagnose issues, however, the debug setting is not designed to be enabled during normal everyday use. The increase in logging output can significantly impact performance.When encountering performance issues, especially ones that are localized to specific machines or users, first check that debug logging isn’t enabled.Keeping up to dateIf you’re encountering performance issues, check that your core, apps, engines, and frameworks are up to date, as there may already be fixes or optimizations available in newer releases.Centralized configs vs distributed configsThere are two different ways of setting up advanced Toolkit configurations: centralized and distributed. The key differences are that the centralized configs typically live on your studio’s network storage where they can be accessed by all users, and the distributed configs are usually stored in the cloud and get cached locally per user.Whilst the differences between these two methods extend beyond performance, they can both bring performance benefits and disadvantages. Here is a table showing the pros and cons, purely from a performance standpoint.                   Advantages      Disadvantages                  Centralized Configs      - Once the initial setup process is complete, it will have everything it needs already downloaded and ready to go for all users.      - Centralized configs are usually kept on network storage; therefore the performance can be degraded during normal Toolkit usage.                     - Future updates only need to be downloaded once to the centralized location.      - Toolkit configurations contain many small files, and handling metadata operations on lots of small files can be a lot slower and harder for servers. Also, heavy read operations both through the use of Toolkit or through general use of the server may impact Toolkit’s performance by not being able to read the configuration as quickly.              Distributed Configs      - The cached apps, engines, frameworks, and cores are stored in such a way that they can be shared with other locally cached configs. This means subsequent loading of different projects will likely be faster to cache if they share the same dependencies.      - Distributed configs need to be cached locally per user. Usually, this involves downloading the config and all the required apps, engines, frameworks, and core.                     - They are stored in the user’s cache on their local hard drive and thus normally perform better than server speeds. This means that after the initial cache, the performance should be better than a centralized config.      - The process happens seamlessly behind the scenes, but there is still the initial cost of downloading these.                            - Every time the config gets updated to point to new versions of the dependencies, both the config and the new dependencies will need to be cached.      In summary, if you have slow storage but a reasonable internet connection, then distributed configs maybe the best answer, but if you have good server storage performance and poor internet, then a centralized config might be more suitable.                    Note: If you are interested in the distributed configs but are concerned about downloading the dependencies per machine, it is possible to centralize just your bundle cache so that it is shared among all users.    When using distributed configs, a user will only have to download something if it is not already found in the cache, and once one user has downloaded it, others will be able to benefit from it as well. To achieve this you can set the ShotGrid_BUNDLE_CACHE_PATH environment variable on each machine to point to the shared location.Launching software is slowYou may notice that when launching software such as Maya, Nuke, Houdini, or others, they take longer to start up than without ShotGrid. It is normal that they may take a short while longer than without ShotGrid, but sometimes these times can increase to unacceptable levels, (normally depending on the software we would expect them to startup in under a minute). This can be one of the more tricky areas to diagnose as there are many processes involved in launching the software.DiagnosisThe first thing you should do is figure out under what conditions this is happening.  Is it slow when launching without ShotGrid? - This might seem obvious, but it’s worth checking that the issue only occurs when launching with ShotGrid.  Is it slow regardless of which approach you use to launch, i.e., is it about the same if you launch from SG Desktop, or from the SG site using the browser integration? - If it’s slow launching from the ShotGrid site but not from SG Desktop, then it could be an issue with the browser integration, or it could point to issues creating the folders on disk. If you’re launching from a context other than a Project, then it will likely be creating more folders on disk so this might explain where the time is taken. It’s also worth noting that we check for the existence of the required folders every time software is launched.  Does it happen on all projects? - If it doesn’t, then it’s likely to be something specific to the way the configuration is setup.  Does this happen at specific points in the day? - If so, then this could point to high demand on the infrastructure, such as server usage being higher at certain times of the day.  Does this happen for all Machines/OSs used? - If a particular machine is slow, then it’s possible there is something outside of Toolkit that is causing the issues. However, clearing the Toolkit cache on that machine is a good first step. Different OSs come with different versions of software and Python packages, and sometimes performance issues can crop up on specific builds. Specifically we have seen issues with performance on Windows using Samba (SMB) shares. There isn’t a fix for this as such, but it’s good to be aware of if you are using it.If you believe the issue is limited to a certain OS, Python package, or software version then please let our support team know so they can investigate further.  Does this happen for all users? - Similar to above, it’s possible that as a different user on the same machine, the issue might disappear. In this situation, start by clearing the user’s local ShotGrid cache. Also, make sure debug logging is not enabled for normal production use, as this will impact performance.  Is the slow launching exclusive to a specific app/software or are all apps/software launched abnormally slow? - If specific software is slow to launch, this might mean that there is a configuration issue. It may be worth checking to see if you have any custom hooks set up to run either before or after launch that might be impacting performance. Common hooks used in start up are before_app_launch.py, app_launch.py, and the core hook engine_init.py. There can also be occurrences from time to time where a newer version of software is released and our integrations are suddenly much slower to start. In this situation, you should reach out to support to check if they are aware of this, and if there is any known fix. Please provide the version number of the software your using (including patches/service pack if applicable) and the version of the tk engine and core you’re running.Is the issue pre or post launch?If the above hasn’t helped you narrow it down, then the next step is to establish where in the startup process things are slowing down. When launching software via Toolkit, it can usually be boiled down into a two step process.The first step performs some initial operations, such as gathering the information required to launch the software, automatically creating the folders from the context and then actually launching the software. Then the second step of the process starts the Toolkit integration once the software has launched.Usually, you can see without looking at the logs if the performance issue lies in the first step of the process or the second:  By watching and seeing if it takes a long time for the software’s splash screen to start. If it does then the issue could well be in the first step.  By seeing the software begin to start up relatively quickly but then become slow (after getting to the point where it has finished initializing and the ShotGrid menu is present). If this is the case then the issue will fall into the second step.Knowing this will help you in the next bit which is looking at the logs.Checking the logsNow you hopefully have some idea of if the issue is in the first step or the second step of the launching; this will help target which log you will be looking in. The logs are broken up per engine, so if the issue appears to be in the pre-launch phase, then you will need to look in either the tk-desktop.log or in the tk-ShotGrid.log, depending on if you launched from SG Desktop or the SG site respectively.The next thing you should do is enable debug logging.                    Note: If it was already enabled, as mentioned above this could be a cause for sluggishness, so you should also test without it enabled    Once debug logging is enabled, you should clear your existing logs, and then replicate the launch process. Then you can use the timestamps in the logs to see where the jumps in time appear.For example, here are a few lines where a 5 second jump in time occurs during folder creation:2019-05-01 11:27:56,835 [82801 DEBUG sgtk.core.path_cache] Path cache syncing not necessary - local folders already up to date!2019-05-01 11:28:01,847 [82801 INFO sgtk.env.asset.tk-shotgun.tk-shotgun-folders] 1 Asset processed - Processed 66 folders on disk.Once you locate the jumps in time, the log line will hopefully give you some idea about what was happening at that stage, such as if it occurred during folder creation, or if it was trying to get a ShotGrid connection.Reading logs can be tricky though and the contents may not always make sense, so again you can reach out to support to assist you with this bit.Common causes of slow software launches            Slow internet speed      Pretty much every aspect of Toolkit usage where it needs to connect and communicate with the ShotGrid site will be affected by slow internet speeds. In this case, typically, you will see speed issues in other situations in addition to launching software. However, if the connection is unstable rather than slow, you’re more likely to run into performance issues during launch (as there is quite a bit of ShotGrid communication going on throughout the process).              Slow server access      This can certainly affect launch times. If you’re using a centralized config, (i.e., your config is stored on a central server) there can be a lot of I/O as it reads your configuration files. On top of that, launching the software will trigger folder creation for the context it’s being launched in. This means that it will be checking to see if your folders are created, and creating them if not.              Folder creation      As mentioned above, folder creation can be a common cause of slowdown. See the folder creation performance troubleshooting below for more details.      File Open, File Save, or the Loader app is slow?The first thing to do is to narrow down to certain aspects of where the app in question is slow.  Is it slow to launch the app or navigate through the tabs?          It’s possible that the app is currently configured to show too much information. The My Tasks tab and others can be configured to filter out unneeded entities from the list. For example, you could filter out tasks that are of a certain status, such as On Hold (hld) or Final (fin).  Not only does this offer performance benefits, but it also lets the artist see only the information that is important to them. Both the Loader app and the Workfiles app can be filtered, however, Workfiles doesn’t currently have a specific doc section on filtering but filters can be applied as part of the hierarchy settings.      The hierarchy on the File Open app can also be configured to defer the loading of the sub items until it is expanded. This is now the default configuration setup, however, if you have older configs you may wish to transition over to using this.      Check that debug logging isn’t enabled. This can cause a lot of additional I/O and therefore slow things down; these apps do contain a lot of debugging output.        Is it slow opening, saving, or creating a new file?          Check to see if you’ve taken over scene operations or actions hooks, and see if there is any custom behavior around these functions that might slow things down.      When creating or saving a file, Workfiles will ensure that all the required folders for the context are created. Folder creation can be a common point at which performance issues can occur.      Folder Creation is slowFolder creation has many parts to it, which can contribute to the process being slow when an issue arises.Folder creation will:  Synchronise your local path cache.  Read your config’s schema.  Generate a list of paths that should be created given a certain context.  Check the paths against path registries stored locally.  Attempt to register the new paths both on your SG site and locally, if not already registered.  Check to see if the folders actually exist on disk regardless of if they have already been registered, and create the folders if they are not.In short, folder creation will have potentially significant I/O usage on the disk, as well as need to write to a local database and communicate with the SG site.Tackling I/O usageIt may be possible that your storage is slow or inefficient at handling many small read-write operations, so anything that can be done to improve the infrastructure will help speed up the folder creation operations. However, there are steps that can be taken on the Toolkit configuration side to try and reduce the strain as much as possible.The first thing is to limit the folders that are created to the ones that are important to that context and thus the environment you would be working in. For example, if you’re working on a Task on a Shot in Maya, then you would ideally only want it to check and create the folders for your specific Shot and software.Basically, create the minimum required folders that allow you to save and publish your work.Create with parentThere is a create_with_parent setting that can be applied to schema folders.Setting it to true will cause the folder to be created at the same time as it’s parent. You should be careful to avoid situations where setting it to True will cause large numbers of folders to be checked and created.ExampleIf you had a Sequence/Shot folder hierarchy and you set your Shot folder to create with its parent Sequence, then whenever a Sequence folder gets created, it will check for all associated Shots and create folders for them.Whilst this might be convenient in some situations, it is causing a lot more folders to be checked and potentially created at once. In this scenario, if you were to create a new file in workfiles on a Task on a Shot, it would trigger the creation of the Shot’s parent Sequence folder and that in turn would create all children Shot folders, not just the Shot you’re working on.                    Note: The setting for step schema folders defaults to true.    Defer creationThe defer_creation setting allows you to further refine when folders should be created by restricting the creation of folders to only happen when a certain engine is running. You can even use custom names, and then trigger the creation of them using the sgtk API.ExampleYou may have a bunch of folders that should only be created at publish stage. In this case, you could set a custom to defer keyword of maya_publish, and then use the API to create the folders using that keyword as the engine name.Your folder in the schema might look something like:# the type of dynamic contenttype: &quot;static&quot;# defer creation and only create this folder when Photoshop startsdefer_creation: &quot;publish&quot;And then you would create the folders with a script like this:sgtk.create_filesystem_structure(entity[&quot;type&quot;], entity[&quot;id&quot;], engine=&quot;publish&quot;)Extended ExampleTaking the idea of deferring folders further, if you have a number of non-dynamic folders at the root of your project, these typically only ever need to be created once. For example, the “editorial” and “reference” folders in the root of the Default Configuration’s  schema would only likely need creating once at the start of the project, but by default, the folder creation will check for their existence every time.To limit this, you could create yml files for them, where you can set a defer keyword so that they only get created when the folder creation is run in a certain engine or passed the keyword. You could set the defer keyword to tk-shell and then run the folder creation via the tank command like tank folders.This would mean that these folders would only get created if the folder creation was run via the tank command, which a Toolkit administrator could do when setting up the project for the first time. Alternatively, you could write a small script that ran the folder creation with a custom keyword a bit like the example above.Registering foldersDuring the folder creation process the folders are registered so that the paths can be used to look up the context in the future. As mentioned before, part of this process requires talking to the ShotGrid site, which is the central location where the registries are stored. However, these registries are also cached locally to enable faster lookup by the tools.SQLite databaseThe local path cache uses an SQLite database to store the data. The performance of reading and writing to the database can be severely impacted if the database is stored on network storage.Initial synchronizationThere can be situations where a local cache needs to be generated from scratch for a project (such as when a new user joins an already in progress project) that has a lot of folders registered. This process can take noticeably longer, but the good news here is that this should only happen once for that project.Subsequent syncs will only pull the differences between the local cache and the site registry. If the user infrequently works on the project and a lot of folders get created between sessions, then they may experience a noticeable wait whilst everything caches.One method we’ve seen people employ here is to transfer a reasonably up to date version of a local cache to the user’s machine.                    Note: This approach is only necessary in situations where there is an extremely large amount of folders being created on a project.    This update process can be achieved automatically through the use of the core hook cache_location.py. This hook can be used to set the location of the cache, but rather than changing the location, you can use this hook to copy a version of the path_cache.db file from a central location to the user’s default location, thus cutting out the need for it to do an expensive full sync.The centrally stored path cache could then be updated periodically by either manually copying from someone’s cache, or perhaps having a script transfer it on a regular basis.                    WARNING: The cache_location.py hook can be used to set the location of the cache, but setting this to point to a single location for all users should be avoided, as this can lead to database locks when one or more processes try to edit the database at the same time.    ",
    "url": "/396dd133/",
    "relUrl": "/396dd133/"
  },
  "94": {
    "id": "94",
    "title": "Pipeline Integration Components",
    "content": "Pipeline Integration ComponentsHere you’ll find reference documentation for components of the Toolkit platform.",
    "url": "/162eaa4b/",
    "relUrl": "/162eaa4b/"
  },
  "95": {
    "id": "95",
    "title": "Pipeline Integrations",
    "content": "Pipeline IntegrationsShotGrid’s pipeline integrations bring ShotGrid data to your artists. Customizable UIs within popular content creation software give artists out-of-the-box tools to view information about their tasks, read and add notes, and share files with teammates. Pipeline integrations are build on the ShotGrid Toolkit platform, and developers can use the Toolkit API to extend functionality or create custom Toolkit apps.This section contains learning materials to help you get started as you administer a ShotGrid pipeline. You’ll find guides to configuring your pipeline and managing your production file system, a tutorial for building a basic vfx pipeline, and resources for writing your own pipeline tools.",
    "url": "/e058fbea/",
    "relUrl": "/e058fbea/"
  },
  "96": {
    "id": "96",
    "title": "Animation Pipeline Tutorial",
    "content": "Animation Pipeline TutorialThis tutorial covers building a simplified, yet typical, pipeline for animation or visual effects production. By following this tutorial you will build a pipeline that provides all of the pieces necessary to push Assets from modeling through look development, and then into and through a production scene.Much of the workflows covered in this pipeline work out-of-the-box with ShotGrid’s built-in integrations. For the portions of the pipeline where studios are more often building custom solutions the tutorial will walk you through the process of customizing the artists workflow using the Toolkit platform.Here is a high level view of the pipeline you will build in this tutorial:    Pipeline OverviewPipeline OverviewFor simplicity, the digital content creation (DCC) software used will be kept to a minimum and limited to Maya and Nuke. Also for the sake of simplicity, data passed between pipeline steps will be limited to Maya ascii files, Alembic caches, and rendered image sequences.                    Note: The simple pipeline outlined in this tutorial has not been tested on production and should only be used as an example of how a ShotGrid-based pipeline could be built.    Prerequisites      A working ShotGrid Project - This tutorial assumes you have experience using ShotGrid for tracking and managing production data.        Understanding of ShotGrid Integrations - ShotGrid ships with integrations that provide some simple production workflows without requiring any manual configuration. You should understand the features and scope of these workflows before diving into the manual configuration and customizations outlined in this tutorial. More information about ShotGrid Integrations can be found here.        Maya &amp;amp; Nuke Experience - This tutorial is designed to build a simple pipeline using Maya and Nuke. You should have a basic understanding of these packages in order to customize the integrations provided by ShotGrid.        Working knowledge of Python - The tutorial requires modifying the functionality of ShotGrid integrations via “hooks” that are written in Python.        Familiarity with YAML - Much of the configuration of the pipeline you will be building is handled by modifying YAML files.  Additional Resources      ShotGrid Support Site        ShotGrid Integrations                  User Guide                    Admin Guide                    Developer Guide            Project Creation &amp;amp; SetupFor this Tutorial, you will need to create a new project in ShotGrid and configure it as if you were preparing for production to begin. This includes ensuring all of the necessary ShotGrid entities are in place and linked up properly. For this tutorial, the Asset, Sequence, Shot, and Task entities are required and should be available by default in a new project. You will create:      Two Assets:                  Teapot character                    Table prop                  One Sequence        One Shot linked to the Sequence you created        A Task per pipeline step  Here are some screenshots of what your configured project entities should look like in ShotGrid:    Teapot and Table Assets    Shot linked to a Sequence    TasksSoftware LaunchersNext, you’ll need to ensure that Maya and Nuke are available to launch in ShotGrid Desktop. In Desktop, make sure that each of these packages can be launched by clicking on their icon. Be sure that the proper version of each package is launched.If either application does not show up in Desktop or the expected version does not launch, you may need to manually configure the launch in ShotGrid via the Software entity.    The default Software entities defined in ShotGridThe Software entity is used to drive which DCC packages to use on your production. By default, the integrations will search for these packages in standard installation locations and make them launchable via Desktop. If you have more than one version installed or you have them installed in a non-standard location, it is possible you need to update the corresponding Software entity entry in ShotGrid to curate the launch experience for your artists.For complete details on the Software entity and how to properly configure it, please see the Integrations Admin Guide. Once you have your DCCs launching the way you expect, you can continue to the next section.ConfigurationThe configuration (config) defines the artist workflow for your project. This includes specifying which ShotGrid integrations to include within the DCCs your artists are launching, how your project’s folder structure is defined, and the naming conventions for files and folders created as artists share data.By default, all new projects are configured to use the basic ShotGrid Integrations which provide a basic workflow for sharing files between artists using many off-the-shelf software packages. The following sections outline how to take over your project’s pipeline configuration (config) and customize it for your studio.Taking Over the Project ConfigUse ShotGrid Desktop (Desktop) to take over your project’s configuration. RMB click within Desktop or click the user icon in the bottom right to show the popup menu. Select the Advanced project setup… option and follow the wizard to locally install your project configuration. The images below show the required steps. You can also follow the steps outlined in the Integrations Admin Guide for Taking over a Pipeline Configuration.    Select the Advanced project setup… in the Desktop popup menu    Choose the ShotGrid Default configuration typeIf this is your first time setting up a ShotGrid project, you’ll also be prompted to define a storage location for your project data.  Otherwise, you can select an existing storage location.    Create a new storage.    Name your new storage.  Remember, this storage is site-wide and not project specific.    Set the path(s) where this storage will be accessible on the operating systems you intend to use.You can view and edit the storages for your ShotGrid site in your Site Preferences, under the File Management section.  You can learn more about these settings here.Now that you have a storage location selected, you’ll choose the name of the directory in that location for your new project.    Enter the name of the folder where your project’s files will live.For this tutorial, we’ll be using a centralized configuration.  The Distributed Setup option provides an alternate option that can provide a different set of benefits, and may be the preferred option for studios without fast shared storage.  You can learn more about the pro and cons of different configuration setups in the Toolkit Administration presentation.Unlike the storages, which are site-wide, the configuration will be project specific, and so the directory you choose here will be used directly to store your configuration.    Make a note of the configuration path you select for the current operating system.The folder you select on the screen above is where your configuration will be installed. You will explore and modify the contents of the configuration in this folder throughout this tutorial.When you click Run Setup on the above screen, Desktop will begin to download and install all of the required components of your configuration. The installation process could take several minutes to complete. Once complete, you will have a local copy of the entire project configuration that you will modify in the following steps.The configuration location you specified during the Desktop installation tutorial is recorded in ShotGrid in the Pipeline Configurations page for your project.    The Pipeline Configuration entity in ShotGridFamiliarize yourself with the contents of this folder in preparation for the next section.Config OrganizationBefore beginning the process of building your simple pipeline, you need to understand how the pipeline configurations are organized and how they work. The following graphic highlights the major components of the configuration and their purposes. For additional information about configurations and their administration, see the Administering Toolkit article.    Project SchemaThe simple pipeline you will build in this tutorial uses the project schema provided by the Default configuration. You can browse the config/core/schema folder to get a feel for the structure that will be created as Toolkit Apps write files to disk. For additional information about configuring the project directory structure, see the File System Configuration Reference documentation.TemplatesThis tutorial also uses the templates defined in the Default pipeline configuration. You can open the config/core/templates.yml file to get a peek at the templates that are used by the apps to map input and output files to paths on disk. For more information about the templating system, see the File System Configuration Reference documentation.HooksMuch of this tutorial will involve modifying App hooks in order to customize the artist workflows. Before diving into that customization, you should have a basic understanding of what hooks are, how they work, and where they live. Read through the Hooks section of the  Administration documentation.As you progress through the tutorial, you will be asked to “take over” a hook defined by one of the Toolkit Apps. The process of taking over an app hook is straightforward. Each time you’re asked to do so, simply follow these steps:      Locate the app containing the hook you want to override in your configuration’s install folder. Find the hooks subdirectory for that app and locate the hook file you want to override.        Copy the hook (renaming it if necessary) into your configuration’s top-level hooks directory.      Once the file is in your configuration’s hooks folder, you will be ready to make changes and customize the code. An additional step is required to point the corresponding App to this new location. You will see how to do this later in the tutorial.Building the PipelineAt this point you should be ready to begin building a pipeline. You have a project set up in ShotGrid, you can launch Maya &amp;amp; Nuke via Desktop, and you’ve taken control of the project’s configuration. You also have a basic understanding of the structure of the config and are ready to begin fleshing out the artist workflow.The following sections will walk through each step of the pipeline, highlighting the features that are available out-of-the-box and walking you through the process of customizing the ShotGrid integrations. By the end of these sections, you will have a simple, fully functional, end-to-end production pipeline. You will also get a feel for the steps artists will take as they work on production.                    Note: All code and configuration for this tutorial can be found on the pipeline_tutorial branch of the tk-config-default2 repository. Feel free to use this branch if you need hints as to where files should live, where code should be added, etc.    Modeling WorkflowThe first step in the simple pipeline is Modeling. In this section you will create the first iteration of the Teapot Asset in your project. You will save it to disk in your project’s folder structure and then publish it.First, launch Maya from ShotGrid Desktop.Once Maya has full loaded, you will see the File Open Dialog appear. This dialog allows you to browse existing Maya files within the project. It also allows you to create new files that the ShotGrid integrations will be aware of.Select the Assets tab and drill down into the Teapot’s modeling task. Since there are no artist work files for this task yet, click the + New File button.    Clicking this button will create a new, empty Maya session and set your current working context to the Teapot Asset’s Model task.                    Note: At any time during this tutorial you can launch the ShotGrid Panel via the ShotGrid menu in Maya or Nuke. This panel provides a view into your project data without leaving your DCC. It will show you your current working context and any recent activity within that context. You can also add notes for feedback directly into the panel. See the ShotGrid Panel documentation for more info.    Next, model a Teapot, or download and import the provided Teapot.    When you’re happy with your Teapot model, select the ShotGrid &amp;gt; File Save… menu action. This dialog will prompt you to save the file to a given name, version, and type.    Notice how the dialog does not ask you to specify the full save path. This is because the App has been configured to save to the maya_asset_work template. This template is defined like this by default:@asset_root/work/maya/{name}.v{version}.{maya_extension}The tokenized fields, {name}, {version}, and {maya_extension} are all the app needs to populate the full path. The @asset_root portion of the template is defined as:assets/{sg_asset_type}/{Asset}/{Step}The tokenized fields here can be automatically inferred by the Toolkit platform, given the current working context that you set when you created the new file above.Also notice the preview of the file name and path to be written at the bottom of the dialog. Note the primary storage and project folder you defined while taking over the project configuration make up the root of the template path.Click the Save button to save the teapot model.An important thing to note at this point is that the steps you just completed will be the same steps artists take when opening and saving workfiles throughout the pipeline. The File Open and File Save dialogs are part of Workfiles App. This “multi” app runs in all of the DCCs supported by the ShotGrid integrations and provides a consistent workflow for all artists.The next step is to make some changes to your teapot. Make sure the lid geometry is separate from the rest of the model so that it can be rigged later on.    Once you’re satisfied with your work, run the ShotGrid &amp;gt; File Save… menu action again. This time the dialog will default your version number to 2. The automatic incrementing of the file version allows artists to maintain a complete history of the work they’ve done. Click the Save button.    Once you have saved the Teapot model to version 2, you are ready for the last step in this section of the tutorial.Now that your Teapot model is ready, you need to publish it so that it can be surfaced and rigged. To publish, click the ShotGrid &amp;gt; Publish… menu action. You will be presented with the Publish App dialog.    The dialog shows a tree of items representing what will be published. The tree includes some entries that represent the items to be published and some entries represent the actions that will be performed during the publish operation.On the left side of the dialog you will see an item representing the current Maya session. Underneath it, you will see a Publish to ShotGrid child action. An additional item representing All Session Geometry is shown as a child item of the current session. It also has a Publish to ShotGrid child action.                    Note: If the All Session Geometry item doesn’t show up, ensure that the Alembic export plugin is enabled in Maya.    Explore the Publish App by clicking on the items on the left side of the tree. You’ll notice that the items to be acted upon, when selected, allow you to enter a description of what is being published. You can also take a screenshot to be associated with the item by clicking the camera icon on the right.When you are ready, click the Publish button in the bottom right corner to publish the current work file and the teapot geometry. Once complete, you can browse to the Teapot Asset in ShotGrid to verify that the publish completed successfully.    In the image above, you can see the published alembic file that contains the teapot model. You should also see a publish for the maya session file. These publishes correspond to the items in the Publish app’s tree view.Like the work file created when using the File Save dialog, the output paths of these two publishes are driven by templates. Here’s what they look like (you’ll find out where these templates are configured for the app later):Maya session publish:@asset_root/publish/maya/{name}.v{version}.{maya_extension}This template is very similar to the work file template by default, the only difference being the publish folder.Asset publish:@asset_root/publish/caches/{name}.v{version}.abcThis template is similar to the maya session publish template, but the file is written to a caches folder.Unlike the File Save dialog, when publishing, you don’t have to supply the name, version, or file extension values. This is because by default the publisher pulls these values from the work file path. Under the hood it is extracting these values through the work template and then applying them to the publish templates. This is an important concept with regard to the Toolkit platform and how templates are used to connect the output of one pipeline step to the input of another. You will look at this in more depth in subsequent sections.Browse to the files on disk to ensure they’ve been created in the correct location.Congratulations! You have successfully created the first published iteration of the Teapot. See if you can use what you’ve learned to publish a model of a table from the Table prop’s modeling task. The result should look something like this:    Next up, the surfacing workflow.Surfacing WorkflowIn this section you will build on what you learned in the modeling section. You will learn how to load the Teapot model you created in the previous section using the Loader app. You will also learn how to customize the Publish app to publish shaders for your Teapot.Start by launching Maya from Desktop. If you still have Maya open after working through the previous section, you do not need to relaunch. Once Maya is open, use the ShotGrid &amp;gt; File Open… menu item to open the Workfiles app. Just like in the Modeling section, use the Assets tab to drill down into the Teapot asset’s tasks. This time, select the surfacing task and click + New File.    You are now working in the Teapot’s surfacing task. An easy way to verify that you are in the right production context is to check the first entry in the ShotGrid menu.    Next you need to load the teapot model into your new surfacing work file. To do this, launch the Loader app via the ShotGrid &amp;gt; Load… menu item in Maya.    The layout of the Loader app is similar to the Workfiles app, but now you are browsing for published files to load rather than work files to open.In the Assets tab, browse to the Teapot character to show the teapot publishes you created in the previous section. You should see a Maya Scene and an Alembic Cache publish. Select the Alembic Cache publish to show details about it on the right side of the dialog. Next, click the Create Reference item in the Actions menu of the Alembic Cache publish. The loader will remain open by default to allow additional actions to be performed, but you can close it to continue. You should see in Maya that a reference has been created pointing to the Teapot publish from the modeling task.    Next, add a simple procedural shader to the teapot.    Shader management can be a time consuming and complex task when building a pipeline. It is often very specific to a studio. It is for these reasons that the shipped Maya integration does not handle shader or texture management out-of-the-box.Use the ShotGrid &amp;gt; File Save… menu action to save the current session before continuing.Custom Shader PublishFor the purposes of this simple pipeline, you will customize the Publisher app to export Maya shader networks as additional publish items from the surfacing step. Later in the tutorial, you will put together a quick and dirty solution that allows the shaders to be reconnected to the Alembic geometry caches when referenced downstream.                    Note: The customization you’ll be adding is, admittedly, very simple and fragile. A more robust solution might take into account alternate representations of a surfaced character as well as the asset management side of using external images as texture maps. This example presents only a starting point for building a real-world solution.                        Note: You can see the full details of how to write publisher plugins here.    Override the Maya collectorFirst, you will need to modify the Publish app’s collection logic. The publisher is configured with a collector hook that defines the logic for “collecting” items to publish and display in the app. You can find the configured app’s settings in this file within your project’s configuration:env/includes/settings/tk-multi-publish2.ymlThis file defines how the Publish app will be used within all of the artist environments. Open the file and search for the Maya section, specifically the configuration for the asset step. It will look like this:    The collector setting defines the hook where the publisher’s collection logic lives. By default, the value is:collector: &quot;{self}/collector.py:{engine}/tk-multi-publish2/basic/collector.py&quot;This definition includes two files. When multiple files are listed in a hook setting, it implies inheritance. The first file contains the {self} token which will evaluate to the installed Publish app’s hooks folder. The second file contains the {engine} token which will evaluate to the current engine’s (in this case the installed Maya engine’s) hooks folder. To summarize, this value says the Maya-specific collector inherits the Publish app’s collector. This is a common pattern for Publisher configuration since the app’s collector hook has logic that is useful regardless of the DCC that is running. The DCC-specific logic inherits from that base logic and extends it to collect items that are specific to the current session.                    Note: We’re only changing the collector setting for the Asset step environment, so our modifications won’t be seen by artists working in other contexts, like Shot steps. They will continue to use the shipped, default Maya collector.    In the Configuration section you learned how to take over a hook. Begin the customization process by taking over the Maya engine’s collector hook in your configuration.    The image above shows how to do this. First, create a folder structure in your project configuration’s hooks folder. This will provide some namespacing to the collector plugin since you may override the same hook for other DCCs later on. Next, copy the Maya engine’s collector hook from the install folder into your new hook folder structure. You should now have a copy of the Maya collector in your configuration with the path:config/hooks/tk-multi-publish2/maya/collector.pyNext, update the publish2 settings file to point to your new hook location. Your collector setting should now have this value:collector: &quot;{self}/collector.py:{config}/tk-multi-publish2/maya/collector.py&quot;Note the {config} token. The path will now resolve to the hooks folder in your project configuration. Your new copy of the collector will inherit from the collector defined by the app itself.                    Note: If you were to publish at this point, the Publish logic would be exactly the same as the collector has simply been copied and referenced from a new location.    Now you need to open up your copy of the collector in your preferred IDE or text editor, then locate the process_current_session method. This method is responsible for collecting all publish items in the current DCC session. Because you will be collecting a new publish type, go to the bottom of this method and add the following line:self._collect_meshes(item)This is a new method that you will add to collect any meshes found in the current session. The method will create mesh items that a shader publish plugin (that you’ll create later) can act upon. The item being passed in is the session item that will be the parent for our mesh items.                    Note: This is a very directed approach to modifying existing publish plugins. For a deeper dive into the structure of the publisher and all of its moving parts, please see the developer docs.    Now add the new method definition below to the bottom of the file:    def _collect_meshes(self, parent_item):       &quot;&quot;&quot;       Collect mesh definitions and create publish items for them.       :param parent_item: The maya session parent item       &quot;&quot;&quot;       # build a path for the icon to use for each item. the disk       # location refers to the path of this hook file. this means that       # the icon should live one level above the hook in an &quot;icons&quot;       # folder.       icon_path = os.path.join(           self.disk_location,           os.pardir,           &quot;icons&quot;,           &quot;mesh.png&quot;       )       # iterate over all top-level transforms and create mesh items       # for any mesh.       for object in cmds.ls(assemblies=True):           if not cmds.ls(object, dag=True, type=&quot;mesh&quot;):               # ignore non-meshes               continue           # create a new item parented to the supplied session item. We           # define an item type (maya.session.mesh) that will be           # used by an associated shader publish plugin as it searches for           # items to act upon. We also give the item a display type and           # display name (the group name). In the future, other publish           # plugins might attach to these mesh items to publish other things           mesh_item = parent_item.create_item(               &quot;maya.session.mesh&quot;,               &quot;Mesh&quot;,               object           )                     # set the icon for the item           mesh_item.set_icon_from_path(icon_path)           # finally, add information to the mesh item that can be used           # by the publish plugin to identify and export it properly           mesh_item.properties[&quot;object&quot;] = objectThe code is commented and should give you an idea of what is being done. The main point is that you’ve now added logic to collect mesh items for any top-level meshes in the current session. If you were to execute the publisher at this point however, you would not see any mesh items in the item tree. This is because there are no publish plugins defined to act on them. Next, you’ll write a new shader publish plugin that will attach to these mesh items and handle publishing them for use downstream.                    Note: You probably saw the call to set an icon for the mesh item in the code above. For this to work, you will need to add an icon to your configuration at the specified path:    config/hooks/tk-multi-publish2/icons/mesh.pngCreate a shader publish pluginThe next step is to connect the newly collected mesh items to a publish plugin that can export the mesh’s shaders to disk and publish them. You will need to create a new publish plugin to do this. Follow this link to the source code for this hook and save it in the hooks/tk-multi-publish2/maya folder and name it publish_shader_network.py.                    Note: The plugin is a lot of code to take in if you are new to the Toolkit platform and the publish code. Don’t worry about that right now. You will have time to go through and understand what is happening as you progress through this tutorial and are exposed to the features of the publisher. For now, just create the file and know that its purpose is to handle writing the shader networks to disk.    The last step before being able to publish shaders is to add the template and configuration defined by the new shader publish plugin. You can see the setting defined by the plugin in the settings property:    @property    def settings(self):       &quot;”” … &quot;””       # inherit the settings from the base publish plugin       plugin_settings = super(MayaShaderPublishPlugin, self).settings or {}       # settings specific to this class       shader_publish_settings = {           &quot;Publish Template&quot;: {               &quot;type&quot;: &quot;template&quot;,               &quot;default&quot;: None,               &quot;description&quot;: &quot;Template path for published shader networks. &quot;                              &quot;Should correspond to a template defined in &quot;                              &quot;templates.yml.&quot;,           }       }       # update the base settings       plugin_settings.update(shader_publish_settings)       return plugin_settingsThis method defines the configuration interface for the plugin. A “Publish Template” setting is required to tell the plugin where to write the shader networks to disk. Add the new publish plugin to the publisher configuration and include the template setting. This is the same configuration block you modified before when taking over the collector. It is defined in this file:env/includes/settings/tk-multi-publish2.ymlYour configuration should look like this now:    Finally, you need to define the new maya_shader_network_publish template in your configuration. Edit this file to add it:config/core/templates.ymlFind the section where asset related Maya templates are defined and add the new template definition. Your definition will look like this:    That should be everything. You have overridden the Publish app’s collector hook to find meshes to publish shaders for. You have implemented a new publish plugin to attach to the collected shader items, and you have defined and configured a new publish template where the shader networks will be written to disk.                    Note: If you closed Maya while making the customizations to your configuration, do not worry. You can simply launch Maya again and use the File Open dialog to open your surfacing work file. You can skip the reloading step below.    Reloading the ShotGrid IntegrationsIn order to try out your customizations, you’ll need to reload the integrations in your Maya session. To do this, click the ShotGrid &amp;gt; [Task Name] &amp;gt; Work Area Info… menu action.    This will launch the Work Area Info app that provides information about your current context. It also has a handy button for reloading integrations while you’re making changes to your configuration. Click the button to reload the the apps and engines, and then close the dialog.    Publishing Shader NetworksNow it is time to see the results of your changes to the project configuration. Launch the publish app from the ShotGrid menu. You should see the collected teapot mesh item with a Publish Shaders plugin attached:    Enter a description of your work and capture a thumbnail of your surfaced Teapot to associate with the published files. Finally, click publish to export the Teapot shaders to disk and register the file as a publish in ShotGrid. When finished, notice that the session publish plugin has automatically saved your work file to the next available version. This is the default behavior within all of the DCCs supported by ShotGrid integrations.You can now browse to the Teapot asset in ShotGrid to verify that everything worked as expected.    Congratulations! You have successfully customized your pipeline and published shaders for the  Teapot. See if you can use what you’ve learned to publish shaders from the Table prop’s surfacing task. The result should look something like this:    Next up, the rigging workflow.Rigging WorkflowAt this point, you should feel pretty comfortable opening (or creating), saving, and publishing workfiles using the Workfile and Publish apps provided by ShotGrid. You’ve also had a chance to use the Loader app to load a publish from upstream. Use what you’ve learned to complete the following tasks:      Launch Maya from ShotGrid Desktop        Create a new workfile in the Teapot asset’s rigging step        Load (reference) Teapot alembic cache publish from the modeling step        Rig the teapot’s lid to open and close (keep it simple)        Save and publish the Teapot rig  You should end up with something like this in ShotGrid:    Next, let’s see how artists handle upstream changes in their workflow. Open up the modeling work file and make some changes to the teapot model. Then publish the updated work. The result should be something like this:    Open the work file in the Teapot’s rigging step again (via ShotGrid &amp;gt; File Open…). Now launch the ShotGrid &amp;gt; Scene Breakdown… menu action. This launches the Breakdown app which shows you all of the upstream publishes that you have referenced into your work file. In this case, there is only the upstream Teapot model. You should see something like this:    For each reference, the app shows you one of two indicators – a green check to show that the referenced publish is the latest version, or a red “x” to indicate that there is a newer publish available.  In this case, we can see that there is a newer publish available.Now select the referenced Teapot alembic cache item (or click the Select All Red button at the bottom), then click Update Selected.The app will update the Maya reference to the latest iteration of the Teapot alembic cache. You should now see your new model in the file.    Make any adjustments to your rigging setup that you need to account for the new model and then publish your changes.In the following sections, you’ll be working in a shot context. Next up, shot layout.Layout WorkflowIn this section, you will begin working in the Shot you created for your project. You will load the assets created in the previous sections and block out the shot. You will then customize the publisher again, this time to publish the shot camera.Begin by using what you learned in the previous sections to complete the following tasks:      Launch Maya from ShotGrid Desktop        Create a new workfile in your Shot’s layout step (Hint: use the Shots tab in the Loader)        Load (reference) the Teapot publish from the Teapot’s rigging step        Load (reference) the Table publish from the Table’s model step  Now block your simple scene with the Teapot on the Table. Add a camera to your scene called camMain and animate a few frames to create your shot’s camera move.    Once you are happy with your shot layout, save the file via the ShotGrid &amp;gt; File Save… menu action. If you were to go ahead and publish at this point, you would only see the entire maya session as an available item to publish.An easy customization to add, and one that provides a lot of flexibility to a pipeline, is the ability to publish stand-alone cameras to a file format that is easy to import into other packages. This makes it possible to generate the camera once, typically in layout, and then have all other pipeline steps, such as animation, lighting, and compositing, consume it directly.Collecting camerasAs with shader publishing, the first step is to customize the collector hook. You’ve already taken over the collector hook for maya and configured it for the asset step. Now you need to update the configuration for the shot pipeline steps. To do this, modify the publisher’s configuration file and edit the maya shot step collector setting.    Now, when working in a task within a Shot context, your custom collector logic will run. The next step is to add the custom camera collection logic.Open your custom collector hook and add the following method call at the bottom of the process_current_session method where you added the call to collect meshes in the surfacing section:self._collect_cameras(item)Next, add the method itself to the bottom of the file:    def _collect_cameras(self, parent_item):       &quot;&quot;&quot;       Creates items for each camera in the session.       :param parent_item: The maya session parent item       &quot;&quot;&quot;       # build a path for the icon to use for each item. the disk       # location refers to the path of this hook file. this means that       # the icon should live one level above the hook in an &quot;icons&quot;       # folder.       icon_path = os.path.join(           self.disk_location,           os.pardir,           &quot;icons&quot;,           &quot;camera.png&quot;       )       # iterate over each camera and create an item for it       for camera_shape in cmds.ls(cameras=True):           # try to determine the camera display name           try:               camera_name = cmds.listRelatives(camera_shape, parent=True)[0]           except Exception:               # could not determine the name, just use the shape               camera_name = camera_shape           # create a new item parented to the supplied session item. We           # define an item type (maya.session.camera) that will be           # used by an associated camera publish plugin as it searches for           # items to act upon. We also give the item a display type and           # display name. In the future, other publish plugins might attach to           # these camera items to perform other actions           cam_item = parent_item.create_item(               &quot;maya.session.camera&quot;,               &quot;Camera&quot;,               camera_name           )           # set the icon for the item           cam_item.set_icon_from_path(icon_path)           # store the camera name so that any attached plugin knows which           # camera this item represents!           cam_item.properties[&quot;camera_name&quot;] = camera_name           cam_item.properties[&quot;camera_shape&quot;] = camera_shapeOnce again, the code is commented and should give you an idea of what is being done. You have added logic to collect camera items for all cameras in the current session. As before, if you were to execute the publisher at this point however, you would not see any camera items in the item tree. This is because there are no publish plugins defined to act on them. Next, you’ll write a camera publish plugin that will attach to these items and handle publishing them for use downstream.                    Note: You probably saw the call to set an icon for the camera item in the code above. For this to work, you will need to add an icon to your configuration at the specified path:    config/hooks/tk-multi-publish2/icons/camera.pngCustom camera publish pluginThe next step is to connect the newly collected mesh items to a publish plugin that can export the mesh’s shaders to disk and publish them. You will need to create a new publish plugin to do this. Follow this link to the source code for this hook and save it in the hooks/tk-multi-publish2/maya folder and name it publish_camera.py.Camera publish configurationFinally, you need to update the Publish app’s configuration for the Shot steps. Edit the settings file to add your new plugin.env/includes/settings/tk-multi-publish2.ymlYour configuration should look like this now:    You’ll notice the two settings added to the file as defined by the settings method of the new plugin. As with the shader plugin, there is a Publish Template setting which defines where the camera files will be written. The Cameras setting is a list of camera strings that drive which cameras the plugin should act on. The expectation is that there is some type of camera naming convention and this setting prevents the user from being presented with publish items for cameras that don’t match the convention. In the image above, only the camMain camera will be presented for publishing. The implementation of the plugin you added will also work with wildcard patterns like cam*.The last step before testing your changes is to add the definition for the new camera publish template. Edit the config/core/templates.yml file and add the template definition to the maya shot template section:    At this point, you should be ready to publish your camera with the new plugin. Use the Work Area Info app to reload the integrations, then launch the publisher.    As you can see in the image, the new camera item is collected and the publish plugin is attached. Go ahead and click Publish to write the camera to disk and register it with ShotGrid.                    Note: Similarly to Alembic export, the camera publish plugin requires the FBX export plugin to be loaded.  If you don’t see the camera publish plugin item, check to ensure that the FBX plugin is loaded, and re-launch the publisher.    You should see something like this in ShotGrid:    That’s it! Next up, animation.Animation WorkflowUp to this point, you’ve only customized the Publish app in order to write custom file types/contents to disk and share them with other pipeline steps. In this section, you will customize the Loader app’s configuration to complete the round trip to make it possible to import/reference custom publishes.Use what you’ve learned in previous sections to complete the following tasks.      Launch Maya from ShotGrid Desktop        Create a new workfile in your Shot’s animation step        Load (reference) the maya session publish from the Shot’s layout step                      Note: You’ll notice that the camera was included in the layout session publish file. In a robust pipeline, the camera might be explicitly hidden or excluded from the session publish in order to allow the separate camera publish file to be the one true camera definition. Go ahead and delete or hide the camera included by the reference.    Custom camera Loader actionIn order to customize the Loader app to import/reference the camera publishes, you will need to edit the app’s settings file. This is the path to the file in your configuration:config/env/includes/settings/tk-multi-loader2.ymlFind the section where the app is configured for maya and add this line to the list of actions in the action_mappings setting:FBX Camera: [reference, import]In the custom camera publish plugin, the FBXExport mel command in Maya was used to write the camera to disk, and the publish type used to register the file with ShotGrid was FBX Camera. The line you added to the settings tells the loader to display the reference and import actions for any publishes of type FBX Camera. These actions are defined in the tk-maya-actions.py hook of the Loader app. These actions are implemented in a way to handle any type of file that Maya can reference or import. The .fbx files generated by the custom plugin fall into that category so this is the only change needed to be able to load the published cameras.Your app settings should now look like this:    Now reload the integrations via the Work Area Info app to pick up the new setting, then browse to the published camera from layout.    Filter by the new publish type, then create a reference to the camera. Close the Loader and you should be able to play back the camera motion you created in the previous section with the newly reference camera.Next, animate your Teapot model to do something (keep it simple).    When you are happy with your animation, save and publish your work file just like you did in previous sections.Next up, lighting.Lighting WorkflowIn this section, you will bring together everything you published in the previous sections and render your shot. To do this, you will customize the Loader app to load the published shaders from the Teapot asset’s surfacing step.First, use what you’ve learned in previous sections to complete the following tasks.      Launch Maya from ShotGrid Desktop        Create a new workfile in your Shot’s lighting step        Load (reference) the maya session publish from the Shot’s animation step        Load (reference) the camera publish from the Shot’s layout step  Custom shader Loader actionIn order to load the shaders you published in the surfacing step, you will need to take over the tk-maya-actions.py hook mentioned in the previous section. Copy that hook from the install location into your configuration.    This hook is responsible for generating a list of actions that can be performed for a given publish. The Loader app defines a different version of this hook for each DCC supported by the shipped integrations.The shaders published in the surfacing workflow section are just Maya files, so like the exported cameras, they can be referenced by the Loader without changing the existing logic. The only change required is to add new logic to the actions hook to connect shaders to the appropriate mesh after they are referenced into the file.Add the following method at the end of the actions hook (outside the class).    def _hookup_shaders(reference_node):       &quot;&quot;&quot;       Reconnects published shaders to the corresponding mesh.       :return:       &quot;&quot;&quot;       # find all shader hookup script nodes and extract the mesh object info       hookup_prefix = &quot;SHADER_HOOKUP_&quot;       shader_hookups = {}       for node in cmds.ls(type=&quot;script&quot;):           node_parts = node.split(&quot;:&quot;)           node_base = node_parts[-1]           node_namespace = &quot;:&quot;.join(node_parts[:-1])           if not node_base.startswith(hookup_prefix):               continue           obj_pattern = node_base.replace(hookup_prefix, &quot;&quot;) + &quot; d*&quot;           obj_pattern = &quot;^&quot; + obj_pattern + &quot;$&quot;           shader = cmds.scriptNode(node, query=True, beforeScript=True)           shader_hookups[obj_pattern] = node_namespace + &quot;:&quot; + shader       # if the object name matches an object in the file, connect the shaders       for node in (cmds.ls(references=True, transforms=True) or []):           for (obj_pattern, shader) in shader_hookups.iteritems():               # get rid of namespacing               node_base = node.split(&quot;:&quot;)[-1]               if re.match(obj_pattern, node_base, re.IGNORECASE):                   # assign the shader to the object                   cmds.select(node, replace=True)                   cmds.hyperShade(assign=shader)Now add the following 2 lines at the end of the _create_reference method to call the shader hookup logic:    reference_node = cmds.referenceQuery(path, referenceNode=True)    _hookup_shaders(reference_node)&amp;lt;/td&amp;gt;The code runs whenever a new reference is created, so it should assign the shader when referencing new geometry if the shader already exists in the file. Similarly, it should work when referencing the shader and the geometry already exists.                    Note: This hookup logic is very brute force and does not properly handle namespaces and other Maya-related subtleties that should be considered when implementing a production-ready pipeline.    Finally, point your shot’s loader settings to your new hook by editing this file:config/env/includes/settings/tk-multi-loader2.ymlWhile, there, also associate the Maya Shader Network publish type with the reference action. Your Loader settings should now look like this:    Now reload the integrations via the Work Area Info app to pick up the new settings, then browse to the published shaders from surfacing.Create a reference to the Teapot shader network publish.    Now load the Table shader network. If you turn on Hardware Texturing in Maya, your shaders should have been automatically connected to the meshes reference from the animation step.    Now add some lights to your scene (keep it simple).    Publishing Maya RendersRender your shot to disk.                        Note: As you can see, there are issues with the surfacing of both the Teapot and the Table asset. For the purposes of this tutorial, assume these were intentional, artistic choices. If you want to address these issues, you can always load the surfacing work files for these assets and adjust the shaders and re-publish them. If you do, remember to update the references in the lighting work file and re-render. If you go through the steps, you may find that the breakdown app does not reconnect your updated shaders after reloading the reference. Based on your experience modifying the loader to hook up shader references, you should be able to update the breakdown app’s scene operations hook to add the required logic. HINT: See the update method in this file.    The shipped ShotGrid integrations will collect image sequences by looking at the render layers defined in the file. Once your render is complete, launch the publisher. You will see the rendered sequence as an item in the tree.    Go ahead and publish the session and the rendered image file sequence. You should see something like this in ShotGrid:    Next up, compositing!Compositing WorkflowIn this final section of the tutorial, you will be introduced to some of the default integrations provided by Nuke. In addition to the app’s you have seen in previous sections, you will learn about the ShotGrid-aware Write node and an app that allows you to quickly send your renders to others for review.Start by following these steps to prepare your work file.      Launch Nuke from ShotGrid Desktop        Just like in Maya, use the ShotGrid &amp;gt; File Open… menu action to create a new work file in the Shot’s compositing step.  Load the image sequence you rendered and published in the previous section via the Loader app.    The action defined for the Image and Rendered Image publish types (the type depends on the file extension) is Create Read Node. Click this action to create a new Read node in your nuke session.Make sure your Nuke Project Settings output format matches your rendered images. Create a Constant color to use as your background and merge it with your Read node. Attach a viewer to see your composite.    Once you are happy with your comp, use the ShotGrid &amp;gt; File Save… menu action to save your work file.Next, click the ShotGrid logo in the left hand menu in Nuke. Click on one of the ShotGrid-aware write nodes in that menu:    The ShotGrid Write Node app provides a layer on top of the built-in Nuke Write node that automatically evaluates the output path based on your current ShotGrid context.    Render the image frames to disk. You can now publish your nuke session to associate the work file with the rendered images. By default, the publisher will collect the rendered frames and attach a plugin to register the frames with ShotGrid. A second plugin will upload the frames for review by way of an integration that runs in the background called review submission. This app uses nuke to generate a quicktime that will be uploaded and made available for review.    Another useful integration is the Quick Review app. This is an output node that will quickly generate and upload a quicktime to ShotGrid for Review. The app can be found in the left hand menu next to the ShotGrid Write Nodes.    Create a Quick Review node, then click the Upload button to render the input to disk, generate the quicktime, and upload the result to ShotGrid for review. Some standard options are provided before submitting the frames.    Check the media tab in ShotGrid to see both of the uploaded quicktimes.    For more information on reviewing media in ShotGrid, see the official documentation.ConclusionCongratulations, you’re done! Hopefully this tutorial has given you a starting point for building your own custom pipeline using the ShotGrid integrations. You should have an understanding of how to extend the default integrations to meet the specific needs of your studio.Ask questions and learn how other studios are using Toolkit over at the shotgun-dev Google Group.  Be sure to subscribe to stay up to date with the latest posts!If there are features or workflows that you feel are outside of the default integrations, then you can always write your own apps. Here is an excellent document to help you get started writing your first app.As always, if you have additional questions about this tutorial or about ShotGrid or the Toolkit platform in general, reach out to the community.",
    "url": "/cb8926fc/",
    "relUrl": "/cb8926fc/"
  },
  "97": {
    "id": "97",
    "title": "Planning Your Setup",
    "content": "Planning Your SetupPick your optionsPick which features you want to activate  Media Isolation  Media Traffic Isolation  Media ReplicationAWS Account CreationBefore going further, you will require an AWS Account. If you don’t already have an AWS Account, create your AWS Account.Choose an AWS RegionChoose an AWS Region for your AWS S3 bucket and VPC. Which region to use? You should chose the a region that is the closest possible to your studio.If your company is located in different locations, consider enabling the media replication feature to reduce latency and improve performancePlan the VPC IP rangesPlan your AWS VPC and subnets IP ranges if you plan to use Media Traffic Isolation.IP Range Example            Region      VPC      Subnet 1      Subnet 2      Subnet 3                  ap-southeast-2      10.1.0.0/16      10.1.0.0/24      10.1.1.0/24      10.1.2.0/24      Plan how you will privately access your AWS VPCIf you plan to activate any of the Traffic Isolation feature, you will need a way to connect your AWS VPC and your network infrastructure. The main options are:  AWS Direct Connect  Other VPN solutionWe highly recommand you to leverage Direct Connect. Direct Connect guarantees the lowest latency possible to the ShotGrid services, a consistent network experience, and allow you to leverage the optimization AWS is relying on to guarantee an optimal performance across the globe.Next StepWith your plan layed down, you are ready to start implementing the AWS building blocks that will allow you to activate the isolation features.See Media Isolation for activating the Media Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/7897b2e2/",
    "relUrl": "/7897b2e2/"
  },
  "98": {
    "id": "98",
    "title": "Private Link",
    "content": "Private LinkAWS PrivateLink is an AWS service that connects different AWS VPCs without going through the public internet.In conjunction with AWS Direct Connect, PrivateLink helps create a dedicated connection between your studio and ShotGrid’s infrastructure.",
    "url": "/9da985a7/",
    "relUrl": "/9da985a7/"
  },
  "99": {
    "id": "99",
    "title": "urlopen error SSL CERTIFICATE_VERIFY_FAILED certificate verify failed (_ssl.c:726)",
    "content": "[ERROR publish_creation] &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;Use caseDeveloping tools for digital assets in Houdini 17.5, while using a build toolkit app, I execute a hook which try to register the published file.The script executes the code:    args = {        &quot;tk&quot;: self.parent.tank,        &quot;context&quot;: self.parent.engine.context,        &quot;path&quot;: esto['operator'],        &quot;name&quot;: os.path.basename(esto['operator']),        &quot;version_number&quot;: 6,        &quot;published_file_type&quot;: &quot;Library item&quot;,    }    print 'sgtk: ', sgtk.__file__    sg_publish = sgtk.util.register_publish(**args)The published files is registered correctly in ShotGrid, but it presents the following error:---------------------------------------------------------------------------[ERROR publish_creation] &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;Traceback (most recent call last):  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank/util/shotgun/publish_creation.py&quot;, line 308, in register_publish    tk.shotgun.upload_thumbnail(published_file_entity_type, entity.get(&quot;id&quot;), no_thumb)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank_vendor/shotgun_api3/shotgun.py&quot;, line 2173, in upload_thumbnail    field_name=&quot;thumb_image&quot;, **kwargs)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank_vendor/shotgun_api3/shotgun.py&quot;, line 2263, in upload    tag_list, is_thumbnail)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank_vendor/shotgun_api3/shotgun.py&quot;, line 2383, in _upload_to_sg    result = self._send_form(url, params)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank_vendor/shotgun_api3/shotgun.py&quot;, line 3806, in _send_form    resp = opener.open(url, params)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 429, in open    response = self._open(req, data)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 447, in _open    '_open', req)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 407, in _call_chain    result = func(*args)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 1241, in https_open    context=self._context)  File &quot;/opt/hfs17.5.173/python/lib/python2.7/urllib2.py&quot;, line 1198, in do_open    raise URLError(err)URLError: &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;Traceback (most recent call last):  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/config/hooks/publish_digital_asset.py&quot;, line 66, in register_publishedfile    description='Alembic nodes.')  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank/log.py&quot;, line 503, in wrapper    response = func(*args, **kwargs)  File &quot;/home/cvizcarra/ollinDev/PIGS_kDev/install/core/python/tank/util/shotgun/publish_creation.py&quot;, line 323, in register_publish    entity=entityShotgunPublishError: Unable to complete publishing because of the following error: &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;, although PublishedFile PIGS_libary_tool_hda_asasas_v017.hda (id: 114715) was created.---------------------------------------------------------------------------What’s causing the error?Missing cacert.pem and the required environment variable SHOTGUN_API_CACERTS pointing to that location.How to fixAdd the cacert.pem and environment variable SHOTGUN_API_CACERTS pointing to the location.See the full thread in the community.",
    "url": "/02a75bb2/",
    "relUrl": "/02a75bb2/"
  },
  "100": {
    "id": "100",
    "title": "Python 3 Porting Best Practices",
    "content": "Python 3 Porting Best PracticesWhy the move to Python 3?There are a few compelling reasons to make the leap to Python 3.  Perhaps the most dramatic is the Python 2 end of life, which occurred on January 1, 20201. With the sunsetting of Python 2, all support for Python 2 ceases, meaning that even new security vulnerabilities found in Python 2 will not be addressed.Things to Consider Before StartingWhen considering moving to Python 3, it’s good to look at the requirements and application of your codebase to set expectations.  Obviously, any host applications your code runs in will help drive this decision.  Knowing whether you need to support many different Python interpreter versions and, if so, which ones, will be important information as you decide on the porting process that makes sense for you.Next, take an audit of what libraries your code depends on.  If any of these libraries do not have Python 3 compatible versions, you’ll need to find an alternative library, or fork the library to provide compatibility yourself. Both of these options could potentially be costly decisions and are important to consider early on.  Additionally, even libraries that do offer Python 3 compatible versions may not be drop-in replacements, and some libraries choose to fork for Python 3 support rather than maintain compatibility for both Python 2 and 3 as a single source.  We’ll discuss this in more depth in the “Porting Options” section below.Finally, it’s worth noting that while it is possible to continue to support Python versions older than 2.5 and Python 3 simultaneously2, this will make your life much harder.  Since Python 2.5 is very old and not used in modern DCC versions, this guide will work under the assumption that Python 2.5 and earlier will not be targeted.  If you do need to support older versions of Python, a branching approach as described in the “Porting Options” section below may be your best option.What’s Different in Python 3Python 3 comes with some slight syntax changes, changes to builtin functions, new features, and small behavior changes.  There are many great guides that enumerate these specific changes and provide examples.  Rather than dive into specifics here, the goal of this guide will be to describe the porting process from a higher-level perspective, with a few small deep dives where compatibility may be more complicated than just matching syntax.Porting OptionsFor most of us, porting our code to only support Python 3 is not yet an option.  Many DCCs still require Python 2 support, and this is unlikely to change overnight.  This means that in the real world, it will be a necessity to be able to support both Python 2 and 3.There are two major approaches to supporting Python 2 and 3 simultaneously.  We’ll discuss both of them briefly:BranchingIn this approach, a new Python 3 compatible branch of your code is maintained in parallel with the current (Python 2 compatible) branch.  This has the advantage of letting you write cleaner, easier to read Python 3 code, and allows you to fully leverage new features without needing branching logic to maintain Python 2 support.  It also means that when the time comes to drop support for Python 2, you’ll be left with a cleaner, more modern starting point in your Python 3 branch.  The obvious downside here is that maintaining two branches can be unwieldy and mean more work, especially if the Python 3 and Python 2 code starts to diverge as the Python 3 branch can leverage new features that can significantly change how your code looks (e.g. asyncio.)Cross-CompatibilityIn this approach, a single branch is maintained that uses the subset of syntax and builtins that are compatible with both Python 2 and 3.  This allows for a graceful transition from Python 2 to 3 without maintaining multiple branches of your code.  There are a few popular libraries designed to help with this approach, and it’s a commonly-used solution to the problem of transition from Python 2 to 3.  In addition to the reduced complexity compared to maintaining multiple branches, this approach also means you don’t need to change your code distribution mechanisms or worry about using the correct (Python 2 or 3) version of your code at import time.The two most commonly used libraries for this approach are future and six.futureThe future module is probably the most popular choice for Python 2 + 3 compatibility.  It backports many Python 3 libraries to Python 2, and aims to allow you to move your codebase to a pure Python 3 syntax.  Because it backports modules and works by shadowing builtins, it is slightly more invasive than six.  Given the variety of DCCs and unknown client code in VFX environments, future may be too invasive and in an environment like this may pose a greater risk of causing problems down the road.  For this reason, we will focus on using six instead.sixThe six module does not attempt to backport Python 3 modules, or allow you to write pure Python 3 syntax, but instead unifies renamed modules and changed interfaces inside the six.moves namespace.  This allows you to update imports and use six’s helper functions to write code that is both Python 2 and 3 compatible.Testing and LintingBlackThe porting process requires an examination of the entire python codebase, and introduces a fair amount of noise in the revision control history.  This makes it a good opportunity to take care of any other housekeeping that may have similar impacts.  We took this opportunity to apply black to our code.  This is not strictly necessary or directly related to Python 3 compatibility (unless your code is mixing tabs and spaces3), but given the reasons identified above, we decided this was a good opportunity to modernize our code formatting.TestsTest coverage was incredibly valuable during the porting process since it allowed us to quickly find problems that still needed to be addressed, and verify that large sections of code were working as expected without as much manual intervention.  In many cases, we found it worthwhile to increase test coverage as part of the porting process to ensure that Python 2/3 specific cases (e.g. unicode handling) were being addressed correctly.  This being said, we recognize that in many cases the realities of production mean that test coverage is sparse, and that adding tests to code that has little or no coverage may be too time consuming to be worthwhile as part of a project like adding Python 3 compatibility.  For those in this situation, there may still be some value in using coverage measurement tools and some more basic testing code during the porting process, as these tools can provide fast feedback on what code has been covered and what may still need attention.Porting ProcedureAutomated Porting using modernizepython-modernize is a tool that can be very useful for automatically generating Python 3 compatible code.  modernize usually produces runnable code with minimal human intervention, and because of this can be a great tool to get most of the way to Python 3 compatibility very quickly.  Of course, as an automated tool it does come with the drawbacks one would expect.  It frequently produces less readable and less efficient code (e.g. wrapping all iterables in a list() instantiation.)  In some cases, modernize can even introduce regressions that might be difficult to spot.  There are also some areas where you’ll find modernize is not much help at all, like when dealing with bytes and text.  Since these decisions require a bit more understanding of context, you’ll likely have to spend some time manually addressing the handling of strings in your code even if you do rely on modernize for the bulk of the compatibility work.The alternative to using an automated tool like modernize, of course, is to go through code manually to fix incompatibilities.  This can be tedious, but in our experience generally produces nicer looking code.For our process we went with a hybrid approach, using modernize with a select set of fixers, and doing some of the work manually.  We also broke the process into two stages; first doing a pure syntax compatibility and code formatting pass, and then doing a more manual Python 3 port.  Our process was as follows:In a branch:  Run modernize with the except, numliterals, and print fixers  python-modernize --no-diffs --nobackups -f except -f numliterals -f print -w .  Make sure the resulting code is Python 3 syntax compliant by compiling it with Python 3.  The goal here is not to have your code work in Python 3, but to ensure that the basic formatting and automatable syntax fixes are in place.  If your code does not successfully compile after this step, you’ll need to find the source of the problem and either add additional fixers to the above step, or manually fix the incompatibilities.  Ensure that any changes you make manually at this stage are syntax only and will not change the behavior of the code in Python 2.  python3 -m compileall .  Run black on the resulting codeThis branch should not change any behavior or functionality, and should not introduce regressions, so it is considered safe to merge at this point.  This helps keep the history easier to read, and means that the Python 3 compatibility branch and master will diverge less during the porting process, making for an easier merge once the work is done.In a new branch, the actual Python 3 port can now begin:  Search for method names that may require some work to deal with list/view/iterator differences between Python 2 and 3.  In Python 3 .values(), .items() and .keys() return an iterator or view instead of a list, so in cases where these methods are called the code should be able to handle both iterator and list returns, otherwise the result will need to be cast to a list.  Similarly, the filter() method returned a list in Python 2, but now returns an iterator.  Change calls from dict.iteritems() and dict.itervalues() to dict.items() and dict.values() if the returned collection won’t be too big.  In these cases, the resulting cleaner code at the cost of a slight performance hit in Python 2 is preferable.  In cases where the collection might contain thousands of items or more, use six.iteritems and six.itervalues instead.  If dict.iterkeys() was used, simply replace the code with something like for key in dictionary:, since this will iterate on keys in both Python versions.  Watch out that returning an iterator in Python 3 doesn’t change the semantics of the code however. If a method used to return dict.values(), you’ll need to wrap the call inside list(dict.values()) to ensure the method always returns a list in all versions on Python.  Search for str, basestring, unicode, open, pickle, encode, decode since these will be areas of the code that likely require some attention to handling of bytes and strings.  We used the coercion helper methods provided by six (e.g. ensure_string) where needed.  See the sections on bytes and pickle below.  Unless generating a super long range, xrange can be changed to range for simplicity, otherwise six.range can be used.  After committing the manual changes from above, run a full python-modernize and go through the diff manually.  Many of the resulting changes will be unwanted, as discussed above, however this is a good way to catch potential problems that were overlooked in the manual porting process.  python-modernize --no-diffs --nobackups -f default . -w &amp;amp;&amp;amp; git diff HEAD  Test the resulting code to find the remaining problems.  There are some incompatibilities that don’t have fixers (this is a good resource to look at to get an idea of what those changes entail), and it’s easy to overlook text/binary problems during the port process.We chose to use this process because we believe it allowed us to maintain a standard of more readable, efficient code than would have been automatically generated by using modernize on its own.GotchasBytes WoesPython 3 introduces a strict separation between binary and textual data.  This is a long-called-for addition that most see as an improvement, but for Python 2 + 3 compatible code it adds some headaches.  Since Python 2 does not enforce this separation, and Python 3 introduces new types to do so, code that deals with data and strings will likely need some attention.  For the most part this just means making sure that strings are encoded / decoded properly, for which the six.ensure_binary and six.ensure_text helper functions are invaluable.  See the examples below for common applications of these methods.  In some cases, however, this can be more complicated.  For an example of this, see the pickle section below.# base64.encodestring expects str in Python 2, and bytes in Python 3.# By using six.ensure_binary() we can ensure that the we always# pass it the correct type.base64.encodestring(six.ensure_binary(some_string))# In this example (from tk-multi-publish2), we get a list of files# from a QDropEvent in Pyside.  The  filenames are unicode, however# they're being passed to code that expects str.# In Python 2, this had looked like:if isinstance(category_type, unicode):                    category_type = category_type.encode(&quot;utf-8&quot;)# Using six, we can get the same behavior in Python 2, and ensure# compatibility with Python 3 with:category_type = six.ensure_str(category_type)The pickle PicklePickle in Python 3 returns a bytes object from dumps(), where previously it had returned a str.  Additionally, the output of pickle.dumps() in Python 3 contains  x00 bytes, which cannot be decoded. This is not a  problem if the data is being stored in a file, but if the pickled data is being stored in, for example, an environment variable, this can become problematic.  As a workaround, we found that by forcing pickle to use protocol 0, no 0 bytes were included, and the output is once again decodable.  This comes at the cost of the slightly less efficient and fewer-featured older protocol.# Dumping data to a pickle string:DUMP_KWARGS = {&quot;protocol&quot;: 0}# Force pickle protocol 0, since this is a non-binary pickle protocol.# See https://docs.python.org/2/library/pickle.html#pickle.HIGHEST_PROTOCOL# Decode the result to a str before returning.pickled_data = six.ensure_str(cPickle.dumps(data, **DUMP_KWARGS))# Loading data from a pickle string:LOAD_KWARGS = {&quot;encoding&quot;: &quot;bytes&quot;} if six.PY3 else {}data = cPickle.loads(six.ensure_binary(data), **LOAD_KWARGS)Regex  W flagIn Python 3, regular expression metacharacters match unicode characters where in Python 2 they do not.  To reproduce the previous behavior, Python 3 introduces a new re.ASCII flag, which does not exist in Python 2.  To maintain consistent behavior across Python 2 and 3, we wrapped re functions to include this flag across the board in Python 3.Dictionary OrderPrior to Python 3.7, dictionary order was not guaranteed.  As of Python 3.7, insertion order is preserved in dictionaries[11].  In practice, on Python 2.7 dictionary order was random but deterministic (though this was not guaranteed), on some versions of Python (including some version of Python 3) dictionary order is non-deterministic[10].  While code prior to Python 3.7 should not rely on dictionary key order being deterministic, there were instances where this assumption was made in our unit tests.  These tests broke in Python 3.7, and needed to be updated to ensure that dictionary key order was not relied upon.sys.platformIn Python 3.3+ sys.platform on Linux returns linux, where previously it had returned “linux” appended with the kernel major version (i.e. linux2).  Of course when testing for Linux it is easy enough to check sys.platform.startswith('linux').  We chose to centralize these tests and platform “normalization”, and introduced functions sgtk.util.is_windows(), sgtk.util.is_linux(), sgtk.util.is_macos(), as well as a sgsix.platform constant that contains a normalized platform string that can be used for consistent mapping to platform names across python versions.Notes            https://www.python.org/doc/sunset-python-2/ &amp;#8617;              https://docs.python.org/3/howto/pyporting.html#drop-support-for-python-2-6-and-older &amp;#8617;              https://portingguide.readthedocs.io/en/latest/syntax.html#tabs-and-spaces &amp;#8617;      ",
    "url": "/5583eab1/",
    "relUrl": "/5583eab1/"
  },
  "101": {
    "id": "101",
    "title": "Python API best practices",
    "content": "Python API best practicesBelow is a list of best practices when using the ShotGrid Python API.Performance  Don’t request any fields you don’t need for your script. Including additional fields can add unnecessary overhead to your request.  Make your filters as specific as possible. Wherever possible, filtering in the API query rather than parsing it after you have the results back is better.  Exact match filters will perform better than partial match filters. For example, using “is” will perform better than “contains”.  When requesting linked entities, if you only need the name or id of the linked entity, only request the linked field as these fields are provided by default. For example, request entity instead of entity.Asset.id (as the latter will take longer). If you need fields on the linked entities that are not provided by default (i.e. not type, id or name), then it is appropriate to use the dot notation to access them.Control and debugging  Use separate keys for scripts, so you have a unique key for every tool. This is invaluable for debugging.  Make sure that every script has an owner or maintainer and the information is up to date in your Scripts page, under the Admin menu.  Consider creating a read-only permission group for API users . Many scripts only need read access and this can limit your exposure to accidental changes.  Track which keys are in use so that old scripts can be removed. Some studios script auditing information in their API wrapper, to make this easier.  Check entity names and fields. ShotGrid has two names for each field: a display name that’s used in the UI (and isn’t necessarily unique) and an internal field name that’s used by the API. Because the display name can be changed at any point, you can’t reliably predict the field name from the display name. You can see field names by going to the fields option in the Admin menu, or you can use the schema_read(), schema_field_read(), schema_entity_read() methods , as described in https://developer.shotgridsoftware.com/python-api/reference.html?%20read#working-with-the-shotgun-schema.Design  For larger studios especially, consider having an API isolation layer—a wrapper. This isolates your tools from changes in the ShotGrid API. It also means that you can control API access, manage debugging, track auditing, etc. without needing to modify the API itself.  Use the latest version of the API. It will contain bug fixes and performance improvements.  Be aware of where the script will be run from. A script running on a render farm, where it will be calling to ShotGrid for the same information 1000’s of times per minute, can impact site performance. In cases like these, consider implementing a read-only caching layer to alleviate unnecessarily repetitive calls.  You can turn off event generation for scripts. This is most useful for scripts that are running very often whose events you won’t need to track later. For scripts that run extremely often, this is highly recommended as the event log can otherwise become very large.",
    "url": "/09b77cf4/",
    "relUrl": "/09b77cf4/"
  },
  "102": {
    "id": "102",
    "title": "Create and manage API scripts",
    "content": "Create and manage API scriptsFollow the steps below to create a new Script:  Go to the Admin Menu and select “Scripts”.  Create a new Script using the “+ Script” button.      Grab the value from the Application Key. You’ll need this to initiate a connection to ShotGrid.          Note: API keys are treated like passwords, and once created cannot be viewed again via the ShotGrid web app or API. Make sure you copy the key before proceeding.        Now you can use your Script key to connect to ShotGrid. See “ShotGrid Methods” in our API documentation to learn more about how to connect to ShotGrid with your Script.  Tip: If for some reason you need to reset the Application Key of your Script, you’ll need to create a new ShotGrid Script entity to do so. First rename your existing Script to something like “[My Script]—OLD”, then delete it. Create a new Script. The reason you need to rename the old one is that ShotGrid requires unique names for each Script.When to set up a new ScriptScript actions can be logged. The more fine-grained the use of individual Script keys, the easier it will be for you to track which Script is making changes for debugging. Having separate Scripts is also a good way to track which Scripts will be impacted by changes on your ShotGrid site and who maintains the Script.",
    "url": "/99105475/",
    "relUrl": "/99105475/"
  },
  "103": {
    "id": "103",
    "title": "Python API",
    "content": "Python APIHere you’ll find reference documentation for the Python API.",
    "url": "/682204e9/",
    "relUrl": "/682204e9/"
  },
  "104": {
    "id": "104",
    "title": "API Overview",
    "content": "API OverviewNote: For more information about the ShotGrid API, see our API documentation .The ShotGrid Python Application Programming Interface (API) enables users to easily integrate their tools with ShotGrid. Through it you can create automated processes, integrate with many third party software packages, and communicate with existing tools within your studio. Because the needs of every studio are very different, the ShotGrid API provides powerful, low-level functionality and leaves most of the business logic to you.The API is built using Python , a common programming language used widely across the media and entertainment industry. Use of the ShotGrid Python API is included for free with your ShotGrid site.The API follows the CRUD pattern, allowing your script to run Create, Read, Update, and Delete actions for a single entity type. Many operations include the ability to define filters, columns to return, and sort results.Setting Up Your Environment with the Python API Overview VideoScript KeysIn order to communicate with the ShotGrid server via the API, your script can authenticate with the server either by providing a user’s credentials or by utilizing a script key. You can generate new script keys from the Scripts page, listed in the Admin menu:Tip: Register your scripts separately and have individual API keys for each. This will help you to monitor each of your scripts and the actions they are performing much more accurately in the event logs.Personal Access Tokens (PAT)In addition to script keys, you will also need to set up a Personal Access Token (PAT) in order to communicate with your ShotGrid site. Reference the following video documentation to set this up:  Configure your Personal Access Token (PAT).Common first projectsYou can download the API at https://github.com/shotgunsoftware/python-api . Some common first projects include:  Creating a Version and linking it to a Shot . Allows you to automate the submission of new renders for review.  Uploading a thumbnail . Everything on your site can have an up-to-date thumbnail without manually adding them.  Integrating ShotGrid with your code repository such as SVN . Utilize ShotGrid to project manage any software development.Some things you can’t do with the API  Access or alter permission rules, for security reasons  Read or alter page settings  Access filter or query settings for individual pages or widgets  Interact with the UI  Add, edit, or remove conditional formatting rules  Create or edit query fieldsAction Menu Items (AMIs)If you write a script that you want to easily launch from within the ShotGrid interface, you can do so via AMIs . These are customizable options that appear in context menus you get when right-clicking on a row of data. When clicked, they will send a contextual data dump to a web server or a custom browser protocol handler, where you can then run custom business logic.You can set up different AMIs for different entities, and can restrict access to them by project or by permission group.Event Trigger DaemonEvery action performed in ShotGrid (either by a user or an API script) generates an Event. The Event Daemon can monitor that event stream and then execute specific API scripts based on conditions you define. Some examples include:  Automatically changing downstream Task statuses based on the status of upstream Tasks.  Recalculating relevant cut duration fields when values change.  Performing file packaging and transfer operations when a Shot is set to a particular status.Additional informationFor more information about the ShotGrid API, see these articles:  Download the ShotGrid API from GitHub  ShotGrid API documentation  ShotGrid-dev list (Public)  ShotGrid Event Daemon sample code  Writing event driven triggers  ShotGrid schema  API best practicesContribute and collaborateHave you made some amazing tools with ShotGrid you want to share with the world? Awesome! We have an active and vibrant developer community who love to share and collaborate with each other. To get involved:  Join the ShotGrid Community .  Post your code to GitHub (make sure your code isn’t pipeline specific, is well documented, and has a README in either .txt or .mdk format).  Post a link and description to the dev list. The dev community and ShotGrid developers will check it out, provide feedback, and sing your praises.We are constantly amazed and inspired by many of the tools and integrations made by our clients. Show us what you can do!",
    "url": "/b6636515/",
    "relUrl": "/b6636515/"
  },
  "105": {
    "id": "105",
    "title": "API user permission groups",
    "content": "API user permission groupsYou can create separate Permission Groups for API users so that your scripts and keys can have different permission levels just like your People.Accessing the API user pageGo to your Admin Menu and select Permissions - Scripts.Refer to the  for usage.How to use API user permission groupsOnce you have created API permissions groups beyond the initial API Admin, you can use them for your API scripts.  From the Admin menu, select “Scripts.”  Display the Permission Group column and select the appropriate Permission Group.ExamplesSo why would you use this? There are many potential uses, but here are a couple to get you thinking:Example 1: You want to give an API key to someone in your studio who should not have full Admin privileges.Example 2: You want to give a read-only API key to a partner studio to perform a one-way sync from your  database to their  Database, and only expose a limited entity set.Example 3: You want to restrict API scripts per project.  Navigate to your Permissions - Scripts page via the Admin menu and create a new role. Make sure the “See Assigned Projects Only” advanced permission is enabled. You can also tweak any other permissions needed (e.g. if you only wanted them to have Read access on certain entities/fields).  Navigate to the Scripts page via the Admin menu. Expose the “Projects” field. Here you can enter in Projects to restrict the script’s scope to.  Make sure to assign that script permission to the new one created in step 1, via the “Permission Group” field.",
    "url": "/bbae2ca7/",
    "relUrl": "/bbae2ca7/"
  },
  "106": {
    "id": "106",
    "title": "How do I re-setup a Toolkit project using ShotGrid Desktop?",
    "content": "How do I re-setup a Toolkit project using ShotGrid Desktop?If you’ve already set up a Toolkit configuration for a project and need to start fresh, the Advanced Setup Wizard in ShotGrid Desktop will not allow you to re-setup the project unless you’ve removed the previously setup configuration.Here are the steps for manually removing those settings:  Delete any PipelineConfiguration entities linked to your Project in ShotGrid..  Set the Tank Name field on your Project entity in ShotGrid to a blank value.  Remove any corresponding pipeline configuration directories on disk..  In ShotGrid Desktop select the project you wish to set up. If you were already viewing the project, jump out to the project list view and then back into your project again.  Now you can run the project setup process again.Alternate methodIf you are used to using the command line to set up your project with the  tank setup_project command then you can add a --force argument to the end of the command. This allows you to set up a previously setup project without following the manual steps listed above.tank setup_project --force&quot;",
    "url": "/fb5544b1/",
    "relUrl": "/fb5544b1/"
  },
  "107": {
    "id": "107",
    "title": "Client Responsibilities",
    "content": "Client ResponsibilitiesBelow, we have outlined setup responsibilities between Autodesk and You.Isolation SetupYou are entirely responsible for the validity, security, and execution of the Isolation setup in Your AWS Account. Autodesk should not, under any circumstances, be granted access to Your AWS environment.Autodesk is available during the process for assistance, but the configuration of Isolation features in Your AWS Account is to be executed by You on Your own.Isolation feature set activation requires the ShotGrid Support team’s intervention. Activation delays are to be expected and will depend on demand. You understand that an estimated period of 2-8 weeks is usually required to complete the setup necessary to implement the isolation feature set. The setup time is highly dependent on your cooperation, so please plan to dedicate resources for the setup before beginning the onboarding process.Autodesk does not guarantee any timeline for setup completion.Onboarding            Type      Description / Agreement      Responsibility      Available for Assistance                  AWS Knowledge      Acquiring the AWS-specific knowledge required to set up the isolation features.      You      N/A              S3      Setting up the S3 Bucket that will host Your media Securing access to the S3 Bucket. Additional high-availability measures (versioning, bucket replication, etc.)      You      ShotGrid and *AWS              Closed VPC      Setting up DirectConnect/VPN, etc. to allow closed access to the VPC. Securing the VPC by putting the correct Security Groups in place.      You      *AWS              Media Isolation      Creating the S3 end-points. Deploying the S3 Proxy.      You      ShotGrid and *AWS              Traffic Isolation      Creating VPCs. Creating Subnets.      You      ShotGrid              Monitoring and Reliability      Maintaining uptime up to Autodesk standards. High availability and redundancy of Cloud Services. Metadata and database resiliency and redundancy. Maintaining Recovery Point Objective (RPO) for metadata and database.      ShotGrid      N/A              Service Level Objective      Maintaining ShotGrid target RPO and RTO (See ShotGrid Security White Paper for more details).      ShotGrid      N/A              Security and Governance      Maintaining the ShotGrid Cloud Services that Isolation clients are interfacing with, so that they are meeting expectations in terms of security, vulnerability patching, scanning, auditing, etc. (See ShotGrid Security White Paper for more details).      ShotGrid      N/A      *You are solely responsible to seek or obtain any support services AWS may provide under any existing relationship between You and AWS. Autodesk teams are not parties to Your relationship with AWS and therefore not responsible or liable for any services or lack thereof provided by AWS to You.",
    "url": "/2f59bc69/",
    "relUrl": "/2f59bc69/"
  },
  "108": {
    "id": "108",
    "title": "Exception Review submission failed. Could not render and submit the review associated sequence.",
    "content": "Exception: Review submission failed. Could not render and submit the review associated sequence.Use case:‘Submit for publish’ in Nuke has never worked.Question 1:What’s the best way of navigating up the hereditary stream? I get as far as ‘HookBaseClass’ then am a bit lost.My current problem is getting the submit for review working in Nuke.I’m getting this error in Nuke’s SG publish GUI:Traceback (most recent call last):  File &quot;C: Users STEVE AppData Roaming Shotgun bundle_cache app_store tk-multi-publish2 v2.4.1 python tk_multi_publish2 api plugins publish_plugin_instance.py&quot;, line 282, in _handle_plugin_error    yield  File &quot;C: Users STEVE AppData Roaming Shotgun bundle_cache app_store tk-multi-publish2 v2.4.1 python tk_multi_publish2 api plugins publish_plugin_instance.py&quot;, line 198, in run_publish    self._hook_instance.publish(settings, item)  File &quot;C: Users STEVE AppData Roaming Shotgun bundle_cache app_store tk-nuke v0.12.5 hooks tk-multi-publish2 basic submit_for_review.py&quot;, line 272, in publish    raise Exception(&quot;Review submission failed. Could not render and &quot;Exception: Review submission failed. Could not render and submit the review associated sequence.Also get this exception:'sg_publish_data' was not found in the item's properties. Review Submission for 'path/to/sequences/AB/AB_001/comp/work/images/AB_001_comp_v002_output/AB_001_comp_v002_output.%04d.jpg' failed. This property must be set by a publish plugin that has run before this one.So it’s looking in ‘publish_plugin_instance.py’ for:_handle_plugin_error    yieldrun_publish    self._hook_instance.publish(settings, item)I can find these in my local Appdata folder but not in my main install so I’m assuming that I need to look in ‘submit_for_review.py’ to get at this problem.Looking at this file I can see that its using settings and info for the item from higher up the hereditary chain ‘HookBaseClass’.So looking for where the ‘sg_publish_data’ is set in ‘submit_for_review.py’ I see line 225:sg_publish_data = item.properties.get(&quot;sg_publish_data&quot;)question 2So where upstream is ‘item.properties’ is being set? I suspect in the nuke collector.py but ‘sg_publish_data’ is not present in there and is also a child of the ‘HookBaseClass’How to fixThe Short Answer:Assuming you have not added custom code or modified the config too much, you just need to make sure you have Publish to ShotGrid checked on the item that you are  submitting for reviewThe Long Answer:First, here’s the documentation for the publisher API. Most of the concepts involved in solving this problem are explained there. But here’s the breakdown for your specific problem. Hopefully going through it like this will help you debug future issues as well.In the above screenshot, under the ShorgunWrite1 item you see two plugins. These correspond to plugins that were defined in the config.These plugins are run in order and act on the same item in memory. To get to the bottom of your problem you want to look at the code for these two plugins. You can figure out where those live by looking at the hook settings.For the first plugin since we are looking at the settings for tk-multi-publish2, {self} refers to tk-multi-publish2. Therefore{self}/publish_file.pycan be found under the tk-multi-publish2 app folder:Where the app exists on your file system depends on how app_locations.yml is configured, but if you haven’t changed anything there, you can find the app in your bundle cache folder. Here’s how to find your cache location if you need it.For the second plugin, the hook path is{engine}/tk-multi-publish2/basic/submit_for_review.pyWe are running the tk-nuke engine when in Nuke, so to find this publish hook we need to look under tk-nuke which again should be in your bundle cache.Now that you know where to find the code you can see that the first plugin sets the values that are expected to exist in the second plugin.The idea for the combination of these two plugins is that you are submitting for review something that is published (and will not change). So the workflow is to publish the source files first, then create a SG Version from them for review. The version is linked to the publish as well. the first plugin does the file publish and stores the information in the item for the second publish to use.You mentioned inheritance so I wanted to clarify that as well. I think what you’re coming across in the documentation is referring to hook inheritance that is driven by the config and not a python inheritance as I suspect you think it means.In the python files you’ll see that all the hooks inherit from HookBaseClass. But the hook mechanism in the config allows you to essentially treat these base hooks as mixins and combine them to get all the functionality you need while reusing code. You can see an example of this in the tk-multi-publish2 config:settings.tk-multi-publish2.nuke.shot_step:  collector: &quot;{self}/collector.py:{engine}/tk-multi-publish2/basic/collector.py&quot;The collector defined here does not exist in any python file. It is actually a combination of the tk-multi-publish2’s collector.py and tk-nuke’s collector.py.If the quick fix is not enough for you and you need to modify these hooks, checkout the Customizing Publish Workflows video. It’s a great place to start.See the full thread in the community.",
    "url": "/1d15d7ad/",
    "relUrl": "/1d15d7ad/"
  },
  "109": {
    "id": "109",
    "title": "Review",
    "content": "ReviewLearn to how to get the most out of RV, the award-winning suite of digital review tools that allows you to play back, compare, and convert digital media with collaboration tools and many deep integrations.Dig into RV’s Reference Manuals for a complete understanding of node graphs, custom shaders, event handling, and networking.Check out the RV-SDI manual to learn about our implementation of the NVIDIA SDI video device as a presentation mode device.Look to our Integration Packages for seamless workflows with Maya, Nuke, and even ShotGrid itself.",
    "url": "/61e62b21/",
    "relUrl": "/61e62b21/"
  },
  "110": {
    "id": "110",
    "title": "Could not resolve row id for path!",
    "content": "Could not resolve row id for path!Related error messages:  Could not resolve row id for path!  Database concurrency problems: The path &amp;lt;PATH&amp;gt; is already associated with ShotGrid entity &amp;lt;ENTITY&amp;gt;.Example:A Toolkit user is getting the error “Could not resolve row id for path!” when they create folders.Oddly, this is creating FileSystemLocation entities, but sometimes resulting in duplicates, which can cause a whole host of problems.The full error looks something like:Creating folders, stand by...ERROR: Could not resolve row id for path! Please contact support! trying to resolve path '  server nas_production CLICK 00_CG scenes Animation 01 001'. Source data set: [{'path_cache_row_id': 8711, 'path': '    server  NAS_Production  CLICK  00_CG  scenes  Animation  01  001', 'metadata': {'type': 'ShotGrid_entity', 'name': 'sg_scenenum', 'filters': [{'path': 'sg_sequence', 'values': ['$sequence'], 'relation': 'is'}], 'entity_type': 'Shot'}, 'primary': True, 'entity': {'type': 'Shot', 'id': 1571, 'name': '001_01_001'}}, {'path_cache_row_id': 8712, 'path': '    server  NAS_Production  CLICK  00_CG  scenes  Animation  01  001  Fx', 'metadata': {'type': 'ShotGrid_step', 'name': 'short_name'}, 'primary': True, 'entity': {'type': 'Step', 'id': 6, 'name': 'FX'}}, {'path_cache_row_id': 8713, 'path': '    server  NAS_Production  CLICK  00_CG  scenes  Animation  01  001  Comp',note: it can go on much longer than that.What’s causing the error?This error is pointing to a mismatch between the storage roots as specified in ShotGrid (Site Prefs -&amp;gt; File Management) and config/core/roots.yml in the Pipeline Configuration.It often comes up because of a case mismatch in studios running Windows. Their paths are case-insensitive, but our configs are case-sensitive. A difference as simple as E: Projects vs E: projects can cause this error.What’s happening behind the scenes?The code creates the FilesystemLocation entity in ShotGrid for the path it just created, using ShotGrid’s storage roots to determine the root for the path. Then, it goes to create the same entry in the local cache, and has to determine where to put it in the database. For the local cache, it uses roots.yml to determine the root for the path, and because of the case mismatch, the path it generates doesn’t match what was just entered in ShotGrid. At this point, it throws the error.It’s especially bad because it doesn’t error cleanly: the folders are created, the FilesystemLocation entries are created, they are not synced in the local path cache, nor will they ever be able to be synced because of the storage root mismatch.How to fixFirst, make sure the storage root paths in the Site Prefs match the paths in config/core/roots.yml. Fixing the mismatch should make the error go away in subsequent folder creation calls.Then, clear the bad FilesystemLocation entities. If you can narrow down to a set of errant FilesystemLocation entities, just remove those. In a lot of cases though, all of the paths for a project are compromised, so they all need to go.  How to clear the FilesystemLocation entities: ideally you can run tank unregister_folders. To clear all of them, run tank unregister_folders --all. (For all the options for tank unregister_folders, just run it with no arguments and it will output usage notes.)  However, because the db is already in a wonky state, this may not work, or may only partially work. Once you’ve run the command, go back to FilesystemLocations in ShotGrid, and confirm that what you expected to be deleted is actually gone. If not, select the bad entities, and move them to trash manually.At this point, the FilesystemLocations in ShotGrid are clean, but artists’ local caches may not reflect your changes. The last step is to actually sync the local cache on each user’s machine. To do this, they should run tank synchronize_folders --full.Once all those steps are taken, the path cache should be in a good state, and that errors shouldn’t appear anymore.Related links  Here’s the code in question  What is the path cache? What are Filesystem Locations?See the full thread in the community.",
    "url": "/da6b219a/",
    "relUrl": "/da6b219a/"
  },
  "111": {
    "id": "111",
    "title": "RV Developer Overview",
    "content": "RV Developer OverviewRV Core ReferenceUser ManualThe User Manual includes introductory material to get you started with RV and RVIO as well as complete command-line and GUI usage. In addition, you’ll find installation notes and tips on maximizing performance as well as in-depth information on LUTs, the RV pixel pipeline, stereoscopic 3D, expanding RV with Packages, networking with RV and the RVLS media listing utility.  RV User Manual  Questions &amp;amp; Troubleshooting ForumTechnical Reference ManualThe Reference Manual is the starting place for learning how to customize RV. It contains an overview of RV’s package system and Mu scripting capabilities. It is the place to start if you want to change hot keys, add menus, customize color management, create new widgets or integrate RV with your pipeline.  Technical Reference Manual  Extending RV ForumRV-SDI ManualThis manual describes Tweak’s implementation of the NVIDIA SDI video device as a presentation mode device. For more information on presentation mode and how it relates to RV in general see the RV User Manual. To use RV-SDI, you must run the “rv” (or “rv.exe”) executable, and have an “rvsdi” license.  RV-SDI ManualRV IntegrationRV / Nuke IntegrationRV now comes with Nuke integration tools. This document describes installation for an individual or system wide setup and describes the workflow, tools, concepts and usage for RV/Nuke.  RV-Nuke Integration DocumentationRV / Maya IntegrationRV now comes with Maya integration. This document explains how to install the RV/Maya Package and describes the RV/Maya workflow and how to compare and organize playblasts and how to render into edits, A/B comparisons, and layouts.  RV-Maya Integration DocumentationConfiguring software launchesNewer versions of RV need an additional configuration within the software_paths.yml file. The software_paths.yml file is available when you have taken over your configuration. Ensure that your reflects the following paths for RV to launch, with your specific path, version, and application information added:# RVpath.linux.rv: &quot;rv&quot;path.mac.rv: &quot;/Applications/RV.app&quot;path.windows.rv: C: Program Files Shotgun RV-7.9.0 bin rv.exeSee this software_paths.yml file for reference.",
    "url": "/7e1071f0/",
    "relUrl": "/7e1071f0/"
  },
  "112": {
    "id": "112",
    "title": "S3",
    "content": "S3Amazon S3 is an object storage service offered by AWS. It can be thought of as a highly durable storage space in the cloud. ShotGrid uses S3 to store uploaded media and files.In order to use ShotGrid isolation features, you will bring your own S3 bucket and configure ShotGrid to use it for storage. Please refer to our S3 Bucket Setup article for details on how to do this.",
    "url": "/dfc0cc1b/",
    "relUrl": "/dfc0cc1b/"
  },
  "113": {
    "id": "113",
    "title": "Media Isolation",
    "content": "Media Isolation                    Disclaimer: The security of your S3 bucket is solely a client responsibility, and the integrity of your data will be at risk without it. We very strongly recommend securing your S3 bucket properly.    AWS Account CreationYou can quickly create your AWS Account.You should also contact your AWS contacts to get help with your AWS account setup.AWS CloudFormation templateIt’s possible to start from the Private S3 bucket AWS CloudFormation template and customize it for your needs for a faster deployment.                    Disclaimer: This template is provided as an example only. It is your responsibility to validate that running the template will result in the configuration/policy/security settings your studio requires.      Go the CloudFormation service in AWS Console  Select Template is ready  Set Amazon S3 URL to https://sg-shotgunsoftware.s3-us-west-2.amazonaws.com/tier1/cloudformation_templates/sg-private-s3-bucket.yml  Next  Set a stack name like ShotGrid-s3-bucket  Set your S3 bucket name and your ShotGrid site name  Next  Accept I acknowledge that AWS CloudFormation might create IAM resources  NextCORS ConfigurationCORS policy on your S3 bucket will be minimally configured, allowing only the required origin (your site) and methods, amongst other things.IAM RoleThe template will create an AWS Role with the following permissions on your bucket:  Allow ShotGrid to access your S3 bucket.  Allow the ShotGrid account to assume the role by setting the role Trust Relationship.Media Isolation ActivationPlease contact ShotGrid support via the dedicated Microsoft Teams channel and provide the following information:  ShotGrid IAM Role ARNShotGrid will allow your site to use your IAM role.Media Configuration SetupNavigate to your site’s site preferences and under the Isolation section, fill in the S3 Configuration preference with the following JSON:{​​​​​​​   &quot;&amp;lt;S3_CONFIG_NAME&amp;gt;&quot;: {​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​}​​Fields description            Field      Description                  S3_CONFIG_NAME      Unique name for the configuration. This will be selectable as a bucket later on.              BUCKET_REGION      Isolation bucket’s region              BUCKET_NAME      Isolation bucket’s name              BUCKET_PREFIX      The S3 prefix where the media is located on the isolation bucket              ROLE_ARN      AWS Role ARN that ShotGrid can use to access the bucket. This must be the same role specified in the Initial Setup              S3_INTERFACE_VPC_ENDPOINT      Optional - This is only needed if Media Traffic Isolation is utilized.      Testing Media ConfigurationAfter the configuration has been updated on your site, navigate to the /admin/speedtest route of your ShotGrid site. Select the new S3_CONFIG_NAME that was just set up previously and start the test to confirm that all the upload/download tests work as intended.Next StepsSee Media Traffic Isolation to activate the Media Traffic Isolation feature.See Media Replication to activate the Media Replication Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/439f0627/",
    "relUrl": "/439f0627/"
  },
  "114": {
    "id": "114",
    "title": "Media Replication",
    "content": "Media ReplicationDescriptionIt’s possible to add S3 replication between two S3 buckets in different regions and configure ShotGrid to leverage it for faster access to media.Features  Support one replica bucket in another region leveraging the AWS S3 replication featureHow it worksWhen S3 bucket replication is activated, users will be able download media files from the replica S3 bucket.For each user, the S3 replication is activated by the Use S3 Replication field.            Value      Behavior                  no      Never use replica S3 bucket (default)              yes      Use replica S3 bucket when delay is over              auto      Use replica S3 bucket when delay is over and the client IP is in IP Adresses for S3 replication range      The IP Adresses for S3 replication preference can be edited in Site Preferences under the Isolation category.Limitations  Only one replica S3 bucket can be configured  Only downloading from the replica bucket is supported  Configurable delay for new media to be replicated before being made available to usersSetup steps  Create the replica S3 bucket in a new AWS region. See Media Isolation  Update your existing ShotGrid role policy to allow ShotGrid to also access the replica bucket  Setup the replication rules on the primary S3 bucket. See How do I add a replication rule to an S3 bucket?  Setup a VPC + Direct Connect + S3 proxy in the new AWS region if needed. See Media Traffic IsolationConfigure your siteTo configure S3 replication, you will need to add an additional entry to the “S3 Configuration” site preference.The complete entry may look something like the following:{​​​​​​​​   &quot;&amp;lt;S3_CONFIG_NAME&amp;gt;&quot;: {​​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;,     &quot;s3_interface_vpc_endpoint_dns_name&quot;: &quot;&amp;lt;S3_INTERFACE_VPC_ENDPOINT&amp;gt;&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​,   &quot;&amp;lt;S3_CONFIG_NAME_REPLICA&amp;gt;&quot;: {​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​     &quot;region&quot;: &quot;&amp;lt;BUCKET_REGION_REPLICA&amp;gt;&quot;,     &quot;bucket&quot;: &quot;&amp;lt;BUCKET_NAME_REPLICA&amp;gt;&quot;,     &quot;prefix&quot;: &quot;&amp;lt;BUCKET_PREFIX_REPLICA&amp;gt;&quot;,     &quot;aws_role_arn&quot;: &quot;&amp;lt;ROLE_ARN&amp;gt;&quot;,     &quot;s3_interface_vpc_endpoint_dns_name&quot;: &quot;&amp;lt;S3_INTERFACE_VPC_ENDPOINT_REPLICA&amp;gt;&quot;   }​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​After the configuration has been updated on your site, navigate to the /admin/speedtest route of your ShotGrid site. Select the new S3_CONFIG_NAME_REPLICA and start the test to confirm that all the upload/download tests work as intended.Update the following Site Preferences:  S3 Bucket for Replication - This should have the same value as S3_CONFIG_NAME_REPLICA from the S3 Configuration  S3 Replication Delay - Set this to something reasonable such as 60 seconds.FAQCopy existing mediaS3 replication only applies to media uploaded after the feature has been enabled. Existing media in the primary bucket must be copied to the replica bucket manually. You can simply use aws-cli sync or use Amazon S3 Batch Operations if you have a lot of media to achieve this.Next StepsSee Fine Tuning to finalize your setup and optimize costs and security.Go to Setup for an overview of the possible next steps.",
    "url": "/44623c83/",
    "relUrl": "/44623c83/"
  },
  "115": {
    "id": "115",
    "title": "Integrations User Guide",
    "content": "Integrations user guideIn this guide:  Introduction  Getting started with Desktop          Installation of Desktop                  Installing a newer version of Desktop                    Logging in when self hosted or behind a proxy server                  Authentication and browser integration                    The system tray      The project browser      The command launcher      The console        Launching applications  The Panel          Overview      UI details                  The activity stream          Creating and replying to Notes          Notes, Versions, Publishes, and Tasks          The info tab          Searching          Actions          The current work area and the me area          Current Work Area                      The Publisher          Overview      Interface components and concepts      Basic workflow                  Publishing within content creation software          Publish items and tasks                          Context              Validation              Multi-document workflows                                Stand-alone publishing          Publish types                          Standalone              3ds Max              Houdini              Maya              Nuke              Nuke Studio              Photoshop CC                                            The Loader          Overview      The tree view      Navigation      Looking at publishes      Bringing one or multiple publishes into your scene      Working with older publishes      Associated review        Advanced functionality  AcknowledgmentsIntroductionShotGrid integrations bring ShotGrid into your content creation tools. When you use ShotGrid’s integrations, you’ll be able to easily launch your software, use the Panel to track notes and data ShotGrid has about your tasks, and use the Publisher and Loader to track files and bring them into your scene. Artists will have access to all the ShotGrid data about their Tasks, and all Tasks on their Project, from right within the app. They can reply to Notes, playback Versions, publish files, and load in their colleagues’ published files.For the latest updates to ShotGrid integrations, please subscribe to the release notes.Getting started with DesktopThe ShotGrid Desktop app sits at the heart of our integrations. It is a software application that extends the ShotGrid experience onto your local machine, and makes it easy to access ShotGrid data, launch applications, and run pipeline integration tools directly from your machine.Running Toolkit Classic or a Custom Setup?The ShotGrid Integrations install automatically. If you are an advanced client wanting to install the Classic Toolkit configuration or you have a Custom Toolkit setup that you want to install via the Desktop Setup Wizard , please head over to the administrator’s guide to learn how to do this.Installation of DesktopYou can download ShotGrid Desktop under the Apps menu.Follow the prompts and choose whether to download Desktop for Mac, Windows, or Linux.Installing a newer version of DesktopYou can update ShotGrid Desktop on all supported operating systems without uninstalling you current version. However, ensure that you close your existing session prior to updating your ShotGrid Desktop version.Note: on Windows, if Desktop is running while updating the version, a binary lock will interfere with the install and cause the installer to stop. This will result in an incomplete installation since some files have already been copied. To fix this, exit Desktop and select “retry”.Logging in when self hosted or behind a proxy serverNote: the following content regarding logging in is intended if you are self hosted or using a proxy server. This is not the defaut behavior.If you are self hosted or using a proxy server, the first time you open Desktop, you’ll be prompted by your browser about certificates. We do this in order to connect ShotGrid with the Desktop app. If you’re having trouble getting certificates set up, take a look at our troubleshooting docs for Firefox and Chrome and other browsers .You will only need to update your security certificate list once. Please note that only Mac and Windows show a prompt for certificates, not Linux.Once that’s set up, you’ll need to log in to your ShotGrid site.If you go through a proxy, you will have to do some additional configuration. See instructions on how to do that in our Admin Guide .Authentication and browser integrationDesktop provides services that allow the ShotGrid web application to interact with your computer. This enables features like local file linking and software launching. For security reasons, you must be logged into Desktop as the same user on the same ShotGrid site as you are in the browser. If you are logged in as a different user or on a different site, Desktop will prompt you to switch accounts and if you do it will restart and prompt for the appropriate credentials.The system trayWhen the application starts it shows up as an icon in your system tray. To show the window, click the icon. By default, the window will be pinned to the system tray, which means that if the window loses focus, it will automatically hide itself.You can unpin the window by selecting “Undock from Menu” from the user menu or by dragging it by its header. When the window is unpinned it will look like a regular window and will no longer hide itself when it loses focus.While the window is undocked, you can hide it by clicking on the close button. To show it again, click on the system tray icon.The project browserThe first main view of the app is the project browser. Here you will see all the projects in your ShotGrid instance. Your most recently accessed projects will be listed first.Near the bottom right of the window you will see your ShotGrid account’s thumbnail. This is the user menu, where you can do things like dock and undock the window, keep it on top of other windows, and show the logging console.At the top of the window, you can click on the magnifying glass icon to show the search box. Typing in this box will filter the list of projects shown to just those that contain the letters you are typing.Clicking on a project will take you to the command launcher view for that project, where you can launch the tools that are available for the project.The command launcherOnce you have selected a project, you are taken to the command launcher for that project. This window will show whatever tools and applications are available for the project as a grid of buttons. Simply click on a button to launch its application. It will run in a project-specific environment, and if ShotGrid has an integration for it, you’ll see a ShotGrid menu with all of the available tools.The consoleYou can launch the console from the user menu. The logs from launching a project are displayed here. If you run into an error, the details of the error should be shown here.If you right-click on the console, you are given a standard edit menu, allowing you to select all of the text, copy your selection, or to clear the text in the console.Launching applicationsWhen you launch ShotGrid Desktop and choose a project, it scans the standard applications directory for your operating system. Desktop will display launchers for any applications that we have integrations for . If you have more than one version of the same software, the launcher will have a dropdown list with all available versions. Clicking on the launcher icon itself will launch the latest version.You can launch applications like Maya and Nuke straight from ShotGrid Desktop, or you can launch them directly from ShotGrid. Either way, ShotGrid’s integrations will be available from within your application.It’s normal for a studio to need additional configuration other than what comes out-of-the-box. Your studio may have software in a non-standard location or in-house engines for software we don’t support natively. It’s easy to configure these cases from right within the ShotGrid web app. See the Admin Guide for details.If you’re not seeing an app you expect to see, take a look at the Configuring the software in ShotGrid Desktop section of our Admin Guide .The PanelOverviewUpon launching an application from Desktop or ShotGrid, the ShotGrid Panel will appear. The ShotGrid Panel is a small and lightweight version of ShotGrid which runs directly inside artist applications such as Maya and Nuke. The Panel lets you quickly access ShotGrid information without leaving the application you’re working in. It provides easy access to information about your current task, and you have instant access to the activity stream, Notes, Tasks, Versions, and Publishes from ShotGrid. You can play back Versions sent to review by other members of your team, reply to Notes, create new Tasks, and search your ShotGrid site.UI detailsThe ShotGrid panel consists of a couple of main UI elements. On top you’ll find a toolbar with buttons for navigation and searching. Right below the toolbar you have the details area which displays information about the item you are currently viewing. This details area is configurable, so if you want to display custom fields or have data that is extra important in your pipeline, it is easy to make it appear here. Lastly, you find a number of Content tabs . These all display listings of ShotGrid data and make it easy to navigate around in the ShotGrid Panel to quickly browse things like publishes, review Versions, or see who is assigned to the Tasks linked to your current focus.In applications where the integration supports docking, the ShotGrid Panel will appear seamlessly docked inside the UI. In other applications, it will be displayed as a normal window.Below is a brief overview of the different tabs and features available in the ShotGrid Panel.The activity streamThe activity stream works just like the activity stream in ShotGrid—it shows you all the things happening in and around the object you are looking at:  users creating Notes,  Versions being submitted for review, and  publishes being created by the pipeline.You can add new Notes directly from the activity stream and also reply to existing Notes. Attachments will show up automatically, and clicking them will show a large preview.Please note that after uploading a file, you may see a placeholder icon. Manually refresh the panel to display the final thumbnail, once it becomes available.Creating and replying to NotesCreating or replying to a Note is easy with the ShotGrid Panel. Simply navigate to an activity stream or Note details page and click either create note or reply to note . A dialog will appear where you can type in the Note text. You can use @name notation if you want to send the Note to a specific person—this will add that person to the TO field of the Note automatically.Notes, Versions, Publishes, and TasksThe Notes, Versions, publishes, and Tasks tabs all work the same way—by displaying data associated with the current item you are seeing. You can double click an item to focus on that item. Once you have navigated to a Publish , you can view the dependencies for that publish. This is useful if your pipeline is tracking dependency information and gives you instant access to how your assets are interconnected.The info tabIf you cannot find what you are looking for in the other tabs, try navigating to the info tab. This holds most of the ShotGrid fields for your focused entity and you can click on the blue hyperlinks in order to navigate around to other ShotGrid locations.SearchingIf you want to quickly navigate to another location or object in ShotGrid, you can use the built-in search. This is similar to the global search in the ShotGrid web application. Just start typing the name or description of what you are looking for. Once you have typed in three or more characters, you will see results displayed.ActionsYou can also use the ShotGrid Panel to use ShotGrid data to run operations in your scene. Similar to the Loader, the Panel has an actions system that makes it easy to register snippets of code to be triggered by a menu on an item in the browser. You can access actions from the detail area as well as from the listings. The actions button in the details area also contains some handy built-in functions to quickly jump to ShotGrid and to refresh your current view.The current work area and the me areaThe icon on the top left navigates you to your current work area. This is typically the Task that you are currently working on and is a quick way to get access to Notes, and review Versions and other information relevant to what you are currently working on. This is also the location that the ShotGrid Panel always starts focused on.On the top right you will find a button displaying the current user’s thumbnail. This button will take you to a page which displays information associated with the current user. This includes  All the publishes and Versions you have submitted  Tasks that are assigned to you  All note conversations where you are either participating or where the Note is relevant to you—e.g., Notes that are associated with Tasks that you are assigned to.Current Work AreaWhen you start working on a Task, you can use the Panel to set your Current Work Area. Then, when you publish your work, it will be associated with your current Task in ShotGrid.The PublisherOverviewThe Publish app allows artists to publish their work so that it can be used by artists downstream. It supports traditional publishing workflows within the artist’s content creation software as well as stand-alone publishing of any file on disk. When working in content creation software and using the basic ShotGrid integration, the app will automatically discover and display items for the artist to publish. For more sophisticated production needs, studios can write custom publish plugins to drive artist workflows.The following sections cover the publisher UI and basic integration workflows. For information about customizing the publisher for your studio-specific needs, please see the Publisher Dev Guide .Interface components and conceptsDrag and drop files from anywhere on your local filesystem. Use the browse button to open a file browser to select one or more files to publish.The tree of items on the left show what will be published. The top level items can include subitems that are related, such as renders or caches generated from within the work file. Under each item is one or more publish tasks, which represent the actions to be performed at publish time.Items themselves are grouped under context headers that indicate the ShotGrid context that the published file will be associated with.When there is more than one top-level item, a summary item will be present which provides an overall look at the items to publish and actions that will be executed.When an item is selected, the right side of the interface will show the item’s details. This includes the destination context as well as a thumbnail and description for the publish. A summary will also be included for the item and any subitems.At the bottom of the interface, there are a series of tool buttons on the left. These buttons are:  Browse : Browse for files to publish  Refresh : Refresh the publish item list  Delete : Remove the selected items from the list  Expand : Expand all items in the list  Collapse : Collapse all items in the list  Documentation : Open the workflow documentationIn the middle is a status label. This will update as the Publisher performs validation and executes the publish tasks. When clicked, you will see the progress detail overlay.To the far right are the Validate and Publish buttons. The Validate button will execute an initial validation pass on all items and tasks to ensure they are in a publishable state. The Publish button will initiate the publishing of items in the list.The progress details overlay shows the output of collection, validation, and publishing of items in the list.A Copy to Clipboard button makes it easy for users to share publish logs. When validation or publish errors occur, the log messages may include an action button that will guide the user toward additional information and, in some cases, an immediate fix.Basic workflowThe purpose of the Publish app is to allow an artist to make their work available for other artists to use. In ShotGrid, publishing a file means creating a record in ShotGrid with information about the file being published, including the path, version number, artist info, related ShotGrid context, etc. Once the file is tracked in ShotGrid, other users can make use of it via the Loader app.The basic ShotGrid integration provides two ways to use the Publish app in your pipeline: standalone publishing and publishing within content creation software. The following sections outline the workflows for each of these scenarios.Publishing within content creation softwareThe basic ShotGrid integrations include publishing workflow support for content creation software including 3dsMax, Houdini, Maya, Nuke, Nuke Studio, and Photoshop. When the Publisher is launched with the content creation software, it will automatically attempt to find items to publish. While the items that are presented for publishing will differ slightly based on the software and the contents of the artist’s work file, the same basic publish concepts apply. Here is an example of publishing within Nuke:Publish items and tasksHere you can see the publish items that have been collected on the left hand side. There are three publish items: the selected item is the work file itself with two child items below it. Additionally, there is an image file sequence and an Alembic cache. These items each have a Publish to ShotGrid publish task attached that, when executed, will handle creating the publish entry in ShotGrid in order to keep track of the individual files or image sequences.The parent item representing the Nuke Script has a Begin file versioning plugin attached. This plugin will appear when the work file does not have a version number in the path. If checked, this task will insert a version number into the file name prior to publishing. In this case, the file would be renamed from bunny_010_0010.nk to bunny_010_0010.v001.nk . This encourages keeping a history of the artist work file. The task is not checked by default and is not required to run. If the item is published with the task enabled, the next time the work file is published, since it will have a version number in the file name, the task will not show up.The publish tasks can be turned on or off as desired. The check box on an item reflects and controls the check state of its subtasks. For example, unchecking an item will uncheck all of its tasks. Unchecking one of multiple tasks will put the item into a semi-checked state. To toggle the check state of all tasks of a certain type (all Publish to ShotGrid tasks for example), simply hold the Shift key when checking the box.Selecting a publish task will show information about what the task does.ContextAbove the Nuke Script item, you can see the name of the context that the published items will be associated with in ShotGrid. This can be modified by changing the Task and/or Link fields on the right side of the interface. If multiple items are being published, they may show up under different contexts. The icon with three horizontal lines on the left of the publish items is a drag handle for moving items from one context to another.A menu dropdown button is also provided next to the Task entry field. This menu can show several groups of Tasks that you might be interested in. It will show any tasks assigned to the current user, tasks related to the current context (such as other tasks assigned to the same Shot), and any recently browsed tasks.To search for a task or entity link, simply click on one of the fields or click the search icon and begin typing the name of the context you’re interested in. The fields will show matching tasks or entity links and you can click or navigate to the desired context.For each publish item, you can click the camera icon to select a portion of the screen to use as the thumbnail for the Publish in ShotGrid. For scenarios where there are child items, they will inherit the thumbnail from the parent by default. You can override the child item’s thumbnail by selecting the child and clicking its thumbnail.The description entered will be included in the Publish data in ShotGrid. Like the thumbnail, the description is inherited from parent items but can be overridden by entering a new description in the child’s detail entry.ValidationOnce the items are ready to be published, you can click the Validate button to ensure the state of the file and the publish items will allow the publish to complete as expected.If all items validate properly, you should see green checkmarks on the right. For any items that do not validate, you will see a warning icon.The status will also be displayed in the status label area at the bottom of the publisher.Clicking on the icon in the item or the status label will open the progress details overlay and highlight the validation issue.In the example above, the Nuke script has not been saved. In some scenarios, an action button will be provided to quickly direct you to the fix for the issue or to get more information about the issue. Here you can see a Save As… action button that will open the Nuke save dialog.Once the validation issues have been corrected, you can close the progress details overlay to return to the publish item view. Validation can be run as many times as required while addressing publish task warnings or errors.When the Publish button is pushed, the app will walk through the items and tasks in the list, run another validation pass on each, and then execute the publish logic to create entries in ShotGrid, upload thumbnails, bump the work file version, etc. A finalize pass is also executed to summarize publish for each item and do any cleanup work necessary.The results of the entire process can be reviewed afterward by clicking the status label at the bottom of the publisher to show the progress details overlay. You can also leave the progress details view on while publishing to see the output as the publish occurs. You can see additional action buttons, shown here, to quickly jump to the newly created publish entry in ShotGrid.Multi-document workflowsFor multi-document workflows in content creation software such as Photoshop or Nuke Studio, multiple top-level items will be displayed in the publish item list.Only the current/active document will be expanded and checked. To check all documents to publish, simply hold Shift and click one of the unchecked item’s check box. To expand the collapsed items, use the expand button in the toolbar at the bottom.When there are multiple top-level items, a summary item is also included at the top of the list.Selecting this item will show a complete summary of all items selected for publishing. Above you can see four items with a total of eight tasks to execute in four different contexts. You can override the context and description for all items in this view if you desire.You can also see an Upload for review task in the image above. This task is not limited to the Photoshop workflow. It will be available for any file type that can be transcoded and uploaded to ShotGrid as reviewable media.Stand-alone publishingThe Publish app is not required to be run from within content creation software.Here you can see the publisher can be launched directly from ShotGrid Desktop. When launched in standalone mode, you will be presented with an area to browse or drag and drop files.Clicking the browse button will open a standard file browser where you can select the files you would like to publish.Once you have selected files from the browser or dragged and dropped them from somewhere on your file system, the app will show them as top-level items for publish.As with the previous examples, you can select the context for each item, set the description, and identify which task should execute when publishing.Publish typesThe following sections describe the automatically collected publish types for each of the basic ShotGrid integrations.StandaloneThe standalone workflow does not automatically collect files for publishing. Users must drag file paths into the interface or browse to them in order to publish. The publisher will accept browsed or dropped files at any point prior to the Publish button being clicked. The basic integration will accept any file extension using known file types to associate with ShotGrid publish types. If the file extension is not recognized, the mimetype of the file will be used. Recognized image and video mimetypes will be publishable and have a task attached to upload for review.The basic integration assumes that folders dropped contain image sequences. Any recognized image sequences found in the folder will be presented as items for publishing. If no sequences are found, no items will be created for publish.3ds MaxThe current Max session will be collected for publishing with a publish type of 3dsmax Scene which can be merged or referenced into another Max session via the Loader.If a project folder can be determined for the current session, any files found in the project’s export folder will be presented for publish. Similarly, any movie files found in the project’s preview folder will be publishable.HoudiniThe current Houdini session will be collected for publishing with a publish type of Houdini Scene which can be merged into another Houdini session via the Loader.Any files written to disk from nodes of the following types will also be automatically collected and presented as publish items:  alembic  comp  ifd  opengl  wrenMayaThe current Maya session will be collected for publishing with a publish type of Maya Scene which can be imported or referenced into another Maya session via the Loader.If a project root can be determined for the current session, any Alembic files found in the project’s cache/Alembic folder will be presented for publish. Similarly, any movie files found in the project’s movies folder will be publishable.NukeThe current Nuke session will be collected for publishing with a publish type of Nuke Script which can be imported into another Nuke session or opened as a new session via the Loader.Any files written to disk from nodes of the following types will also be automatically collected presented as publish items:  Write  WriteGeoNuke StudioAny open Nuke Studio projects will be collected for publishing with a publish type of NukeStudio Project which can be opened as a new project via the Loader in another Nuke Studio session.Photoshop CCAny open Photoshop documents will be collected for publishing with a publish type of Photoshop Image which can be loaded as a new layer or opened as a new document via the Loader in another Photoshop session.The LoaderThe ShotGrid Loader lets you quickly overview and browse the files that you have published to ShotGrid. A searchable tree view navigation system makes it easy to quickly get to the Task, Shot or Asset that you are looking for and once there, the Loader shows a thumbnail based overview of all the publishes for that item. Through configurable hooks you can then easily reference or import a publish into your current scene.Publishes are records in ShotGrid, each representing a file on disk or a sequence of files (like a sequence of images, for example). Publishes can be created by any application, but are typically created by the Publisher.Once the publishes have been created, they can be loaded in by other people in the pipeline. This is where the loader comes in. The loader will let you browse the publishes stored inside ShotGrid in a way which is reminiscent of a file system browser.OverviewThe Loader app lets you quickly browse files that have been published to ShotGrid. The app has a searchable tree view navigation system that makes it easy to see a thumbnail of a Task, Shot, or Asset.The tree viewUse the tree view on the left to quickly locate the Shot, Asset, or Task that you are looking for. If you know the name of the item you are looking for, you can type it into the search area and only items matching your search phrase will be shown in the tree.As soon as you start typing, a blue bar will be shown around the tree, indicating that you are no longer viewing the full tree, but a subset of the items in the tree, based on your search phrase. All nodes in the tree will be automatically expanded as you start searching. For convenience, if you right click the tree, you’ll find options to expand or collapse all nodes in the tree.NavigationOn top of the tree view, you’ll find three navigation buttons.If you click the home button, the loader will automatically navigate to the Shot or Asset representing your current work area. This is handy if you want to quickly load something that relates to the work you are currently doing. On startup, this is also the location the Loader will show by default. When you select different items in the tree view, a history is built up over time. This can be navigated using the back and forward buttons, just like a browser.Looking at publishesOnce you select an item in the tree, the available publishes will be shown in the publish area in the middle of the UI. Each item in this view represents the most recent item in a stream of publishes, so you may for example see version 15 of a texture, meaning that there are 14 previous versions in the version history for that item.In addition to publishes, you will also see folder icons representing Shots, Sequences, Assets or other ShotGrid entity types. If there is a thumbnail for an object, you will see it overlaid on top of the folder to make navigation quick and visual. Double clicking on a folder will navigate down into that folder in the hierarchy.There are two viewing modes. The thumbnail mode is great when you are visually browsing, for example looking for a texture. You can quickly eyeball the list and use the zoom handle to zoom in and out quickly.If you are browsing something less visual than textures, for example Nuke scripts or Maya files, you can use the list view instead of the thumbnail view. This mode provides you with some more information and is also more compact, allowing you to quickly scroll through lots of items.If you only want to view items of a certain type, you can use the filter panel on the bottom left to quickly hide or show publishes. You’ll also see a summary next to each type in the list, indicating how many publishes of each type was found for the currently selected tree item.Bringing one or multiple publishes into your sceneIf you want to bring an item into your scene, simply double click it and the Loader will execute the default action for the publish. There may be more than one way to add an item to your scene (for example in Maya you may want to either reference or import another Maya file into your scene). In this case, click the actions dropdown menu or right click anywhere on the publish to see all available options.If you want to bring multiple items into your scene, select multiple elements and right-click any item in the selection to show the actions pop-up menu. Note that only the actions that can be applied on every item in the selection will be shown.If you select a Shot or Asset Folder object instead of a publish, there will be options to show that item in ShotGrid or in the File system.Working with older publishesIf you open up the right hand side detail pane, you will see all the version history for your selected publish. This makes it possible to load in an older version. If this is desirable, simply select it in the version history and use its action menu to load it in, just like the publishes in the main view.Associated reviewIf a publish has an associated review version, you will see a play button appearing in the detail pane. Clicking this will launch Screening Room in a web page, allowing you to quickly see or add notes to the version, as well as playing back the associated review Quicktime.Advanced functionalityAll of ShotGrid’s integrations are built on top of a highly customizable and extensible platform for building pipelines called Toolkit. For more information on how to access and configure this functionality, see our Admin Guide .Acknowledgments  A bug fix version of PySide is distributed with ShotGrid Desktop and is available here .  Big Buck Bunny - footage courtesy of (CC) Blender Foundation, www.blender.orgTell the doc gen system that we don’t want a header by adding this special markup: TANK_NO_HEADER",
    "url": "/d587be80/",
    "relUrl": "/d587be80/"
  },
  "116": {
    "id": "116",
    "title": "Setting Python 2 for Desktop",
    "content": "Set Python 2 as the default Python version in ShotGrid Desktop                    Warning: This topic is only valid when using ShotGrid Desktop version 1.7.3—these steps are no longer needed when using newer versions of ShotGrid Desktop. Python 2 was removed January 26, 2023 with the release of ShotGrid Desktop 1.8.0 due to security reasons. Learn more here.      Windows  MacOS  CentOS 7WindowsManually Set the SHOTGUN_PYTHON_VERSION environment to 2 on Windows  On the Windows taskbar, right-click the Windows icon and select System, navigate through the Control Panel/System and Security/System.  Once there, select Advanced system settings.  Next, select Environment Variables in System Properties.  In the Environment Variables window, you can add/edit your paths by selecting New….  For the Variable name, add SHOTGUN_PYTHON_VERSION, and set the Variable value to 2.  Restart the ShotGrid Desktop application. Now, you should see that the Python version has been updated to run Python 2.MacOSSet the SHOTGUN_PYTHON_VERSION environment to 2 on MacOS  Create a properties file under ~/Library/LaunchAgents/ named my.startup.plist$ vi my.startup.plist  Add the following to my.startup.plist and save:&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;https://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt; &amp;lt;plist version=&quot;1.0&quot;&amp;gt; &amp;lt;dict&amp;gt;   &amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;   &amp;lt;string&amp;gt;my.startup&amp;lt;/string&amp;gt;   &amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt;   &amp;lt;array&amp;gt;     &amp;lt;string&amp;gt;sh&amp;lt;/string&amp;gt;     &amp;lt;string&amp;gt;-c&amp;lt;/string&amp;gt;     &amp;lt;string&amp;gt;launchctl setenv SHOTGUN_PYTHON_VERSION 2&amp;lt;/string&amp;gt;   &amp;lt;/array&amp;gt;   &amp;lt;key&amp;gt;RunAtLoad&amp;lt;/key&amp;gt;   &amp;lt;true/&amp;gt; &amp;lt;/dict&amp;gt; &amp;lt;/plist&amp;gt;      After rebooting your Mac, the new environment variable will remain active.        Restart the ShotGrid Desktop application. Now, you should see that the Python version has been updated to run Python 2.  CentOS 7Set the SHOTGUN_PYTHON_VERSION environment to 2 on CentOS 7  Add the following to your ~/.bashrc file:export SHOTGUN_PYTHON_VERSION=&quot;2&quot;  Reboot your OS by running:$ sudo reboot   Restart the ShotGrid Desktop application. Now, you should see that the Python version has been updated to run Python 2.",
    "url": "/69833488/",
    "relUrl": "/69833488/"
  },
  "117": {
    "id": "117",
    "title": "How do I set environment variables before launching software?",
    "content": "How do I set environment variables before launching software?ShotGrid Toolkit allows you to use hooks during the launch process to configure the environment and run custom code.When you launch software, for example Nuke or Maya, via ShotGrid Desktop or through the browser integration, the tk-multi-launchapp will be run.This app is responsible for launching the software and ensuring the ShotGrid integrations start up as expected. There are two points during this process that are exposed via hooks to allow custom code to be run.before_app_launch.pyThe before_app_launch.py hook is called just before the software is launched. This provides a perfect opportunity to set any custom environment variables to be passed onto the launched software.Example:import osimport tankclass BeforeAppLaunch(tank.Hook):    def execute(self, app_path, app_args, version, engine_name, **kwargs):                if engine_name == &quot;tk-maya&quot;:            os.environ[&quot;MY_CUSTOM_MAYA_ENV_VAR&quot;] = &quot;Some Maya specific setting&quot;                    Warning: Be careful not to completely redefine environment variables set by ShotGrid. For example, if you need to add a path to NUKE_PATH (for Nuke), or PYTHONPATH (for Maya), make sure you append your path to the existing value, rather than replace it.You can use our convenience method for this:tank.util.append_path_to_env_var(&quot;NUKE_PATH&quot;, &quot;/my/custom/path&quot;)    Custom wrapperSome studios have custom wrappers that handle setting the environment variables and launching the software. If you prefer to use custom code like this to set the environment, you can point the Software entity’s path fields to your executable wrapper, and tk-multi-launchapp will run that instead.                    Warning: Take care with this approach to preserve the environment variables set by ShotGrid other wise the integration will not start.    ",
    "url": "/624f2593/",
    "relUrl": "/624f2593/"
  },
  "118": {
    "id": "118",
    "title": "Setup",
    "content": "ShotGrid Isolation Feature Set - SetupIsolation the isolation features are independent of each other, and can be activated independently of each other. Media replication have as pre-requisite for Media Isolation to be implemented.The setup process will depend on which feature you want to activate for your site.In This Section  Planning your Setup  Media Isolation  Media Traffic Isolation  Media Replication  Isolation Fine Tuning  ActivationSetup OverviewUnderstand your responsibilitiesMake sure that you understand the client responsibilities and the implication of activating any of the Isolation feature.Start the onboarding processLeveraging the isolation features requires adopters to become AWS users. The features activation also requires Autodesk Support intervention. In order to ensure that this joint venture between Autodesk, AWS, and our clients is as streamlined as possible, we decided to work closely with AWS to define a cooperative onboarding process that would meet client expectations for a premium offering. Kick-start the onboarding process before going further.Planning your SetupBefore you start working on your setup, put a plan in place. Choose the features you need and get the required security/legal approval from your team to get started with the Isolation feature set.Media IsolationThis feature allow you to use a S3 Bucket owned by your studio to store media.Media Traffic IsolationThis feature allows for private routing of the media through the AWS Backbone and your studio network, isolating the media traffic from the public internet.Media ReplicationThis feature allows the media to be replicated between AWS Regions, for faster access in your world wide studios. Media Isolation is required.Fine TuningOnce the isolation features you need are activated, make sure that you everything is properly configured for security and cost-efficiency by reviewing this fine tuning guide.ActivationOnce everything is ready, it’s now time to migrate your production site to use the isolation features.",
    "url": "/8128c5fb/",
    "relUrl": "/8128c5fb/"
  },
  "119": {
    "id": "119",
    "title": "ShotGrid 데스크톱이 Ubuntu 같은 Debian 시스템에서도 작동합니까?",
    "content": "ShotGrid 데스크톱이 Ubuntu 같은 Debian 시스템에서도 작동합니까?현재는 ShotGrid 데스크톱용 Debian 기반 배포판을 지원하지 않습니다.과거에 몇몇 고객이 이를 구현하려고 했던 적이 있었는데, cpio를 사용하여 RPM에서 ShotGrid 데스크톱을 추출한 다음 라이브러리 종속성을 충족하려고 했지만 그리 좋은 결과를 내진 못했습니다. 추가 내용은 dev 그룹에서 이 스레드를 확인할 수 있습니다.Python 자체가 많은 시스템 레벨 라이브러리 위에 위치하기 때문에 명시적인 라이브러리 종속성 목록은 없습니다.지금으로서는 Debian 지원에 대한 공식적인 계획이 없습니다. Ubuntu를 위한 빌드에는 문제가 있지만 한편으로는 결코 사소하다고 할 수 없는 변화를 구현하다 보면 추가 운영 체제를 QA 및 지원해야 할 필요도 있습니다.ShotGrid 데스크톱 없이 툴킷을 수동으로 실행 및 활성화하려는 경우(여기 문서에서 설명) - 설명서 페이지에서 activate_shotgun_pipeline_toolkit.py 스크립트를 다운로드하십시오. 이 안내서의 8단계에 있으며, “다운로드하려면 클릭…“(click to download…) 헤더를 클릭하면 됩니다.",
    "url": "/3830df9d/",
    "relUrl": "/3830df9d/"
  },
  "120": {
    "id": "120",
    "title": "Developing apps",
    "content": "Developing your own appIntroductionThis guide outlines what a Toolkit app is, covers how to create one, and explains some basics around app development.ShotGrid Pipeline Toolkit is not only a collection of apps and engines maintained by ShotGrid Software, it is also a development platform that makes it easy to quickly build custom pipeline tools!  What is a Toolkit app?  Creating your own appSteps:  Creating a development sandbox  Forking or downloading the starter app repository  Adding the app to your config  Developing the app          Anatomy of the Template Starter App      Configuration settings      Frameworks      Reloading your changes        Testing  Preparing your first releaseAdditional info:  Modifying an existing app          Contributing      What is a Toolkit app?A Toolkit app can be defined as follows:  A tool that is usually run by an end-user, using the ShotGrid integrations.  Apps usually have a graphical user interface with which the user can guide the app’s operations, but they don’t have to. An app can also be a command registered with the integrations, triggered by the user from the ShotGrid menu in the host software.  They can have an API/public methods in which other processes or apps could interact.  They can be multi-platform, and software agnostic.  They can be set up to be configured differently per environment.  They can be contextually aware. For example, an app can know the task the user is working on, and act accordingly.  They can only be run from a Toolkit engine.Toolkit apps are initialized by Toolkit engines. Engines are designed to run within a specific software environment, where they then provide an interface from which to run Toolkit apps. The engine abstracts away the complexity of needing to handle the various software environments from the app.This means the app only needs to focus on providing the functionality to fulfill its purpose and doesn’t need to, for example, handle window parenting, keeping track of the user’s context, or providing a shortcut for launching itself.Creating your own app.All apps and engines maintained and released by ShotGrid Software are open source and you can find them in GitHub.This section goes through how to create a new app using our starter template. We assume that you are familiar with GitHub and git workflows, but please note that you can do Toolkit development even if you are not using git as your source control solution.Part 1: Creating a development sandboxBefore you do anything else, we recommend that you set up a development sandbox by cloning the project configuration by cloning your project’s configuration.This will result in a separate configuration where you can develop your code and test changes without affecting anyone else on the production.Part 2: Forking or downloading the starter app repositoryWe provide a template starter app that you can use as a starting point for your own app.By using this app you get all the standard Toolkit boilerplate code set up for you, and a basic example GUI.To use it, you can either fork the git repository and then clone it to your local dev area on disk, or if you don’t want to use git source control at this stage, you can just download the files from GitHub as a zip file, and unzip them locally (you can always set up a git repository later).Either way, the goal is to have a local copy of the starter app code so you can start making changes.Part 3: Adding the app to your configWe recommend reading the “Adding an app” guide, as it explains in more detail how to add an app to your configuration.When adding the app to your config, you need to consider where your app will be used, i.e. perhaps only in Nuke or in multiple different software, or standalone from ShotGrid Desktop.You also need to think about the context that your app will depend on.For example, can your app only run when you know the task the user is working on, or can it run with just the project known?Knowing this will dictate which environment YAMLs and engines you need to add your app settings to.If you’re not sure right now, it’s a good idea to start by adding it to the tk-shell engine in the project environment. That way you can run it from your IDE or via the command line with the tank command if you have a centralized config. This will make it quicker to develop with.To start, use a dev descriptor for the location of your app.tk-multi-starterapp:  location:    type: dev    path: /path/to/source_code/tk-multi-starterappThis instructs Toolkit to load the app code directly from disk in the given location, which is great for development, where you want to change the code all the time.Later when you add the app to your production config, you may want to use a different descriptor.Now you’ve added the app to an environment; you should be able to go ahead and launch it. How you launch it will depend on the engine and environment you defined it in.Part 4: Developing the appYou are now all set to start developing your app!Anatomy of the Template Starter AppThe template starter app contains the following basic structure:  app.py - The app entry point and menu registration can be found in the app.py file. This is where you typically set up your classes, get things initialized, and get menu items registered.  info.yml - Also known as the manifest file. It defines all the different settings that this app requires when it is installed, along with their default values if supplied. Settings are often useful if you want reusable apps and you don’t want to hard code any values in the app itself.  python/app/dialog.py - This contains the logic, event callbacks, etc. that produce the main app window.  python/app/ui - This folder contains the automatically generated UI code and resource file. You don’t edit this directly; instead, you edit the Qt UI file in the resources folder.  resources/ - In the resources folder, the dialog.ui file is a Qt Designer file that you can open up and use to rapidly design and define the look and feel of the app. Once you have made changes, you have to execute the build_resources.sh script, which will convert the UI file to python code and store it as /python/app/ui/dialog.py.  style.qss - You can define QSS (Qt style sheets) for your UI in this file.                    Note: An app doesn’t need to have a UI however, and the minimum requirements for a valid app are an app.py containing an Application class and an info.yml.    Configuration settingsInside the manifest file, there should be a configuration section where you can define app settings.Defining a setting in the manifest file allows you to configure different setting values for your app in the environment YAML files.This is useful if your app needs to behave differently depending on the environment it is in.For example, you may wish to have a setting that defines a template to use when saving a file.save_template:    type: template    default_value: &quot;maya_asset_work&quot;    description: The template to use when building the path to save the file into    allows_empty: FalseCreating a setting for this means you don’t have to hard code the template name in your app code, and can instead get the value from the settings defined either by default in the info.yml or overridden in the environment YAML file settings.template = app.get_setting(&quot;save_template&quot;)This means that you could configure your app to use a different template depending on the environment the app is running in.You can read more on configuration settings in the reference documentation.FrameworksIf you know that you will be using frameworks, you can add them to the manifest file.For example, if you plan to use the Qt Widgets and ShotGrid Utils frameworks for your app, add the following to the info.yml:# the frameworks required to run this appframeworks:    - {&quot;name&quot;: &quot;tk-framework-shotgunutils&quot;, &quot;version&quot;: &quot;v2.x.x&quot;}    - {&quot;name&quot;: &quot;tk-framework-qtwidgets&quot;, &quot;version&quot;: &quot;v1.x.x&quot;}Minimum required framework versionsIf there is a required minimum version for a framework, the minimum_version setting can be used in the info.yml:# the frameworks required to run this appframeworks:    - {&quot;name&quot;: &quot;tk-framework-shotgunutils&quot;, &quot;version&quot;: &quot;v2.x.x&quot;}    - {&quot;name&quot;: &quot;tk-framework-qtwidgets&quot;, &quot;version&quot;: &quot;v1.x.x&quot;, &quot;minimum_version&quot;: &quot;v1.5.0&quot;}The above will ensure that v1.5.0 of tk-framework-qtwidgets is available for the app to use. If it is not, the app will not be loaded at startup time and an error will be printed to the console. When the app is updated using tank updates, any configured frameworks not meeting their required minimum versions will be automatically updated along with the app.For more information about frameworks and how they can be useful, check out the following links:  The Qt Widgets Framework  The ShotGrid utils FrameworkReloading your changesIf you are testing your app within software such as Maya, then as soon as you have one or more dev items in your configuration, Toolkit will automatically add a Reload and Restart option to the ShotGrid menu.Clicking this will reload your configuration and code and then restart your engine. This means that you can iterate quickly: start Maya once, and then each time you make code or configuration changes that you want to try out, simply hit the Reload and Restart button and your changes will be pulled in.                    Note: If you have any UIs active on screen, these will not automatically update, but you have to go in and re-launch the UIs from the menu.    Part 5: TestingWhen you want to test your code, you can easily invite other users to your dev sandbox by adding them to the User Restrictions field on the PipelineConfiguration entity in ShotGrid. As soon as you have added a user, they will see new entries on their menus inside of ShotGrid Create and the browser actions, as well as an option to pick the configuration inside of ShotGrid Desktop.                    Note: Make sure they have access to see your app code as well, otherwise the app will not load.    Part 6: Preparing your first releaseIn part three you set your configuration to point to your app using a dev descriptor.For released software, you will want to ensure that your app can be accessed by all users and that things are versioned so that they can be upgraded safely and easily.All apps provided by ShotGrid use the Toolkit app store to track updates and releases, and they will have a location tag that looks something like this:location:   name: tk-multi-setframerange   type: app_store   version: v0.1.7This allows Toolkit (for example the tank updates command) to check when updates are available, update and maintain configurations in a very safe way. Whenever the updates command is run and a new version is available, Toolkit will download the code and place it in a local “bundle cache” on disk and ensure that users have access to it.There are a few different options for sourcing your app releases.  Git and GitHub  ShotGrid Uploads  Local pathsIn your production config, you add your app and switch to using the descriptor that suits your needs.Git-based descriptorsWe recommend that you start using source control to make sure that changes are tracked, regardless of if you intend to use a git descriptor.Toolkit supports git (https://git-scm.com/) out of the box, and when running tank updates on a configuration, it can check for the latest release in your git repository and update your configuration, just like with the app store descriptor.The requirements for this are:  Your git repo needs to contain just a single app  Your git repo should have the same structure as the starter app repository.  You use Semantic Versioning when creating your tags. Toolkit will use these version numbers to try to determine which version is the most recent, and by following the convention vX.Y.Z.Once you have created your first tag in git (eg. v1.0.0), you could then set up your config to use a git descriptor that points to your tag.Then you can simply run tank updates, and if new tags have been created, you will be prompted if you want to upgrade. The workflow is now identical to the one which happens with official app store apps.                    Caution: The git descriptor works well with centralized configs, where the caching of apps is usually run by an admin and is stored to a central location where all users can access it. However, if you are using a distributed config, then it may not be as suitable. Your app will be downloaded per user, which means each user will need to have git installed and setup to authenticate with your repo and access the code.    Modifying an existing appRather than starting from an empty starter template, it is sometimes necessary to add a minor feature to an existing app, for example, one of ShotGrid Software’s standard apps. When you work with a modified version of an app, you typically want to ‘track’ against the source app and make sure to regularly pull in changes and bug fixes.When you do this type of development, you pick up the parent code, then apply some of your changes, then release this to your pipeline. Your release effectively consists of the base version of the app PLUS your applied local changes. We recommend that you add a version suffix to the existing version number. This will work seamlessly with Toolkit and is relatively straight forward. The following workflow illustrates how to proceed:  You fork the parent app and create your own repository. With the fork, you get all the git tags. Let’s say the latest tag is called v0.2.12 and the master branch basically equals the contents in this tag.  You apply your changes and commit to your master branch. You now have v0.2.12 PLUS your changes. When you release this to production you need to create a tag. Name the tag v0.2.12.1, to indicate that your code is based on v0.2.12 and it is the first release.  Now someone finds a bug in your modifications. Fix the bug and tag up and release v0.2.12.2.  A number of important bug fixes have been released in the parent repository. Pull them down to your repository. The most recent tag is now v0.2.15 due to releases that have happened in the parent repository. Now merge your changes with master and test. You now basically have parent app v0.2.15 merged with your changes. Tag up v0.2.15.1.The tagging scheme outlined above guarantees that the Toolkit updates work correctly and make it easy to quickly see what code each tag in your fork is based on.ContributingWe love pull requests! If you feel you have made a change that can benefit others, don’t hesitate to feed it back to us as a pull request.We may then fold it back into the main version of the app.Alternatively, add a suggestion for a new idea on our roadmap page.If you’ve made an entire app that your willing to share with the community, let us all know on the forums!",
    "url": "/2e5ed7bb/",
    "relUrl": "/2e5ed7bb/"
  },
  "121": {
    "id": "121",
    "title": "Bootstrapping and running an app",
    "content": "Bootstrapping and running an appThis guide walks you through the process of initializing a Toolkit engine so that you can run custom code or launch apps, also known as bootstrapping.Bootstrapping is useful in situations where a Toolkit engine has not already been started and you need to use the API.For example, you might have a processing script that runs on a render farm and needs to utilize the Toolkit API to handle paths and context.Or you may wish to be able to run your Toolkit app from your favorite IDE.                    Note: If you are using a distributed config, a Toolkit engine must be initialized before running Toolkit API methods. It is possible to use the API without bootstrapping an engine if you are using a centralized config, using the factory methods, however, you will need to manually find the path to the correct core API for your project when importing sgtk.    Requirements  An understanding of Python programming fundamentals.  A project with an advanced configuration. If you haven’t set up a configuration before you can follow the “Getting started with configurations” guide.Steps  Importing the Toolkit API for bootstrapping  Logging  Authentication  Bootstrapping an engine  launching an app  Complete scriptPart 1: Importing the Toolkit API for bootstrappingWhere should I import sgtk from?If you’ve followed the “generating a path and publishing it” guide then you’ll have covered the step of importing sgtk.That guide states that you must import the sgtk package from the project configuration you wish to work with.With bootstrapping, this is still true, however, it doesn’t matter which initial sgtk package you import, as any Toolkit API can perform the bootstrap operation into a different project configuration.The bootstrap process will swap out the currently imported sgtk package for the new project config’s Toolkit API.Downloading a standalone Toolkit core APITo start, you need to import an sgtk API package which is found in tk-core.You could import one from an existing project, however, this might be tricky to conveniently locate.A recommended approach would be to download a standalone copy of the latest core API which will be used purely for the purpose of bootstrapping.You should store it in a convenient place where it can be imported. Make sure that the path you add points to the python folder inside the tk-core folder as this is where the sgtk package is located.Code# If your sgtk package is not located in a location where Python will automatically look# then add the path to sys.path.import syssys.path.insert(0, &quot;/path/to/tk-core/python&quot;)import sgtkPart 2: LoggingIf you are running this script via an IDE or shell, then you will most likely want to enable the logging to be output.To do this you need to run LogManager().initialize_custom_handler().You don’t need to provide a custom handler for this purpose, as not providing one will set up a standard stream-based logging handler.Optionally you can also set the LogManager().global_debug = True to give you more verbose output. This means that any logger.debug() calls in our code or yours will now be output.Logging can have an impact on performance, so you should only enable debug logging when developing, and try to limit the amount of logger.info() method calls to those that are important to have visibility over during normal operation.import sgtk# Initialize the logger so we get output to our terminal.sgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing).sgtk.LogManager().global_debug = TruePart 3: AuthenticationWhen running a script that uses the Toolkit API outside of an environment where ShotGrid Toolkit has already been started, you will always need to authenticate.So before you can perform the bootstrapping, you need to authenticate the Toolkit API with your ShotGrid site.You can authenticate with user credentials or with script credentials.  If the purpose is to bootstrap for a user-facing process like launching an app, or running some code that will require user input,then user authentication is the best way to go, (This is how all our integrations work by default).  If you’re writing a script to automate something and a user is not present to authenticate then you should use script credentials.Authentication is handled via the ShotGridAuthenticator class.Here is an example of both user and script authentication.User Authentication# Import Toolkit so we can access to Toolkit specific features.import sgtk# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Optionally you can clear any previously cached sessions. This will force you to enter credentials each time.authenticator.clear_default_user()# The user will be prompted for their username,# password, and optional 2-factor authentication code. If a QApplication is# available, a UI will pop-up. If not, the credentials will be prompted# on the command line. The user object returned encapsulates the login# information.user = authenticator.get_user()# Tells Toolkit which user to use for connecting to ShotGrid. Note that this should# always take place before creating an `Sgtk` instance.sgtk.set_authenticated_user(user)Script Authentication# Import Toolkit so we can access to Toolkit specific features.import sgtk# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your ShotGrid site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to ShotGrid.sgtk.set_authenticated_user(user)Part 4: Bootstrapping an engineNow that you have authenticated the Toolkit API for the session, you can start the bootstrapping process.You can find a lot of information on the bootstrap API in our reference docs.The bootstrapping process at a high level essentially performs the following steps:  Retrieves or locates the Toolkit configuration folder.  Ensures that the configuration dependencies such as the apps and engines are present in the bundle cache. If they are not present, and they are using cloud-based descriptors such as app_store, or ShotGrid then it will download them to the bundle cache.  Swaps out the current loaded sgtk core for the one appropriate to the config.  Initializes the engine, apps, and frameworks.                    Note: Usually bootstrapping should take care of everything that is needed for that engine to run successfully.However, in some situations, the engine may have specific setup requirements that fall outside of the bootstrap process, and must be handled separately.    Bootstrap PreparationTo bootstrap, you must first create a ToolkitManager instance.mgr = sgtk.bootstrap.ToolkitManager(user)  If a user is not passed into the ToolkitManager’s initializer, ShotgunAuthenticator().get_user() is called internally, which will return the currently authenticated ShotGrid user. To bootstrap using any other HumanUser or ScriptUser, pass in a user created via ShotgunAuthenticator.create_session_user or ShotgunAuthenticator.create_script_user.For Toolkit to bootstrap, it needs to know at least the entity, plugin id, and engine.This guide won’t cover all the available parameters and options, as they are covered in the reference documentation.Plugin IDYou can define the plugin id by passing a string to the ToolkitManager.plugin_id parameter before calling the bootstrap method.In this guide, you will be bootstrapping the tk-shell engine so you should provide a suitable plugin id name following the conventions described in the reference docs.mgr.plugin_id = &quot;basic.shell&quot;EngineIf your goal is to launch an app or run Toolkit code in a standalone python environment outside of software such as Maya or Nuke, then tk-shell is the engine you will want to bootstrap into.If you are wanting to run Toolkit apps within supported Software, then you will want to pick the appropriate engine, such as tk-maya or tk-nuke.This parameter is passed directly to the ToolkitManager.bootstrap_engine() method. See the example in the entity section bellow.EntityThe ToolkitManager.bootstrap_engine() methods entity parameter, is used to set the context and therefore environment for the launched engine.The entity can be of any entity type that the configuration is set up to work with. For example, if you provide a Project entity, the engine will start up in a project context, using the project environment settings.Likewise, you could provide a Task entity (where the task is linked to an Asset), and it will start up using the asset_step.yml environment.This is based on the default configuration behavior, the environment that is chosen is controlled via the core hook, pick_environment.py, and so could be changed to pick a different environment based on the context or other parameters.You need to provide the entity in the format of a ShotGrid entity dictionary which must contain at least the type and id:task = {&quot;type&quot;: &quot;Task&quot;, &quot;id&quot;: 17264}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=task)If you bootstrap into an entity type other than Project, you may need to ensure your path cache is in sync, otherwise, it may not be able to load the environment if, for example, it tries to resolve a template.Since you don’t have an Sgtk instance before bootstrapping, you will need to tell the bootstrap process to perform the synchronization after it’s created an Sgtk instance but before it starts the engine.You can do this by setting the ToolkitManager.pre_engine_start_callback property to point to a custom method.In that method you can then run the synchronization:def pre_engine_start_callback(ctx):    '''    Called before the engine is started.    :param :class:&quot;~sgtk.Context&quot; ctx: Context into        which the engine will be launched. This can also be used        to access the Toolkit instance.    '''    ctx.sgtk.synchronize_filesystem_structure()mgr.pre_engine_start_callback = pre_engine_start_callbackChoice of configurationYou have the choice of explicitly defining which configuration to bootstrap, or leaving the bootstrap logic to autodetect an appropriate configuration.You can even set a fallback configuration in case one is not automatically found.In this guide, we assume that your project has a configuration already setup and that it will be found automatically.BootstrappingOnce all the ToolkitManager parameters have been set, and you call the ToolkitManager.bootstrap_engine() method, it will start the engine, and return a pointer to the engine instance.Here is a recap of the code so far:# Import Toolkit so we can access to Toolkit specific features.import sgtk# Initialize the logger so we get output to our terminal.sgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing).sgtk.LogManager().global_debug = True# Authentication################# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your ShotGrid site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to ShotGrid.# This is actually not necessary when using the ToolkitManager. The authenticated user will be set# before launching the engine.# sgtk.set_authenticated_user(user)# Bootstrap############ create an instance of the ToolkitManager which we will use to set a bunch of settings before initiating the bootstrap. mgr = sgtk.bootstrap.ToolkitManager(user)mgr.plugin_id = &quot;basic.shell&quot;project = {&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=project)Part 5: Launching an appNow that you have an engine instance, you’re ready to start using the Toolkit API.Before covering how to launch the app, it’s worth pointing out you can get hold of the current context, Sgtk instance, and ShotGrid API instance via the engine.engine.contextengine.sgtkengine.shotgunWhilst the end goal of this guide is to show you how to launch an app, you could from this point make use of the above attributes and test some code snippets or run some automation that makes use of the Toolkit API.Launching the AppWhen the engine starts, it initializes all the apps defined for the environment. The apps in turn register commands with the engine, and the engine usually displays these as actions in a menu, if running in Software like Maya.Finding the commandsTo first see what commands have been registered, you can print out the Engine.commands property:# use pprint to give us a nicely formatted output.import pprintpprint.pprint(engine.commands.keys())&amp;gt;&amp;gt; ['houdini_fx_17.5.360', 'nukestudio_11.2v5', 'nukestudio_11.3v2', 'after_effects_cc_2019', 'maya_2019', 'maya_2018', 'Jump to Screening Room Web Player', 'Publish...',...]With that list, you can see which commands have been registered and can be run.Running the commandHow you run the command will be different depending on the engine, as there is currently no standardized method.For the tk-shell engine, you can use the convenience method: Engine.execute_command().It expects a command string name, which we listed out earlier, and a list of parameters that the app’s command expects to be passed.if &quot;Publish...&quot; in engine.commands:    # Launch the Publish app, and it doesn't require any arguments to run so provide an empty list.    engine.execute_command(&quot;Publish...&quot;,[])If you’re not running in the tk-shell engine, then you can fallback to calling the registered callback directly.# now find the command we specifically want to executeapp_command = engine.commands.get(&quot;Publish...&quot;)if app_command:    # now run the command, which in this case will launch the Publish app.    app_command[&quot;callback&quot;]()Your app should now have started, and if you’re running the tk-shell engine then the output should be appearing in the terminal/console.Part 6: The complete script# Import Toolkit so we can access to Toolkit specific features.import sgtk# Initialize the logger so we get output to our terminalsgtk.LogManager().initialize_custom_handler()# Set debugging to true so that we get more verbose output, (should only be used for testing)sgtk.LogManager().global_debug = True# Authentication################# Instantiate the authenticator object.authenticator = sgtk.authentication.ShotgunAuthenticator()# Create a user programmatically using the script's key.user = authenticator.create_script_user( api_script=&quot;Script Name&quot;, api_key=&quot;4e48f....&amp;lt;use the key from your ShotGrid site&amp;gt;&quot;, host=&quot;https://yoursite.shotgunstudio.com&quot;)# Tells Toolkit which user to use for connecting to ShotGrid.# This is actually not necessary when using the ToolkitManager. The authenticated user will be set# before launching the engine.# sgtk.set_authenticated_user(user)# Bootstrap############ create an instance of the ToolkitManager which we will use to set a bunch of settings before initiating the bootstrap. mgr = sgtk.bootstrap.ToolkitManager(user)mgr.plugin_id = &quot;basic.shell&quot;project = {&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176}engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity=project)# Optionally print out the list of registered commands:# use pprint to give us a nicely formatted output.# import pprint# pprint.pprint(engine.commands.keys())if &quot;Publish...&quot; in engine.commands:    # Launch the Publish app, and it doesn't require any arguments to run so provide an empty list.    engine.execute_command(&quot;Publish...&quot;,[])",
    "url": "/3d8cc69a/",
    "relUrl": "/3d8cc69a/"
  },
  "122": {
    "id": "122",
    "title": "Developing engines",
    "content": "Developing your own engineIntroductionThis document outlines some of the technical details relating to Toolkit engine development.Table of Contents:  What is a Toolkit engine?  Things to know before you start  Approaches to engine integration          Host software includes Qt, PyQt/PySide and Python      Host software includes Qt and Python but not PySide/PyQt      Host software includes Python      Host software does not contain Python but you can write plugins      Host software provides no scriptability at all        Qt window parenting  Startup behavior  Host software wish listWhat is a Toolkit engine?When developing an engine, you effectively establish a bridge between the host software and the various Toolkit apps and frameworks that are loaded into the engine. The engine makes it possible to abstract the differences between software so that apps can be written in more of a software-agnostic manner using Python and Qt.The engine is a collection of files, similar in structure to an app. It has an engine.py file and this must derive from the core Engine base class. Different engines then re-implement various aspects of this base class depending on their internal complexity. An engine typically handles or provides the following services:  Menu management. At engine startup, once the apps have been loaded, the engine needs to create its ShotGrid menu and add the various apps to this menu.  Logging methods are typically overridden to write to the software’s log/console.  Methods for displaying UI dialogs and windows. These methods are usually overridden, if the way the engine handles Qt is different from the default base class behavior, to ensure seamless integration of windows launched by Toolkit apps and the underlying host software window management setup.  Provides a commands dictionary containing all the command objects registered by apps. This is typically accessed when menu entries are created.  The base class exposes various init and destroy methods that are executed at various points in the startup process. These can be overridden to control startup and shutdown execution.  Startup logic that gets called by the tk-multi-launchapp at launch time, as well as automatic software discovery.Engines are launched by the Toolkit platform using the sgtk.platform.start_engine()  or the sgtk.bootstrap.ToolkitManager.bootstrap_engine() methods. This command will read the configuration files, launch the engines, load all apps, etc.The goal with the engine is that once it has launched, it will provide a consistent Python/Qt interface to the apps. Since all engines implement the same base class, apps can call methods on the engines, for example, to create UIs. It is up to each engine to implement these methods so that they work nicely inside the host software.Things to know before you startWe provide integrations for the most commonly used content creation software.There are also engines that Toolkit Community members have built and shared back. But sometimes you’ll need pipeline integrations for software that doesn’t have a Toolkit engine yet.If you have the time and resources, we encourage you to help the Toolkit Community (and yourselves) in writing a missing engine you would like to use!Before embarking on writing code, talk to us! We can’t promise anything, but we will be happy to discuss your plans with you. We may also be able to connect you to other users who are interested in or have done work on the same engine.If you can, open a channel of communication with a technical contact or developer of the software you are looking to integrate Toolkit into. This helps gain insight into what the possibilities and/or roadblocks are for getting something going. Once you establish a contact and talk through the basics of what you are trying to do, you can bring us into the conversation and set up a meeting with all of us to talk through some of the specifics of the engine.Also, you can engage directly with the Toolkit community in the ShotGrid community forum.We love to see new integrations, and are always eternally grateful for people’s generous contributions to the Toolkit Community!                    Tip: The Developing your own app contains a step by step guide to developing an app, which contains principles that apply to developing an engine as well that are not covered in this guide.    Approaches to engine integrationDepending on what the capabilities of the host app are, engine development may be more or less complex. This section outlines a couple of different complexity levels that we have noticed during engine development.Host software includes Qt, PyQt/PySide, and PythonThis is the best setup for Toolkit and implementing an engine on top of a host software that supports Qt, Python, and PySide is very straight forward. The Nuke engine or the Maya engine is a good example of this. Integration is merely a matter of hooking up some log file management and write code to set up the ShotGrid menu.Host software includes Qt and Python but not PySide/PyQtThis class of software includes for example Motionbuilder and is relatively easy to integrate. Since the host software itself was written in Qt and contains a Python interpreter, it is possible to compile a version of PySide or PyQt and distribute it with the engine.This PySide is then added to the Python environment and will allow access to the Qt objects using Python. Commonly, the exact compiler settings that were used when compiling the shot application must be used when compiling PySide, to guarantee it to work.Host software includes PythonThis class of software includes for example, the third party integration Unreal.These host software have a non-Qt UI but contain a Python interpreter. This means that Python code can execute inside of the environment, but there is no existing Qt event loop running. In this case, Qt and PySide will need to be included with the engine and the Qt message pump (event) loop must be hooked up with the main event loop in the UI. Sometimes the host software may contain special methods for doing precisely this. If not, arrangements must be made so that the Qt event loop runs regularly, for example via an on-idle call.Host software does not contain Python but you can write pluginsThis class includes Photoshop and After Effects.There is no Python scripting, but C++ plugins can be created. In this case, the strategy is often to create a plugin that contains an IPC layer and launches Qt and Python in a separate process at startup. Once the secondary process is running, commands are sent back and forth using the IPC layer.  This type of host software usually means significant work to get a working engine solution.                    Tip: With the Photoshop and After Effects engines we actually created a framework that handles the adobe plugin.  Both engine make use of the framework to communicate with the host software, and it makes it easier to build other engines for the rest of the adobe family.    Host software provides no scriptability at allIf the host software cannot be accessed programmatically in any way, it is not possible to create an engine for it.Qt window parentingSpecial attention typically needs to be paid to window parenting. Usually, the PySide windows will not have a natural parent in the widget hierarchy and this needs to be explicitly called out. The window parenting is important to provide a consistent experience and without it implemented, Toolkit app windows may appear behind the main window, which can be quite confusing.Startup behaviorThe engine is also responsible for handling how the software is launched and its integration is started. This logic will be called when the tk-multi-launchapp tries to launch the software with your engine.You can read more about how this is set up in the core documentation.Host software wish listThe following host software traits can be taken advantage of by Toolkit engines. The more of them that are supported, the better the engine experience will be!  Built-in Python interpreter, Qt, and PySide!  Ability to run code at software startup/init.  Ability to access and auto-run code in two places: once when the software is up and running and once when the UI has fully initialized.  API commands that wrap filesystem interaction: Open, Save, Save As, Add reference, etc.      API commands to add UI elements          Add a custom Qt widget as a panel to the app (ideally via a bundled PySide)      Add custom Menu / Context Menu items      Custom nodes in node-based packages (with an easy way to integrate a custom UI for interaction)      Introspection to get at things like selected items/nodes        Flexible event system          “Interesting” events can trigger custom code        Support for running UI asynchronously          For example, pop up a dialog when a custom menu item is triggered that does not lock up the interface      Provide a handle to a top-level window so custom UI windows can be parented correctly      ",
    "url": "/be19bc87/",
    "relUrl": "/be19bc87/"
  },
  "123": {
    "id": "123",
    "title": "Developing frameworks",
    "content": "Developing your own frameworkIntroductionThis document outlines some of the technical details relating to Toolkit framework development.Table of Contents:  What is a Toolkit framework?  Pre-made ShotGrid frameworks  Creating a Framework  Using Frameworks from hooksWhat is a Toolkit framework?Toolkit frameworks are very similar to Toolkit apps. The main difference is that a framework is not something you would run on its own.Instead, you would import a framework into your app or engine. It allows you to keep reusable logic separate so that it can be used in multiple engines and apps.An example of a framework would be a library of reusable UI components, that might contain a playlist picker component.You could then import that framework in your app, and plug in the playlist picker component to your main app UI.Pre-made ShotGrid frameworksShotGrid supplies some premade frameworks that you may find useful when creating your own apps.The Qt Widgets and ShotGrid Utils frameworks are especially useful in app development.Creating a FrameworkWhen it comes to creating your own framework, the setup is pretty much the same as writing an app, and you can get more information on that in the “Developing your own apps” guide.Instead of an app.py file, a framework has a framework.py at the root of the framework package, that contains a class deriving from the Framework base class.Also, your framework won’t register a command with the engine.Instead, you can either store methods directly on the framework instance itself, or store modules inside the python/ folder.For example, the shotgunutils framework stores them in the python folder.To access them, you would import the framework, and then use the import_module() method, to access the submodules.The API docs contain examples on how to import frameworks.Using Frameworks from hooksIt can be useful to create a framework so that you can share some common logic across hooks.A framework can be used in an app, or other framework hooks, even if the app/framework doesn’t explicitly require it in the manifest file, via theHook.load_framework() method. Note frameworks can’t be used in core hooks even with this method.",
    "url": "/312b792f/",
    "relUrl": "/312b792f/"
  },
  "124": {
    "id": "124",
    "title": "Generating a path and publishing it",
    "content": "Generating a path and publishing itThis guide covers getting started with the ShotGrid Toolkit Python API, which is what our pipeline integrations are built with.The purpose of this guide is to walk through a basic example of how you can use the API, and by the end, you will be able to import the Toolkit API and generate a path and publish it.Requirements  An understanding of Python programming fundamentals.  A project with an advanced configuration. If you haven’t set up a configuration before you can follow the Getting started with configurations guide.Steps  Importing sgtk  Getting an Sgtk instance  Getting context  Creating folders  Using a template to build a path  Finding existing files and getting the latest version number  Registering a published file  Pulling it all together into a complete scriptPart 1: Importing sgtkThe Toolkit API is contained in a python package called sgtk. Each Toolkit configuration has its own copy of the API, which comes as part of tk-core.To use the API on a project’s configuration, you must import the sgtk package from the configuration you wish to work with; importing it from a different configuration will lead to errors.                    Note: You may sometimes come across references to a tank package. This is the legacy name for the same thing. While both work sgtk is the correct name to use going forward.    To import the API you need to make sure that the path to the core’s python folder exists in the sys.path.However, for this example, we recommend that you run this code in the ShotGrid Desktop’s Python console.This will mean that the correct sgtk package path is already added to your sys.path.Equally, you don’t need to add the path if you are running this code within software where the ShotGrid integration is already running.When running your code in an environment where ShotGrid is already started you can import the API by simply writing:import sgtkIf you want to use the API outside of a ShotGrid integration, for example, if you’re testing it in your favorite IDE, then you will need to set the path to the API first:import syssys.path.append(&quot;/shotgun/configs/my_project_config/install/core/python&quot;)import sgtk                    Note: If you’re using distributed configs and you want to import sgtk in an environment where Toolkit hasn’t already been bootstrapped, you will need to take a different approach. Please see the bootstrapping guide for more details.    Part 2: Getting an Sgtk instanceIn order to start using the Toolkit API, you’ll need to create an instance of the Sgtk class.Sgtk is a class in the sgtk package that acts as the main interface to the API.Once you create an instance of Sgtk, you will be able to do things like get a context, create folders, or access the templates.As the API documentation states, you don’t create an instance of Sgtk directly. Here are some options for getting an Sgtk instance.      You can get an Sgtk instance from the current engine, if you are running the Python code within an environment where the ShotGrid integrations are already running, (such as the Maya Python console, if Maya was launched from ShotGrid.)The Engine.sgtk property holds the engine’s Sgtk instance.So for example, in Maya, you could run the following:     # Get the engine that is currently running. current_engine = sgtk.platform.current_engine()     # Grab the already created Sgtk instance from the current engine. tk = current_engine.sgtk        You can access the Sgtk instance through the Engine.sgtk property.    Note: The Engine.sgtk property should not be confused with or considered the same as the sgtk package that you imported in part 1.        sgtk.sgtk_from_entity() -  If you are running in an environment where an engine hasn’t already been started, you can use this method to get an Sgtk instance based upon an entity id. The entity whose id you are supplying must belong to the project that the sgtk API was imported from. This doesn’t work with distributed configs, please see the bootstrapping guide for more details.        sgtk.sgtk_from_path() - much like the sgtk_from_entity() except this will accept a path to a configuration or a path to or inside the project root folder, for example, a work file or shot folder. This doesn’t work with distributed configs, please see the bootstrapping guide for more details.  Throughout this guide we will assume you are running this code in an environment where an engine has already been started, so we’ll use option 1.Also you will store the Sgtk class instance in a variable called tk.If you’re using the ShotGrid Python Console then the tk variable is already pre-defined as a global variable.You now have an Sgtk instance and you’re ready to start using the API.Your publish script should now look like this:import sgtk# Get the engine that is currently running.current_engine = sgtk.platform.current_engine()# Grab the already created Sgtk instance from the current engine.tk = current_engine.sgtkPart 3: Getting contextWhat is a context and why do I need it?A lot of what happens in Toolkit revolves around context, in other words knowing what you are working on and being able to act accordingly.With the Toolkit API, you will need to be able to store important details about the entities you are working with, and share them with apps or other processes so they can operate in a contextually aware way.For example, when Toolkit knows what task you’re working on, it can automatically link your published files to that task in ShotGrid.The Context class acts as a container for this information.You can store the Task, Step, entity (such as a Shot or Asset), Project, and current HumanUser within an instance of the class, among a few other things.You can create as many different context objects as you like in a given session. However, when there is an engine present, there is a concept of a single current context, which the engine keeps track of.This is the context that the user is currently working in, and that the apps should be working with.In a later step, you will be using the context to help resolve a path that can be used for saving or copying a file.Acquiring a ContextTo create a context you must use one of the following constructor methods Sgtk.context_from_entity(), Sgtk.context_from_entity_dictionary() or Sgtk.context_from_path().You access these methods through the Sgtk instance you created in the previous step, which you stored in the tk variable.                    Note: To get a context from a path, you must have already created folders, which is covered in the next step of this guide.    Instead of creating a new context however, you could grab the current context from the engine, that you gathered in part 2, like this:context = current_engine.contextSince you will be using the context to help resolve a file path for a Task on a Shot in later steps, you need to be certain the context contains the relevant information.If your code was running as part of a Toolkit app, and your app was configured to only run in a shot_step environment then you could safely assume you would get an appropriate current context.However, for the sake of avoiding ambiguity in this guide, you will create a context explicitly from a Task, (that must belong to a Shot), using the Sgtk.context_from_entity().When you create a context you provide the deepest level required for your operations.For example, you could create a context from a Task and Toolkit will work out the rest of the context parameters for you.context = tk.context_from_entity(&quot;Task&quot;, 13155)If you print out a representation of the context instance you will get something like this:print(repr(context))&amp;gt;&amp;gt; &amp;lt;Sgtk Context:   Project: {'type': 'Project', 'name': 'My Project', 'id': 176}  Entity: {'type': 'Shot', 'name': 'shot01_running_away', 'id': 1381}  Step: {'type': 'Step', 'name': 'Comp', 'id': 8}  Task: {'type': 'Task', 'name': 'Comp', 'id': 13155}  User: None  Shotgun URL: https://mysite.shotgunstudio.com/detail/Task/13155  Additional Entities: []  Source Entity: {'type': 'Shot', 'name': 'shot01_running_away', 'id': 1381}&amp;gt;Even though you only provided the task, it should have filled in the other related details.The publish script should now look like this:import sgtk# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work. context = tk.context_from_entity(&quot;Task&quot;, 13155)Part 4: Creating FoldersToolkit can dynamically generate a folder structure on disk based upon your project entities.This fulfills two purposes.  You get an organized structure created on disk where you can place your files.  It allows Toolkit to programmatically understand your structure, derive context from it, and know where to place files.You need to ensure that the folders exist on disk so that you can resolve the path in a later step.You will use the Sgtk.create_filesystem_structure() method to achieve this:tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])You can use the context object to get the task id to generate the folders.Your code should now look like this:import sgtk# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task, this Task must belong to a Shot for the future steps to work. context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the task.tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])You’ve now completed all the preparation steps and are ready to move onto generating a path using a template.Part 5: Using a template to build a pathGenerating the pathWhenever you need to know where a file should be placed or found in Toolkit you can use the templates to resolve an absolute path on disk.Templates are essentially tokenized strings that when you apply the context and other data to, can be resolved into filesystem paths.They are customizable via your project’s pipeline configuration, and their purpose is to provide a standardized method for working out where files should be stored.The first thing you need to do is get a template instance for the path you wish to generate.Using the Sgtk instance you created, you can access the desired Template instance via the Sgtk.templates attribute, which is a dictionary where the keys are the template names, and the values are Template instances.template = tk.templates[&quot;maya_shot_publish&quot;]In this example, you will use the maya_shot_publish template. In the Default Configuration the unresolved template path looks like this:'sequences/{Sequence}/{Shot}/{Step}/work/maya/{name}.v{version}.{maya_extension}'The template is made up of keys that you will need to resolve into actual values.Since the context contains enough information for the majority of the keys, you can start by using that to extract values:fields = context.as_template_fields(template)&amp;gt;&amp;gt; {'Sequence': 'seq01_chase', 'Shot': 'shot01_running_away', 'Step': 'comp'}The Context.as_template_fields() method gives you a dictionary with the correct values to resolve the template keys. However, it hasn’t provided values for all the keys. The name, version and maya_extension are still missing.The maya_extension key defines a default value in the template keys section so you don’t need to provide a value for that, although you could if you wanted a value other than the default.Which leaves the name and version. Since the name is a matter of choice, you can either hard code a default or provide an opportunity for the user to enter a value, for example, by popping up an interface.For now, you will hard code both, but in the next step, we’ll cover how to find the next available version number.fields[&quot;name&quot;] = &quot;myscene&quot;fields[&quot;version&quot;] = 1Now you have all the fields, you’re ready to resolve the template into an absolute path using Template.apply_fields():publish_path = template.apply_fields(fields)&amp;gt;&amp;gt; /sg_toolkit/mysite.shotgunstudio.com/my_project/sequences/seq01_chase/shot01_running_away/comp/publish/maya/myscene.v001.maEnsuring the folders existAlthough you ran the folder creation method earlier you may need to perform an additional step to ensure that all the folders exist.This can be required if, for example, your template defines folders that are not present in the schema, and so were not created in the original create_filesystem_structure() call.There are a couple of convenience methods you can use to do this.If, your code is running in a Toolkit app or hook you can use the Application.ensure_folder_exists() method.If, there is an engine present you can use Engine.ensure_folder_exists() method.Or if you’re running code outside of an engine, there’s sgtk.util.filesystem.ensure_folder_exists().Make sure to only create the folders for the directory and not the full file path.You can import the os module and run os.path.dirname(publish_path) to extract the folder portion of the full file path.Creating or copying a file using the pathAt this point you have a path, and you could use this, for example, to tell Maya to save a file there, or perhaps copy the file from a different location. It’s not important for the sake of this guide that you implement any behavior that actually creates a file on disk in that location.You can still publish the path even if there is no file there. However, you can use sgtk.util.filesystem.touch_file() to get Toolkit to create an empty file on disk.Bringing it all together so farimport sgtkimport os# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work. context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the task.tk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])# Get a template instance by providing a name of a valid template in your config's templates.yml.template = tk.templates[&quot;maya_shot_publish&quot;]# Use the context to resolve as many of the template fields as possible.fields = context.as_template_fields(template)# Manually resolve the remaining fields that can't be figured out automatically from context.fields[&quot;name&quot;] = &quot;myscene&quot;fields[&quot;version&quot;] = 1# Use the fields to resolve the template path into an absolute path.publish_path = template.apply_fields(fields)# Make sure we create any missing folders.current_engine.ensure_folder_exists(os.path.dirname(publish_path))# Create an empty file on disk. (optional - should be replaced by actual file save or copy logic)sgtk.util.filesystem.touch_file(publish_path)The next step is to dynamically work out the next version number rather than hard coding it.Part 6: Finding existing files and getting the latest version numberThere two methods you could use here.  Since in this particular example you are resolving a publish file, you could use the ShotGrid API to query for the next available version number on PublishedFile entities.  You can scan the files on disk and work out what versions already exist, and extract the next version number. This is helpful if the files you’re working with aren’t tracked in ShotGrid (such as work files).While the first option would probably be most suitable for the example in this guide, both approaches have their uses so we’ll cover them both.Querying ShotGrid for the next version number.Using the ShotGrid API and the summarize() method you can get the highest version number amongst the PublishedFile entities, that share the same name and task, and then add 1.r = sg.summarize(entity_type=&quot;PublishedFile&quot;,                 filters = [[&quot;task&quot;, &quot;is&quot;, {&quot;type&quot;:&quot;Task&quot;, &quot;id&quot;: context.task[&quot;id&quot;]}],                            [&quot;name&quot;,&quot;is&quot;, fields[&quot;name&quot;] + &quot;.ma&quot;]],                 summary_fields=[{&quot;field&quot;:&quot;version_number&quot;, &quot;type&quot;:&quot;maximum&quot;}])# Extract the version number and add 1 to it.# In scenarios where there are no files already this summary will return 0.# Apply the version number to the fields dictionary, that will be used to resolve the template into a path.fields[&quot;version&quot;] = r[&quot;summaries&quot;][&quot;version_number&quot;] + 1Searching the file system for the next version number.Using the Toolkit API you can gather a list of existing files, extract the template field values from them, and then figure out the next version.In the example below, it’s gathering the latest version from the work file template. Assuming the work file template and publish file template have the same fields, you could call the method below twice with the same fields to work out the highest publish and work file version and decide using a combination of the two.def get_next_version_number(tk, template_name, fields):    template = tk.templates[template_name]    # Get a list of existing file paths on disk that match the template and provided fields    # Skip the version field as we want to find all versions, not a specific version.    skip_fields = [&quot;version&quot;]    file_paths = tk.paths_from_template(                 template,                 fields,                 skip_fields,                 skip_missing_optional_keys=True             )    versions = []    for a_file in file_paths:        # extract the values from the path so we can read the version.        path_fields = template.get_fields(a_file)        versions.append(path_fields[&quot;version&quot;])        # find the highest version in the list and add one.    return max(versions) + 1# Set the version number in the fields dictionary, that will be used to resolve the template into a path. fields[&quot;version&quot;] = get_next_version_number(tk, &quot;maya_shot_work&quot;, fields)The sgtk.paths_from_template() method will gather all the files on disk that match the provided template and fields.This is method is also useful for scenarios where you want to find and display a list of files to the user.You can chose to use either option, but the guide will use the code from option one however to keep it simple.Part 7: Registering a published fileNow that you have a path you’re ready to publish it. To do this you can use the utility method sgtk.util.register_publish().It is possible to use the ShotGrid API’s ShotGrid.create() method to create a PublishedFile entity as well, but we strongly recommend using the Toolkit API for this as it will ensure all the required fields are provided and filled in correctly.# So as to match the Publish app's default behavior, we are adding the extension to the end of the publish name.# This is optional, however.publish_name = fields[&quot;name&quot;] + &quot;.ma&quot;version_number = fields[&quot;version&quot;]# Now register the publishsgtk.util.register_publish(tk,                           context,                           publish_path,                           publish_name,                           version_number,                           published_file_type = &quot;Maya Scene&quot;)At this point, it’s also worth noting that our Publish app also comes with its own API as well.Although that is still essentially using this same sgtk.util.register_publish() method, it builds upon the publishing process by providing a framework to handle collection, validation, and publishing.Part 8: The complete script# Initialization# ==============import sgtkimport os# Get the engine instance that is currently running.current_engine = sgtk.platform.current_engine()# Grab the pre-created Sgtk instance from the current engine.tk = current_engine.sgtk# Get a context object from a Task. This Task must belong to a Shot for the future steps to work. context = tk.context_from_entity(&quot;Task&quot;, 13155)# Create the required folders based upon the tasktk.create_filesystem_structure(&quot;Task&quot;, context.task[&quot;id&quot;])# Generating a Path# =================# Get a template instance by providing a name of a valid template in your config's templates.ymltemplate = tk.templates[&quot;maya_shot_publish&quot;]# Use the context to resolve as many of the template fields as possible.fields = context.as_template_fields(template)# Manually resolve the remaining fields that can't be figured out automatically from context.fields[&quot;name&quot;] = &quot;myscene&quot;# Get an authenticated Shotgun API instance from the enginesg = current_engine.shotgun# Run a Shotgun API query to summarize the maximum version number on PublishedFiles that# are linked to the task and match the provided name.# Since PublishedFiles generated by the Publish app have the extension on the end of the name we need to add the# extension in our filter.r = sg.summarize(entity_type=&quot;PublishedFile&quot;,                 filters = [[&quot;task&quot;, &quot;is&quot;, {&quot;type&quot;:&quot;Task&quot;, &quot;id&quot;: context.task[&quot;id&quot;]}],                            [&quot;name&quot;,&quot;is&quot;, fields[&quot;name&quot;] + &quot;.ma&quot;]],                 summary_fields=[{&quot;field&quot;:&quot;version_number&quot;, &quot;type&quot;:&quot;maximum&quot;}])# Extract the version number and add 1 to it.# In scenarios where there are no files already this summary will return 0.# Apply the version number to the fields dictionary, that will be used to resolve the template into a path.fields[&quot;version&quot;] = r[&quot;summaries&quot;][&quot;version_number&quot;] + 1# Use the fields to resolve the template path into an absolute path.publish_path = template.apply_fields(fields)# Make sure we create any missing folderscurrent_engine.ensure_folder_exists(os.path.dirname(publish_path))# Creating a file# ===============# This is the bit where you would add your own logic to copy or save a file using the path.# In the absence of any file saving in the example, we'll use the following to create an empty file on disk.sgtk.util.filesystem.touch_file(publish_path)# Publishing# ==========# So as to match publishes created by the Publish app's, we are adding the extension to the end of the publish name.publish_name = fields[&quot;name&quot;] + &quot;.ma&quot;version_number = fields[&quot;version&quot;]# Now register the publishsgtk.util.register_publish(tk,                           context,                           publish_path,                           publish_name,                           version_number,                           published_file_type = &quot;Maya Scene&quot;)                    Tip: By this point, the code is getting a bit long, so a recommended next step would be to tidy it up a bit and break things into methods.    Final ThoughtsThis guide has hopefully left you with a foundational understanding of how to get started with the Toolkit API.There are of course many other uses for the API, so we recommend reading through the tk-core API for more information.Also our forums are an excellent place to discuss API questions and get answers, and even leave feedback for us about the this guide.",
    "url": "/836446f3/",
    "relUrl": "/836446f3/"
  },
  "125": {
    "id": "125",
    "title": "Integrations Developer Guide",
    "content": "Integrations Developer GuidePanelsSee https://github.com/shotgunsoftware/tk-multi-shotgunpanel/tree/master/hooks  for examples of panel actions.Configuring what is being displayedThe values in the detail area and the listings are both configurable through the shotgun_fields hook. You can subclass this hook and change the implementation in order to display the exact values you want.Templating SystemThe hook supports a simple templating language, allowing for great flexibility. It also supports the HTML subset supported by Qt, so you can control color, font size, weight, etc. of your displayed values.The template language works in the following way:      ShotGrid values are enclosed in {brackets}, for example &amp;lt;b&amp;gt;Description:&amp;lt;/b&amp;gt; {description}. When this template is rendered, the {description} part will be replaced with the description field value.        If you want an optional pre- or post-fix for a value which is only shown if the value is not empty, you can use the syntax {[Prefix]sg_field[suffix]}. The template {[Start: ]start_date} {[End: ]end_date} will render Start: 12 July 2009 End: 14 July 2012 if both values are populated but Start: 12 July 2009 if end date isn’t set.        You can define fallbacks in the case some values are not set. For ShotGrid Versions, the artist fields takes precedence over the created_by field in order to support a workflow where a producer submits versions on behalf of an artist. In this case, the Version will be created by the producer but the artist field will be set to the artist. This, however, is not always the case - in some cases, artist is left blank in pipelines where artists submit their own work. When displaying versions, it is therefore useful to be able to check the artist field first, and in case this isn’t set, fall back on the created_by field. This is done using the {field1|field2} syntax, for example: Created By: {artist|created_by}. You can combine this with optional fields too, e.g. {[Created By: ]artist|created_by}.  This hook contains the following methods:Controlling items appearing in listsThe get_list_item_definition() method returns a dictionary that controls the appearance of items in the various listings, given a ShotGrid entity type. It returns a dictionary with the keys top_left, top_right and body, for example:{ &quot;top_left&quot;: &quot;&amp;lt;big&amp;gt;{code}&amp;lt;/big&amp;gt;&quot;, &quot;top_right&quot;: &quot;{updated_at}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}Controlling the top detail areaThe get_main_view_definition() method returns a dictionary with the keys title and body given a ShotGrid entity type. These values controls the appearance of an object in the detail area, for example:{ &quot;title&quot;: &quot;{type} {code}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;}Controlling the fields shown in the Info tabThe get_all_fields() methods returns a list of fields to display for a given entity when this is rendered in the Info tab.Configuring ActionsActions are little snippets of code that operate on a piece of ShotGrid data. Examples include:  An action that launches RV for a given ShotGrid Version  An action that allows a user to assign herself to a given Task  An action that loads a ShotGrid publish into Maya as a Maya reference.The actual payload of an action is defined in an  action hook. Once you have defined the action logic, you can then map that action to ShotGrid objects in the app configuration. These action mappings may for example look like this:action_mappings:  PublishedFile:  - actions: [reference, import]    filters: {published_file_type: Maya Scene}  - actions: [texture_node]    filters: {published_file_type: Rendered Image}  Task:  - actions: [assign_task]    filters: {}  Version:  - actions: [play_in_rv]    filters: {}In the above example, we use the actions reference, import, texture_node, assign_task and play_in_rv. We then map the actions to various ShotGrid objects and conditions. For example, we are requesting the import action to appear for all publishes of type Maya Scene.When an object is loaded into the Panel, the action configuration above is read in and analyzed. A list of suitable actions for the current object is determined and the generate_actions() hook method will be executed. ShotGrid data for the given entity will be passed to the hook at this point so that the hook code can determine if the action can be run for this particular ShotGrid object. This is a way to allow each hook to run a check prior to being displayed. For example, the play_in_rv hook may only be relevant in the case there is media available locally - the action mappings set up in the configuration tells the panel which actions to enable for a given ShotGrid entity but they may not all be displayed because the generate_actions() method may determine that they are not suitable for the given object.The actions returned from the generate_actions() method will be displayed on the actions menu and when a user clicks on it, the execute_acton() hook method is called to run the action.For each application that the panel supports, there is an actions hook which implements suitable actions. For example, with something like Maya, the default hook will implement reference, import and texture_nodeactions, each carrying out specific Maya commands to bring publishes into the current Maya scene. As with all hooks, it is perfectly possible to override and change these, and it is also possible to create a hook that derives from the built in hook, making it easy to add additional actions to a built-in hook without having to duplicate lots of code.The panel uses Toolkit’s second generation hooks interface, allowing for greater flexibility. This hook format uses an improved syntax. You can see this in the default configuration settings, looking something like this:actions_hook: '{self}/tk-maya_actions.py'The {self} keyword tells Toolkit to look in the app’s hooks folder for the hook. If you are overriding this hook with your implementation, change the value to {config}/panel/maya_actions.py. This will tell Toolkit to use a hook called hooks/panel/maya_actions.py in your configuration folder.For more information, please see the hook files that come with the app. The hooks also take advantage of inheritance, meaning that you don’t need to override everything in the hook, but can more easily extend or augment the default hook in various ways, making hooks easier to manage.Learn more about the second gen hook format here.By using inheritance in your hook, it would be possible to add additional actions to the default hooks like this:import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_data, actions, ui_area):        &quot;&quot;&quot; Returns a list of action instances for a particular object. The data returned from this hook will be used to populate the  actions menu. The mapping between ShotGrid objects and actions are kept in a different place (in the configuration) so at the point when this hook is called, the app has already established *which* actions are appropriate for this object. This method needs to return detailed data for those actions, in the form of a list of dictionaries, each with name, params, caption and description keys. Because you are operating on a particular object, you may tailor the output  (caption, tooltip etc) to contain custom information suitable for this publish. The ui_area parameter is a string and indicates where the publish is to be shown.  - If it will be shown in the main browsing area, &quot;main&quot; is passed.  - If it will be shown in the details area, &quot;details&quot; is passed. :param sg_data: ShotGrid data dictionary with all the standard publish fields. :param actions: List of action strings which have been defined in the app configuration. :param ui_area: String denoting the UI Area (see above). :returns List of dictionaries, each with keys name, params, caption and description &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_data):        &quot;&quot;&quot; Execute a given action. The data sent to this be method will represent one of the actions enumerated by the generate_actions method. :param name: Action name string representing one of the items returned by generate_actions. :param params: Params data, as specified by generate_actions. :param sg_data: ShotGrid data dictionary with all the standard publish fields. :returns: No return value expected. &quot;&quot;&quot;        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_data)We could then bind this new action to a set of publish types in the configuration:action_mappings:  PublishedFile:  - actions: [reference, import, my_new_action]    filters: {published_file_type: Maya Scene}  Version:  - actions: [play_in_rv]    filters: {}By deriving from the hook as shown above, the custom hook code only need to contain the actual added business logic which makes it easier to maintain and update.PublisherThe Publish app is highly customizable by way of hooks that control how items are presented to artists for publishing and how those items are then processed.The full developer documentation for the publisher app can now be found on the  Toolkit Developer Site.For more information on how to use the Publish app, see the User Guide.LoaderSee https://github.com/shotgunsoftware/tk-multi-loader2/tree/master/hooks for examples of load actions.Advanced functionalityShotGrid Toolkit makes it easy to develop toolsDid we mention that you can write your own Apps? Each Engine exposes a consistent interface based on Python and PySide, so you can write a single App that works in both Nuke, Photoshop and 3dsmax. With the Core API functionality, there is no need to build a big pipeline stack for the studio - instead focus dev resources on solving production problems. Reusing tools between projects is easy with our Toolkit - if file naming conventions or other requirements are changing, simply reconfigure the app. Roll out tools safely via the Toolkit’s built-in Git and Github support and quickly hot-load your code when doing development. Work in your own Dev Sandbox and invite TDs and early adopters to test your code without having to roll it out to everyone on the project.",
    "url": "/93c6e555/",
    "relUrl": "/93c6e555/"
  },
  "126": {
    "id": "126",
    "title": "How to Submit Integrations Fixes",
    "content": "How to Submit Integrations FixesWe welcome contributions from the Toolkit community! If you have a potential fix for a bug you’ve discovered or have implemented a feature you think we should include, we welcome you to follow the guidelines below in order to sent it through the right channels.Talk to UsWe encourage you to talk to us about what you want to develop or fix. We may have information that will help steer you in the right direction, or prevent you from doing a lot of unnecessary work. Most importantly, we love talking to our users about what they want to build, how they use Toolkit, and how we can make it more awesome.Fork the Repo from GithubMost of the Toolkit engine, app, and framework code is developed in the public on Github. Fork the repo you’re modifying from Github to your local environment.Make Your ChangesDo your development work locally in a branch and test it out in your own environment to the point you feel confident that it’s ready to submit to us. Try and match the style of the existing codebase. Keep your changes focused on your purpose. For example, if you’re fixing a bug in 3 lines of code, don’t try and modify whitespace issues throughout the file. That will make the Toolkit gremlins angry.Comment!Make sure you add detailed comments about what it is you’re doing any why you’re doing it. Keep in mind, there will be other people like you who may fork this repo later and will need to understand what your code does and why. Be clear, but don’t over-comment either. :)TestRemember that other users will have a wide variety of environments and variables in play that may not match what you have at your studio. Toolkit tries to minimize the impact of these types of things for users but there are always things that could be different in other users’ environments. Some examples:  Will your code work the same on OS X, Windows, and Linux?  Will it work in all supported versions of a Software?  Will it work the same whether the user launches from a terminal, SG Desktop, ShotGrid, or perhaps their own custom app?Create a Pull RequestOnce you’re ready, push your changes back to Github and create a pull request. Your pull request should be detailed, explain what your code does, and why the changes are required. When writing this up, think about the user who is coming into this with very little knowledge about this area of code. The public will see your pull request and other users will be happy to understand your well written description!Then What?We will review your pull request when we have time in our sprint. It’s very likely we’ll comment and ask questions about your code or use case. We may kick back the request and ask you to make changes. Don’t be offended! We love contributions but also have deep knowledge about how things will work. We are in this code every day so we don’t expect everyone to submit perfect code.Once we review it, if we accept your pull request, we’ll queue it for QA and then it will be merged into our repo and released at some point. The timeline can vary depending on a lot of factors. Please be patient.We may also politely turn down your pull request. Again, please don’t be offended. We appreciate your efforts and contribution. There can be any number of factors that contribute to this. But if you follow the guidelines above, hopefully this won’t happen.",
    "url": "/924c14e8/",
    "relUrl": "/924c14e8/"
  },
  "127": {
    "id": "127",
    "title": "How do I work with authentication and login credentials in custom scripts?",
    "content": "How do I work with authentication and login credentials in custom scripts?Error MessageIf you’re seeing an error like the one below coming from your script, then it means your script is not authorized to talk to your ShotGrid site.tank.errors.TankError: Missing required script user in config '/path/to/your/project/config/core/shotgun.yml'If user authentication or script authentication is not provided up front, then Toolkit falls back to checking credentials have been defined in the config’s shotgun.yml file.Defining credentials in your shotgun.yml file is the old method of handling authentication.You should avoid defining them in the shotgun.yml file, and instead use one of the approaches detailed below:User-facing scriptsIf the script is user-facing, you can add this at the beginning, before creating a Sgtk instance:# Import the Toolkit API so we can access Toolkit specific features.import sgtk# Import the ShotgunAuthenticator from the tank_vendor.shotgun_authentication# module. This class allows you to authenticate either programmatically or, in this# case, interactively.from tank_vendor.shotgun_authentication import ShotgunAuthenticator# Instantiate the CoreDefaultsManager. This allows the ShotgunAuthenticator to# retrieve the site, proxy and optional script_user credentials from shotgun.ymlcdm = sgtk.util.CoreDefaultsManager()# Instantiate the authenticator object, passing in the defaults manager.authenticator = ShotgunAuthenticator(cdm)# Optionally clear the current user if you've already logged in before.authenticator.clear_default_user()# Get an authenticated user. In this scenario, since we've passed in the# CoreDefaultsManager, the code will first look to see if there is a script_user inside# shotgun.yml. If there isn't, the user will be prompted for their username,# password and optional 2-factor authentication code. If a QApplication is# available, a UI will pop-up. If not, the credentials will be prompted# on the command line. The user object returned encapsulates the login# information.user = authenticator.get_user()# print &quot;User is '%s'&quot; % user# Tells Toolkit which user to use for connecting to ShotGrid. Note that this should# always take place before creating a Sgtk instance.sgtk.set_authenticated_user(user)## Add your app code here...## When you are done, you could optionally clear the current user. Doing so# however, means that the next time the script is run, the user will be prompted# for their credentials again. You should probably avoid doing this in# order to provide a user experience that is as frictionless as possible.authenticator.clear_default_user()If QApplication is available, you’ll get something akin to this:                    Note: If you are importing a Toolkit API (sgtk package) that isn’t associated with a configuration, for example one that you have downloaded to use to bootstrap into a different configuration, then you shouldn’t attempt to create a CoreDefaultsManager. Instead, create a ShotgunAuthenticator() instance without passing a defaults manager.authenticator = ShotgunAuthenticator()    Non-user-facing scriptsIf the script is not user-facing, like on a render farm or in the event handler, you can add this at the beginning, before creating a Sgtk/Tank instance:# Import Toolkit so we can access to Toolkit specific features.import sgtk# Import the ShotgunAuthenticator from the tank_vendor.shotgun_authentication# module. This class allows you to authenticate either interactively or, in this# case, programmatically.from tank_vendor.shotgun_authentication import ShotgunAuthenticator# Instantiate the CoreDefaultsManager. This allows the ShotgunAuthenticator to# retrieve the site, proxy and optional script_user credentials from shotgun.ymlcdm = sgtk.util.CoreDefaultsManager()# Instantiate the authenticator object, passing in the defaults manager.authenticator = ShotgunAuthenticator(cdm)# Create a user programmatically using the script's key.user = authenticator.create_script_user(    api_script=&quot;Toolkit&quot;,    api_key=&quot;4e48f....&amp;lt;use the key from your ShotGrid site&amp;gt;&quot;)# print &quot;User is '%s'&quot; % user# Tells Toolkit which user to use for connecting to ShotGrid.sgtk.set_authenticated_user(user)                    Note: As noted at the end of the user facing scripts section, you shouldn’t create a defaults manager if the sgtk package you imported is standalone/isn’t from a configuration. Also you should provide the host kwarg to the create_script_user() method:user = authenticator.create_script_user(    host=&quot;https://yoursite.shotgunstudio.com&quot;,    api_script=&quot;Toolkit&quot;,    api_key=&quot;4e48f....&amp;lt;use the key from your Shotgun site&amp;gt;&quot;)    ",
    "url": "/724152ce/",
    "relUrl": "/724152ce/"
  },
  "128": {
    "id": "128",
    "title": "How do I share assets between projects?",
    "content": "How do I share assets between projects?It is common to have a project that is used as an Asset Library, containing assets that can be loaded into shots in other projects.With the introduction of the Linked Projects field on the Asset entity, you can now add a single tab to the Loader app that includes all Linked Projects. In order to do so, you’ll have to define this in the Loader settings for the engine and environment you’re working in. You’ll potentially have to update this in multiple places.- caption: Assets - Linked    entity_type: Asset    filters:      - [linked_projects, is, &quot;{context.project}&quot;]    hierarchy: [project.Project.name, sg_asset_type, code]You can refer to the Alias Engine settings in the tk-multi-loader2.yml configuration file included with tk-config-default2 as it is the default behavior there.Before introducing the Linked Projects field on Assets, the initial way to achieve cross-Project sharing was to add a tab to the Loader app that lists assets from a specific Asset Library project.For example, to add this to the Maya engine in the shot step environment, you’d add this snippet:- caption: Asset Library    hierarchy: [project, sg_asset_type, code]    entity_type: Asset    filters:      - [project, is, {'type': 'Project', 'id': 207}]replacing 207 with your library project’s ID.When you’re working in the shot step environment in Maya now, this will add a new tab that will display all the available publishes in that project. If you want to add this tab to the Loader in other engines (e.g., Nuke, 3dsmax, etc.) you’ll have to modify the tk-multi-loader2 settings for each of those engines as well. If you want to enable this in other environments, you’ll have to go through the same steps in the asset step environment, and any other environments you want it to be in. A bit tedious, but it allows some fine-grain control.With these settings, you should get the Loader app to show a tab that lists publishes from your identified project.                    Note: This initial technique is still included here as it does offer a way to have a different tab per Project identified within the Loader.    To learn more about web-based cross-Project Asset linking, visit our Cross-Project Asset Linking documentation here.",
    "url": "/2088a677/",
    "relUrl": "/2088a677/"
  },
  "129": {
    "id": "129",
    "title": "Overview",
    "content": "ShotGrid DevelopmentManaging a production takes a lot of work to keep all the moving pieces in sync.Use our ShotGrid REST API or Python API to connect directly to your data, the Event Trigger Framework to automate repetitive tasks, and Action Menu Items to launch your apps directly from ShotGrid’s web interface.We encourage you to use ShotGrid APIs to develop your own services, applications, modules, and components that operate on or with the Service for your own and your Authorized Users’ use.                    Authentication Keys: We ask that you do not disclose (and do not permit your Authorized Users to disclose) API Information that includes authentication keys or other means that could allow users to access the Service or its functionality without a log on, or use the APIs yourself to access or allow users to access the Service or its functionality without a log on.    ",
    "url": "/6dfa5d53/",
    "relUrl": "/6dfa5d53/"
  },
  "130": {
    "id": "130",
    "title": "Migration Test Site",
    "content": "ShotGrid Migration Test SiteActivating the isolation feature set is an intrusive procedure that can have an impact on the usability of your site. To prevent a production stopping event, we require clients to follow an approach where the configuration is first validated on a test site, before being applied to the production site.The ShotGrid team will create a temporary site to be used as a Proof of Concept for your ShotGrid Isolation deployment. Upon the successful completion of the setup process, your existing ShotGrid site can be migrated to your ShotGrid Isolation environment.If your Migration Test Site has not been created yet, please reach out to our Support team through your Zendesk ticket or your dedicated on-boarding Slack Channel.Next StepsOnce you have your test site, you can the implementation of the feature you need.See Media Isolation for activating the Media Isolation feature.See Web Traffic Isolation for activating the Web Traffic Isolation feature.Go to Setup for an overview of the possible next steps.",
    "url": "/0bbe0010/",
    "relUrl": "/0bbe0010/"
  },
  "131": {
    "id": "131",
    "title": "SSLHandshakeError CERTIFICATE_VERIFY_FAILED certificate verify failed",
    "content": "SSLHandshakeError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failedUse caseOn a local network set up with a firewall that does local packet inspection, you can get the following error message:SSLHandshakeError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)This error occurs due to firewalls often getting configured with a self-signed certificate that your network administrator created themselves, and that Python does not have access to. Unfortunately, unlike other applications, Python does not always look inside the OS’s keychain for certificates, so you have to provide it yourself.How to fixYou need to set the SHOTGUN_API_CACERTS environment variable to point to a file on disk that contains the complete list of certificate authorities the Python API and Shotgun Desktop can trust.You can download such a copy from the latest copy of the certifi package on Github. Once you’ve done this, you need to add the public key of your corporate firewall at the bottom of that file and save it.Once this is done, simply set SHOTGUN_API_CACERTS environment variable to the path location, e.g. /opt/certs/cacert.pem and launch the Shotgun Desktop.Related linksSee the full thread in the community",
    "url": "/4528ba21/",
    "relUrl": "/4528ba21/"
  },
  "132": {
    "id": "132",
    "title": "WARNING Storage Root Primary Could Not Be Mapped to a SG Local Storage",
    "content": "WARNING: Storage Root Primary Could Not Be Mapped to a SG Local StorageUse caseWhen attempting to set up a project and use Google Drive as primary storage using Drive File stream, the Project Wizard issues a warning in the console when accessing the storage configuration:[WARNING] Storage root primary could not be mapped to a SG local storagePressing continue does not work.How to fixThis issue can be caused when there is a typo in the storage name.  Ensure it matches exactly the name of the Google Drive.In addition, when using Google Drive, ensure it is set to always keep files locally, to avoid duplicate projects appearing.Related LinksSee the full thread in the community",
    "url": "/a59c77b9/",
    "relUrl": "/a59c77b9/"
  },
  "133": {
    "id": "133",
    "title": "Cannot resolve template data for context",
    "content": "TankError: Cannot resolve template data for contextUse CaseWhen doing an advanced project setup on a new project and using the standalone Publisher app from ShotGrid Desktop to publish some images for a new asset task I’ve created, after selecting the context to validate the publish, the following error is presented:creation for %s and try again!&quot; % (self, self.shotgun_url))TankError: Cannot resolve template data for context ‘concept, Asset door-01’ - this context does not have any associated folders created on disk yet and therefore no template data can be extracted. Please run the folder creation for and try again!Running tank.bat Asset door-01 folders in a terminal resolved this. However, this has never happened on any previous projects.How to fixThis may have happened due to this being the first time attempting to standalone publish for a new entity/task without going through a DCC first.The reason it probably did not happened before is because you’ve started work on the asset in a Software prior to using the standalone publisher, so the folders have already been created/synced. Launching a Software (via Toolkit) will create the folders for the context you launch in, and the open app will create the folders for the context you start a new file in. So usually you don’t need to specifically create folders.A common practice is that studios generally create folders manually after the shots/assets have been added in ShotGrid.Keep in mind also that this is affected by your “folder schema”, which can cause weird issues if it doesn’t completely match the templates.Related linksSee the full thread in the community",
    "url": "/5cdbc2a3/",
    "relUrl": "/5cdbc2a3/"
  },
  "134": {
    "id": "134",
    "title": "TankError Tried to Resolve a Path From The Template",
    "content": "TankError: Tried to resolve a path from the templateUse case 1When setting up a new configuration for SGTK, trying to create a new file through the File Open dialog (in tk-multi-workfiles2), you get the following error:TankError: Tried to resolve a path from the template &amp;lt;Sgtk TemplatePath asset_work_area_maya:Use case 2When trying to save in certain tasks, you get the error:TankError: Tried to resolve a path from the template &amp;lt;Sgtk TemplatePath nuke_shot_work:How to fixFor case 1: Check the asset.yml file, it may be missing a filter: - { &quot;path&quot;: &quot;sg_asset_type&quot;, &quot;relation&quot;: &quot;is&quot;, &quot;values&quot;: [ &quot;$asset_type&quot;] }For case 2: This can be caused by a Sequence getting renamed, and leaving behind a few FilesystemLocations, which were confusing toolkit.The fix:  Delete stale FilesystemLocations in Shotgun  Unregister folders related to stale FilesystemLocations from Toolkit  Register folders again from ToolkitRelated linksSee the full thread in the community hereand also in this community thread here.",
    "url": "/ea55eac2/",
    "relUrl": "/ea55eac2/"
  },
  "135": {
    "id": "135",
    "title": "You are loading the Toolkit platform from the pipeline configuration located in",
    "content": "TankInitError: You are loading the Toolkit platform from the pipeline configuration located inUse CaseWhen running some code to publish files from an app, there are times the files belong to a different project.Is it possible to get around the TankInitError: You are loading the Toolkit platform from the pipeline configuration located in error?Ideally, it’s possible to find the context from the path to properly register these files (even if they belong in a different project).How to fixUse the following function:def get_sgtk(proj_name, script_name):    &quot;&quot;&quot; Load sgtk path and import module    If sgtk was previously loaded, replace include paths and reimport    &quot;&quot;&quot;    project_path = get_proj_tank_dir(proj_name)    sys.path.insert(1, project_path)    sys.path.insert(1, os.path.join(        project_path,        &quot;install&quot;, &quot;core&quot;, &quot;python&quot;    ))    # unload old core    for mod in filter(lambda m: m.startswith(&quot;sgtk&quot;) or m.startswith(&quot;tank&quot;), sys.modules):        sys.modules.pop(mod)        del mod    if &quot;TANK_CURRENT_PC&quot; in os.environ:        del os.environ[&quot;TANK_CURRENT_PC&quot;]    import sgtk    setup_sgtk_auth(sgtk, script_name)    return sgtkThe key is deleting all sgtk-related modules from sys.modules and removing TANK_CURRENT_PC from the environment. This is outlined in How can I load different Toolkit Core modules using the shotgunEvent daemon?Related linksSee the full thread in the community",
    "url": "/a2befe6a/",
    "relUrl": "/a2befe6a/"
  },
  "136": {
    "id": "136",
    "title": "Isolation Features",
    "content": "Isolation Feature SetThe isolation feature set is an hybrid solution that satisfies strict security and legal requirements, while minimizing ShotGrid System Admin specific required knowledge and maintenance. These features enable creative studios to confidently meet their supplier’s and studio’s highly stringent security, privacy, and performance requirements—from the cloud.Continue to About the isolation feature set for more details.Go to Setup if you are ready to activate the Isolation features.In This SectionGetting Started  About Isolation  Client Responsibilities  Onboarding Process  Planning your SetupFeatures Description  Media Isolation  Media Traffic Isolation  Media ReplicationSetup  Setup Overview  Media Isolation  Media Traffic Isolation  Media Replication  Isolation Fine Tuning  ActivationAWS Knowledge  Connecting Your Studio With Your AWS VPC  ShotGrid AWS Direct Connect Onboarding  S3  VPC / IAM / Security Group  Direct Connect  Private Link  VPC Endpoints  AWS Knowledge",
    "url": "/f378a164/",
    "relUrl": "/f378a164/"
  },
  "137": {
    "id": "137",
    "title": "3ds Max Plus",
    "content": "3dsMax PlusThe ShotGrid engine for 3ds Max Plus provides a bridge between the 3ds Max application and the ShotGrid Pipeline Toolkit. The engine supports PySide and all Multi apps, meaning that you can run our standard apps inside of 3ds Max - the same apps that also work in Maya, Nuke etc. This engine uses the 3ds Max Plus python API.Supported Application VersionsThis item has been tested and is known to be working on the following application versions:2020 - 2023DocumenationThis engine connects ShotGrid Pipeline Toolkit (Sgtk) and 3D studio Max via Max Plus’ Python support.Installation and UpdatesAdding this Engine to the ShotGrid Pipeline Toolkitf you want to add this engine to Project XYZ, and an environment named asset, execute the following command:&amp;gt; tank Project XYZ install_engine asset tk-3dsmaxplusUpdating to the latest versionIf you already have this item installed in a project and you want to get the latest version, you can run the update command. You can either navigate to the tank command that comes with that specific project, and run it there:&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updatesAlternatively, you can run your studio tank command and specify the project name to tell it which project to run the update check for:&amp;gt; tank Project XYZ updatesCollaboration and EvolutionIf you have access to the ShotGrid Pipeline Toolkit, you also have access to the source code for all apps, engines and frameworks in Github where we store and manage them. Feel free to evolve these items; use them as a base for further independent development, make changes (and submit pull requests back to us!) or simply tinker with them to see how they have been built and how the toolkit works. You can access this code repository at https://github.com/shotgunsoftware/tk-3dsmaxplus.Special RequirementsYou need ShotGrid Pipeline Toolkit Core API version v0.19.18 or higher to use this.",
    "url": "/7112d6a1/",
    "relUrl": "/7112d6a1/"
  },
  "138": {
    "id": "138",
    "title": "3ds Max",
    "content": "3dsMaxThe ShotGrid engine for 3dsMax contains a standard platform for integrating ShotGrid Toolkit (Sgtk) Apps into 3dsMax. It is light weight, straight forward and adds a ShotGrid menu to the main menu.Supported Application VersionsThis item has been tested and is known to be working on the following application versions:2020 - 2023DocumenationThe ShotGrid engine for 3dsMax contains a standard platform for integrating ShotGrid Pipeline Toolkit (Sgtk) Apps into 3dsMax. It is light weight, straight forward and adds a ShotGrid menu to the main menu.Installation and UpdatesAdding this Engine to the ShotGrid Pipeline ToolkitIf you want to add this engine to Project XYZ, and an environment named asset, execute the following command:&amp;gt; tank Project XYZ install_engine asset tk-3dsmaxUpdating to the latest versionIf you already have this item installed in a project and you want to get the latest version, you can run the update command. You can either navigate to the tank command that comes with that specific project, and run it there:&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updatesAlternatively, you can run your studio tank command and specify the project name to tell it which project to run the update check for:&amp;gt; tank Project XYZ updatesCollaboration and EvolutionIf you have access to the ShotGrid Pipeline Toolkit, you also have access to the source code for all apps, engines and frameworks in Github where we store and manage them. Feel free to evolve these items; use them as a base for further independent development, make changes (and submit pull requests back to us!) or simply tinker with them to see how they have been built and how the toolkit works. You can access this code repository at https://github.com/shotgunsoftware/tk-3dsmax.Special RequirementsYou need ShotGrid Pipeline Toolkit Core API version v0.19.18 or higher to use this.",
    "url": "/bb1266cb/",
    "relUrl": "/bb1266cb/"
  },
  "139": {
    "id": "139",
    "title": "After Effects",
    "content": "After EffectsThe ShotGrid engine for After Effects provides a platform for integrating ShotGrid into your After Effects workflow. It consists of a standard ShotGrid Pipeline Toolkit engine and relies on the tk-framework-adobe (CEP).Once enabled, a ShotGrid Adobe Panel becomes available in After Effects. It displays information about the current ShotGrid context as well as the commands that are registered for the apps installed in that context.Supported Application VersionsThis item has been tested and is known to be working on the following application versions:2020 (v17.0) - 2023 (v23.6)Please note that it is perfectly possible, even likely, that it will work with more recent releases, however it has not yet been formally tested with these versions.Interface OverviewThe ShotGrid extension panel uses the same color palette and basic layout as native After Effects panels. It is comprised of five components:  Context Header - Thumbnail and fields for the current context.  Favorites Shelf - Designed to show the most commonly-used apps for the current context.  Command List - All non-favorited commands for the current context.  Context Menu - Additional context-related commands and debugging tools.  Logging Console - A console overlay that displays logging output for debugging.InstallationInstallation of the ShotGrid Engine for After Effects follows the same protocol as the other ShotGrid integrations. For information on installing engines and apps, see the Administering Toolkit article. In addition, you can reference the default toolkit config as an example of how to configure the integration.Enabling the extensionOnce the extension is installed, it will need to be launched via the extensions menu in After Effects.This will only need to be done once and the ShotGrid extension panel can remain in the After Effects layout without having to be enabled on subsequent launches.Once enabled, and on future launches, the extension panel will display a loading screen while the ShotGrid integration is bootstrapping.This screen typically displays for a few seconds before the current context is determined and the commands are displayed.Interface componentsThe following sections outline the components of the ShotGrid After Effects integration.Context headerThe context header is a customizable area which can display information about the current ShotGrid context.The context is determined by the currently-active document. Once the context is determined by the engine, the header will update to display the context’s thumbnail field detail. The field information is controlled by a hook. For information on how to customize the field display, see the Context Fields Display Hook section below.It should also be noted that the context switching will only be recognized in if ShotGrid open was used.Favorites shelfThe favorites shelf is similar to the menu favorites available in other ShotGrid DCC integrations such as Maya and Houdini. This section of the interface makes the most commonly used Toolkit apps readily available and easy to find just under the context header.The shelf displays the favorited commands as buttons that, when moused over, transition from grayscale to color and display their name in the label at the top. Tooltips for the buttons will show by hovering the mouse above them.Clicking one of the buttons will trigger the callback for the registered command to execute.For details on how to specify command favorites, see the Shelf Favorites section below.Command listThe command list shows the other “regular” commands that are registered for the current context.Typically, apps installed within a pipeline configuration will register one or more commands that are displayed here. If the commands are not identified as favorites, and are not identified as context-menu commands, they will display here.The command list buttons behave in a manner similar to those in the favorites shelf. The only real difference is that they display as a list with the full name to the right of their icon.Context menuAny commands registered as context menu commands will show in the ShotGrid extension panel’s context menu.Like the other command areas, these commands will change along with the context. Commands such as Jump to ShotGrid and Jump to Filesystem will always be available here.Logging consoleThe logging console shows all of the logging output from both the CEP Javascript interpreter and Toolkit’s Python process.If there are any issues with the extension that require support, the logging console output is extremely useful for helping the ShotGrid support team debug the problem.Configuration and technical detailsThe following sections outline some of the more technical aspects of the integration to help configure the integration to the specific needs of your studio pipeline.PySideThe ShotGrid engine for After Effects relies on PySide. Please see the official instructions for Installing PySide.CEP extensionThe extension itself is bundled with the engine and the engine handles installation automatically on the first launch of After Effects. The extension is installed on the artist’s local machine in the standard, OS-specific CEP extension directories:# Windows&amp;gt; C: Users [user name] AppData Roaming Adobe CEP extensions # OS X&amp;gt; ~/Library/Application Support/Adobe/CEP/extensions/Each time After Effects is launched, the engine bootstrap code will check the version of the extension that is bundled with the engine against the version that is installed on the machine. This means that after an engine update, assuming a new version of the extension came with it, the installed extension will be automatically updated to the newly-bundled version.Configuring favoritesThe Favorites Shelf can be configured to display any of the registered commands for your installed apps. To do this, simply add the shelf_favorites setting to the tk-aftereffects section of your environment configuration. Here’s an example:shelf_favorites:    - {app_instance: tk-multi-workfiles2, name: File Save...}    - {app_instance: tk-multi-workfiles2, name: File Open...}    - {app_instance: tk-multi-publish, name: Publish...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}The value of the setting is a list of dictionaries identifying a registered command provided by one of the installed apps in the configuration. The app_instance key identifies a particular installed app and the name key matches the command’s display name registered by that app. In the example above, you can see four favorited commands: the file open and save dialogs from the tk-multi-workfiles2 app as well as the standard Toolkit publish and snapshot dialogs. These four commands will now show in the favorites shelf.Environment variablesTo aid in debugging, there are a set of environment variables that change some of the engine’s default values:  SHOTGUN_ADOBE_HEARTBEAT_INTERVAL - The Python heartbeat interval in seconds (default is 1 second).  SHOTGUN_ADOBE_HEARTBEAT_TOLERANCE - The number of heartbeat errors before quitting (default is 2). The legacy environment variable  SGTK_PHOTOSHOP_HEARTBEAT_TOLERANCE is also respected if set.  SHOTGUN_ADOBE_NETWORK_DEBUG - Include additional networking debug messages when logging output. The legacy environment variable  SGTK_PHOTOSHOP_NETWORK_DEBUG is also respected if set.  SHOTGUN_ADOBE_PYTHON - The path to the Python executable to use when launching the engine. If not set, the system Python is used. If Photoshop is launched from a Python process, like ShotGrid Desktop or via the tk-shell engine, the Python used by that process will be used by the Photoshop integration.Note: Additional environment variables exist in the Adobe Framework. For details, please see the developer documentation.Context fields display hookThe engine comes with a hook to control the fields displayed in the Context Header section of the panel. There are two methods in the hook that can be overridden to customize what is displayed.The first method is the get_entity_fields() method. This method accepts an entity type representing the current ShotGrid context. The expected return value is a list of fields for that entity that should be queried for display. The engine itself handles querying the data asynchronously.Once the data has been queried from ShotGrid, the second method in the hook is called. This method, get_context_html(), receives the context entity dictionary populated with the queried fields specified by the get_entity_fields() method. The expected return value is a string containing formatted HTML to display the queried entity fields.The default hook implementation is a good reference as to what is required by these methods.It should be noted that the engine will always display the entity thumbnail if one is available.Import Footage HookThe engine comes with a hook to control the import behaviour of certain file types. One may want that a psd file will be imported as single layer instead of a composition. In this case the this hook may be used to overwrite this behaviour.The default hook implementationAfter Effects APIPlease see the developer documentation for details on the After Effects API.",
    "url": "/1eca509c/",
    "relUrl": "/1eca509c/"
  },
  "140": {
    "id": "140",
    "title": "Alias",
    "content": "AliasThe ShotGrid engine for Alias contains a standard platform for integrating ShotGrid Apps into Alias. It is lightweight and straight forward and adds a ShotGrid menu to the Alias menu.Supported Application VersionsThis item has been tested and is known to be working on the following application versions:2020 - 2023Please note that it is perfectly possible, even likely, that it will work with more recent releases, however it has not yet been formally tested with these versions.Python Version Support  Important: With the release of v2.1.5 of the Alias ShotGrid toolkit engine, we have discontinued support for Python v2.7.x. Please download v1.7.3 (or newer) of ShotGrid Desktop to ensure Python 3 is used as the default.Older VersionsLearn more about Python version support for older versions here.NotesA locally installed interpreter may lead to unexpected behaviour. Please contact support if you would like to use this in your studio environment.Information for App DevelopersPySideThe ShotGrid engine for Alias uses a PySide installation shipped with the ShotGrid Desktop and will activate this whenever this is necessary.Alias Project ManagementWhenever the ShotGrid engine for Alias starts, it will set the Alias Project to point at a location defined in the settings for this engine. This means that the Project may also change when a new file is opened. The details relating to how the Alias project is set based on a file can be configured in the configuration file, using the template system.Working with tk-aliasThis ShotGrid integration supports the Alias application family (Concept, Surface, and AutoStudio).When Alias opens, a ShotGrid menu (the Alias engine) is added to the menu bar.File Open and SaveUse the My Tasks and Assets tabs to see all your assigned tasks and browse for assets. To the right, use these tabs to view all files, working or published files associated with what is selected to the left.PublishOpens the Publish dialog for publishing the file to ShotGrid, which can then be used by artists downstream. For more information, see Publishing in Alias. LoaderOpens the Content Loader app, allowing you to load data into Alias. For more information see Loading in AliasScene BreakdownOpens the Breakdown dialog, which displays a list of referenced (WREF References) content, along with what in the scene is out-of-date or using an alternate version of the PublishedFile. For more information see Scene Breakdown in Alias",
    "url": "/8229b689/",
    "relUrl": "/8229b689/"
  },
  "141": {
    "id": "141",
    "title": "Create",
    "content": "ShotGrid CreateThe Desktop2 Engine is the engine which runs inside of the ShotGrid Create Application. It handles DCC launching from ShotGrid Create, as well as from the ShotGrid web application via browser integration.The tk-desktop2 engine powers Toolkit’s integration with ShotGrid Create. The ShotGrid Create provides support for features that users of Toolkit are familiar with, including DCC launching.Installation and UpdatesAdding this Engine to the ShotGrid Pipeline ToolkitIf you want to add this engine to Project XYZ, and an environment named asset, execute the following command:&amp;gt; tank Project XYZ install_engine asset tk-desktop2Updating to the latest versionIf you already have this item installed in a project and you want to get the latest version, you can run the update command. You can either navigate to the tank command that comes with that specific project, and run it there:&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updatesAlternatively, you can run your studio tank command and specify the project name to tell it which project to run the update check for:&amp;gt; tank Project XYZ updatesCollaboration and EvolutionIf you have access to the ShotGrid Pipeline Toolkit, you also have access to the source code for all apps, engines and frameworks in Github where we store and manage them. Feel free to evolve these items; use them as a base for further independent development, make changes (and submit pull requests back to us!) or simply tinker with them to see how they have been built and how the toolkit works. You can access this code repository at https://github.com/shotgunsoftware/tk-desktop2.Special RequirementsYou need ShotGrid Pipeline Toolkit Core API version v0.19.1 or higher to use this.Fixing ShotGrid Integration ErrorYour users are getting the following error message: Failed to initialize integrations. ValueError - Invalid localhost certificate data in ShotGrid! Please contact support. This error message indicates that they are trying to access ShotGrid Toolkit features when your ShotGrid instance is not configured to use the ShotGrid Toolkit integration.To prevent users from accessng the ShotGrid Toolkit and seeing the error message, enable the environment variable SHOTGUN_CREATE_DISABLE_TOOLKIT_INTEGRATION. This env var completely disables ShotGrid Toolkit integration in Create.If you’ve enabled this env var by mistake, disabling it should restore ShotGrid Toolkit integration.",
    "url": "/969c1d7f/",
    "relUrl": "/969c1d7f/"
  },
  "142": {
    "id": "142",
    "title": "Tk-desktop console silently ignoring errors",
    "content": "Tk-desktop console silently ignoring errorsUse caseWhen developing a toolkit app, tk-desktop is silently ignoring all the exceptions the app raises during initialization,  even though the “Toggle debug logging” checkbox on. The only way to know there is an issue is that registered commands don’t show up after loading the config for a project.How to fixWhen Desktop is loading the app for the project, that logging is never getting passed to SG Desktop main UI process.  However, it should still get output to the tk-desktop.log.  Check that file for exceptions.Related linksSee the full thread in the community",
    "url": "/228e7940/",
    "relUrl": "/228e7940/"
  },
  "143": {
    "id": "143",
    "title": "Desktop",
    "content": "DesktopThe tk-desktop engine is an application to let you easily run your Toolkit apps. It is a system tray based window that makes it easy to get started with Toolkit, setup Projects for Toolkit, and access your Projects’ pipeline.Site configuration and Project configurationWhen you launch the desktop application, it will startup the tk-desktop engine for your site configuration.  This configuration is usually automatically managed, although it is possible to disable that behavior and take control over what is in that environment.One of the fundamental principles of Toolkit is that projects can be completely isolated from each other.  This is usually done to make sure that changes made to one project cannot adversely effect another project (possibly nearing delivery). In order to offer this project isolation, the desktop engine makes sure that whenever you are looking at the commands for a particular project, you will run them in a separate python interpreter that has been initialized just for that project.When you click on a project, a python interpreter is launched in the background. This python interpreter is the one the project has been configured to use and on startup will initialize the tk-desktop for that project.  That instance of the engine will communicate back to the GUI what commands it can launch.When you click on a command, that background python process is responsible for launching the command.Registering custom panelsToolkit apps which have panel based UI will be automatically docked in tabs inside of Desktop when they execute.If you have a panel based app such as the ShotGrid Panel, and want it to appear as a tab in ShotGrid Desktop, just configure it to run at startup. When Desktop starts up in its site context mode (where it displays all projects), it will launch all items registered to auto start. If any of these items are panels, these will get docked. Items will be processed in the order they are defined in the configuration and this will dictate the tab order.For example, if you wanted the ShotGrid Panel to show as a tab in ShotGrid Desktop, add the following configuration for your site level environment:tk-desktop:  apps:    tk-multi-shotgunpanel:      actions_hook: ...      action_mappings: ...      location: ...  location: ...  run_at_startup:  - {app_instance: '', name: Apps}  - {app_instance: tk-multi-shotgunpanel, name: ''}Please note that the special Apps entry controls where (in the tab order) the default Apps tab should appear.Configuring the thumbnail display in ShotGrid Desktop",
    "url": "/75097ed0/",
    "relUrl": "/75097ed0/"
  },
  "144": {
    "id": "144",
    "title": "Flame Export",
    "content": "Flame ExportThe ShotGrid Flame Export App helps kickstart your project!Once you have created an initial conform in Flame, the Shot Exporter can help you quicklygenerate content in ShotGrid, render out plates to disk and send content to review.Once you are up and running, the exporter app will also track all the renders happening in Flare or in Flame batch mode, making it easy to send content to review as part of your workflow.Pushing a conform to ShotGridOnce you have your conform set up in Flame for a sequence, and have allocated shot names to all the segments in your timeline, select the sequence, right click and choose the ShotGrid Shot Export option.This will bring up a ShotGrid UI where you can enter some initial comments for your publish. These comments will be sent to review and also used when adding description to publishes and other content.In addition to the description, you can also select which output data format you want to use for your exported plates. These presets are part of the toolkit app configuration and can be configured to suit the needs of your studio.Once you click the submit button, a number of things will happen straight away:      Shots and Tasks will be created in ShotGrid. The list of tasks to associate with each new Shot that gets created is configurable via a Task template setting to make it quick and painless to create consistent structures. The shots will be parented under a sequence by default, but this is also configurable and if you are working with Scenes or Episodes, it is possible to reconfigure the exporter to work with these instead.        Once ShotGrid contains the right data, folders will be created on disk using the standard folder creation mechanism. This ensures that the project can be kick-started with a set of consistent folders for all shots that are being created.  Once the two steps above have been carried out, you have the basic structure to proceed with further steps. These will happen in the background:      Plates will be exported on disk for each shot according to the presets defined in your configuation. File locations are defined using the Toolkit Template system, meaning that the location of these plates will be well defined and understood by other tools downstream in the pipeline.        Batch files and clip xml files will be exported. These are used by Flame to enable an iterative workflow where you can quickly render out new versions that are later pulled in to the main conform in Flame.        Quicktimes are generated and uploaded to ShotGrid for review.  Sending batch renders to ReviewOnce you have published a Flame batch file for a Shot, you can launch Flare directly from that Shot in order to open up the batch file with render and output settings pre-populated. In order to render out a new version, simply click the Render Range Button.Toolkit will display a dialog at this point where you can choose to send the render to ShotGrid review or not.Files will be published and tracked by ShotGrid and optionally also sent to review.Want to learn more?If you want to learn more, and see this workflow in action, head over tothe Flame engine documentation where we also have some video content that demonstrates the various workflows in action.LINKBOX_ENGINE:ShotGridsoftware/tk-flame:The Flame EngineAs always, if you have question regarding integration or customization, don’t hesitate to visit our support site.Advanced TopicsBelow you’ll find more advanced details relating to configuration and customizationUsing export presetsThe exporter uses a concept of Export Presets in its configuration. When you launch the Export UI inside of Flame you see a dropdown with the available export presets. Each preset is a configuration option which allows you to configure how files are written to disk and uploaded to ShotGrid. High level settings such as file locations on disk are controlled directly in the environment configuration, making it easy to adjust the default configuration options to work with your pipeline.More advanced settings and control over the actual export xml content that is being passed to flame in order to control Flame, is handled by a hook where the behaviour is defined for each preset. In the hook, you have complete control over how media is being generated by the exporter.Bypassing ShotGrid server side transcodingBy default, Quicktimes are uploaded to ShotGrid review by setting the Version.sg_uploaded_movie field. This in turn will trigger ShotGrid server side transcoding; the uploaded quicktime will be further converted to mp4 and webm representations tailored for playback in browsers and mobile. Sometimes, it can be beneficial to bypass this server side transcoding. This is possible by setting the bypass_shotgun_transcoding configuration setting. When this is set to true, the integration will upload directly to the Version.sg_uploaded_movie_mp4 field in ShotGrid, thereby bypassing the server side transcoding. In this case, no webm version is generated, so review playback will not be possible in Firefox.For more information, see https://help.autodesk.com/view/SGSUB/ENU/?guid=SG_Supervisor_Artist_sa_review_approval_sa_transcoding_htmlCustomizing ffmpegWhen the exporter generates quicktimes, it uses a version of ffmpeg which comes distributed with Flame. By modifying the settings hook in the exporter, you can specify an external version of ffmpeg to use instead of the built-in one. The version of ffmpeg distributed with Flame is tracking the very latest advancements in ffmpeg transcoding and performance, so sometimes using the latest version may result in performance improvements.Please note that the way h264 parameters are passed to ffmpeg has changed between the version that is used by default and the latest versions. By switching to the latest generation of ffmpeg, it is possible to implement exactly the recommended transcoding guidelines that results in optimal upload and performance on the ShotGrid side. You can find these guidelines here:https://help.autodesk.com/view/SGSUB/ENU/?guid=SG_Supervisor_Artist_sa_review_approval_sa_transcoding_htmlWe only recommend changing the ffmpeg version if you are an advanced user. In that case, follow these steps:Copying the settings hookAll settings that need to be modified can be found in the settings hook that comes shipped with the Flame export app. In order to modify this hook, you first need to copy this hook file from its default location inside the app location into your configuration. Inside your project configuration, you’ll typically find the hook file in a location similar to install/apps/app_store/tk-flame-export/va.b.c/hooks/settings.py. Copy this file into the hooks location inside of your configuration, e.g. config/hooks. We recommend renaming it to something a little more verbose than just settings.py in order to make it clear what it is:install/apps/app_store/tk-flame-export/va.b.c/hooks/settings.py -&amp;gt; config/hooks/flame_export_settings.pyNow edit your Flame environment configuration file. This is typically config/env/includes/flame.yml. Under the tk-flame-export heading, you’ll find the path to the hook being defined as settings_hook: '{self}/settings.py'. This essentially means that the configuration will look for the hook file inside the app location (e.g. {self}). Changing this to settings_hook: '{config}/flame_export_settings.py' will tell Toolkit to look for the hook file inside the configuration instad. In summary:settings_hook: '{self}/settings.py' -&amp;gt; '{config}/flame_export_settings.py'Modifying the hookNow we are ready to start modifying our config/hooks/flame_export_settings.py hook! Open it up in a text editor. You’ll notice several methods relating to ffmpeg and ffmpeg settings. The first one to modify is the following:def get_external_ffmpeg_location(self):    &quot;&quot;&quot;    Control which version of ffmpeg you want to use when doing transcoding.    By default, this hook returns None, indicating that the app should use    the built-in version of ffmpeg that comes with Flame.    If you want to use a different version of ffmpeg, simply return the path    to the ffmpeg binary here.    :returns: path to ffmpeg as str, or None if the default should be used.    &quot;&quot;&quot;    return NoneBy returning None by default, the exporter will use Flame’s built-in ffmpeg. Change this to return a full path to your ffmpeg. Keep in mind that if you are running a backburner cluster, ffmpeg may be called from any machines in the cluster, so make sure the executable is installed everywhere.Now that once the ffmpeg location is updated, you most likely either need or want to tweak the parameters passed to ffmpeg. This needs to be changed in two different methods:      get_ffmpeg_quicktime_encode_parameters will return the parameters used when generating a quicktime to be uploaded to ShotGrid.        get_local_quicktime_ffmpeg_encode_parameters will return the parameters used when a quicktime is written to disk.  For the ShotGrid upload, we recommend using the default ShotGrid encoding settings as a starting point:def get_ffmpeg_quicktime_encode_parameters(self):    return &quot;-vcodec libx264 -pix_fmt yuv420p -vf 'scale=trunc((a*oh)/2)*2:720' -g 30 -b:v 2000k -vprofile high -bf 0&quot;For the local ShotGrid transcode, we recommend basing your settings on the ShotGrid transcode settings but removing the resolution constraints and increasing the bit rate:def get_local_quicktime_ffmpeg_encode_parameters(self):    return &quot;-vcodec libx264 -pix_fmt yuv420p -g 30 -b:v 6000k -vprofile high -bf 0&quot;",
    "url": "/04a6342b/",
    "relUrl": "/04a6342b/"
  },
  "145": {
    "id": "145",
    "title": "Flame Review",
    "content": "Flame ReviewThe ShotGrid Flame Review App makes it easy to push one or more sequences from Flame into ShotGrid review.Simply right click a sequence or a selection of sequences that you want to review:Select the ShotGrid Review Option:A Toolkit UI will appear where you can add some review notes:When you click ok, a background job will be generated and everything will happen behind the scenes.The following steps will be carried out:      The Sequence will be exported to disk as a quicktime. This export is handled as a Flame Quicktime export and you have complete control of the various settings via a configuration hook.        Once the sequence is complete, Toolkit will check if there is a matching Sequence in ShotGrid. If not, a Sequence will be created automatically.        A review version will be generated and associated with the sequence.        Lastly, the quicktime will be uploaded to the review version.  The process supports audio tracks, transitions etc and should be a “what you see is what you get”. Once in ShotGrid, you can review the media in many different ways, including the client review site and the ShotGrid iPhone app.Customization and SettingsThe Flame Review app can be customized in a couple of different ways:      You can control which Entity Type that should be used in ShotGrid to represent a Sequnce in Flame. For example, if you are working on episodic content, it may make more sense to link your review versions to episodes in ShotGrid rather than sequences.        You can customize which tasks the app should automatically add to new items created in ShotGrid. This is done via a task template setting and allows you to standardize the structure that’s created.        Via a hook, you get complete control over the xml preset that the app uses to generate a quicktime out of Flame.  ",
    "url": "/b38dc286/",
    "relUrl": "/b38dc286/"
  },
  "146": {
    "id": "146",
    "title": "Flame",
    "content": "FlameInstallationThe ShotGrid engine for Flame relies on new integration hooks that were added in Flame 2015 Extension 2.  This version of Flame must be used in order for the engine to function.  For more info on Flame 2015 Extension 2 (including how to get it), reach out to Flame Support.The simplest way to get started with the ShotGrid engine for Flame is to set up a new test project with our example pipeline configuration. You can do this by launching the ShotGrid Desktop, running the Project Setup for a new project and choosing the default Flame configuration (in the default configurations section).Supported Application VersionsThis item has been tested and is known to be working on the following application versions:2020+Flame Project SetupThe ShotGrid engine for Flame also helps associate the ShotGrid project with a Flame project, and creates it if need be.  This is key to the integration, as it ensures data from Flame gets associated with the right things in ShotGrid.  As an added feature, the engine provides functionality for managing the naming conventions of Flame projects as well as the other various settings for the project.When Flame is launched via ShotGrid for the first time, a Flame project creation UI will appear that lets the artist edit the usual settings from the standard Flame project creation screen:But with the ShotGrid integration, the settings can be pre-populated with pipeline-friendly values, helping artists quickly get the right thing without having to think about it.  The defaults can be customized via the project_setup_hook, which supports the following options:use_project_settings_uiIf set to True, the project creation UI will appear.  If False, the Flame project will automatically be created based on the rest of the defaults in the hook.get_server_hostnameBy default this is set to ‘localhost’, but it can be overridden if desired.get_project_nameBy default this is set to the same value as the ShotGrid project, but it can be overridden if desired.get_volumeBy default this is set to the first available storage, but it can be overridden if desired.get_workspaceBy default Flame will create a default workspace according to its standard workspace creation logic, but it can be overridden if desired.get_userThis will try to associate the user logged into the Flame machine with a user in ShotGrid.get_project_settingsThis is where the main Flame settings are configured and the hook helps build the Flame project XML stream.  The following parameters must be supplied:  FrameWidth (e.g. 1280)  FrameHeight (e.g. 1080)  FrameDepth (16-bit fp, 12-bit, 12-bit u, 10-bit, 8-bit)  FieldDominance (PROGRESSIVE, FIELD_1, FIELD_2)  AspectRatio (4:3, 16:9, or floating point value as string)Proxy settings can also be supplied.  For more info, see the Autodesk Wiretap SDK docs!To view the entire codebase for the project_setup hook, please see our Github repo for the engine.",
    "url": "/d5d7b724/",
    "relUrl": "/d5d7b724/"
  },
  "147": {
    "id": "147",
    "title": "Admin UI",
    "content": "Toolkit Admin UI FrameworkThe Admin UI Framework implements a place that holds standard user interfaces that wrap Toolkitadministrative commands.Currently the only interface is for the setup_project command.SetupProjectWizard API ReferenceThis is a QWizard implementation that walks somebody through setting up a Projectfrom their ShotGrid instance for Toolkit.  To use the wizard, simply create aninstance of the class, passing in the project to setup (as a standard ShotGrid APIentity dictionary) and the window to parent to.adminui = sgtk.platform.import_framework(&quot;tk-framework-adminui&quot;, &quot;setup_project&quot;)setup = adminui.SetupProjectWizard(project, parent)dialog_result = setup.exec_()This will run the wizard and return a standard QDialog Accepted or Rejected value.SetupProjectWizard ConstructorInitialize a SetupProjectWizard.  This is a subclass of QtGui.QWizard.SetupProjectWizard()",
    "url": "/02fa2cba/",
    "relUrl": "/02fa2cba/"
  },
  "148": {
    "id": "148",
    "title": "Desktop Server Framework",
    "content": "Toolkit Desktop Server FrameworkThe desktopserver framework provides the functionality behind ShotGrid’s local file linkingand Toolkit integration.  It provides a local websocket server that securely listens forrequests from ShotGrid websites for an action that requires desktop access.For local file linking, these requests allow ShotGrid access to local file paths from the web interface and the ability to open those files directly from ShotGrid pages when requested. For Toolkit, they allow ShotGrid to determine what pipeline actions have been registered for a given entity and to execute them.How to get desktop integration runningFor these ShotGrid features to work, some supported desktop integration must be running.This page covers the various options for howShotGrid can integrate with your desktop.  The Websocket Server section covers the functionality that this framework provides.ShotGrid DesktopThis framework is bundled with ShotGrid Desktop, which can be downloaded following these steps. When ShotGrid Desktop is run it will automatically start up the websocket server.  If you are already running ShotGrid Desktop then your setup process is complete.Configuring the serverYou can store the browser integration settings in a configuration file. This configuration file can be specified by setting the environment variable SGTK_BROWSER_INTEGRATION_CONFIG_LOCATION. More details on how you can configure the local server can be found in our sample file.Removing a certificateIf you wish to remove a certificate you have created, you can run the python certificates.py --remove command.Launching via a wrapperBy default, the server will use the operating-system default to launch a command (the equivalent of“xdg-open” on Linux, “open” on OS X, and “run” on Windows). If you wish to provide your own wrapper forlaunching files you can set the SHOTGUN_PLUGIN_LAUNCHER environment variable to point to yourcustom wrapper. If that is set, the wrapper will be called with the path as its only argument.CertificatesThe first time you run the server it will generate the certificate required to establish a secure connection. These certificates are stored local to your machine and are never shared with the public.They allow the encrypted connection that websockets requires, which is necessary despite all traffic remaining local (from your browser to the server); ShotGrid’s websocket traffic is never made available over the Internet.When the certificates are registered with the system you will see dialogs appear like the following.Click “Ok” to allow the registration to proceed.When using the ShotGrid Desktop, the generated certificates will be stored in the following locations:OS X: ~/Library/Caches/Shotgun/desktop/config/certificatesWindows: %AppData% Shotgun desktop config certificatesLinux: ~/.shotgun/desktop/config/certificatesSecurity Setup - Local ShotGrid InstallsBy default, the websocket server is setup to listen to hosted ShotGrid sites on port 9000.If you run a local ShotGrid server, you will need to update the configuration for the ShotGrid server to allow connections from your websocket server.When running ShotGrid Desktop, you will need to setup a config.ini file that lives with the ShotGrid binary.Within that file there is a section that controls the functionality of the websocket server.A typical configuration would look like this:[BrowserIntegration]low_level_debug=0port=9000enabled=1whitelist=*.shotgunstudio.comTroubleshootingOn Linux the server introduces a dependency on libffi.  If Desktop crashes on startup and you see a message about libffi not found in your logs, then you need to install this package.Visit our support site if you have any issues or questions during setup.  If there is a problemrunning the server, please set debug to 1 in the config.ini file and include Desktop’s logfile.The log file can be found in the following locations:OS X: ~/Library/Logs/Shotgun/tk-desktop.logWindows: ~ %APPDATA% Shotgun tk-desktop.logLinux: ~/.shotgun/tk-desktop.log",
    "url": "/c79f1656/",
    "relUrl": "/c79f1656/"
  },
  "149": {
    "id": "149",
    "title": "Desktop Startup",
    "content": "Toolkit Desktop Startup FrameworkThe Desktop Startup framework implements the startup logic of the ShotGrid Desktop. Its main function is to:  initialize the browser integration  log the user in  download Toolkit  configure the site configuration  auto update itself and the site configuration when necessary  launch the tk-desktop engine.  This is an internal Toolkit framework and therefore the interface it implements is subject to change. We advise that you do not use this framework in your projects.Locking-down the startup logic  Note, this requires the ShotGrid Desktop app version 1.3.4. If you are unsure of your application version, launch the ShotGrid Desktop. Once you are logged in, click on the user icon at the bottom right and click About.... The App Version should be 1.3.4 or greater.By default, ShotGrid Desktop downloads tk-framework-desktopstartup updates locally on the user’s machine and uses it during the launch sequence of the application. When you launch the application, Toolkit automatically checks for updates to the framework. If an update is available, it will also download and install it automatically.Alternately, you can configure the ShotGrid Desktop to use a specific copy of the framework instead of using the local copy. This will disable the auto-update function and you will now be responsible for updating your the startup logic.Download a specific release from GitHubYou will need to download updates from GitHub manually. The bundles can easily be downloaded from the Releases page and you can find more information about each official release here.Configure the ShotGrid Desktop to use a specific copyThe only way to lock down the startup logic is to use an environment variable. By setting SGTK_DESKTOP_STARTUP_LOCATION to the root folder of a copy of the framework, you will tell the ShotGrid Desktop to use this copy of the code when starting up. Once the variable is set, you can launch the ShotGrid Desktop and it will use this specific copy of the startup logic.  Note that as of this writing the Startup Version field in the About... box will be Undefined when locking the startup logic due to a technical limitation.Reverting to the old behaviourTo revert back your changes, simply unset the environment variable and launch the ShotGrid Desktop.",
    "url": "/3414fbb3/",
    "relUrl": "/3414fbb3/"
  },
  "150": {
    "id": "150",
    "title": "Hiero/Nuke Studio Export",
    "content": "Hiero/Nuke Studio ExportIntroductionThis app adds ShotGrid awareness to Hiero’s export dialog for sequences.Overview Video &amp;amp; DemoIf you’re new to ShotGrid Toolkit or the Hiero integration, check out the following video which gives a fast-paced overview of what you can do in your pipeline with the ShotGrid Toolkit Hiero integration.If you’re already familiar with Toolkit and Hiero, then feel free to continue on to the docs below.ShotGrid Shot ProcessorWhen this app activates itself it registers a bunch of changes with the Hiero export dialog:The first thing to notice is the new processor that is registered:When you click on this processor, there are some new things to notice.At the top of the dialog, there is extra UI that helps control how shots get created/updated in ShotGrid as a result of exporting the sequence:TagsBy adjusting the dropdowns you can map various Hiero tags into ShotGrid shot statuses and shot task templates.  Thus via Hiero’s tagging workflow you can set a ShotGrid shot to being in progress or setup the tasks for the Shot for a green screen, cg extra, or whatever makes sense for your configuration.  This UI is populated via a hook and is easy to configure for extra functionality.CollatingThere are also options to control collating track items together that mirror Hiero’s built in logic.  If you have multiple items that make up a shot (either overlapping, on different tracks or with the same shot name on multiple tracks) then you should turn these options on. This will cause the ShotGrid Toolkit Shot updater to treat the matching collated items as a single Shot.For example, assume we have two track items representing shots 010 and 020. 010 comes first and 020 overlaps with the end of 010 on a different track. Since 010 comes first, it’s the hero and with collating enabled, ShotGrid treats the two items as a single shot, 010. This means Shot 010 will be created or updated in ShotGrid. The cut in will match the beginning of track item 010 and the cut out will match the end of track item 020. A Screening Room-ready Version will be created for each item, but both will be linked to Shot 010. A plate will be created for each item as a Published File but both will be linked to Shot 010. A single Nuke script will be published linked to Shot 010 containing 2 read nodes, one for each item. Note that in this situation, there is no creation or update to Shot 020 in ShotGrid, since it has been collated into Shot 010.PathsBelow the ShotGrid UI is the standard paths dialog.  There are three items that are added to Shots via Hiero by default… a default Nuke script, a default Nuke write location, and a default location for a plate transcode.  The locations of these items are determined by the app configuration and can make full use of the templating system:This app adds a {tk_version} token to Hiero which will be replaced by the version string, correctly formatted for ShotGrid Toolkit.Custom Template FieldsAny tokens you define in the custom_template_fields setting that are resolved by the resolve_custom_strings hook will automatically be added to Hiero’s list of valid replacement tokens and will be considered valid replacements in your Toolkit template paths.For example, in your Toolkit templates.yml file, say you define a key with the following:    resolution:         type: str         filter_by: alphanumeric  In your project.yml settings for tk-hiero-export you have:  ...  ...  tk-hiero:    apps:      tk-hiero-export:        custom_template_fields:        - {description: Shot Resolution, keyword: resolution}  ...  ...And then you modify the resolve_custom_strings hook with something like the following:# Copyright (c) 2014 ShotGrid Software Inc.## CONFIDENTIAL AND PROPRIETARY## This work is provided &quot;AS IS&quot; and subject to the ShotGrid Pipeline Toolkit# Source Code License included in this distribution package. See LICENSE.# By accessing, using, copying or modifying this work you indicate your# agreement to the ShotGrid Pipeline Toolkit Source Code License. All rights# not expressly granted therein are reserved by ShotGrid Software Inc.from tank import Hookclass HieroResolveCustomStrings(Hook):    &quot;&quot;&quot;Translates a keyword string into its resolved value for a given task.&quot;&quot;&quot;    RESOLUTION_TOKEN_NAME = &quot;{resolution}&quot;    def execute(self, task, keyword, **kwargs):        &quot;&quot;&quot;        &quot;&quot;&quot;        self.parent.log_debug(&quot;attempting to resolve custom keyword: %s&quot; % keyword)        if keyword == self.RESOLUTION_TOKEN_NAME:            translated_value = self._clip_resolution_string(task)        else:            raise RuntimeError(&quot;No translation handler found for custom_template_field: %s&quot; % keyword)        self.parent.log_debug(&quot;Custom resolver: %s -&amp;gt; %s&quot; % (keyword, translated_value))        return translated_value    # Handle the {resolution_fs} token     def _clip_resolution_string(self, task):         &quot;&quot;&quot; returns sequence resolution or task format override&quot;&quot;&quot;         width = &quot;&quot;         height = &quot;&quot;        sequence_format = task._sequence.format()        width = sequence_format.width()         height = sequence_format.height()        if &quot;reformat&quot; in task._preset.properties():             task_reformat_settings = task._preset.properties()[&quot;reformat&quot;]             if task_reformat_settings['to_type'] != &quot;None&quot;:                 width = task_reformat_settings['width']                 height = task_reformat_settings['height']        return &quot;%sx%s&quot; % (width, height)You can now not only use the resolution token in Hiero but it will validate against any template paths you have defined in Toolkit so you can export to a location like:    hiero_plate_path: &quot;sequences/{Sequence}/{Shot}/hiero_plates/{resolution}/v{version}/{project}_{Shot}.mov&quot;ShotGrid TasksThere are two new task types registered.ShotGrid Transcode ImagesThis is a subclass of the standard Hiero transcoding task, which will register the results of the transcode as a Publish in ShotGrid.  Optionally a Version will also be created in ShotGrid.  If a Version is created, then a Quicktime will also be created and uploaded as Screening Room media.ShotGrid Nuke Project FileThis is a subclass of the standard Hiero Nuke script exporter, which registers the resulting Nuke script as a PublishedFile in ShotGrid linked to the Shot. The settings allow you to specify which Toolkit-enabled WriteNodes to include in the file on export.The app settings plate_published_file_type and nuke_script_published_file_type allow you to control what file type the PublishedFiles are registered as. In addition, nuke_script_toolkit_write_nodes allows you to control which WriteNode settings should be available in the export dialog.Export processWhen the export is run, there will be some extra tasks that show up in the export queue:Each shot will run a ShotGridShotUpdater tasks that is responsible for creating the Shot in ShotGrid and creating the full Shot structure specified in the schema configuration:Sequence and Shot updates in ShotGridThe name of the Hiero sequence will be used for the sequence name, and theshots will have their cut info filled in (Cut Order, Head In, Cut In, Cut Out,Tail Out, Cut Duration, and Working Duration).  In addition if poster frameswere selected for the sequence or the items that make up the shot, they will beuploaded as the thumbnails for the shots.If your workflow uses an entity other than Sequence as the shot parent(like Episode), then you can override the get_shot_parent method in thehook_get_shot hook. The default implementation creates (if necessary) andreturns a Sequence.Cut Schema SupportIf your ShotGrid site supports the Cuts schema (v7.0.0 or later), then this appwill automatically generate a Cut with corresponding CutItems inShotGrid.  The Cut entity corresponds to the Hiero sequence and theCutItems correspond to the items in the sequence. The Cut will belinked to the parent entity (Sequence by default) as returned by theget_shot_parent method in the hook_get_shot hook. The CutItems will beassociated with a Shot entity and linked to the reviewable Versioncreated during the export. After exporting, the Cut will be playable in theMedia tab in ShotGrid and in RV.All of the meta data associated with the Cut and CutItem entities isinferred from Hiero except the Cut Type field which can be specified in theexport UI.The value here will show up in the Type field of the Cut.It should be noted that the Cut schema is not supported when either of theCollate options are selected, and creation of Cut and CutItem entrieswill be skipped.In addition, the Cut schema does not handle retimed clips. A debug warning will be logged when exporting retimed clips.Alternate Shot HierarchiesFor studios that don’t work in the standard Sequence &amp;gt; Shot hierarchy, but  perhaps use Episodes and/or Scenes,  there is a hook hiero_get_shot that allows you to configure the app to work with whatever Shot hierarchy is in use at your studio.",
    "url": "/523d3720/",
    "relUrl": "/523d3720/"
  },
  "151": {
    "id": "151",
    "title": "Hiero/Nuke Studio Open in ShotGrid",
    "content": "Hiero/Nuke Studio Open in ShotGridThis app adds a context menu to the Hiero spreadsheet and timeline that allows you to open a given track item in ShotGrid if there is a Shot for that item.You typically configure this app by adding it to the time line and spreadsheet menus in Hiero by adding the following to the ShotGrid Engine for Nuke configuration:    timeline_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: &quot;Open in ShotGrid&quot;, requires_selection: true}    spreadsheet_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: &quot;Open in ShotGrid&quot;, requires_selection: true}",
    "url": "/88ae1c1d/",
    "relUrl": "/88ae1c1d/"
  },
  "152": {
    "id": "152",
    "title": "Houdini Alembic Node",
    "content": "Houdini Alembic NodeThe Houdini Alembic Node App provides a custom ShotGrid Alembic Output node which makes it easy to standardise the location where alembic files are output.  It can be configured for each environment.General UseIn order to use the ShotGrid Alembic Output, save your script as a Toolkit work file first and then create a new node via the TAB menu in Houdini. This will create a node which looks similar to a normal Alembic output node:The node can be configured with multiple output profiles, each using a different template path for where the alembic cache should be written to disk.Rather than entering a path by hand, you just specify which output profile to use and the node will compute the rest of the path automatically. You can see the computed path in the UI.The output alembic files will be versioned and the version number will always follow the current Houdini scene file version which will be incremented automatically when you publish using Multi Publish.ConfigurationThe Toolkit alembic node provides the ability to specify multiple output profiles for an environment configuration. Here’s an example of configuring the node with multiple profiles:  tk-houdini:    apps:      tk-houdini-alembicnode:        location:           name: tk-houdini-alembicnode          type: app_store          version: v0.2.2        work_file_template: houdini_shot_work        default_node_name: tk_alembic_out        output_profiles:          - name: For Publishing            settings: {}            color: [1.0, 0.5, 0.0]            output_cache_template: houdini_shot_work_alembic_cache          - name: Local Testing            settings: {}            color: [0.0, 0.5, 1.0]            output_cache_template: houdini_shot_local_alembic_cacheYou can use the output profiles to alter the look of the node via the color field, and you can adjust individual parms on the underlying Alembic node by supplying key/value pairs matching those parms in the settings field. Finally, the output_cache_template field drives the output path for the alembic cache written to disk.",
    "url": "/55f75584/",
    "relUrl": "/55f75584/"
  },
  "153": {
    "id": "153",
    "title": "Houdini Mantra Node",
    "content": "Houdini Mantra NodeThe Houdini Mantra Node App provides a custom ShotGrid Mantra Output node which makes it easy to standardise the location where render files are output.  It can be configured for each environment.General UseIn order to use the ShotGrid Mantra Node, save your script as a Toolkit work file first and then create a new node via the TAB menu in Houdini. This will create a node which looks similar to a normal Mantra output node:The node can be configured with multiple output profiles, each using a different set of template paths for where the render output (images, ifd, dcm, aov, etc) should be written to disk.Rather than entering a path by hand, you just specify which configuration to use and the node will compute the rest of the path automatically. You can see the computed path in the UI.The rendered files will be versioned and the version number will always follow the current Houdini scene file version which will be incremented automatically when you publish using Multi Publish.ConfigurationThe Toolkit mantra node provides the ability to specify multiple output profiles for an environment configuration. Here’s an example of configuring the node with multiple profiles:  tk-houdini:    apps:      tk-houdini-mantranode:        location:           name: tk-houdini-mantranode          type: dev          version: v0.2.2        default_node_name: tk_mantra_out        work_file_template: houdini_shot_work        output_profiles:          - name: Primary Render            settings: {}            color: [1.0, 0.5, 0.0]            output_render_template: houdini_shot_render            output_ifd_template: houdini_shot_ifd            output_dcm_template: houdini_shot_dcm            output_extra_plane_template: houdini_shot_extra_plane          - name: Local Render            settings: {}            color: [0.0, 0.5, 1.0]            output_render_template: houdini_shot_local_render            output_ifd_template: houdini_shot_local_ifd            output_dcm_template: houdini_shot_local_dcm            output_extra_plane_template: houdini_shot_local_extra_planeYou can use the output profiles to alter the look of the node via the color field, and you can adjust individual parms on the underlying Alembic node by supplying key/value pairs matching those parms in the settings field. Finally, the output_*_template fields drive the output paths for the files written to disk by the mantra renderer.",
    "url": "/2c47f879/",
    "relUrl": "/2c47f879/"
  },
  "154": {
    "id": "154",
    "title": "Houdini",
    "content": "HoudiniThe ShotGrid Engine for Houdini contains a standard platform for integrating ShotGrid Apps into Houdini.Information for App DevelopersSupported PlatformsThe ShotGrid Engine for Houdini is currently supported on Windows, Linux, and OSXSupported Application VersionsThis item has been tested and is known to be working on the following application versions:17.5 - 19.5 Note: Running on Apple Silicon (M1/M2), Houdini is supported for both Native mode and Rosetta mode.PySideFor older versions of Houdini (13 and older) an external build of PySide is required. On Windows, we have bundled a compatible PySide build that will work with the python that Houdini runs. On Linux, Houdini uses the system python (per https://www.sidefx.com/docs/houdini12.0/hom/) which needs to have PySide or PyQt support.Menu loadingA dynamic menu system was introduced by Side Effects as of Houdini 15, so the engine now supports rebuilding of the ShotGrid menu on context switches.In Houdini 14 and older, the ShotGrid menu in Houdini is generated before Houdini starts and is static throughout the session. Due to this, the toolkit commands registered in the menu will not update on context changes.ShotGrid shelfRelease v0.2.4 introduced a dynamic ShotGrid shelf to the engine. The shelf displays any registered app commands as tool buttons. The buttons will be displayed in roughly the same order as the menu commands.Use the enable_sg_shelf setting to turn on the shelf within an environment. If using a version of Houdini (14 or older) that does not support dynamic menus, you may also want to turn off the ShotGrid menu when using the shelf. This can be done by setting the enable_sg_menu setting to false.To enable context switching via the shelf, you’ll also need to add entity types to the sg_entity_types setting of the tk-multi-workfiles app in your engine configuration.Here’s a look at the settings related to the ShotGrid shelf:tk-houdini:  apps:    # ... other app definitions    tk-multi-workfiles:       # ... other app settings       sg_entity_types: [Shot, Asset] # allow context switching to Shots or Assets       # ... other app settings  enable_sg_shelf: true  enable_sg_menu: false  # ... other engine settingsOnce you’ve enabled the ShotGrid shelf, you need to manually add it to a shelf set inside houdini.Once added to a shelf set the ShotGrid shelf will remain there between houdini sessions and will update dynamically as your ShotGrid context changes.PanelsAs of v0.2.8 the engine adds support for embedded toolkit panels.The panel support currently requires Houdini version 15.0.272 or later for proper embedded panels. Registered panels will show up as panes in the pane  menu for supported versions of Houdini.Older versions of Houdini will display the registered panels as dialogs. SESI may backport some bug fixes to newer builds of Houdini 14. If and when that happens, we will make embedded panels work for those versions as well.Apps with OTLsThe ShotGrid Engine for Houdini makes it easy to load application supplied OTLs. If you are writing an app which uses OTLs, you can just drop them into a folder called otls and the engine will automatically load them into your session:You can then easily access your nodes via the usual Houdini methods.Warning!! Please note that while the use of OTLs may be convenient, it is typically NOT the right solution if you want to create nodes that persist in a scene. The reason for this is because as soon as you have put an OTL in the scene, you have introduced a dependency between that scene and the OTL code. Not only will you need to load the ShotGrid Toolkit every time you load the scene, but you also need to carefully manage your code so that any updates to the code does not break old OTLs being used in scenes.Startup Debugging via Terminal on OSXTurning on debug_logging for the tk-houdini engine on OS X will not send all debug messages to the Terminal. This is because, by default, the tk-multi-launchapp app uses the open command to launch executables. This does not spawn a new subprocess from the Terminal, but rather uses OS X’s Launch Services to create a new process elsewhere. As a result, the log statements are not shown. Even having a python shell saved in the user’s default desktop in houdini does not seem to show debugging statements during startup. After startup, and embedded Python shell will show debug logging statements, but there is a gap in available output during startup. If you need access to debug logging statements during engine startup, you can make 2 changes.First, change your houdini_mac path (temporarily) in your test configuration to point to the executable inside the Houdini app bundle. For example:#houdini_mac: /Applications/Houdini 15.0.272/Houdini Apprentice.apphoudini_mac: /Applications/Houdini  15.0.272/Houdini  Apprentice.app/Contents/MacOS/happrenticeNext, you can make a copy of the tk-multi-launchapp app’s app_launch hook in your test configuration’s config/hooks directory and point to it in your config/env/includes/app_launchers.yml file:launch_houdini:  defer_keyword: ''  engine: tk-houdini  extra: {}  hook_app_launch: app_launch    # &amp;lt;----- use a custom app_launch hook  hook_before_app_launch: default  icon: '{target_engine}/icon_256.png'  linux_args: ''  linux_path: '@houdini_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.6.6}  mac_args: ''  mac_path: '@houdini_mac'  menu_name: Launch Houdini  versions: []  windows_args: ''  windows_path: '@houdini_windows'Then all you have to do is modify the launch logic to launch the executable directly. As an example, you could keep the old behavior for directories (application bundles) and otherwise execute the command directly. Here’s an example:        elif system == &quot;darwin&quot;:            # on the mac, the executable paths are normally pointing            # to the application bundle and not to the binary file            # embedded in the bundle, meaning that we should use the            # built-in mac open command to execute it            if os.path.isdir(app_path):                cmd = &quot;open -n  &quot;%s &quot;&quot; % (app_path)                if app_args:                    cmd += &quot; --args  &quot;%s &quot;&quot; % app_args.replace(&quot; &quot;&quot;, &quot;   &quot;&quot;)            # not a directory, execute directly            else:                cmd = &quot;%s %s&quot; % (app_path, app_args.replace(&quot; &quot;&quot;, &quot;   &quot;&quot;))The next time you run launch_houdini via tank in the Terminal, you should get all the debug output. Once you’re done testing, don’t forget to revert your path and undo your app launch changes. Happy debugging!",
    "url": "/797202da/",
    "relUrl": "/797202da/"
  },
  "155": {
    "id": "155",
    "title": "Mari Project Manager",
    "content": "Mari Project ManagerThe Mari Project Manager streamlines the process of creating new projects in Mari, allowing artists to quickly select published geometry to load using the ShotGrid Loader. Projects created with this app are ShotGrid aware, helping artists publish textures to other parts of the pipeline without having to be concerned about export options and file locations.",
    "url": "/82aaf735/",
    "relUrl": "/82aaf735/"
  },
  "156": {
    "id": "156",
    "title": "Mari",
    "content": "MariThe ShotGrid engine for Mari contains a standard platform for integrating ShotGrid Toolkit Apps into Mari. It is light weight and straight forward and adds a ShotGrid menu to the main menu.Supported Application VersionsThis item has been tested and is known to be working on the following application versions:4.0 - 6.0v2Please note that it is perfectly possible, even likely, that it will work with more recent releases, however it has not yet been formally tested with these versions.Overview VideoSee the overview video here.Installation and UpdatesAdding this Engine to the ShotGrid Pipeline ToolkitIf you want to add this engine to Project XYZ, and an environment named asset, execute the following command:&amp;gt; tank Project XYZ install_engine asset tk-mariUpdating to the latest versionIf you already have this item installed in a project and you want to get the latest version, you can run the update command. You can either navigate to the tank command that comes with that specific project, and run it there:&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updatesAlternatively, you can run your studio tank command and specify the project name to tell it which project to run the update check for:&amp;gt; tank Project XYZ updatesConfiguring software launchesNewer versions of Mari will need an additional configuration within the software_paths.yml file. The software_paths.yml file is available when you have taken over your configuration. Ensure that your reflects the following paths for Mari to launch, with your specific path, version, and application information added:# Maripath.linux.mari: &quot;Mari4.6&quot;path.mac.mari: &quot;/Applications/Mari4.6v4/Mari4.6v4.app&quot;path.windows.mari: C: Program Files Mari4.6v4 Bundle bin Mari4.6v4.exeSee this software_paths.yml file for reference.Collaboration and EvolutionIf you have access to the ShotGrid Pipeline Toolkit, you also have access to the source code for all apps, engines and ShotGrid in Github where we store and manage them. Feel free to evolve these items; use them as a base for further independent development, make changes (and submit pull requests back to us!) or simply tinker with them to see how they have been built and how the toolkit works. You can access this code repository at https://github.com/shotgunsoftware/tk-mari.",
    "url": "/301f5e66/",
    "relUrl": "/301f5e66/"
  },
  "157": {
    "id": "157",
    "title": "Error {% include product %} tk-maya An exception was raised from Toolkit",
    "content": "Error: ShotGrid tk-maya: An exception was raised from ToolkitUse caseIt is possible for the Toolkit App to be set up to receive custom arguments when it is triggered to run.For example, when you run an app, you may want to provide some kind of state flag which causes the app to launch differently depending on the state.Here are a couple of examples of where this is already used:  The tk-shotgun-folders app, (which creates folders based on the selected entities in the Shotgun web app,) will get passed the Shotgun entity/s and the entity type that the user selected in the Shotgun web app and ran the action on:https://github.com/shotgunsoftware/tk-shotgun-folders/blob/v0.1.7/app.py#L86  The tk-multi-launchapp (which is responsible for launching software with the Shotgun integrations) can be passed a file_to_open arg, which it will then use to open the file once the software is launched:https://github.com/shotgunsoftware/tk-multi-launchapp/blob/v0.11.2/python/tk_multi_launchapp/base_launcher.py#L157Normally when you launch the software through ShotGrid Desktop it won’t provide a file_to_open argument, however, you can call the app via the tank command if you are using a centralized config (tank maya_2019 /path/to/maya/file.mb). Also our tk-shotgun-launchpublish app, in turn, launches the tk-multi-launchapp and provides the published file as the file_to_open arg.https://github.com/shotgunsoftware/tk-shotgun-launchpublish/blob/v0.3.2/hooks/shotgun_launch_publish.py#L126-L133Programming your app to accept argsIf you’re writing a custom app, all you need to do is set the callback method that gets registered with the engine to accept the args you need. Here is a simple app set up to require two args, accept any additional ones, and print them:from sgtk.platform import Applicationclass AnimalApp(Application):    def init_app(self):        self.engine.register_command(&quot;print_animal&quot;, self.run_method)    def run_method(self, animal, age, *args):        print (&quot;&quot;,animal)        print (&quot;age&quot;,age)        print (&quot;args&quot;, args)Running from the tank commandNow if you run the following tank command in a shell: ./tank print_animal cat 7 Tortoiseshell largeit will result in the following being output:...----------------------------------------------------------------------Command: Print animal----------------------------------------------------------------------libpng warning: iCCP: known incorrect sRGB profile('animal', 'cat')('age', '7')('args', ('Tortoiseshell', 'large'))Running from a scriptIf you wanted to call your app from a script on the tk-shell engine you could do the following:# This assumes you have a reference to the `tk-shell` engine.engine.execute_command(&quot;print_animal&quot;, [&quot;dog&quot;, &quot;3&quot;, &quot;needs a bath&quot;])&amp;gt;&amp;gt;# ('animal', 'dog')# ('age', '3')# ('args', ('needs a bath',))if you were in Maya you would do something like:import sgtk# get the engine we are currently running in.engine = sgtk.platform.current_engine()# Run the app.engine.commands['print_animal']['callback'](&quot;unicorn&quot;,4,&quot;it's soooo fluffy!!!!&quot;)&amp;gt;&amp;gt;# ('animal', 'unicorn')# ('age', 4)# ('args', (&quot;it's soooo fluffy!!!!&quot;,))Error messageIf you tried to launch the app from the menu in Maya you would get an error like this:// Error: Shotgun tk-maya: An exception was raised from ToolkitTraceback (most recent call last):  File &quot;/Users/philips1/Library/Caches/Shotgun/bundle_cache/app_store/tk-maya/v0.10.1/python/tk_maya/menu_generation.py&quot;, line 234, in _execute_within_exception_trap    self.callback()  File &quot;/Users/philips1/Library/Caches/Shotgun/mysite/p89c1.basic.maya/cfg/install/core/python/tank/platform/engine.py&quot;, line 1082, in callback_wrapper    return callback(*args, **kwargs)TypeError: run_method() takes at least 3 arguments (1 given) // And that is because the app is set to require the arguments, and the menu button doesn’t know to provide them.How to fixIt is better to write your app’s run_method to use keyword arguments like this:    def run_method(self, animal=None, age=None, *args):        print (&quot;&quot;,animal)        print (&quot;age&quot;,age)        print (&quot;args&quot;, args)Then you can handle what happens if the args are not provided and implement a fallback behavior.See the full thread in the community.",
    "url": "/0c5e6ac8/",
    "relUrl": "/0c5e6ac8/"
  },
  "158": {
    "id": "158",
    "title": "Maya",
    "content": "MayaThe ShotGrid engine for Maya contains a standard platform for integrating ShotGrid Apps into Maya. It is lightweight and straight forward and adds a ShotGrid menu to the Maya menu bar.Supported Application VersionsThis item has been tested and is known to be working on the following application versions:2020 - 2024 Note: Apple Silicon (M1/M2) native is supported starting with Maya 2024.Please note that it is perfectly possible, even likely, that it will work with more recent releases, however it has not yet been formally tested with these versions.PysideThe ShotGrid engine for Maya contains a PySide installation, and will activate this whenever this is necessary.Maya Project ManagementWhenever the ShotGrid engine for Maya starts, it will set the Maya Project to point at a location defined in the settings for this engine. This means that the Project may also change when a new file is opened. The details relating to how the maya project is set based on a file can be configured in the configuration file, using the template system.Installation and UpdatesAdding this Engine to the ShotGrid Pipeline ToolkitIf you want to add this engine to Project XYZ, and an environment named asset, execute the following command:&amp;gt; tank Project XYZ install_engine asset tk-mayaUpdating to the latest versionIf you already have this item installed in a project and you want to get the latest version, you can run the update command. You can either navigate to the tank command that comes with that specific project, and run it there:&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updatesAlternatively, you can run your studio tank command and specify the project name to tell it which project to run the update check for:&amp;gt; tank Project XYZ updatesCollaboration and EvolutionIf you have access to the ShotGrid Pipeline Toolkit, you also have access to the source code for all apps, engines and frameworks in Github where we store and manage them. Feel free to evolve these items; use them as a base for further independent development, make changes (and submit pull requests back to us!) or simply tinker with them to see how they have been built and how the toolkit works. You can access this code repository at https://github.com/shotgunsoftware/tk-maya.",
    "url": "/9e62da4a/",
    "relUrl": "/9e62da4a/"
  },
  "159": {
    "id": "159",
    "title": "Motion Builder",
    "content": "Motion BuilderThe ShotGrid engine for Motion Builder contains a standard platform for integrating ShotGrid Toolkit Apps into Motion Builder. It is light weight and straight forward and adds a ShotGrid menu to the main menu.Supported Application VersionsThis item has been tested and is known to be working on the following application versions:2020 - 2024Please note that it is perfectly possible, even likely, that it will work with more recent releases, however it has not yet been formally tested with these versions.Installation and UpdatesAdding this Engine to the ShotGrid Pipeline ToolkitIf you want to add this engine to Project XYZ, and an environment named asset, execute the following command:&amp;gt; tank Project XYZ install_engine asset tk-motionbuilderUpdating to the latest versionIf you already have this item installed in a project and you want to get the latest version, you can run the update command. You can either navigate to the tank command that comes with that specific project, and run it there:&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updatesAlternatively, you can run your studio tank command and specify the project name to tell it which project to run the update check for:&amp;gt; tank Project XYZ updatesConfiguring software launchesNewer versions of MotionBuilder need an additional configuration within the software_paths.yml file. The software_paths.yml file is available when you have taken over your configuration. Ensure that your reflects the following paths for MotionBuilder to launch, with your specific path, version, and application information added:# Motionbuilderpath.windows.motionbuilder: C: Program Files Autodesk MotionBuilder 2020 bin x64 motionbuilder.exeSee this software_paths.yml file for reference.Collaboration and EvolutionIf you have access to the ShotGrid Pipeline Toolkit, you also have access to the source code for all apps, engines and frameworks in Github where we store and manage them. Feel free to evolve these items; use them as a base for further independent development, make changes (and submit pull requests back to us!) or simply tinker with them to see how they have been built and how the toolkit works. You can access this code repository at https://github.com/shotgunsoftware/tk-motionbuilder.",
    "url": "/54009c12/",
    "relUrl": "/54009c12/"
  },
  "160": {
    "id": "160",
    "title": "About",
    "content": "AboutThis app gives a graphical breakdown of the current work area and all the apps running in the current environment. You can find it on the Context Menu:Reload all appsThere is a handy button this app that reloads the entire environment. This is useful if you are doing development and have made some code changes you want to try out! No need to restart Maya or Nuke, just hit the reload button!In addition to the reload feature, this apps shows a breakdown of your current work area and all the apps that are currently loaded.Three separate views exist:Current Work AreaThis shows the current Shot or Asset, the current Task etc. If you double click any of the items in the list, the system will open the ShotGrid Detail page for that item.Running AppsA view of all the currently running apps, along with their version and description. Double clicking an app will launch the documentation page for that app.Current EnvironmentA view of the currently loaded environment file and engine. This can be useful for debugging purposes 🎀",
    "url": "/c542e4dd/",
    "relUrl": "/c542e4dd/"
  },
  "161": {
    "id": "161",
    "title": "Breakdown",
    "content": "BreakdownIf you are using ShotGrid for managing your Published Files, use the Scene Breakdown app to keep your references up to date. The Scene Breakdown app helps you manage references and versioning of ShotGrid Published Files. The breakdown app allows you to:  Manage references in multiple ShotGrid Projects  Override to a version of a PublishedFile that is not the latest  Get version history file information  Multiple configurable and scalable viewing styles availableBoth the Breakdown and Legacy Breakdown apps are available in your application via the ShotGrid menu &amp;gt; Scene Breakdown.                    Note: You can run both the Breakdown and Legacy Breakdown apps concurrently, as seen in the above image. Running both apps at the same time is the default behavior.    Please refer to the following documentation for the latest breakdown app:  Breakdown App User Documentation  Breakdown App Developer API Documentation  Release NotesLegacy BreakdownThe Legacy Scene Breakdown app shows you a list of referenced content and tells you which items are out of date. You access it from the ShotGrid Menu.You can select one more items and hit update selected. This will switch the items to use the latest version of the content.Scanning the SceneWhen the legacy breakdown app scans the scene for references, it will call a special scanning hook. The scanning hook will return a list of nodes with file corresponding paths. For each reference it finds, it returns the file path, and tank will look at the file path and first check if it recognizes it as a publish, and if it does, see if there is a more recent version available.If the user clicks the update button that is shown for outdated versions, the app will call another hook to do the actual update work. This means that by customizing these hooks it is relatively simple to add new custom nodes to the breakdown.Accessing ShotGrid DataIf you need to access ShotGrid data for the publish you are about to update to in the hook, this is straight forward; a single call to find_publish will retrieve metadata for all the items passed in from the app, like this:class BreakdownHook(Hook):    def update(self, items):        &quot;&quot;&quot;        Perform replacements given a number of scene items passed from the app.        Once a selection has been performed in the main UI and the user clicks        the update button, this method is called.        The items parameter is a list of dictionaries on the same form as was        generated by the scan_scene hook above. The path key now holds        the that each node should be updated *to* rather than the current path.        &quot;&quot;&quot;        engine = self.parent.engine        # resolve ShotGrid data for all paths passed via the items dictionary        sg_data = tank.util.find_publish(engine.sgtk,                                         [i[&quot;path&quot;] for i in items],                                         fields=[&quot;id&quot;, &quot;code&quot;, &quot;version_number&quot;])        for i in items:            node_name = i[&quot;node&quot;]            node_type = i[&quot;type&quot;]            new_path = i[&quot;path&quot;]            # now that each item is processed, it is easy to access the            # ShotGrid data via a dictionary lookup:            sg_data = sg_data.get(i[&quot;path&quot;])            # once we have all our desired info and metadata, we can go ahead            # and apply the update business logic.            # [-business logic here-]API AccessYou can access the breakdown app programatically using its API. The following methods exist:Showing the breakdown UIapp_object.show_breakdown_dialog()If you want to show the breakdown UI, execute the show_breakdown_dialog() method. Assuming the app is included under a tk-multi-breakdown section in your currently running environment, this could for example be done like this:&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; e = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; e.apps[&quot;tk-multi-breakdown&quot;].show_breakdown_dialog()Running the scene analysisitems = app_object.analyze_scene()You can programmatically run the scene analysis logic by executing the analyze_scene() method. This executes exactly the same logic that the breakdown UI uses when it builds the listing of scene items.The method returns a list of breakdown items. Each item is represented by a dictionary with a number of keys to describe the item. Only files whose path corresponds to a template in the Toolkit templates file will be detected. Files do not need to exist as publishes in ShotGrid, however if they do, this method will return basic ShotGrid publish metadata for them.The two keys node_name and node_type are used to return a DCC-centric “address” or representation which makes it possible to identify the path within the DCC. In for example Maya and Nuke, this will return the node name and type. The logic for this is implemented in the hooks and will vary between DCCs. This method will attempt to connect to ShotGrid, but the number of calls made are constant and independent of the scene complexity.Here is an example of what a dictionary in the return data typically looks like:{'fields': {'Sequence': 'aaa',            'Shot': 'aaa_00010',            'Step': 'Comp',            'eye': '%V',            'height': 1556,            'name': 'test',            'output': 'output',            'version': 1,            'width': 2048}, 'template': &amp;lt;Sgtk TemplatePath nuke_shot_render_pub_mono_dpx&amp;gt;,  'node_name': 'Read2', 'node_type': 'Read',  'sg_data': {'code': 'aaa_00010_test_output_v001.%04d.dpx',             'entity': {'id': 1660, 'name': 'aaa_00010', 'type': 'Shot'},             'id': 1424,             'name': 'test',             'published_file_type': {'id': 3,                                     'name': 'Rendered Image',                                     'type': 'PublishedFileType'},             'task': {'id': 4714, 'name': 'Comp', 'type': 'Task'},             'type': 'PublishedFile',             'project': {'id': 234, 'name': 'Climp', 'type': 'Project'},             'version_number': 1}, }Handy Tip!: As you can see above, each item returns a template object and a fields dictionary to represent the path. If you want to see the actual raw path for the item, you can simply run template_obj.apply_fields(fields_dict). In the context of one of the item dictionaries returned by this method, the code would bebreakdown_items = analyze_scene()for item in breakdown_items:   path = item[&quot;template&quot;].apply_fields(item[&quot;fields&quot;])Computing the highest version for an itemhighest_version = app_object.compute_highest_version(template, fields)In order to figure out the highest version for an item, use the compute_highest_version(template, fields) method. The template and fields parameters represent a path that should be analyzed are typically grabbed from the output of the analyze_scene() method. With the breakdown app, the template key containing the version number is always required to be named {version}.This will perform a scan on disk to determine the highest version. The method returns the highest version number found on disk. See the usage example below for more details.Updating a scene itemapp_object.update_item(node_type, node_name, template, fields)In order to update an item, you can use the update_item(node_type, node_name, template, fields) method. The template and fields parameters represent a path that should be updated to. The node_name and node_type parameters are used to identify which node in the scene should be modified. Typically, these  values are grabbed from the output of the analyze_scene() method.This is similar to running the update in the breakdown UI. The actual update call will be dispatched to a hook which handles the DCC specific logic. See the usage example below for more details.Breakdown API exampleBelow is an example showing how to retrieve the scene breakdown and update all items that are not using the latest version.# find the breakdown app instanceimport sgtkengine = sgtk.platform.current_engine()breakdown_app = engine.apps[&quot;tk-multi-breakdown&quot;]# get list of breakdown itemsitems = breakdown_app.analyze_scene()# now loop over all itemsfor item in items:    # get the latest version on disk    latest_version = breakdown_app.compute_highest_version(item[&quot;template&quot;], item[&quot;fields&quot;])        # if our current version is out of date, update it!    current_version = item[&quot;fields&quot;][&quot;version&quot;]    if latest_version &amp;gt; current_version:                # make a fields dictionary representing the latest version        latest_fields = copy.copy(item[&quot;fields&quot;])        latest_fields[&quot;version&quot;] = latest_version                # request that the breakdown updates to the latest version        breakdown_app.update_item(item[&quot;node_type&quot;], item[&quot;node_name&quot;], item[&quot;template&quot;], latest_fields)",
    "url": "/3c0c0ab6/",
    "relUrl": "/3c0c0ab6/"
  },
  "162": {
    "id": "162",
    "title": "Demo",
    "content": "DemoThe Demo App provides live demonstrations of ShotGrid’s native developer platform components including the ShotGrid Utilities framework, the Qt Widgets frameworks and Toolkit core.Each demo displayed in the app includes a working, interactive UI that shows how to use one or more components of the native platform. In addition, the code that is running is readily available to copy and paste into your own app.The app is simple to use. Just select a demo from the list on the left and then interact with the components on the right. Some demos are as simple as displaying a single widget from the Qt Widgets framework. Other demos provide examples of how ShotGrid platform components are commonly wired up for use in production apps.New demos will be added as new components are added to the platform and as time permits. If there is a common pattern of component usage or a demo that you’d like to see, please let us know by submitting a ticket.InstallationTo install the demo app, run the following command:tank install_app project tk-shell tk-multi-demoOnce installed, you can run the following command to launch the app:./tank demos",
    "url": "/42395ae7/",
    "relUrl": "/42395ae7/"
  },
  "163": {
    "id": "163",
    "title": "Launch App",
    "content": "Launch AppThis app provides a shortcut to make it easy to jump from ShotGrid to any supported application. It registers a ShotGrid Action entry called for various entities in ShotGrid according to your configuration choices.How It WorksDepending on your configuration options a menu entry will appear in ShotGrid when right-clicking entities or using the ShotGrid actions menu or gear menu.For example, this screenshot comes from a site who’s configuration uses this app three times to implement menus for Maya, Nuke and Photoshop.Currently supported applications and engines are:  3DSMax  Hiero  Maya  MotionBuilder  Nuke  Photoshop  Mari  Houdini  FlameUse Command Line Arguments at LaunchMany applications have command line options that can be called to choose a different edition of the application (ex. Nuke vs. NukeX) or to specify other various usage aspects.  The launcher app has an ‘args’ setting for each OS that can be configured for this purpose.  For example if you put ‘–nukex’ there, it will add that to the command line launch and NukeX will run instead of regular Nuke:Launch NukeX Examplelaunch_nuke:  engine: tk-nuke  extra: {}  hook_app_launch: default  hook_before_app_launch: default  linux_args: '--nukex'  linux_path: '@nuke_linux'  location: {name: tk-multi-launchapp, type: app_store, version: v0.2.15}  mac_args: '--nukex'  mac_path: '@nuke_mac'  menu_name: Launch Nuke  windows_args: '--nukex'  windows_path: '@nuke_windows'Set Environment Variables and Automate Behavior at LaunchApplications often require certain certain environment variables, plugin paths, etc. to be set in order to properly function in a studio pipeline. The launch app helps cover this case via the ‘before_app_launch’ hook, which allows you to define a snippet of code to run each time an application starts up. By default, the ‘before_app_launch’ hook is a simple pass-through that does nothing, but it can be overridden by following the instructions in this doc.For example, if you use Zync Render, the Zync Maya plugin directory needs to be part of both $PYTHONPATH and $XBMLANGPATH. To have the launch app set these environment variables, update the before_app_launch hook with a few lines of code, as follows:Set Environment Variables Exampledef execute(self, **kwargs):    &quot;&quot;&quot;    The execute functon of the hook will be called to start the required application            &quot;&quot;&quot;    # Example to show how to set env vars on Maya launch    # Append the desired path to the existing $PYTHONPATH to ensure    # everything upstream still works    os.environ[&quot;PYTHONPATH&quot;] = os.environ[&quot;PYTHONPATH&quot;] + os.pathsep + &quot;~/Library/zync/zync-maya&quot;    # Set $XBMLANGPATH to the desired path, may need to append it as    # with $PYTHONPATH if already defined in your pipeline    os.environ[&quot;XBMLANGPATH&quot;] = &quot;~/Library/zync/zync-maya&quot;You can also use the ‘before_app_launch’ to automate other behavior, including ShotGrid updates. For example, you can configure the launch app to update the Task status (in this case, to “in progress”) each time it’s run (as long as the launch is from a Task, of course), as follows:Automate Task Status Update Exampledef execute(self, **kwargs):    &quot;&quot;&quot;    The execute functon of the hook will be called to start the required application            &quot;&quot;&quot;    # If there is a Task in the context, set its status to 'ip'    if self.parent.context.task:        task_id = self.parent.context.task['id']        data = {            'sg_status_list':'ip'        }        self.parent.shotgun.update(&quot;Task&quot;, task_id, data)As you can imagine, there are many possibilities here, and the launch app aims to provide the flexibility your pipeline needs.Launching Applications that do not have an Engine YetYou can also use the launch app to start up applications that do not have a Toolkit engine yet. In this case, folders will be created on disk for the shot, task or asset you are launching from and the application will be launched, but no code will run after application startup and no ShotGrid menu will appear inside the application. This means that you can launch applications that are not yet supported by Toolkit from within ShotGrid.In order to do this, configure the app with paths to the application you wish to launch, but leave the engine option as an empty string.Technical Details3DSMaxThis app automatically adds a MaxScript, init_tank.ms, to the 3DSMax command line that 3DSMax will run as part of its boot process.When 3DSMax is booting, the following will happen:  3DSMax will run init_tank.ms upon starting  init_tank.ms makes sure a Python interpreter is available and runs tank_startup.py  Using the ShotGrid Toolkit Context API, the entity id passed from ShotGrid is converted into a Toolkit Context.  Start the appropriate Engine (via tank.system.start_engine()) and pass in the Context. The engine will take care of the rest.MayaThis app registers a userSetup.py auto start script with Maya which Maya will call as part of its boot process.When Maya is booting, the following will happen:  Maya starts execution of the userSetup.py startup script  Using the ShotGrid Toolkit Context API, the entity id passed from ShotGrid is converted into a Toolkit Context.  Start the appropriate Engine (via tank.system.start_engine()) and pass in the Context. The engine will take care of the rest.MotionBuilderThis app registers a init_tank.py auto start script with MotionBuilder which MotionBuilder will call as part of its boot process.When MotionBuilder is booting, the following will happen:  MotionBuilder starts execution of the init_tank.py startup script  Using the ShotGrid Toolkit Context API, the entity id passed from ShotGrid is converted into a Toolkit Context.  Start the appropriate Engine (via tank.system.start_engine()) and pass in the Context. The engine will take care of the rest.NukeThis app registers a menu.py auto start script with Nuke which Nuke will call as part of its boot process.When Nuke is booting, the following will happen:  Nuke starts execution of the menu.py startup script  Using the ShotGrid Toolkit Context API, the entity id passed from ShotGrid is converted into a Toolkit Context.  Start the appropriate Engine (via tank.system.start_engine()) and pass in the Context. The engine will take care of the rest.PhotoshopThis app will use the Adobe Extension Manager to install or make sure the Tank plugin is installed.When Photoshop is booting, the following will happen:  Photoshop will start the execution of the Tank Plugin  Using the ShotGrid Toolkit Context API, the entity id passed from ShotGrid is converted into a Toolkit Context.  Start the appropriate Engine (via tank.system.start_engine()) and pass in the Context. The engine will take care of the rest.Extra configsIf you intend to use this app to launch Photoshop you will need to supply four config values in the extra section. Here are the configs and sane default values which you would need to adjust for your system and installation locations:mac_python_path: &quot;/usr/bin/python&quot;windows_python_path: &quot;C:  Python27  python.exe&quot;mac_extension_manager_path: &quot;/Applications/Adobe Extension Manager CS6/Adobe Extension Manager CS6.app&quot;windows_extension_manager_path: &quot;C:  Program Files (x86)  Adobe  Adobe Extension Manager CS6  XManCommand.exe&quot;",
    "url": "/1b9c259a/",
    "relUrl": "/1b9c259a/"
  },
  "164": {
    "id": "164",
    "title": "Loader",
    "content": "LoaderThis document describes functionality only available if you have taken control over a Toolkit configuration. Please refer to the ShotGrid Integrations User Guide for details.ConfigurationThe loader is highly configurable and you can set it up in many different ways. There are two main configuration areas:  Setting up what tabs and what content to display in the left hand side tree view.  Controlling which actions to display for different publishes and controlling what the actions actually do.The following sections will give a high level overview how you can configure the loader.For technical minutiae relating to the configuration, please see the separate section further down in the documentation.The tree viewThe tree view is highly configurable and you can control the content of the various tabs using standard ShotGrid filter syntax. Each tab consists of a single ShotGrid API query which is grouped into a hierarchy. You can add arbitrary filters to control which items are being shown, and you can use the special keywords {context.entity}, {context.project}, {context.project.id}, {context.step}, {context.task} and {context.user} to scope a query based on the current context. Each of these keywords will be replaced with the relevant context information, either None, if that part of the context is not populated or a standard ShotGrid link dictionary containing the keys id, type and name.By default, the loader will show assets and shots belonging to the current project. By reconfiguring, this could easily be extended to for example show items from other projects (or a specific asset library project for example). You could also for example use filters to only show items with certain approval status or group items by status or by other ShotGrid fields. Below are some sample configuration settings illustrating how you could set up your tree view tabs:# An asset library tab which shows assets from a specific# ShotGrid projectcaption: Asset Libraryentity_type: Assethierarchy: [sg_asset_type, code]filters:- [project, is, {type: Project, id: 123}]# Approved shots from the current projectcaption: Shotshierarchy: [project, sg_sequence, code]entity_type: Shotfilters:- [project, is, '{context.project}']- [sg_status_list, is, fin]# All assets for which the current user has tasks assignedcaption: Assetsentity_type: Taskhierarchy: [entity.Asset.sg_asset_type, entity, content]filters:- [entity, is_not, null]- [entity, type_is, Asset]- [task_assignees, is, '{context.user}']- [project, is, '{context.project}']Filtering publishesIt is possible to apply a ShotGrid filter to the publish query that the loader carries out when it loads publish data from ShotGrid. This is controlled via the publish_filters parameter and can be used for example to hide publishes that have not been approved or where their associated review version has not been approved.Help, no actions are showing up!The loader comes with a number of different actions for each engine. For example, in the case of Nuke, there are two actions: “import script” and “create read node”. Actions are defined in hooks, meaning that you can modify their behaviour or add additional actions if you wanted to. Then, in the configuration for the loader, you can bind these actions to certain publish types you have. Binding an action to a publish type basically means that the action will appear on the actions menu for all items of that type inside the loader.As an example, by default, the mappings for Nuke are set up like this:action_mappings:  Nuke Script: [script_import]  Rendered Image: [read_node]If you are finding that no action menus are showing up, it may be because you have chosen different names for the publish types that you are using. In that case, go into the config and add those types in order to have them show up inside the loader.Managing actionsFor each application that the loader supports, there is an actions hook which implements the actions that are supported for that application. For example, with something like Maya, the default hook will implement the reference, import and texture_node actions, each carrying out specific Maya commands to bring content into the current Maya scene. As with all hooks, it is perfectly possible to override and change these, and it is also possible to create a hook that derives from the built in hook, making it easy to add additional actions to a built-in hook without having to duplicate lots of code.Once you have defined a list of actions in your actions hook, you can then bind these actions to Publish File types. For example, if you have a Publish File type in your pipeline named “Maya Scene” you can bind this in the configuration to the reference and import actions that are defined in the hook. By doing this, Toolkit will add a reference and an import action to each Maya Scene publish that is being shown. Separating the Publish Types from the actual hook like this makes it easier to reconfigure the loader for use with a different publish type setup than the one that comes with the default configuration.The loader uses Toolkit’s second generation hooks interface, allowing for greater flexibility. This hook format uses an improved syntax. You can see this in the default configuration settings that are installed for the loader, looking something like this:actions_hook: '{self}/tk-maya_actions.py'The {self} keyword tells Toolkit to look in the app hooks folder for the hook. If you are overriding this hook with your implementation, change the value to {config}/loader/my_hook.py. This will tell Toolkit to use a hook called hooks/loader/my_hook.py in your configuration folder.Another second generation hooks feature that the loader is using is that hooks no longer need to have an execute() method. Instead, a hook is more like a normal class and can contain a collection of methods that all makes sense to group together. In the case of the loader, your actions hook will need to implement the following two methods:def generate_actions(self, sg_publish_data, actions, ui_area)def execute_multiple_actions(self, actions)For more information, please see the hook files that come with the app. The hooks also take advantage of inheritance, meaning that you don’t need to override everything in the hook, but can more easily extend or augment the default hook in various ways, making hooks easier to manage.Note that in versions previous to v1.12.0, the application invoked the execute_action hook to execute an action. Newer versions invoke the execute_multiple_actions hook. In order to provide backward compatibility with existing hooks, the execute_multiple_actions hook actually invokes execute_action for each actions provided. If the application is reporting that the execute_multiple_actions hook is not defined after upgrading to v1.12.0 or later, make sure that the actions_hook setting in your environment correctly inherits from the builtin hook {self}/{engine_name}_actions.py. To learn more about how you can derive custom hooks from the builtin ones, see our Toolkit reference documentation.Learn more about the second gen hook format here.By using inheritance in your hook, it would be possible to add additional actions to the default hooks likethis:import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_publish_data, actions, ui_area):        &quot;&quot;&quot;        Returns a list of action instances for a particular publish.        This method is called each time a user clicks a publish somewhere in the UI.        The data returned from this hook will be used to populate the actions menu for a publish.        The mapping between Publish types and actions are kept in a different place        (in the configuration) so at the point when this hook is called, the loader app        has already established *which* actions are appropriate for this object.        The hook should return at least one action for each item passed in via the        actions parameter.        This method needs to return detailed data for those actions, in the form of a list        of dictionaries, each with name, params, caption and description keys.        Because you are operating on a particular publish, you may tailor the output        (caption, tooltip etc) to contain custom information suitable for this publish.        The ui_area parameter is a string and indicates where the publish is to be shown.        - If it will be shown in the main browsing area, &quot;main&quot; is passed.        - If it will be shown in the details area, &quot;details&quot; is passed.        - If it will be shown in the history area, &quot;history&quot; is passed.        Please note that it is perfectly possible to create more than one action &quot;instance&quot; for        an action! You can for example do scene introspection - if the action passed in        is &quot;character_attachment&quot; you may for example scan the scene, figure out all the nodes        where this object can be attached and return a list of action instances:        &quot;attach to left hand&quot;, &quot;attach to right hand&quot; etc. In this case, when more than        one object is returned for an action, use the params key to pass additional        data into the run_action hook.        :param sg_publish_data: ShotGrid data dictionary with all the standard publish fields.        :param actions: List of action strings which have been defined in the app configuration.        :param ui_area: String denoting the UI Area (see above).        :returns List of dictionaries, each with keys name, params, caption and description        &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_publish_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_publish_data):        &quot;&quot;&quot;        Execute a given action. The data sent to this be method will        represent one of the actions enumerated by the generate_actions method.        :param name: Action name string representing one of the items returned by generate_actions.        :param params: Params data, as specified by generate_actions.        :param sg_publish_data: ShotGrid data dictionary with all the standard publish fields.        :returns: No return value expected.        &quot;&quot;&quot;        # resolve local path to publish via central method        path = self.get_publish_path(sg_publish_data)        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_publish_data)We could then bind this new action to a set of publish types in the configuration:action_mappings:  Maya Scene: [import, reference, my_new_action]  Maya Rig: [reference, my_new_action]  Rendered Image: [texture_node]By deriving from the hook as shown above, the custom hook code only need to contain the actual added business logic which makes it easier to maintain and update.ReferenceThe following methods are available on the app instance.open_publish()Presents an ‘Open File’ style version of the Loader that allows the user to select a publish.  The selected publish is then returned.  The normal actions configured for the app are not permitted when run in this mode.app.open_publish( str title, str action, list publish_types )Parameters and Return Value  str title - The title to be displayed in the open publish dialog.  str action - The name of the action to be used for the ‘open’ button.  list publish_types - A list of publish types to use to filter the available list of publishes.  If this is empty/None then all publishes will be shown.  Returns: A list of ShotGrid entity dictionaries that were selected by the user.Example&amp;gt;&amp;gt;&amp;gt; engine = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; loader_app = engine.apps.get[&quot;tk-multi-loader2&quot;]&amp;gt;&amp;gt;&amp;gt; selected = loader_app.open_publish(&quot;Select Geometry Cache&quot;, &quot;Select&quot;, [&quot;Alembic Cache&quot;])&amp;gt;&amp;gt;&amp;gt; print selected",
    "url": "/a4c0a4f1/",
    "relUrl": "/a4c0a4f1/"
  },
  "165": {
    "id": "165",
    "title": "Publish",
    "content": "PublishOverviewThe Publish app allows artists to publish their work so that it can be used by artists downstream. It supports traditional publishing workflows within the artist’s content creation software as well as stand-alone publishing of any file on disk. When working in content creation software and using the basic ShotGrid integration, the app will automatically discover and display items for the artist to publish. For more sophisticated production needs, studios can write custom publish plugins to drive artist workflows.DocumentationFull documentation for the Publisher can be found here!",
    "url": "/bc718491/",
    "relUrl": "/bc718491/"
  },
  "166": {
    "id": "166",
    "title": "Python Console",
    "content": "Python ConsoleThis is a python console panel for use in DCCs with access to a python interpreter that have limited or no support for interacting with said interpreter.PanelOnce installed, the console is registered as a panel in the DCC and is available in the ShotGrid menu. In apps that support embedded Toolkit panels(maya, nuke, houdini), the console will display in a docked panel. When using with older versions of these DCCs or in a DCC that does not support panels, the console will simply be shown as a regular Toolkit dialog.TabsThe python console displays one or more tabs, each containing an editor and an output window. New tabs can be created by clicking the + button in the bottom right hand corner. Tabs have an x button next to the tab name that allow you to delete the tab. Double clicking the tab itself will prompt you to enter a new name for the tab. Tabs can be rearranged via drag and drop. The state of the tabs is saved when the DCC is closed and restored on the next launch.EditorThe console has an input area for editing python. The editor includes line numbers, highlights the cursor’s current line, and does some basic syntax highlighting. The console attempts to use the palette of the DCC to give it an integrated look and feel.Block indenting and unindenting is supported. Select one or more lines and press tab to indent by four spaces or shift + tab to unindent by four spaces. It tries to keep the indentation in blocks of four so it will indent/unindent to the nearest whole block of four spaces.Block commenting and uncommenting is also supported. Select one or more lines and press cmd + / on Mac, ctrl + / for Windows and Linux. If any of the selected lines don’t have a # at the start it will add one to all selected lines. If all the lines do have a #, then it will remove them.OutputThe output area displays the results of the executed python. Echoing the source python commands is turned on by default and is differentiated in the output by being prefixed with &amp;gt;&amp;gt;&amp;gt;. Each execution is also marked with a timestamp. There is a toggle for turning the echo off. Syntax and Runtime errors are shown in red with a full stack trace for debugging.ButtonsOutput  Clear - Clear the contents of the output browser.  Echo - Toggle echoing the executed commands in the output browser.Editor  Execute - Execute the contents of the editor  Save - Save the current contents of the editor to a file.  Open - Open a file in the editor.  Clear - Clear the contents of the editor.  Lines - Toggle line numbers for the current tabGlobalsSome ShotGrid/Toolkit globals are pre-defined in the console, similar to what is available in the ShotGrid Engine for the shell.  Tk API handle is available via the tk variable  ShotGrid API handle is available via the shotgun variable  The current context is stored in the context variable  The shell engine can be accessed via the engine variableExternal sourcesThe app comes with a hook that can be implemented to load python source from an external location. The hook is called external_sources_hook and requires implementing a method called get_external_source_actions. The method should return a list of QActions that, when triggered, add a new tab (with content)to the console. An example implementation is provided that loads gists from github for a list of predefined users. The actions returned by the hook are shown in the popup menu displayed when the Open button is pressed and held.Hotkeys  Execute selected with Ctrl + Enter  Create a new tab with Ctrl + T  Navigate tabs with Ctrl + Shift + [ or Ctrl + Shift + ]  Resize input/output font via Ctrl + WheelNOTE: These hotkeys may not be available in all DCCs.Other notes  In some older versions of DCCs, leaving the python console open when closing the session may cause a crash. We believe this may be a bug in some older versions of PySide. More recent versions of DCCs, bundled with newer versions of PySide, do not appear to crash on exit. If you encounter this issue with a recent DCC release, please submit a ticket so that we can investigate further.",
    "url": "/770a748a/",
    "relUrl": "/770a748a/"
  },
  "167": {
    "id": "167",
    "title": "Review Submission",
    "content": "Review SubmissionHow do I use this App?As an APIThis app have a mode that is meant to be called from inside other apps like the multi-publish app.This mode creates quicktimes from image sequences and submits them as Versions to ShotGrid in order to facilitate review. The generated quicktimes will have slates and burnins. Things such as font, logo position, movie compression options and burnin / slate information are currently hardcoded in the default hooks and as such you are encouraged to re-implement the hook function to adjust the behaviour.Here are a the current default formats for slate and burnin:Should you want to leverage this app from within your own apps or hooks here is a quick rundown of the simple way to go about it.  Get the tk-multi-reviewsubmission app from the current engine. This can be donefrom inside a hook using the call self.parent.engine.apps.get('tk-multi-reviewsubmission').  If the app is available, call the render_and_submit_version() method.Here’s an example of what this can look like inside your hook code:review_submission_app = self.parent.engine.apps.get(&quot;tk-multi-reviewsubmission&quot;)if review_submission_app:    review_submission_app.render_and_submit_version(        template,        fields,        first_frame,        last_frame,        sg_publishes,        sg_task,        comment,        thumbnail_path,        progress_cb,        color_space    )The arguments that you need to pass to render_and_submit_version are as follows:  template: A template that defines where the files to publish are located  fields: Fields that will be used to fill out the template  first_frame: The first frame of the image sequence to process  last_frame: The last frame of the image sequence to process  sg_publishes: A list of ShotGrid Published File objects to link the version to.  sg_task: A ShotGrid Task link dictionary to link the version to.  comment: Text to add to the Version’s description.  thumbnail_path: The path to a thumbnail to use for the version when the movie isn’t being uploaded to ShotGrid (this is set in the config)  progress_cb: A callback to report progress with.  This should be of the form: callback(percent, message)  color_space: The color space that the input frames are in.  In Nuke, this would be one of the enumeration values on the colorspace knob for the Write node.As a menu itemThis mode adds a menu item to the ShotGrid menu inside the DCC. This mode creates a quick snapshot of the current viewport and sends it to ShotGrid Create as a Version draft. Then, the user can extend the review submission inside of ShotGrid Create by adding annotations, text or comparison notes.In order to add this functionality to your context, you need to:  Set the display_name field to have it in the menu item.  Set the render_media_hook field to a hook that tells how to render media in your DCC (tk-photoshopcc and tk-maya have a default implementation)  Set the submitter_hook field to {self}/submitter_create.pyLike this:tk-multi-reviewsubmission:  display_name: Send for review  render_media_hook: '{self}/render_media.py:{self}/{engine_name}/render_media.py'  submitter_hook: '{self}/submitter_create.py'  location:     type: app_store    name: tk-multi-reviewsubmission    version: v1.0.1",
    "url": "/4badd856/",
    "relUrl": "/4badd856/"
  },
  "168": {
    "id": "168",
    "title": "Screening Room",
    "content": "Screening RoomThis is a small app that hooks up your current Maya session with Screening Room. It will add an item to the ShotGrid menu saying Jump to Screening Room. Clicking this button will launch Screening Room and point it at the current ShotGrid Toolkit Context - for example a Shot, Asset or a Task. You can then use Screening Room to browse all submitted content.",
    "url": "/f3e452a2/",
    "relUrl": "/f3e452a2/"
  },
  "169": {
    "id": "169",
    "title": "Set Frame Range",
    "content": "Set Frame RangeThis app helps managing the frame range in the currently open scene. You can access it from the ShotGrid menu by clicking the Sync Frame Range with ShotGrid menu option.When you click it, the ShotGrid Toolkit will look at the ShotGrid entity associated with the current work area (typically a Shot) and look for in and out fields which contain the in and out frame information. Typically, this is something used in conjunction with Shots and in that case the app uses the standard shot in and out fields defined in ShotGrid’s default config. However, it is perfectly possible to configure the app to pull the frame ranges from other fields too.Once you run the App, it will update the current scene with those ins and outs and finally display a summary message:Multiple ShotGrid field synchronisation optionsYou can define multiple instances of this app in the ShotGrid Menu by setting the menu_name property. This allows the possibility to define a multiple menu actions for synchronization of different ShotGrid fields.To do this, set a different app instance name, menu_name and in and out frame fields for each instance:tk-multi-setframerange_cuts:  menu_name: Sync frame range using cut fields  sg_in_frame_field: sg_cut_in  sg_out_frame_field: sg_cut_out  location: &quot;@apps.tk-multi-setframerange.location&quot;tk-multi-setframerange_handles:  menu_name: Sync frame range using handle fields  sg_in_frame_field: sg_handle_in  sg_out_frame_field: sg_handle_out  location: &quot;@apps.tk-multi-setframerange.location&quot;These should then appear as separate options in the ShotGrid menu:Note: this is new to version v0.4.0 of the app.Operations hookThe software specific logic for getting the current scene frame range or setting the frame range is handled in the frame operations hook. If you are wanting to add support for a new engine or want to change how the behaviour is implemented, you can take over the frame operations hook by setting the hook_frame_operation app property and implementing your own get and set logic.Note: this is new to version v0.4.0 of the app.",
    "url": "/8ac43263/",
    "relUrl": "/8ac43263/"
  },
  "170": {
    "id": "170",
    "title": "ShotGrid Panel",
    "content": "ShotGrid PanelThis document describes functionality only available if you have taken control over a Toolkit configuration. Please refer to the ShotGrid Integrations User Guide for details.Configuring the ShotGrid PanelThere are two main areas that you can configure extensively in the ShotGrid Panel: The appearance of text in the UI and the actions you want to associate with data. The sections below outline how to control the configuration for the two systems.Configuring what is being displayedThe values in the detail area and the listings are both configurable through the ShotGrid_fields hook. You can subclass this hook and change the implementation in order to display the exact values you want:Templating SystemThe hook supports a simple templating language, allowing for great flexibility. It also supports the HTML subset supported by Qt, so you can control color, font size, weight, etc. of your displayed values. The template language works in the following way:      ShotGrid values are enclosed in {brackets}, for example &amp;lt;b&amp;gt;Description:&amp;lt;/b&amp;gt; {description}. When this template is rendered, the {description} part will be replaced with the description field value.        If you want an optional pre- or post-fix for a value which is only shown if the value is not empty, you can use the syntax {[Prefix]sg_field[suffix]}. The template {[Start: ]start_date} {[End: ]end_date} will render Start: 12 July 2009 End: 14 July 2012 if both values are populated but Start: 12 July 2009 if end date isn’t set.        You can define fallbacks in the case some values are not set. For ShotGrid Versions, the artist fields takes precedence over the created_by field in order to support a workflow where a producer submits versions on behalf of an artist. In this case, the Version will be created by the producer but the artist field will be set to the artist. This, however, is not always the case - in some cases, artist is left blank in pipelines where artists submit their own work. When displaying versions, it is therefore useful to be able to check the artist field first, and in case this isn’t set, fall back on the created_by field. This is done using the {field1|field2} syntax, for example: Created By: {artist|created_by}. You can combine this with optional fields too, e.g. {[Created By: ]artist|created_by}  This hook contains the following methods:Controlling items appearing in listsThe get_list_item_definition() method returns a dictionary that controls the appearance of items in the various listings, given a ShotGrid entity type. It returns a dictionary with the keys top_left, top_right and body, for example:{ &quot;top_left&quot;: &quot;&amp;lt;big&amp;gt;{code}&amp;lt;/big&amp;gt;&quot;, &quot;top_right&quot;: &quot;{updated_at}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;} Controlling the top detail areaThe get_main_view_definition() method returns a dictionary with the keys title and body given a ShotGrid entity type. These values controls the appearance of an object in the detail area, for example:{ &quot;title&quot;: &quot;{type} {code}&quot;, &quot;body&quot;: &quot;By: {created_by}&amp;lt;br&amp;gt;Description: {description}&quot;} Controlling the fields shown in the Info tabThe get_all_fields() methods returns a list of fields to display for a given entity when this is rendered in the Info tab.Configuring ActionsActions are little snippets of code that operate on a piece of ShotGrid data. Examples include:  An action that launches RV for a given ShotGrid Version  An action that allows a user to assign herself to a given Task  An action that loads a ShotGrid publish into Maya as a Maya reference.The actual payload of an action is defined in an action hook. Once you have defined the action logic, you can then map that action to ShotGrid objects in the app configuration. These action mappings may for example look like this:action_mappings:  PublishedFile:  - actions: [reference, import]    filters: {published_file_type: Maya Scene}  - actions: [texture_node]    filters: {published_file_type: Rendered Image}  Task:  - actions: [assign_task]    filters: {}  Version:  - actions: [play_in_rv]    filters: {}In the above example, we use the actions reference, import, texture_node, assign_task and play_in_rv. We then map the actions to various ShotGrid objects and conditions. For example, we are requesting the import action to appear for all publishes of type Maya Scene.When an object is loaded into the Panel, the action configuration above is read in and analyzed. A list of suitable actions for the current object is determined and the generate_actions() hook method will be executed. ShotGrid data for the given entity will be passed to the hook at this point so that the hook code can determine if the action can be run for this particular ShotGrid object. This is a way to allow each hook to run a check prior to being displayed. For example, the play_in_rv hook may only be relevant in the case there is media available locally - the action mappings set up in the configuration tells the panel which actions to enable for a given ShotGrid entity but they may not all be displayed because the generate_actions() method may determine that they are not suitable for the given object.The actions returned from the generate_actions() method will be displayed on the actions menu and when a user clicks on it, the execute_action() hook method is called to run the action.For each application that the panel supports, there is an actions hook which implements suitable actions. For example, with something like Maya, the default hook will implement reference, import and texture_node actions, each carrying out specific Maya commands to bring publishes into the current Maya scene. As with all hooks, it is perfectly possible to override and change these, and it is also possible to create a hook that derives from the built in hook, making it easy to add additional actions to a built-in hook without having to duplicate lots of code.The panel uses Toolkit’s second generation hooks interface, allowing for greater flexibility. This hook format uses an improved syntax. You can see this in the default configuration settings, looking something like this:actions_hook: '{self}/tk-maya_actions.py'The {self} keyword tells Toolkit to look in the app’s hooks folder for the hook. If you are overriding this hook with your implementation, change the value to {config}/panel/maya_actions.py. This will tell Toolkit to use a hook called hooks/panel/maya_actions.py in your configuration folder.For more information, please see the hook files that come with the app. The hooks also take advantage of inheritance, meaning that you don’t need to override everything in the hook, but can more easily extend or augment the default hook in various ways, making hooks easier to manage.LINKBOX_DOC:5#The%20hook%20data%20type:Learn more about the second gen hook format here.By using inheritance in your hook, it would be possible to add additional actions to the default hooks like this:import sgtkimport os# toolkit will automatically resolve the base class for you# this means that you will derive from the default hook that comes with the appHookBaseClass = sgtk.get_hook_baseclass()class MyActions(HookBaseClass):    def generate_actions(self, sg_data, actions, ui_area):        &quot;&quot;&quot;        Returns a list of action instances for a particular object.        The data returned from this hook will be used to populate the         actions menu.            The mapping between ShotGrid objects and actions are kept in a different place        (in the configuration) so at the point when this hook is called, the app        has already established *which* actions are appropriate for this object.                This method needs to return detailed data for those actions, in the form of a list        of dictionaries, each with name, params, caption and description keys.                Because you are operating on a particular object, you may tailor the output         (caption, tooltip etc) to contain custom information suitable for this publish.                The ui_area parameter is a string and indicates where the publish is to be shown.                 - If it will be shown in the main browsing area, &quot;main&quot; is passed.         - If it will be shown in the details area, &quot;details&quot; is passed.                        :param sg_data: ShotGrid data dictionary with all the standard publish fields.        :param actions: List of action strings which have been defined in the app configuration.        :param ui_area: String denoting the UI Area (see above).        :returns List of dictionaries, each with keys name, params, caption, group and description        &quot;&quot;&quot;        # get the actions from the base class first        action_instances = super(MyActions, self).generate_actions(sg_data, actions, ui_area)        if &quot;my_new_action&quot; in actions:            action_instances.append( {&quot;name&quot;: &quot;my_new_action&quot;,                                      &quot;params&quot;: None,                                      &quot;group&quot;: &quot;Pipeline Utils&quot;,                                      &quot;caption&quot;: &quot;My New Action&quot;,                                      &quot;description&quot;: &quot;My New Action.&quot;} )        return action_instances    def execute_action(self, name, params, sg_data):        &quot;&quot;&quot;        Execute a given action. The data sent to this be method will        represent one of the actions enumerated by the generate_actions method.                :param name: Action name string representing one of the items returned by generate_actions.        :param params: Params data, as specified by generate_actions.        :param sg_data: ShotGrid data dictionary with all the standard publish fields.        :returns: No return value expected.        &quot;&quot;&quot;        if name == &quot;my_new_action&quot;:            # do some stuff here!        else:            # call base class implementation            super(MyActions, self).execute_action(name, params, sg_data)We could then bind this new action to a set of publish types in the configuration:action_mappings:  PublishedFile:  - actions: [reference, import, my_new_action]    filters: {published_file_type: Maya Scene}  Version:  - actions: [play_in_rv]    filters: {}By deriving from the hook as shown above, the custom hook code only need to contain the actual addedbusiness logic which makes it easier to maintain and update.",
    "url": "/c0b0ce05/",
    "relUrl": "/c0b0ce05/"
  },
  "171": {
    "id": "171",
    "title": "Snapshot",
    "content": "SnapshotA ShotGrid Snapshot is a quick incremental backup that lets you version and manage increments of your work without sharing it with anyone else. Take a Snapshot, add a description and a thumbnail, and you create a point in time to which you can always go back to at a later point and restore. This is useful if you are making big changes and want to make sure you have a backup of previous versions of your scene.",
    "url": "/233f8961/",
    "relUrl": "/233f8961/"
  },
  "172": {
    "id": "172",
    "title": "Workfiles",
    "content": "WorkfilesFile Open dialogNavigating your work areasThe main dialog is split in two halves. On the left hand side, there is a series of tabs. The first tab is called “My Tasks” and will display all the tasks that are assigned to the current user. It is very reminiscent of the “My Tasks” page on the ShotGrid website.Alternatively, the user can also browse for a ShotGrid entity using the entities tabs. By default, the workfiles application allows to browse for any tasks associated on shots or assets by looking at the respective tab.The set of tabs is entirely configurable through the entities settings in the environment files.You can disable/enable this dialog by setting the show_file_open: true/false in the app settings.Finding filesOn the right hand-side you will see the working files and publishes associated with the selection from the left hand-side. Working files and publishes can be viewed together or separately using the tabs “All”, “Working” and “Publishes”.Accessing previous versionsThere are two ways to access previous versions. First, the user can click on the “All versions” box at the top of the browser, which will uncollapse the versions and list them all individually in the browser. Another option is to right-click on a file, which will allow you to access the last 10 versions.User sandboxesIf your pipeline configuration uses user sandboxes, only the files for the current user will be seen by default. If the user wants to see the files from other user’s sandboxes, a button at the top will allow to pick which sandboxes to show files from.Narrowing resultsYou can narrow results in the any of the views by typing text. The search will match any item’s name.File Save dialogBy default, the “File Save” dialog allows the user to save a file in the current context. The user will be prompted for a scene name, version number and an optional file extension, if available and the “Save” button will be greyed out. Only once the application has confirmed the next available version number for a scene name will the Save button at the bottom right be enabled.You can disable/enable this dialog by setting the show_file_save: true/false in the app settings.Saving in a different contextIn order to save a file in a different context, a user can click on the expand button at the top-left of the dialog which will expand the “File Save” dialog and allow to pick another context to save into.Adding the file extension dropdownWith the new file save dialog, it is possible to pick the extension of the file being saved. In order to enable this, you need to tweak your pipeline configuration’s templates.yml file. First, a token needs to be defined in the token list inside templates.yml.maya_extension:    type: str    choices:        ma: Maya Ascii (.ma)        mb: Maya Binary (.mb)    default: ma    alias: extensionmaya_extension is the token’s name. choices is a dictionary of file types that will be displayed in the dropdown. The keys (ma and mb) are the possible values that this template token can have. The values (Maya Ascii (.ma) and Maya Binary (.mb)) are UI friendly descriptions that can be used by a Toolkit application. The alias is an hint that is required by the workfiles application. It tells the application that this token is an extension and should be displayed in the dropdown widget.Then, this token can be added to any Maya specific template.maya_shot_work:    definition: '@shot_root/work/maya/{name}.v{version}.{maya_extension}'    root_name: 'primary'Context Change dialogThe context change dialog is similar to the open dialog except that it doesn’t have a the right hand side for file browsing. You can select a task or entity and change your current engine context by pressing press the change context button.You can disable/enable this dialog by setting the show_change_context: true/false in the app settings.Step filteringWhen retrieving Tasks, and if step is included in the hierarchy, the amount of data retrieved from ShotGrid can be reduced with Pipeline Step filtering: only Tasks linked to the selected list of Steps will be retrieved.The list of Steps displayed in a tab is controlled with the step_filter_on setting. If not set, all existing Pipeline Steps are displayed.The example below defines two tabs, respectively displaying Tasks for Assets and Shots:  - caption: Assets Tasks    entity_type: Task    step_filter_on: Asset    filters:    - [entity, type_is, Asset]    hierarchy: [entity.Asset.sg_asset_type, entity, step, content]  - caption: Shots Tasks    entity_type: Task    step_filter_on: Shot    filters:    - [entity, type_is, Shot]    hierarchy: [entity.Shot.sg_sequence, entity, step, content]Deferred queriesFor better performances, building the Entities tree can be broken into two step queries:  A first query is used to retrieve records from ShotGrid and populate the top of the tree.  A second query is used to retrieve children as the user expand the tree.With the following settings, Assets and Shots would be retrieved from ShotGrid when the app is started. And then Tasks linked to a particular Asset or Shot would only be retrieved when this Asset or Shot is selected or expanded in the tree view.  entities:  - caption: Assets    entity_type: Asset    hierarchy: [sg_asset_type, code]    filters:    sub_hierarchy:      entity_type: Task      filters:      link_field: entity      hierarchy: [step]  - caption: Shots    entity_type: Shot    filters:    hierarchy: [sg_sequence, code]    sub_hierarchy:      entity_type: Task      filters:      link_field: entity      hierarchy: [step]",
    "url": "/9a736ee3/",
    "relUrl": "/9a736ee3/"
  },
  "173": {
    "id": "173",
    "title": "Nuke Quickreview",
    "content": "Nuke QuickreviewThe Quickreview app makes it easy to submit Nuke renders for review in ShotGrid. A Version in ShotGrid will be created with each quickreview submission. It appears as a node in Nuke, located on the ShotGrid Node menu. Simply create a new node, attach it to your Nuke network, double click it and click the Upload button.You get presented with the following UI, allowing you control how your Version is created in ShotGrid:The following items can be controlled:  The version name is pre-populated based on the currently loaded nuke script and can be adjusted if needed.  The entity link and task associated with the version is based on the current context and can be adjusted.  The frame range to be submitted can be adjusted.  The created Version can be added to a playlist. A dropdown with recent playlist are being displayed.Once you press the Upload button, a quicktime will be generated in nuke and then uploaded to ShotGrid. Once uploaded, the following screen will be shown, allowing you to either show the Version in the Built-in ShotGrid Panel in Nuke or in the web overlay player.Burnins and slateBy default, the app will generate a Quicktime with a slate and burn-ins:CustomizationMost aspects of the review submission can be adjusted using hooks. Documentation can be found here.",
    "url": "/40da6878/",
    "relUrl": "/40da6878/"
  },
  "174": {
    "id": "174",
    "title": "Nuke Write Node",
    "content": "Nuke Write NodeThe Nuke Write Node App provides a custom ShotGrid Write node which makes it easy to standardise the location where images are rendered to.  It can be configured for each environment.  In addition to the path, the configuration will also determine the render format to be used.General UseIn order to use the ShotGrid Write Node, save your script as a Toolkit work file first and then create a new node via the Nuke menu. This will create a node which looks similar to a normal write node:Rather than entering a path by hand, you just specify an output name and Toolkit will then compute the rest of the path automatically. You can see the computed path in the UI and open up the location on disk by clicking the Show in File System button. The location where the renders are written to depends on the Toolkit configuration.The renders will be versioned and the version number will always follow the current nuke script version which will be incremented automatically when you publish using Multi Publish.Resetting the render pathThe Write Node will cache the current path so that it is still valid if the file is opened outside a Toolkit Work Area.  Occasionally, this can mean that the path becomes out of sync and ‘locked’.  If the render path is locked then renders created with this Write Node cannot be published.To reset a render path, either version-up the scene using the Work-files app’s ‘Version Up Scene’ command or select the Write node individually and in the properties, click Reset Path:Adding Another Write Node ProfileThe ShotGrid Write Node wraps Nuke’s built-in write node, so any format supported by Nuke can be used with the app and additional nodes can be added via configuration.  The simplest way to start is to set up a simple Nuke write node with the parameters you want. For the example, let’s imagine you are doing 16-bit tifs with LZW compression. If you look at your Nuke script in a text editor, the write node will look something like this:Write {    file /Users/ryanmayeda/Desktop/test.%04d.tif    file_type tiff    datatype &quot;16 bit&quot;    compression LZW    checkHashOnRead false    name Write1    xpos -145    ypos -61}The text will tell you what the parameter names and values you need are. In this case it’s datatype and compression. Next, go into your environment configuration (for example: /path/to/pipeline/config/env/shot_step.yml) and find the area where the tk-nuke-writenode app is configured.  Add another Write Node, with these two parameters in the settings:tk-nuke-writenode:  location: {name: tk-nuke-writenode, type: app_store, version: v0.1.6}  template_script_work: nuke_shot_work  ...  write_nodes:  - file_type: exr    ...  - file_type: dpx    ...  - file_type: tiff    name: Mono Tif    publish_template: nuke_shot_render_pub_mono_tif    render_template: nuke_shot_render_mono_tif    proxy_publish_template: null    proxy_render_template: null    settings: {datatype: 16 bit, compression: LZW}    tank_type: Rendered Image    tile_color: []    promote_write_knobs: []The updated configuration will then result in the additional ShotGrid Write Node appearing in Nuke:Note: Be sure to add any new templates (e.g. nuke_shot_render_mono_tif) to your templates.yml file which can be found in your project’s configuration (&amp;lt;configuration root&amp;gt;/config/core/templates.yml).Another example, showing how to add a ShotGrid Write Node that outputs to JPEG with 0.5 compression and a 4:2:2 sub-sampling is shown below. This profile also makes use of the “promote_write_knobs” option to promote the jpeg quality knob to the gizmo’s user interface. This allows the profile to set the default value for quality, but also provide the user the slider to alter that setting themselves:tk-nuke-writenode:  write_nodes:    - file_type: jpeg      name: Compressed JPEG      publish_template: nuke_shot_render_pub_jpeg      render_template: nuke_shot_render_jpeg      proxy_publish_template: null      proxy_render_template: null      settings: {_jpeg_quality: 0.5, _jpeg_sub_sampling: &quot;4:2:2&quot;}      tank_type: Rendered Image      tile_color: []      promote_write_knobs: [_jpeg_quality]Promoting Write KnobsAs shown in the profile example above, knobs from the encapsulated write node can be promoted to become visible in the ShotGrid Write Node’s properties panel. The promoted write knobs are defined as part of a profile and are identified by knob name. Multiple knobs may be promoted.Render Farm IntegrationIt’s common for studios to use a render farm that runs job management tools such as Deadline,  which typically launch Nuke directly when rendering. Because these tools do not launch Nuke in a ShotGrid-aware way (e.g., via Desktop or the tank command), the ShotGrid write node does not have the information it needs to run. We offer a couple options to get around this limitation.Convert ShotGrid write nodes to standard Nuke write nodesA simple solution is to convert the ShotGrid write nodes to regular Nuke write nodes before sending the script to be rendered. There are two options 1. you can enable and use the convert menu options, 2. you can use the API convert methods on the app.Enabling the convert menu optionsThere is a configuration option called show_convert_actions that can be added to the app’s settings in the environment yml files. When you add the setting show_convert_actions: True, the Convert SG Write Nodes to Write Nodes… and Convert Write Nodes back to SG format… menu options become available.However if you have any ShotGrid Write node profiles defined that promote write knobs, then these menu options will be hidden even if the show_convert_actions is set to True. This is because at present the convert back functionality does not support promoted knobs.Using the API to ConvertThere is a convert_to_write_nodes() method that performs this conversion available on the tk-nuke-writenode app.To convert all ShotGrid write nodes in a script to regular Nuke write nodes, run the following code inside Nuke:import sgtkeng = sgtk.platform.current_engine()app = eng.apps[&quot;tk-nuke-writenode&quot;]if app:    app.convert_to_write_nodes() This will remove the ShotGrid write nodes from the scene, so our suggested workflow is that you make a copy of the script to be rendered, perform the conversions on the copy, and submit the copy to the farm. The scene no longer has any Toolkit references and thus Toolkit is not required when the nuke script opened on the render farm.Note: There is a corresponding convert_from_write_nodes() method available, but to ensure data integrity, we recommend that it only be used for debugging and not as part of your pipeline.Bootstrap the ShotGrid Pipeline Toolkit engine using init.pyNuke will run any init.py scripts found in its plugin path. This option consists of adding code to init.py that will perform a minimal bootstrap of the tk-nuke engine, so that ShotGrid write nodes behave as expected on the render farm.There are a few steps to this workflow: First, a “pre-flight” submission script that runs in a ShotGrid-aware Nuke session gets data that will be used to set the environment for your farm job. Next, additional environment variables used to authenticate the ShotGrid session on the render farm are set by render farm administrators. Finally, an init.py with the ShotGrid bootstrap code is placed in a location where the Nuke session on the render farm will detect and run it, bootstrapping the tk-nuke engine within the session, and allowing the ShotGrid write nodes to function properly.1. Pre-flight submission scriptThis approach assumes that artists are submitting farm jobs within a ShotGrid-aware session of Nuke. At submission time, the following code should run. It pulls environment information like Toolkit context, Pipeline Configuration URI, Toolkit Core API location, etc. from the current Nuke session to populate a dictionary that will be passed to the render job, where it will be used to set environment variables.# Populating environment variables from running Nuke:# https://developer.shotgridsoftware.com/tk-core/platform.html#sgtk.platform.create_engine_launchercurrent_engine = sgtk.platform.current_engine()launcher = sgtk.platform.create_engine_launcher(     current_engine.sgtk,     current_engine.context,     current_engine.name)# Get a dictionary with the following keys:# SHOTGUN_SITE: The ShotGrid site url# SHOTGUN_ENTITY_TYPE: The ShotGrid Entity type, e.g. Shot# SHOTGUN_ENTITY_ID: The ShotGrid Entity id, e.g. 1234environment = launcher.get_standard_plugin_environment()# Get the current pipeline config descriptorenvironment[&quot;SHOTGUN_CONFIG_URI&quot;] = os.path.join(current_engine.sgtk.configuration_descriptor.get_uri(),&quot;config&quot;)# Get the current tk-core installation pathenvironment[&quot;SHOTGUN_SGTK_MODULE_PATH&quot;] = sgtk.get_sgtk_module_path()Once you’ve gathered this information, you can pass it to your render submission tool. This process will vary depending on the render farm management system you’re using. Consult your farm management system documentation for more information on how to write render submission scripts.2. ShotGrid authenticationThe bootstrap API’s ToolkitManager requires a script user in order to initialize. In our example, we’re assuming that your site name, script user, and script key exist as environment variables on the farm machine. Typically this is managed by the render farm administrator. Here are the environment variable names our code is expecting, with sample values:SHOTGUN_SITE = “https://mysitename.shotgunstudio.com”SHOTGUN_FARM_SCRIPT_USER = “sg_api_user”SHOTGUN_FARM_SCRIPT_KEY = “xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx”For more information on authentication, see our developer documentation.A note on securing your script user: It’s good practice to lock down the script user you use on the farm so that it doesn’t have admin-level permissions. You can learn more about API user permissions here.3. The init.py scriptAt this point, Toolkit environment data is being passed from the render submission tool, and authentication data is in environment variables on the render farm machine. The final piece to bootstrapping Toolkit within your render job is to place the following example init.py code in Nuke’s plugin path, so that Nuke will launch it at startup time. (See the Foundry’s documentation on startup scripts for more details.)# This script shows how a Toolkit as a plugin approach could be used to bootstrap# Toolkit in Nuke on the render farm.# https://developer.shotgridsoftware.com/tk-core/bootstrap.html#bootstrapping-toolkitimport sysimport os# If your render nodes can access the same tk-core install location as# artist workstations, retrieve its path from the environment and ensure# it is in the PYTHONPATHTK_CORE_PATH = os.environ[&quot;SHOTGUN_SGTK_MODULE_PATH&quot;]if TK_CORE_PATH not in sys.path:    sys.path.append(TK_CORE_PATH)# If your render nodes don’t have access to the Toolkit Core API in the same filesystem location as artist workstations, you have to make sure that it is available in the PYTHONPATH, so that render nodes can import it. An easy way # to install tk-core in a centralized location is with pip. You can read more # about it here:# https://developer.shotgridsoftware.com/tk-core/bootstrap.html#installing-the-sgtk-module-using-pipimport sgtk# Authenticate using a pre-defined script user.sa = sgtk.authentication.ShotgunAuthenticator()# Here we retrieve credentials from environment variables, assuming a script user# will be used when rendering. This should be typically be handled by your render# farm administrators.SG_SITE_URL = os.environ[&quot;SHOTGUN_SITE&quot;]SG_SCRIPT_USER = os.environ[&quot;SHOTGUN_FARM_SCRIPT_USER&quot;]SG_SCRIPT_KEY = os.environ[&quot;SHOTGUN_FARM_SCRIPT_KEY&quot;]user = sa.create_script_user(    api_script=SG_SCRIPT_USER,    api_key=SG_SCRIPT_KEY,    host=SG_SITE_URL)# Start up a Toolkit Manager with our script usermgr = sgtk.bootstrap.ToolkitManager(sg_user=user)# Set the base pipeline configuration from the environment variable:mgr.base_configuration = os.environ[&quot;SHOTGUN_CONFIG_URI&quot;]# Disable ShotGrid lookup to ensure that we are getting the Pipeline # Configuration defined in SHOTGUN_CONFIG_URI, and not a dev or override# Pipeline Configuration defined in ShotGrid.mgr.do_shotgun_config_lookup = False# Set a plugin id to indicate to the bootstrap that we are starting# up a standard Nuke integrationmgr.plugin_id = &quot;basic.nuke&quot;# Retrieve the Toolkit context from environment variables:# SHOTGUN_SITE: The ShotGrid site url# SHOTGUN_ENTITY_TYPE: The ShotGrid Entity type, e.g. Shot# SHOTGUN_ENTITY_ID: The ShotGrid Entity id, e.g. 1234sg_entity = mgr.get_entity_from_environment()# Now start up the Nuke engine for a given ShotGrid Entitynuke_engine = mgr.bootstrap_engine(&quot;tk-nuke&quot;, entity=sg_entity)You may need to extend this if your configuration is more complex than this example or if you are passing a Python script to the command line using the -t flag instead of a nuke (.nk) script.Deadline-specific stepsDeadline can copy Nuke scripts to a temporary location when rendering. This will cause problems with Toolkit as the files will no longer be in a disk location that it recognizes. To disable this behavior and load the scripts from their original location:  In Deadline, navigate to Tools &amp;gt; Configure Plugin (In the super user mode)  Disable the ‘Enable Path Mapping’ optionTechnical DetailsThe following API methods are available on the App:get_write_nodes()Return a list of all ShotGrid Write Nodes in the current scene.list app.get_write_nodes()Parameters &amp;amp; Return Value  Returns: list - a list of Toolkit Write nodes found in the sceneExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()get_node_name()Return the name of the specified Write Node.string get_node_name(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the name of the node.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_name(nodes[0])get_node_profile_name()Get the name of the configuration profile used by the specified Write node.string get_node_profile_name(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the profile name for this Write Node as defined by the configurationExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_profile_name(nodes[0])get_node_render_path()Get the path that the specified Write node will render images to.string get_node_render_path(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the render path for this nodeExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_path(nodes[0]) get_node_render_files()Get a list of all image files that have been rendered for the specified Write Node.list get_node_render_files(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: list - a list of the image files rendered by this Write node.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_files(nodes[0])get_node_render_template()Get the template that determines where rendered images will be written to for the specified Write Node as defined in the configuration.template get_node_render_template(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: template - the render template this node is configured to use.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_render_template(nodes[0]) get_node_publish_template()Get the template that determines where rendered images will be published to for the specified Write Node as defined in the configuration.template get_node_publish_template(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: template - the publish template this node is configured to use.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_publish_template(nodes[0]) get_node_proxy_render_path()Get the path that the specified Write node will render proxy images to.string get_node_proxy_render_path(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the proxy render path for this nodeExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_path(nodes[0]) get_node_proxy_render_files()Get a list of all proxy image files that have been rendered for the specified Write Node.list get_node_proxy_render_files(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: list - a list of the proxy image files rendered by this Write node.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_files(nodes[0])get_node_proxy_render_template()Get the template that determines where proxy rendered images will be written to for the specified Write Node as defined in the configuration.If there is no proxy render template configured for the specified node then this will return the regular render template instead.template get_node_proxy_render_template(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: template - the proxy render template this node is configured to use.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_render_template(nodes[0]) get_node_proxy_publish_template()Get the template that determines where proxy rendered images will be published to for the specified Write Node as defined in the configuration.If there is no proxy publish template configured for the specified node then this will return the regular publish template instead.template get_node_proxy_publish_template(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: template - the proxy publish template this node is configured to use.Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_proxy_publish_template(nodes[0]) get_node_published_file_type()Get the Published File Type to be used when Published files are created for images rendered by the specified Write node as defined in the configuration.string get_node_published_file_type(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the Published File Type this node is configured to useExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.get_node_published_file_type(nodes[0]) generate_node_thumbnail()Generate a thumbnail for the specified Write Node.  This will render a frame from the middle of the sequence with a maximum size of 800x800px to a temp file (.png).  It is the responsibility of the caller to clean up this file when it is no longer needed.string generate_node_thumbnail(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: string - the path to the rendered thumbnail image on diskExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.generate_node_thumbnail(nodes[0]) reset_node_render_path()Reset the render path for the specified Write Node to match the current script.None reset_node_render_path(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: None - no value is returnedExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.reset_node_render_path(nodes[0]) is_node_render_path_locked()Determine if the render path for the specified Write node is locked or not.bool is_node_render_path_locked(node node)Parameters &amp;amp; Return Value  node node - the Write Node to query  Returns: bool - True if the render path is locked, otherwise FalseExample&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; nodes = app.get_write_nodes()&amp;gt;&amp;gt;&amp;gt; app.is_node_render_path_locked(nodes[0]) convert_to_write_nodes()Convert all ShotGrid write nodes found in the current Script to regular Nuke Write nodes.  Additional toolkit information will be stored on user knobs named ‘tk_*’None convert_to_write_nodes()Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.convert_to_write_nodes() convert_from_write_nodes()Convert all regular Nuke Write nodes that have previously been converted from ShotGrid Write nodes, back into ShotGrid Write nodes.None convert_from_write_nodes()Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.convert_from_write_nodes() process_placeholder_nodes()Convert any placeholder nodes into full ShotGrid Write Nodes.  This is primarily used to convert placeholder nodes created by the Hiero Toolkit script exporter when a script is first opened in Nuke.None process_placeholder_nodes()Example&amp;gt;&amp;gt;&amp;gt; import sgtk&amp;gt;&amp;gt;&amp;gt; eng = sgtk.platform.current_engine()&amp;gt;&amp;gt;&amp;gt; app = eng.apps[&quot;tk-nuke-writenode&quot;]&amp;gt;&amp;gt;&amp;gt; app.process_placeholder_nodes() ",
    "url": "/09168e73/",
    "relUrl": "/09168e73/"
  },
  "175": {
    "id": "175",
    "title": "Nuke",
    "content": "NukeThe ShotGrid engine for Nuke contains a standard platform for integrating ShotGrid Apps into Nuke, Nuke Studio, and Hiero. It is light weight and straight forward and adds a bunch of new things to Nuke.It creates a ShotGrid Menu in Nuke on which various items are displayed:It creates a ShotGrid Node Menu in Nuke on which various items are displayed:It adds ShotGrid shortcuts to the file dialogs which makes it easy to jump to various file system locations:You can add your own shortcuts based on template paths in your current environment with the favourite_directories setting. The setting expects a list of dictionaries, with each item in the list representing a new favourite directory. Here is an example of the format you would use: (the icon can also be left unspecified by providing “” as the value.)  favourite_directories:  - display_name: &quot;Shot Publish Path&quot;    template_directory: &quot;shot_publish_area_nuke&quot;    icon: &quot;icons/custom_publish_icon.png&quot;  - display_name: &quot;Shot Work Path&quot;    template_directory: &quot;shot_work_area_nuke&quot;    icon: &quot;icons/custom_work_icon.png&quot;The “ShotGrid Current Project” favourite is added automatically for each root defined. You can customize the name with the project_favourite_name setting, or disable these favourites by setting the value to an empty string ''Supported Application VersionsThis item has been tested and is known to be working on the following application versions:12.0 - 14.0v5Please note that it is perfectly possible, even likely, that it will work with more recent releases, however it has not yet been formally tested with these versions.Note: There is currently a bug in Nuke 8.0 running specifically on CentOS 6.5 that causes Nuke to crash when running Toolkit. Other versions of CentOS are unaffected. The Foundry is aware of this issue (bug 43766). If you are running into this, please contact us so we can try and help you workaround it until it is resolved in a future update of Nuke.Configuring software launchesNewer versions of Hiero need an additional configuration within the software_paths.yml file. The software_paths.yml file is available when you have taken over your configuration. Ensure that your reflects the following paths for Hiero to launch, with your specific path, version, and application information added:# Hieropath.linux.hiero: &quot;Nuke12.1&quot;path.mac.hiero: &quot;/Applications/Nuke12.1v4/Hiero12.1v4.app&quot;path.windows.hiero: C: Program Files Nuke12.1v4 Nuke12.1.exeSee this software_paths.yml file for reference.Information for App DevelopersContext TrackingThe ShotGrid engine for Nuke will switch context automatically when files are loaded. Whenever a file is loaded, the engine will look at the file, try and resolve a context from it.Apps with custom gizmosThe ShotGrid engine for Nuke makes it easy to handle custom gizmos. If you are writing an app which uses custom gizmos, you can just drop them into a folder called gizmos and the engine will automatically add that location to the nuke path:You can then easily access your gizmo via the create node functionality:  nuke.createNode(&quot;WriteTank&quot;)                    Warning: Please note that while the use of gizmos may be convenient, it is typically NOT the right solution if you want to create nodes that persist in a scene. The reason for this is because as soon as you have put a gizmo in the scene, you have introduced a dependency between that scene and the gizmo code. Not only will you need to load the ShotGrid Toolkit every time you load the scene, but you also need to carefully manage your code so that any updates to the code does not break old gizmos being used in scenes.    Apps Creating NodesApps that create custom nuke nodes need to be carefully crafted. We recommend not using gizmos since these require a dependency between the scene and the gizmo code. Instead, save your custom nodes as a nuke file and import them into the scene:    group_node_script = os.path.join(self.disk_location, &quot;resources&quot;, &quot;my_group_node.nk&quot;)    group_node = nuke.nodePaste(group_node_script)Any code calling the node from within the app can just use the instance returned.Any code needing to call the app from inside the group should do so carefully so that the code is backwards compatible. We recommend the following approach:At app startup, register app handle as part of the nuke namespace:    def init_app(self):        nuke.tk_nuke_nameofmyapp = selfIf you for example have a button on your group node and want to call some ShotGrid app code, try to gracefully fail if the ShotGrid Toolkit cannot be found. The below code is code that is associated with a python button knob that belongs to the group node that the app can create:# have to gracefully support the case when # sgtk is not in the system at all!import nuketry:  app = nuke.tk_nuke_nameofmyapp  app.do_something_v1(nuke.thisNode())except:  nuke.warning(&quot;Could not do XYZ! Most likely Sgtk is not currently active.&quot;)If you make changes to the app behaviour, just keep versioning up the version number on the app callback and that way your app code can support both the new and the old behaviour.Using the ShotGrid Engine for Nuke within HieroThe ShotGrid engine for Nuke is also used for ShotGrid-aware integrations running within Hiero.It allows you to place ShotGrid App actions in several places in the application, both in a specific ShotGrid menu on the main menu bar and in the various right click context menus that you find in the different Hiero panels.How to Configure Hiero MenusBecause Hiero has several different menus, there are more options to configure where menu items go than in Maya or Nuke, for example. The ShotGrid engine for Nuke’s Hiero workflow configuration may look like this:  tk-hiero:    location: {name: tk-nuke, type: app_store, version: v0.6.9}    debug_logging: false    timeline_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: Open in Shotgun, requires_selection: true}    spreadsheet_context_menu:    - {app_instance: tk-hiero-openinshotgun, keep_in_menu: false, name: Open in Shotgun, requires_selection: true}    bin_context_menu:    - {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;ShotGrid Save As...&quot;, requires_selection: true}    - {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;Version up Current Scene...&quot;, requires_selection: true}    - {app_instance: tk-multi-snapshot, keep_in_menu: false, name: &quot;Snapshot...&quot;, requires_selection: true}    - {app_instance: tk-multi-snapshot, keep_in_menu: false, name: &quot;Snapshot History...&quot;, requires_selection: true}    - {app_instance: tk-multi-publish, keep_in_menu: false, name: &quot;Publish Project...&quot;, requires_selection: true}    menu_favourites:    - {app_instance: tk-multi-workfiles, name: Shotgun File Manager...}Most engines have a menu_favourites option, a list where you can specify “shortcuts” which are put on the main ShotGrid menu. In addition to this, the Hiero-specific configuration has three special sections:  timeline_context_menu represents the menu you get when you right click on a clip in thetime line editor.  spreadsheet_context_menu represents the menu you get when you right click on a selection ofitems in the spreadsheet editor.  bin_context_menu represents the menu you get when you right click on a selection in of itemsin the bin editor, where you see all the different projects and media.In order to add items to these menus, just make sure that the name field you define in the config matches what the App is displaying on its menus.Apps which require the concept of a current sceneSome Toolkit Apps requires a notion of a default scene or default project. For example, the snapshot app knows how to snapshot the current scene. However, unlike Maya or Nuke, Hiero does not have a concept of a current scene. Several projects can be opened in Hiero at the same time. Therefore, you often need to add special logic in your hooks to help an app (like the snapshot app) to find out which project is being clicked on. We show how this works in the following doc sections.Information for App DevelopersBecause Hiero does not have the notion of a current project, we have added more powerful tools so that Apps can easily find out what is being clicked on inside of Hiero. Therefore, two methods have been added to the ShotGrid engine for Hiero:get_menu_selection()Returns the list of Hiero objects selected in the most recent menu click.This list may contain items of various types. To see exactly what is beingreturned by which methods, turn on debug logging - this will print out detailsof what is going on.Examples of objects that are being returned are:  Selecting a project in the bin view: hiero.core.Bin  Selecting an item in a bin view: hiero.core.BinItem  Selecting a track: hiero.core.TrackItemlist engine_object.get_menu_selection()Parameters &amp;amp; Return Value  Returns: List of Hiero ObjectsExampleGet the objects selected in the most recent click,ensure that a single object was selected and that thisobject is a valid Hiero project. This can be useful for example if you want to triggersave, load or publish operations for a project in Hiero.# get the menu selection from the engineselection = engine_obj.get_menu_selection()if len(selection) != 1:    raise TankError(&quot;Please select a single Project!&quot;)if not isinstance(selection[0] , hiero.core.Bin):    raise TankError(&quot;Please select a Hiero Project!&quot;)project = selection[0].project()if project is None:    # apparently bins can be without projects (child bins I think)    raise TankError(&quot;Please select a Hiero Project!&quot;)HieroEngine.get_menu_category()Returns the UI area where the last menu click took place. This command is lesslikely to be used - you may need it in cases where you have an app command that you wantto behave differently depending on which menu it was called from.area_enum engine_object.get_menu_category()Parameters &amp;amp; Return ValueReturns one of the following constants:  HieroEngine.HIERO_BIN_AREA  HieroEngine.HIERO_SPREADSHEET_AREA  HieroEngine.HIERO_TIMELINE_AREA  None for unknown or undefinedHow to configure your hooks to work with HieroMulti Apps configured for Hiero will typically need to find out which project was being clicked on. For example, the tk-multi-workfiles App needs to do a “ShotGrid Save As” of a project. We therefore add the Tank Save As command to the bin menu in Hiero so that a user can right click a project in the bin view and select the Save As option.The engine configuration would look like this:bin_context_menu:- {app_instance: tk-multi-workfiles, keep_in_menu: false, name: &quot;ShotGrid Save As...&quot;, requires_selection: true}Now, in the app itself, each engine needs to configure a hook which handles scene events such assave and load. For an application like Maya or Nuke, this is normally just doing a save, a load etc.But for Hiero, we need to start by finding out which project was actually clicked. The hook codein our example above would look like this:class SceneOperation(Hook):    &quot;&quot;&quot;    Hook called to perform an operation with the    current scene    &quot;&quot;&quot;    def execute(self, operation, file_path, context, **kwargs):        &quot;&quot;&quot;        Main hook entry point        :operation: String                    Scene operation to perform        :file_path: String                    File path to use if the operation                    requires it (e.g. open)        :context:   Context                    The context the file operation is being                    performed in.        :returns:   Depends on operation:                    'current_path' - Return the current scene                                     file path as a String                    'reset'        - True if scene was reset to an empty                                     state, otherwise False                    all others     - None        &quot;&quot;&quot;        if operation == &quot;current_path&quot;:            # return the current script path            project = self._get_current_project()            curr_path = project.path().replace(&quot;/&quot;, os.path.sep)            return curr_path        elif operation == &quot;open&quot;:            # open the specified script            hiero.core.openProject(file_path.replace(os.path.sep, &quot;/&quot;))        elif operation == &quot;save&quot;:            # save the current script:            project = self._get_current_project()            project.save()        elif operation == &quot;save_as&quot;:            project = self._get_current_project()            project.saveAs(file_path.replace(os.path.sep, &quot;/&quot;))        elif operation == &quot;reset&quot;:            # do nothing and indicate scene was reset to empty            return True        elif operation == &quot;prepare_new&quot;:            # add a new project to hiero            hiero.core.newProject()    def _get_current_project(self):        &quot;&quot;&quot;        Returns the current project based on where in the UI the user clicked        &quot;&quot;&quot;        # get the menu selection from the engine        selection = self.parent.engine.get_menu_selection()        if len(selection) != 1:            raise TankError(&quot;Please select a single Project!&quot;)        if not isinstance(selection[0] , hiero.core.Bin):            raise TankError(&quot;Please select a Hiero Project!&quot;)        project = selection[0].project()        if project is None:            # apparently bins can be without projects (child bins I think)            raise TankError(&quot;Please select a Hiero Project!&quot;)        return projectUsing debug logging to see menu eventsIf you want to see which objects are returned by Hiero when a certain selection is clicked on,just turn on the engine debug mode. In the script editor you get a summary of the objectsthat are selected with each click:",
    "url": "/4dc252e5/",
    "relUrl": "/4dc252e5/"
  },
  "176": {
    "id": "176",
    "title": "Photoshop",
    "content": "PhotoshopThe ShotGrid engine for Photoshop CC provides a platform for integrating ShotGrid into your Photoshop CC workflow. It consists of a standard ShotGrid Pipeline Toolkit engine and relies on the tk-framework-adobe (CEP).Once enabled, a ShotGrid Adobe Panel becomes available in Photoshop CC. It displays information about the current ShotGrid context as well as the commands that are registered for the apps installed in that context.Supported Application VersionsThis item has been tested and is known to be working on the following application versions:2020 (v21.0) - 2023 (v24.7) Note: Apple Silicon (M1/M2) native is not supported, Apple Silicon with Rosetta is supported, learn more here.Please note that it is perfectly possible, even likely, that it will work with more recent releases, however it has not yet been formally tested with these versions.Interface OverviewThe ShotGrid extension panel uses the same color palette and basic layout as native Photoshop CC panels. It is comprised of five components:  Context Header - Thumbnail and fields for the current context.  Favorites Shelf - Designed to show the most commonly-used apps for the current context.  Command List - All non-favorited commands for the current context.  Context Menu - Additional context-related commands and debugging tools.  Logging Console - A console overlay that displays logging output for debugging.InstallationInstallation of the ShotGrid Engine for Photoshop CC follows the same protocol as the other ShotGrid integrations. For information on installing engines and apps, see the Administering Toolkit article. In addition, you can reference the default toolkit config as an example of how to configure the integration.Enabling the extensionOnce the extension is installed, it will need to be launched via the extensions menu in Photoshop CC.This will only need to be done once and the ShotGrid extension panel can remain in the Photoshop CC layout without having to be enabled on subsequent launches.Once enabled, and on future launches, the extension panel will display a loading screen while the ShotGrid integration is bootstrapping.This screen typically displays for a few seconds before the current context is determined and the commands are displayed.Interface componentsThe following sections outline the components of the ShotGrid Photoshop CC integration.Context headerThe context header is a customizable area which can display information about the current ShotGrid context.The context is determined by the currently-active document. Once the context is determined by the engine, the header will update to display the context’s thumbnail field detail. The field information is controlled by a hook. For information on how to customize the field display, see the Context Fields Display Hook section below.It should also be noted that since Photoshop CC is a multi-document interface, the context, and therefore the ShotGrid extension, will update as you change the active document. It is important that artists understand this behavior, especially when working in multiple ShotGrid contexts simultaneously.Favorites shelfThe favorites shelf is similar to the menu favorites available in other ShotGrid DCC integrations such as Maya and Houdini. This section of the interface makes the most commonly used Toolkit apps readily available and easy to find just under the context header.The shelf displays the favorited commands as buttons that, when moused over, transition from grayscale to color and display their name in the label at the top. Tooltips for the buttons will show by hovering the mouse above them.Clicking one of the buttons will trigger the callback for the registered command to execute.For details on how to specify command favorites, see the Shelf Favorites section below.Command listThe command list shows the other “regular” commands that are registered for the current context.Typically, apps installed within a pipeline configuration will register one or more commands that are displayed here. If the commands are not identified as favorites, and are not identified as context-menu commands, they will display here.The command list buttons behave in a manner similar to those in the favorites shelf. The only real difference is that they display as a list with the full name to the right of their icon.Context menuAny commands registered as context menu commands will show in the ShotGrid extension panel’s context menu.Like the other command areas, these commands will change along with the context. Commands such as Jump to ShotGrid and Jump to Filesystem will always be available here.Logging consoleThe logging console shows all of the logging output from both the CEP Javascript interpreter and Toolkit’s Python process.If there are any issues with the extension that require support, the logging console output is extremely useful for helping the ShotGrid support team debug the problem.Configuration and technical detailsThe following sections outline some of the more technical aspects of the integration to help configure the integration to the specific needs of your studio pipeline.PySideThe ShotGrid engine for Photoshop CC relies on PySide. Please see the official instructions for Installing Pyside.CEP extensionThe extension itself is bundled with the engine and the engine handles installation automatically on the first launch of Photoshop CC. The extension is installed on the artist’s local machine in the standard, OS-specific CEP extension directories:# Windows&amp;gt; C: Users [user name] AppData Roaming Adobe CEP extensions # OS X&amp;gt; ~/Library/Application Support/Adobe/CEP/extensions/Each time Photoshop CC is launched, the engine bootstrap code will check the version of the extension that is bundled with the engine against the version that is installed on the machine. This means that after an engine update, assuming a new version of the extension came with it, the installed extension will be automatically updated to the newly-bundled version.Configuring favoritesThe Favorites Shelf can be configured to display any of the registered commands for your installed apps. To do this, simply add the shelf_favorites setting to the tk-photoshopcc section of your environment configuration. Here’s an example:shelf_favorites:    - {app_instance: tk-multi-workfiles2, name: File Save...}    - {app_instance: tk-multi-workfiles2, name: File Open...}    - {app_instance: tk-multi-publish, name: Publish...}    - {app_instance: tk-multi-snapshot, name: Snapshot...}The value of the setting is a list of dictionaries identifying a registered command provided by one of the installed apps in the configuration. The app_instance key identifies a particular installed app and the name key matches the command’s display name registered by that app. In the example above, you can see four favorited commands: the file open and save dialogs from the tk-multi-workfiles2 app as well as the standard Toolkit publish and snapshot dialogs. These four commands will now show in the favorites shelf.Context fields display hookThe engine comes with a hook to control the fields displayed in the Context Header section of the panel. There are two methods in the hook that can be overridden to customize what is displayed.The first method is the get_entity_fields() method. This method accepts an entity type representing the current ShotGrid context. The expected return value is a list of fields for that entity that should be queried for display. The engine itself handles querying the data asynchronously.Once the data has been queried from ShotGrid, the second method in the hook is called. This method, get_context_html(), receives the context entity dictionary populated with the queried fields specified by the get_entity_fields() method. The expected return value is a string containing formatted HTML to display the queried entity fields.The default hook implementation is a good reference as to what is required by these methods.It should be noted that the engine will always display the entity thumbnail if one is available.Photoshop APIThe engine exposes the Javascript API for Photoshop CC to Python.The Photoshop API object is exposed as engine.adobe. The examples below show how it is possible to directly manipulate the Photoshop DOM from within Toolkit apps and hooks. The standard Toolkit apps also contain working examples of how to interact with Photoshop documents.ExamplesLoad a file:f = adobe.File('/Path/To/File.jpeg')adobe.app.load(f)Set the ruler units to PIXELS:pixels = adobe.Units.PIXELSadobe.app.preferences.rulerUnits = pixelsExport the current doc for the web with default options:temp_thumb_file = adobe.File(out_path)save_for_web = adobe.ExportType.SAVEFORWEBexport_options = adobe.ExportOptionsSaveForWeb()adobe.app.activeDocument.exportDocument(temp_thumb_file, save_for_web, export_options)Export each layer as a separate file:doc = adobe.app.activeDocumentlayers = doc.artLayerslayers = [layers[i] for i in xrange(layers.length)]original_visibility = [layer.visible for layer in layers]save_for_web = adobe.ExportType.SAVEFORWEBexport_options = adobe.ExportOptionsSaveForWeb()for layer in layers:    layer.visible = Falsefor layer in layers:    layer.visible = True    out_file = adobe.File(&quot;c:/layer.%s.jpg&quot; % str(layer.name))    doc.exportDocument(        out_file,        save_for_web,        export_options,    )    layer.visible = Falsefor (i, layer) in enumerate(layers):    layer.visible = original_visibility[i]Environment variablesTo aid in debugging, there are a set of environment variables that change some of the engine’s default values:SHOTGUN_ADOBE_HEARTBEAT_INTERVAL - The Python heartbeat interval in seconds (default is 1 second). The legacy environment variable SGTK_PHOTOSHOP_HEARTBEAT_INTERVAL is also respected if set.SHOTGUN_ADOBE_HEARTBEAT_TOLERANCE - The number of heartbeat errors before quitting (default is 2). The legacy environment variable SGTK_PHOTOSHOP_HEARTBEAT_TOLERANCE is also respected if set.SHOTGUN_ADOBE_NETWORK_DEBUG - Include additional networking debug messages when logging output. The legacy environment variable SGTK_PHOTOSHOP_NETWORK_DEBUG is also respected if set.SHOTGUN_ADOBE_PYTHON - The path to the Python executable to use when launching the engine. If not set, the system Python is used. If Photoshop is launched from a Python process, like ShotGrid Desktop or via the tk-shell engine, the Python used by that process will be used by the Photoshop integration.Note: Additional environment variables exist in the Adobe Framework. For details, please see thedeveloper documentation.App Developer notes  Because the python process is separate from the Photoshop CC process, there is some work done within the engine to try to make the app windows show above the Photoshop window in as clean a manner as possible. One gotcha with this setup is the default option to use native OS windows for QFileDialog. If you are developing an app for use with this engine, be sureto set the option to not use the native dialog. See an example of this in the tk-multi-pythonconsole app.",
    "url": "/8d461cbe/",
    "relUrl": "/8d461cbe/"
  },
  "177": {
    "id": "177",
    "title": "Shell",
    "content": "ShellThe ShotGrid engine for the shell handles command line interaction and is tightly integrated with the tank command which is distributed as part of the Core API. When you execute the tank command in a terminal, Toolkit launches the engine to handle app execution.For more information about the tank command, please see our Advanced Toolkit Administration documentation.Installation and UpdatesAdding this Engine to the ShotGrid Pipeline ToolkitIf you want to add this engine to Project XYZ, and an environment named asset, execute the following command:&amp;gt; tank Project XYZ install_engine asset tk-shellUpdating to the latest versionIf you already have this item installed in a project and you want to get the latest version, you can run the update command. You can either navigate to the tank command that comes with that specific project, and run it there:&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updatesAlternatively, you can run your studio tank command and specify the project name to tell it which project to run the update check for:&amp;gt; tank Project XYZ updatesCollaboration and EvolutionIf you have access to the ShotGrid Pipeline Toolkit, you also have access to the source code for all apps, engines and frameworks in Github where we store and manage them. Feel free to evolve these items; use them as a base for further independent development, make changes (and submit pull requests back to us!) or simply tinker with them to see how they have been built and how the toolkit works. You can access this code repository at https://github.com/shotgunsoftware/tk-shell.",
    "url": "/2ad59ee8/",
    "relUrl": "/2ad59ee8/"
  },
  "178": {
    "id": "178",
    "title": "ShotGrid Folders",
    "content": "ShotGrid FoldersShotGrid Toolkit has a built in system that handles the creation of standardized directory structures based on a configuration. This makes it easy to quickly produce consistent file system layouts for multiple shots.This App hooks up the file system creation API methods in the Sgtk Core API with ShotGrid. This makes folder creation an easy task; just select a collection of Shots or assets and click the Create Folders action.How it worksSimply select one or more Tasks, Shots or other entities (depending on the configuration). Now select create folders from the action menu. Once the process has completed, you will get a report of how many folders were created.",
    "url": "/134adb0e/",
    "relUrl": "/134adb0e/"
  },
  "179": {
    "id": "179",
    "title": "ShotGrid Launch Folder",
    "content": "ShotGrid Launch FolderThe Launch Folder App is a ShotGrid utility which allows you to jump from ShotGrid into the File System.How it worksThe Launch Folder App allows you to jump from ShotGrid into the File System. You can register it for ShotGrid entity types such as Shots, Assets and Sequences. Once activated, it will appear on the Action menu:You can select a single or multiple entries in ShotGrid and when you click the menu action a standard file browser will be launched (Explorer on Windows, Finder on Mac etc.)",
    "url": "/0c3049eb/",
    "relUrl": "/0c3049eb/"
  },
  "180": {
    "id": "180",
    "title": "ShotGrid Launch Publish",
    "content": "ShotGrid Launch PublishThis app adds an “Open in Associated Application” action to the Published File entity in ShotGrid. This makes it easy to open up an already published file: Just navigate to that file, right click on it and select the action.The app makes it easy to configure different app launch sequences for different files – all this is done inside a hook. It also dispatches image sequences to a viewer (such as RV). Files not recognized by the hook will be dispatched to the os-level app.",
    "url": "/a01dbeb7/",
    "relUrl": "/a01dbeb7/"
  },
  "181": {
    "id": "181",
    "title": "ShotGrid",
    "content": "ShotGridThe ShotGrid engine manages apps that can be launched from within ShotGrid. Sometimes we refer to these Toolkit Apps as Actions. They typically appear as items on menus inside of ShotGrid.Using ShotGrid Pipeline Toolkit ActionsActions are visible on the ShotGrid Home page:They can also be found on the standard ShotGrid context menu, which can be shown by right clickingon an object or a selection:When you click on an action, processing will immediately start. Once the app has completed, a message is typically displayed with some status information, or an error message if things didn’t work.Developing Apps for ShotGridDeveloping apps that run inside of ShotGrid is easy! If you are not familiar with how app development works in general, head over to the Platform documentation and read the introductory material over there. In this section we will just cover the ShotGrid specific aspects of the app development process!As of Core v0.13, you can use all the multi apps with the ShotGrid Engine. Technically speaking there is little difference between the ShotGrid engine and other engines. There are, however, some subtle differences:  You will need to manually install PySide or PyQt into your standard python environment if you want to execute QT based apps in the ShotGrid Engine.  It is possible in the ShotGrid engine to make an action visible to a user depending on which permissions group they belong to. This is useful if you want example want to add a command to the ShotGrid Action menu and you only want admins to see it.A hello-world style ShotGrid App, only visible to admins, would look something like this:from tank.platform import Applicationclass LaunchPublish(Application):        def init_app(self):        &quot;&quot;&quot;        Register menu items with ShotGrid        &quot;&quot;&quot;                params = {            &quot;title&quot;: &quot;Hello, World!&quot;,            &quot;deny_permissions&quot;: [&quot;Artist&quot;],        }                self.engine.register_command(&quot;hello_world_cmd&quot;, self.do_stuff, params)            def do_stuff(self, entity_type, entity_ids):        # this message will be displayed to the user        self.engine.log_info(&quot;Hello, World!&quot;)    Installation and UpdatesAdding this Engine to the ShotGrid Pipeline ToolkitIf you want to add this engine to Project XYZ, and an environment named asset, execute the following command:&amp;gt; tank Project XYZ install_engine asset tk-shotgunUpdating to the latest versionIf you already have this item installed in a project and you want to get the latest version, you can run the update command. You can either navigate to the tank command that comes with that specific project, and run it there:&amp;gt; cd /my_tank_configs/project_xyz&amp;gt; ./tank updatesAlternatively, you can run your studio tank command and specify the project name to tell it which project to run the update check for:&amp;gt; tank Project XYZ updatesCollaboration and EvolutionIf you have access to the ShotGrid Pipeline Toolkit, you also have access to the source code for all apps, engines and frameworks in Github where we store and manage them. Feel free to evolve these items; use them as a base for further independent development, make changes (and submit pull requests back to us!) or simply tinker with them to see how they have been built and how the toolkit works. You can access this code repository at https://github.com/shotgunsoftware/tk-shotgun.Special RequirementsYou need ShotGrid Pipeline Toolkit Core API version v0.19.5 or higher to use this.",
    "url": "/02c2d8aa/",
    "relUrl": "/02c2d8aa/"
  },
  "182": {
    "id": "182",
    "title": "VRED",
    "content": "VREDThe ShotGrid engine for VRED contains a standard platform for integrating ShotGrid Apps into VRED. It is lightweight and straight forward and adds a ShotGrid menu to the VRED menu.Supported Application VersionsThis item has been tested and is known to be working on the following application versions:2020.3 - 2023Please note that it is perfectly possible, even likely, that it will work with more recent releases, however it has not yet been formally tested with these versions.Information for App DevelopersVRED Project ManagementWhenever the ShotGrid engine for VRED starts, it will set the VRED Project to point at a location defined in the settings for this engine. This means that the Project may also change when a new file is opened. The details relating to how the VRED project is set based on a file can be configured in the configuration file, using the template system.Working with tk-vredThis ShotGrid integration supports the VRED product family (Pro &amp;amp; Design).When VRED opens, a ShotGrid menu (the VRED engine) is added to the menu bar.File Open and SaveUse the My Tasks and Assets tabs to see all your assigned tasks and browse for assets. To the right, use these tabs to view all files, working or published files associated with what is selected to the left.PublishPublish: Opens the Publish dialog for publishing the file to ShotGrid, which can then be used by artists downstream. For more information on VRED Publishing, see hereLoaderLoad: Opens the Content Loader app, along with instructional slides explaining how it works.To see more info about VRED loading see hereScene BreakdownScene Breakdown: Opens the Breakdown dialog, which displays a list of “referenced” files (and their links), along with what in the scene is out-of-date or using an alternate version of the PublishedFile.",
    "url": "/9d824e0b/",
    "relUrl": "/9d824e0b/"
  },
  "183": {
    "id": "183",
    "title": "APIs",
    "content": "Toolkit APIsHere you’ll find reference documentation for APIs provided by the Toolkit platform.",
    "url": "/6c5b0b61/",
    "relUrl": "/6c5b0b61/"
  },
  "184": {
    "id": "184",
    "title": "Apps",
    "content": "Toolkit AppsHere you’ll find reference documentation for apps available for the Toolkit platform.",
    "url": "/f8596e35/",
    "relUrl": "/f8596e35/"
  },
  "185": {
    "id": "185",
    "title": "Environment Configuration",
    "content": "Environment Configuration ReferenceIntroductionAt the heart of a Toolkit pipeline is the environment configuration. Within a Toolkit pipeline configuration, the environment configuration files are where you define which Toolkit apps are available within different DCCs and customize the settings for each. This document is a complete reference to the structure and function of the environment configuration files. It covers the Toolkit concept of environments for configuring different workflows within a project, configuration structure, file referencing, and ways to discover what customizations are available.                    Note: While this document acts as a reference to the environment configuration files, you can  see a step-by-step example of editing a configuration setting in the Toolkit Basics Guide on Editing a pipeline configuration.    What is an environment?The ShotGrid Toolkit platform provides a fully customizable set of integrations for commonly used content creation software with which you can build your studio pipeline. Within a project’s configuration, you can specify which software packages have integrations, which specific Toolkit apps are available in each, and your options for each app—building out artists workflows to suit your studio’s needs.But often in studio pipelines, it’s common for different types of artists to have different workflows. As a simple example, for artists working on assets, you might want to make texture painting software such as Mari available, whereas for artists working on shots, you might want to make compositing software such as Nuke available.Beyond just software packages, you might have different settings for the same Toolkit app for different artists. For example, both shot artists and asset artists might use the Workfiles app, but you might want to limit the file navigation to files associated with Shot entities for the former and Asset entities for the latter.To support these different workflows within a project, Toolkit divides its app and engine configurations across environments. An environment contains the integrations and their settings for a set of software packages, all with a certain context in common.In the above example, artists working on assets would be working in an asset step environment, whereas artists working on shots would be working in a shot step environment. Each environment is configured independent of any others, allowing you to have distinct workflows within a project.A note on Toolkit’s Default ConfigurationToolkit gives you a lot of freedom in the way you structure your environment configuration. This document is a reference for all of the options that are available to you, so that you’ll have the necessary knowledge to make choices that best suit the needs of your pipeline.This document will also occasionally cover some of the specific choices we’ve made in the pipeline configuration provided as a starting point, known as the Default Configuration. When you’re ready to customize your pipeline, the first step is to create an editable pipeline configuration for your project.While these choices are only conventions and not hardcoded into the Toolkit workflow, it’s helpful to refer to the Default Configuration as an example for learning what features are available once you start customizing your pipeline and best practices for structuring your own configurations. And, since it’s the suggested starting point for new Toolkit users, it’s helpful to know some of its conventions. We will always distinguish between general features of the Toolkit environment configuration and specific choices in the Default Configuration in this document. For specific details on the Default Configuration’s environment structure, see its README file.File locationsWithin your Pipeline Configuration, the config/ directory contains all the files and folders that are meant to be customized. In config/, you’ll find three sub-directories: cache, core, and env. The env directory holds the environment configuration files, so this document will refer to the files in config/env.In the Default Configuration, you’ll see the following files in config/env/:asset.ymlasset_step.ymlproject.ymlsequence.ymlshot.ymlshot_step.ymlEach of these files corresponds to an environment; having separate files allows each environment to be configured separately.How Toolkit determines the current environmentToolkit uses a core hook called pick_environment to determine which environment file to use at a given time based on the current context. The pick_environment hook’s return values correspond to environment configuration files. For example, if pick_environment returns shot_step, Toolkit will use config/env/shot_step.yml to configure the Toolkit environment.Custom environmentsThe environment configuration files listed above are the ones provided with the Default Configuration. However, some studios may want to employ different or additional environments. For example, a studio might want different configuration settings for every stage in the pipeline—asset_step_rig, asset_step_model, shot_step_anim, shot_step_light, and so on. Fortunately, you can fully customize the available environments.To do so, add the desired environment config files to the config/env directory. Then, override the pick_environment core hook, adding to it the logic that defines when to use your new environments.Basic structureToolkit’s configuration files are written in YAML. The general configuration structure for any bundle (an app, engine, or framework) is as follows:bundle_name:  setting1: value  setting2: value  complex_setting:    sub_setting1: value      Sub_setting2: value  location:     type: descriptor_type    descriptor_setting1: value    descriptor_setting2: valueTo demonstrate this structure, here is a very simple example: an environment in which there is a single engine, with a single app defined within it. The following might be the contents of project.yml in this config:engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4The engines blockEvery environment configuration file starts with an engines block. Nested within it are all of the engines defined for that environment.In our example, only a single engine is defined, tk-maya. It has two settings listed, apps and location.location is a special setting that every bundle requires. The apps setting is a list of all the apps defined for the engine, each with its own settings. In this case, only one app is defined for the engine, tk-multi-workfiles2.The location descriptorEvery Toolkit bundle has a location setting, which we refer to as the bundle’s descriptor. The descriptor tells Toolkit where to find the given bundle, and depending on its type, whether to access it directly or cache it locally. Some examples of locations that a Toolkit bundle can come from are the ShotGrid App Store, a git repository, a path on disk, or a zip file uploaded to your ShotGrid site. Each of these has a corresponding descriptor type, with settings specific to that type. Here again is the descriptor for the tk-maya engine from the example above:    location:        type: app_store        name: tk-maya        version: v0.9.4This is a descriptor of type app_store, which tells Toolkit to get the given bundle from the ShotGrid App Store. Descriptors of type app_store have the settings name and version.In contrast, if you are actively developing a custom bundle—say you’re working on writing a Toolkit app for a specific workflow in your studio, you may want to get it directly from a path on disk. In this case you’d use a descriptor of type dev, which might look like this:    location:        type: dev        path: /path/to/appThe dev descriptor has different settings from the app_store descriptor. While it can take other settings, it can be set up simply with a path setting pointing to where the app lives on disk.See the Descriptor section of the Toolkit Core API docs for details on all available descriptor types and their settings.The apps blockApps are Toolkit’s user tools, and each can run independently of any others. You can choose which apps you want to use based on your pipeline needs, and the apps setting within an engine block is where you define which apps are available in a given engine.Here again is the apps setting from our example above:engines:  tk-maya:    apps:      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8You can see that we have a single app defined, the tk-multi-workfiles2 app. It currently only has a single setting defined:  its descriptor.If you wanted to make other apps available in the tk-maya engine in the project environment, you’d add them here. Let’s add the Panel, tk-multi-shotgunpanel, and the About app, tk-multi-about, to our engine. Our example project.yml file now looks like this:engines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location:        type: app_store        name: tk-maya        version: v0.9.4There are a few important things to note at this time:  The Default Config lists bundles in alphabetical order, and this example follows that convention.  The file is beginning to get long, and we haven’t even added any configuration settings yet.  You might imagine that you’ll be using these same apps in other engines and other environments. For example, you’ll probably have all three of these apps—the Panel, the About app, and the Workfiles app—in different engines (say, Houdini, Nuke, or Photoshop), and in different environments (like asset_step or shot_step). Defining common app settings in many places in your config means that when it comes time to make a change, you’ll have to make the modification in many places.To mitigate the last two issues, Toolkit configurations support includes.IncludesIncludes allow you to reference a section of one file in another file in your configuration. Using includes allows you set a configuration setting in one place, but use it in multiple environments.Includes consist of two parts:  The includes list: a YAML dictionary whose key is includes, and whose value is a list of all files we want to include from.  A reference within your configuration settings, prefixed by the @ symbol, and named to point to the name of the section you want to reference from the included file.To flesh out our above example, you might have a single file where you hold the location descriptors for all of your engines. Let’s put that file in an includes subfolder, and call it engine_locations.yml.The contents of engine_locations.yml would look like this:config/env/includes/engine_locations.yml:engines.tk-maya.location:  type: app_store  name: tk-maya  version: v0.9.4engines.tk-nuke.location:  type: app_store  name: tk-nuke  version: v0.11.5...This file can act as a single source for all engine locations, and all of your environment configurations can reference it. Using this include file, our example now looks like this:config/env/project.yml:includes:- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location:          type: app_store          name: tk-multi-about          version: v0.2.8      tk-multi-shotgunpanel:        location:          type: app_store          name: tk-multi-shotgunpanel          version: v1.6.3      tk-multi-workfiles2:        location:          type: app_store          name: tk-multi-workfiles2          version: v0.11.8    location: @engines.tk-maya.locationYou can see here that the value of the location setting for the tk-maya engine is now a reference to a key from the included YAML file.                    Note: Having all engine locations in a config/env/includes/engine_locations.yml file, as we do in this example, follows the convention of the Default Configuration.    You can add a second include file for app locations, and in fact, the Default Configuration does just that. Let’s expand our example:config/env/includes/app_locations.yml:apps.tk-multi-about.location:  type: app_store  name: tk-multi-about  version: v0.2.8apps.tk-multi-shotgunpanel.location:  type: app_store  name: tk-multi-shotgunpanel  version: v1.6.3apps.tk-multi-workfiles2.location:  type: app_store  name: tk-multi-workfiles2  version: v0.11.8config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.locationWe’re now getting the tk-maya engine’s descriptor from the included engine_locations.yml file, and the descriptor for each app defined for the tk-maya engine from the included app_locations.yml file.                    Note: The Default Configuration employs a second level of nesting that’s not demonstrated here. Every app or engine that has settings beyond just a descriptor has a settings file in includes/settings (e.g., includes/settings/tk-maya.yml, includes/settings/tk-multi-workfiles2.yml). The engine settings files include app settings from the app settings files, and the environment configuration files include from the engine settings files. For details on the Default Configuration’s structure, see its README file. For a detailed walkthrough of modifying a configuration setting, see the Toolkit Basics Guide on Editing a Configuration Setting.    Sparse configurationsEvery Toolkit bundle has a set of available configuration settings, with a default value for each. Toolkit allows sparse configurations: if a configuration setting is not explicitly specified in the environment config files (and/or the files they include), then the default value from the bundle will be used.In our example, we haven’t specified any settings for our apps aside from location. So, in our configuration’s current state, our three apps will use the default values for all of their settings. So, how do we know what configuration settings are available?                    Note: While it’s not a requirement that Toolkit configurations be sparse, the Default Configuration is a sparse configuration.    Discovering available configuration settingsWith sparse configurations, it’s not immediately evident what configuration settings are available for an app simply by looking at your configuration files. To find out what configuration settings an app has available, you have two choices:  App documentation: Each of our apps has its own documentation page, and each of these pages has a “Configuration Options” section. This section lists all of the available configuration settings for the app, with description and default values for each. You can see the Workfiles documentation page as an example. The Apps and Engines page lists the documentation pages for all apps and engines.  The manifest: Every Toolkit bundle includes a file called info.yml in its root directory. We refer to this file as the bundle’s manifest, and it defines all of the available configuration settings for the bundle, with a description and default value for each. You can find the manifest in your own cache of the bundle (e.g., install/app_store/tk-multi-workfiles2/v0.11.8/info.yml within your pipeline configuration), or in Github (here it is for Workfiles as an example).Modifying configuration settingsTo modify a configuration from the default value, simply add it to the proper block, in the proper environment in your Pipeline Configuration, and set its value.Going back to our example, let’s say that we want to configure tk-multi-workfiles2 so that it launches automatically when Maya is launched in the project environment. We can see in the app’s manifest that there is a launch_at_startup setting that controls whether to launch the Workfiles UI at application startup time, and that its default value is False. So, we’ll just add the launch_at_startup option, and set it to True. Our project.yml file now looks like this:config/env/project.yml:includes:- includes/app_locations.yml- includes/engine_locations.ymlengines:  tk-maya:    apps:      tk-multi-about:        location: @apps.tk-multi-about.location      tk-multi-shotgunpanel:        location: @apps.tk-multi-about.shotgunpanel.location      tk-multi-workfiles2:        launch_at_startup: True        location: @apps.tk-multi-workfiles2.location    location: @engines.tk-maya.locationNote that if the settings for tk-multi-workfiles2 were coming from an included file, we’d make this change in that file.Additional resources  Toolkit Basics Guide: Editing a pipeline configuration  Toolkit Basics Guide: Adding an app  Animation pipeline tutorial  Descriptor reference documentation  Webinar: Toolkit administration  File system configuration reference  Default Configuration environment structure README",
    "url": "/c73fcb84/",
    "relUrl": "/c73fcb84/"
  },
  "186": {
    "id": "186",
    "title": "Configuration",
    "content": "Toolkit ConfigurationHere you’ll find reference documentation for configuring the Toolkit platform",
    "url": "/10e8ee51/",
    "relUrl": "/10e8ee51/"
  },
  "187": {
    "id": "187",
    "title": "How can I load different Toolkit Core modules using the ShotGrid Event Daemon?",
    "content": "How can I load different Toolkit Core modules using the shotgunEvent daemon?Huge thanks to Benoit Leveau @ Milk VFX for sharing this.The problemToolkit’s sgtk API is project-centric. In other words, you must import it specifically from the project you wish to use it on.This means that if you use sgtk API operations for multiple projects in a single Python session, then you will run into a problem, as Python only allows a module with the same name to be imported once.If you’re using the ShotGrid event daemon, you may want to perform Toolkit actions inside of a plugin for certain events. This can be tricky since Python only imports a module once. So if your Toolkit Core API for Project A is imported the first time the plugin is run, that is the version that will remain imported for the life of the daemon. This means if the next event dispatched to the plugin is for Project B, you may get an error from Toolkit if you try and instantiate a new Toolkit object for Project B using the core API from Project A.Example of the problem using centralized configs:  Event 123 is for Project A.  The core API for Project A is located at /mnt/toolkit/projectA/install/core/python.  Prepend sys.path with this directory.  import sgtk imports it from this location.  Instantiate a Toolkit instance with this core API and perform some action(s).  Pop the core API directory off of sys.path.  Event 234 is for Project B.  The core API for Project B is located at /mnt/toolkit/projectB/install/core/python.  Prepend sys.path with this directory.  import sgtk won’t do anything since Python sees it’s already imported sgtk.  Instantiate a Toolkit instance with this core API and perform some action(s).  This will cause errors since the Toolkit core is for a different Project (A) than the Project (B) you’re trying to perform actions on.The solutionThe example below shows you how you can import the correct version of the sgtk core in a script or plugin when a different version of the module may have already been imported. The original import is unloaded and removed from memory in Python so the new instance of the module can be imported and used successfully.&quot;&quot;&quot;Example of how to import the correct sgtk core code in a script wherea different instance of the module may have already been imported. Theoriginal import is unloaded and removed from memory in Python so the newinstance of the module can be imported and used successfully.    Thanks to Benoit Leveau @ Milk VFX for sharing this.&quot;&quot;&quot;import osimport sysdef import_sgtk(project):    &quot;&quot;&quot;    Import and return the sgtk module related to a Project.    This will check where the Core API is located on disk (in case it's localized or shared).    It shouldn't be used to get several instances of the sgtk module at different places.    This should be seen as a kind of 'reload(sgtk)' command.    :param project: (str) project name on disk for to import the Toolkit Core API for.    &quot;&quot;&quot;    # where all our pipeline configurations are located    shotgun_base = os.getenv(&quot;SHOTGUN_BASE&quot;, &quot;/mnt/sgtk/configs&quot;)        # delete existing core modules in the environment    for mod in filter(lambda mod: mod.startswith(&quot;tank&quot;) or mod.startswith(&quot;sgtk&quot;), sys.modules):        sys.modules.pop(mod)        del mod    # check which location to use to import the core    python_subfolder = os.path.join(&quot;install&quot;, &quot;core&quot;, &quot;python&quot;)    is_core_localized = os.path.exists(os.path.join(shotgun_base, project, &quot;install&quot;, &quot;core&quot;, &quot;_core_upgrader.py&quot;))    if is_core_localized:        # the core API is located inside the configuration        core_python_path = os.path.join(shotgun_base, project, python_subfolder)    else:        # the core API can still be localized through the share_core/attach_to_core commands        # so look in the core_Linux.cfg file which will give us the proper location (modify this        # to match your primary platform)        core_cfg = os.path.join(shotgun_base, project, &quot;install&quot;, &quot;core&quot;, &quot;core_Linux.cfg&quot;)        if os.path.exists(core_cfg):            core_python_path = os.path.join(open(core_cfg).read(), python_subfolder)        else:            # use the studio default one            # this assumes you have a shared studio core installed.            # See https://developer.shotgridsoftware.com/b12f2510/#how-do-i-share-the-toolkit-core-between-projects            core_python_path = os.path.join(shotgun_base, &quot;studio&quot;, python_subfolder)    # tweak sys.path to add the core API to the beginning so it will be picked up    if sys.path[0] != &quot;&quot;:        sys.path.pop(0)    sys.path = [core_python_path] + sys.path     # Remove the TANK_CURRENT_PC env variable so that it can be populated by the new import    if &quot;TANK_CURRENT_PC&quot; in os.environ:        del os.environ[&quot;TANK_CURRENT_PC&quot;]    # now import the sgtk module, it should be found at the 'core_python_path' location above    import sgtk    return sgtkDistributed ConfigsThe above example is assuming you are using a centralized config, however, things are a bit different if you are using a distributed config. Importing the sgtk API for a distributed config requires you to use the bootstrap API. When using the bootstrap API, you usually start by importing a non-project centric sgtk API and then use that to bootstrap an engine for a given project. The bootstrap process handles the swapping out of the sgtk modules so that at the end of the bootstrap process you have an engine object. If you import sgtk after bootstrap, it will import the relevant sgtk module appropriate to your project. Given the example above of needing to load sgtk for multiple projects, you would need to bootstrap for multiple projects instead. The small catch here is that you can only have one engine running at a time, so you must destroy it before you load another.                    Warning: Bootstrapping a config can be slow, as the process needs to ensure the config is cached locally and all the dependencies are downloaded. Bootstrapping in an Event Daemon plugin could severely affect performance. One potential approach would be to spawn off separate Python instances for each project bootstrap to communicate and send commands from the plugins. This will avoid needing to re-bootstrap a project each time it is needed.    Here is an example:# insert the path to the non project centric sgtk APIsys.path.insert(0,&quot;/path/to/non/project/centric/sgtk&quot;)import sgtksa = sgtk.authentication.ShotgunAuthenticator()# Use the authenticator to create a user object.user = sa.create_script_user(api_script=&quot;SCRIPTNAME&quot;,                            api_key=&quot;SCRIPTKEY&quot;,                            host=&quot;https://SITENAME.shotgunstudio.com&quot;)sgtk.set_authenticated_user(user)mgr = sgtk.bootstrap.ToolkitManager(sg_user=user)mgr.plugin_id = &quot;basic.&quot;engine = mgr.bootstrap_engine(&quot;tk-shell&quot;, entity={&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: 176})# import sgtk again for the newly bootstrapped project, (we don't need to handle setting sys paths)import sgtk# perform any required operations on Project 176 ...# Destroy the engine to allow us to bootstrap into another project/engine.engine.destroy()# now repeat the process for the next project, although we don't need to do the initial non-project centric sgtk import this time.# We can reuse the already import sgtk API to bootstrap the next...                    Note: Centralized configs can be bootstrapped as well, so you don’t need a different method if you’re using a mix.    ",
    "url": "/3520ad2e/",
    "relUrl": "/3520ad2e/"
  },
  "188": {
    "id": "188",
    "title": "Supported OS Versions for Toolkit Engines",
    "content": "Supported OS Versions for Toolkit EnginesHere is a list of Toolkit engine supported operating systems.            Windows      macOS      Linux                  10      10.14+      CentOS 7.4, Rocky 8.5      ",
    "url": "/918daccf/",
    "relUrl": "/918daccf/"
  },
  "189": {
    "id": "189",
    "title": "Engine Supported Versions",
    "content": "Toolkit Engine Supported VersionsHere is a list of the minimum supported application versions on engines available for the Toolkit platform.            Integration      Engine      Supported Versions                        tk-3dsmax      2020 - 2023                    tk-aftereffects      2020 (v17.0) - 2023 (v23.6)                    tk-alias      2020 - 2023                    tk-flame      2020+                    tk-houdini      17.5 - 19.5 Note: Running on Apple Silicon (M1/M2), Houdini is supported for both Native mode and Rosetta mode.                    tk-mari      4.0 - 6.0v2                    tk-maya      2020 - 2024 Note: Apple Silicon (M1/M2) native is supported starting with Maya 2024.                    tk-motionbuilder      2020 - 2024                    tk-nuke      12.0 - 14.0v5                    tk-photoshopcc      2020 (v21.0) - 2023 (v24.7) Note: Apple Silicon (M1/M2) native is not supported, Apple Silicon with Rosetta is supported, learn more here.                    tk-vred      2020.3 - 2023      ",
    "url": "/cc3d2160/",
    "relUrl": "/cc3d2160/"
  },
  "190": {
    "id": "190",
    "title": "Engines",
    "content": "Toolkit EnginesHere you’ll find reference documentation for engines available for the Toolkit platform.",
    "url": "/3a69db47/",
    "relUrl": "/3a69db47/"
  },
  "191": {
    "id": "191",
    "title": "Frameworks",
    "content": "Toolkit FrameworksHere you’ll find reference documentation for frameworks available for the Toolkit platform.",
    "url": "/c6db88dd/",
    "relUrl": "/c6db88dd/"
  },
  "192": {
    "id": "192",
    "title": "An Overview of Toolkit",
    "content": "An Overview of ToolkitAn overview of the different concepts in the ShotGrid Pipeline Toolkit.Here, we cover the main concepts in detail: How apps and Engines work, how Toolkit is launched and manages the current context (work area), how folders are created on disk, etc. We recommend that anyone involved in configuration or development start here.Please note that this document describes functionality only available if you have taken control over a Toolkit configuration. For details, see the  ShotGrid Integrations Admin Guide.IntroductionThis document explains some of the key features in more depth. With explanations, examples and small demos, we show what Toolkit is all about. This document is a good starting point if you want to familiarize yourself with Toolkit or if you want to understand how Toolkit could add value to your studio. After you have read it, you’ll have a good grasp of some of the key concepts and how they work in practice.Below is a brief description of Toolkit (SGTK):  Toolkit is a  Pipeline Toolkit  based on the ShotGrid platform - it makes it easier to write and install tools for a studio.  Toolkit is filesystem based - it helps you organize where things are stored on disk so that what you have on disk is nicely structured.  Toolkit is an assistant - it does not try to take over or abstract the data in your pipeline, but rather is there to provide artists with compelling tools to make finding information easier and avoid making mistakes.  Toolkit is helping you to share work by storing all of its publishes in ShotGrid. Toolkit makes it easy to share updates and work that is going on across a production.In the following sections, we will be looking in depth at the Toolkit and how it works.Projects and ConfigurationsIn Toolkit, everything is project centric. A project typically starts its lifecycle inside of ShotGrid, goes through a bidding and a pre-production phase, and then once it is ready for the content-creation phase Toolkit can be set up for that project.When you set up a new project, you use a template configuration. This is a predefined config containing engines and apps, filesystem configuration, and other settings. If you are just starting with Toolkit, you can use our example configuration as a starting point for your exploration. If you have already been using Toolkit on another project, we suggest that you take that configuration and use that as the starting point for your new project. That way, you will be evolving a studio configuration and it will be refined with each new project. Of course, you can also maintain a studio configuration separately and use this as a template for all new projects.Each configuration defines a number of storage points. For the standard sample configuration, tk-config-default, we define a single storage point called  primary. This means that all your production data will be under a single filesystem project root. You can also set up configs with more than a single file system root. We call these multi-root configurations. Examples of when you might need multi-root configurations include having a separate storage for renders, a separate storage for editorial, etc. Each of these storage points need to exist as a Local File Storage in ShotGrid, which can be set up in the Site Preferences, under the File Management tab.Toolkit will install the actual project configuration in any location you like. Typically this will go into a  software install area on disk and not into the project data area itself.Let your studio configuration evolveWhen you set up a new project, you can base it off of an existing project. Toolkit will then copy the configuration folder from that project to your new project. This means that your new project will get exactly the same versions of apps and engines, the same settings and the same customizations as the project you are basing it on. This can be useful if you want to evolve your pipeline and take advantage of improvements and tweaks that have happened as part of an existing production.Alternatively, you can just take the configuration folder from a project when you are happy with that project’s setup and save it in a central location somewhere. This config can then be used as a studio template and each time you create a new project you can base it off this config. If you want, you can even source control this studio template config using a revision control system, such as git or something similar, and tracking how the pipeline configuration template evolves over time becomes simple and transparent. Whenever you want to update it, just copy the config from one of your projects and commit the changes.For detailed information about configuration management, check out our detailed docs:Managing your project configuration.Each Project has a Pipeline ConfigurationWhenever you set up Toolkit for a project, a pipeline configuration is created. This configuration contains all the settings and files needed for the project. The configuration has a dedicated tank command which you can run in a shell if you want to address the project directly (there is also a global tank command that works with all projects). In ShotGrid, the Pipeline Configuration has been registered as a special Pipeline Configuration Entity to make it easy to keep track of where your project configurations reside on disk.In addition to the master config that is created when the project is set up, you can create additional configurations for a project. This is often useful if you want to make changes to the configuration without affecting everyone on the project. If you want to do this, you can navigate to a pipeline configuration in ShotGrid, right click it and choose to clone it. This will create a new pipeline configuration for a project, based on another one, and using the new configuration you can safely test out a new app without affecting other users.Please note that the main configuration for a project needs to be named Primary. If you rename, modify or delete it, things may not work as expected. The Pipeline Configurations stored in ShotGrid are not intended to be manipulated by hand, but rather through various specific tank administration commands.Example:How to clone a configurationChecking for updatesSimilar to other App stores out there, the Toolkit app store constantly gets new versions for apps and engines. These new versions may contain important bug fixes or interesting new features. Upgrading your apps and engines is completely optional. It is normally a quick process and the upgrade scripts will always prompt you before making any changes. Likewise, it is straightforward to roll back should you have accidentally installed an unsatisfactory version.A single command handles the upgrade process. Simply run the  tank  command located in your project configuration folder and add an  updates  parameter:/software/shotgun/bug_buck_bunny/tank updatesRunning this command with no parameters will check all environments, engines and app. This may take a long time, but you can also run the updater on a subset of your installed apps and engines.General syntax:tank updates [environment_name] [engine_name] [app_name]The special keyword ALL can be used to denote all items in a category.Examples:  Check everything:  tank updates  Check the Shot environment:  tank updates Shot  Check all maya apps in all environments:  tank updates ALL tk-maya  Check all maya apps in the Shot environment:  tank updates Shot tk-maya  Make sure the loader app is up to date everywhere:  tank updates ALL ALL tk-multi-loader  Make sure the loader app is up to date in maya:  tank updates ALL tk-maya tk-multi-loaderIn addition to checking the app store, this script checks all other registered locations too, so it may query your local git, a GitHub repository, a file on disk and the app store, depending on where you have deployed your apps.Please note that a new version of an app may introduce changes to the app configuration. For example, there may be a new feature which requires a new configuration parameter. In that case, the tank upgrade script will prompt you to type in values for these parameters.Checking for updates to the Core APISometimes we release new versions of the Toolkit Core API. A separate command is used to update the Core API. In this case, the command is tank core.Creating folders on diskOnce Toolkit has been set up for your project, you can use it to help you create a consistent folder structure. This folder structure is configured by creating a filesystem template as part of the pipeline configuration on disk. In this folder structure, some of the paths will be dynamic - for example, you may have a folder called asset that represents a ShotGrid Asset entity. These dynamic folders can be connected to ShotGrid queries and many other things.Toolkit provides a number of different dynamic folder types that handle different setups and scenarios. You can use the standard ShotGrid API query syntax when you set up your folder creation, so you could organize your filesystem so that assets with different types end up in different folders on the filesystem.For a detailed walkthrough of how this works, see the admin guide:Administering the ShotGrid Pipeline ToolkitToolkit’s folder creation happens in two passes: a direct pass, which can be run by anyone at any time, and a deferred pass, which is typically run by the artist just before application launch. This deferred pass is completely automatic and can be used to set up application-specific folders and user sandboxes.The Current ContextOnce the filesystem structure has been created, Toolkit knows the relationship between a folder on disk and the ShotGrid object that the folder came from. This is important, because it allows Toolkit to easily associate an object in ShotGrid with a folder or disk, or file, when publishing, loading or resolving paths. It also relates to what we call the context or sometimes the current work area. The context object is part of the Toolkit Core and tracks the current thing that is being worked on. It is a central mechanism when Toolkit resolves filesystem paths.The context can be created either from a ShotGrid object, such as a Task, Asset or Shot, or from a path on disk. When apps are running, they can always access the context, and this makes it easy to construct apps that have no knowledge of the filesystem naming conventions or whether the app is used in an Asset or Shot pipeline. This is all handled by the Toolkit Core API and the context.Filesystem TemplatesThe Toolkit Core contains a system for handling file paths. It is called the Templates System. Since Toolkit is filesystem based, apps will need to resolve file paths whenever they need to read or write data from disk. Apps are filesystem-structure agnostic, meaning that they don’t know how the filesystem is organized. The template system handles all this for them.At the heart of the template system, there is a Templates Configuration File. This file contains all the important filesystem locations for a project. A  Template looks something like this:maya_shot_publish: 'shots/{Shot}/{Step}/pub/{name}.v{version}.ma'It defines a path which contains certain dynamic fields. Each field can be configured with validation and typing, so that, for example, you can define that the {version} field in the template above is an integer padded with three zeros (e.g. 001, 012, 132). Whenever and app needs to write or read something from disk, a template is added to the templates file to describe that location. Since apps often are set up to form a pipeline, the output template of one app (e.g. a publishing app) is often the input template of another app (e.g. a loading app). This is why all of the filesystem locations are kept in a single file.The template API lets you jump between a list of field values and paths:# get a template object from the API&amp;gt;&amp;gt;&amp;gt; template_obj = sgtk.templates[&quot;maya_shot_publish&quot;]&amp;lt;SGTK Template maya_asset_project: shots/{Shot}/{Step}/pub/{name}.v{version}.ma&amp;gt;# we can use the template object to turn a path into a set of fields...&amp;gt;&amp;gt;&amp;gt; path = '/projects/bbb/shots/001_002/comp/pub/main_scene.v003.ma'&amp;gt;&amp;gt;&amp;gt; fields = template_obj.get_fields(path){'Shot': '001_002', 'Step': 'comp', 'name': 'main_scene', 'version': 3}# alternatively, we can take a fields dictionary and make a path&amp;gt;&amp;gt;&amp;gt; template_obj.apply_fields(fields)'/projects/bbb/shots/001_002/comp/pub/main_scene.v003.ma'Note how the above path and template has two different types of fields. The Shot and Step fields are high-level fields with equivalent objects in ShotGrid (a Shot and a Pipeline Step) where the name and the version fields are very specific to this particular type of template. If we wanted to describe a publish path for an Asset rather than a Shot, we would still have a name and a version field, since this is needed for all publishes, regardless of what type of data it is. However, we would not have a Shot and a Step field. Instead, we may have an Asset and a Step field, where the asset field would be associated with an asset in ShotGrid.When we develop an app that does publishing, we obviously don’t want to have a separate app that does Shot publishing and one that does Asset publishing. Instead, we want a single publishing app that can handle any publish scenario, regardless of whether it is a Sequence, Shot, Asset or whatever.This is where the Toolkit Context comes into play. The Toolkit Context allows us to split the template fields into two distinct groups: the Context fields (Shot, Step, Asset, etc) are fields that we want to ensure are resolved outside of the app in such a way that the app’s logic will not have to have code that specifically handles concepts such as Shots and Assets. Instead, the app should only populate the fields that are directly associated with the particular  business logic of the app. In our example of a publish app, the business logic consists of the name and the version fields. As the figure above illustrates, Toolkit therefore splits the field resolution into two distinct phases: some fields are populated by the context and some fields are populated by the business logic inside the app. This way, apps can be designed that are not tied to a particular filesystem layout. We believe this is an important aspect of building good pipeline tools.The App Code that would deal with the path resolve would typically look something like this:# start with an empty fields dictionaryfields = {}# first let the context populate all its fieldsfields.update( self.context.as_template_fields( publish_template_obj ) )# fields is now {'Shot': '001_002', 'Step': 'comp' }# now the app can add its business logicfields[&quot;name&quot;] = &quot;main_scene&quot;fields[&quot;version&quot;] = 234# and finally the app can produce the path it needs in# order to save out the filepath = publish_template_obj.apply_fields(fields)For more details of how you can configure and use the Templates API, see the following:File System Configuration ReferenceCore API ReferenceChoosing which Engines and Apps to runAnother important role that the Toolkit Core plays is in deciding which Apps should be presented to a user. If you are working on character rigging and start up Maya, you probably want a different collection of apps than if you are doing lighting on a shot. Furthermore, the apps can be configured differently depending on how you want them to operate, so a review app for rigging may be generating a turntable, whereas the same review app is doing a playblast using the shot camera when an animator runs it.In order to allow for this flexibility, a Toolkit project configuration contains a collection of environments. An environment is a configuration file that defines a collection of apps and engines and all their configuration parameters.When Toolkit starts up, it needs to decide which environment to initialize. This is done via a piece of Python code called a hook, where you can add your own business logic. The context object is passed into this piece of code and this is often what is used to determine which environment to use.This makes it possible to configure separate collections of apps for different parts of the pipeline. Furthermore, you can also update them independently and even have different supervisors managing them separately.Environments in the Default ConfigurationTo give you a practical example of how environments work and can be structured, let’s take a look at the environments that come with the default configuration:  project.yml - Apps and Engines to run when the context only contains a project.  shot_and_asset.yml - Apps and Engines to run when the context contains a shot or an asset.  shot_step.yml - Apps ane Engines when the context contains a Shot and a Pipeline Step.  asset_step.yml - Apps and Engines when the context contains an Asset and a Pipeline Step.The default config has organized its filesystem based on pipeline steps. This means that under a Shot location, you can find folders for modeling, rigging, etc. Essentially, there is one folder for each pipeline step you work on. Each of these folders have its own work and publish areas on disk. This means that a publish template may look like this:maya_shot_publish: 'sequences/{Sequence}/{Shot}/{Step}/pub/{name}.v{version}.ma'In order to use this template, the context needs to contain both an entity and a Pipeline Step. For Shot 1122, parented under Sequence ABC and pipeline step Modeling, the above template would resolve to  sequences/ABC/1122/Modeling/.... This means that a context that contains a Shot but not a Pipeline Step is not enough to populate the above template. You cannot launch Maya for a Shot-only context and use the above template. In order for it to be functional, a Step is required.This leads us to the environment breakdown shown above. Because the filesystem structure defined in the default configuration is centered around steps, all the main apps need to run in a context which has a step defined. We define two such environments in the default config: the asset_step.yml file and the shot_step.yml file. Each of these files contain engines for a number of DCCs, such as Maya, Nuke, 3dsmax, Motionbuilder, and Photoshop to mention a few. When you launch Maya from a Task inside of ShotGrid, the pick environment hook will choose the shot_step environment, start Maya and load up the Maya app configuration.It can also be useful to launch Maya directly from a Shot object inside of ShotGrid. More importantly, it can be really useful to be able to type in a console tank Shot 1122 launch_maya. This is where the shot and asset environments come in. When you load Maya with a context which contains a Shot or Asset but no Pipeline Step, it will load one of these environments. Since the filesystem structure is all organized per Pipeline Step, it is not really possible to do any loading or publishing if we are missing that information in our context. Maya instead launches with a bare configuration, only containing the Workfiles app. This app lets you choose a Task to work on. Once you have picked a Task, Toolkit switches the context and restarts the engine for you and will load up the shot_step environment with the full range of apps.Similarly, the project environment is a catch-all fallback, also just containing the Workfiles app. This makes it possible to launch Maya from pretty much anywhere inside the project and it will initialize Toolkit in a minimal state, allowing you to jump to a valid work area using the Workfiles app.Configuring AppsEach app has number of configuration parameters that need to be specified. When you install or upgrade an app, Toolkit makes sure that you have specified all the required settings.Simple setting values such as strings or integers are specified directly in the environment config. Templates are different, and since Toolkit wants to keep all templates in a single place, the environment file merely points to templates defined in the templates file. Each app will require different fields to be present in the templates that it uses in its configuration. In our previous example, the publish app was using a template with the fields name and version when creating its output files on disk. The app would therefore have a configuration setting which requires a template containing the fields name and version.If you try to configure the app using a template that has more than the context fields (name and version), the app would not know how to populate these additional fields and would not be able to generate a path from that template. Similarly, if you provided a template that was missing one of the fields it would lead to confusing results; in our case, version numbers would not be written out of the app. Therefore, Toolkit will validate the configuration at startup to make sure that the necessary fields are provided for all templates. Toolkit also supports several ways of using default values and optional fields.For a complete reference, check the following links:Apps and Engines Configuration ReferenceFile System Configuration ReferenceHooksIn addition to app settings using templates, Toolkit also supports a concept called hooks. Hooks are small snippets of Python code, allowing you to customize parts of the app as part of your configuration.Here’s how it works and why it is useful:Apps are powerful because they can be reused across multiple engines and projects. But apps tend to need some small snippets of engine-specific logic. For example, if we are building a loader app which should work both in Nuke and Maya, there will need to be code that handles the actual file load and this code will have to be different in Nuke and Maya. Furthermore, it would be great if it would be possible to use this app with any engine! Different studios may also have different ways to load items into a scene, and someone may need to support a custom Maya reference node where other studios may just do an import.This situation is handled in Toolkit using a hook. The hook is a customizable piece of code. The App comes with a default hook which contains a base level implementation, meaning that the app will work fine right out of the box. However, if you want to customize the behaviour you can copy that hook file into your configuration and Toolkit will use that code instead.Read more about how to work with hooks in the Admin guide.Running from ShotGrid and the ShellOnce Toolkit is installed, you can access it from several primary entry points:  ShotGrid Actions will appear on the right-click menus inside of ShotGrid  Launch icons will appear for the project in the ShotGrid Desktop app  You can use the tank command in a console.  The Toolkit Python API is available both inside applications and in the shell.Running the Toolkit from within ShotGrid is a common way of starting applications and carrying out tasks. ShotGrid will use ShotGrid Desktop to communicate with the Toolkit install that is local on your machine and use a local Python to execute a Toolkit command. This means that you can run local operations such as folder creation right from inside of ShotGrid.You can also access Toolkit from a shell. Each project configuration comes with its own tank command. Simply navigate to your project configuration root and execute the ./tank command from there.Lastly, you can simply add the Toolkit API to the PYTHONPATH environment variable and import it. Using the API is straightforward and if you want to start up Toolkit inside of Maya manually or as part of an existing studio launch system instead of using ShotGrid Desktop, all you need to execute is a couple of simple commands.PublishingWhen you want to share files that you are working on with others, you can publish them. What this means is that a PublishedFile entity is created in ShotGrid which other users can import using Toolkit’s loader app.The details of exactly what this means in terms of the data management (where on disk things are saved, what the file contains, etc) is left to the app doing the actual work. The Toolkit API provides developers with methods to easily create publishes inside of ShotGrid and link these up to the right objects to ensure that ShotGrid can go ahead and push notifications to all the right people. We also provide a default publish app that is meant to be versatile and highly configurable, but this is by no means the only way to implement version control using Toolkit. Because Toolkit is extensible, you could build your own custom version control and publishing system using Toolkit if this is desirable.As a starting point, however, we recommend our Publish App:The Default Multi Publish App.Building Reusable AppsToolkit is not just a collection of apps and engines. It is also a framework that you can use to develop your own tools and technologies! We have included a lot of features to make Toolkit a rich studio development platform. With Toolkit as a foundation, you can focus on the problems at hand rather than building the underlying platform yourself. We have tried to make it easy for developers to build, evaluate and release software without accidentally breaking the pipeline for artists.  The engines ensure that apps can be written in Python and Qt (PySide/PySide2) regardless of the underlying foundation. This means that some engines are very simple, while some engines are more complex depending on their provided APIs. This means that there is a straightforward, consistent way to develop tools for the studio. In our experience, Python and Qt is often found being the development environment studios use and many TDs are familiar with it.  The engine layer also means that apps can be written once and then be deployed in multiple environments. We have developed the standard app suite as Multi Apps, meaning that the same app is used in all engines. There will inevitably be specific code that needs to be tailored to work with the specific API that each DCC application exposes, but this is typically contained in one or more hooks, making it easy to reuse an app. Another consequence of being able to create multi apps like this is that when a new engine is being developed, all the standard apps can be easily configured to work with that new engine.  Via Pipeline Configurations and Cloning, it is easy to create a development sandbox, allowing developers to do work on a production without interfering with the day-to-day production activity. Once the tools are ready to be deployed, the main project configuration can be easily updated and the tool is rolled out to all artists.  Since apps run inside an engine, it is easy to reload them. Instead of having to restart Nuke or Maya every time you want to test a new code change, simply hit the reload button in Toolkit and the latest code is loaded in.For an more extensive introduction to App Development, see the following documents:An Introduction to the Toolkit App Development.The Toolkit API ReferenceApps and Engines Configuration Reference",
    "url": "/e95205a8/",
    "relUrl": "/e95205a8/"
  },
  "193": {
    "id": "193",
    "title": "Pipeline Integrations",
    "content": "Pipeline IntegrationsShotGrid includes integrations that bring the ShotGrid experience into the creative tools artists use every day. Out of the box, you get plugin within artists’ tools that give you the foundation for a basic publish pipeline.These integrations are built on the Toolkit platform, a set of APIs, UIs, and configurations that give studios the tools to build custom workflows.",
    "url": "/3d1cd26d/",
    "relUrl": "/3d1cd26d/"
  },
  "194": {
    "id": "194",
    "title": "Web Traffic Isolation",
    "content": "Web Traffic IsolationThe goal is to set up an AWS PrivateLink to privately access your ShotGrid site.Set up PrivateLink to ShotGrid      Ask ShotGrid support to provide you with the ShotGrid PrivateLink service name for your AWS region.        Update the private VPC CloudFormation stack you created earlier and set ShotGridPrivateServiceName parameter.  Manual steps if needed      Add a new VPC Endpoint in your VPC        For the security group, ShotGrid service only requires the inbound port tcp/443 to be open.  DNS ConfigurationProvide your PrivateLink DNS name to ShotGrid support. We will setup a new private URL for your site that will look like mystudio-staging.priv.shotgunstudio.com.ValidationVerify that your site private URL resolves to IPs in your AWS VPC block.nslookup mystudio-staging.priv.shotgunstudio.comTry to access your test site from inside your office ie https://mystudio-staging.priv.shotgunstudio.comNext StepsSee Fine Tuning to finalize your setup and optimize costs and security.Go to Setup for an overview of the possible next steps.",
    "url": "/d9ef03ce/",
    "relUrl": "/d9ef03ce/"
  },
  "195": {
    "id": "195",
    "title": "Troubleshooting Guide",
    "content": "Troubleshooting GuideA collection of quick answers aimed at troubleshooting issues.General troubleshooting help  Performance troubleshooting  How do I turn on debug logging?  Remote Debugging  Where are my log files?  How do the Toolkit logs work and how do I know which one to look at?  Where is my config?  How to debug Toolkit Apps not loading, showing up, missing in the Menus, ShotGrid Desktop or the AMIs  Why is my context is missing the Task/Step when it exists as part of the filename?  Why and how do I unregister folders?  Can I delete FilesystemLocations on my site instead of unregistering folders?  How can I unregister folders when using a distributed config?Error message guidance  Error: module ‘tank’ has no attribute ‘support_url’  ASCII codec can’t decode byte 0x97 in position 10: ordinal not in range  Configurations does not point to a valid bundle on disk!  Cannot find procedure “MTsetToggleMenuItem”  Could not resolve row id for path!  data_handler_cache error message: ERROR sgtk.env.project.tk-nuke.tk-multi-workfiles2 Failed to create File Open dialog!  Database concurrency problems: The path &amp;lt;PATH&amp;gt; is already associated with ShotGrid entity &amp;lt;ENTITY&amp;gt;  ERROR: App store does not contain an item named my-app  [ERROR] Attempted to communicate without completing encryption handshake.  error Invalid LUT selected : Gamma2.2  [ERROR] [PROXY] Error calling __commands::unreal_engine  [ERROR publish_creation] &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&amp;gt;  Error: ShotGrid tk-maya: An exception was raised from Toolkit  ERROR 18:13:28.365:Hiero(34236): Error! Task type  Exception: Review submission failed. Could not render and submit the review associated sequence.  Errors due to Windows paths too long (&amp;gt;256 characters)  Failed to change work area - Error during execution of MEL script  Failed to create folders: Folder creation aborded  The Frame Server has encountered an error.  ModuleNotFoundError  In Maya, when I print context.task, it is empty “None”  Fixing the SSL: CERTIFICATE_VERIFY_FAILED issues with the Python API  Getting CERTIFICATE_VERIFY_FAILED when using ShotGrid Desktop on a local ShotGrid site  SSLError: [Errno 8] _ssl.c:504: EOF occurred in violation of protocol  [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate  TankInitError: You are loading the Toolkit platform from the pipeline configuration located in  TankError: Cannot resolve template data for context  TankError: Tried to resolve a path from the template  Tk-desktop console silently ignoring errors  SSLHandshakeError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:727)  TankError: Could not create folders on disk. Error reported: Critical! Could not update ShotGrid with folder data.  [WARNING] Storage root primary could not be mapped to a SG local storageSoftware integrations  Recommended way to share/update pipeline configurations between projects?  How can I distributing my pipeline configuration for users working from home  How can I turn a centralized config into a distributed config for some users?  How to compile Qt ui and resource files on Windows  How can I add Toolkit context menu items in the ShotGrid UI?  Why are my Houdini ShotGrid integrations not starting?  I’ve launched Nuke/Maya/etc. from ShotGrid Desktop, but the ShotGrid menu is missing entries  Why does the Nuke integration fail to start when I set the NUKE_PATH environment variable?  Troubleshooting Photoshop integration when two extensions are installed  Why does 3ds Max crashes on startup when using ShotGrid Toolkit?  How do I set a default software version?  Why is the loader app not showing my Alembic publishes?  When Toolkit bootstraps, what order is used to determine the correct PipelineConfiguration entity?  Why do I get two different SG panels in Photoshop?  Photoshop integration panel is stuck loading! “Some thing went wrong”  Desktop is missing software entities, how can I fix this?  Tank.template_from_path() can’t return multiple templates?  How can I procedurally populate a series of shots (an entire sequence) with workfiles for artists?  How can I take control of the userSetup.py when users launch tk-maya?  Tank Command for Dev config?  I want to take action only if an artist is opening an existing publish, not if they’re opening an existing workfile. How can I do this with a hook?  How do I convert white spaces in entity names to underscores and not hyphens during folder creation?Browser integration  I can’t use local file linking and launch Toolkit applications from Chrome  I can’t use local file linking and launch Toolkit applications from Firefox  ShotGrid Desktop / browser integration fails to launch on LinuxCan’t find your answer?For further troublesooting, you can search our community for answers!",
    "url": "/7ef5be1d/",
    "relUrl": "/7ef5be1d/"
  },
  "196": {
    "id": "196",
    "title": "Fine Tuning",
    "content": "Fine TuningCost Management RecommendationsS3 Infrequent AccessWe recommend enabling S3 Infrequent Access to easily reduce costs without impacting performance. For the ShotGrid Cloud hosted offering, we apply a policy for all objects older than one month.With Infrequent Access, objects are stored at a lower cost. However, if they are accessed, it will involve an additional cost. ShotGrid has observed that one month was the right policy to use globally, but you may want to adapt that policy to your studio workflows as needed.Read more about S3 Infrequent Access and other storage classes here.S3 Bucket policyWe recommend you restrict access to your S3 bucket to only your VPC and ShotGrid transcoding services IPs. There is an example policy, replace your_vpc_id and your_s3_bucket by your values.We strongly recommend you test media access and media transcoding in your site right after applying the bucket policy changes to be sure your S3 bucket is still accessible from your VPC and from ShotGrid transcoders.{    &quot;Version&quot;: &quot;2012-10-17&quot;,    &quot;Id&quot;: &quot;Policy1415115909152&quot;,    &quot;Statement&quot;: [        {            &quot;Sid&quot;: &quot;AllowSSLRequestsOnly&quot;,            &quot;Effect&quot;: &quot;Deny&quot;,            &quot;Principal&quot;: &quot;*&quot;,            &quot;Action&quot;: &quot;s3:*&quot;,            &quot;Resource&quot;: [                &quot;arn:aws:s3:::your_s3_bucket&quot;,                &quot;arn:aws:s3:::your_s3_bucket/*&quot;            ],            &quot;Condition&quot;: {                &quot;Bool&quot;: {                    &quot;aws:SecureTransport&quot;: &quot;false&quot;                }            }        },        {            &quot;Sid&quot;: &quot;Access-to-specific-VPC-only and Shotgun transcoder&quot;,            &quot;Effect&quot;: &quot;Deny&quot;,            &quot;Principal&quot;: &quot;*&quot;,            &quot;Action&quot;: &quot;s3:GetObject*&quot;,            &quot;Resource&quot;: &quot;arn:aws:s3:::your_s3_bucket/shotgun/*&quot;,            &quot;Condition&quot;: {                &quot;NotIpAddress&quot;: {                    &quot;aws:SourceIp&quot;: [                        &quot;34.200.155.69/32&quot;,                        &quot;34.224.232.103/32&quot;,                        &quot;34.202.127.170/32&quot;,                        &quot;34.195.16.11/32&quot;,                        &quot;3.234.125.244/32&quot;,                        &quot;3.234.133.244/32&quot;,                        &quot;100.26.115.40/32&quot;,                        &quot;3.224.231.216/32&quot;,                        &quot;54.145.164.228/32&quot;                    ]                },                &quot;StringNotEquals&quot;: {                    &quot;aws:sourceVpc&quot;: [                        &quot;vpc-2fd62a56&quot;,                        &quot;vpc-098e0ff163debc966&quot;,                        &quot;vpc-09441e47c87a28dd4&quot;,                        &quot;your_vpc_id&quot;                    ]                }            }        }    ]}S3 endpoint policyWe recommend setting a VPC endpoint policy on your S3 endpoint to allow access to your S3 bucket only. See here for an example.Application Load Balancer  We recommend you enable deletion protection on the S3 proxy load balancer to prevent accidental deletion.  We recommend you enable access logging on the S3 proxy load balancer to aid in traffic analysis and identification of security issues.Next StepsSee Activation to migrate your production site to use the isolation features.Go to Setup for an overview of the possible next steps.",
    "url": "/26190270/",
    "relUrl": "/26190270/"
  },
  "197": {
    "id": "197",
    "title": "How do I turn on debug logging?",
    "content": "How do I turn on debug logging?Sometimes you want to see more logging data than Toolkit tools output by default. You can enable debug logging to get more verbose log output, and there are a few methods to do so.                    Note: Not sure where to find your log files? Take a look at our Where are my log files? doc.    Enable debugging through ShotGrid DesktopThe easiest way to enable debugging is to toggle it on through the ShotGrid Desktop app. This can be set once you are logged into ShotGrid Desktop: click on your profile picture in the bottom right of the app, and select Advanced -&amp;gt; Toggle Debug Logging. This setting is persistent between sessions, so remember to turn it off when you are finished.It should also be noted that when this is toggled on, apps launched from ShotGrid Desktop, or even the Toolkit commands through the browser integration, will also inherit this debug state.Setting up an environment variablePermanently turning on debug loggingFirst, you will need to set up a new environment variable: TK_DEBUG=1                    Note: We suggest discussing how to set up environment variables with a technical expert at your studio since instructions are platform specific. However, the example below includes setting up an environment variable on a Windows 7 machine.    Example using Windows 7  You can permanently turn on debug logging by navigating to the Windows icon &amp;gt; Control Panel &amp;gt; System &amp;gt; Advanced system settings &amp;gt; Environment Variables… &amp;gt; New…  Variable name: TK_DEBUG  Variable value: 1  Select OKNow, your environment variable is set up properly and debug logging is turned on.                    Note: Make sure to restart Desktop in order for logging to take effect.    If you would like to turn debug logging off, you can either:a. Set the TK_DEBUG environment variable value to 0.b. Delete the TK_DEBUG environment variable.Checking to see if the environment variable is already setTo see if the environment variable has already been set, open a terminal and execute the following command: setThen, search for TK_DEBUG=1.This will ensure that once you launch Desktop, debug logging will be turned on.Temporarily turning on debug loggingIf you would like to use debug logging temporarily for a session instead, you can open a terminal and set debug logging with the following command: set TK_DEBUG=1Then, launch the Desktop through your terminal.                    Note: Once you close ShotGrid Desktop and your terminal, debug logging is no longer turned on.    Advanced configuration debug logging optionsIf you are in an advanced setup, there are a few more options for you. This functionality is only available if you have taken control over a Toolkit configuration.Every engine has a debug_logging setting in the environment file. Turning this on will emit additional debug-level log messages to the default output in your Software (e.g., the script editor in Nuke or Maya). All of the apps running in your engine will emit these debug-level messages so turning this on for the engine will effectively turn it on for all of your apps as well.This does not output any log messages to a file. We are working on a more standard logging framework that will allow this. The exceptions are ShotGrid Desktop and the Photoshop engine, which log output both in a GUI console and to a file.Turning on debug logging for an engine in your softwareAs an example, to turn on debugging output for the Nuke engine in the shot step environment, find the Nuke engine (tk-nuke) section in your environment file and update the setting to debug_logging: true.Edit config/env/shot_step.yml.engines:   ...  ...  tk-nuke:    apps:      ...      ...    compatibility_dialog_min_version: 9    debug_logging: true    favourite_directories: []    location: {name: tk-nuke, type: app_store, version: v0.2.23}    ...   ...Save the file and relaunch Nuke in the shot step environment. You will now see the debug output in the script editor window.                    Note: If debug logging is enabled via any one of the ShotGrid Desktop checkbox, environment variable, or engine configuration setting, debug logging will be output. Additionally, each of these three is modified independently of the others: the checkbox value a persistent app setting, totally independent of the engine setting or environment variable. This means that while the Desktop checkbox may be unchecked, debug logging might still be enabled by way of one of the other methods.    Turning on debug logging for the tank commandIf you’re running the tank command and want to see debug output in your terminal, use the --debug option with the command you’re running and this will turn on debug logging for the command../tank --debug coreDEBUG [10:11:38 617.835998535]:DEBUG [10:11:38 618.768930435]: Running with debug output enabled.DEBUG [10:11:38 618.921995163]:DEBUG [10:11:38 619.092941284]: Core API resides inside a (localized) pipelineconfiguration.DEBUG [10:11:38 619.235992432]: Full command line passed:['/sgtk/software/shotgun/scarlet/install/core/scripts/tank_cmd.py','/sgtk/software/shotgun/scarlet', '--debug', 'core']DEBUG [10:11:38 619.364023209]:DEBUG [10:11:38 619.463920593]:DEBUG [10:11:38 619.575977325]: Code install root:/sgtk/software/shotgun/scarletDEBUG [10:11:38 619.678020477]: Pipeline Config Root:/sgtk/software/shotgun/scarletDEBUG [10:11:38 619.756937027]:DEBUG [10:11:38 619.826078415]:DEBUG [10:11:38 619.905948639]:DEBUG [10:11:38 619.978904724]: Context items:['/sgtk/software/shotgun/scarlet']DEBUG [10:11:38 620.06688118]: Command: coreDEBUG [10:11:38 620.129108429]: Command Arguments: []DEBUG [10:11:38 620.193004608]: Sgtk Pipeline Config Location:/sgtk/software/shotgun/scarletDEBUG [10:11:38 620.270967484]: Location of this script (__file__):/sgtk/software/shotgun/scarlet/install/core/scripts/tank_cmd.pyWelcome to the Shotgun Pipeline Toolkit!For documentation, see https://developer.shotgridsoftware.com/d587be80/?title=Integrations+User+GuideStarting Toolkit for your current path '/sgtk/software/shotgun/scarlet'- The path is not associated with any Shotgun object.- Falling back on default project settings.DEBUG [10:11:39 125.463962555]: Sgtk API and Context resolve complete.DEBUG [10:11:39 126.449108124]: Sgtk API: Sgtk Core v0.15.18, config/sgtk/software/shotgun/scarletDEBUG [10:11:39 126.588106155]: Context: scarlet- Using configuration 'Primary' and Core v0.15.18- Setting the Context to scarlet.DEBUG [10:11:39 129.276990891]: No need to load up the engine for thiscommand.- Running command core...----------------------------------------------------------------------Command: Core----------------------------------------------------------------------Welcome to the ShotGrid Pipeline Toolkit update checker!This script will check if the Toolkit Core API installedin /sgtk/software/shotgun/scarletis up to date.Please note that when you upgrade the core API, you typically affect more thanone project. If you want to test a Core API upgrade in isolation prior torolling it out to multiple projects, we recommend creating a special*localized* pipeline configuration. For more information about this, pleasesee the Toolkit documentation.You are currently running version v0.15.18 of the Shotgun Pipeline ToolkitNo need to update the Toolkit Core API at this time!DEBUG [10:11:39 981.74405098]: Exiting with exit code None",
    "url": "/143e0a94/",
    "relUrl": "/143e0a94/"
  },
  "198": {
    "id": "198",
    "title": "Troubleshooting Photoshop integration when two extensions are installed",
    "content": "Troubleshooting Photoshop integration when two extensions are installedWhat is the problem?With the release of our After Effects integration, there is a common plugin that can be used by all Adobe apps that integrate with ShotGrid. As part of this change, we needed to rename the extension so that we could preserve backward compatibility with our older Photoshop integration and make it possible for studios to cleanly transition to the update.Unfortunately, this also means that it is possible to have two ShotGrid extensions installed as you upgrade:The ShotGrid Adobe Panel is the new one, and should be used when you are using v1.7.0 of the Photoshop integration or newer.How do I fix it?To get rid of the older extension, you can remove it from the Adobe install location in your home directory. The folder for this can be seen in the debug output upon Photoshop launch, and is  OSX: ~/Library/Application Support/Adobe/CEP/extensions/com.sg.basic.ps  Windows: %AppData% Adobe CEP extensions com.sg.basic.psIf you quit Photoshop and remove that directory, then you should have just the one extension on relaunch.                    Note: If you have the Photoshop integration in multiple environments or multiple configurations and there is a mixture of old and new plugins, then the old plugin will return when somebody launches Photoshop with that older integration. It is good to update Photoshop across the board so that you only need to do this cleanup once.    ",
    "url": "/3fd1f835/",
    "relUrl": "/3fd1f835/"
  },
  "199": {
    "id": "199",
    "title": "Unable to get local issuer certificate",
    "content": "[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificateUse CaseUsers experiencing issues uploading and downloading media from Amazon with the Python API on Windows. This issue manifests itself by the Python API raising the following error message:shotgun_api3.shotgun.ShotgunFileDownloadError: Failed to open https://xxx.shotgunstudio.com/file_serve/attachment/xyz&amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1108)&amp;gt;Amazon updated some certificates on their backend. Windows usually refreshes its certificate store when browsing a webpage that requires a new certificate. A standalone Python script running on a computer that doesn’t see regular browsing activity will not retrieve certificate updates, which may cause that computer to be missing quite a few.How to fixIf you have GUI access to the machine that has the issue, simply playing back any media that is currently stored on S3 should update your certificate store. This playback solution only works on Chrome, Internet Explorer, Edge or other Chromium based browsers. This playback solution does not work on Firefox or Safari, as these browser do not use Windows’ standard APIs for certificate validation.For users whom this solution does not work, or if you have a big list of computers to update, like a Deadline render farm, we’re also providing a script that will add the missing certificate to your computer. Here is a link to a script we’ve shared.For users of Powershell on Windows 10 or Powershell 3 on Windows 7, you can run the following script as an administrator on the computer to get the new certificate.$cert_url = &quot;https://www.amazontrust.com/repository/AmazonRootCA1.cer&quot;$cert_file = New-TemporaryFileInvoke-WebRequest -Uri $cert_url -UseBasicParsing -OutFile $cert_file.FullNameImport-Certificate -FilePath $cert_file.FullName -CertStoreLocation Cert: LocalMachine RootIf the command worked, you should see this:   PSParentPath: Microsoft.PowerShell.Security Certificate::LocalMachine RootThumbprint                                Subject----------                                -------8DA7F965EC5EFC37910F1C6E59FDC1CC6A6EDE16  CN=Amazon Root CA 1, O=Amazon, C=USThis will make the certificate available for all user accounts on the computer it is run on. If you don’t have admin access, you can change the last line with:Import-Certificate -FilePath $cert_file.FullName -CertStoreLocation Cert: CurrentUser Rootand the certificate will be added for the current user only.If you’re old school like me and still rock using cmd.exe, you can also use certutil. First, you’ll need to download the certificate from https://www.amazontrust.com/repository/AmazonRootCA1.cer and save it somewhere on your computer.Then launch the command prompt in administrative mode:and execute the following line:certutil -addstore root &amp;lt;path-to-the-cert&amp;gt;This will make the certificate available for all user accounts. If you don’t have admin access, you can add -user to install the certificate for the current user only like thiscertutil -user -addstore root &amp;lt;path-to-the-cert&amp;gt;Related linksSee the full thread in the community",
    "url": "/e9d994eb/",
    "relUrl": "/e9d994eb/"
  },
  "200": {
    "id": "200",
    "title": "How do I uninstall an app or engine?",
    "content": "How do I uninstall an app or engine?You can remove an app or engine by editing your configuration’s environment YAML files, so that the app or engine is no longer present. The environment files allow you to configure apps to only be available in certain contexts or engines instead of removing them entirely.To find out more about editing environment files in general, take a look at this guide.ExampleHere is an example on how to entirely remove the Publish app from our Default Configuration.Apps are added to engines inside the environment settings, so we must remove the Publish app from all engines that its been added to.Removing the App from the enginesEach engine has its own YAML file inside .../env/includes/settings; as the Publish app is included in all engines you will need to modify each engine YAML file. Taking the Maya engine as an example you would open up tk-maya.yml and remove all references to the Publish app.First there is a reference to it in the includes section:.../env/includes/settings/tk-maya.yml L18The app is also being included in the Maya engine when in an Asset Step context:.../env/includes/settings/tk-maya.yml L47As well as a line adding it to the menu favourites:.../env/includes/settings/tk-maya.yml L56Then you have a repeat of these lines under the Shot Step settings:.../env/includes/settings/tk-maya.yml L106.../env/includes/settings/tk-maya.yml L115You would then repeat these steps for all the other engine environment yml files, such as tk-nuke, tk-3dsmaxplus, tk-desktop, and so on.                    Important: At this point you have done enough to stop the app from appearing in the integrations for your users, so this is as far as you need to go. However, if you want to completely remove reference to the app from your configuration for the sake of keeping it clean you would need to complete the remaining steps.    Removing the App settingsAll those engines YAML files were including the tk-multi-publish2.yml settings file. Now that you have removed reference to it in your engine YAML files, you can remove this file entirely.                    Important: If you remove the tk-multi-publish2.yml but still have engine files pointing at it then you will likely get an error along the lines of this:ErrorInclude resolve error in '/configs/my_project/env/./includes/settings/tk-desktop2.yml': './tk-multi-publish2.yml' resolved to '/configs/my_project/env/./includes/settings/./tk-multi-publish2.yml' which does not exist!    Removing the App LocationIn the Default Configuration all the apps store their location descriptor in the …/env/includes/app_locations.yml file. The tk-multi-publish2.yml referenced this so you would need to remove the the descriptor lines.",
    "url": "/86ab39ef/",
    "relUrl": "/86ab39ef/"
  },
  "201": {
    "id": "201",
    "title": "Error calling __commands::unreal_engine",
    "content": "[ERROR] [PROXY] Error calling __commands::unreal_engine]Use case:After setting up the ShotGrid desktop app, now after being able to get UE4 to show in the ShotGrid app, once I try to Launch Unreal I get these messages:2020-06-06 03:22:24,246 [ ERROR] [PROXY] Error calling __commands::unreal_engine_4.24.3((), {}):Traceback (most recent call last):File “C: Users USER0 AppData Roaming Shotgun bundle_cache app_store tk-desktop v2.4.12 python tk_desktop desktop_engine_project_implementation.py”, line 164, in _trigger_callbackcallback(*args, **kwargs)File “C: Users USER0 AppData Roaming Shotgun babilgames p91c38.basic.desktop cfg install core python tank platform engine.py”, line 1084, in callback_wrapperreturn callback(*args, **kwargs)File “C: Users USER0 AppData Roaming Shotgun bundle_cache app_store tk-multi-launchapp v0.10.2 python tk_multi_launchapp base_launcher.py”, line 125, in launch_version*args, **kwargsFile “C: Users USER0 AppData Roaming Shotgun bundle_cache app_store tk-multi-launchapp v0.10.2 python tk_multi_launchapp base_launcher.py”, line 343, in _launch_callback“Could not create folders on disk. Error reported: %s” % errTankError: Could not create folders on disk. Error reported: Could not resolve row id for path! Please contact support! trying to resolve path ‘D: UEProjects SON D: UEProjects SON’. Source data set: [{‘path_cache_row_id’: 2, ‘path’: ‘D: UEProjects SON’, ‘metadata’: {‘root_name’: ‘primary’, ‘type’: ‘project’}, ‘primary’: True, ‘entity’: {‘type’: ‘Project’, ‘id’: 91, ‘name’: ‘SON’}}]What’s causing the error?The path of the UE4’s Project on disk which was D: UEProjects PROJECT_NAME  incorrect.How to fixCreating a new folder for ShotGrid’s settings solves the issue.See the full thread in the community.",
    "url": "/5e456562/",
    "relUrl": "/5e456562/"
  },
  "202": {
    "id": "202",
    "title": "How do I update my Toolkit config programmatically with the API?",
    "content": "How do I update my Toolkit config programmatically with the API?Updating apps, engines, and frameworksIf you want to programmatically update all of the engines, apps, and frameworks to their latest versions, you can do so using the following code:import syssys.path.append(&quot;&amp;lt;path_to_your_config&amp;gt;/install/core/python&quot;)import sgtk# substitute your Project id here or alternatively use sgtk_from_path()tk = sgtk.sgtk_from_entity('Project', 161)c=tk.get_command(&quot;updates&quot;)# setup authenticationif hasattr(sgtk, &quot;set_authenticated_user&quot;):      from tank_vendor.shotgun_authentication import ShotgunAuthenticator     user = ShotgunAuthenticator(sgtk.util.CoreDefaultsManager()).get_default_user()      sgtk.set_authenticated_user(user)# finally, execute the commandc.execute({})                    Caution: This will update all of the engines, apps, and frameworks in this pipeline configuration to the latest version without any further interaction or confirmation. Be sure you’re aware of this before proceeding.    Updating the coreIf you want to update your Project’s core version from a script in order to run it non-interactively, you can do so using the following code:import syssys.path.append(&quot;&amp;lt;path_to_your_config&amp;gt;/install/core/python&quot;)import sgtk# substitute your Project id here or alternatively use sgtk_from_path()tk = sgtk.sgtk_from_entity('Project', 161)c=tk.get_command(&quot;core&quot;)# setup authenticationif hasattr(sgtk, &quot;set_authenticated_user&quot;):     from tank_vendor.shotgun_authentication import ShotgunAuthenticator    user = ShotgunAuthenticator(sgtk.util.CoreDefaultsManager()).get_default_user()     sgtk.set_authenticated_user(user)# finally, execute the commandc.execute({})                    Caution: This will update the Toolkit core to the latest version without any further interaction or confirmation. If the core you are running this from is a shared core, this will update the core version that is used by all projects sharing this core version! Be sure you’re aware of this before proceeding.    See also:  Authentication and login credentials in custom scripts",
    "url": "/4de9c1d6/",
    "relUrl": "/4de9c1d6/"
  },
  "203": {
    "id": "203",
    "title": "How do I update my pipeline configuration core locations?",
    "content": "How do I update my pipeline configuration core locations?How do I update my pipeline configuration to use a local core?If your pipeline configuration has been setup to use a shared Toolkit core, you can essentially undo that process, or “unshare” your core, installing a copy of the Toolkit Core API inside your pipeline configuration using the tank localize command. We refer to this as “localizing” your core.      Open a terminal and navigate to the pipeline configuration you wish to install the Toolkit core into.     $ cd /sgtk/software/shotgun/scarlet            Run the following tank command:     $ ./tank localize ... ... ---------------------------------------------------------------------- Command: Localize ----------------------------------------------------------------------     This will copy the Core API in /sgtk/software/shotgun/studio into the Pipeline configuration /sgtk/software/shotgun/scarlet. Do you want to proceed [yn]        Toolkit will confirm everything before continuing. A copy of the Toolkit core, which your pipeline configuration is currently pointing at, will be copied locally into your pipeline configuration.        Toolkit will now copy all of the apps, engines, and frameworks in use by your pipeline configuration locally into the install folder. It will then copy the Toolkit core and update the configuration files in your pipeline configuration to use the newly installed local Toolkit core.     Copying 59 apps, engines and frameworks... 1/59: Copying tk-multi-workfiles v0.6.15... 2/59: Copying tk-maya v0.4.7... 3/59: Copying tk-nuke-breakdown v0.3.0... 4/59: Copying tk-framework-widget v0.2.2... 5/59: Copying tk-shell v0.4.1... 6/59: Copying tk-multi-launchapp Undefined... 7/59: Copying tk-motionbuilder v0.3.0... 8/59: Copying tk-hiero-openinshotgun v0.1.0... 9/59: Copying tk-multi-workfiles2 v0.7.9... ... ... 59/59: Copying tk-framework-qtwidgets v2.0.1... Localizing Core: /sgtk/software/shotgun/studio/install/core -&amp;gt; /sgtk/software/shotgun/scarlet/install/core Copying Core Configuration Files... The Core API was successfully localized. Localize complete! This pipeline configuration now has an independent API. If you upgrade the API for this configuration (using the 'tank core' command), no other configurations or projects will be affected.                          Note: Your output will vary depending on which apps, engines, and framework versions you have installed.    How do I update my pipeline configuration to use an existing shared core?If you have an existing shared Toolkit core, you can update any existing “localized” pipeline configurations to use the shared core using the tank command.      Open a terminal and navigate to the pipeline configuration you wish to update.     $ cd /sgtk/software/shotgun/scarlet            Next you’ll run the tank attach_to_core command and provide the valid path to the shared core on the current platform.     $ ./tank attach_to_core /sgtk/software/shotgun/studio  ... ... ---------------------------------------------------------------------- Command: Attach to core ---------------------------------------------------------------------- After this command has completed, the configuration will not contain an embedded copy of the core but instead it will be picked up from the following locations:     - Linux: '/mnt/hgfs/sgtk/software/shotgun/studio' - Windows: 'z: sgtk software shotgun studio' - Mac: '/sgtk/software/shotgun/studio' Note for expert users: Prior to executing this command, please ensure that you have no configurations that are using the core embedded in this configuration. Do you want to proceed [yn]        Toolkit will confirm everything before continuing. Since this shared core was already set up for multiple platforms, it shows you the location for each.    If you need to add the location for a new platform, update the config/core/install_location.yml file in the shared core configuration and add the necessary path(s).        Toolkit will now back up the local core API in your pipeline configuration, remove localized core, and add the necessary configurations to point your pipeline configuration at the shared core.     Backing up local core install... Removing core system files from configuration... Creating core proxy... The Core API was successfully processed.         If you decide later you would like to localize the Toolkit core inside your pipeline configuration (i.e., detaching your pipeline configuration from the shared core and using a locally installed version), you can do so using the tank localize command.                      Note: The shared studio core must be an equal or later version than the current pipeline configuration’s core.    How do I share the Toolkit core between Projects?Currently when you set up a project with SG Desktop, the Toolkit core API is “localized”, which means it’s installed inside the pipeline configuration. This means every pipeline configuration is a fully self-contained Toolkit installation. You may prefer to have version of the Toolkit Core API that is shared between projects which can minimize maintenance and ensure all of your projects are using the same core code. We sometimes refer to this as a “shared studio core”.Here’s how to create a new Toolkit Core API configuration that can be shared between different project pipeline configurations.      Open a terminal and navigate to an existing pipeline configuration that contains the Toolkit Core version you wish to share. Once the process is complete, this pipeline configuration will no longer be localized, but will use the newly created shared core.     $ cd /sgtk/software/shotgun/pied_piper            Run the following tank command to copy the Toolkit core to an external location on disk. You need to provide the location this path can be found on all platforms (linux_path, windows_path, mac_path). We recommend using quotes for each path. If you don’t use Toolkit on a particular platform, you can simply specify an empty string &quot;&quot;.     $ ./tank share_core &quot;/mnt/sgtk/software/shotgun/studio&quot; &quot;Z: sgtk software shotgun studio&quot;   &quot;/sgtk/software/shotgun/studio&quot;            You will be shown a summary of the change that is about to be made before Toolkit will proceed.     ---------------------------------------------------------------------- Command: Share core ---------------------------------------------------------------------- This will move the embedded core API in the configuration  '/sgtk/software/shotgun/pied_piper'. After this command has completed, the configuration will not contain an embedded copy of the core but instead it will be picked up from the following locations: - Linux: '/mnt/sgtk/software/shotgun/studio' - Windows: 'Z: sgtk software shotgun studio' - Mac: '/sgtk/software/shotgun/studio' Note for expert users: Prior to executing this command, please ensure that you have no configurations that are using the core embedded in this configuration. Do you want to proceed [yn]            Toolkit will copy the core installation to your new shared location and will update your existing pipeline configuration to point to the new shared core.     Setting up base structure... Copying configuration files... Copying core installation... Backing up local core install... Removing core system files from configuration... Creating core proxy... The Core API was successfully processed.      You can now use this new shared core from other pipeline configurations. In order to update a pipeline configuration to use an existing shared core (like the one you just created), you can use the tank attach_to_core command.",
    "url": "/b12f2510/",
    "relUrl": "/b12f2510/"
  },
  "204": {
    "id": "204",
    "title": "What's the difference between a Version and a PublishedFile?",
    "content": "What’s the difference between a Version and a PublishedFile?A “Publish” represents a file (or an image sequence) or data on disk which can be used inside an application. It could be an exr sequence, an abc, a Maya file, etc. Publishes are represented by the PublishedFile entity in ShotGrid.A “Version” (the Version entity in ShotGrid) is the visual representation of a publish — and is used for review and taking notes. There is a field on the Version entity named Published Files which you can populate with any number of publish records to connect them together. This is how you can keep track of which review Version is associated with a group of publishes. We recommend that you populate this relationship when you publish. Versions are represented by the Version entity in ShotGrid.The ultimate idea is that when you publish, you may generate a collection of files — sometimes different file formats but effectively the same content (a Maya file, an obj, an alembic, etc.) — and these are all different representations of the same thing. They are then associated with a single review Version for previewing the publish data and taking notes.This idea becomes a little bit redundant when the published data is an image sequence. Effectively the image sequence is both the thing you want to review and the thing that will be sent down the pipe. In this case you may have to “double up” and create both a publish and a Version. This allows you to load the published data (e.g. via the Loader app) that represents the Version.",
    "url": "/b867b4b0/",
    "relUrl": "/b867b4b0/"
  },
  "205": {
    "id": "205",
    "title": "Toolkit Webinars",
    "content": "ShotGrid Toolkit WebinarsUpdated: 2020/5/8ShotGrid Toolkit Webinar PlaylistShotGrid Toolkit Webinar Videos1: ShotGrid Toolkit Webinar: Out-of-the-box Integrations (60m)In the first of a new series of Toolkit webinars, Rob Blau, and Manne Öhrström, answer questions about out-of-the-box integrations.2: ShotGrid Toolkit Webinar: Demystifying the New Default Configuration (60m)In this webinar, Josh Tomlinson and Rob Blau cover what has changed (and why) in the new default configuration for Toolkit projects.3: ShotGrid Toolkit Webinar: Customizing Publish Workflows - A Live Demo (60m)In this webinar, Josh Tomlinson gives a step-by-step walkthrough of creating a custom publish workflow in Maya. Learn the constructs of the publish app, how to configure it, and how to write custom hooks for collecting and publishing data.Supplemental MaterialPipeline Tutorial4: ShotGrid Toolkit Webinar: Cloud Configurations and Multi-location Workflows (60m)In this webinar, Manne Ohrstrom explores workflows for studios with artists in multiple locations.Supplemental MaterialDeveloper docs on Toolkit initialization and configuration managementList of Descriptor types that Manne references in the video5: ShotGrid Ecosystem Webinar: REST API (60m)In this webinar, Brandon Ashworth will walk us through a bunch of useful demos, examples, and recipes to show what the REST API is, why it’s important, and how it can be used.Supplemental MaterialREST API reference docs6: ShotGrid Toolkit Webinar: The New Publisher API (35m)The latest Integrations release includes an improved Publish API, which allows you to decouple publish logic from the GUI app and run publishes from your own tools, or even on the render farm. In this webinar, Jean-Francois Boismenu demos how you can use the API to pass a publish item tree from the Publisher UI to a render farm job.Supplemental MaterialGithub repo with configPull Request referenced at 31:00Publish API Documentation7: ShotGrid Toolkit Webinar: After Effects Integration (38m)Adobe After Effects is our latest ShotGrid integration. In this webinar, Rob Blau dives deep into the After Effects integration with a live demo of features and discusses how we refactored the heaving lifting from our Photoshop integration to develop a reusable framework for any Adobe integration.Also, Tannaz Sassooni tours our new developer’s documentation site and shows how we’re making it easier for our users to learn how to integrate with ShotGrid.Supplemental MaterialAfter Effects integration documentationDeveloper documentation portalShotGrid Developer Day PlaylistShotGrid Developer Day VideosAt SIGGRAPH 2018 and 2019, the ShotGrid team presented ShotGrid Developer Day: a series of courses designed to acquaint developers on the many resources available for automating tasks, writing custom apps and more. After SIGGRAPH, we held a series of webinars featuring the content from Developer Day. This playlist contains recordings of those webinars.Full slide decks, code examples and other resources related to this content can be found here for 2019 and here for 2018 .1: SIGGRAPH Developer Day 2019: Introduction to ShotGrid Development (83m)In this webinar, Tannaz Sassooni and Patrick Boucher give an introduction to ShotGrid development, including a discussion on ShotGrid’s entry points for automation, ShotGrid’s Python and REST APIs and how ShotGrid’s APIs automate tasks and data-tracking for studios.0:56 Welcome and orientation3:00 Introduction to ShotGrid Development: A high-level overview of common pipeline needs and how you can use ShotGrid’s APIs and development frameworks to address them. [Tannaz Sassooni]25:59 Introduction to Data Management Using ShotGrid APIs: Dive into ShotGrid’s API using simple Python and REST scripting, as well as frameworks for creating Action Menu Items. [Patrick Boucher]2: SIGGRAPH Developer Day 2019: Advanced ShotGrid Development (78m)In this webinar,  Brandon Ashworth and Manne Öhrström dive into ShotGrid using the event daemon and new webhooks to react to data changes in ShotGrid, and show how to write a simple pipeline tool using ShotGrid Toolkit.0:39 Welcome and orientation2:33 Working with ShotGrid Events [Brandon Ashworth]41:25 Developing a ShotGrid Tool that runs in multiple artist apps [Manne Öhrström]3: SIGGRAPH Developer Day: Toolkit Administration (1h15m)In this webinar,  Josh Tomlinson, Tannaz Sassooni and Phil Scadding demo how to take over integrations and create a custom directory structure and hooks to automate more of the data flow in your studio.0:00 Welcome and Orientation1:04 ShotGrid Toolkit Administration: Learn how to launch common content creation software through our ShotGrid Desktop app and check out how artists can interact with ShotGrid without ever leaving their work session, with our default pipeline integrations. [Phil Scadding]32:41 Introduction to Toolkit Configurations: Master navigating through the Toolkit Pipeline Configuration, learning how to use it to customize your pipeline workflows. [Tannaz Sassooni]56:20 Managing Hooks: Learn to use ShotGrid Toolkit’s extensive set of hooks to add custom logic to your configuration and tailor your Toolkit pipeline to your studio’s needs. [Josh Tomlinson]4: SIGGRAPH Developer Day: Advanced ShotGrid Development (1h15m)Manne Ohrstrom, Jeff Beeland, and Rob Blau demonstrate best practices for source control and cloud-based pipeline deployment, and dive into building apps and using Toolkit’s standard frameworks for rapidly designing UIs and handling data.0:00 Welcome and Orientation2:31 Toolkit platform: Development and deployment patterns: Learn the different ways you can set up and deploy a Toolkit pipeline configation, including workflows for development, version control best practices, and distributing your pipeline configuration to remote users by uploading it to your ShotGrid site. [Manne Ohrstrom]30:23 Toolkit platform: Writing your own App: Walk through writing a simple Toolkit app, utilizing provided APIs and frameworks to rapidly create a powerful UI. [Jeff Beeland]1:02:22 Introduction to Autodesk Forge: Learn about Forge, Autodesk’s series of API-driven cloud services, and how you can use them to extend the ShotGrid experience. [Rob Blau]",
    "url": "/869a6fab/",
    "relUrl": "/869a6fab/"
  },
  "206": {
    "id": "206",
    "title": "VPC / IAM / Security Group",
    "content": "VPC / IAM / Security GroupAmazon Virtual Private Cloud permits users to logically separate virtual networks that host their AWS resources and provides you complete control over access to your AWS network.Within a VPC, security groups act as a basic firewall and control what inbound and outbound connections are permitted to each given resource. For example, a security group can allow inbound HTTPS traffic to a proxy server but block all other inbound traffic.With AWS Identity and Access Management (IAM), access to AWS resources and services can be controlled at a more fine-grained level. For example, IAM can be leveraged to control who or which resources can access S3 buckets used by ShotGrid.All three of the above features are used in the ShotGrid isolation features implementation to ensure that you securely connect your closed VPC to ShotGrid and allow access to the media S3 buckets.",
    "url": "/28430132/",
    "relUrl": "/28430132/"
  },
  "207": {
    "id": "207",
    "title": "Web Traffic Isolation",
    "content": "Web Traffic IsolationCommunication between your client systems and your ShotGrid site will traverse the open Internet by default. Web Traffic Isolation allows you to restrict access to your ShotGrid site from the public Internet entirely and ensure that all traffic transits directly between your AWS VPC and Autodesk’s AWS VPC.ConfigurationA unique VPC endpoint is provided by Autodesk. Access to the endpoint must be configured from your VPC, and the relevant DNS configuration must be completed to allow your client systems to reach the new endpoint.How it worksBy using the provided VPC endpoint, web traffic is isolated from the public Internet completely. All web traffic transits between your AWS VPC and Autodesk’s AWS VPC, rather than the public Internet.CostsThe only cost associated with Web Traffic Isolation are those related to web traffic transiting to/from your AWS VPC. See AWS VPC Pricing for more details.Next StepsSee Web Traffic Isolation for setup instructions.",
    "url": "/57122ae9/",
    "relUrl": "/57122ae9/"
  },
  "208": {
    "id": "208",
    "title": "Webhooks",
    "content": "WebhooksWebhooks allow a service you control to be notified of events that occur in ShotGrid. When you create a webhook, you specify the type of event you are interested in and tell ShotGrid what URL to send data to when it is triggered. Once the relevant event happens in ShotGrid, a payload of data describing the event will be sent to the webhook’s URL. This allows you to build tight integrations with ShotGrid and automate portions of your workflow.In this topic:  What are some examples of how to use Webhooks?          Create a directory structure on disk when an entity is created      Automation of status management        When should Webhooks be used instead of the ShotGrid event daemon?  Which events are available for Webhook subscriptions?          Custom events available for Webhook subscriptions      Excluded events        When do entity lifecycle events occur?  Creating a Webhook          Creating a Webhook from the Webhooks Page      Creating a Webhook from an Event Log      Secret token                  Header format          Why use a secret token?          Signature verification                    Validate SSL certificate      Deliver in Batched Format      Notify when unstable      Filtering by Project and Entity                  Entity lifecycle Events          Custom Events                      Webhook status  Deliveries          Delivery status      Delivery details                  Request Payload                          Example payload              Session UUID                                Response from the Webhook                    Responding to deliveries                  Throttling          Bursts          Webhooks and geographic considerations          Status codes                      Performance          Response Times                  Slow responses and heavy loads                      Acknowledgements          Example headers      What are acknowledgements used for?        Testing Webhooks          Using webhook.site      What are some examples of how to use Webhooks?There are numerous use cases for Webhooks. A few that we think are compelling are outlined in this document, but their uses are by no means limited to these few examples.Create a directory structure on disk when an entity is createdOne workflow that we have seen repeated many times over is the need to create a directory structure on disk when a new entity is created in ShotGrid. Why not go ahead and make sure that a new shot is ready for artist work automatically once it is created in ShotGrid?Automation of status managementWhen your animation team is finished with their work, why not go ahead and change the status of downstream Tasks in the same Shot to indicate that more work is ready to begin? This way, you can automatically notify the assigned artists in different disciplines that everything is ready to go!Another great example of how to automate status management would be to trigger a status change on a Task entity when a new Note is created. This is a good way to indicate to the artist and production teams that a supervisor has requested changes or fixes to the current work after a review session.When should Webhooks be used instead of the ShotGrid event daemon?Webhooks and the ShotGrid event daemon offer similar features, but with a few key differences. The event daemon requires that you run, monitor, and maintain your own service. All of your code must be written in Python, and it allows you to initiate your own connections to ShotGrid. Webhooks, in contrast, answer connections and can be written in any programming language. They can be hosted in a serverless environment, such as AWS Lambda, or can trigger any of the automation platforms available online, such as Zapier and IFTTT. If your use case works with Webhooks, it should be the preferred solution.Which events are available for Webhook subscriptions?Webhooks may be created for Entities that are in use for the SG site. ShotGrid supports Webhooks for two broad event groups:1. Entity type lifecycle events  Events that are created whenever an Entity is created, revived, updated or deleted.  The Entity options for Entity Lifecycle Events are limited to those that are available via API calls.2. Custom events  Events that are typically not related to the lifecycle of an entity, but which are created when an event occurs in the ShotGrid system.  Example: when a user logs in, logs out, or a user performs a data Import or triggers an Action Menu Item.You may retrieve the full list of the Entities available for API access using either the ShotGrid Python API or Rest API.Custom events available for Webhook subscriptions  ClientUser_FailedLogin  ClientUser_Login  ClientUser_Logout  CRS_HumanUser_Thumbnail_Access_By_Client  CRS_PlaylistShare_Create  CRS_PlaylistShare_Revoke  CRS_Preferences_Change  CRS_Version_Media_Download  CRS_Version_Thumbnail_Access_By_Client  SG_RV_Session_Validate_Success  ShotGrid_Invitation  ShotGrid_PAT_Added  ShotGrid_PAT_Exchanged  ShotGrid_PAT_Removed  Shotgun_ActionMenuItem_Triggered  Shotgun_CutSupportDataMigration_data_migration  Shotgun_CutSupportDataMigration_disable_cutversionconnection  Shotgun_CutSupportDataMigration_schema_cleanup  Shotgun_DisplayColumn_Delete  Shotgun_ImportApp_Complete  Shotgun_ImportApp_Failed  Shotgun_ImportApp_Start  Shotgun_NotesApp_Summary_Email  Shotgun_Nsx_Support_Ticket  Shotgun_PageSetting_Change  Shotgun_PermissionRuleSet_ChangeRule  Shotgun_PermissionRuleSet_DeleteRule  Shotgun_PermissionRuleSet_NewRule  Shotgun_Preferences_Change  Shotgun_ProjectConfiguration_Update  Shotgun_Reading_Change  Shotgun_Review_Tools_Version_View  Shotgun_User_FailedLogin  Shotgun_User_Login  Shotgun_User_Logout  Shotgun_User_PasswordChange  Shotgun_ValidationRule_Create  Shotgun_Webhook_Created  Shotgun_Webhook_Deleted  Shotgun_Webhook_UpdatedExcluded eventsWebhooks are not available for some Entities returned by API schema queries (reference Python API, Rest API). Exclusions include:  API Users  Event Log Entries  Connection entities (entities that are used by ShotGrid internally to create relationships between entities). Connection Entities typically include Connection in their name.When do entity lifecycle events occur?ShotGrid supports subscriptions to Entity lifecycle events when Created, Updated, Deleted and Revived.  Create events: generates when a new entity has been created from the Web U, or from an API request  Update events: generates when any field is updated on an entity after initial creation. When subscribed to an update lifecycle event, A Webhook delivery will occur for any update operation on a field after initial creation. A Webhook delivery will not occur when subscribed to a field update for the initial creation operation of that entity  Delete events: generates when an entity is logically deleted (moved to the trash)  Revive events: generates when an entity is logically revived (restored from the trash)Creating a WebhookCreating a Webhook from the Webhooks PageTo get started creating a webhook, go to the Webhooks page.Then, select Create Webhook.                    Note: Access to webhooks is controlled by Show Webhooks under Advanced Permissions. It is enabled by default for Admin and Manager permission roles .    Next, fill out the information required to create your new webhook.Creating a Webhook from an Event LogWhile on an Event Log Entries Page, right-click on an Event Log Entry record and select Create Webhook from event.This will open up and pre-populate the Webhook creation form. Secret tokenAssigning a secret token to a webhook is optional. When provided, any request sent to the webhook URL will be signed using that token. The token value is sent with the request as a header named X-SG-SIGNATURE. The signature is calculated using HMAC with SHA1 and the message signed is the JSON body of the request.Header format&amp;lt;algorithm&amp;gt;=&amp;lt;signature&amp;gt;Why use a secret token?While not strictly required, providing a secret token causes the payload sent to the webhook URL to be signed. This allows the consumer service to verify that the data originated from the source it expects, and that the payload has not been altered in any way during transit.Signature verificationAn example of how to verify the signature of the payload is provided below using Python.&amp;gt;&amp;gt;&amp;gt; import hmac&amp;gt;&amp;gt;&amp;gt; import hashlib&amp;gt;&amp;gt;&amp;gt; body | `&amp;lt;json body&amp;gt;'&amp;gt;&amp;gt;&amp;gt; token | `mytoken'&amp;gt;&amp;gt;&amp;gt; 'sha1=' + hmac.new(token, body, hashlib.sha1).hexdigest()  == 'sha1=32824e0ea4b3f1ae37ba8d67ec40042f3ff02f6c'TrueValidate SSL certificateValidation of SSL certificates is an optional feature that will help ensure the security of any connections made to the webhook’s consumer URL. If turned on, when a delivery is made to the webhook’s URL, ShotGrid will use OpenSSL’s certificate validation routine to verify the certificate.Deliver in Batched FormatRead more about delivering in batched format here.Notify when unstableNotify when unstable allows you to select a person or group to notify when the webhook fails. This setting is optional.Filtering by Project and EntitySelecting specific projects, entities, and fields will minimize traffic to your webhook, which in result will:  Improve performance  Reduce resource costs  Prevent unnecessary backlogs                    Note: Selecting a project limits you to selecting an entity that always belongs to a single project, such as Versions. If you want to select a non-project (or multi-project) entity like Person, you should not select a project. This ensures webhook event filtering does not add performance overhead to entity updates.    Entity lifecycle EventsThese are standard create/revive/update/delete events for entities like Shots, Assets and Tasks.Custom EventsCustom events are more events that can be subscribed to—like Client Review Site activity, User Logins, and Permission changes.Webhook statusA webhook can have one of several different statuses, indicating its health and ability to continue receiving deliveries.            Status      Example      Description                  Active            The webhook is operating in a stable fashion. No deliveries to this webhook’s consumer URL have failed to reach their destination in the past 24 hours.              Unstable            The webhook is operating in an unstable fashion. Some deliveries have failed to reach their destination in the past 24 hours, but not enough to cause ShotGrid to consider the webhook to be dead.              Failed            The webhook is considered to be dead, and no further deliveries will be attempted. This is a result of too many delivery failures in a short period of time, and the system has determined that the webhook should no longer be considered viable. A webhook is considered failed if it has 100 failed deliveries in the past 24 hours.              Disabled            The webhook is in a disabled state, and no further deliveries will be attempted until it is re-enabled.      DeliveriesSelecting a webhook from the Webhooks list will show all of the deliveries that have been made for that webhook dating back as far as seven days.                    Note: Delivery logs older than seven days are removed and are not recoverable.    Delivery statusA delivery status indicates whether it was successfully delivered to the webhook’s URL.Delivery detailsDeliveries can be expanded to show detailed information about the request sent to the webhook URL and the response to that request.Request PayloadThe payload sent to the webhook’s URL contains information describing the event that occurred in ShotGrid and who triggered it. It is provided in JSON format.                    Payload size: The maximum size of a delivery’s payload is 1 megabyte. Any event triggered in ShotGrid that would result in a payload size larger than 1 megabyte will have its new_value and old_value keys removed, and a warning key added that contains a message explaining what happened, why, and how to retrieve the entire event log entry from ShotGrid.    Example payload{  &quot;data&quot;: {    &quot;id&quot;: &quot;11777.3065.0&quot;,    &quot;meta&quot;: {      &quot;type&quot;: &quot;attribute_change&quot;,      &quot;entity_id&quot;: 1246,      &quot;new_value&quot;: &quot;*Add fog and mist with depth&quot;,      &quot;old_value&quot;: &quot;*Add fog and mist.&quot;,      &quot;entity_type&quot;: &quot;Shot&quot;,      &quot;attribute_name&quot;: &quot;description&quot;,      &quot;field_data_type&quot;: &quot;text&quot;    },    &quot;user&quot;: {      &quot;id&quot;: 88,      &quot;type&quot;: &quot;HumanUser&quot;    },    &quot;entity&quot;: {      &quot;id&quot;: 1246,      &quot;type&quot;: &quot;Shot&quot;    },    &quot;project&quot;: {      &quot;id&quot;: 122,      &quot;type&quot;: &quot;Project&quot;    },    &quot;operation&quot;: &quot;update&quot;,    &quot;created_at&quot;: &quot;2022-02-01 20:53:08.523887&quot;,    &quot;event_type&quot;: &quot;Shotgun_Shot_Change&quot;,    &quot;delivery_id&quot;: &quot;3a5de4ee-8f05-4eac-b537-611e845352fc&quot;,    &quot;session_uuid&quot;: &quot;dd6a1d6a-83a0-11ec-8826-0242ac110006&quot;,    &quot;attribute_name&quot;: &quot;description&quot;,    &quot;event_log_entry_id&quot;: 545175  },  &quot;timestamp&quot;: &quot;2022-02-01T20:53:09Z&quot;}Session UUIDProvided as part of the event payload is the session_uuid that triggered the event in ShotGrid. This value can be provided to ShotGrid’s Python API, which will cause any open browser session with that session_uuid to display updates for events generated by the API.Response from the WebhookThe Response tab shows details about your webhook’s response to the delivery.You can see your webhook’s response HTTP headers, body, and the measured response time.A maximum of 100 characters of your webhook’s response body are retained. (As noted above, delivery information is retained for review for 7 days and deleted afterwards.)                    Security best practices: Do not include any secure data in your webhook’s response, and do not return details of system errors in the response.    Responding to deliveriesA webhook consumer service must respond to deliveries in order for the system to consider them successfully delivered.                    Response timeouts: A response must be received within six seconds of delivery to a webhook’s URL, after which the connection will be closed. Failure to respond in time will result in a failed delivery.    Process time is recorded for each delivery and can be viewed in the Response details tab.ThrottlingShotGrid’s delivery infrastructure is optimized to deliver a large number of customer Webhooks and has a number of mechanisms in place to ensure optimal performance and reliability for all our customers. When a Webhook delivery is made, we examine the time that it took for the endpoint to respond. This metric, along with information about the volume of deliveries being processed, is combined to determine whether your Webhook endpoint is performing at a sustainable rate.Your consumer response times to deliveries will impact Webhooks throughput for your site.Each site is allowed 1 minute of response time per minute. If all configured consumer endpoints for a site take the full 6 seconds to respond, Webhooks deliveries for that site will be throttled to 10 per a minute.When a high rate of overall throughput is needed, consumer endpoints should be designed according to the following model:  Receive the request  Spawn another process/thread to handle it the way you want  Answer an acknowledging 200 immediatelyFactors that may contribute to poor performance include:  A poorly configured or under-resourced Webhook consumer endpoint  Delays in processing the delivery before sending a responseBurstsIf your ShotGrid site is being throttled as a result of short bursts of heavy activity, it will return to normal throughput once the burst of event activity has subsided. The performance indicators will provide insight into which of your configured endpoints are not performing well.Webhooks and geographic considerationsThe ShotGrid Webhook delivery infrastructure is hosted in the AWS US-East-1 (N. Virginia) region. Optimization for delivery times may be possible by hosting your webhook endpint in that general location.Status codes            Status      Code      Description                  Success      &amp;lt; 400      The delivery was received and processed successfully.              Error      &amp;gt;= 400      The delivery was received but was not processed successfully.              Redirect      3xx      The delivery was received but should be redirected to another URL.      PerformanceResponse TimesWhen you select a Webhook, you can view the Current response times.Slow responses and heavy loadsSlow response times and heavy loads are indicated with a colored badge on each Webhook. You can also sort Webhooks based on response times.When a Webhook impacted by performance is selected, more information about the impact is visible in a banner.Slow Response  Issue:          This occurs when the average time to receive a response is &amp;gt; 500ms, impacting the Webhook to respond slowly        Solution:          You will need to optimize your infrastructure since individual event processing has exceeded the 500ms threshold for some events.      Heavy Load  Issue:          This occurs when the ratio of time taken to process / event time span (for a set of deliveries) is &amp;gt;10%), impacting the Webhook to consume over 10% of your allocated bandwidth        Solution:          You will need to optimize your infrastructure since the number of events being generated is high relative to the number of events being processed.      Very Heavy Load  Issue:          This occurs when the ratio of time taken to process / event time span (for a set of deliveries) is &amp;gt;50%      This webhook consumes over 50% of your allocated bandwidth        Solution:          You will need to optimize your infrastructure since the number of events being generated is very high relative to the number of events being processed and throttling will initiate when you consume over 100% of your allotted processing bandwidth.      Note:AcknowledgementsA delivery can be updated to include an acknowledgement. When a delivery is made, headers are provided as part of the request. Included in those headers is the ID of the delivery record, stored in the x-sg-delivery-id key. This ID can be used to update the delivery record to include an acknowledgement using the ShotGrid REST API.                    Acknowledgement size: The maximum size allowed for an acknowledgement is 4 kilobytes.    Example headers{  &quot;accept&quot;: &quot;application/json&quot;,  &quot;content-type&quot;: &quot;application/json; charset=utf-8&quot;,  &quot;x-sg-webhook-id&quot;: &quot;30f279a0-42a6-4cf2-bb5e-6fc550d187c8&quot;,  &quot;x-sg-delivery-id&quot;: &quot;dea7a71d-4896-482f-b238-b61820df8b65&quot;,  &quot;x-sg-event-batch-id&quot;: &quot;1&quot;,  &quot;x-sg-event-batch-size&quot;: &quot;4&quot;,  &quot;x-sg-webhook-site-url&quot;: &quot;https://yoursite.shotgunstudio.com/&quot;,  &quot;x-sg-event-batch-index&quot;: &quot;3&quot;}What are acknowledgements used for?Acknowledgements allow for out of band, detailed reporting of success or failure to process a delivery that was successfully received by your webhook’s URL. This creates a separation between the status of receiving the delivery from ShotGrid and the success or failure to process the event associated with that delivery. As a result, successfully-delivered events can contain additional information useful for debugging purposes.A good example would be a webhook triggered on the creation of an Asset entity. If that webhook’s responsibility is to create a directory structure on disk for each new Asset, the webhook’s URL can successfully receive a delivery, but be unable to create the associated directories due to a disk or network outage. Then, it can update the delivery record with a detailed error message stating that the directory structure was not created, and why.Testing WebhooksYou can use any of the freely available webhook URL generators online for testing purposes. These services are specifically intended to be used for testing Webhooks and other types of HTTP requests. This is a great way to get started learning about Webhooks without needing to set up any infrastructure on your own network.Using webhook.siteWe recommend webhook.site. It provides a unique URL that can be copied and pasted into a webhook and will show you deliveries made to that address in real time. The page can be customized to respond to deliveries with a specific status code and body, which means you can test delivery success and failure.The webhook.site service is aggressively rate limited. This means that it is easy to end up in a situation where some deliveries are rejected, resulting in unstable or failed Webhooks. When testing, we recommend that you use a known, controllable project environment rather than live data in production.                    Production data: It is not good to send production event data to publicly available, third party web services! We recommend using test data only when using services like webhook.site to test Webhooks.    ",
    "url": "/3d448f5e/",
    "relUrl": "/3d448f5e/"
  },
  "209": {
    "id": "209",
    "title": "What is the Path Cache? What are Filesystem Locations?",
    "content": "What is the Path Cache? What are Filesystem Locations?The path cache is used by Toolkit to track the associations between folders on disk and entities in ShotGrid. The master cache is stored in ShotGrid using the FilesystemLocation entity type. Each user then has their own version of the path cache stored locally in the Toolkit cache directory on disk, which is synchronized in the background whenever applications are launched or folders are created.Typically, we don’t advise modifying the path cache manually. Our internal processes not only sync your local cache with the FilesystemLocation entities in ShotGrid, but also create event log entries that allow all users’ machines to stay in sync with ShotGrid.There are a couple tank commands that can be used to modify the path cache:  tank unregister_folders removes path cache associations.  tank synchronize_folders forces a sync of the local path cache with ShotGrid.Typically you won’t need to run either of these commands, but in certain circumstances, they can be useful. For example, unregister_folders should be run before renaming or recreating an entity in your project.",
    "url": "/cbbf99a4/",
    "relUrl": "/cbbf99a4/"
  },
  "210": {
    "id": "210",
    "title": "Where are my log files?",
    "content": "Where are my log files?By default, ShotGrid Desktop and Integrations store their log files in the following directory:Mac~/Library/Logs/Shotgun/Windows%APPDATA% Shotgun logs Linux~/.shotgun/logs/Log file names are in the form tk-&amp;lt;ENGINE&amp;gt;.log. Examples include tk-desktop.log or tk-maya.log.If you’ve set the ShotGrid_HOME environment variable to override the user’s cache location, then the log files will be located in: $SHOTGUN_HOME/logs.                    Note: You can also reach this directory from ShotGrid Desktop. Selecting a project, click the down-arrow button to the right of the project name, and choose Open Log Folder.    ",
    "url": "/38c5c024/",
    "relUrl": "/38c5c024/"
  },
  "211": {
    "id": "211",
    "title": "Where is my cache?",
    "content": "Where is my cache?Root Cache LocationToolkit stores some data in a local cache to prevent unnecessary calls to the ShotGrid server. This includes the path cache, bundle cache, and thumbnails. While the default location should work for most users, it is configurable using the cache_location core hook should you need to change it.The default cache root location is:Mac OS X~/Library/Caches/ShotgunWindows%APPDATA% ShotgunLinux~/.shotgunPath CacheThe path cache is located at:&amp;lt;site_name&amp;gt;/p&amp;lt;project_id&amp;gt;c&amp;lt;pipeline_configuration_id&amp;gt;/path_cache.dbBundle CacheDistributed ConfigurationsThe bundle cache is a cached collection of all the applications, engines, and frameworks used across all of the projects on your ShotGrid site. The bundle cache for distributed configs is stored in the following location:Mac:~/Library/Caches/Shotgun/bundle_cacheWindows:%APPDATA% Shotgun bundle_cacheLinux:~/.shotgun/bundle_cache                    Note: You can override these locations with the SHOTGUN_BUNDLE_CACHE_PATH environment variable, so specific implementations may vary.    Centralized ConfigurationsThe bundle cache for centralized configs are located inside the centralized configuration....{project configuration}/install/If your configuration uses a shared core, then this will be located inside your shared core’s install folder instead.ThumbnailsThumbnails used by Toolkit apps (like the Loader) are stored in the local Toolkit cache. They are stored per Project, Pipeline Configuration, and App (as needed). The structure beneath the root cache directory is as follows:&amp;lt;site_name&amp;gt;/p&amp;lt;project_id&amp;gt;c&amp;lt;pipeline_configuration_id&amp;gt;/&amp;lt;app_or_framework_name&amp;gt;/thumbs/",
    "url": "/7c9867c0/",
    "relUrl": "/7c9867c0/"
  },
  "212": {
    "id": "212",
    "title": "Workflow",
    "content": "WorkflowA collection of related quick answers based around Toolkit workflows.  What’s the difference between a Version and a PublishedFile?",
    "url": "/8396394b/",
    "relUrl": "/8396394b/"
  },
  "213": {
    "id": "213",
    "title": "Workflows",
    "content": "WorkflowsThe customizations in ShotGrid’s pipeline integrations allow you to use the tools to create a variety of workflows: from feature animation to episodic workflows, from visual effects to games.This section contains resources for building specific workflows.",
    "url": "/f5a4341f/",
    "relUrl": "/f5a4341f/"
  }
}
